<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>慕雪的寒舍</title>
  
  <subtitle>雪下了一夜</subtitle>
  <link href="https://blog.musnow.top/atom.xml" rel="self"/>
  
  <link href="https://blog.musnow.top/"/>
  <updated>2023-12-13T09:52:14.000Z</updated>
  <id>https://blog.musnow.top/</id>
  
  <author>
    <name>慕雪年华</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>【MySQL】wsl的ubuntu中无法systemctl启动mariadb（已解决）</title>
    <link href="https://blog.musnow.top/posts/1382619221/"/>
    <id>https://blog.musnow.top/posts/1382619221/</id>
    <published>2023-12-13T09:52:14.000Z</published>
    <updated>2023-12-13T09:52:14.000Z</updated>
    
    <content type="html"><![CDATA[<p>这是GPT的答案，实测有效。</p><p>如果您在启动 MariaDB 时遇到 <code>&quot;Failed to start mariadb.service: Interactive authentication required&quot; </code>错误，这是因为在 Ubuntu 22.04 上默认启用了 systemd 的用户会话限制，需要进行一些额外的步骤来解决该问题。以下是解决方法：</p><p>打开终端，并使用以下命令编辑 MariaDB 的服务文件：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo nano /lib/systemd/system/mariadb.service</span><br></pre></td></tr></table></figure><p>在文件的 <code>[Service]</code> 部分中添加一个新的行，内容如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[Service]</span><br><span class="line">...</span><br><span class="line">...</span><br><span class="line">ExecStartPre=/bin/sh -c <span class="string">&#x27;touch /etc/mysql/mariadb.conf.d/.interactive&#x27;</span></span><br></pre></td></tr></table></figure><p>确保在 <code>[Service]</code> 部分内的其他行之后添加此行。</p><p>保存并关闭文件（在 Nano 编辑器中按 Ctrl+X，然后按 Y 确认保存）。</p><p>运行以下命令重新加载 systemd 配置：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo systemctl daemon-reload</span><br></pre></td></tr></table></figure><p>现在，您可以启动 MariaDB 服务：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo systemctl start mariadb</span><br></pre></td></tr></table></figure><p>这次启动应该没有出现 “Interactive authentication required” 错误。</p><p>最后，您可以设置 MariaDB 在系统启动时自动启动：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo systemctl enable mariadb</span><br></pre></td></tr></table></figure><p>现在，您应该能够成功启动和运行 MariaDB 服务了。如果您仍然遇到问题，请确保按照上述步骤操作，并仔细检查所做的更改是否正确。</p>]]></content>
    
    
    <summary type="html">wsl的ubuntu中无法systemctl启动mariadb问题解决</summary>
    
    
    
    <category term="学习sql" scheme="https://blog.musnow.top/categories/%E5%AD%A6%E4%B9%A0sql/"/>
    
    
    <category term="Linux" scheme="https://blog.musnow.top/tags/Linux/"/>
    
    <category term="mysql" scheme="https://blog.musnow.top/tags/mysql/"/>
    
  </entry>
  
  <entry>
    <title>【Linux】wsl虚拟机时间和实际时间不符合</title>
    <link href="https://blog.musnow.top/posts/1339169411/"/>
    <id>https://blog.musnow.top/posts/1339169411/</id>
    <published>2023-12-12T01:30:55.000Z</published>
    <updated>2023-12-12T01:31:55.000Z</updated>
    
    <content type="html"><![CDATA[<p>偶然遇到了这个问题，触发原因是电脑在开启wsl的情况下进入了<code>休眠</code>模式，且在无网络情况下几天不使用。</p><p>然后开启wsl，发现<code>git log</code>显示最新commit的提交时间是明天，给我吓一跳，然后才发现原来是wsl里面的时间不对。</p><p>Linux下看时间的命令是<code>date</code>，本文写于12月12日，但wsl中的时间是12月10日，肯定是不对。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; date</span><br><span class="line">Tue Dec 10 09:51:29 AM CST 2023</span><br></pre></td></tr></table></figure><p>在wsl内部使用如下命令进行时间同步</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo hwclock -s</span><br></pre></td></tr></table></figure><p>执行后，在windows的命令行里面执行如下命令，重启wsl子系统。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wsl --shutdown</span><br></pre></td></tr></table></figure><p>再在wsl里面执行<code>date</code>命令，时间正确。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; date</span><br><span class="line">Tue Dec 12 09:53:21 AM CST 2023</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">wsl虚拟机时间和实际时间不符合</summary>
    
    
    
    <category term="玩上Linux" scheme="https://blog.musnow.top/categories/%E7%8E%A9%E4%B8%8ALinux/"/>
    
    
    <category term="Linux" scheme="https://blog.musnow.top/tags/Linux/"/>
    
    <category term="虚拟机" scheme="https://blog.musnow.top/tags/%E8%99%9A%E6%8B%9F%E6%9C%BA/"/>
    
  </entry>
  
  <entry>
    <title>【Hexo】在中英文之间添加空格</title>
    <link href="https://blog.musnow.top/posts/3894841472/"/>
    <id>https://blog.musnow.top/posts/3894841472/</id>
    <published>2023-12-10T07:32:14.000Z</published>
    <updated>2023-12-10T07:32:14.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="说明和插件安装"><a href="#说明和插件安装" class="headerlink" title="说明和插件安装"></a>说明和插件安装</h1><p>如题，中英文添加空格是比较规范的写法， 但是我个人实在是懒，每次都要这么弄太累了。想找找hexo有没有对应的插件，还是有的</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-filter-auto-spacing --save</span><br></pre></td></tr></table></figure><p>安装了之后，在hexo的<code>_config.yml</code>里面添加配置项</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># hexo 中英文之间自动加空格</span><br><span class="line"># npm install hexo-filter-auto-spacing --save</span><br><span class="line">auto_spacing:</span><br><span class="line">  enable: true</span><br></pre></td></tr></table></figure><p>随后<code>hexo s</code>就能看到插件启用后的结果了</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2023/12/bc23322af55db5caac57603bdc3df125.png" alt="image-20231210153203131"></p><p>请注意，该插件仓库 <a href="https://github.com/hexojs/hexo-filter-auto-spacing">https://github.com/hexojs/hexo-filter-auto-spacing</a> 已经被设置为公共归档，且最后一次代码提交是<strong>2022年6月</strong>。</p><p>2023年12月10日实测该插件依旧有用，但不保证hexo更新后依旧有效。慕雪使用的hexo和主题版本如下。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hexo 6.2.0</span><br><span class="line">hexo-butterfly 4.9.0</span><br></pre></td></tr></table></figure><p>暂时没有搜到其他仍在更新的插件。</p><h1 id="buffterfly主题自带配置"><a href="#buffterfly主题自带配置" class="headerlink" title="buffterfly主题自带配置"></a>buffterfly主题自带配置</h1><p>感谢评论区老哥的提醒，buffterfly主题其实<strong>自带</strong>了这个配置项 <a href="https://butterfly.js.org/posts/ceeb73f/#Pangu">https://butterfly.js.org/posts/ceeb73f/#Pangu</a></p><p>使用如下命令<strong>卸载</strong>上方提到的插件。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm uninstall hexo-filter-auto-spacing --save</span><br></pre></td></tr></table></figure><p>在hexo-butterfly主题中<code>pangu</code>配置项就是中英文之间添加空格的配置。</p><p>其中site是对全站生效，post是只对文章生效（对其他页面不生效）</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># https://github.com/vinta/pangu.js</span></span><br><span class="line"><span class="comment"># Insert a space between Chinese character and English character (中英文之間添加空格)</span></span><br><span class="line"><span class="attr">pangu:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">false</span></span><br><span class="line">  <span class="attr">field:</span> <span class="string">site</span> <span class="comment"># site/post</span></span><br></pre></td></tr></table></figure><p>将enable改成true即可启用，效果也很好，不仅中英文之间会添加空格，数字和中文之间也添加了空格。完美啦！</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2023/12/1ffcfb9e601a003fd9e246a31d833e15.png" alt="image-20231210213203331"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;说明和插件安装&quot;&gt;&lt;a href=&quot;#说明和插件安装&quot; class=&quot;headerlink&quot; title=&quot;说明和插件安装&quot;&gt;&lt;/a&gt;说明和插件安装&lt;/h1&gt;&lt;p&gt;如题，中英文添加空格是比较规范的写法， 但是我个人实在是懒，每次都要这么弄太累了。想找找hexo有没</summary>
      
    
    
    
    <category term="差生文具多" scheme="https://blog.musnow.top/categories/%E5%B7%AE%E7%94%9F%E6%96%87%E5%85%B7%E5%A4%9A/"/>
    
    
    <category term="Hexo" scheme="https://blog.musnow.top/tags/Hexo/"/>
    
  </entry>
  
  <entry>
    <title>【Nginx】NGINX 配置避免 IP 访问时证书暴露域名</title>
    <link href="https://blog.musnow.top/posts/3528013149/"/>
    <id>https://blog.musnow.top/posts/3528013149/</id>
    <published>2023-12-09T09:12:55.000Z</published>
    <updated>2023-12-09T10:12:55.000Z</updated>
    
    <content type="html"><![CDATA[<p>本文转载自：<a href="https://zinglix.xyz/2021/10/04/nginx-ssl-reject-handshake/">https://zinglix.xyz/2021/10/04/nginx-ssl-reject-handshake/</a></p><h1 id="原文"><a href="#原文" class="headerlink" title="原文"></a>原文</h1><h2 id="TL-DR"><a href="#TL-DR" class="headerlink" title="TL;DR"></a>TL;DR</h2><p>NGINX 配置避免 IP 访问时证书暴露域名</p><p>利用 <code>NGINX 1.19.4</code> 后的新特性 <code>ssl_reject_handshake on;</code>，将其置于默认访问时配置中，IP 访问时会终止 TLS 握手，也就不会暴露域名了。</p><p>使用如下命令查看你的nginx版本</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># nginx -v</span><br><span class="line">nginx version: nginx/1.20.1</span><br></pre></td></tr></table></figure><h2 id="细说"><a href="#细说" class="headerlink" title="细说"></a>细说</h2><p>CDN 是建站时常用的工具，在自己的主机外面套一层 CDN 是常见操作，一般这样认为自己的主机就安全了，有人来攻击也会先到 CDN 服务器，攻击者根本无法获取到自己主机的 IP，但事实真的是这样吗？</p><p>我们先来看看一般配置后会出现什么问题。</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">    <span class="attribute">listen</span> <span class="number">80</span> default_server;</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Redirect all HTTP requests to HTTPS.</span></span><br><span class="line">    <span class="attribute">return</span> <span class="number">301</span> https://<span class="variable">$host</span><span class="variable">$request_uri</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">    <span class="attribute">listen</span> <span class="number">443</span> default_server;</span><br><span class="line">    <span class="attribute">server_name</span> _;</span><br><span class="line">    <span class="attribute">include</span> conf.d/ssl.config;</span><br><span class="line">    <span class="attribute">return</span> <span class="number">444</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面是一个很常用的 NGINX 配置，HTTP 访问全部重定向到 HTTPS 的 443 端口上，没有配置过的域名返回 444 终止连接。</p><p>好了，现在尝试用 IP 和 HTTPS 访问你的网站，你应该能够看到预想中访问失败、证书无效等连接失败的提示。</p><p><strong>但是！</strong>注意下浏览器左上角提示的不安全，点开查看证书信息，你就会发现你的域名其实随着证书发送了过来。此时如果你是攻击者，那么其实就可以知道该域名背后的源主机 IP 就是这个。</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2023/12/035ad572d3638bb917c07e53e24c9575.png"></p><p>上图即为用 IP 访问后，依旧能看到证书内容。这是因为返回 444 是 HTTP 层面的事情，意味着到达这一步下层的 TLS 握手已经完成。证书不被信任是一回事，但说明已经拿到了服务器的证书。</p><p>CDN 确实避免了直接 DNS 查询暴露 IP 的问题，但攻击者通过扫描全网 IP，用上述方式依旧可以知道每个 IP 对应的域名是什么，这也是为什么很多站长用了 CDN 后并且反复更换 IP 却依旧被攻击者迅速找到 IP 的原因。</p><blockquote><p><a href="https://search.censys.io/">Censys</a> 就一直在干这件事，全网扫描 IP 并找到其对应的域名</p></blockquote><h2 id="那该怎么办呢？"><a href="#那该怎么办呢？" class="headerlink" title="那该怎么办呢？"></a>那该怎么办呢？</h2><p>问题根源出在 client 在 TLS 握手时发送了 ClientHello 后，NGINX 在 ServerHello 中带着含有域名的默认证书返回了，因为 NGINX 期望可以完成握手，这可能可以算是 NGINX 的一个缺陷。</p><blockquote><p>如果你不熟悉 TLS 握手流程，那么可以看看 <a href="https://zinglix.xyz/2019/05/07/tls-handshake/">这篇文章</a></p></blockquote><h3 id="笨办法"><a href="#笨办法" class="headerlink" title="笨办法"></a>笨办法</h3><p>既然 NGINX 默认提供了带有域名的证书，那么想不暴露也很简单，提供一个不含有正确域名的证书即可。</p><p>NGINX 设置中 HTTPS 访问如果没有设置证书，那么就会报错。但反正 IP 访问也不需要提供服务，那么直接自签一个 IP 证书，或者随便一个域名的证书都可。当然，如果能搞定合法的 IP 证书也不是不行。</p><p>搞定证书后，添加一个配置，让 IP 访问返回错误证书就完事了。</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">    <span class="attribute">listen</span> <span class="number">443</span> ssl default_server;</span><br><span class="line">    <span class="attribute">server_name</span> your_ip;</span><br><span class="line"></span><br><span class="line">    <span class="attribute">ssl_certificate</span>    xxxx.pem;</span><br><span class="line">    // <span class="attribute">and</span> more ssl config ...</span><br><span class="line"></span><br><span class="line">    return <span class="number">444</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="好方法"><a href="#好方法" class="headerlink" title="好方法"></a>好方法</h3><p>这种方法还得自己搞个证书，如果服务器多每个都得这么搞也挺麻烦的，好在这个问题 NGINX 这已经有了很完美的解决方案。</p><p>ClientHello 中是带着 SNI 的，所以其实握手阶段是可以知道访问的域名是否合法的，NGINX 1.19.4 中添加了一个新的配置项 <code>ssl_reject_handshake</code> 用于拒绝握手，也就不会提供证书。</p><p>使用方法也很简单，将原本默认配置中的 <code>return 444</code> 替换成 <code>ssl_reject_handshake on</code> 即可。</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">    <span class="attribute">listen</span> <span class="number">443</span> default_server;</span><br><span class="line">    <span class="attribute">server_name</span> _;</span><br><span class="line">    <span class="attribute">include</span> conf.d/ssl.config;</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 不用返回 444 了，直接拒绝握手</span></span><br><span class="line">    <span class="attribute">ssl_reject_handshake</span> <span class="literal">on</span>;</span><br><span class="line">    <span class="comment"># return 444;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>配置后，再尝试 IP 访问，会发现浏览器报了 <code>ERR_SSL_UNRECOGNIZED_NAME_ALERT</code> 的错误，也看不到证书信息，目标达成！</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2023/12/18ba4a8ac5a7c8d5400ecf4a2a6bb392.png"></p><h2 id="其实还没完"><a href="#其实还没完" class="headerlink" title="其实还没完"></a>其实还没完</h2><p>上述方法是通过 ClientHello 中的 SNI 确定访问是否合法的，那如果 SNI 就是正确的域名呢？</p><p>这种场景发生于攻击者已经确定要攻击某个域名，那么他就可以将带着该域名的握手信息遍历所有 IP，握手成功就找到，这样访问其实与正常访问并无区别，<strong>唯一解决方法</strong>就是白名单只允许 CDN 服务器访问。</p><blockquote><p>例如攻击者用 hosts 直接硬写 IP，<strong>将域名强行指向某个 IP</strong></p><p>或者用这种方式 <code>curl https://example.com --resolve &#39;example.com:443:172.17.54.18&#39;</code></p></blockquote><p>如下，在 nginx 里面的 location 配置添加上 allow 的 IP 段，只允许 CDN 运营商的 IP 访问你的服务，就能避免绕过 CDN 造成的攻击</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">location</span> / &#123;</span><br><span class="line">    <span class="attribute">allow</span>   <span class="number">172.1.2.0</span>/<span class="number">24</span>; <span class="comment"># 允许CDN运营商的IP</span></span><br><span class="line">    <span class="attribute">allow</span>   <span class="number">1.2.3.4</span>/<span class="number">32</span>;</span><br><span class="line">    <span class="attribute">deny</span>    all; <span class="comment"># 阻止其他任何IP</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述 IP 段只能向 CDN 服务提供商询问，一般文档中都是有相关信息的。</p><h1 id="慕雪的测试"><a href="#慕雪的测试" class="headerlink" title="慕雪的测试"></a>慕雪的测试</h1><p>上面这篇文章我第一次看的时候还没有理解他说的是什么内容。后来测试了一下，明白了。</p><h2 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h2><p>以我的服务器举例，我是<code>centos 7.2</code>的服务器，直接用yum安装的nginx，版本<code>nginx/1.20.1</code>，配置路径是<code>/etc/nginx</code>；</p><p>在默认情况下，你会有个<code>nginx.conf</code>，和<code>/etc/nginx/conf.d</code>里面的用户配置文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">/etc/nginx</span><br><span class="line">- nginx.conf</span><br><span class="line">- conf.d</span><br><span class="line">- server1.conf</span><br><span class="line">- server2.conf</span><br></pre></td></tr></table></figure><p>在<code>nginx.conf</code>里面除了加载用户配置文件，还会有一个默认的server，指向一个<strong>静态文件路径</strong>。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"># 用户配置文件</span><br><span class="line">   include /etc/nginx/conf.d/*.conf;</span><br><span class="line"></span><br><span class="line">   server &#123;</span><br><span class="line">       listen       80;</span><br><span class="line">       listen       [::]:80;</span><br><span class="line">       server_name  _;</span><br><span class="line">       root         /usr/share/nginx/html; # 默认的静态文件路径</span><br><span class="line"></span><br><span class="line">       # Load configuration files for the default server block.</span><br><span class="line">       include /etc/nginx/default.d/*.conf;</span><br><span class="line"></span><br><span class="line">       error_page 404 /404.html;</span><br><span class="line">       location = /404.html &#123;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       error_page 500 502 503 504 /50x.html;</span><br><span class="line">       location = /50x.html &#123;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>在我的服务器上，这个路径里面是如下内容</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@bt-7274:/etc/nginx]# ls /usr/share/nginx/html</span><br><span class="line">404.html  50x.html  en-US  icons  img  index.html  nginx-logo.png  poweredby.png</span><br></pre></td></tr></table></figure><p>此时直接在浏览器访问你的ip，会展示这个默认路径里面的<code>index.html</code>，是centos的一个介绍页面。</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2023/12/03207321f1c2ee5a4f77f22d55746121.png" alt="image-20231209173337849"></p><p>但是，这并不代表你当前没有解析到任何<strong>用户自定义文件</strong>！nginx默认情况下会使用第一个用户自定义conf来作为ip访问的结果（这是因为对用户自定义conf的include是在defualt server之前的，你可以理解为用户自定义文件会像C语言的头文件一样在<code>nginx.conf</code>中被展开）</p><p>当前实际上是访问了<code>/etc/nginx/conf.d</code>里面按字典排序的<strong>第一个用户conf配置</strong>！</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">/etc/nginx</span><br><span class="line">- nginx.conf</span><br><span class="line">- conf.d</span><br><span class="line">- server1.conf # 直接访问ip，使用了这个配置文件</span><br><span class="line">- server2.conf</span><br></pre></td></tr></table></figure><p>为什么在我这里依旧展示了<strong>默认的静态文件路径呢</strong>？是因为我的第一个配置文件<code>a.conf</code>中没有配置<code>location /</code>，全都是其他路径（比如<code>/a/</code>）的反代！所以nginx就往后采用了最末尾的default server里面提供的默认静态文件。</p><p>而浏览器链接左侧的红色<code>不安全</code>就告诉我们，当前其实收到了一个ssl证书，这便是上面原文中提到的<code>ip访问会因为ssl证书泄漏域名</code>的问题。</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2023/12/0aff6af71c686835cb262961360442ab.png" alt="image-20231209174001901"></p><p>我们可以点击<code>不安全</code>提示，再点击右上角那个<strong>带徽章的小按钮</strong>，查看当前收到的证书</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2023/12/96fafa7dca660e58ec838fb95350aa05.png" alt="image-20231209174025184"></p><p>如下图，当前收到的这证书，正是我的<code>/etc/nginx/conf.d</code>中第一个用户配置里面的ssl证书；内部包含了该证书对应的域名，我们的域名因此泄漏！</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2023/12/c59ed5779697e2dda320ae46d6b8f7e5.png" alt="image-20231209174102666"></p><h2 id="思路回顾"><a href="#思路回顾" class="headerlink" title="思路回顾"></a>思路回顾</h2><p>再来缕一缕思路</p><ul><li>nginx会先加载用户配置文件，末尾才是默认指向<code>/usr/share/nginx/html</code>静态路径的配置</li><li>当你使用ip访问当前服务器，nginx会给浏览器发送<code>/etc/nginx/conf.d</code>中按<strong>字典序</strong>排在第一位的<strong>用户配置文件</strong>中的ssl证书（即上图所示证书）</li><li>恶意访问人员可以通过遍历访问所有IP地址，当访问你的服务器IP地址时，他拿到一个ssl证书，其中包括了一个域名A；</li><li>假设你的域名A是按<code>域名A-&gt;CDN-&gt;服务器IP</code>来进行解析的，此时恶意访问人员就通过这个ssl证书直接得到了<code>域名A-&gt;服务器IP</code>的对应关系，完全绕过了CDN</li><li>此时他就可以通过修改hosts强制让<code>域名A</code>指向<code>服务器IP</code>，绕过CDN直接攻击你的源站</li></ul><p>套了CDN还暴露源站IP肯定不是我们想要的结果，所以我们需要解决这个问题！</p><h2 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h2><p>在<code>/etc/nginx/conf.d</code>中直接添加一个<code>a.conf</code>，让其排序在<strong>字典序的第一位</strong>，里面写入如下内容，其中<code>server_name _</code>的含义是除了我们配置过的域名外的其他访问</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">    <span class="attribute">listen</span> <span class="number">80</span> default_server;</span><br><span class="line">    <span class="attribute">server_name</span> _;</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Redirect all HTTP requests to HTTPS.</span></span><br><span class="line">    <span class="attribute">return</span> <span class="number">301</span> https://<span class="variable">$host</span><span class="variable">$request_uri</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">    <span class="attribute">listen</span> <span class="number">443</span> default_server;</span><br><span class="line">    <span class="attribute">server_name</span> _;</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 不用返回 444 了，直接拒绝握手</span></span><br><span class="line">    <span class="attribute">ssl_reject_handshake</span> <span class="literal">on</span>;</span><br><span class="line">    <span class="comment"># return 444;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>配置后直接重启nginx，没有报错就是ok了</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@bt-7274:/etc/nginx/conf.d]# systemctl restart nginx</span><br><span class="line">[root@bt-7274:/etc/nginx/conf.d]# ll</span><br><span class="line">total 28</span><br><span class="line">-rw-r--r-- 1 root root  193 Dec  9 17:52 a.conf</span><br></pre></td></tr></table></figure><p>此时直接访问就会报错ssl的alert了，但是edge中估计是因为<strong>缓存的问题</strong>，依旧能看到证书</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2023/12/9c095bed2d740e56c781c10e33212c9d.png" alt="image-20231209175534238"></p><p>换火狐看一下，无法连接，没有证书，目标达成！</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2023/12/20311f168b98f1ebe38157edf25b0c1a.png" alt="image-20231209175736923"></p><p>这里顺带贴一下火狐中一个正常ssl网站会显示成什么样子。在锁的按钮里面能看到证书的颁发者是谷歌，而<strong>上图中</strong>没有看到证书颁发者，即我们的证书并没有泄漏，目的达成。</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2023/12/6b4716321086d0e5ef6978695a52b630.png" alt="image-20231209175834078"></p><p>另外，我试了试我另外一个服务器使用的1panel安装的OpenResty，这个比较好，在默认情况下直接访问IP地址返回的是404，且没有暴露证书。不需要自己额外做配置了。</p>]]></content>
    
    
    <summary type="html">NGINX配置避免IP访问时证书暴露域名</summary>
    
    
    
    <category term="玩上Linux" scheme="https://blog.musnow.top/categories/%E7%8E%A9%E4%B8%8ALinux/"/>
    
    
    <category term="Linux" scheme="https://blog.musnow.top/tags/Linux/"/>
    
    <category term="Nginx" scheme="https://blog.musnow.top/tags/Nginx/"/>
    
  </entry>
  
  <entry>
    <title>【Nginx】nginx通过配置文件阻止海外ip访问</title>
    <link href="https://blog.musnow.top/posts/2029711168/"/>
    <id>https://blog.musnow.top/posts/2029711168/</id>
    <published>2023-12-09T08:12:55.000Z</published>
    <updated>2023-12-09T12:12:55.000Z</updated>
    
    <content type="html"><![CDATA[<p>nginx通过配置文件阻止海外ip访问</p><h1 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h1><p>因为最近发现有不少刷评论的脚本，在nginx请求日志里面看了眼，都是海外的ip，反正我的博客也是全中文。所以干脆把海外ip禁止artalk评论。</p><p>在<code>/etc/nginx/nginx.conf</code>中可以看到默认的日志路径，在里面能找到每一个转发的请求和其源IP。其中artak新增评论的请求是<code>/api/add</code>路径</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">access_log  /var/log/nginx/access.log  main;</span><br></pre></td></tr></table></figure><p>考虑到添加海外ip屏蔽可能会阻止一些真的在国外的朋友，如果你在阅读本站博客时，遇到相关问题无法直接评论与我交流，可以移步github随便找个我的仓库开个issue提问！</p><h1 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h1><h2 id="APNIC介绍"><a href="#APNIC介绍" class="headerlink" title="APNIC介绍"></a>APNIC介绍</h2><p>后文出现的网站是来自<strong>APNIC</strong> (Asia Pacific Network Information Center)，其是IP地址管理机构之一，负责亚洲、太平洋地区。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">APNIC提供了每日更新的亚太地区IPv4，IPv6，AS号分配的信息表：</span><br><span class="line">http://ftp.apnic.net/apnic/stats/apnic/delegated-apnic-latest</span><br><span class="line">该文件的格式与具体内容参见：</span><br><span class="line">http://ftp.apnic.net/pub/apnic/stats/apnic/README.TXT</span><br></pre></td></tr></table></figure><h2 id="脚本获取ip"><a href="#脚本获取ip" class="headerlink" title="脚本获取ip"></a>脚本获取ip</h2><p>初步解决方法参考：<a href="https://www.cnblogs.com/guoyabin/p/14263732.html">https://www.cnblogs.com/guoyabin/p/14263732.html</a></p><p>原博主提供的脚本如下，可以下载所有海外ip列表并生成一个nginx配置，写入<code>/etc/nginx/blackip.conf</code>中</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="built_in">rm</span> -f legacy-apnic-latest black_`<span class="built_in">date</span> +%F`.conf &amp;&amp; wget http://ftp.apnic.net/apnic/stats/apnic/legacy-apnic-latest</span><br><span class="line"></span><br><span class="line">awk -F <span class="string">&#x27;|&#x27;</span> <span class="string">&#x27;&#123;if(NR&gt;2)printf(&quot;%s %s/%d%s\n&quot;,&quot;deny&quot;,$4,24,&quot;;&quot;)&#125;&#x27;</span> legacy-apnic-latest &gt; black_`<span class="built_in">date</span> +%F`.conf &amp;&amp; \</span><br><span class="line"><span class="built_in">rm</span> -f /etc/nginx/blackip.conf &amp;&amp; \</span><br><span class="line"><span class="built_in">ln</span> -s <span class="variable">$PWD</span>/black_`<span class="built_in">date</span> +%F`.conf /etc/nginx/blackip.conf </span><br></pre></td></tr></table></figure><p>脚本执行后的效果如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@bt-7274:/etc/nginx]# ll</span><br><span class="line">total 88</span><br><span class="line">lrwxrwxrwx 1 root root   34 Dec  9 16:03 blackip.conf -&gt; /root/docker/black_2023-12-09.conf</span><br></pre></td></tr></table></figure><p>文件内容如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[root@bt-7274:/etc/nginx/conf.d]# cat ../blackip.conf</span><br><span class="line">deny 128.134.0.0/24;</span><br><span class="line">deny 128.184.0.0/24;</span><br><span class="line">deny 128.250.0.0/24;</span><br><span class="line">deny 129.60.0.0/24;</span><br><span class="line">deny 129.78.0.0/24;</span><br><span class="line">...后面的省略了</span><br></pre></td></tr></table></figure><h2 id="nginx屏蔽海外ip"><a href="#nginx屏蔽海外ip" class="headerlink" title="nginx屏蔽海外ip"></a>nginx屏蔽海外ip</h2><p>参考原博主的做法，你可以将这个<code>blackip.conf</code>在<code>/etc/nginx/nginx.conf</code>中的<strong>http模块</strong>里面include，这样会阻止当前服务器所有反代的海外的请求。</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">include</span> /etc/nginx/blackip.conf;</span><br></pre></td></tr></table></figure><p>还可以在单个配置文件的<a href="https://zinglix.xyz/2021/10/04/nginx-ssl-reject-handshake/">location里面引用</a></p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">  <span class="section">location</span> / &#123;</span><br><span class="line">      <span class="attribute">proxy_redirect</span> <span class="literal">off</span>; <span class="comment"># artalk的nginx配置中必须有这个</span></span><br><span class="line">      <span class="attribute">proxy_set_header</span> X-Real-IP <span class="variable">$remote_addr</span>;</span><br><span class="line">      <span class="attribute">proxy_set_header</span> X-Forwarded-For <span class="variable">$proxy_add_x_forwarded_for</span>;</span><br><span class="line">      <span class="attribute">proxy_set_header</span> Host <span class="variable">$host</span>;</span><br><span class="line">      <span class="attribute">proxy_set_header</span> Upgrade-Insecure-Requests <span class="number">1</span>;</span><br><span class="line">      <span class="attribute">proxy_set_header</span> X-Forwarded-Proto https;</span><br><span class="line"></span><br><span class="line">      <span class="attribute">include</span> /etc/nginx/blackip.conf; <span class="comment"># 引用配置</span></span><br><span class="line"></span><br><span class="line">      <span class="attribute">proxy_pass</span> http://127.0.0.1:14722;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>修改后重启nginx，没有报错就是ok了</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl restart nginx</span><br></pre></td></tr></table></figure><p>用海外的服务器试试能不能请求artalk，用<a href="https://artk.musnow.top/sidebar/#/login">artk.musnow.top&#x2F;sidebar&#x2F;…</a>这个管理员登录页面来进行测试。</p><p>国内服务器请求结果如下，和浏览器打开的结果基本是一样（管理员登录界面）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">[root@bt-7274:/etc/nginx/conf.d]# curl https://artk.musnow.top/sidebar/#/login</span><br><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">  &lt;head&gt;</span><br><span class="line">    &lt;meta charset=&quot;UTF-8&quot; /&gt;</span><br><span class="line">    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot; /&gt;</span><br><span class="line">    &lt;title&gt;Artalk Sidebar&lt;/title&gt;</span><br><span class="line">    &lt;script type=&quot;module&quot; crossorigin src=&quot;./assets/index-5a0b3a93.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">    &lt;link rel=&quot;stylesheet&quot; href=&quot;./assets/index-84fdcf98.css&quot;&gt;</span><br><span class="line">  &lt;/head&gt;</span><br><span class="line">  &lt;body&gt;</span><br><span class="line">    &lt;div id=&quot;app&quot;&gt;&lt;/div&gt;</span><br><span class="line">  </span><br><span class="line">  &lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><p>海外服务器请求结果也是上面这样……然后发现是因为我的海外服务器ip压根不在那个black的deny列表里面</p><p>尝试把ip的网段给加进去，重启nginx再试试。<strong>完美处理</strong>！添加前能正常请求到，添加后就变成403了</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">[root@RainYun-8aNbbsmA:~]# curl https://artk.musnow.top/sidebar/#/login</span><br><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">  &lt;head&gt;</span><br><span class="line">    &lt;meta charset=&quot;UTF-8&quot; /&gt;</span><br><span class="line">    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot; /&gt;</span><br><span class="line">    &lt;title&gt;Artalk Sidebar&lt;/title&gt;</span><br><span class="line">    &lt;script type=&quot;module&quot; crossorigin src=&quot;./assets/index-5a0b3a93.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">    &lt;link rel=&quot;stylesheet&quot; href=&quot;./assets/index-84fdcf98.css&quot;&gt;</span><br><span class="line">  &lt;/head&gt;</span><br><span class="line">  &lt;body&gt;</span><br><span class="line">    &lt;div id=&quot;app&quot;&gt;&lt;/div&gt;</span><br><span class="line">    </span><br><span class="line">  &lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br><span class="line">[root@RainYun-8aNbbsmA:~]# </span><br><span class="line">[root@RainYun-8aNbbsmA:~]# curl https://artk.musnow.top/sidebar/#/login</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;&lt;title&gt;403 Forbidden&lt;/title&gt;&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;center&gt;&lt;h1&gt;403 Forbidden&lt;/h1&gt;&lt;/center&gt;</span><br><span class="line">&lt;hr&gt;&lt;center&gt;nginx/1.20.1&lt;/center&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br><span class="line">[root@RainYun-8aNbbsmA:~]# </span><br></pre></td></tr></table></figure><h2 id="nginx屏蔽非国内ip"><a href="#nginx屏蔽非国内ip" class="headerlink" title="nginx屏蔽非国内ip"></a>nginx屏蔽非国内ip</h2><p>我前文提到了我的海外服务器的ip不在这个deny的ip列表里面，没有被屏蔽。</p><p>考虑到网上搜不到<code>legacy-apnic-latest</code>文件存放的是什么ip的信息，我决定换一个思路：allow国内的ip，拒绝所有非国内的ip</p><blockquote><p>获取国内ip列表 <a href="https://www.cnblogs.com/sentangle/p/13201770.html">https://www.cnblogs.com/sentangle/p/13201770.html</a></p></blockquote><p>下面这个url里面的ip地址标明了地区，我们只需要将其提取出来即可</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://ftp.apnic.net/apnic/stats/apnic/delegated-apnic-latest</span><br></pre></td></tr></table></figure><p>这个文件里面的内容结构如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">等级机构|获得该IP段的国家/组织|资源类型|起始IP|IP段长度|分配日期|分配状态</span><br></pre></td></tr></table></figure><p>我们只需要提取CN的所有IP，然后允许他们，再<code>deny all</code>阻止其他ip就可以了</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="built_in">rm</span> -f delegated-apnic-latest blackcn_`<span class="built_in">date</span> +%F`.conf &amp;&amp; wget http://ftp.apnic.net/apnic/stats/apnic/delegated-apnic-latest</span><br><span class="line"></span><br><span class="line">awk -F\| <span class="string">&#x27;/CN\|ipv4/ &#123; printf(&quot;%s %s/%d%s\n&quot;,&quot;allow&quot;,$4, 32-log($5)/log(2), &quot;;&quot;) &#125;&#x27;</span> delegated-apnic-latest &gt; blackcn_`<span class="built_in">date</span> +%F`.conf &amp;&amp; \</span><br><span class="line"><span class="built_in">rm</span> -f /etc/nginx/blackcn.conf &amp;&amp; \</span><br><span class="line"><span class="built_in">ln</span> -s <span class="variable">$PWD</span>/blackcn_`<span class="built_in">date</span> +%F`.conf /etc/nginx/blackcn.conf</span><br></pre></td></tr></table></figure><p>执行这个脚本后，会生成<code>/etc/nginx/blackcn.conf</code>文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@bt-7274:/etc/nginx]# ll</span><br><span class="line">total 88</span><br><span class="line">lrwxrwxrwx 1 root root   42 Dec  9 16:54 blackcn.conf -&gt; /root/docker/nginx/blackcn_2023-12-09.conf</span><br><span class="line">lrwxrwxrwx 1 root root   40 Dec  9 16:56 blackip.conf -&gt; /root/docker/nginx/black_2023-12-09.conf</span><br></pre></td></tr></table></figure><p>内容如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">allow 223.248.0.0/14;</span><br><span class="line">allow 223.252.128.0/17;</span><br><span class="line">allow 223.254.0.0/16;</span><br><span class="line">allow 223.255.0.0/17;</span><br><span class="line">allow 223.255.236.0/22;</span><br><span class="line">allow 223.255.252.0/23;</span><br><span class="line">....</span><br></pre></td></tr></table></figure><p>还是修改nginx单个站点配置文件的location中的内容</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">  <span class="section">location</span> / &#123;</span><br><span class="line">      <span class="attribute">proxy_redirect</span> <span class="literal">off</span>;</span><br><span class="line">  <span class="attribute">proxy_set_header</span> X-Real-IP <span class="variable">$remote_addr</span>;</span><br><span class="line">      <span class="attribute">proxy_set_header</span> X-Forwarded-For <span class="variable">$proxy_add_x_forwarded_for</span>;</span><br><span class="line">      <span class="attribute">proxy_set_header</span> Host <span class="variable">$host</span>;</span><br><span class="line">      <span class="attribute">proxy_set_header</span> Upgrade-Insecure-Requests <span class="number">1</span>;</span><br><span class="line">      <span class="attribute">proxy_set_header</span> X-Forwarded-Proto https;</span><br><span class="line"><span class="comment"># 允许所有国内ip</span></span><br><span class="line">  <span class="attribute">include</span> /etc/nginx/blackcn.conf;</span><br><span class="line">  <span class="attribute">deny</span> all; <span class="comment"># 阻止其他ip</span></span><br><span class="line"></span><br><span class="line">  <span class="attribute">proxy_pass</span> http://127.0.0.1:14722;</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure><p>先来试试不修改配置文件（不做任何deny和allow操作的情况下）海外ip请求结果</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">[root@RainYun-8aNbbsmA:~]# curl https://artk.musnow.top/sidebar/#/login</span><br><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">  &lt;head&gt;</span><br><span class="line">    &lt;meta charset=&quot;UTF-8&quot; /&gt;</span><br><span class="line">    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot; /&gt;</span><br><span class="line">    &lt;title&gt;Artalk Sidebar&lt;/title&gt;</span><br><span class="line">    &lt;script type=&quot;module&quot; crossorigin src=&quot;./assets/index-5a0b3a93.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">    &lt;link rel=&quot;stylesheet&quot; href=&quot;./assets/index-84fdcf98.css&quot;&gt;</span><br><span class="line">  &lt;/head&gt;</span><br><span class="line">  &lt;body&gt;</span><br><span class="line">    &lt;div id=&quot;app&quot;&gt;&lt;/div&gt;</span><br><span class="line">    </span><br><span class="line">  &lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><p>符合预期，正常请求出了登录页面的html文件。</p><p>添加如上修改后，重启nginx，再次进行测试。这一次已经403阻止了，完美！</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[root@RainYun-8aNbbsmA:~]# curl https://artk.musnow.top/sidebar/#/login</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;&lt;title&gt;403 Forbidden&lt;/title&gt;&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;center&gt;&lt;h1&gt;403 Forbidden&lt;/h1&gt;&lt;/center&gt;</span><br><span class="line">&lt;hr&gt;&lt;center&gt;nginx/1.20.1&lt;/center&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><h1 id="The-end"><a href="#The-end" class="headerlink" title="The end"></a>The end</h1><p>你可以写个crontab让其定时执行脚本并重启nginx，我个人还是选择人工处理了（什么时候想起来就去更新一下ip列表）</p><p>感谢本文中出现的博客的博主。没有他们的帮助，我无法编写出shell脚本。</p>]]></content>
    
    
    <summary type="html">nginx通过配置文件阻止海外ip访问</summary>
    
    
    
    <category term="玩上Linux" scheme="https://blog.musnow.top/categories/%E7%8E%A9%E4%B8%8ALinux/"/>
    
    
    <category term="Linux" scheme="https://blog.musnow.top/tags/Linux/"/>
    
    <category term="Nginx" scheme="https://blog.musnow.top/tags/Nginx/"/>
    
  </entry>
  
  <entry>
    <title>【图床】删除对象存储桶前一定要检查！</title>
    <link href="https://blog.musnow.top/posts/3595872827/"/>
    <id>https://blog.musnow.top/posts/3595872827/</id>
    <published>2023-12-09T02:32:14.000Z</published>
    <updated>2023-12-09T02:32:14.000Z</updated>
    
    <content type="html"><![CDATA[<p>我又干蠢事了！虽然没有很大影响，但是这种问题还是不要发生的好。</p><h2 id="什么情况？"><a href="#什么情况？" class="headerlink" title="什么情况？"></a>什么情况？</h2><p>我在博客尚有引用某个对象存储bucket中图片的情况下，删除了那个bucket（因为这个bucket很久没有用，算是弃用的）</p><p>还好今天看旧笔记的时候，突然发现了这个问题，立马去重新搜索了一下这个旧bucket的图片链接，还好还好，受影响的只有两篇文章</p><ul><li>一篇之前导出过PDF，图片还能找到</li><li>另外一篇文章以文字为主，内部丢失的图片可有可无</li></ul><p>我恢复了第一篇里面的图片，然后修改了第二篇中和图片相关的文字说明，算是解决了这个问题。</p><p>又重写检查了一下笔记目录，算是彻底没有这个被我删除的bucket里面的图片了。</p><p>这一次还好，算是没有丢东西，不然数据不备份就删除的笑料又要多一个了……🤣</p><h2 id="以此为戒"><a href="#以此为戒" class="headerlink" title="以此为戒"></a>以此为戒</h2><p>删除bucket之前一定要检查自己到底还有没有使用这个bucket中的文件或者图片！</p><p>删除图床本地目录前，一定要检查自己还有没有这个本地目录里面的图片！</p><p>最佳方案：不要管那个bucket，将其访问权限改成<strong>私有</strong>后，使用备注功能将其标记为弃用。以后不再使用该bucket即可。</p><p>因为对于我个人使用来说，一个bucket里面不会有太多文件，目前最大的图床bucket也不过2GB而已，把它留在那里花不了几个钱！不然把bucket删了，哪天发现需要去里面找旧文件的时候无从下手就麻烦了！</p><blockquote><p>至于我为什么要删……其实是因为我有点强迫症，不用还留在那里看着有点不爽……</p></blockquote><p>当然还有另外一个解决方案：使用<code>rclone</code>等工具，将s3中的所有文件下载到本地，打包多地备份后，删除云端bucket</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;我又干蠢事了！虽然没有很大影响，但是这种问题还是不要发生的好。&lt;/p&gt;
&lt;h2 id=&quot;什么情况？&quot;&gt;&lt;a href=&quot;#什么情况？&quot; class=&quot;headerlink&quot; title=&quot;什么情况？&quot;&gt;&lt;/a&gt;什么情况？&lt;/h2&gt;&lt;p&gt;我在博客尚有引用某个对象存储bucke</summary>
      
    
    
    
    <category term="差生文具多" scheme="https://blog.musnow.top/categories/%E5%B7%AE%E7%94%9F%E6%96%87%E5%85%B7%E5%A4%9A/"/>
    
    
    <category term="图床" scheme="https://blog.musnow.top/tags/%E5%9B%BE%E5%BA%8A/"/>
    
  </entry>
  
  <entry>
    <title>【博客】hexo配置sitemap和百度|必应|谷歌收录</title>
    <link href="https://blog.musnow.top/posts/3595872826/"/>
    <id>https://blog.musnow.top/posts/3595872826/</id>
    <published>2023-12-08T12:32:14.000Z</published>
    <updated>2023-12-08T12:32:14.000Z</updated>
    
    <content type="html"><![CDATA[<p>最近没事找事，又看了会关于博客主题的东西，之前的sitemap一直没有弄上去，现在有时间就弄一下。</p><h1 id="1-hexo安装sitemap插件"><a href="#1-hexo安装sitemap插件" class="headerlink" title="1.hexo安装sitemap插件"></a>1.hexo安装sitemap插件</h1><p>在你的hexo路径下执行如下命令，安装sitemap生成插件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-generator-baidu-sitemap --save</span><br><span class="line">npm install hexo-generator-sitemap --save</span><br></pre></td></tr></table></figure><p>实测在windows11的<code>node v16.20.2</code>和<code>npm  9.8.1</code>下可以正常安装，但是安装baidu-sitemap插件的时候可能会有警告（不影响使用）</p><p>安装完毕插件后，在你的hexo配置文件<code>_config.yml</code>中添加如下内容，指定站点地图的文件名字即可。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 百度和谷歌的sitemap</span></span><br><span class="line"><span class="comment"># npm install hexo-generator-baidu-sitemap --save</span></span><br><span class="line"><span class="comment"># npm install hexo-generator-sitemap --save</span></span><br><span class="line"><span class="attr">baidusitemap:</span></span><br><span class="line">    <span class="attr">path:</span> <span class="string">baidusitemap.xml</span></span><br><span class="line"><span class="attr">sitemap:</span></span><br><span class="line">    <span class="attr">path:</span> <span class="string">sitemap.xml</span></span><br></pre></td></tr></table></figure><p>请注意，需要修改的是hexo的配置文件，并非主题配置文件！</p><h1 id="2-如何修改hexo主题生成的index-html文件？"><a href="#2-如何修改hexo主题生成的index-html文件？" class="headerlink" title="2.如何修改hexo主题生成的index.html文件？"></a>2.如何修改hexo主题生成的index.html文件？</h1><p>一般情况下，站点平台都会让你在<code>index.html</code>的<code>&lt;head&gt;</code>里面加一个html语句，来验证站点的所有权。比图百度的验证html语句如下</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;baidu-site-verification&quot;</span> <span class="attr">content</span>=<span class="string">&quot;验证码&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure><p>部分hexo主题可能提供了自定义<code>&lt;head&gt;</code>的选项（比如butterfly主题就有）</p><p>如果你使用的主题没有提供自定义<code>&lt;head&gt;</code>，可以尝试在主题文件夹下搜索index或者head关键字，来找到当前主题使用的<code>index.html</code>生成源文件</p><blockquote><p>该方法<strong>仅</strong>适用于将主题文件直接下载到<code>themes</code>文件夹下的情况，因为如果你用的是npm安装的主题，那么修改的主题文件是不会对其他地方的部署生效的，下一次更新主题还会覆盖掉。</p></blockquote><p>比如下图是keep主题<code>v3.6.1</code>版本中的<code>head.ejs</code>，你只需要把提供的meta标签加到这里面，下一次部署的时候的<code>index.html</code>中就会带上这个标头了。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">themes\keep\layout\_partial\head.ejs</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2023/12/c5c020be0607437acbd2d4364edd839b.png" alt="image-20231208205004240"></p><h1 id="3-站长平台添加sitemap"><a href="#3-站长平台添加sitemap" class="headerlink" title="3.站长平台添加sitemap"></a>3.站长平台添加sitemap</h1><h2 id="百度"><a href="#百度" class="headerlink" title="百度"></a>百度</h2><p>百度资源搜索平台 <a href="https://ziyuan.baidu.com/site/index#/">https://ziyuan.baidu.com/site/index#/</a></p><p>百度实在是无语，之前安装了<code>hexo-baidu-url-submit</code>插件，主动调用百度api给他推送url，结果弄了已经快一年了，还没有收录我的站点。</p><blockquote><p>实话说，百度不收录站点，网站看的人就很少。百度我自己博客的关键词，结果是一堆被百度收录的爬虫站点用我的文章赚流量。唉……</p></blockquote><p>在资源搜索平台的站点管理中添加你的站点，用第二点提到的方式进行验证</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2023/12/f5049ad4122b226e6621e3f77bbca406.png" alt="image-20231208205611557"></p><p>添加完毕后，在普通收录中可以找到sitemap提交的区域。但是不知道为什么我这里的提交配额是0，搜索了一下也没有找到原因。</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2023/12/f1271309829d10b946af8dc1834d6530.png" alt="image-20231208205652153"></p><p><a href="https://zmingcx.com/baidu-linksubmit-sitemap.html">百度资源平台提交sitemap是取消了还是我被限制了？</a></p><p>有人说是站点质量太低被百度屏蔽了，但是这个情况也是很多人都遇到过的。估计是百度策略更新什么的，不允许你添加了吧！</p><p>如果你已经添加了sitemap，请不要将其删除，免得到时候又没有办法添加了。</p><h2 id="bing"><a href="#bing" class="headerlink" title="bing"></a>bing</h2><p>bing的站长平台直接搜就行：<a href="https://www.bing.com/webmasters/about?setlang=zh-cn">https://www.bing.com/webmasters/about?setlang=zh-cn</a></p><blockquote><p>国内裸连可能不稳定，需要用点方法。</p><p>不过bing即便不提交sitemap也咔咔收录了我的博客，主打一个主动+来者不拒。</p></blockquote><p>进去之后，用微软账户登录，然后点击新增站点，<strong>输入你博客的域名</strong></p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2023/12/46eaebbcbe275e5719c48c0fa212d482.png" alt="image-20231208203803163"></p><p>bing会让你验证站点所有权，根据下面三种方式的指引，选择一种就行了。如果你不知道如何修改hexo的源文件，使用<strong>CNAME验证</strong>方式是最简单的（只要你有域名有权就行了）。</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2023/12/6decdf248d463e8dcf22c1408d1521a8.png" alt="image-20231208204120311"></p><p>不过估计有很多老哥都是白嫖的github pages或者netlify&#x2F;vercel的<strong>二级域名</strong>，在没有域名所有权的情况下，你可以用前两种方式来验证。</p><ul><li>XML文件方式：将bing提供的XML文件下载，然后放到你hexo源目录的<strong>source</strong>文件夹下，就可以了。</li><li>HTML MATE标记验证：部分hexo主题可能提供了自定义header的选项（比如butterfly主题就有）其他主题可以参考上文第二点操作</li></ul><p>域名验证完毕后，在左侧可以提交网站地图（即sidemap）</p><p>直接点击按钮提交你的站点地图的url就可以了。bing会自动进行处理，如下图我的第一个sitemap已经成功处理出来了383个链接，非常完美。</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2023/12/24f236053b3ebece4028124e987e6c65.png" alt="image-20231208204707769"></p><h2 id="谷歌"><a href="#谷歌" class="headerlink" title="谷歌"></a>谷歌</h2><p>实话说，一个纯中文且面向国内读者的站点，在谷歌上面收录了估计也没多大用处，但是可以没用，但不能没有。也给他弄一下吧。</p><p><a href="https://search.google.com/search-console/welcome">https://search.google.com/search-console/welcome</a></p><p>首先是输入站点网址，因为我不需要验证所有站点，只把博客收录了就行，所以这里我选的是网址前缀。输入站点的时候需要把http也带上</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2023/12/940d735d204146063e8cb6de8db30326.png" alt="image-20231208210159103"></p><p>谷歌的验证方式也有很多种，这里的操作和bing是一样的，把它发给你的文件直接放到hexo的source路径下就可以了，或者采用html标签的方式验证。</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2023/12/6b7aef8d762ec3127bf418fba2257ff7.png" alt="image-20231208210317624"></p><p>验证成功后，选择前往资源界面，即前往当前站点的控制台。</p><p>如果你不小心点了完成，站点资源界面在站长工具的<strong>左侧边栏</strong>里面，在里面可以找到你已经添加了的站点。</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2023/12/2b62fc8c0f4a83a969894d7a97f13007.png" alt="image-20231208210604314"></p><p>在左侧选择站点地图，点击添加即可</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2023/12/f8159f7211dc0f12fc854ae74476f2f8.png" alt="image-20231208210802621"></p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2023/12/d57012975919635230b6bd8f57e9871b.png" alt="image-20231208210849226"></p><h1 id="搞定！"><a href="#搞定！" class="headerlink" title="搞定！"></a>搞定！</h1><p>有什么问题，欢迎评论区提出！</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;最近没事找事，又看了会关于博客主题的东西，之前的sitemap一直没有弄上去，现在有时间就弄一下。&lt;/p&gt;
&lt;h1 id=&quot;1-hexo安装sitemap插件&quot;&gt;&lt;a href=&quot;#1-hexo安装sitemap插件&quot; class=&quot;headerlink&quot; title=&quot;1</summary>
      
    
    
    
    <category term="差生文具多" scheme="https://blog.musnow.top/categories/%E5%B7%AE%E7%94%9F%E6%96%87%E5%85%B7%E5%A4%9A/"/>
    
    
    <category term="Hexo" scheme="https://blog.musnow.top/tags/Hexo/"/>
    
  </entry>
  
  <entry>
    <title>【Linux】lcov2.0安装和perl修改镜像源</title>
    <link href="https://blog.musnow.top/posts/1274282021/"/>
    <id>https://blog.musnow.top/posts/1274282021/</id>
    <published>2023-11-26T12:12:55.000Z</published>
    <updated>2023-11-26T12:12:55.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="安装lcov-2-0"><a href="#安装lcov-2-0" class="headerlink" title="安装lcov 2.0"></a>安装lcov 2.0</h1><p>你可能不知道lcov是什么，简而言之，它是一个代码单元测试覆盖率的显示工具，基于gcov。</p><ul><li>什么是单元测试覆盖率？</li></ul><p>我们需要对项目中的每个函数编写单元测试，其实就是测试函数的功能。通过gcc&#x2F;g++的相关编译选项，可以得到一个gcda文件，内部包含某个cpp文件中相关函数被执行了多少次，以及某些if&#x2F;switch中的多分支是否覆盖上了；</p><p>lcov就可以解析这些gcda文件，得到如下图所示的函数<strong>测试覆盖率</strong>的报告</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2023/11/6115958c076400afbfaf6ace5c1e89b9.png" alt="image-20231126201406666"></p><p>包括单元测试在内，这部分对代码函数测试的操作一般被称之为<code>功能安全</code>，这里就不多说了。</p><p>lcov 2.0的安装命令相对来说很简单，就是下面这些</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">wget https://github.com/linux-test-project/lcov/releases/download/v2.0/lcov-2.0.tar.gz</span><br><span class="line">tar -zxvf lcov-2.0.tar.gz</span><br><span class="line"><span class="built_in">cd</span> lcov-2.0</span><br><span class="line">sudo make install</span><br></pre></td></tr></table></figure><h1 id="perl"><a href="#perl" class="headerlink" title="perl"></a>perl</h1><p>使用lcov的时候需要perl，此时就需要修改镜像源。默认的perl module的源是在国外的，国内基本上是完全用不了。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># centos8 安装perl</span></span><br><span class="line">sudo yum install perl</span><br></pre></td></tr></table></figure><p>如果你的lcov运行的时候遇到下面类似的错误，那么就是因为perl缺少对应module导致的，比如如下报错是因为缺少<code>Capture::Tiny</code>这个module；</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Can&#x27;t locate Capture/Tiny.pm in @INC (you may need to install the Capture::Tiny module) (@INC contains: /usr/local/lib/lcov /usr/local/lib64/perl5 /usr/local/share/perl5 /usr/lib64/perl5/vendor_perl /usr/share/perl5/vendor_perl /usr/lib64/perl5 /usr/share/perl5) at /usr/local/lib/lcov/lcovutil.pm line 14.</span><br><span class="line">BEGIN failed--compilation aborted at /usr/local/lib/lcov/lcovutil.pm line 14.</span><br><span class="line">Compilation failed in require at /usr/local/bin/lcov line 102.</span><br><span class="line">BEGIN failed--compilation aborted at /usr/local/bin/lcov line 102.</span><br><span class="line">make: *** [makefile:6: lcov] Error 2</span><br></pre></td></tr></table></figure><h2 id="perl使用清华源"><a href="#perl使用清华源" class="headerlink" title="perl使用清华源"></a>perl使用清华源</h2><p>使用清华源就行了 <a href="https://mirrors.tuna.tsinghua.edu.cn/help/CPAN/">https://mirrors.tuna.tsinghua.edu.cn/help/CPAN/</a></p><p>因为我用的centos的系统，安装的perl版本很老，<code>v5.26.3</code>，所以这里记录一个手动修改镜像源的办法</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">perl --version</span><br></pre></td></tr></table></figure><p>在root用户下执行如下命令，会进入一个perl的命令行</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">perl -MCPAN -e shell</span><br></pre></td></tr></table></figure><p>在perl的命令行中执行如下命令</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">o conf init</span><br></pre></td></tr></table></figure><p>最终展现的结果应该如下，会自动往当前用户的家目录下创建一个配置文件</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2023/11/fdfb49a8a83aa12789080503070a9a7a.png" alt="image-20231126200126012"></p><p>这里创建的配置文件是在root用户下，输入<code>quit</code>退出perl的命令行后，我们直接vim打开这个配置文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim /root/.cpan/CPAN/MyConfig.pm</span><br></pre></td></tr></table></figure><p>在里面找到urllist选项，根据已有格式添加一个新的镜像路径就可以了</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2023/11/0f2b4af79a73a2f95bb6f6de6b17560b.png" alt="image-20231126200230352"></p><p>我这里添加后的urllist配置项如下，第一项是镜像源就OK</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#x27;urllist&#x27; =&gt; [q[https://mirrors.tuna.tsinghua.edu.cn/CPAN/], q[http://www.cpan.org/]],</span><br></pre></td></tr></table></figure><p>但是要注意一下，在我这边的网络环境中，清华源在perl安装包的时候也容易抽风，我试出来比较稳定的ip如下，将其写入<code>/etc/hosts</code>文件中，这样安装perl包的时候就不会timeout了</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">101.6.15.130 mirrors.tuna.tsinghua.edu.cn</span><br></pre></td></tr></table></figure><p>这个ip后续可能会有变化啊，请以你的实际情况为准！</p><h2 id="perl安装module"><a href="#perl安装module" class="headerlink" title="perl安装module"></a>perl安装module</h2><p>后续安装包的时候，就可以用上镜像源了，安装包的语句如下，请注意这个安装语句最后还有个英文的单引号，一定不要把他删了！</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo perl -MCPAN -e <span class="string">&#x27;install &quot;包名&quot;&#x27;</span></span><br></pre></td></tr></table></figure><p>我需要用perl是因为要用到lcov，在lcov仓库的readme里面提到了lcov需要的perl包，一个一个安装就行了（以下节选自<code>lcov2.0</code>的仓库README）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">These perl packages include:</span><br><span class="line"></span><br><span class="line">  - Capture::Tiny</span><br><span class="line">  - DateTime</span><br><span class="line">  - Devel::Cover</span><br><span class="line">  - Digest::MD5</span><br><span class="line">  - File::Spec</span><br><span class="line">  - at least one flavor of JSON module.</span><br><span class="line">    In order of performance/preference:</span><br><span class="line">       - JSON::XS</span><br><span class="line">       - Cpanel::JSON::XS</span><br><span class="line">       - JSON::PP</span><br><span class="line">       - JSON</span><br><span class="line"> - Memory::Process</span><br><span class="line"> - Module::Load::Conditional</span><br><span class="line"> - Scalar::Util</span><br><span class="line"> - Time::HiRes</span><br><span class="line"></span><br><span class="line">If your system is missing any of these, then you may be able to install them</span><br><span class="line">via:</span><br><span class="line"></span><br><span class="line">   $ perl -MCPAN -e &#x27;install &quot;packageName&quot;&#x27;</span><br></pre></td></tr></table></figure><p>比如我需要安装<code>Capture::Tiny</code>包，就用如下命令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo perl -MCPAN -e <span class="string">&#x27;install &quot;Capture::Tiny&quot;&#x27;</span></span><br></pre></td></tr></table></figure><p>正常安装的命令输出结果如下图所示</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2023/11/566a4438035e393943d353c48b016149.png" alt="image-20231126201023622"></p><h2 id="ubuntu安装perl-module"><a href="#ubuntu安装perl-module" class="headerlink" title="ubuntu安装perl module"></a>ubuntu安装perl module</h2><p>如果是ubuntu，安装perl的包会方便一点，因为apt源里面是有perl的module</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># ubuntu 22.04 可以直接安装下面的依赖项，就可以使用lcov 2.0了</span></span><br><span class="line">sudo apt install -y perl libcapture-tiny-perl libdatetime-perl</span><br></pre></td></tr></table></figure><p>你可以根据perl的包名中的<strong>关键字</strong>，尝试在<code>apt list</code>里面找找有没有对应的包</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt list | grep 包名</span><br></pre></td></tr></table></figure><h1 id="使用lcov"><a href="#使用lcov" class="headerlink" title="使用lcov"></a>使用lcov</h1><p>对于lcov2.0的命令使用，可以参考我的linux仓库中的测试</p><p><a href="https://gitee.com/musnows/raspberry-practice/tree/master/lcov_test">https://gitee.com/musnows/raspberry-practice/tree/master/lcov_test</a></p>]]></content>
    
    
    <summary type="html">lcov2.0安装和perl修改镜像源</summary>
    
    
    
    <category term="玩上Linux" scheme="https://blog.musnow.top/categories/%E7%8E%A9%E4%B8%8ALinux/"/>
    
    
    <category term="Linux" scheme="https://blog.musnow.top/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>【C++】空对象指针也能访问成员函数？</title>
    <link href="https://blog.musnow.top/posts/3858168549/"/>
    <id>https://blog.musnow.top/posts/3858168549/</id>
    <published>2023-11-16T08:40:46.000Z</published>
    <updated>2023-11-16T08:40:46.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-起因"><a href="#1-起因" class="headerlink" title="1.起因"></a>1.起因</h1><p>今天写代码的时候遇到一个bug，一个类中的set函数在设置一个POD类型的时候出现了异常，直接段错误退出了。</p><blockquote><p>小tips，POD类型指的是内置类型。</p></blockquote><p>想了好久，都没发现这里的问题到底是因为什么。后来才知道，原来空的对象指针，也能被解引用访问到函数！</p><h1 id="2-示例"><a href="#2-示例" class="headerlink" title="2.示例"></a>2.示例</h1><p>下面是关于这个情况的示例代码</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">mytest</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">mytest</span>() = <span class="keyword">default</span>;</span><br><span class="line">    <span class="built_in">mytest</span>(<span class="type">int</span> a):_a(<span class="number">0</span>)&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">set_int</span><span class="params">(<span class="type">int</span> a)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;set int to &quot;</span> &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">        _a = a;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(<span class="type">int</span> a)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;just a print&quot;</span> &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> _a = <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    mytest* ptr = <span class="literal">nullptr</span>;</span><br><span class="line">    ptr-&gt;<span class="built_in">print</span>(<span class="number">20</span>);</span><br><span class="line">    ptr-&gt;<span class="built_in">set_int</span>(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行这个程序，会出现段错误。但你会发现这个段错误并不是因为我们的<code>ptr-&gt;</code> 里面出现的，而是成功进入了set_int函数，执行了打印，最终对成员变量<code>_a</code>赋值的时候出现的！</p><p>对象指针为空，代表压根不存在一个实际的对象，也没办法对不存在的成员变量操作。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt; ./test</span><br><span class="line">just a print20</span><br><span class="line">set int to 10</span><br><span class="line">[1]    280362 segmentation fault  ./test</span><br></pre></td></tr></table></figure><p>当代码很多的时候，就会因为忽略这个特性（其实我当时是压根不知道）而误以为错误出现在set_int函数中。</p><p>没有想到是外层的对象指针为空导致的。</p><h1 id="3-为什么？"><a href="#3-为什么？" class="headerlink" title="3.为什么？"></a>3.为什么？</h1><p>在编译过程中，对象就已经绑定了函数地址。一个类的所有对象，使用的函数地址都是一样的。当编译<code>ptr-&gt;set_int(10)</code> 的时候，函数的地址就已经和这个指针绑定了，调用它等价于直接调用 set_int 函数。</p><p>如果这个函数中没有需要用到成员变量的地方，也就不需要解引用this指针，是不会出错的。比如上方代码中的print函数，就没有出现异常。</p><p>但如果函数内访问了内置成员，那么就会出现解引用空指针导致的段错误！</p>]]></content>
    
    
    <summary type="html">真没想到，空对象指针也能访问成员函数啊？</summary>
    
    
    
    <category term="遇见C++" scheme="https://blog.musnow.top/categories/%E9%81%87%E8%A7%81C/"/>
    
    
    <category term="C++" scheme="https://blog.musnow.top/tags/C/"/>
    
    <category term="数据结构" scheme="https://blog.musnow.top/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>【面经】C++面筋记录 (一) 231021</title>
    <link href="https://blog.musnow.top/posts/721187015/"/>
    <id>https://blog.musnow.top/posts/721187015/</id>
    <published>2023-10-21T10:50:14.000Z</published>
    <updated>2023-10-21T10:50:14.000Z</updated>
    
    <content type="html"><![CDATA[<p>记录部分从牛客网上看到的面筋</p><span id="more"></span><h1 id="1-声明一个vector，当vector过大时会栈溢出吗？"><a href="#1-声明一个vector，当vector过大时会栈溢出吗？" class="headerlink" title="1.声明一个vector，当vector过大时会栈溢出吗？"></a>1.声明一个vector，当vector过大时会栈溢出吗？</h1><p>答案是会。</p><p>默认申请的vector是放在栈区的，栈区的大小&lt;&lt;堆区的大小。所以如果我们在栈区中开辟的vector中插入巨量的数据，是会导致栈溢出的。</p><p>解决办法是将数据存放到堆区上（使用new来创建vector，而不是直接创建）</p><h1 id="2-如何实现多次运行程序但只有一个后台进程？"><a href="#2-如何实现多次运行程序但只有一个后台进程？" class="headerlink" title="2.如何实现多次运行程序但只有一个后台进程？"></a>2.如何实现多次运行程序但只有一个后台进程？</h1><p>使用命名互斥锁，程序启动前申请锁。</p><ul><li>如果锁没有被申请，代表是第一个进程，可以正常运行</li><li>如果锁已经被占用，代表已经有进程了，直接退出当前进程（这里要使用try_lock避免阻塞等待）</li></ul><p>在Linux下可以用命名信号量来实现类似进程共享锁的操作。这部分可以去学习进程通信中信号量的部分。</p><p>咨询了发这篇面筋的大佬，说是用文件保存之前进程的PID，读取出来将之前的进程kill掉。</p><h1 id="3-二分法的前提是什么？"><a href="#3-二分法的前提是什么？" class="headerlink" title="3.二分法的前提是什么？"></a>3.二分法的前提是什么？</h1><ul><li>数据有序</li><li>数据结构支持随机访问</li></ul><h1 id="4-互斥锁和自旋锁有什么区别"><a href="#4-互斥锁和自旋锁有什么区别" class="headerlink" title="4.互斥锁和自旋锁有什么区别"></a>4.互斥锁和自旋锁有什么区别</h1><ul><li>互斥锁是在内核态进行阻塞等待</li><li>自旋锁是在用户态不断循环沦陷检测锁的状态</li></ul><p>如果使用场景是较长运行的共享资源，那么就使用互斥锁。避免自旋锁不断沦陷检测消耗大量CPU资源。</p><p>如果使用场景的共享资源访问速度快，那么可以使用自旋锁。避免互斥锁频繁进行用户、内核态的转换而造成消耗（这里指其他需要获取锁的进程得进入内核态阻塞等待）</p><h1 id="5-TCP三次握手除了序列号还发了什么其他东西？"><a href="#5-TCP三次握手除了序列号还发了什么其他东西？" class="headerlink" title="5.TCP三次握手除了序列号还发了什么其他东西？"></a>5.TCP三次握手除了序列号还发了什么其他东西？</h1><ul><li>SYN和ACK这些表记位（具体复习三次握手每个阶段的发送）</li><li>双方服务进程的端口号</li><li>起始序列号和对对方发送的SYN报文的应答序列号</li><li>TCP校验和</li><li>TCP窗口大小</li></ul><p>后续建立连接后，就会根据双方的窗口大小和数据的序列号开始相互通信。</p><h1 id="6-子类重写父类函数，子类中该函数声明为private，能否重写成功？"><a href="#6-子类重写父类函数，子类中该函数声明为private，能否重写成功？" class="headerlink" title="6.子类重写父类函数，子类中该函数声明为private，能否重写成功？"></a>6.子类重写父类函数，子类中该函数声明为private，能否重写成功？</h1><p>用下面这个毛坯房来进行测试，在默认情况下，我们子类的重写函数都和父类有相同的作用域声明符。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">test</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">foo1</span>();</span><br><span class="line"><span class="built_in">foo2</span>();</span><br><span class="line"><span class="built_in">foo3</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">foo1</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;A::foo1&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">foo2</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;A::foo2&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">foo3</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;A::foo3&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> : <span class="keyword">public</span> A</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">foo1</span>();</span><br><span class="line"><span class="built_in">foo2</span>();</span><br><span class="line"><span class="built_in">foo3</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">foo1</span><span class="params">()</span> <span class="keyword">override</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;B::foo1&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">foo2</span><span class="params">()</span> <span class="keyword">override</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;B::foo2&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">foo3</span><span class="params">()</span> <span class="keyword">override</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;B::foo3&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">B b;</span><br><span class="line">b.<span class="built_in">test</span>();</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;----&quot;</span> &lt;&lt; endl;</span><br><span class="line">A *bb = &amp;b;</span><br><span class="line">bb-&gt;<span class="built_in">test</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>直接运行，结果也符合预期，目前调用的是子类重写后的虚函数，所有函数都重写成功。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">B::foo1</span><br><span class="line">B::foo2</span><br><span class="line">B::foo3</span><br><span class="line">----</span><br><span class="line">B::foo1</span><br><span class="line">B::foo2</span><br><span class="line">B::foo3</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> : <span class="keyword">public</span> A</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">foo1</span>();</span><br><span class="line"><span class="built_in">foo2</span>();</span><br><span class="line"><span class="built_in">foo3</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">foo2</span><span class="params">()</span> <span class="keyword">override</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;B::foo2&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">foo3</span><span class="params">()</span> <span class="keyword">override</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;B::foo3&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">foo1</span><span class="params">()</span> <span class="keyword">override</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;B::foo1&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 编译能通过，运行输出和上方没区别</span></span><br></pre></td></tr></table></figure><p>我尝试了各种修改作用域的方式，包括将子类中foo3函数改成公有，foo1函数改成私有，都能正常完成重写。这里的作用域声明符只是会改变<strong>子类外是否能调用这个函数</strong>，和能否完成虚函数重写无关！</p><p>请注意，如果你将<strong>继承方式由public改成private</strong>，那么就无法在类外使用父类指针指向子类对象了</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">╰─ g++ test2.cpp -o test</span><br><span class="line">test2.cpp: In function ‘int main()’:</span><br><span class="line">test2.cpp:316:11: error: ‘A’ is an inaccessible base of ‘B’</span><br><span class="line">  A *bb = &amp;b;</span><br></pre></td></tr></table></figure><p>但这依旧不影响子类函数重写父类函数（我的依据是override关键字没有报错）</p><h1 id="7-pthread-create能传入类成员函数的指针吗"><a href="#7-pthread-create能传入类成员函数的指针吗" class="headerlink" title="7.pthread_create能传入类成员函数的指针吗"></a>7.pthread_create能传入类成员函数的指针吗</h1><p>可以，但是必须是静态成员函数。</p><p>如果是普通成员函数，那就需要用中间函数来处理，比如下面的示例代码。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span>* <span class="title">threadFunc</span><span class="params">(<span class="type">void</span>* arg)</span> </span>&#123;</span><br><span class="line">    std::function&lt;<span class="type">void</span>()&gt; func = *<span class="keyword">reinterpret_cast</span>&lt;std::function&lt;<span class="built_in">void</span>()&gt;*&gt;(arg);</span><br><span class="line">    <span class="built_in">func</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::function&lt;<span class="type">void</span>()&gt; myFunc = []() &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Hello from thread!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="type">pthread_t</span> thread;</span><br><span class="line">    <span class="built_in">pthread_create</span>(&amp;thread, <span class="literal">nullptr</span>, &amp;threadFunc, <span class="built_in">reinterpret_cast</span>&lt;<span class="type">void</span>*&gt;(&amp;myFunc));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 等待线程结束</span></span><br><span class="line">    <span class="built_in">pthread_join</span>(thread, <span class="literal">nullptr</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们可以用<code>std::function</code>包装一个类的成员函数，并用<code>std::bind</code>将对象的this指针绑定到第一个参数上。外层再套上一个用于执行该函数的void函数，就能传给<code>pthread_create</code>。</p><p><code>std::function</code>的对象不能直接传给C语言的函数指针，即便参数对应。会报错。</p><h1 id="8-函数内static变量的作用"><a href="#8-函数内static变量的作用" class="headerlink" title="8.函数内static变量的作用"></a>8.函数内static变量的作用</h1><p>在函数内定义一个static变量，该变量只会在进入这个函数的时候初始化一次。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 计算某一月的1号是一年的第几天(不考虑闰年)</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">DayOfYear</span><span class="params">(<span class="type">int</span> month)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> day_array = &#123;<span class="number">0</span>,<span class="number">31</span>,<span class="number">59</span>,<span class="number">90</span>,<span class="number">120</span>,<span class="number">151</span>,<span class="number">181</span>,<span class="number">212</span>,<span class="number">243</span>,<span class="number">273</span>,<span class="number">304</span>,<span class="number">334</span>&#125;;</span><br><span class="line">    <span class="keyword">return</span> day_array[month];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>比如上面的函数，我们定义的day数组就只会在第一次进入这个函数的时候初始化。之后进入这个函数将不在初始化，就节省了初始化一个数组的消耗。出了这个函数后，该数组变量依旧存在。</p><p>请注意，这个static语句并不只是变量只初始化一次，实际上这一行语句在该函数中都只会进行一次</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="title function_">checkFlag</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">static</span> <span class="type">bool</span> flag = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span>(!flag)&#123;</span><br><span class="line">        <span class="comment">// ..进行对应修改</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>比如上面的代码中，如果用正常思维来理解，你会觉得这个if语句每次都会判断为真而进入其中。但实际上flag的定义只会被定义一次，<strong>只要我们在if中将其改成了true</strong>，那么下一次进入该函数的时候，<strong>flag依旧会是true</strong>，<code>static bool flag = false;</code>语句会被直接跳过，并不会再次执行赋值！</p><p>我之前理解的就是flag变量只会被创建一次，但static后的赋值依旧会执行。这个理解是<strong>错误</strong>的！</p>]]></content>
    
    
    <summary type="html">C++面筋记录 (一) 231021</summary>
    
    
    
    <category term="求职路上一去不复返" scheme="https://blog.musnow.top/categories/%E6%B1%82%E8%81%8C%E8%B7%AF%E4%B8%8A%E4%B8%80%E5%8E%BB%E4%B8%8D%E5%A4%8D%E8%BF%94/"/>
    
    
    <category term="面经" scheme="https://blog.musnow.top/tags/%E9%9D%A2%E7%BB%8F/"/>
    
  </entry>
  
  <entry>
    <title>【Linux】wsl安装的ubuntu不支持POSIX消息队列 | 已解决</title>
    <link href="https://blog.musnow.top/posts/4006913293/"/>
    <id>https://blog.musnow.top/posts/4006913293/</id>
    <published>2023-10-17T04:30:55.000Z</published>
    <updated>2023-10-17T04:30:55.000Z</updated>
    
    <content type="html"><![CDATA[<p>wsl安装的ubuntu不支持POSIX消息队列的解决办法</p><span id="more"></span><h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2023/10/f317c38d511b44a48ff5dc5df48b1c80.png"></p><p>如题，我的win10上安装了wsl的ubuntu后（微软商店下载的wsl的Ubuntu）这个系统内部不支持POSIX的消息队列，虽然有<code>&lt;mqueue.h&gt;</code>头文件，但是没有实现，会报错。</p><p>如果想找个简单的办法呢，那就是用systemV的消息队列，可这是个<strong>虚拟机本地环境问题</strong>，我用virtualbox安装的虚拟机就能正常使用。所以肯定得解决这个问题，换成systemV的消息队列就有点「掩耳盗铃」的意味了。</p><h1 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h1><p>下面是一个POSIX消息队列的demo</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mqueue.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">mqd_t</span> mqID;</span><br><span class="line">    mqID = <span class="built_in">mq_open</span>(<span class="string">&quot;/testmQueue&quot;</span>, O_RDWR | O_CREAT, <span class="number">0666</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (mqID &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;open message queue error...&quot;</span>&lt;&lt;<span class="built_in">strerror</span>(errno)&lt;&lt;endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mq_attr mqAttr;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">mq_getattr</span>(mqID, &amp;mqAttr) &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;get the message queue attribute error&quot;</span>&lt;&lt;endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;mq_flags:&quot;</span>&lt;&lt;mqAttr.mq_flags&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;mq_maxmsg:&quot;</span>&lt;&lt;mqAttr.mq_maxmsg&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;mq_msgsize:&quot;</span>&lt;&lt;mqAttr.mq_msgsize&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;mq_curmsgs:&quot;</span>&lt;&lt;mqAttr.mq_curmsgs&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果编译后运行出现了下面的报错，代表当前系统不支持POSIX消息队列。当前系统下有mqueue头文件，但并没有函数的实现体</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">root@DESKTOP-5SQO6N0:~# ./test</span><br><span class="line">open message queue error...No such file or directory</span><br><span class="line">open message queue error...Function not implemented</span><br></pre></td></tr></table></figure><h1 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h1><p>需要将wsl版本1改成版本2，否则无完整Linux内核支持，无法使用POSIX消息队列。<strong>这也是WSL版本1和2的重大区别之一</strong>。</p><p>用如下命令将当前虚拟机改成wsl2版本，就可以使用了。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">wsl -l -v # 用这个命令查看当前虚拟机的version是不是1</span><br><span class="line">wsl --update # 更新wsl</span><br><span class="line">wsl --set-version 虚拟机名 2  # 把指定虚拟机改成wsl版本2</span><br></pre></td></tr></table></figure><h2 id="再次测试"><a href="#再次测试" class="headerlink" title="再次测试"></a>再次测试</h2><p>正常情况下，上面的消息队列代码应该输出如下内容</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">root@DESKTOP-5SQO6N0:~# ./test</span><br><span class="line">mq_flags:0</span><br><span class="line">mq_maxmsg:10</span><br><span class="line">mq_msgsize:8192</span><br><span class="line">mq_curmsgs:0</span><br></pre></td></tr></table></figure><h2 id="绑定目录"><a href="#绑定目录" class="headerlink" title="绑定目录"></a>绑定目录</h2><p>除了上面这个问题，在使用消息队列之前还可以monut一下路径，参考man手册中的教程（似乎不是必须要做的，mount了这个路径之后能更好地看到现有的消息队列）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mkdir /dev/mqueue</span><br><span class="line">mount -t mqueue none /dev/mqueue</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">wsl安装的ubuntu不支持POSIX消息队列的解决办法</summary>
    
    
    
    <category term="玩上Linux" scheme="https://blog.musnow.top/categories/%E7%8E%A9%E4%B8%8ALinux/"/>
    
    
    <category term="Linux" scheme="https://blog.musnow.top/tags/Linux/"/>
    
    <category term="虚拟机" scheme="https://blog.musnow.top/tags/%E8%99%9A%E6%8B%9F%E6%9C%BA/"/>
    
  </entry>
  
  <entry>
    <title>【微机】DOSBox在windows上的安装和masm的配置</title>
    <link href="https://blog.musnow.top/posts/2839269095/"/>
    <id>https://blog.musnow.top/posts/2839269095/</id>
    <published>2023-10-16T17:49:13.000Z</published>
    <updated>2023-10-16T17:49:13.000Z</updated>
    
    <content type="html"><![CDATA[<p>最近学校学习微型计算机原理与接口技术，需要用到DOSBox来模拟DOS环境进行汇编编程的学习。</p><p>本文记录了如何在windows11&#x2F;10上安装<code>DOSBox0.74</code>并配置<code>masm5</code></p><h1 id="1-安装"><a href="#1-安装" class="headerlink" title="1.安装"></a>1.安装</h1><p>这两个软件我打包上传到了百度云盘。放心，加起来也就2mb，下载应该不会很久</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">链接: https://pan.baidu.com/s/1vjbSL7iwP8WpMVA9K505ZA</span><br><span class="line">提取码: kr4x</span><br></pre></td></tr></table></figure><h2 id="1-1-DOSBox"><a href="#1-1-DOSBox" class="headerlink" title="1.1 DOSBox"></a>1.1 DOSBox</h2><p>点击<code>DOSBox0.74</code>的安装包，无脑下一步安装即可</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2023/10/4ef1475a8016a019d58a90bd6845e70d.png" alt="image-20231017015458406"></p><p>安装出来的图标如下</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2023/10/cc5f29112bed916bb978c49a9a23636d.png" alt="image-20231017015529621"></p><h2 id="1-2-masm5"><a href="#1-2-masm5" class="headerlink" title="1.2 masm5"></a>1.2 masm5</h2><p>找一个空的文件夹，文件路径中不能包含空格、特殊字符和中文，将<code>masm5.zip</code>中的文件全部解压到这个文件夹中，如下图</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2023/10/21d3adc3a7e767d3aa3d0eba69df75e9.png" alt="image-20231017015700958"></p><p>随后修改DOSBox软件的配置文件，右键桌面上Dosbox软件的快捷图标，选择<code>打开文件所在位置</code>找到DOSBox软件的安装路径，点击<code>DOSBox 0.74 Options.bat</code>文件，稍等片刻，会以记事本的方式打开配置文件。</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2023/10/06f84cbaea8c2c0380807a61e01f1a7d.png" alt="image-20231017015801923"></p><p>拉到配置文件最底下，新增如下配置。你只需要修改<code>D:\GAME\masm</code>为你的masm5文件的解压目录就行了。这个文件路径中不能有空格，也不能有特殊字符和中文！</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">MOUNT C D:\GAME\masm</span><br><span class="line">path=%path%; \masm</span><br><span class="line">C: </span><br><span class="line">cd \asm</span><br></pre></td></tr></table></figure><p>配置完成后，启动DOSbox，查看masm命令是否能正常使用。如图所示，没有报错masm命令不存在，那么就是配置好了。</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2023/10/62cba64fa60c2fd957b5968d4387109b.png" alt="image-20231017020002774"></p><h1 id="2-修改DOSBox窗口大小"><a href="#2-修改DOSBox窗口大小" class="headerlink" title="2.修改DOSBox窗口大小"></a>2.修改DOSBox窗口大小</h1><p>默认情况下DOSBox的命令行窗口是非常非常非常小的，我们需要将其改大。同样是修改DOSBox的配置文件，如何打开配置文件参考上文。</p><p>按下图所示修改</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2023/10/2b5bab3f2fc1dbb0a766659d1eb51130.png" alt="image-20231017020347782"></p><p>请注意，这里的1280和1080中间的是大写的X，并不是乘号</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">windowresolution=1280X1080</span><br><span class="line">output=opengl</span><br></pre></td></tr></table></figure><p>修改了之后保存，再重新打开DOSBox，界面就应该会变大了。如果你觉得还是小了，可以修改这里的分辨率，继续让他变大一点。</p><h1 id="3-编译一个汇编程序"><a href="#3-编译一个汇编程序" class="headerlink" title="3.编译一个汇编程序"></a>3.编译一个汇编程序</h1><p>用下面最简单的汇编程序做测试，将如下内容写入到<code>test.asm</code>中，并放入和masm的同一目录下（必须要是同一目录）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">CODE SEGMENT ;USE16</span><br><span class="line">     ASSUME CS:CODE</span><br><span class="line">BEG: MOV DL,&#x27;H&#x27;</span><br><span class="line">     MOV AH, 2 ; 调用2号DOS系统调用输出字符到屏幕上</span><br><span class="line">     INT 21H</span><br><span class="line">     MOV AH, 4CH</span><br><span class="line">     INT 21H</span><br><span class="line">CODE  ENDS</span><br><span class="line">        END BEG</span><br></pre></td></tr></table></figure><p>打开DOSBox，输入如下命令</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">masm test.asm</span><br><span class="line">link test.obj</span><br></pre></td></tr></table></figure><p>输出如下图所示，第一个命令的作用是编译源文件（注意看有没有编译报错）；第二个命令的作用是链接obj文件，最终会弹出来一个警告，不用管他。</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2023/10/60d8190bb6bda5b544018ce777909c0f.png" alt="image-20231017020903839"></p><p>最终执行test，成功输出字符H到终端上。</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2023/10/8cace87b33fc71a4387afa5d7765e8a4.png" alt="image-20231017020946832"></p><p>能走到这一步，就代表你的masm基本环境已经配置好了。可以用来编译运行汇编代码了</p>]]></content>
    
    
    <summary type="html">DOSBox在windows上的安装和masm的配置</summary>
    
    
    
    <category term="差生文具多" scheme="https://blog.musnow.top/categories/%E5%B7%AE%E7%94%9F%E6%96%87%E5%85%B7%E5%A4%9A/"/>
    
    
    <category term="win" scheme="https://blog.musnow.top/tags/win/"/>
    
  </entry>
  
  <entry>
    <title>【Linux】ubuntu/centos8安装zsh终端</title>
    <link href="https://blog.musnow.top/posts/2565866661/"/>
    <id>https://blog.musnow.top/posts/2565866661/</id>
    <published>2023-10-15T09:12:55.000Z</published>
    <updated>2023-10-15T09:12:55.000Z</updated>
    
    <content type="html"><![CDATA[<p>根据这篇知乎文章进行 <a href="https://zhuanlan.zhihu.com/p/514636147">https://zhuanlan.zhihu.com/p/514636147</a></p><h1 id="1-安装zsh"><a href="#1-安装zsh" class="headerlink" title="1.安装zsh"></a>1.安装zsh</h1><p>先安装zsh并设置为默认的终端</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># ubuntu</span></span><br><span class="line">sudo apt install zsh</span><br><span class="line"><span class="comment"># centos </span></span><br><span class="line">sudo yum install zsh util-linux-user</span><br><span class="line"><span class="comment"># 通用</span></span><br><span class="line">chsh -s /bin/zsh</span><br></pre></td></tr></table></figure><blockquote><p>如果centos下找不到chsh命令，参考此博客：<a href="https://blog.csdn.net/FungLeo/article/details/99448425">https://blog.csdn.net/FungLeo/article/details/99448425</a></p></blockquote><p>然后安装oh-my-zsh，这是一个大佬在github上开源的一个zsh配置项，相对方便点</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget --no-check-certificate https://github.com/robbyrussell/oh-my-zsh/raw/master/tools/install.sh -O - | sh </span><br></pre></td></tr></table></figure><p>如果github连不上就用gitee，如果你用的是子用户，那么<strong>这个命令不要用sudo权限执行</strong>！否则后续子用户会因为权限问题没办法使用。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sh -c <span class="string">&quot;<span class="subst">$(curl -fsSL https://gitee.com/shmhlsy/oh-my-zsh-install.sh/raw/master/install.sh)</span>&quot;</span></span><br></pre></td></tr></table></figure><p>最终出现如图所示的界面就是安装成功了。</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2023/10/5ebc935468a46d95ac77e65dc879c66d.png" alt="image-20231015205326739"></p><h1 id="2-安装zsh插件"><a href="#2-安装zsh插件" class="headerlink" title="2.安装zsh插件"></a>2.安装zsh插件</h1><p>安装这两个最常用的插件就可以了</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># zsh-autosuggestions 命令行命令键入时的历史命令建议</span></span><br><span class="line">git <span class="built_in">clone</span> https://github.com/zsh-users/zsh-autosuggestions <span class="variable">$&#123;ZSH_CUSTOM:-~/.oh-my-zsh/custom&#125;</span>/plugins/zsh-autosuggestions</span><br><span class="line"><span class="comment"># zsh-syntax-highlighting 命令行语法高亮插件</span></span><br><span class="line">git <span class="built_in">clone</span> https://gitee.com/Annihilater/zsh-syntax-highlighting.git <span class="variable">$&#123;ZSH_CUSTOM:-~/.oh-my-zsh/custom&#125;</span>/plugins/zsh-syntax-highlighting</span><br></pre></td></tr></table></figure><p>这个历史命令建议的插件是用方向键👉来进行补全的，不要和我一样傻乎乎按tab。</p><h1 id="3-配置文件和主题"><a href="#3-配置文件和主题" class="headerlink" title="3.配置文件和主题"></a>3.配置文件和主题</h1><p>原文中的配置文件有很多地方都不对劲，需要我们修改；</p><p>首先是<code>oh-my-zsh</code>的安装路径，需要改成你的用户家目录下，然后需要先安装一下<code>powerlevel10k</code>主题，这个主题很好用！</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> --depth=1 https://gitee.com/romkatv/powerlevel10k.git <span class="variable">$&#123;ZSH_CUSTOM:-<span class="variable">$HOME</span>/.oh-my-zsh/custom&#125;</span>/themes/powerlevel10k</span><br></pre></td></tr></table></figure><p>配置文件<code>~/.zshrc</code>改成如下内容（建议将原本的配置文件cp备份一下）其中的zsh安装路径一定要修改，否则无法正常配置！</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 防止中文乱码</span></span><br><span class="line"><span class="built_in">export</span> LC_ALL=en_US.UTF-8</span><br><span class="line"><span class="built_in">export</span> LANG=en_US.UTF-8</span><br><span class="line"><span class="comment"># oh-my-zsh的安装路径（zsh的配置路径）</span></span><br><span class="line">ZSH=<span class="string">&quot;/home/你的用户名/.oh-my-zsh&quot;</span></span><br><span class="line"><span class="comment"># ZSH_THEME=&quot;robbyrussell&quot;</span></span><br><span class="line"><span class="comment"># 设置字体模式以及配置命令行的主题</span></span><br><span class="line">POWERLEVEL9K_MODE=<span class="string">&#x27;nerdfont-complete&#x27;</span></span><br><span class="line"><span class="comment"># ZSH_THEME=&quot;agnoster&quot;</span></span><br><span class="line">ZSH_THEME=<span class="string">&quot;powerlevel10k/powerlevel10k&quot;</span> <span class="comment"># 主题推荐这个，需要进行安装</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 启动错误命令自动更正</span></span><br><span class="line">ENABLE_CORRECTION=<span class="string">&quot;true&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 在命令执行的过程中，使用小红点进行提示</span></span><br><span class="line">COMPLETION_WAITING_DOTS=<span class="string">&quot;true&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 配置要使用的插件</span></span><br><span class="line">plugins=(</span><br><span class="line">        git</span><br><span class="line">        extract</span><br><span class="line">        zsh-autosuggestions</span><br><span class="line">        zsh-syntax-highlighting</span><br><span class="line">)</span><br><span class="line"><span class="built_in">source</span> <span class="variable">$ZSH</span>/oh-my-zsh.sh</span><br><span class="line"><span class="built_in">source</span> <span class="variable">$ZSH_CUSTOM</span>/plugins/zsh-autosuggestions/zsh-autosuggestions.zsh</span><br><span class="line"><span class="comment"># python虚拟环境相关设置</span></span><br><span class="line"><span class="keyword">if</span> [ -f /usr/local/bin/virtualenvwrapper.sh ];</span><br><span class="line"><span class="keyword">then</span></span><br><span class="line">    <span class="built_in">export</span> WORKON_HOME=<span class="variable">$HOME</span>/.virtualenvs</span><br><span class="line">    <span class="built_in">export</span> VIRTUALENVWRAPPER_PYTHON=/usr/bin/python3</span><br><span class="line">    <span class="built_in">source</span> /usr/local/bin/virtualenvwrapper.sh</span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure><p>改好了之后，启用他，然后就可以了；执行下方命令后，就会自动弹出<code>powerlevel10k</code>主题的配置引导过程。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">source ~/.zshrc</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2023/10/684bc428ce3e1369d8d60997845180a8.png" alt="image-20231015205703586"></p><p>如果设置完毕后，你对<code>powerlevel10k/powerlevel10k</code>的配置又不满意了，可以执行如下命令重新配置</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">p10k configure</span><br></pre></td></tr></table></figure><p>你可能也会遇到如下报错，原因未知，但似乎不影响使用</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">❯ ls</span><br><span class="line">_p9k_worker_stop:zle:4: No handler installed for fd 12</span><br><span class="line">_p9k_worker_stop:5: failed to close file descriptor 12: bad file descriptor</span><br></pre></td></tr></table></figure><p>如上报错解决办法参考github的issue内的说明</p><p><a href="https://github.com/romkatv/powerlevel10k/issues/1554">https://github.com/romkatv/powerlevel10k/issues/1554</a></p><p>在配置文件<code>.zshrc</code>的末尾加上下面这一行，然后source让其生效就可以了</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">unset ZSH_AUTOSUGGEST_USE_ASYNC</span><br></pre></td></tr></table></figure><h1 id="4-使用小技巧"><a href="#4-使用小技巧" class="headerlink" title="4.使用小技巧"></a>4.使用小技巧</h1><p>输入命令的时候键入tab，会弹出一些命令的提示</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2023/10/486730657def543552dc7a82163410e9.png" alt="image-20231015210623737"></p><p>输入之前写过的命令的时候，会出现历史命令提示，使用方向键右👉就可以补全这个命令</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2023/10/eb1e448943c27dd0bdeb29267b26d252.png" alt="image-20231015210708230"></p><p>zsh主要就是这一点非常的方便，至于会不会和默认的<code>/bin/bash</code>有性能差异，那就不知道了。</p><p>另外，在zsh终端中直接重定向会卡住，如下命令就会阻塞掉。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt; 文本文件</span><br></pre></td></tr></table></figure><p>所以要用echo（一般我是用来清空某个文本文件）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo &gt; 文本文件</span><br></pre></td></tr></table></figure><h1 id="5-zsh安装后git中文乱码"><a href="#5-zsh安装后git中文乱码" class="headerlink" title="5.zsh安装后git中文乱码"></a>5.zsh安装后git中文乱码</h1><p>安装zsh后用<code>git log</code>查看提交信息的时候发现中文乱码。</p><h2 id="5-1-修改zsh配置文件"><a href="#5-1-修改zsh配置文件" class="headerlink" title="5.1 修改zsh配置文件"></a>5.1 修改zsh配置文件</h2><p>其实上文中提到的配置文件里面已经有这两个配置项了，说明问题不在这里</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># 防止中文乱码</span><br><span class="line">export LC_ALL=en_US.UTF-8</span><br><span class="line">export LANG=en_US.UTF-8</span><br></pre></td></tr></table></figure><h2 id="5-2-执行git配置"><a href="#5-2-执行git配置" class="headerlink" title="5.2 执行git配置"></a>5.2 执行git配置</h2><p>一篇博客说要执行下面的git命令，也没有用</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">git config --global core.quotepath false </span><br><span class="line">git config --global gui.encoding utf-8 </span><br><span class="line">git config --global i18n.commit.encoding utf-8 </span><br><span class="line">git config --global i18n.logoutputencoding utf-8 </span><br><span class="line">set LESSCHARSET=utf-8</span><br></pre></td></tr></table></figure><h2 id="5-3-修改系统字符配置"><a href="#5-3-修改系统字符配置" class="headerlink" title="5.3 修改系统字符配置"></a>5.3 修改系统字符配置</h2><p>另外一篇博客说要修改系统的字符集配置，如下环境变量</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">export LESSCHARSET=utf-8</span><br></pre></td></tr></table></figure><p>执行后确实ok了，可以编辑<code>/etc/profile</code>文件，在该文件末尾追加如下内容让其始终生效</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">export LESSCHARSET=utf-8</span><br></pre></td></tr></table></figure><p>随后用source命令刷新这个配置文件即可。</p><h1 id="6-粘贴文本很慢的问题"><a href="#6-粘贴文本很慢的问题" class="headerlink" title="6.粘贴文本很慢的问题"></a>6.粘贴文本很慢的问题</h1><p>参考 <a href="https://github.com/zsh-users/zsh-autosuggestions/issues/238">zsh-users&#x2F;zsh-autosuggestions&#x2F;issues&#x2F;238</a> 解决这个问题</p><p>在<code>.zshrc</code>之后添加如下配置项</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"># This speeds up pasting w/ autosuggest</span><br><span class="line"># https://github.com/zsh-users/zsh-autosuggestions/issues/238</span><br><span class="line">pasteinit() &#123;</span><br><span class="line">  OLD_SELF_INSERT=$&#123;$&#123;(s.:.)widgets[self-insert]&#125;[2,3]&#125;</span><br><span class="line">  zle -N self-insert url-quote-magic # I wonder if you&#x27;d need `.url-quote-magic`?</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">pastefinish() &#123;</span><br><span class="line">  zle -N self-insert $OLD_SELF_INSERT</span><br><span class="line">&#125;</span><br><span class="line">zstyle :bracketed-paste-magic paste-init pasteinit</span><br><span class="line">zstyle :bracketed-paste-magic paste-finish pastefinish</span><br></pre></td></tr></table></figure><p>配置了之后，source使其生效。</p><p>这时候在终端里面粘贴内容的时候，就不会一个一个字符地打印出来了。那样实在是太慢了。</p>]]></content>
    
    
    <summary type="html">ubuntu/centos8虚拟机安装zsh终端</summary>
    
    
    
    <category term="玩上Linux" scheme="https://blog.musnow.top/categories/%E7%8E%A9%E4%B8%8ALinux/"/>
    
    
    <category term="Linux" scheme="https://blog.musnow.top/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>【虚拟机】WIN11的WSL安装CentOS8Stream虚拟机</title>
    <link href="https://blog.musnow.top/posts/4065446782/"/>
    <id>https://blog.musnow.top/posts/4065446782/</id>
    <published>2023-10-15T03:30:55.000Z</published>
    <updated>2023-10-15T03:30:55.000Z</updated>
    
    <content type="html"><![CDATA[<p>本人所使用的系统是 <code>win11 22H2 家庭版</code>，如果你不是非CentOS不可，强烈建议直接去微软应用商店里面下载Ubuntu，全自动安装到WSL，啥都不用管。(就是好像没办法选择安装路径)</p><h1 id="1-启用WSL"><a href="#1-启用WSL" class="headerlink" title="1.启用WSL"></a>1.启用WSL</h1><p>刚开始安装WSL的时候，参考的是<a href="https://blog.csdn.net/qq_38442140/article/details/120724215">这个博客</a>。说实话，我个人并不喜欢这篇博客。因为里面遗漏了很多东西，并且在不恰当的位置贴出了命令，导致读者会误以为是需要执行这些命令。</p><p>比如我就理解错误，先执行了设置wsl默认版本为2的命令，<strong>这个命令先不要执行</strong>！后文会告诉你为什么。</p><p>这篇博客中对开启wsl的设置的位置描述也不完全，看上去像从网上哪里抄过来的win10的设置逻辑（win11的位置完全不一样）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">该博客原文：在windows设置中打开【启用或关闭Windwos功能】，勾选【适用于Linux的Windwos子系统】，点击确定后会系统会提示重启，选择确认即可</span><br></pre></td></tr></table></figure><p>实际上在win11中，需要多点好几个地方才能找到这个设置的位置</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">右键桌面 - 个性化 - 进入win11设置界面 - 应用 - 可选功能 - (往下滑)更多windows功能</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2023/10/542d2e77f4272f4598629626e44ee2a7.png" alt="image-20231015104701566"></p><blockquote><p>这都是我对一个<strong>不完善博客</strong>的吐槽，但并没有贬低这个教程的意思啊！至少他告诉我基本步骤应该做哪些。</p><p>为什么我要吐槽呢？因为这种写的不全的博客经常会让读者得去重新搜索某些设置的位置，而作者明明是已经走过这个流程的。博客里面作者的截图明显是windows11，但他提供的设置却是win10中的旧位置。多花30秒写清楚位置并带上截图，不知道能节省读者多少时间……如果你体会过查资料的时候阅读这些「断头短尾」的博客，应该也能体会到我的心情。</p></blockquote><p>回到正题。在更多 windows 功能选项框中（win10&#x2F;11的这个选项框基本相同），勾选上下面的几个选项，三个都要勾选上！</p><ul><li>适用于 Linux 的 Windows 子系统</li><li>虚拟机平台</li><li>windows 虚拟机监控程序平台</li></ul><p>点击确定，就成功启用了 WSL。系统会弹出一个进度条，下载一些东西。</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2023/10/61b796407e655ae94c7ff535edaeae69.png" alt="image-20231015104951463"></p><p>处理完毕后，WIN+R输入cmd，打开命令行工具，在命令行工具中输入<code>wsl -l -v</code>命令，有相关输出就是启用成功了！</p><p>初始化情况下，执行这个命令，应该会提示你当前什么虚拟机都没有安装。</p><h1 id="2-安装Centos8"><a href="#2-安装Centos8" class="headerlink" title="2.安装Centos8"></a>2.安装Centos8</h1><h2 id="2-1-下载系统zip"><a href="#2-1-下载系统zip" class="headerlink" title="2.1 下载系统zip"></a>2.1 下载系统zip</h2><p>去 <a href="https://github.com/wsldl-pg/CentWSL/releases/tag/8.1.1911.1">github&#x2F;wsldl-pg&#x2F;CentWSL</a> 上下载适用于wsl的<code>CentOS8</code>系统的zip</p><blockquote><p>这个也可以：<a href="https://github.com/mishamosher/CentOS-WSL">https://github.com/mishamosher/CentOS-WSL</a></p></blockquote><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2023/10/c42449d2875a2e60a296953f2bfcfae8.png" alt="image-20231015104110576"></p><p>把zip解压到你想安装虚拟机的位置（一定要是一个空文件夹），然后右键<code>CentOS8.exe</code>，以管理员身份运行。</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2023/10/a13a0b3e0db1dab54e499c9c7bf5ddc6.png" alt="image-20231015104455537"></p><h2 id="2-2-报错HRESULT-0x80370102解决"><a href="#2-2-报错HRESULT-0x80370102解决" class="headerlink" title="2.2 报错HRESULT:0x80370102解决"></a>2.2 报错HRESULT:0x80370102解决</h2><p>安装CentOS8的时候，就遇到了这个<strong>issue</strong>中的问题👇</p><p><a href="https://github.com/wsldl-pg/CentWSL/issues/36">github.com&#x2F;wsldl-pg&#x2F;CentWSL&#x2F;issues&#x2F;36</a></p><p>用管理员身份运行<code>CentOS8.exe</code>之后，弹出的终端会输出如下内容</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ERROR:Installation Failed!</span><br><span class="line">HRESULT:0x80370102</span><br></pre></td></tr></table></figure><p>根据<a href="https://github.com/wsldl-pg/CentWSL/issues/36">该issue</a> 中最后一个回复的解决办法，我先将wsl版本设置回了1（这就是为什么前文说不要先设置为默认wsl2）</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2023/10/d19e82cbafe8e5eba20d8c6eef64687a.png" alt="image-20231015112649042"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wsl --set-default-version 1</span><br></pre></td></tr></table></figure><p>重复如上安装步骤（以管理员身份运行<code>CentOS8.exe</code>），就成功安装了虚拟机。在win11的文件管理器左侧会多出来一个Linux图标，里面有CentOS8的系统里面的文件。</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2023/10/721c72e099c746ab5f618282dc205e27.png" alt="image-20231015105247440"></p><p>在windows的powershell或者cmd中，输入<code>wsl</code>，就可以进入CentOS8的bash；见下图，我们已经成功安装好了一个CentOS8的虚拟机。内部的文件就是CentOS8系统的默认文件。</p><p>在内部执行<code>exit</code>命令，就可以退出wsl虚拟机，回到windows的终端下。</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2023/10/fa9eb9786e59758af270ae93f120ed51.png" alt="image-20231015105338512"></p><p>而且WSL有个最大的好处，就是它能自动挂载windows下的文件到<code>/mnt</code>目录下，这个目录里面可以看到我的win11宿主机的3个硬盘分区；windows的文件资源管理器里面也可以看到Linux中的文件，<strong>方便我们在windows和linux下互传文件</strong>（就不需要用sftp工具了）</p><p>特别是如果你需要写带Doxygen文档的项目，在生成Doxygen的html后，就能直接从这里在windows的浏览器中打开网页，而不需要用sftp或者其他工具传到windows下再打开了！</p><blockquote><p>当然，你也可以用带GUI的Linux系统来解决这个问题。</p></blockquote><h2 id="2-3-更新为WSL2"><a href="#2-3-更新为WSL2" class="headerlink" title="2.3 更新为WSL2"></a>2.3 更新为WSL2</h2><p>使用<code>wsl -l -v</code>命令，可以看到当前运行的wsl虚拟机，版本是1</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">PS C:\Users\S2522\Desktop&gt; wsl -l -v</span><br><span class="line">  NAME       STATE           VERSION</span><br><span class="line">* CentOS8    Running         1</span><br></pre></td></tr></table></figure><p>我们可以将其升级为WSL2版本，但是这里会告诉你需要更新内核组件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">PS C:\Users\S2522\Desktop&gt; wsl --set-version CentOS8 2</span><br><span class="line">正在进行转换，这可能需要几分钟时间...</span><br><span class="line">有关与 WSL 2 的主要区别的信息，请访问 https://aka.ms/wsl2</span><br><span class="line">WSL 2 需要更新其内核组件。有关信息，请访问 https://aka.ms/wsl2kernel</span><br></pre></td></tr></table></figure><p>那就更新呗！<a href="https://aka.ms/wsl2kernel">微软官方文档</a> 中会告诉你需要 <code>wsl.exe --install</code> 或 <code>wsl.exe --update</code>命令。</p><p>这里我执行了<code>wsl --update</code>命令，执行后会弹窗要你提供管理权限，并出现一个进度条，等他跑完就行。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">PS C:\Users\S2522\Desktop&gt; wsl --update</span><br><span class="line">正在安装: 适用于 Linux 的 Windows 子系统</span><br><span class="line">已安装 适用于 Linux 的 Windows 子系统。</span><br></pre></td></tr></table></figure><p>更新好了，再重新执行<code>wsl --set-version CentOS8 2</code>升级命令，会提示你正在执行转换，需要等待一会。</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2023/10/a870772fe8f185d55935bb2eb1d720d3.png" alt="image-20231015105730332"></p><p>最终成功转换了，使用命令<code>wsl -l -v</code>里面显示的版本也是2了。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">PS C:\Users\S2522\Desktop&gt; wsl --set-version CentOS8 2</span><br><span class="line">有关与 WSL 2 关键区别的信息，请访问 https://aka.ms/wsl2</span><br><span class="line"></span><br><span class="line">正在进行转换，这可能需要几分钟时间。</span><br><span class="line">操作成功完成。</span><br><span class="line">PS C:\Users\S2522\Desktop&gt; wsl -l -v</span><br><span class="line">  NAME       STATE           VERSION</span><br><span class="line">* CentOS8    Stopped         2</span><br></pre></td></tr></table></figure><p>搞定！现在我们就有一个方便的CentOS8的WSL环境啦！</p><p>可以用如下命令，将当前的CentOS8设置为默认的wsl虚拟机。这样在windows命令行中执行wsl或者bash命令，就能直接进入CentOS8中。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wslconfig /setdefault CentOS8</span><br></pre></td></tr></table></figure><p>重启电脑后，在powershell的下拉栏中会自动出现CentOS8的选项，点击它也能进入wsl虚拟机环境中。</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2023/10/e40e68ef976f8ef57c9f73d03a8dc892.png" alt="image-20231015134927313"></p><h1 id="3-解决yum报错问题"><a href="#3-解决yum报错问题" class="headerlink" title="3.解决yum报错问题"></a>3.解决yum报错问题</h1><p>因为这个CentOS的镜像是最小安装版本（类似于Docker安装的CentOS），所以内部的yum源都是坏掉的。执行<code>yum update</code>会出现如下报错。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@7945R9P ~]# yum -y update</span><br><span class="line">Failed to set locale, defaulting to C.UTF-8</span><br><span class="line">CentOS-8 - AppStream                                                                     68  B/s |  38  B     00:00</span><br><span class="line">Failed to download metadata for repo &#x27;AppStream&#x27;</span><br><span class="line">Error: Failed to download metadata for repo &#x27;AppStream&#x27;</span><br></pre></td></tr></table></figure><p>这时候需要进行yum源的重新设置，参考本站博客解决这个问题就行</p><p> <a href="https://blog.musnow.top/posts/1296728696/">【Docker】配置CentOS容器时出现 Error Failed to download metadata for repo ‘appstream’ Cannot prepare internal mirrorlist | 转载</a></p><p>搞定yum之后，就可以正常安装你想要的开发软件了。这个系统很轻量，sudo和passwd等很多完整系统会自带的命令都没有，需要自行安装一些。</p><p>另外，我写过一个CentOS8的初始化脚本，可以自动化安装一些软件，这里安装的软件并不一定是你想要的，请酌情参考：<a href="https://gitee.com/musnows/centos8-init">https://gitee.com/musnows/centos8-init</a></p><hr><p>而且，默认情况下的ls命令也没有颜色输出，需要修改bash配置来设置命令别名</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">alias</span> <span class="built_in">ls</span>=<span class="string">&#x27;ls --color=auto&#x27;</span></span><br></pre></td></tr></table></figure><p>你也可以根据自己的喜好，改成zsh或者其他终端。</p><h1 id="4-vscode连接"><a href="#4-vscode连接" class="headerlink" title="4.vscode连接"></a>4.vscode连接</h1><p>普通的虚拟机我们需要用vscode的remote ssh插件来连接，但是WSL主机我们直接用vsc的<strong>WSL插件</strong>来连接就行了，使用的效果和remote ssh插件是相同的</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2023/10/4211aec9f60b6984a3a680c1a900b5c8.png" alt="image-20231015111412100"></p><p>在左侧这个远程连接控制器中（和Remote ssh是同一个位置），找到上方的下拉条，改成WSL目标，就能看到我们的CentOS8虚拟机。点击连接它就可以了。</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2023/10/344e4ab417ab6246fa14351b211f016c.png" alt="image-20231015111429863"></p><p>但是vscode默认链接的是root用户，一般情况下肯定不会在root下写代码的。所以需要配置一下子用户</p><p>修改虚拟机中的<code>/etc/wsl.conf</code>文件，添加下面两行</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[user]</span><br><span class="line">default=用户名</span><br></pre></td></tr></table></figure><p>然后回到windows的命令行，重启wsl</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wsl --shutdown CentOS8</span><br></pre></td></tr></table></figure><p>再次启动wsl，这样vsc就能默认链接你的子用户了。</p><h1 id="5-修改wsl资源限制"><a href="#5-修改wsl资源限制" class="headerlink" title="5.修改wsl资源限制"></a>5.修改wsl资源限制</h1><p>默认情况下，<strong>wsl2的虚拟机能访问到完整的系统资源</strong>，包括所有CPU核心和内存。</p><p>这就会导致如果Linux下对一些东西进行了缓存而没有及时清理，Windows是没办法回收这部分内存的。<strong>最终就导致我们Windows宿主机没有足够的内存可用了</strong>，这怎么行？</p><blockquote><p>这种情况下，一般windows系统会把wsl直接给干掉，那我们虚拟机里面跑的活也没办法完成了。要知道，Linux可是很喜欢cache内存的，很容易会把宿主机的内存给干没。</p></blockquote><p>为了解决这个问题，我们需要设置wsl的虚拟机内存&#x2F;CPU限制。</p><p>在<strong>Linux下</strong>可以用这两个命令来查看cpu和内存的配置信息，刚开始的时候应该是和你的宿主机的CPU和内存一样。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cat</span> /proc/cpuinfo | grep processor <span class="comment"># 查看cpu核心数量</span></span><br><span class="line"><span class="built_in">cat</span> /proc/meminfo | grep Total     <span class="comment"># 查看内存信息</span></span><br></pre></td></tr></table></figure><p>在windows的<strong>C盘</strong>的<strong>用户文件夹</strong>下，创建一个<code>.wslconfig</code>文件，并在内部写入限制</p><ul><li>processors是cpu核数限制</li><li>memory和swap都是内存限制</li></ul><p>顶多设置为宿主机内存的一半，避免宿主机卡顿。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[wsl2]</span><br><span class="line">processors=8</span><br><span class="line">memory=8GB</span><br><span class="line">swap=8GB</span><br></pre></td></tr></table></figure><p>这个配置文件的路径是（windows下）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">C:\Users\你的用户名\.wslconfig</span><br></pre></td></tr></table></figure><p>随后在windows的终端中使用如下命令，终止这个wsl虚拟机</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">PS C:\Users\S2522\Desktop&gt; wsl --shutdown CentOS8</span><br><span class="line">PS C:\Users\S2522\Desktop&gt; wsl -l -v</span><br><span class="line">  NAME       STATE           VERSION</span><br><span class="line">* CentOS8    Stopped         2</span><br></pre></td></tr></table></figure><p>wsl命令中并没有<code>--start</code>选项，我们直接用wsl命令，就会自动重启并进入这个虚拟机。</p><p>这时候再在虚拟机内部看看CPU和内存信息，就可以看到你刚刚配置的性能限制结果了。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">[root@7945R9P ~]# cat /proc/cpuinfo | grep processor</span><br><span class="line">processor       : 0</span><br><span class="line">processor       : 1</span><br><span class="line">processor       : 2</span><br><span class="line">processor       : 3</span><br><span class="line">processor       : 4</span><br><span class="line">processor       : 5</span><br><span class="line">processor       : 6</span><br><span class="line">processor       : 7</span><br><span class="line">[root@7945R9P ~]# cat /proc/meminfo | grep Total</span><br><span class="line">MemTotal:        8136640 kB</span><br><span class="line">SwapTotal:       8388608 kB</span><br><span class="line">VmallocTotal:   34359738367 kB</span><br><span class="line">HugePages_Total:       0</span><br></pre></td></tr></table></figure><h2 id="删除wsl主机"><a href="#删除wsl主机" class="headerlink" title="删除wsl主机"></a>删除wsl主机</h2><p>删除虚拟机的命令如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wsl --unregister &lt;DistributionName&gt;</span><br></pre></td></tr></table></figure><p>更多命令参考微软官网 <a href="https://learn.microsoft.com/zh-cn/windows/wsl/basic-commands">https://learn.microsoft.com/zh-cn/windows/wsl/basic-commands</a></p><h1 id="6-启用systemctl"><a href="#6-启用systemctl" class="headerlink" title="6.启用systemctl"></a>6.启用systemctl</h1><p>我们的系统里面有systemctl命令，但是没有办法使用。网上有些教程说用service命令来替代，但CentOS中是没有service命令的。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@7945R9P bison-3.8]# systemctl</span><br><span class="line">System has not been booted with systemd as init system (PID 1). Can&#x27;t operate.</span><br><span class="line">Failed to connect to bus: Host is down</span><br></pre></td></tr></table></figure><h2 id="6-1-distrod-第三方工具"><a href="#6-1-distrod-第三方工具" class="headerlink" title="6.1 distrod 第三方工具"></a>6.1 distrod 第三方工具</h2><p>我们需要用distrod来安装systemctl的组件，才能成功启用它。具体教程参考github仓库的README中的介绍。不是很难</p><blockquote><p><a href="https://github.com/nullpo-head/wsl-distrod">https://github.com/nullpo-head/wsl-distrod</a></p></blockquote><p>先下载一个自动安装的脚本（连不上github会报ssl或者timeout错误，请使用其他办法下载这个脚本再丢到虚拟机里面去就行）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">curl -L -O &quot;https://raw.githubusercontent.com/nullpo-head/wsl-distrod/main/install.sh&quot;</span><br><span class="line">chmod +x install.sh</span><br><span class="line">sudo ./install.sh install</span><br></pre></td></tr></table></figure><p>然后用下面两个命令之一来启动（第一个命令是会在windows开机自动启动的）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">/opt/distrod/bin/distrod enable --start-on-windows-boot</span><br><span class="line">/opt/distrod/bin/distrod enable</span><br></pre></td></tr></table></figure><p>更多内容相见<a href="https://github.com/nullpo-head/wsl-distrod">该仓库README</a>；</p><p>请注意，执行第一个自启动命令的时候需要windows的管理员权限，此时需要输入的是系统登录的微软账户的密码（不是你的PIN），看下面，我第一次输入密码输入的就是PIN，显示错误，第二次输入了微软账户的密码才成功。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">[root@7945R9P pkg]# /opt/distrod/bin/distrod enable --start-on-windows-boot</span><br><span class="line">[Distrod] Distrod has been enabled. Now your shell will start under systemd.</span><br><span class="line">[Distrod] Enabling atuomatic startup of Distrod. UAC dialog will appear because scheduling</span><br><span class="line">a task requires the admin privilege. Please hit enter to proceed.</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Error</span><br><span class="line">It seems the task has not been scheduled successfully. You may have typed a wrong password, or you may not have the</span><br><span class="line">necessary administrative privileges. Do you want to retry?</span><br><span class="line">[Y] Yes  [N] No  [?] 帮助 (默认值为“Y”): y</span><br><span class="line">Enabling autostart has succeeded.</span><br><span class="line">[Distrod] Distrod will now start automatically on Windows startup.</span><br></pre></td></tr></table></figure><p>操作完成后，需要重启虚拟机。用如下命令将对应的wsl虚拟机关闭就行了，再次执行wsl就会重启这个虚拟机。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wsl --terminate CentOS8</span><br></pre></td></tr></table></figure><p>如图，我的systemctl命令已经生效。</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2023/10/9340e7964572037fbd3b58f1b379b177.png" alt="image-20231015150251531"></p><p>也能正常通过systemctl命令启动mariadb数据库</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2023/10/6edf311cf4a5dd1749328456a0008255.png" alt="image-20231015150404823"></p><h2 id="6-2-微软官方（推荐）"><a href="#6-2-微软官方（推荐）" class="headerlink" title="6.2 微软官方（推荐）"></a>6.2 微软官方（推荐）</h2><blockquote><p>参考 <a href="https://zhuanlan.zhihu.com/p/569883693">https://zhuanlan.zhihu.com/p/569883693</a></p></blockquote><p>查看wsl版本号命令为： <code>wsl --version</code>，如果此命令未正常回显版本号，或版本号低于<code>0.67.6</code>，那么你安装的wsl还不支持systemd。如下，我的wsl版本已经是支持的了。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">PS C:\Users\S2522\Desktop&gt; wsl --version</span><br><span class="line">WSL 版本： 1.2.5.0</span><br><span class="line">内核版本： 5.15.90.1</span><br><span class="line">WSLg 版本： 1.0.51</span><br><span class="line">MSRDC 版本： 1.2.3770</span><br><span class="line">Direct3D 版本： 1.608.2-61064218</span><br><span class="line">DXCore 版本： 10.0.25131.1002-220531-1700.rs-onecore-base2-hyp</span><br><span class="line">Windows 版本： 10.0.22621.2134</span><br></pre></td></tr></table></figure><p>进入wsl的CentOS虚拟机，执行如下命令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> -e <span class="string">&quot;[boot]\nsystemd=true&quot;</span> | sudo <span class="built_in">tee</span> -a /etc/wsl.conf</span><br></pre></td></tr></table></figure><p>随后exit退出虚拟机，<strong>回到windows终端命令行</strong>，重启wsl</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wsl <span class="literal">--shutdown</span></span><br></pre></td></tr></table></figure><p>随后再次在windows命令行下执行wsl命令，重启这个虚拟机；</p><p>重启wsl虚拟机后，在<strong>虚拟机内部</strong>执行如下命令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ps --no-headers -o <span class="built_in">comm</span> 1</span><br></pre></td></tr></table></figure><ul><li>如果这个命令返回结果是<strong>systemd</strong>，则代表我们的<code>systemctl</code>命令已经可以使用。</li><li>如果返回的是<code>init</code>，则设置失败</li></ul><p>如下图，我已经设置成功了！</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2023/10/a072fdd5b53abc04cf444c1ab0ac9ad2.png" alt="image-20231015204810685"></p><p>微软官方支持的systemd还是有一点是优于distrod的，那就是启用了官方 systemd 的 wsl2 实例，在用户停止操作后，<strong>会自动关闭</strong>，和未启用 systemd 时的特性一样，这有利于节约电脑的计算资源。</p>]]></content>
    
    
    <summary type="html">win11安装wsl和CentOS8Stream虚拟机</summary>
    
    
    
    <category term="玩上Linux" scheme="https://blog.musnow.top/categories/%E7%8E%A9%E4%B8%8ALinux/"/>
    
    
    <category term="Linux" scheme="https://blog.musnow.top/tags/Linux/"/>
    
    <category term="虚拟机" scheme="https://blog.musnow.top/tags/%E8%99%9A%E6%8B%9F%E6%9C%BA/"/>
    
  </entry>
  
  <entry>
    <title>【七牛云】artalk表情遇到跨域访问问题</title>
    <link href="https://blog.musnow.top/posts/489538601/"/>
    <id>https://blog.musnow.top/posts/489538601/</id>
    <published>2023-10-02T04:35:28.000Z</published>
    <updated>2023-10-02T04:35:28.000Z</updated>
    
    <content type="html"><![CDATA[<p>如题，当我在我自己编写的文档站点 <a href="https://khl-py.eu.org/">https://khl-py.eu.org/</a> 访问我的artalk服务时，其中包含一个artalk表情的请求，被浏览器的跨域策略给挡住了。这会导致artalk评论中无法发送表情（虽然无伤大雅）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Access to fetch at &#x27;https://img.musnow.top/i/artalk-emoji.json&#x27; from origin &#x27;https://khl-py.eu.org&#x27; has been blocked by CORS policy: No &#x27;Access-Control-Allow-Origin&#x27; header is present on the requested resource. If an opaque response serves your needs, set the request&#x27;s mode to &#x27;no-cors&#x27; to fetch the resource with CORS disabled.</span><br></pre></td></tr></table></figure><p>百度了一下，我们需要在七牛云的CDN策略中进行配置（我的七牛云KODO是绑定到CDN上，通过CDN进行访问的）</p><p>找到CDN界面中的<strong>HTTP响应头配置</strong></p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2023/10/6e1119859945ce9b07928a2bff2643d8.png" alt="image-20231002222846450"></p><p>点击修改配置，添加如下两点</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2023/10/6b3b5f2bc783ef6bf7cc614d5bc2a1e7.png" alt="image-20231002222920540"></p><p>保存后过一会，就不会出现这个跨域访问问题了。至于这部分设置会不会导致有人盗刷你的CDN流量，仍待更多的观察。</p><p>另外，如果你的CDN还开启了防盗链，还需要把对应域名填入防盗链的白名单中！</p>]]></content>
    
    
    <summary type="html">七牛云存放的artalk表情遇到跨域访问问题</summary>
    
    
    
    <category term="差生文具多" scheme="https://blog.musnow.top/categories/%E5%B7%AE%E7%94%9F%E6%96%87%E5%85%B7%E5%A4%9A/"/>
    
    
    <category term="图床" scheme="https://blog.musnow.top/tags/%E5%9B%BE%E5%BA%8A/"/>
    
  </entry>
  
  <entry>
    <title>【C语言】clock_gettime函数的使用</title>
    <link href="https://blog.musnow.top/posts/107825263/"/>
    <id>https://blog.musnow.top/posts/107825263/</id>
    <published>2023-09-27T12:41:59.000Z</published>
    <updated>2023-09-27T13:29:17.000Z</updated>
    
    <content type="html"><![CDATA[<p>函数的基本信息如下</p><ul><li>其中第一个参数是配置你想获取什么类型的时间</li><li>第二个参数是一个<strong>输出型参数</strong>，会将当前时间存放到一个结构体里面给你返回。</li><li>返回值标识是否获取成功</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//头文件</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;time.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//函数原型</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">clock_gettime</span><span class="params">( <span class="type">clockid_t</span> clock_id,<span class="keyword">struct</span> timespec * tp )</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// timespec 结构体</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">timespec</span> &#123;</span> </span><br><span class="line">    <span class="type">__time_t</span> tv_sec; <span class="comment">/* 秒 */</span> </span><br><span class="line">    __syscall_s <span class="type">long_t</span> tv_nsec; <span class="comment">/* 纳秒 */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>第一个参数有下面几种选项</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">CLOCK_REALTIME: 是指系统时间，随着系统时间的改变而改变。系统时钟会被用户而改变。并非不变的时间戳。</span><br><span class="line">CLOCK_MONOTONIC: 指从系统启动时开始计时。不受系统设置影响，也不会被用户改变。</span><br><span class="line">CLOCK_PROCESS_CPUTIME_ID: 指这个进程运行到当前代码时，CPU花费的时间。</span><br><span class="line">CLOCK_THREAD_CPUTIME_ID: 指这个线程运行到当前代码时，CPU花费的时间。</span><br></pre></td></tr></table></figure><p>使用例子</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;time.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">timespec</span> <span class="title">now</span>;</span></span><br><span class="line"></span><br><span class="line">    clock_gettime(CLOCK_MONOTONIC,&amp;now);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Seconds = %ld \t Nanoseconds = %ld\n&quot;</span>,, now.tv_sec, now.tv_nsec);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Seconds = 29642          Nanoseconds = 751516090</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">clock_gettime函数的使用</summary>
    
    
    
    <category term="初识C语言" scheme="https://blog.musnow.top/categories/%E5%88%9D%E8%AF%86C%E8%AF%AD%E8%A8%80/"/>
    
    
    <category term="C语言" scheme="https://blog.musnow.top/tags/C%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title>【Linux】valgrind检测程序内存泄漏</title>
    <link href="https://blog.musnow.top/posts/565285228/"/>
    <id>https://blog.musnow.top/posts/565285228/</id>
    <published>2023-09-26T10:12:55.000Z</published>
    <updated>2023-09-26T10:12:55.000Z</updated>
    
    <content type="html"><![CDATA[<p>valgrind是一个用于检测debug内存泄漏的命令行工具</p><h1 id="安装遵循如下命令"><a href="#安装遵循如下命令" class="headerlink" title="安装遵循如下命令"></a>安装遵循如下命令</h1><h2 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget https://sourceware.org/pub/valgrind/valgrind-3.21.0.tar.bz2</span><br></pre></td></tr></table></figure><h2 id="解压"><a href="#解压" class="headerlink" title="解压"></a>解压</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">tar -xf valgrind-3.21.0.tar.bz2</span><br><span class="line">cd valgrind-3.21.0</span><br></pre></td></tr></table></figure><h2 id="配置-x2F-安装，需要有root权限"><a href="#配置-x2F-安装，需要有root权限" class="headerlink" title="配置&#x2F;安装，需要有root权限"></a>配置&#x2F;安装，需要有root权限</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo ./configure</span><br><span class="line">sudo make</span><br><span class="line">sudo make install</span><br></pre></td></tr></table></figure><h1 id="使用mencheck"><a href="#使用mencheck" class="headerlink" title="使用mencheck"></a>使用mencheck</h1><p>mencheck是valgrind的一个模块，其还拥有其他功能，但是我们在这里不做使用<br> –tool&#x3D;memcheck  选择memcheck工具<br> –log-file&#x3D;log.txt  指定日志输出文件到 log.txt <br> –leak-check&#x3D;no|summary|full  指定输出日志的详细程度</p><p>基本使用命令的一个示例，最后的 <code>./test</code> 是一个可执行文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">valgrind --tool=memcheck --log-file=log.txt --leak-check=full ./test</span><br></pre></td></tr></table></figure><h2 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h2><p>memcheck模块检测的范围包括 </p><ul><li>使用未初始化的内存</li><li>使用已经被释放的内存</li><li>使用超出malloc分配空间的内存</li><li>对堆栈的非法访问</li><li>是否有释放申请的空间</li><li>memcpy中src和dst的重叠（参数的内存空间有重合部分）</li></ul><p>注意，对于某些new和malloc出来的常驻对象（比如全局的某个对象，单例模式中就会遇到）并不能算作内存泄漏，因为它是需要被使用的。</p><h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><p>整了个最简单的代码 </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstddef&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line">​</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test_leak</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> *p = (<span class="type">int</span> *)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">    *p = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">​</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> *p1 = (<span class="type">int</span> *)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">    *p1 = <span class="number">2</span>;</span><br><span class="line">​</span><br><span class="line">    <span class="type">int</span> *p2 = (<span class="type">int</span> *)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">    *p2 = <span class="number">3</span>;</span><br><span class="line">    <span class="comment">// 只析构一个，看看能不能检查出报错</span></span><br><span class="line">    <span class="built_in">free</span>(p2);</span><br><span class="line">    <span class="built_in">test_leak</span>();<span class="comment">// 只有调用的模块出现内存泄漏才能被检测到</span></span><br><span class="line">    <span class="comment">// 如果不调用这个函数，则不会检测到这里的问题</span></span><br><span class="line">    <span class="comment">// 因为valgrind是操作监看可执行文件的，并不是来扫描代码的</span></span><br><span class="line">​</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里面有3个malloc，其中有两个是没有free的，那么用valgrind可以检测出来吗？</p><p>答案是肯定的:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">==24089== Memcheck, a memory error detector</span><br><span class="line">==24089== Copyright (C) 2002-2022, and GNU GPL&#x27;d, by Julian Seward et al.</span><br><span class="line">==24089== Using Valgrind-3.21.0 and LibVEX; rerun with -h for copyright info</span><br><span class="line">==24089== Command: ./test</span><br><span class="line">==24089== Parent PID: 24056</span><br><span class="line">==24089== </span><br><span class="line">==24089== </span><br><span class="line">==24089== HEAP SUMMARY:</span><br><span class="line">==24089==     in use at exit: 8 bytes in 2 blocks</span><br><span class="line">==24089==   total heap usage: 4 allocs, 2 frees, 72,716 bytes allocated</span><br><span class="line">==24089== </span><br><span class="line">==24089== 4 bytes in 1 blocks are definitely lost in loss record 1 of 2</span><br><span class="line">==24089==    at 0x484880F: malloc (vg_replace_malloc.c:431)</span><br><span class="line">==24089==    by 0x1091F8: main (in /home/lyk/ub-vm/test)</span><br><span class="line">==24089== </span><br><span class="line">==24089== 4 bytes in 1 blocks are definitely lost in loss record 2 of 2</span><br><span class="line">==24089==    at 0x484880F: malloc (vg_replace_malloc.c:431)</span><br><span class="line">==24089==    by 0x1091C1: test_leak() (in /home/lyk/ub-vm/test)</span><br><span class="line">==24089==    by 0x10922C: main (in /home/lyk/ub-vm/test)</span><br><span class="line">==24089== </span><br><span class="line">==24089== LEAK SUMMARY:</span><br><span class="line">==24089==    definitely lost: 8 bytes in 2 blocks</span><br><span class="line">==24089==    indirectly lost: 0 bytes in 0 blocks</span><br><span class="line">==24089==      possibly lost: 0 bytes in 0 blocks</span><br><span class="line">==24089==    still reachable: 0 bytes in 0 blocks</span><br><span class="line">==24089==         suppressed: 0 bytes in 0 blocks</span><br><span class="line">==24089== </span><br><span class="line">==24089== For lists of detected and suppressed errors, rerun with: -s</span><br><span class="line">==24089== ERROR SUMMARY: 2 errors from 2 contexts (suppressed: 0 from 0)</span><br></pre></td></tr></table></figure><p>在最后的summry里面可以看到，这里提示 <code>definitely lost</code> 了8个字节，而且是在两个不同的区块中丢失的。和我们的代码吻合。</p><p>如果你不调用  <code>test_leak()</code>  函数，那么就不会出现第二次的内存泄漏，报告会变成只有  <code>4 bytes in 1 blocks</code> ，因为valgrind是通过可执行文件来检测是否有内存泄漏的，他不会扫描你的代码（那样的成本太高了而且不一定准确！）</p>]]></content>
    
    
    <summary type="html">valgrind是一个用于检测debug内存泄漏的命令行工具</summary>
    
    
    
    <category term="玩上Linux" scheme="https://blog.musnow.top/categories/%E7%8E%A9%E4%B8%8ALinux/"/>
    
    
    <category term="Linux" scheme="https://blog.musnow.top/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>【C++】C++17的那些新特性</title>
    <link href="https://blog.musnow.top/posts/3858168547/"/>
    <id>https://blog.musnow.top/posts/3858168547/</id>
    <published>2023-09-26T04:40:46.000Z</published>
    <updated>2023-09-26T04:40:46.000Z</updated>
    
    <content type="html"><![CDATA[<p>学习C++17的新特性</p><h1 id="1-构造函数模板推导"><a href="#1-构造函数模板推导" class="headerlink" title="1.构造函数模板推导"></a>1.构造函数模板推导</h1><p>在之前，我们如果想用stl容器，都需要用<code>&lt;&gt;</code> 来手动指定参数类型。但在C++17中，我们不需要这么做了。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::vector v1 = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125;;</span><br><span class="line">    std::pair p1  = &#123;<span class="number">1</span>,<span class="number">2.4234</span>&#125;;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">typeid</span>(v1).<span class="built_in">name</span>() &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">typeid</span>(p1).<span class="built_in">name</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用C++11编译，这个代码会报错。报错的意思是让我们指定参数的模板类型。</p><p>比如 <code>std::pair p1  = &#123;1,2.4234&#125;;</code> 在C++11中应该写成 <code>std::pair&lt;int,double&gt; p1  = &#123;1,2.4234&#125;;</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">test.cpp:16:10: error: use of class template &#x27;std::pair&#x27; requires template arguments</span><br><span class="line">    std::pair p1  = &#123;1,2.4234&#125;;</span><br><span class="line">         ^</span><br><span class="line">/usr/bin/../lib/gcc/x86_64-linux-gnu/11/../../../../include/c++/11/bits/stl_pair.h:211:12: note: template is declared here</span><br><span class="line">    struct pair</span><br><span class="line">           ^</span><br><span class="line">3 errors generated.</span><br><span class="line">make: *** [makefile:3: test] Error 1</span><br></pre></td></tr></table></figure><p>在C++17中，这样的写法就是可以被通过的了，也能正常推断出参数的类型，分别是一个int的vector，和一个int+double的pair；</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ make</span><br><span class="line">clang++ test.cpp -o test -std=c++17</span><br><span class="line">$ ./test</span><br><span class="line">St6vectorIiSaIiEE</span><br><span class="line">St4pairIidE</span><br></pre></td></tr></table></figure><h1 id="2-结构化绑定"><a href="#2-结构化绑定" class="headerlink" title="2.结构化绑定"></a>2.结构化绑定</h1><p>我们可以用 <code>auto[变量1,变量2]</code>的方式来接受一个tuple或者pair的返回值，将其绑定到两个不同的变量上。</p><p>tuple是C++11新增的一个数据结构，它和pair的用法类似，不同的是元组支持无数个参数。而pair仅支持两个。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::tuple&lt;<span class="type">int</span>, <span class="type">double</span>&gt; <span class="title">func_tuple</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> std::<span class="built_in">tuple</span>&lt;<span class="type">int</span>,<span class="type">double</span>&gt;(<span class="number">1</span>, <span class="number">2.2</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">std::pair&lt;<span class="type">int</span>, <span class="type">double</span>&gt; <span class="title">func_pair</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;<span class="number">1</span>,<span class="number">2</span>&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> [i, d] = <span class="built_in">func_tuple</span>(); </span><br><span class="line">    cout &lt;&lt; <span class="built_in">typeid</span>(i).<span class="built_in">name</span>() &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">typeid</span>(d).<span class="built_in">name</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> [x,y] = <span class="built_in">func_pair</span>();</span><br><span class="line">    cout &lt;&lt; <span class="built_in">typeid</span>(x).<span class="built_in">name</span>() &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">typeid</span>(y).<span class="built_in">name</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用C++11来编译，编译器会报错，但编译依旧能成功。这是因为我们的编译器是支持C++17的，但又被指定了<code>-std=c++11</code>，所以给用户报了个警告，但没有报错（因为这个语法在C++17里面是正确的）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">clang++ test.cpp -o test -std=c++11</span><br><span class="line">test.cpp:34:10: warning: decomposition declarations are a C++17 extension [-Wc++17-extensions]</span><br><span class="line">    auto [i, d] = func_tuple(); </span><br><span class="line">         ^~~~~~</span><br><span class="line">test.cpp:40:10: warning: decomposition declarations are a C++17 extension [-Wc++17-extensions]</span><br><span class="line">    auto [x,y] = func_pair();</span><br><span class="line">         ^~~~~</span><br><span class="line">2 warnings generated.</span><br></pre></td></tr></table></figure><p>运行输出结果如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ ./test</span><br><span class="line">i</span><br><span class="line">d</span><br><span class="line"></span><br><span class="line">i</span><br><span class="line">d</span><br></pre></td></tr></table></figure><p>注意：结构化绑定不能应用于constexpr！</p><p>结构化绑定不止可以绑定pair和tuple，还可以绑定数组和结构体等。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 注意这里的struct的成员一定要是public的，不然外部无法访问，还怎么绑定？</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Point</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line">    <span class="type">int</span> y;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回值是point的函数</span></span><br><span class="line"><span class="function">Point <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;<span class="number">1</span>, <span class="number">2</span>&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> array[<span class="number">3</span>] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line">    <span class="keyword">auto</span> [a, b, c] = array;</span><br><span class="line">    cout &lt;&lt; a &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; b &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; c &lt;&lt; endl;</span><br><span class="line">    <span class="comment">// 直接推导出两个成员变量并赋值给变量x和y</span></span><br><span class="line">    <span class="type">const</span> <span class="keyword">auto</span> [x, y] = <span class="built_in">func</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>成功编译并输出结果</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ make</span><br><span class="line">clang++ test.cpp -o test -std=c++17</span><br><span class="line">$ ./test</span><br><span class="line">1 2 3</span><br><span class="line">1 2</span><br></pre></td></tr></table></figure><p>自定义类型也能实现结构化绑定，这里从网上扒了一个代码下来，就不自己做测试了</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 需要实现相关的tuple_size和tuple_element和get&lt;N&gt;方法。</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Entry</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        name_ = <span class="string">&quot;name&quot;</span>;</span><br><span class="line">        age_ = <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">std::string <span class="title">GetName</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> name_; &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">GetAge</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> age_; &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::string name_;</span><br><span class="line">    <span class="type">int</span> age_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="type">size_t</span> I&gt;</span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">get</span><span class="params">(<span class="type">const</span> Entry&amp; e)</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">if</span> <span class="title">constexpr</span> <span class="params">(I == <span class="number">0</span>)</span> <span class="keyword">return</span> e.<span class="title">GetName</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> <span class="built_in">constexpr</span> (I == <span class="number">1</span>) <span class="keyword">return</span> e.<span class="built_in">GetAge</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> std &#123;</span><br><span class="line">    <span class="keyword">template</span>&lt;&gt; <span class="keyword">struct</span> <span class="title class_">tuple_size</span>&lt;Entry&gt; : integral_constant&lt;<span class="type">size_t</span>, <span class="number">2</span>&gt; &#123;&#125;;</span><br><span class="line">    <span class="keyword">template</span>&lt;&gt; <span class="keyword">struct</span> <span class="title class_">tuple_element</span>&lt;<span class="number">0</span>, Entry&gt; &#123; <span class="keyword">using</span> type = std::string; &#125;;</span><br><span class="line">    <span class="keyword">template</span>&lt;&gt; <span class="keyword">struct</span> <span class="title class_">tuple_element</span>&lt;<span class="number">1</span>, Entry&gt; &#123; <span class="keyword">using</span> type = <span class="type">int</span>; &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Entry e;</span><br><span class="line">    e.<span class="built_in">Init</span>();</span><br><span class="line">    <span class="keyword">auto</span> [name, age] = e;</span><br><span class="line">    cout &lt;&lt; name &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; age &lt;&lt; endl; <span class="comment">// name 10</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="3-if语句新增初始条件"><a href="#3-if语句新增初始条件" class="headerlink" title="3.if语句新增初始条件"></a>3.if语句新增初始条件</h1><p>在之前我们都是用 <code>if(判断条件)</code> 来使用if语句的，C++17中给if新增了一个类似for循环中第一个参数的相同参数</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">if(初始化条件,判断条件)</span><br></pre></td></tr></table></figure><p>比如</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(<span class="type">int</span> i=<span class="number">20</span>;i&lt;<span class="number">39</span>)&#123;</span><br><span class="line">    cout &lt;&lt;<span class="string">&quot;i&lt;39!&quot;</span>&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行效果如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ ./test</span><br><span class="line">i&lt;39!</span><br></pre></td></tr></table></figure><h1 id="4-内联变量"><a href="#4-内联变量" class="headerlink" title="4.内联变量"></a>4.内联变量</h1><p>在之前我们想初始化一个类中的static变量，需要在类中定义，类外初始化。但如果是const的static变量，就能直接在类中通过缺省值的方式来初始化。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在头文件里面这样是能通过编译的，但是不建议在头文件中初始化static变量，会产生ODR冲突:</span></span><br><span class="line"><span class="comment">// Variable &#x27;value&#x27; defined in a header file; variable definitions in header files can lead to ODR violations</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">A</span> &#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> value;  </span><br><span class="line">    <span class="type">static</span> <span class="type">const</span> <span class="type">int</span> value_c=<span class="number">10</span>;  <span class="comment">// const可以直接初始化</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">int</span> A::value = <span class="number">10</span>;</span><br></pre></td></tr></table></figure><p>在C++17中内联变量引入后，我们就可以直接实现在头文件中初始化static非const变量，或者直接用缺省值来初始化了</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">A</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> value;</span><br><span class="line">    <span class="type">static</span> <span class="type">const</span> <span class="type">int</span> value_c = <span class="number">10</span>;</span><br><span class="line">    <span class="comment">// static int value = 10;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">inline</span> <span class="type">int</span> A::value = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ========= 或者 ========</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">B</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">inline</span> <span class="type">static</span> <span class="type">int</span> value = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">inline</span> <span class="type">static</span> <span class="type">const</span> <span class="type">int</span> value_c = <span class="number">10</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>相比于原本static变量初始化需要放到另外一个cpp源文件中，这种直接在头文件里面声明+初始化的方式能更好的确定变量的初始值。</p><h1 id="5-折叠表达式"><a href="#5-折叠表达式" class="headerlink" title="5.折叠表达式"></a>5.折叠表达式</h1><p>C++17引入了折叠表达式使可变参数模板编程更方便：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> ... Ts&gt;</span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">sum</span><span class="params">(Ts ... ts)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (ts + ...);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> a &#123;<span class="built_in">sum</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>)&#125;; <span class="comment">// 15</span></span><br><span class="line">std::string a&#123;<span class="string">&quot;hello &quot;</span>&#125;;</span><br><span class="line">std::string b&#123;<span class="string">&quot;world&quot;</span>&#125;;</span><br><span class="line">cout &lt;&lt; <span class="built_in">sum</span>(a, b) &lt;&lt; endl; <span class="comment">// hello world</span></span><br></pre></td></tr></table></figure><p>实话说，可变模板参数这部分就没有弄明白过，实际上也没有用过，直接跳过！</p><h1 id="6-constexpr-lambda表达式"><a href="#6-constexpr-lambda表达式" class="headerlink" title="6.constexpr+lambda表达式"></a>6.constexpr+lambda表达式</h1><p>C++17前lambda表达式只能在运行时使用，C++17引入了constexpr lambda表达式，可以用于在编译期进行计算。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">int main() &#123; // c++17可编译</span><br><span class="line">    constexpr auto lamb = [] (int n) &#123; return n * n; &#125;;</span><br><span class="line">    static_assert(lamb(3) == 9, &quot;a&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>规则和普通的constexpr函数相同，参考我的C++11和14的文章。这里做简单说明：</p><p>constexpr修饰的函数体不能包含汇编语句、goto语句、label、try块、静态变量、线程局部存储、没有初始化的普通变量，不能动态分配内存，不能有new delete等，不能虚函数。</p><h1 id="7-嵌套命名空间"><a href="#7-嵌套命名空间" class="headerlink" title="7.嵌套命名空间"></a>7.嵌套命名空间</h1><p>在之前如果需要嵌套命名空间，需要这样写</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> A &#123;</span><br><span class="line">    <span class="keyword">namespace</span> B &#123;</span><br><span class="line">        <span class="keyword">namespace</span> C &#123;</span><br><span class="line">            <span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span></span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>C++17中可以直接用类似访问限定符的方式，前面加一个namespace来标明嵌套的命名空间。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// c++17，方便了，可读性也更好</span></span><br><span class="line"><span class="keyword">namespace</span> A::B::C &#123;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="8-has-include预处理表达式"><a href="#8-has-include预处理表达式" class="headerlink" title="8.__has_include预处理表达式"></a>8.__has_include预处理表达式</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">if</span> defined __has_include <span class="comment">// 判断是否支持这个表达式</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> __has_include(<span class="string">&lt;charconv&gt;</span>) <span class="comment">// 支持，判断是否存在该头文件</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> has_charconv 1 <span class="comment">// 头文件存在，定义一个宏</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;charconv&gt;</span> <span class="comment">// 引用这个头文件</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>如果一个代码会在多个不同的平台下跑，这个功能就很重要。比如我之前写项目的时候需要使用到jsoncpp，在centos和deepin下，安装jsoncpp的include路径是不同的</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//centos</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;json/json.h&gt;</span></span></span><br><span class="line"><span class="comment">//deepin</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;jsoncpp/json/json.h&gt;</span></span></span><br></pre></td></tr></table></figure><p>这种场景下就可以使用上面提到的这个预处理表达式进行判断，来确认你的jsoncpp路径到底在哪里。注意，这只能解决从yum和apt安装的jsoncpp，如果是自己手动安装的，那鬼知道你安装到哪里去了？🤣</p><p>所以很多大型项目如果需要使用jsoncpp这种第三方依赖项目，一般都会采用<code>git submodule</code>的方式，直接将第三方库下载到当前项目路径下，以避免不同平台的依赖项<code>include</code>路径不对而导致无法编译程序的问题。</p><h1 id="9-this指针捕获（lambda）"><a href="#9-this指针捕获（lambda）" class="headerlink" title="9.this指针捕获（lambda）"></a>9.this指针捕获（lambda）</h1><p>在lambda表达式中，采用<code>[this]</code>方式捕获的this指针是<strong>值传递</strong>捕获的，但在一些情况下，会出现访问已经被释放了的空间的行为；比如如下代码</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Foo</span></span><br><span class="line">&#123;</span><br><span class="line">    std::unique_ptr&lt;<span class="type">int</span>&gt; p;</span><br><span class="line"></span><br><span class="line">    <span class="function">std::function&lt;<span class="title">void</span><span class="params">()</span>&gt; <span class="title">f</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        p.<span class="built_in">reset</span>(<span class="keyword">new</span> <span class="built_in">int</span>(<span class="number">10</span>));</span><br><span class="line">        <span class="keyword">return</span> [&amp;]</span><br><span class="line">        &#123;</span><br><span class="line">            cout &lt;&lt; <span class="number">5</span> &lt;&lt; endl;</span><br><span class="line">            cout &lt;&lt; *p &lt;&lt; endl; <span class="comment">// 实际上是这一步报错的</span></span><br><span class="line">            <span class="comment">// 这里对*p的访问可以解析为 *(this-&gt;p)，但实际上this指针已经被销毁了</span></span><br><span class="line">            <span class="comment">// 注意，这里采用了智能指针，不存在内存泄漏，p指针指向的空间也被销毁了</span></span><br><span class="line">            <span class="comment">// 但我们的报错其实是对this指针解引用的时候就抛出了</span></span><br><span class="line">            cout &lt;&lt; <span class="number">6</span> &lt;&lt; endl;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> foo = <span class="keyword">new</span> <span class="built_in">Foo</span>();</span><br><span class="line">    cout &lt;&lt; <span class="number">1</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">auto</span> f = foo-&gt;<span class="built_in">f</span>();  <span class="comment">// 获取了一个类内成员函数</span></span><br><span class="line">    cout &lt;&lt; <span class="number">2</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">delete</span> foo;  <span class="comment">// 销毁这个对象</span></span><br><span class="line">    cout &lt;&lt; <span class="number">3</span> &lt;&lt; endl;</span><br><span class="line">    <span class="comment">// 尝试在销毁后继续使用这个对象，我们是通过lambda中=捕获的this指针来访问对象的</span></span><br><span class="line">    <span class="built_in">f</span>();  <span class="comment">// 这里直接报错了 Segmentation fault (core dumped)</span></span><br><span class="line">    cout &lt;&lt; <span class="number">4</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行这个程序，可以看到是在<code>*p</code>的位置报错退出的；具体的原因参考代码中的注释。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ ./test</span><br><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">5</span><br><span class="line">Segmentation fault (core dumped)</span><br></pre></td></tr></table></figure><p>需要注意，lambda表达式中，使用&#x3D;和&amp;都会默认采用<strong>传值捕获this指针</strong>，因为this指针是存在于函数作用域中的一个隐藏参数，并不是独立在成员函数外的变量，所以是可以被捕捉到的；另外，this指针是不能被传引用捕获的，<code>[&amp;this]</code> 的写法是不允许的；</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">clang++ test.cpp -o test -std=c++17</span><br><span class="line">test.cpp:84:18: error: &#x27;this&#x27; cannot be captured by reference</span><br><span class="line">        return [&amp;this]</span><br><span class="line">                 ^</span><br><span class="line">1 error generated.</span><br></pre></td></tr></table></figure><p>C++17中提供了一个特殊的写法 <code>[*this]</code> 通过传值的方式捕获了当前对象本身，此时lambda表达式中存在的就是一个对象的拷贝，即便当前对象被销毁了，我们依旧可以通过这个拷贝访问到目标；</p><p>代码修改如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Foo</span></span><br><span class="line">&#123;</span><br><span class="line">    std::shared_ptr&lt;<span class="type">int</span>&gt; p; <span class="comment">// 不能用unique_ptr，因为它的拷贝构造函数是被delete禁止使用的</span></span><br><span class="line"></span><br><span class="line">    <span class="function">std::function&lt;<span class="title">void</span><span class="params">()</span>&gt; <span class="title">f</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        p.<span class="built_in">reset</span>(<span class="keyword">new</span> <span class="built_in">int</span>(<span class="number">10</span>));</span><br><span class="line">        <span class="keyword">return</span> [*<span class="keyword">this</span>]</span><br><span class="line">        &#123;</span><br><span class="line">            cout &lt;&lt; <span class="number">5</span> &lt;&lt; endl;</span><br><span class="line">            cout &lt;&lt; *p &lt;&lt; endl;</span><br><span class="line">            cout &lt;&lt; <span class="number">6</span> &lt;&lt; endl;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> foo = <span class="keyword">new</span> <span class="built_in">Foo</span>();</span><br><span class="line">    cout &lt;&lt; <span class="number">1</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">auto</span> f = foo-&gt;<span class="built_in">f</span>();  <span class="comment">// 获取了一个类内成员函数</span></span><br><span class="line">    cout &lt;&lt; <span class="number">2</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">delete</span> foo;  <span class="comment">// 销毁这个对象</span></span><br><span class="line">    cout &lt;&lt; <span class="number">3</span> &lt;&lt; endl;</span><br><span class="line">    <span class="comment">// 尝试在销毁后继续使用这个对象，我们是通过lambda中=捕获的this指针来访问对象的</span></span><br><span class="line">    <span class="built_in">f</span>();  <span class="comment">// 这里直接报错了 Segmentation fault (core dumped)</span></span><br><span class="line">    cout &lt;&lt; <span class="number">4</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时重新编译，就能成功访问到指针p指向的对象了，并不受foo对象已经被delete的影响；</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ ./test</span><br><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">5</span><br><span class="line">10</span><br><span class="line">6</span><br><span class="line">4</span><br></pre></td></tr></table></figure><h1 id="10-字符串转换"><a href="#10-字符串转换" class="headerlink" title="10.字符串转换"></a>10.字符串转换</h1><blockquote><p>没看懂这两个函数是干嘛的，找到的代码连编译都过不去，跳过吧</p></blockquote><p>新增from_chars函数和to_chars函数</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">https://zh.cppreference.com/w/cpp/utility/from_chars</span><br><span class="line">https://blog.csdn.net/defaultbyzt/article/details/120151801</span><br></pre></td></tr></table></figure><h1 id="11-std-variant"><a href="#11-std-variant" class="headerlink" title="11.std::variant"></a>11.std::variant</h1><p>C++17增加<code>std::variant</code>实现类似union的功能，但却比union更高级，举个例子union里面不能有string这种类型，但<code>std::variant</code>却可以，还可以支持更多复杂类型，如map等，看代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123; <span class="comment">// c++17可编译</span></span><br><span class="line">    <span class="function">std::variant&lt;<span class="type">int</span>, std::string&gt; <span class="title">var</span><span class="params">(<span class="string">&quot;hello&quot;</span>)</span></span>;</span><br><span class="line">    cout &lt;&lt; var.<span class="built_in">index</span>() &lt;&lt; endl;</span><br><span class="line">    var = <span class="number">123</span>;</span><br><span class="line">    cout &lt;&lt; var.<span class="built_in">index</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        var = <span class="string">&quot;world&quot;</span>;</span><br><span class="line">        std::string str = std::<span class="built_in">get</span>&lt;std::string&gt;(var); <span class="comment">// 通过类型获取值</span></span><br><span class="line">        var = <span class="number">3</span>;</span><br><span class="line">        <span class="type">int</span> i = std::<span class="built_in">get</span>&lt;<span class="number">0</span>&gt;(var); <span class="comment">// 通过index获取对应值</span></span><br><span class="line">        cout &lt;&lt; str &lt;&lt; endl;</span><br><span class="line">        cout &lt;&lt; i &lt;&lt; endl;</span><br><span class="line">    &#125; <span class="built_in">catch</span>(...) &#123;</span><br><span class="line">        <span class="comment">// xxx;</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意：一般情况下variant的第一个类型一般要有对应的构造函数，否则编译失败：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">A</span> &#123;</span><br><span class="line">    <span class="built_in">A</span>(<span class="type">int</span> i)&#123;&#125;  </span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::variant&lt;A, <span class="type">int</span>&gt; var; <span class="comment">// 编译失败</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如何避免这种情况呢，可以使用<code>std::monostate</code>来打个桩，模拟一个空状态。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">std::variant&lt;std::monostate, A&gt; var; <span class="comment">// 可以编译成功</span></span><br></pre></td></tr></table></figure><h2 id="12-std-optional"><a href="#12-std-optional" class="headerlink" title="12.std::optional"></a>12.std::optional</h2><p><a href="https://en.cppreference.com/w/cpp/utility/optional">https://en.cppreference.com/w/cpp/utility/optional</a></p><p>有的时候，我们想在异常的时候抛出一个异常的对象，亦或者是在出现一些不可预期的错误的时候，返回一个空值。要怎么区分空值和异常的对象呢？</p><p>在python中，我们有一个专门的None对象可以来处理这件事。在MySQL中，我们也有NULL来标识空；但在CPP中，我们只剩下一个<code>nullptr</code>，其本质是个<strong>指针</strong>，与Py中的None和MySQL中的NULL完全不同！如果想用指针来区分空和异常对象，那就需要用到动态内存管理，亦或者是用智能指针来避免内存泄漏。</p><p>说人话就是，在CPP中没有一个类似None的含义为空的对象，来告诉调用这个程序的人，到底是发生了错误，生成了一个错误的对象，还是说压根什么都没有弄出来。</p><p>于是<code>std::optional</code>就出现了，其可以包含一个类型，并有<code>std::nullopt</code>来专门标识“空”这个含义。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;optional&gt;</span></span></span><br><span class="line"><span class="function">std::optional&lt;<span class="type">int</span>&gt; <span class="title">StoI</span><span class="params">(<span class="type">const</span> std::string &amp;s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> std::<span class="built_in">stoi</span>(s);</span><br><span class="line">    &#125; <span class="built_in">catch</span>(...) &#123;</span><br><span class="line">        <span class="keyword">return</span> std::<span class="literal">nullopt</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::string s&#123;<span class="string">&quot;123&quot;</span>&#125;;</span><br><span class="line">    std::optional&lt;<span class="type">int</span>&gt; o = <span class="built_in">StoI</span>(s);</span><br><span class="line">    <span class="keyword">if</span> (o) &#123;</span><br><span class="line">        cout &lt;&lt; *o &lt;&lt; endl;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;error&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里我们进行了if的判断，首先判断变量o本身，为真代表的确返回了一个int值，为假代表返回的是<code>nullopt</code>；</p><p>随后再使用<code>*o</code>来访问到内部托管的成员。</p><p>需要注意这里是两层的逻辑关系，只有optional对象中成功托管了一个指定的参数类型，其本身才是真的。如果想访问它托管的对象，则需要用解引用。</p><p>比如这里，我们的o对象托管的是一个bool类型的假，但假并不代表空，o对象本身的判断是真，内部对<code>*o</code>的判断才是判断托管的bool值到底是真是假。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;optional&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::optional&lt;<span class="type">bool</span>&gt; o = <span class="literal">false</span>;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">typeid</span>(o).<span class="built_in">name</span>() &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">if</span> (o) <span class="comment">// 这里判断的是optional对象是否有托管一个bool值</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(*o)&#123; <span class="comment">// 这里判断的是托管的bool值本身</span></span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;true&quot;</span> &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;false&quot;</span> &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123; <span class="comment">// 这里则代表托管的是nullopt</span></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;error&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最终运行打印的结果是<code>false</code>；</p><h1 id="13-std-any"><a href="#13-std-any" class="headerlink" title="13.std::any"></a>13.std::any</h1><p><a href="https://en.cppreference.com/w/cpp/utility/any">https://en.cppreference.com/w/cpp/utility/any</a></p><p>这个类型可以托管任意类型的值，与之对应的还有一个<code>std::any_cast</code>来将其托管的值转成我们需要的类型。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;any&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123; <span class="comment">// c++17可编译</span></span><br><span class="line">    std::any a = <span class="number">1</span>;</span><br><span class="line">    cout &lt;&lt; a.<span class="built_in">type</span>().<span class="built_in">name</span>() &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; std::<span class="built_in">any_cast</span>&lt;<span class="type">int</span>&gt;(a) &lt;&lt; endl;</span><br><span class="line">    a = <span class="number">2.2f</span>;</span><br><span class="line">    cout &lt;&lt; a.<span class="built_in">type</span>().<span class="built_in">name</span>() &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; std::<span class="built_in">any_cast</span>&lt;<span class="type">float</span>&gt;(a) &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">if</span> (a.<span class="built_in">has_value</span>()) &#123;</span><br><span class="line">        cout &lt;&lt; a.<span class="built_in">type</span>().<span class="built_in">name</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    a.<span class="built_in">reset</span>();</span><br><span class="line">    <span class="keyword">if</span> (a.<span class="built_in">has_value</span>()) &#123;</span><br><span class="line">        cout &lt;&lt; a.<span class="built_in">type</span>().<span class="built_in">name</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    a = std::<span class="built_in">string</span>(<span class="string">&quot;a&quot;</span>);</span><br><span class="line">    cout &lt;&lt; a.<span class="built_in">type</span>().<span class="built_in">name</span>() &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; std::<span class="built_in">any_cast</span>&lt;std::string&gt;(a) &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">i 1</span><br><span class="line">f 2.2</span><br><span class="line">fNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEE a</span><br></pre></td></tr></table></figure><p>虽然any的出现让cpp也在一定程度上能实现“弱类型”变量，但在具体的开发中，明确变量的类型依旧比使用any好得多。特别是在变量的类型并不可以被直接转换的情况下。</p><h1 id="14-std-apply"><a href="#14-std-apply" class="headerlink" title="14.std::apply"></a>14.std::apply</h1><p>使用<code>std::apply</code>可以将tuple展开作为函数的参数传入，见代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;tuple&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">add</span><span class="params">(<span class="type">int</span> first, <span class="type">int</span> second)</span> </span>&#123; <span class="keyword">return</span> first + second; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> add_lambda = [](<span class="keyword">auto</span> first, <span class="keyword">auto</span> second) &#123; <span class="keyword">return</span> first + second; &#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; std::<span class="built_in">apply</span>(add, std::<span class="built_in">pair</span>(<span class="number">1</span>, <span class="number">2</span>)) &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="built_in">add</span>(std::<span class="built_in">pair</span>(<span class="number">1</span>, <span class="number">2</span>)) &lt;&lt; <span class="string">&quot;\n&quot;</span>; <span class="comment">// error</span></span><br><span class="line">    std::cout &lt;&lt; std::<span class="built_in">apply</span>(add_lambda, std::<span class="built_in">tuple</span>(<span class="number">2.0f</span>, <span class="number">3.0f</span>)) &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="15-std-make-from-tuple"><a href="#15-std-make-from-tuple" class="headerlink" title="15.std::make_from_tuple"></a>15.std::make_from_tuple</h1><p>使用make_from_tuple可以将tuple展开作为构造函数参数</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Foo</span> &#123;</span><br><span class="line">    <span class="built_in">Foo</span>(<span class="type">int</span> first, <span class="type">float</span> second, <span class="type">int</span> third) &#123;</span><br><span class="line">        std::cout &lt;&lt; first &lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; second &lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; third &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   <span class="keyword">auto</span> tuple = std::<span class="built_in">make_tuple</span>(<span class="number">42</span>, <span class="number">3.14f</span>, <span class="number">0</span>);</span><br><span class="line">   std::<span class="built_in">make_from_tuple</span>&lt;Foo&gt;(std::<span class="built_in">move</span>(tuple));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="16-std-string-view"><a href="#16-std-string-view" class="headerlink" title="16.std::string_view"></a>16.std::string_view</h1><p><a href="https://zhuanlan.zhihu.com/p/166359481">https://zhuanlan.zhihu.com/p/166359481</a></p><p><a href="https://en.cppreference.com/w/cpp/string/basic_string_view">https://en.cppreference.com/w/cpp/string/basic_string_view</a></p><p>如果我们只需要一个string的只读类型的话，可以用string_view来托管。其内部只包含一个指向目标字符串的指针，以及字符串的长度。</p><p>string_view内部封装了string的所有只读接口，本来就是给你读的。</p><p>需要注意的是，因为内部只有一个指针，所以当string_view托管的string被销毁了，与之关联的所有string_view都会失效！同样是因为内部只有一个指针和字符串的长度两个变量，所以在传值拷贝的时候，string_view的效率会高很多。</p><ul><li>这和<code>const string&amp;</code> 类型的传值又有什么区别呢？传引用不是也没有拷贝消耗吗？</li></ul><p>这个问题很好，我不知道！百度也没有百度出来……</p><p>我能想到的就是用<code>string_view</code>作为参数的时候，如果入参是一个常量字符串，此时不需要构造string，而使用<code>const string&amp;</code> 接受常量字符串的时候依旧需要构造一个string对象。这部分就会有一定的消耗。</p><h1 id="17-as-const"><a href="#17-as-const" class="headerlink" title="17.as_const"></a>17.as_const</h1><p>C++17使用as_const可以将左值转成const类型</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">std::string str = <span class="string">&quot;str&quot;</span>;</span><br><span class="line"><span class="type">const</span> std::string&amp; constStr = std::<span class="built_in">as_const</span>(str);</span><br></pre></td></tr></table></figure><h1 id="18-file-system"><a href="#18-file-system" class="headerlink" title="18.file_system"></a>18.file_system</h1><p>C++17正式将file_system纳入标准中，提供了关于文件的大多数功能，基本上应有尽有，这里简单举几个例子：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> fs = std::filesystem;</span><br><span class="line">fs::<span class="built_in">create_directory</span>(dir_path); <span class="comment">// 创建文件或者路径</span></span><br><span class="line">fs::<span class="built_in">copy_file</span>(src, dst, fs::copy_options::skip_existing); <span class="comment">// 文件cp</span></span><br><span class="line">fs::<span class="built_in">exists</span>(filename); <span class="comment">// 文件是否存在</span></span><br><span class="line">fs::<span class="built_in">current_path</span>(err_code); <span class="comment">// 获取当前路径</span></span><br></pre></td></tr></table></figure><h1 id="19-shared-mutex"><a href="#19-shared-mutex" class="headerlink" title="19.shared_mutex"></a>19.shared_mutex</h1><p>这玩意是个读写锁。简单介绍一下什么是读写锁：</p><ul><li>读者可以有多个，写者只能有一个</li><li>写锁是互斥的，如果A有锁，B想拿锁就得阻塞等待</li><li>读锁是共享的，C有读锁，D也想读，两个人可以一起看</li><li>读写锁是互斥的，有人写的时候不能读，有人读的时候不能写</li></ul><p>换到专业术语上，就是分为独占锁（写锁）和共享锁（读锁）；</p><p>在C++14中其实已经有了一个<code>shared_timed_mutex</code>，C++17中这个锁的操作与其基本一致，只不过多了几个和时间相关的接口</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">try_lock_for</span>(...);</span><br><span class="line"><span class="built_in">try_lock_shared_for</span>(...);</span><br><span class="line"><span class="built_in">try_lock_shared_until</span>(...);</span><br><span class="line"><span class="built_in">try_lock_until</span>(...);</span><br></pre></td></tr></table></figure><p>具体使用可以参考 </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">https://zh.cppreference.com/w/cpp/thread/shared_mutex</span><br><span class="line">https://zhuanlan.zhihu.com/p/610781321</span><br></pre></td></tr></table></figure><h1 id="The-end"><a href="#The-end" class="headerlink" title="The end"></a>The end</h1><p>关于C++17常用的基本就是这些了，后续遇到新的再更新本文。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;学习C++17的新特性&lt;/p&gt;
&lt;h1 id=&quot;1-构造函数模板推导&quot;&gt;&lt;a href=&quot;#1-构造函数模板推导&quot; class=&quot;headerlink&quot; title=&quot;1.构造函数模板推导&quot;&gt;&lt;/a&gt;1.构造函数模板推导&lt;/h1&gt;&lt;p&gt;在之前，我们如果想用stl容器，都需要</summary>
      
    
    
    
    <category term="遇见C++" scheme="https://blog.musnow.top/categories/%E9%81%87%E8%A7%81C/"/>
    
    
    <category term="C++" scheme="https://blog.musnow.top/tags/C/"/>
    
    <category term="数据结构" scheme="https://blog.musnow.top/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    <category term="C++17" scheme="https://blog.musnow.top/tags/C-17/"/>
    
  </entry>
  
  <entry>
    <title>【面经】230915上海戎磐网络科技C/LINUX实习生</title>
    <link href="https://blog.musnow.top/posts/2553205100/"/>
    <id>https://blog.musnow.top/posts/2553205100/</id>
    <published>2023-09-15T06:50:14.000Z</published>
    <updated>2023-09-15T06:50:14.000Z</updated>
    
    <content type="html"><![CDATA[<p>10分钟就面完了，堪称急速，面试官说我答的不错；而且上来自我介绍完毕后就问问题，不多比比🤣</p><span id="more"></span><h1 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h1><h2 id="1-Linux下线程互斥怎么实现"><a href="#1-Linux下线程互斥怎么实现" class="headerlink" title="1.Linux下线程互斥怎么实现"></a>1.Linux下线程互斥怎么实现</h2><p>加锁，pthread，然后我还提到了cpp的原子变量</p><p><a href="https://blog.musnow.top/posts/1309150756/">https://blog.musnow.top/posts/1309150756/</a></p><h2 id="2-CPP多态怎么实现"><a href="#2-CPP多态怎么实现" class="headerlink" title="2.CPP多态怎么实现"></a>2.CPP多态怎么实现</h2><p>虚函数表，巴拉巴拉</p><p><a href="https://blog.musnow.top/posts/3933786088/">https://blog.musnow.top/posts/3933786088/</a></p><h2 id="3-CPP为啥要引入模板"><a href="#3-CPP为啥要引入模板" class="headerlink" title="3.CPP为啥要引入模板"></a>3.CPP为啥要引入模板</h2><p>代码更高复用</p><p><a href="https://blog.musnow.top/posts/2940029419/">https://blog.musnow.top/posts/2940029419/</a></p><h2 id="4-NAT怎么实现的？"><a href="#4-NAT怎么实现的？" class="headerlink" title="4.NAT怎么实现的？"></a>4.NAT怎么实现的？</h2><p>转化表，IP地址替换，巴拉巴拉吧说一大堆</p><p><a href="https://blog.musnow.top/posts/3482559497/">https://blog.musnow.top/posts/3482559497/</a></p><h2 id="5-进程通信"><a href="#5-进程通信" class="headerlink" title="5.进程通信"></a>5.进程通信</h2><p>老问题了</p><h2 id="6-inet-ntoa函数知道吗？连续调用会有什么问题？"><a href="#6-inet-ntoa函数知道吗？连续调用会有什么问题？" class="headerlink" title="6.inet_ntoa函数知道吗？连续调用会有什么问题？"></a>6.inet_ntoa函数知道吗？连续调用会有什么问题？</h2><blockquote><p>这是最后一个问题，面试官说我答的挺好的</p></blockquote><p>我先说了这个函数是用于16位IP地址和字符串的转换的；</p><p>然后面试官这里问了一个业务上的问题</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s %s\n&quot;</span>,<span class="built_in">inet_ntoa</span>(x),<span class="built_in">inet_ntoa</span>(y));<span class="comment">// x和y是两个ip地址</span></span><br></pre></td></tr></table></figure><p>这个函数会不会有什么错误的地方？</p><blockquote><p>请注意，这里是面试时候的描述，面试官肯定只能给你描述个大概的，并不会细致到具体的传参应该传什么类型的变量，所以传参x和y也只是个伪代码，想问的地方不在这里！</p></blockquote><p>这里我说了<code>inet_ntoa</code>是采用static变量来返回ip字符串的，线程不安全，有可能两个调用最终返回了一个相同的IP地址，又明说了我不确定；（肯定有问题，不然问你干嘛？）</p><hr><p>面试结束了，来测试一下到底是啥情况吧！</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">in_addr</span> ip1;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">in_addr</span> ip2;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">inet_aton</span>(<span class="string">&quot;192.168.3.1&quot;</span>,&amp;ip1);</span><br><span class="line">    <span class="built_in">inet_aton</span>(<span class="string">&quot;10.161.33.42&quot;</span>,&amp;ip2);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s %s\n&quot;</span>,<span class="built_in">inet_ntoa</span>(ip1),<span class="built_in">inet_ntoa</span>(ip2));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果如下，两个IP地址返回了同一个，我猜对了；</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ ./test</span><br><span class="line">192.168.3.1 192.168.3.1</span><br></pre></td></tr></table></figure><p>为什么呢？打印一下地址，会得到如下输出，两次调用返回了相同的地址，自然打印出来的结果相同；</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%x %x\n&quot;</span>,<span class="built_in">inet_ntoa</span>(ip1),<span class="built_in">inet_ntoa</span>(ip2));</span><br><span class="line"><span class="comment">//68db1ef0 68db1ef0</span></span><br></pre></td></tr></table></figure><p>对于这个函数而言，它需要给我们返回一个字符串，又必须保证这个字符串能在函数外被正常访问（不能被释放），再加上这是一个C语言接口，那么就只有三种方案了</p><ul><li>函数里面malloc，需要用户手动free</li><li>static变量</li><li>让用户传入一个有效的地址，将数据写入作为输出型参数</li></ul><p>第一个方案肯定是不可行的！这相当于官方提供了一个<strong>极其容易导致内存泄漏</strong>的接口！这不得被开发者喷死？比如本题提到的场景里面就是两次printf而已，除此之外没有保存这个返回值，更别提free了，这里就直接两次内存泄漏了！</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s %s\n&quot;</span>,inet_ntoa(ip1),inet_ntoa(ip2));</span><br><span class="line"><span class="comment">// 如果用malloc后的字符串地址做返回值，这里就是两个内存泄漏</span></span><br></pre></td></tr></table></figure><p>第三个方案也不方便，系统依赖用户传入一个数组的入参，我们知道ipv4的IP地址字符串最长是<code>3*4+3=15</code>位，那么如果用户只传入一个<code>char arr[12]</code>呢？越界访问的问题怎么解决？相当于系统之中依旧会出现参数不匹配而可能导致的地址访问错误！</p><p><strong>而这个函数本身的工作很简单，完全没必要弄那么复杂</strong>；</p><p>最终linux系统采用了static变量的方式，来返回这个IP地址的字符串；man手册里面是这么说的，直接看最后一句，翻译过来的意思是<strong>后续的调用会覆盖掉前面的值</strong>；</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"> The inet_ntoa() function converts the Internet host address in, </span><br><span class="line"> given in network byte order, to a string in IPv4 dotted-decimal notation.  </span><br><span class="line"> The string  is returned in a statically allocated buffer,</span><br><span class="line">which subsequent calls will overwrite.</span><br></pre></td></tr></table></figure><p>所以最终我们看到的结果就是两次打印出了相同的IP地址；</p><p>这里还涉及到第二个知识点，<a href="https://blog.musnow.top/posts/3888883052/">printf的传参顺序</a>;</p><p>简单说来就是printf是从右往左执行的（其实所有函数的传参都是这样，这也是为什么缺省值要从右边往左给）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s %s\n&quot;</span>,<span class="built_in">inet_ntoa</span>(ip1),<span class="built_in">inet_ntoa</span>(ip2));</span><br></pre></td></tr></table></figure><p>这里的执行顺序如下</p><ul><li>ip2结构体传给函数，转成ip地址字符串后存在static变量中</li><li>ip1结构体传给函数，转成ip地址字符串后存在了static变量中，覆盖了ip2的结果</li></ul><p>最终打印出来的两个字符串都是ip1的地址！</p><p>对于<code>inet_aton</code>函数而言，<strong>正确的调用</strong>办法是每次调用后都取走返回的IP地址字符串，可以用<code>std::string</code>接收，也可以用strcmp拷贝到一个自己定义的字符串数组变量中；</p><p>你学会了吗，骚年？</p><blockquote><p><code>inet_aton</code>这个函数最早出现于本站的此博客：<a href="https://blog.musnow.top/posts/368672249/">【Linux】来写一个udp的服务端+客户端</a></p></blockquote><h1 id="项目"><a href="#项目" class="headerlink" title="项目"></a>项目</h1><p>因为是cpp的岗位，所以没有问python的机器人项目问题；</p><h2 id="1-视频点播传一半关闭了怎么解决"><a href="#1-视频点播传一半关闭了怎么解决" class="headerlink" title="1.视频点播传一半关闭了怎么解决"></a>1.视频点播传一半关闭了怎么解决</h2><p>两次面试都问到了这个问题，我提到了将新的文件和本地已有文件进行校验，跳过已有数据</p><h2 id="2-传一半剩下的数据后端怎么处理，什么时候删除？"><a href="#2-传一半剩下的数据后端怎么处理，什么时候删除？" class="headerlink" title="2.传一半剩下的数据后端怎么处理，什么时候删除？"></a>2.传一半剩下的数据后端怎么处理，什么时候删除？</h2><p>我提到了前后端用md5验证来确认视频文件无误，如果有问题，可以设置一个定时器，一小时后删除错误的数据</p><h2 id="3-用户修改了视频后上传怎么处理？"><a href="#3-用户修改了视频后上传怎么处理？" class="headerlink" title="3.用户修改了视频后上传怎么处理？"></a>3.用户修改了视频后上传怎么处理？</h2><p>同第一个，进行一定的数据校验，然后再复写没有的数据；</p><blockquote><p>然而这些功能我一个都没有实现🤣</p></blockquote><h1 id="效率"><a href="#效率" class="headerlink" title="效率"></a>效率</h1><p>面经还没写完，结果已经出啦，过了初试！但是要线下复试；</p>]]></content>
    
    
    <summary type="html">230915上海戎磐网络科技C/LINUX实习生</summary>
    
    
    
    <category term="求职路上一去不复返" scheme="https://blog.musnow.top/categories/%E6%B1%82%E8%81%8C%E8%B7%AF%E4%B8%8A%E4%B8%80%E5%8E%BB%E4%B8%8D%E5%A4%8D%E8%BF%94/"/>
    
    
    <category term="面经" scheme="https://blog.musnow.top/tags/%E9%9D%A2%E7%BB%8F/"/>
    
  </entry>
  
  <entry>
    <title>【MySQL】字节跳动MySQL连环40问</title>
    <link href="https://blog.musnow.top/posts/3873856211/"/>
    <id>https://blog.musnow.top/posts/3873856211/</id>
    <published>2023-09-15T00:52:14.000Z</published>
    <updated>2023-09-15T00:52:30.000Z</updated>
    
    <content type="html"><![CDATA[<p>字节MySQL连环40问，网图</p><span id="more"></span><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2023/09/188abb653b96cb823385befe4c196698.jpg" alt="QQ图片20230915081943"></p><p>虽然感觉这玩意和字节跳动没关系，但是管他的？直接开始回答！</p><h1 id="1-MySQL中有哪几种锁？"><a href="#1-MySQL中有哪几种锁？" class="headerlink" title="1.MySQL中有哪几种锁？"></a>1.MySQL中有哪几种锁？</h1><blockquote><p>会的不全，所以查的GPT</p></blockquote><p>MySQL中有多种类型的锁，主要包括以下几种：</p><ol><li>共享锁（Shared Lock）：也称为<strong>读锁</strong>，多个会话可以同时持有共享锁，并且不互斥。共享锁适用于读取操作，多个会话可以并发读取同一份数据而不会产生冲突。</li><li>排他锁（Exclusive Lock）：也称为<strong>写锁</strong>，排他锁与其他任何锁都互斥，只有一个会话可以持有排他锁。排他锁适用于写入或修改操作，确保在某个会话持有排他锁的时候，其他会话无法同时进行写入操作。</li><li>记录锁（Record Lock）：记录锁（<strong>行锁</strong>）是针对某条记录的锁定，用于保护特定记录的完整性。在使用InnoDB存储引擎时，读取或修改某条记录时会自动给该记录加上记录锁，其他会话则无法对该记录进行并发写入或删除操作。</li><li>Gap锁：Gap锁是InnoDB引擎的一种锁机制，<strong>用于防止幻读</strong>。它锁定了一个范围，但不包含实际的记录，用于防止其他会话在这个范围内插入新记录，以避免幻读现象的发生。</li><li>表锁（Table Lock）：表锁是对整个表格进行锁定，可以在某些特殊情况下使用，但会阻塞其他会话的读取和写入操作。在需要并发读写的情况下，表锁的性能较低，因此一般不推荐使用。</li></ol><p>除此之外，还有一个NEXT-KEY锁：</p><p>NEXT-KEY 锁是 InnoDB 存储引擎中的一种锁机制，用于<strong>解决幻读</strong>问题。它是通过将 Gap 锁和 记录锁 组合而成的。</p><p>具体来说，当一个事务在 InnoDB 表中执行范围查询时，如使用 <code>&lt;</code>、<code>&lt;=</code>、<code>&gt;</code>、<code>&gt;=</code> 等操作符，InnoDB 引擎会为查询涉及到的范围加上 NEXT-KEY 锁。这个 NEXT-KEY 锁包含两部分：</p><ol><li>Gap 锁：锁定了查询范围内的间隙（Gap），防止其他事务向该范围内插入新的记录。</li><li>记录锁：锁定了满足查询条件的记录，防止其他事务对这些记录进行并发修改或删除。</li></ol><p>通过使用 NEXT-KEY 锁，InnoDB 可以有效地避免幻读现象的发生。它保证了在一个事务读取一个范围的数据时，<strong>其他事务无法并发地在该范围内插入新的记录</strong>，从而保证了读取的一致性。</p><p>需要注意的是，NEXT-KEY 锁只在事务隔离级别为<strong>可重复读</strong>（REPEATABLE READ）或更高级别时使用（MySQL默认隔离级别为可重复读）。在较高的并发环境下，使用 NEXT-KEY 锁可能会增加锁冲突的概率，因此在设计数据库和查询时需要考虑到锁的开销和事务的隔离级别。</p><h1 id="2-MySQL中有哪些不同的表格？"><a href="#2-MySQL中有哪些不同的表格？" class="headerlink" title="2.MySQL中有哪些不同的表格？"></a>2.MySQL中有哪些不同的表格？</h1><blockquote><p>这个也是GPT回答的，注意，表格和存储引擎不是同一个概念！</p></blockquote><p>在MySQL中，有以下几种不同的表格类型：</p><ol><li>MyISAM：MyISAM是旧版本MySQL的默认表格类型。它提供了快速的读取速度，适用于大量的并发读取操作。不过，MyISAM不支持事务处理和崩溃恢复功能。</li><li>InnoDB：InnoDB是一种支持事务处理和崩溃恢复功能的表格类型。它提供了行级锁定和外键约束等高级功能，适用于需要数据完整性和并发写入操作的场景。InnoDB是<strong>MySQL 5.5版本后</strong>的默认表格类型。</li><li>Memory：Memory（也称为Heap）表格是将数据存储在内存中的临时表格类型。它在读取和写入方面非常快速，但它的数据是临时的，当数据库服务器重启时，表格中的数据将会丢失。</li><li>Archive：Archive表格是一种高度压缩的表格类型，适用于存储大量历史数据和归档数据。它对于读取操作不太有效，但在大量写入和存储空间方面具有优势。</li><li>CSV：CSV表格允许将数据以CSV（逗号分隔值）格式存储在文件中，支持导入和导出数据。它不支持索引，事务处理和其他高级特性。</li></ol><p>除了以上列举的几种常见的表格类型外，MySQL还支持其他一些特殊用途的表格类型，如Partitioned（分区表格）和Federated（联合表格）等。</p><ul><li>表格和存储引擎是同一个东西吗？并<strong>不是</strong>！</li></ul><p>在关系型数据库中，表格（Table）是指一个逻辑上的数据结构，用来组织和存储数据。一张表格由若干列（Column）和若干行（Row）组成，每列定义了一种数据类型和一个字段名，表格中的每一行则代表一个实体或记录，每个单元格存储着对应列的一个数值或字符串。</p><p>存储引擎（Storage Engine）则是指实现了数据库的表格和索引等功能的底层软件模块，它负责将表格数据存储到磁盘、跟踪并处理事务、执行查询语句等任务。不同的存储引擎具有各自的特点和优缺点，在不同场景下选择合适的存储引擎可以提高数据库的性能和可靠性。</p><h1 id="3-MyISAM和InnoDB的区别？"><a href="#3-MyISAM和InnoDB的区别？" class="headerlink" title="3.MyISAM和InnoDB的区别？"></a>3.MyISAM和InnoDB的区别？</h1><p>MyISAM</p><ul><li>不支持事务；</li><li>采用非聚簇索引，普通索引和主键索引的形式相同；</li><li>一张表包含三个本地文件；</li></ul><p>InnoDB</p><ul><li>支持事务；</li><li>采用聚簇索引，普通索引存放的是主键索引中的key值，需要回表查询；可以用索引覆盖来优化；</li><li>一张表包含两个本地文件；</li></ul><h1 id="4-InnoDB支持的四种事务隔离级别和区别"><a href="#4-InnoDB支持的四种事务隔离级别和区别" class="headerlink" title="4.InnoDB支持的四种事务隔离级别和区别"></a>4.InnoDB支持的四种事务隔离级别和区别</h1><p>四种隔离级别：读未提交，读已提交，可重复读，串行化；</p><p>这部分直接去看我的<a href="https://blog.musnow.top/posts/3474107655/">MySQL索引</a>博客，里面详细介绍了区别，这里就不重写一遍了；</p><h1 id="5-CHAR和VARCHAR的区别"><a href="#5-CHAR和VARCHAR的区别" class="headerlink" title="5.CHAR和VARCHAR的区别"></a>5.CHAR和VARCHAR的区别</h1><ul><li>char是定长字符串，最长255；varchar是变长字符串，最长65535；</li><li>这就意味着varchar需要更多空间来存放当前字符串长度等信息，并且会根据当前字符串长度动态开辟空间大小，不会有额外的存储空间浪费；</li><li>而char是定死的空间，<code>char(8)</code>里面即便只有一个字符也会占用八个的空间（会用空格进行补齐）；</li><li>在字符串长度确定的情况下，比如计算长度确定的MD5，那就可以用char定长存储；长度不确定的情况下，比如人名、邮箱等信息，可以采用varchar；</li></ul><p>顺带说一下varchar和text的区别；需要进行索引的长文可以用TEXT进行存储（注意，只有MyISAM支持全文索引）</p><ol><li>存储空间：VARCHAR列存储的内容长度是可变的，而TEXT列可以存储大量的可变长度的文本数据。VARCHAR在存储时会根据实际存储的内容长度进行调整，而TEXT没有固定的最大长度限制，可以用来存储非常长的文本。由于TEXT可以存储更大的数据量，因此它通常占用更多的存储空间。</li><li>查询性能：由于VARCHAR具有固定的最大长度限制，数据库可以更好地优化和管理存储空间，这可能会在某些情况下提升查询性能。而TEXT由于其可变长度和大容量，可能会对某些查询操作稍有影响。</li><li>索引和排序：VARCHAR可以被索引和排序，这意味着可以根据这些列进行快速搜索和排序操作。而TEXT类型通常不直接支持索引和排序，需要额外的配置和处理才能实现类似的功能。</li></ol><p>如下user1表做测试，会发现我们无法给TEXT类型上普通索引。给出的提示是，<code>BLOG/TEXT</code>类型不能在没有指定长度的时候上索引；因为你的长度不确定，如果MySQL将一个几万字的TEXT存到内存里面作为索引节点，那么就会占用过多的内存空间。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">MariaDB [hello_mysql]&gt; desc user1;</span><br><span class="line">+-------+------------------+------+-----+---------+-------+</span><br><span class="line">| Field | Type             | Null | Key | Default | Extra |</span><br><span class="line">+-------+------------------+------+-----+---------+-------+</span><br><span class="line">| id    | int(10) unsigned | NO   | PRI | NULL    |       |</span><br><span class="line">| name  | varchar(200)     | NO   |     | NULL    |       |</span><br><span class="line">| info  | text             | NO   |     | NULL    |       |</span><br><span class="line">+-------+------------------+------+-----+---------+-------+</span><br><span class="line">3 rows in set (0.001 sec)</span><br><span class="line">MariaDB [hello_mysql]&gt; alter table user1 add index(info);</span><br><span class="line">ERROR 1170 (42000): BLOB/TEXT column &#x27;info&#x27; used in key specification without a key length</span><br></pre></td></tr></table></figure><p>即便在创建列的时候给定了TEXT的长度，依旧不能创建索引。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">MariaDB [hello_mysql]&gt; alter table user1 add info1 TEXT(20) NOT NULL;</span><br><span class="line">Query OK, 0 rows affected (0.002 sec)</span><br><span class="line">Records: 0  Duplicates: 0  Warnings: 0</span><br><span class="line"></span><br><span class="line">MariaDB [hello_mysql]&gt; desc user1;</span><br><span class="line">+-------+------------------+------+-----+---------+-------+</span><br><span class="line">| Field | Type             | Null | Key | Default | Extra |</span><br><span class="line">+-------+------------------+------+-----+---------+-------+</span><br><span class="line">| id    | int(10) unsigned | NO   | PRI | NULL    |       |</span><br><span class="line">| name  | varchar(200)     | NO   |     | NULL    |       |</span><br><span class="line">| info  | text             | NO   |     | NULL    |       |</span><br><span class="line">| info1 | tinytext         | NO   |     | NULL    |       |</span><br><span class="line">+-------+------------------+------+-----+---------+-------+</span><br><span class="line">4 rows in set (0.001 sec)</span><br><span class="line"></span><br><span class="line">MariaDB [hello_mysql]&gt; alter table user1 add index(info1);</span><br><span class="line">ERROR 1170 (42000): BLOB/TEXT column &#x27;info1&#x27; used in key specification without a key length</span><br></pre></td></tr></table></figure><p>正确的写法如下，需要在创建索引的时候，括号指定索引的长度；比如<code>index(info1(10))</code>含义就是给info1列的前10个字符建立索引。只要TEXT里面存放的文本前10个字符重复率低，那么这个索引就是有意义的！</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">MariaDB [hello_mysql]&gt; alter table user1 add index(info1(10));</span><br><span class="line">Query OK, 0 rows affected (0.007 sec)</span><br><span class="line">Records: 0  Duplicates: 0  Warnings: 0</span><br></pre></td></tr></table></figure><h1 id="6-主键和候选键-码-有啥区别？"><a href="#6-主键和候选键-码-有啥区别？" class="headerlink" title="6.主键和候选键(码)有啥区别？"></a>6.主键和候选键(码)有啥区别？</h1><p>候选键是一些可以选用（备选）为主键或者唯一键的类型；</p><p>比如一个学生表里面，包含学生主键的INT自增ID，学生学号，学生身份证，学生姓名，学生性别等等信息；在这个表里面，除了主键这个INT的ID，我们还可以把学生的学号和学生的身份证作为主键或者唯一键，因为他们都包含唯一性！</p><p>这时候，这些可以作为主键的列，就叫做候选键；</p><ul><li>候选键也需要保持唯一性</li><li>候选键需要遵循最小原则，不能是某一个聚合唯一标识的子集；（比如我需要用<strong>部门ID和部门内员工ID</strong>来唯一标识一个员工，此时部门ID就不能作为这个员工表的候选键，因为在整个表中部门ID会重复）</li></ul><p>在《数据库系统概率》这门课里面，会把键称作为码，本质上是一个东西。</p><blockquote><p>到底是谁把key翻译成码的？真无语😒</p></blockquote><h1 id="7-myisamchk是用来干什么的"><a href="#7-myisamchk是用来干什么的" class="headerlink" title="7.myisamchk是用来干什么的"></a>7.myisamchk是用来干什么的</h1><p>一个命令行工具（在bash下使用，不是在MySQL命令行使用）</p><blockquote><p>Myisamchk是MyISAM表维护的一个非常实用的工具。可以使用myisamchk实用程序来获得有关数据库表的信息或检查、修复、优化他们。myisamchk适用MyISAM表(对应.MYI和.MYD文件的表)。</p></blockquote><p>这个命令了解即可，下面是两篇使用博客。有需要再去深入学习用法</p><p><a href="http://www.4u4v.net/myisamchk-gadgets-manual.html">http://www.4u4v.net/myisamchk-gadgets-manual.html</a></p><p><a href="https://www.cnblogs.com/analyzer/articles/1381538.html">https://www.cnblogs.com/analyzer/articles/1381538.html</a></p><h1 id="8-如果表中有一列定义为TIMESTAMP会发生什么"><a href="#8-如果表中有一列定义为TIMESTAMP会发生什么" class="headerlink" title="8.如果表中有一列定义为TIMESTAMP会发生什么"></a>8.如果表中有一列定义为TIMESTAMP会发生什么</h1><p>TIMESTAMP底层一般是4个字节，在MySQL里面进行查询的时候，会根据系统时区，转成可读时间进行输出。包括使用cpp devel包获取到的也是可读时间；</p><p>因为只有4个字节，所以TIMESTAMP最多能表示 <code>1970-01-01 00:00:01</code>到<code>2038-01-19 03:14:07</code>，这也是一个2038年问题，需要改成8字节存储才能存放更长的时间。</p><p>另外，如果你想更加精确的标识时间，而不依赖于MySQL对时间戳的自动转换，那么就可以用BIGINT或者DECIMAL类型来存放时间戳数字，再在应用层进行时间戳和可读时间之间的转换。</p><h1 id="9-怎么看到表格定义的所有索引"><a href="#9-怎么看到表格定义的所有索引" class="headerlink" title="9.怎么看到表格定义的所有索引"></a>9.怎么看到表格定义的所有索引</h1><p>两种方式都可以</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> index <span class="keyword">from</span> 表名;</span><br><span class="line"><span class="keyword">show</span> keys <span class="keyword">from</span> 表名;</span><br></pre></td></tr></table></figure><h1 id="10-LIKE声明中的-是什么意思"><a href="#10-LIKE声明中的-是什么意思" class="headerlink" title="10.LIKE声明中的%是什么意思"></a>10.LIKE声明中的%是什么意思</h1><p>代表通配符，匹配所有字符串。下面举几个例子</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">查询 &#x27;张%&#x27;</span><br><span class="line">    张丽丽</span><br><span class="line">    张扣扣</span><br><span class="line">    张三</span><br><span class="line">    张阿斯顿</span><br><span class="line"></span><br><span class="line">查询 &#x27;%张%&#x27;</span><br><span class="line">里张里</span><br><span class="line">    十大张撒打发</span><br><span class="line"></span><br><span class="line">查询 &#x27;%张&#x27;</span><br><span class="line">xx张</span><br><span class="line">xxxxx张</span><br></pre></td></tr></table></figure><p>需要注意，只有<code>关键字%</code>的使用方式才能用上索引，另外两种匹配方式无法使用索引！</p><h1 id="11-列对比运算符是什么"><a href="#11-列对比运算符是什么" class="headerlink" title="11.列对比运算符是什么"></a>11.列对比运算符是什么</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">等于 =</span><br><span class="line">不等于 &lt;&gt; !=</span><br><span class="line">大于和大于等于  &gt; &gt;=</span><br><span class="line">小于和小于等于  &lt; &lt;=</span><br><span class="line">区间 BETWEEN .. AND ...</span><br><span class="line">是否在列表中 IN</span><br><span class="line">模糊匹配 LIKE</span><br><span class="line">NULL比较 IS NULL, IS NOT NULL</span><br></pre></td></tr></table></figure><h1 id="12-BLOB和TEXT有什么区别？"><a href="#12-BLOB和TEXT有什么区别？" class="headerlink" title="12.BLOB和TEXT有什么区别？"></a>12.BLOB和TEXT有什么区别？</h1><p>GPT说的：</p><ol><li>存储容量：BLOB可以存储二进制数据，而TEXT只能存储纯文本数据。</li><li>字符集排序规则：BLOB没有字符集排序规则，而TEXT有，默认为字符集的排序规则。</li><li>数据排序和比较：BLOB会按二进制方式进行排序和比较，而TEXT会按字符排序规则进行排序和比较。</li><li>存储方式：BLOB数据以二进制形式存储，没有字符集转换；而TEXT数据会根据字符集进行转换和存储。</li><li>索引：在MySQL中，BLOB和TEXT列可以有索引，但有一些限制。BLOB列或前缀索引的最大长度是768字节，对于UTF-8字符集是255个字符。而TEXT列或前缀索引的最大长度是3072字节，在UTF-8字符集中是1024个字符。</li><li>默认值：BLOB和TEXT列不能具有默认值。</li></ol><p>总的来说，BLOB适合存储二进制数据，例如图像、音频或视频文件等。而TEXT适合存储纯文本数据，如长文本、文章内容等。根据具体的需求，你可以选择适当的数据类型来存储相应的数据。</p><blockquote><p>实际上，把图片、音频这些静态资源存入数据库是不合理的……</p></blockquote><h1 id="13-MySQL-fetch-array和MySQL-fetch-obj有什么区别？"><a href="#13-MySQL-fetch-array和MySQL-fetch-obj有什么区别？" class="headerlink" title="13.MySQL_fetch_array和MySQL_fetch_obj有什么区别？"></a>13.MySQL_fetch_array和MySQL_fetch_obj有什么区别？</h1><p>PHP里面的函数，不学，直接跳过</p><h1 id="14-MyISAM表格将在那里存储？并且还提供其存储格式？"><a href="#14-MyISAM表格将在那里存储？并且还提供其存储格式？" class="headerlink" title="14.MyISAM表格将在那里存储？并且还提供其存储格式？"></a>14.MyISAM表格将在那里存储？并且还提供其存储格式？</h1><p>在linux下，MyISAM表格以文件形式存储在数据目录下的对应数据库目录中。每个表格对应一个.MYD数据文件（用于存储表格数据）和一个.MYI索引文件（用于存储表格索引），以及一个.frm表格定义文件（包含表格定义信息，如字段名、数据类型等）</p><p>MyISAM使用一种称为“静态行格式”的存储格式来存储表格数据。这种格式用于在磁盘上保存由定长行组成的表格，每个行定长，占用相同的存储空间，以便更快地读取和写入数据。MyISAM表格还支持动态行格式，这种格式允许可变行长度，因此可以更有效地存储可变长度的数据类型（如VARCHAR，TEXT等）。</p><h1 id="15-MySQL如何优化DISTINCT"><a href="#15-MySQL如何优化DISTINCT" class="headerlink" title="15.MySQL如何优化DISTINCT?"></a>15.MySQL如何优化DISTINCT?</h1><p>使用索引，减少查询行数来优化去重操作</p><h1 id="16-如何显示前50行？"><a href="#16-如何显示前50行？" class="headerlink" title="16.如何显示前50行？"></a>16.如何显示前50行？</h1><p>查询语句后带上limit就可以</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> 表名 limit <span class="number">50</span>;</span><br></pre></td></tr></table></figure><h1 id="17-可以使用多少列创建索引？"><a href="#17-可以使用多少列创建索引？" class="headerlink" title="17.可以使用多少列创建索引？"></a>17.可以使用多少列创建索引？</h1><p>根据实际使用场景来确定用几列，并没有固定限制。理论上来说需要保持最小原则，不要包含多余的无效列（除非你需要用来进行索引优化，减少回表操作）</p><h1 id="18-now和current-date有什么区别？"><a href="#18-now和current-date有什么区别？" class="headerlink" title="18.now和current_date有什么区别？"></a>18.now和current_date有什么区别？</h1><p>now会返回一直到时分秒的信息，current_date只会返回当日日期</p><h1 id="19-什么是非标准字符串类型"><a href="#19-什么是非标准字符串类型" class="headerlink" title="19.什么是非标准字符串类型"></a>19.什么是非标准字符串类型</h1><blockquote><p>GPT</p></blockquote><p>非标准字符串类型是指在数据库中没有明确定义或标准化的字符串数据类型。这些类型通常是特定数据库管理系统（DBMS）或应用程序开发框架所支持的扩展。由于不同的DBMS和框架有各自的特性和需求，可能会引入额外的非标准字符串类型以满足特定的数据存储和操作需求。</p><p>举例来说，MySQL数据库在其标准字符串类型中包含了CHAR、VARCHAR、TEXT等。而非标准字符串类型可能是根据具体需求和扩展开发的，如JSON、XML、BLOB、CLOB等。这些非标准类型在一些特定场景中使用广泛，例如存储非结构化的文本数据、大型二进制数据、以及存储和查询复杂的结构化数据等。</p><p>需要注意的是，非标准字符串类型在不同的DBMS和开发框架之间可能存在差异，并且在跨平台和迁移时可能会出现兼容性问题。因此，在使用非标准字符串类型时，建议仔细了解相关的文档和规范，并评估其对应用程序的影响和可移植性。</p><h1 id="20-什么是通用SQL函数"><a href="#20-什么是通用SQL函数" class="headerlink" title="20.什么是通用SQL函数"></a>20.什么是通用SQL函数</h1><p>以下列举了一些常见的通用SQL函数：</p><ol><li>聚合函数：如SUM、AVG、COUNT、MIN、MAX等，用于对数据进行统计和聚合计算。</li><li>字符串函数：如CONCAT、SUBSTRING、UPPER、LOWER、LENGTH等，用于处理和操作字符串数据。</li><li>数值函数：如ABS、ROUND、CEILING、FLOOR等，用于执行数值计算和转换。</li><li>日期和时间函数：如DATE, TIME, YEAR, MONTH, DAY等，用于处理日期和时间数据的计算和格式化。</li><li>条件函数：如IF, CASE WHEN, COALESCE等，用于根据条件执行不同的逻辑和返回不同的结果。</li><li>类型转换函数：如CAST、CONVERT等，用于在不同的数据类型之间进行转换。</li></ol><p>这只是一小部分通用SQL函数的例子，实际上还有很多其他的函数可用于不同的数据处理和查询需求。需要注意的是，尽管这些函数在大多数DBMS中都存在，但某些特定的DBMS可能会提供额外的函数或有稍微不同的语法，因此在使用函数时应查阅相应的文档和规范以确保兼容性和正确性。</p><h1 id="21-MySQL支持事务吗？"><a href="#21-MySQL支持事务吗？" class="headerlink" title="21.MySQL支持事务吗？"></a>21.MySQL支持事务吗？</h1><p>肯定支持，这个问题第四点就已经详细问了</p><h1 id="22-MySQL里面记录货币用什么类型好？"><a href="#22-MySQL里面记录货币用什么类型好？" class="headerlink" title="22.MySQL里面记录货币用什么类型好？"></a>22.MySQL里面记录货币用什么类型好？</h1><p>因为浮点数的精度问题，可以用BIGINT来存放以<strong>分</strong>为单位的货币，实际调用的时候再加上小数点，来保证数据准确。</p><p>如果不用BIGINT，那就需要用DECIMAL来存放货币。</p><blockquote><p>B站冲浪看到的</p></blockquote><h1 id="23-MySQL有关权限的表有那几个"><a href="#23-MySQL有关权限的表有那几个" class="headerlink" title="23.MySQL有关权限的表有那几个"></a>23.MySQL有关权限的表有那几个</h1><p>在MySQL中，有几个与权限相关的系统表和视图，用于管理用户、角色和权限。以下是一些常见的权限相关的表和视图：</p><ol><li>mysql.user：这个表包含了MySQL实例上的所有用户账户信息，包括用户名、密码等。该表记录了每个用户的全局权限。</li><li>mysql.db：这个表记录了用户对数据库级别的权限。它指定了哪个用户对哪个数据库具有什么样的权限。</li><li>mysql.tables_priv：这个表记录了用户对表级别的权限。它存储了用户对某个具体表的权限信息（如SELECT、INSERT、UPDATE、DELETE等）。</li><li>mysql.columns_priv：这个表记录了用户对列级别的权限。它存储了用户对表中某个具体列的权限信息。</li><li>mysql.procs_priv：这个表记录了用户对存储过程和函数的权限。</li><li>mysql.roles：这个表存储了角色的相关信息，包括角色名、角色的创建者等。</li></ol><p>除了上述的表之外，MySQL还提供了一些权限相关的视图，这些视图可以方便地查看用户、角色和权限的信息，如：</p><ul><li>information_schema.USER_PRIVILEGES：显示所有用户的权限信息。</li><li>information_schema.SCHEMA_PRIVILEGES：显示所有数据库的权限信息。</li><li>information_schema.TABLE_PRIVILEGES：显示所有表的权限信息。</li><li>information_schema.COLUMN_PRIVILEGES：显示所有列的权限信息。</li></ul><p>如下是个使用示例</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> information_schema.USER_PRIVILEGES;</span><br></pre></td></tr></table></figure><p>这些表和视图可以通过查询相应的系统表或视图来查看和管理用户、角色和权限。请注意，具体的系统表和视图名称可能因MySQL版本和配置而有所不同。为了确保准确性，请参考MySQL官方文档或特定版本的文档。</p><h1 id="24-列的字符串类型可以是什么"><a href="#24-列的字符串类型可以是什么" class="headerlink" title="24.列的字符串类型可以是什么"></a>24.列的字符串类型可以是什么</h1><p>TEXT CHAR VARCHAR，详见第五点</p><h1 id="25-MySQL作为发布系统的存储，一天五万条以上的增量，预计运维三年，如何优化？"><a href="#25-MySQL作为发布系统的存储，一天五万条以上的增量，预计运维三年，如何优化？" class="headerlink" title="25.MySQL作为发布系统的存储，一天五万条以上的增量，预计运维三年，如何优化？"></a>25.MySQL作为发布系统的存储，一天五万条以上的增量，预计运维三年，如何优化？</h1><blockquote><p>没见过这种业务，只能问GPT</p></blockquote><p>对于一个MySQL作为发布系统存储的场景，处理每天超过五万条增量数据并且需要保持三年的数据，以下是一些优化建议：</p><ol><li>数据库硬件和配置优化：<ul><li>硬件性能：确保数据库服务器具备足够的计算、内存和存储资源，以处理高负载的写入和读取操作。</li><li>存储设备：使用高性能的存储设备（如SSD）来提高写入和读取速度。</li><li>MySQL参数调优：根据实际情况调整MySQL的配置参数，例如设置合理的缓冲区大小、并发连接数、查询缓存等。</li></ul></li><li>数据库架构优化：<ul><li>分库分表：考虑将数据进行分库分表来分担单个数据库的负载压力。根据数据的特点和访问模式，合理划分数据到不同的库表中。</li><li>索引优化：根据查询需求创建合适的索引，以加快查询速度。避免过多的索引和冗余索引，以减少维护成本。</li><li>分区表：如果数据的时间范围有明显的界限，可以考虑使用MySQL的分区表功能，将数据按时间范围进行分区，提高查询性能和维护效率。</li></ul></li><li>数据写入优化：<ul><li>批量插入：使用批量插入方式（如INSERT INTO … VALUES (), (), ()…）来减少单条插入的开销，提高写入性能。</li><li>事务处理：将多个写入操作放在一个事务中，确保数据的一致性和完整性，减少IO开销。</li></ul></li><li>数据归档和压缩：<ul><li>数据归档：对于历史数据，可以将其归档到独立的存储介质中，例如将旧数据迁移到归档数据库或者离线存储系统中以减轻主数据库的负载。</li><li>数据压缩：对于不频繁查询的历史数据，可以考虑使用压缩算法（例如MySQL的压缩表功能或者第三方压缩库）进行存储，以减少存储空间占用。</li></ul></li><li>监控和优化工具：<ul><li>使用监控工具实时监测数据库的性能指标，如查询速度、磁盘使用、锁等情况，及时发现潜在的性能瓶颈并进行调优。</li><li>使用性能优化工具，如Explain分析、慢查询日志等，来找出慢查询和低效的SQL语句，并进行优化。</li></ul></li></ol><p>以上是一些常见的优化建议，具体优化方案还需要根据实际场景和需求进行调整。同时，建议在进行优化前，充分了解应用的读写特征、数据访问模式和业务需求，以便有针对性地进行优化工作。</p><h1 id="26-锁的优化策略？"><a href="#26-锁的优化策略？" class="headerlink" title="26.锁的优化策略？"></a>26.锁的优化策略？</h1><h1 id="27-索引的底层实现和优化？"><a href="#27-索引的底层实现和优化？" class="headerlink" title="27.索引的底层实现和优化？"></a>27.索引的底层实现和优化？</h1><p>底层用B+实现，优化索引方式见索引博客 <a href="https://blog.musnow.top/posts/3474107655/">https://blog.musnow.top/posts/3474107655/</a></p><h1 id="28-什么情况下有索引但是无法使用"><a href="#28-什么情况下有索引但是无法使用" class="headerlink" title="28.什么情况下有索引但是无法使用"></a>28.什么情况下有索引但是无法使用</h1><p>索引失效，见索引博客 <a href="https://blog.musnow.top/posts/3474107655/">https://blog.musnow.top/posts/3474107655/</a></p><h1 id="29-实践中如何优化MySQL"><a href="#29-实践中如何优化MySQL" class="headerlink" title="29.实践中如何优化MySQL"></a>29.实践中如何优化MySQL</h1><p>太宽泛了，不好回答</p><ul><li>索引优化</li><li>分表</li><li>事务隔离性选择</li></ul><h1 id="30-优化数据库的办法？"><a href="#30-优化数据库的办法？" class="headerlink" title="30.优化数据库的办法？"></a>30.优化数据库的办法？</h1><p>和29题重合，不做回答</p><h1 id="31-简单描述索引、主键、唯一索引、联合索引的区别，对数据库性能有什么影响（读写两方面）"><a href="#31-简单描述索引、主键、唯一索引、联合索引的区别，对数据库性能有什么影响（读写两方面）" class="headerlink" title="31.简单描述索引、主键、唯一索引、联合索引的区别，对数据库性能有什么影响（读写两方面）"></a>31.简单描述索引、主键、唯一索引、联合索引的区别，对数据库性能有什么影响（读写两方面）</h1><p>见索引博客 <a href="https://blog.musnow.top/posts/3474107655/">https://blog.musnow.top/posts/3474107655/</a></p><h1 id="32-数据库的事务是什么"><a href="#32-数据库的事务是什么" class="headerlink" title="32.数据库的事务是什么"></a>32.数据库的事务是什么</h1><p>见事务博客 <a href="https://blog.musnow.top/posts/2200233148/">https://blog.musnow.top/posts/2200233148/</a></p><h1 id="33-SQL注入漏洞的产生和原因，如何防止"><a href="#33-SQL注入漏洞的产生和原因，如何防止" class="headerlink" title="33.SQL注入漏洞的产生和原因，如何防止"></a>33.SQL注入漏洞的产生和原因，如何防止</h1><p>SQL注入漏洞是一种常见的安全漏洞，它可以使攻击者通过构造恶意的SQL语句来绕过应用程序的输入验证，进而执行非法的数据库操作或获取敏感信息。以下是SQL注入漏洞产生的原因和一些防止方法：</p><ol><li>原因：<ul><li>不正确的输入验证：当应用程序没有对用户的输入进行充分验证和过滤时，攻击者可以通过输入特定的字符或语句来修改SQL语句的结构，从而执行恶意操作。</li><li>拼接字符串构造SQL语句：如果应用程序使用拼接字符串的方式构造SQL查询语句，并且未对用户输入进行正确的转义处理，就容易受到SQL注入攻击。</li></ul></li><li>防止方法：<ul><li>使用参数化查询或预编译语句：参数化查询将用户输入作为参数传递给SQL语句，而不是直接拼接字符串。这样可以通过数据库驱动程序自动处理转义和编码，有效防止SQL注入攻击。</li><li>输入验证和过滤：对用户的输入数据进行验证和过滤，只接受符合规范的数据。可以使用白名单、黑名单、正则表达式等方法进行输入验证和过滤。</li><li>最小权限原则：在数据库中为应用程序使用的账号设置最小权限，即只授予应用程序完成必要操作所需的最低权限，避免攻击者利用注入漏洞进行更危险的操作。</li><li>不要直接暴露数据库错误信息：在生产环境中，不要将详细的数据库错误信息返回给用户，以防止攻击者从中获取关键信息。可以记录错误日志并给用户一个友好的错误提示。</li><li>定期更新和修补数据库和应用程序：及时安装数据库和应用程序的安全补丁，以修复已知的漏洞，并确保使用最新的安全措施。</li></ul></li></ol><p>总之，为了防止SQL注入漏洞，关键是要对用户输入数据进行合理验证、过滤和转义处理，并使用参数化查询或预编译语句来构造SQL语句。同时，保持应用程序和数据库的安全性，并及时更新和修补已知的安全漏洞。</p><h1 id="34-如何为表中字段选择合适数据类型"><a href="#34-如何为表中字段选择合适数据类型" class="headerlink" title="34.如何为表中字段选择合适数据类型"></a>34.如何为表中字段选择合适数据类型</h1><p>肯定是根据具体情况回答</p><h1 id="35-存储时期？"><a href="#35-存储时期？" class="headerlink" title="35.存储时期？"></a>35.存储时期？</h1><p>感觉这道题有问题，不管他</p><h1 id="36-索引相关问题？"><a href="#36-索引相关问题？" class="headerlink" title="36.索引相关问题？"></a>36.索引相关问题？</h1><p>和31重合，不回答</p><h1 id="37-解释MySQL中外连接、内连接、自连接的区别"><a href="#37-解释MySQL中外连接、内连接、自连接的区别" class="headerlink" title="37.解释MySQL中外连接、内连接、自连接的区别"></a>37.解释MySQL中外连接、内连接、自连接的区别</h1><ol><li>内连接（INNER JOIN）：<ul><li>内连接返回两个表中满足连接条件的记录，即只返回两个表中能够匹配的行。</li><li>内连接使用一个连接谓词（JOIN）或者在FROM子句中使用逗号（,）来表示。</li><li>内连接可以根据指定的连接条件将两个表中的列进行匹配。如果未提供连接条件，则会返回两个表的笛卡尔积。</li><li>语法示例：SELECT * FROM 表1 INNER JOIN 表2 ON 表1.列 &#x3D; 表2.列;</li></ul></li><li>外连接（OUTER JOIN）：<ul><li>外连接将返回两个表中满足连接条件的记录，并且还包括不满足连接条件的记录。</li><li>外连接分为左外连接（LEFT JOIN）和右外连接（RIGHT JOIN）。</li><li>左外连接返回左表中的所有记录，以及右表中与左表满足连接条件的记录。如果右表中没有匹配的记录，则会返回NULL值。</li><li>右外连接返回右表中的所有记录，以及左表中与右表满足连接条件的记录。如果左表中没有匹配的记录，则会返回NULL值。</li><li>语法示例：<ul><li>左外连接：SELECT * FROM 表1 LEFT JOIN 表2 ON 表1.列 &#x3D; 表2.列;</li><li>右外连接：SELECT * FROM 表1 RIGHT JOIN 表2 ON 表1.列 &#x3D; 表2.列;</li></ul></li></ul></li><li>自连接（SELF JOIN）：<ul><li>自连接是指将表视为两个独立的实例，使用别名来区分它们，然后根据某些条件将它们连接在一起。</li><li>自连接通常用于在同一个表中根据某种关系进行数据查询。</li><li>语法示例：SELECT 别名1.列, 别名2.列 FROM 表 别名1, 表 别名2 WHERE 别名1.列 &#x3D; 别名2.列;</li></ul></li></ol><p>总结：</p><ul><li>内连接返回两个表中匹配的记录，外连接返回满足连接条件的记录以及不满足连接条件的记录，而自连接是对同一个表进行连接操作。</li><li>内连接和外连接需要使用JOIN关键字，而自连接使用同一个表的别名进行连接。</li><li>内连接和外连接可以根据连接条件将两个表进行关联，而自连接可以根据表中的某些条件进行关联。</li></ul><h1 id="38-MySQL中事务回滚机制描述"><a href="#38-MySQL中事务回滚机制描述" class="headerlink" title="38.MySQL中事务回滚机制描述"></a>38.MySQL中事务回滚机制描述</h1><p>见事务博客 <a href="https://blog.musnow.top/posts/2200233148/">https://blog.musnow.top/posts/2200233148/</a></p><h1 id="39-SQL语言包含哪几部分？每部分都有哪些操作关键字"><a href="#39-SQL语言包含哪几部分？每部分都有哪些操作关键字" class="headerlink" title="39.SQL语言包含哪几部分？每部分都有哪些操作关键字"></a>39.SQL语言包含哪几部分？每部分都有哪些操作关键字</h1><p>包括DQL数据查询语言，DML数据操作语言（增删改），数据控制语言DCL用来管理数据库，事务控制语言TCL用来控制事务，数据定义语言DDL用来创建删除表</p><ol><li>数据查询语言（Data Query Language，DQL）：用于从数据库中查询和检索数据。常用的操作关键字包括：<ul><li>SELECT：用于从一个或多个表中选择数据列以进行查询。</li><li>FROM：指定要查询的表。</li><li>WHERE：用于指定查询的条件。</li><li>GROUP BY：按照指定的列对结果进行分组。</li><li>HAVING：用于指定对分组后的结果进行筛选的条件。</li><li>ORDER BY：指定结果集的排序方式。</li></ul></li><li>数据操作语言（Data Manipulation Language，DML）：用于对数据库中的数据进行增加、修改和删除操作。常用的操作关键字包括：<ul><li>INSERT INTO：向表中插入新的行或数据。</li><li>UPDATE：更新表中已有的数据。</li><li>DELETE FROM：从表中删除指定的行或数据。</li></ul></li><li>数据定义语言（Data Definition Language，DDL）：用于创建、修改和删除数据库和表结构。常用的操作关键字包括：<ul><li>CREATE DATABASE：创建新的数据库。</li><li>CREATE TABLE：创建新的数据表。</li><li>ALTER TABLE：修改已存在的数据表结构。</li><li>DROP DATABASE：删除现有的数据库。</li><li>DROP TABLE：删除现有的数据表。</li></ul></li><li>数据控制语言（Data Control Language，DCL）：用于管理数据库中的用户权限和访问权限。常用的操作关键字包括：<ul><li>GRANT：授予用户特定的权限。</li><li>REVOKE：撤销用户的权限。</li></ul></li><li>事务控制语言（Transaction Control Language，TCL）：用于管理数据库的事务处理。常用的操作关键字包括：<ul><li>COMMIT：提交一个事务，使其永久生效。</li><li>ROLLBACK：回滚一个事务，撤销之前的操作，使其不生效。</li><li>SAVEPOINT：在事务中设置保存点，以便在需要时进行回滚。</li></ul></li></ol><h1 id="40-完整性的约束包括那些？"><a href="#40-完整性的约束包括那些？" class="headerlink" title="40.完整性的约束包括那些？"></a>40.完整性的约束包括那些？</h1><p>原子性、隔离性、持久性；这里说的完整性应该就是一致性；</p><p>具体的解释依旧是去看事务的博客 <a href="https://blog.musnow.top/posts/2200233148/">https://blog.musnow.top/posts/2200233148/</a></p>]]></content>
    
    
    <summary type="html">字节MySQL连环40问</summary>
    
    
    
    <category term="学习sql" scheme="https://blog.musnow.top/categories/%E5%AD%A6%E4%B9%A0sql/"/>
    
    
    <category term="mysql" scheme="https://blog.musnow.top/tags/mysql/"/>
    
  </entry>
  
</feed>
