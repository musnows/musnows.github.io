<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>慕雪的寒舍</title>
  
  <subtitle>雪下了一夜</subtitle>
  <link href="https://blog.musnow.top/atom.xml" rel="self"/>
  
  <link href="https://blog.musnow.top/"/>
  <updated>2024-09-12T12:10:04.000Z</updated>
  <id>https://blog.musnow.top/</id>
  
  <author>
    <name>慕雪年华</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>【思源】思源笔记代码片段收集</title>
    <link href="https://blog.musnow.top/posts/612440692/"/>
    <id>https://blog.musnow.top/posts/612440692/</id>
    <published>2024-09-12T11:03:37.000Z</published>
    <updated>2024-09-12T12:10:04.000Z</updated>
    
    <content type="html"><![CDATA[<p>在论坛上收集的有效的思源代码片段，思源笔记版本v3.1.3。</p><p>在思源笔记<code>设置-外观-代码片段</code>中添加CSS或者JS代码片段并启用即可。</p><h2 id="1-CSS-表格宽度自适应"><a href="#1-CSS-表格宽度自适应" class="headerlink" title="1. CSS.表格宽度自适应"></a>1. CSS.表格宽度自适应</h2><p>使用如下代码块可以让表格自适应宽度（自动换行） </p><p>来源: <a href="https://ld246.com/article/1726116689636/comment/1726126776087#comments">https://ld246.com/article/1726116689636/comment/1726126776087#comments</a>；</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 表格宽度自适应 */</span></span><br><span class="line"><span class="selector-class">.b3-typography</span> <span class="selector-tag">table</span>, <span class="selector-class">.protyle-wysiwyg</span> <span class="selector-tag">table</span> &#123;</span><br><span class="line"><span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">    <span class="attribute">display</span>: table;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>添加前，表格超长后需要滚动才能看到后续内容</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/09/2169a3e87f8300792804cbc39588f11a.png" alt="image.png"></p><p>添加后，宽度自适应，无需滚动</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/09/9b39e59e95015fb7b581b320ca430f14.png" alt="image.png"></p><h2 id="2-CSS-代码块MAC美化"><a href="#2-CSS-代码块MAC美化" class="headerlink" title="2. CSS.代码块MAC美化"></a>2. CSS.代码块MAC美化</h2><p>默认情况下思源的代码块和其他块的差距没有那么明显，这里给出CSS片段，可以在不安装代码块美化插件的情况下直接让你的代码块变成MAC样式。</p><p>来源：<a href="https://ld246.com/article/1715315635131">https://ld246.com/article/1715315635131</a>；</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br></pre></td><td class="code"><pre><span class="line">pre <span class="selector-tag">code</span><span class="selector-class">.hljs</span> &#123;</span><br><span class="line">    <span class="attribute">display</span>: block;</span><br><span class="line">    <span class="attribute">overflow-x</span>: auto;</span><br><span class="line">    <span class="attribute">padding</span>: <span class="number">1em</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">code</span><span class="selector-class">.hljs</span> &#123;</span><br><span class="line">    <span class="attribute">padding</span>: <span class="number">3px</span> <span class="number">5px</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.hljs-comment</span>,</span><br><span class="line"><span class="selector-class">.hljs-quote</span> &#123;</span><br><span class="line">    <span class="attribute">color</span>: <span class="number">#969896</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.hljs-deletion</span>,</span><br><span class="line"><span class="selector-class">.hljs-name</span>,</span><br><span class="line"><span class="selector-class">.hljs-regexp</span>,</span><br><span class="line"><span class="selector-class">.hljs-selector-class</span>,</span><br><span class="line"><span class="selector-class">.hljs-selector-id</span>,</span><br><span class="line"><span class="selector-class">.hljs-tag</span>,</span><br><span class="line"><span class="selector-class">.hljs-template-variable</span>,</span><br><span class="line"><span class="selector-class">.hljs-variable</span> &#123;</span><br><span class="line">    <span class="attribute">color</span>: <span class="number">#d54e53</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.hljs-built_in</span>,</span><br><span class="line"><span class="selector-class">.hljs-link</span>,</span><br><span class="line"><span class="selector-class">.hljs-literal</span>,</span><br><span class="line"><span class="selector-class">.hljs-meta</span>,</span><br><span class="line"><span class="selector-class">.hljs-number</span>,</span><br><span class="line"><span class="selector-class">.hljs-params</span>,</span><br><span class="line"><span class="selector-class">.hljs-type</span> &#123;</span><br><span class="line">    <span class="attribute">color</span>: <span class="number">#e78c45</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.hljs-attribute</span> &#123;</span><br><span class="line">    <span class="attribute">color</span>: <span class="number">#e7c547</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.hljs-addition</span>,</span><br><span class="line"><span class="selector-class">.hljs-bullet</span>,</span><br><span class="line"><span class="selector-class">.hljs-string</span>,</span><br><span class="line"><span class="selector-class">.hljs-symbol</span> &#123;</span><br><span class="line">    <span class="attribute">color</span>: <span class="number">#b9ca4a</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.hljs-section</span>,</span><br><span class="line"><span class="selector-class">.hljs-title</span> &#123;</span><br><span class="line">    <span class="attribute">color</span>: <span class="number">#7aa6da</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.hljs-keyword</span>,</span><br><span class="line"><span class="selector-class">.hljs-selector-tag</span> &#123;</span><br><span class="line">    <span class="attribute">color</span>: <span class="number">#c397d8</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.hljs</span> &#123;</span><br><span class="line">    <span class="attribute">background</span>: <span class="number">#282828</span>; <span class="comment">/* 如果是3.1.5需要把这个改成 #000 */</span></span><br><span class="line">    <span class="attribute">color</span>: <span class="number">#eaeaea</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.hljs-emphasis</span> &#123;</span><br><span class="line">    <span class="attribute">font-style</span>: italic</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.hljs-strong</span> &#123;</span><br><span class="line">    <span class="attribute">font-weight</span>: <span class="number">700</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 代码块背景设置 */</span></span><br><span class="line"><span class="selector-class">.b3-typography</span> <span class="selector-class">.code-block</span><span class="selector-pseudo">:not</span>(pre), <span class="selector-class">.protyle-wysiwyg</span> <span class="selector-class">.code-block</span><span class="selector-pseudo">:not</span>(pre) &#123;</span><br><span class="line">    <span class="attribute">padding</span>: <span class="number">2em</span> <span class="number">1em</span> <span class="number">1.6em</span>;</span><br><span class="line">    <span class="attribute">margin</span>: <span class="number">1em</span> <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">box-sizing</span>: border-box;</span><br><span class="line">    <span class="attribute">background-color</span>: <span class="number">#282828</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.code-block</span><span class="selector-pseudo">::after</span> &#123;</span><br><span class="line">    <span class="attribute">content</span>: <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    <span class="attribute">position</span>: absolute;</span><br><span class="line">    <span class="attribute">background</span>: <span class="number">#fa625c</span>;</span><br><span class="line">    <span class="attribute">box-shadow</span>: <span class="number">23px</span> <span class="number">0</span> <span class="number">#fdbc40</span>, <span class="number">45px</span> <span class="number">0</span> <span class="number">#35cd4b</span>;</span><br><span class="line">    <span class="attribute">border-radius</span>: <span class="built_in">var</span>(--b3-border-radius-round);</span><br><span class="line">    <span class="attribute">top</span>: <span class="number">10px</span>;</span><br><span class="line">    <span class="attribute">left</span>: <span class="number">15px</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">12px</span>;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">12px</span>;</span><br><span class="line">    <span class="attribute">z-index</span>: <span class="number">1</span>;</span><br><span class="line">    <span class="attribute">border-radius</span>: <span class="number">6px</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="selector-class">.b3-typography</span> <span class="selector-class">.code-block</span><span class="selector-pseudo">:not</span>(pre) <span class="selector-class">.protyle-action</span> <span class="selector-class">.protyle-action__language</span>, <span class="selector-class">.protyle-wysiwyg</span> <span class="selector-class">.code-block</span><span class="selector-pseudo">:not</span>(pre) <span class="selector-class">.protyle-action</span> <span class="selector-class">.protyle-action__language</span> &#123;</span><br><span class="line">    <span class="attribute">font-size</span>: <span class="number">85%</span>;</span><br><span class="line">    <span class="attribute">color</span>: <span class="number">#fff8ed</span>;</span><br><span class="line">    <span class="attribute">margin-top</span>: <span class="number">0px</span>;</span><br><span class="line">    <span class="attribute">align-self</span>: center;</span><br><span class="line">    <span class="attribute">margin-left</span>: <span class="number">75px</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.code-block</span> <span class="selector-class">.protyle-action</span> <span class="selector-class">.protyle-action__copy</span>, <span class="selector-class">.code-block</span> <span class="selector-class">.protyle-action</span> <span class="selector-class">.protyle-action__menu</span> &#123;</span><br><span class="line">    <span class="attribute">margin-top</span>: <span class="number">0px</span>;</span><br><span class="line">    <span class="attribute">color</span>: <span class="number">#fff</span>;</span><br><span class="line">    <span class="attribute">background-color</span>: <span class="built_in">var</span>(--S-list-background);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里改用官方的默认黑色主题midnight来测试，修改前，代码块和其他部分区分度纯靠颜色，而且字体离代码块边缘太近了。</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/09/6ef82fdbac1db7b705a676ae1db1e1b1.png" alt="image.png"></p><p>修改后，顿时好看多了。</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/09/f3ce2aea89979e6f6031be99bf3f5f64.png" alt="image.png"></p><h2 id="3-CSS-JS-多级列表子弹线"><a href="#3-CSS-JS-多级列表子弹线" class="headerlink" title="3. CSS+JS.多级列表子弹线"></a>3. CSS+JS.多级列表子弹线</h2><p>来源: <a href="https://ld246.com/article/1693238082034">https://ld246.com/article/1693238082034</a>;</p><p>css片段</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* REF https://github.com/svchord/Rem-Craft */</span></span><br><span class="line"><span class="selector-class">.protyle-wysiwyg</span> <span class="selector-attr">[data-node-id]</span><span class="selector-class">.li</span><span class="selector-pseudo">:has</span>(<span class="selector-class">.block-focus</span>)&gt;<span class="selector-class">.protyle-action</span>&#123;</span><br><span class="line">    <span class="attribute">color</span>:<span class="built_in">rgb</span>(<span class="number">70</span>, <span class="number">110</span>, <span class="number">220</span>);;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.protyle-wysiwyg</span> <span class="selector-attr">[data-node-id]</span><span class="selector-class">.li</span><span class="selector-pseudo">:has</span>(<span class="selector-class">.block-focus</span>)&gt;<span class="selector-class">.protyle-action</span> svg&#123;</span><br><span class="line">    <span class="attribute">margin</span>:<span class="number">0</span>;</span><br><span class="line">    <span class="attribute">width</span>:<span class="number">16px</span>;</span><br><span class="line">    <span class="attribute">height</span>:<span class="number">16px</span>;</span><br><span class="line">    <span class="attribute">padding</span>:<span class="number">0px</span> <span class="number">0px</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.protyle-wysiwyg</span> <span class="selector-attr">[data-node-id]</span><span class="selector-class">.li</span><span class="selector-pseudo">:has</span>(<span class="selector-class">.block-focus</span>)&gt;<span class="selector-class">.list</span><span class="selector-pseudo">:has</span>(<span class="selector-class">.block-focus</span>)&gt;<span class="selector-class">.li</span><span class="selector-pseudo">::after</span>&#123;</span><br><span class="line">    <span class="attribute">content</span>:<span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="attribute">display</span>:block;</span><br><span class="line">    <span class="attribute">position</span>:absolute;</span><br><span class="line">    <span class="attribute">pointer-events</span>:none;</span><br><span class="line">    <span class="attribute">width</span>:<span class="number">34px</span>;</span><br><span class="line">    <span class="attribute">left</span>:-<span class="number">18px</span>;</span><br><span class="line">    <span class="attribute">top</span>:-<span class="number">20px</span>;</span><br><span class="line">    <span class="attribute">border-style</span>:solid;</span><br><span class="line">    <span class="attribute">border-color</span>:<span class="built_in">rgb</span>(<span class="number">70</span>, <span class="number">110</span>, <span class="number">220</span>);;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.protyle-wysiwyg</span> <span class="selector-attr">[data-node-id]</span><span class="selector-class">.li</span><span class="selector-pseudo">:has</span>(<span class="selector-class">.block-focus</span>)&gt;<span class="selector-class">.list</span><span class="selector-pseudo">:has</span>(<span class="selector-class">.block-focus</span>)&gt;<span class="selector-class">.li</span><span class="selector-pseudo">:not</span>(<span class="selector-pseudo">:has</span>(<span class="selector-class">.block-focus</span>))<span class="selector-pseudo">::after</span>&#123;</span><br><span class="line">    <span class="attribute">bottom</span>:-<span class="number">2px</span>;</span><br><span class="line">    <span class="attribute">border-width</span>:<span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">2px</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.protyle-wysiwyg</span> <span class="selector-attr">[data-node-id]</span><span class="selector-class">.li</span><span class="selector-pseudo">:has</span>(<span class="selector-class">.block-focus</span>)&gt;<span class="selector-class">.list</span><span class="selector-pseudo">:has</span>(<span class="selector-class">.block-focus</span>)&gt;<span class="selector-class">.li</span><span class="selector-pseudo">:has</span>(<span class="selector-class">.block-focus</span>)<span class="selector-pseudo">::after</span>&#123;</span><br><span class="line">    <span class="attribute">height</span>:<span class="number">38px</span>;</span><br><span class="line">    <span class="attribute">border-radius</span>:<span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">8px</span>;</span><br><span class="line">    <span class="attribute">border-width</span>:<span class="number">0</span> <span class="number">0</span> <span class="number">2px</span> <span class="number">2px</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.protyle-wysiwyg</span> <span class="selector-attr">[data-node-id]</span><span class="selector-class">.li</span><span class="selector-pseudo">:has</span>(<span class="selector-class">.block-focus</span>)&gt;<span class="selector-class">.list</span><span class="selector-pseudo">:has</span>(<span class="selector-class">.block-focus</span>)&gt;<span class="selector-class">.li</span><span class="selector-pseudo">:has</span>(<span class="selector-class">.block-focus</span>)~<span class="selector-class">.li</span><span class="selector-pseudo">:not</span>(<span class="selector-pseudo">:has</span>(<span class="selector-class">.block-focus</span>))<span class="selector-pseudo">::after</span>&#123;</span><br><span class="line">    <span class="attribute">border-color</span>:<span class="built_in">rgba</span>(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.protyle-wysiwyg</span> <span class="selector-attr">[data-node-id]</span><span class="selector-class">.li</span><span class="selector-pseudo">:has</span>(<span class="selector-class">.block-focus</span>)&gt;<span class="selector-class">.list</span><span class="selector-pseudo">:has</span>(<span class="selector-class">.block-focus</span>)&gt;<span class="selector-class">.li</span><span class="selector-attr">[data-subtype=o]</span><span class="selector-pseudo">::after</span>&#123;</span><br><span class="line">    <span class="attribute">width</span>:<span class="number">24px</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.protyle-wysiwyg</span> <span class="selector-attr">[data-node-id]</span><span class="selector-class">.li</span><span class="selector-pseudo">:has</span>(<span class="selector-class">.block-focus</span>)&gt;<span class="selector-class">.list</span><span class="selector-pseudo">:has</span>(<span class="selector-class">.block-focus</span>)&gt;<span class="selector-class">.li</span><span class="selector-attr">[data-subtype=t]</span><span class="selector-pseudo">::after</span>&#123;</span><br><span class="line">    <span class="attribute">width</span>:<span class="number">28px</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.protyle-wysiwyg</span> <span class="selector-attr">[data-node-id]</span><span class="selector-class">.li</span><span class="selector-pseudo">:has</span>(<span class="selector-class">.block-focus</span>)&gt;<span class="selector-attr">[data-node-id]</span><span class="selector-pseudo">::after</span>&#123;</span><br><span class="line">    <span class="attribute">content</span>:<span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="attribute">display</span>:block;</span><br><span class="line">    <span class="attribute">position</span>:absolute;</span><br><span class="line">    <span class="attribute">pointer-events</span>:none;</span><br><span class="line">    <span class="attribute">width</span>:<span class="number">34px</span>;</span><br><span class="line">    <span class="attribute">left</span>:-<span class="number">18px</span>;</span><br><span class="line">    <span class="attribute">top</span>:-<span class="number">20px</span>;</span><br><span class="line">    <span class="attribute">border-style</span>:solid;</span><br><span class="line">    <span class="attribute">border-color</span>:<span class="built_in">rgb</span>(<span class="number">70</span>, <span class="number">110</span>, <span class="number">220</span>);</span><br><span class="line">    <span class="attribute">top</span>:<span class="number">20px</span>;</span><br><span class="line">    <span class="attribute">height</span>:<span class="built_in">calc</span>(<span class="number">100%</span> + <span class="number">4px</span>);</span><br><span class="line">    <span class="attribute">border-width</span>:<span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">2px</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.protyle-wysiwyg</span> <span class="selector-attr">[data-node-id]</span><span class="selector-class">.li</span><span class="selector-pseudo">:has</span>(<span class="selector-class">.block-focus</span>)&gt;<span class="selector-attr">[data-node-id]</span><span class="selector-pseudo">:has</span>(+<span class="selector-class">.list</span>)<span class="selector-pseudo">::after</span>&#123;</span><br><span class="line">    <span class="attribute">height</span>:auto;</span><br><span class="line">    <span class="attribute">bottom</span>:<span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.protyle-wysiwyg</span> <span class="selector-attr">[data-node-id]</span><span class="selector-class">.li</span><span class="selector-pseudo">:has</span>(<span class="selector-class">.block-focus</span>)&gt;<span class="selector-attr">[data-node-id]</span><span class="selector-attr">[data-type=NodeHeading]</span><span class="selector-pseudo">::after</span>&#123;</span><br><span class="line">    <span class="attribute">top</span>:<span class="number">0</span>;</span><br><span class="line">    <span class="attribute">height</span>:<span class="number">185%</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.protyle-wysiwyg</span> <span class="selector-attr">[data-node-id]</span><span class="selector-class">.li</span><span class="selector-pseudo">:has</span>(<span class="selector-class">.block-focus</span>)&gt;<span class="selector-attr">[data-node-id]</span><span class="selector-class">.list</span><span class="selector-pseudo">:has</span>(<span class="selector-class">.block-focus</span>)<span class="selector-pseudo">::after</span>,<span class="selector-class">.protyle-wysiwyg</span> <span class="selector-attr">[data-node-id]</span><span class="selector-class">.li</span><span class="selector-pseudo">:has</span>(<span class="selector-class">.block-focus</span>)&gt;<span class="selector-attr">[data-node-id]</span><span class="selector-class">.list</span><span class="selector-pseudo">:has</span>(<span class="selector-class">.block-focus</span>)~<span class="selector-attr">[data-node-id]</span><span class="selector-pseudo">::after</span>,<span class="selector-class">.protyle-wysiwyg</span> <span class="selector-attr">[data-node-id]</span><span class="selector-class">.li</span><span class="selector-pseudo">:has</span>(<span class="selector-class">.block-focus</span>)&gt;<span class="selector-attr">[data-node-id]</span><span class="selector-class">.bq</span><span class="selector-pseudo">:has</span>(<span class="selector-class">.block-focus</span>)<span class="selector-pseudo">::after</span>,<span class="selector-class">.protyle-wysiwyg</span> <span class="selector-attr">[data-node-id]</span><span class="selector-class">.li</span><span class="selector-pseudo">:has</span>(<span class="selector-class">.block-focus</span>)&gt;<span class="selector-attr">[data-node-id]</span><span class="selector-class">.bq</span><span class="selector-pseudo">:has</span>(<span class="selector-class">.block-focus</span>)~<span class="selector-attr">[data-node-id]</span><span class="selector-pseudo">::after</span>,<span class="selector-class">.protyle-wysiwyg</span> <span class="selector-attr">[data-node-id]</span><span class="selector-class">.li</span><span class="selector-pseudo">:has</span>(<span class="selector-class">.block-focus</span>)&gt;<span class="selector-attr">[data-node-id]</span><span class="selector-class">.sb</span><span class="selector-pseudo">:has</span>(<span class="selector-class">.block-focus</span>)<span class="selector-pseudo">::after</span>,<span class="selector-class">.protyle-wysiwyg</span> <span class="selector-attr">[data-node-id]</span><span class="selector-class">.li</span><span class="selector-pseudo">:has</span>(<span class="selector-class">.block-focus</span>)&gt;<span class="selector-attr">[data-node-id]</span><span class="selector-class">.sb</span><span class="selector-pseudo">:has</span>(<span class="selector-class">.block-focus</span>)~<span class="selector-attr">[data-node-id]</span><span class="selector-pseudo">::after</span>&#123;</span><br><span class="line">    <span class="attribute">border-color</span>:<span class="built_in">rgba</span>(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.protyle-wysiwyg</span> <span class="selector-attr">[data-node-id]</span><span class="selector-class">.li</span><span class="selector-pseudo">:has</span>(<span class="selector-class">.block-focus</span>)<span class="selector-attr">[fold=<span class="string">&quot;1&quot;</span>]</span>&gt;<span class="selector-attr">[data-node-id]</span><span class="selector-pseudo">::after</span>,<span class="selector-class">.protyle-wysiwyg</span> <span class="selector-attr">[data-node-id]</span><span class="selector-class">.li</span><span class="selector-pseudo">:has</span>(<span class="selector-class">.block-focus</span>)<span class="selector-pseudo">:has</span>(&gt;<span class="selector-class">.block-focus</span>)&gt;<span class="selector-attr">[data-node-id]</span><span class="selector-pseudo">::after</span>&#123;</span><br><span class="line">    <span class="attribute">border-color</span>:<span class="built_in">rgba</span>(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.protyle-wysiwyg</span> <span class="selector-attr">[data-node-id]</span><span class="selector-class">.li</span><span class="selector-pseudo">:has</span>(<span class="selector-class">.block-focus</span>)<span class="selector-attr">[data-subtype=o]</span><span class="selector-pseudo">:has</span>(<span class="selector-class">.block-focus</span>)&gt;<span class="selector-class">.list</span><span class="selector-pseudo">:has</span>(<span class="selector-class">.block-focus</span>)&gt;<span class="selector-class">.li</span><span class="selector-pseudo">::after</span>&#123;</span><br><span class="line">    <span class="attribute">top</span>:-<span class="number">10px</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.protyle-wysiwyg</span> <span class="selector-attr">[data-node-id]</span><span class="selector-class">.li</span><span class="selector-pseudo">:has</span>(<span class="selector-class">.block-focus</span>)<span class="selector-attr">[data-subtype=o]</span><span class="selector-pseudo">:has</span>(<span class="selector-class">.block-focus</span>)&gt;<span class="selector-class">.list</span><span class="selector-pseudo">:has</span>(<span class="selector-class">.block-focus</span>)&gt;<span class="selector-class">.li</span><span class="selector-pseudo">:has</span>(<span class="selector-class">.block-focus</span>)<span class="selector-pseudo">::after</span>&#123;</span><br><span class="line">    <span class="attribute">height</span>:<span class="number">28px</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.protyle-wysiwyg</span> <span class="selector-attr">[data-node-id]</span><span class="selector-class">.li</span><span class="selector-pseudo">:has</span>(<span class="selector-class">.block-focus</span>)<span class="selector-attr">[data-subtype=t]</span><span class="selector-pseudo">:has</span>(<span class="selector-class">.block-focus</span>)&gt;<span class="selector-class">.protyle-action</span>&#123;</span><br><span class="line">    <span class="attribute">color</span>:<span class="built_in">rgb</span>(<span class="number">70</span>, <span class="number">110</span>, <span class="number">220</span>); <span class="comment">/* 子弹线颜色修改这里 */</span> </span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.protyle-wysiwyg</span> <span class="selector-attr">[data-node-id]</span><span class="selector-class">.li</span><span class="selector-pseudo">:has</span>(<span class="selector-class">.block-focus</span>)<span class="selector-attr">[data-subtype=t]</span><span class="selector-pseudo">:has</span>(<span class="selector-class">.block-focus</span>)&gt;<span class="selector-class">.protyle-action</span> svg&#123;</span><br><span class="line">    <span class="attribute">margin</span>:<span class="number">0</span>;</span><br><span class="line">    <span class="attribute">width</span>:<span class="number">14px</span>;</span><br><span class="line">    <span class="attribute">height</span>:<span class="number">14px</span>;</span><br><span class="line">    <span class="attribute">padding</span>:<span class="number">0px</span> <span class="number">0px</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.protyle-wysiwyg</span> <span class="selector-attr">[data-node-id]</span><span class="selector-class">.li</span><span class="selector-pseudo">:has</span>(<span class="selector-class">.block-focus</span>)<span class="selector-attr">[data-subtype=t]</span><span class="selector-pseudo">:has</span>(<span class="selector-class">.block-focus</span>)&gt;<span class="selector-class">.list</span><span class="selector-pseudo">:has</span>(<span class="selector-class">.block-focus</span>)&gt;<span class="selector-class">.li</span><span class="selector-pseudo">::after</span>&#123;</span><br><span class="line">    <span class="attribute">top</span>:-<span class="number">14px</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.protyle-wysiwyg</span> <span class="selector-attr">[data-node-id]</span><span class="selector-class">.li</span><span class="selector-pseudo">:has</span>(<span class="selector-class">.block-focus</span>)<span class="selector-attr">[data-subtype=t]</span><span class="selector-pseudo">:has</span>(<span class="selector-class">.block-focus</span>)&gt;<span class="selector-class">.list</span><span class="selector-pseudo">:has</span>(<span class="selector-class">.block-focus</span>)&gt;<span class="selector-class">.li</span><span class="selector-pseudo">:has</span>(<span class="selector-class">.block-focus</span>)<span class="selector-pseudo">::after</span>&#123;</span><br><span class="line">    <span class="attribute">height</span>:<span class="number">32px</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.protyle-wysiwyg</span> <span class="selector-attr">[data-node-id]</span><span class="selector-class">.li</span><span class="selector-pseudo">:has</span>(<span class="selector-class">.block-focus</span>)<span class="selector-attr">[data-subtype=t]</span><span class="selector-pseudo">:has</span>(<span class="selector-class">.block-focus</span>)<span class="selector-class">.protyle-task--done</span>&gt;<span class="selector-class">.list</span><span class="selector-pseudo">:has</span>(<span class="selector-class">.block-focus</span>)&gt;<span class="selector-class">.li</span><span class="selector-pseudo">::after</span>&#123;</span><br><span class="line">    <span class="attribute">border-color</span>:<span class="built_in">rgba</span>(<span class="number">139</span>, <span class="number">139</span>, <span class="number">139</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>js片段</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 缓存编辑器块并处理聚焦状态的函数定义</span></span><br><span class="line"><span class="keyword">let</span> cachedEditorBlocks = []; <span class="comment">// 缓存所有编辑器块</span></span><br><span class="line"><span class="keyword">let</span> focusedBlock = <span class="literal">null</span>; <span class="comment">// 缓存当前聚焦的块</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化缓存</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">initEditorBlocksCache</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> editors = <span class="variable language_">document</span>.<span class="title function_">querySelectorAll</span>(<span class="string">&#x27;.protyle-wysiwyg&#x27;</span>);</span><br><span class="line">    editors.<span class="title function_">forEach</span>(<span class="function"><span class="params">editor</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!editor.<span class="property">classList</span>.<span class="title function_">contains</span>(<span class="string">&#x27;NodeAttributeView&#x27;</span>)) &#123;</span><br><span class="line">            cachedEditorBlocks.<span class="title function_">push</span>(...editor.<span class="title function_">querySelectorAll</span>(<span class="string">&#x27;[data-node-id]&#x27;</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 更新聚焦状态并维护缓存</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">handleBlockFocus</span>(<span class="params">e</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> target;</span><br><span class="line">    <span class="keyword">if</span> (e.<span class="property">type</span> === <span class="string">&#x27;mouseup&#x27;</span>) &#123;</span><br><span class="line">        <span class="comment">// 鼠标事件，查找最近的具有data-node-id属性的元素</span></span><br><span class="line">        target = e.<span class="property">target</span>.<span class="title function_">closest</span>(<span class="string">&#x27;[data-node-id]&#x27;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (e.<span class="property">type</span> === <span class="string">&#x27;keyup&#x27;</span>) &#123;</span><br><span class="line">        <span class="comment">// 键盘事件，查找当前焦点所在的具有data-node-id属性的元素</span></span><br><span class="line">        <span class="keyword">const</span> activeElement = <span class="variable language_">document</span>.<span class="property">activeElement</span>;</span><br><span class="line">        <span class="keyword">if</span> (activeElement.<span class="property">classList</span>.<span class="title function_">contains</span>(<span class="string">&#x27;protyle-wysiwyg&#x27;</span>)) &#123;</span><br><span class="line">            target = <span class="variable language_">window</span>.<span class="title function_">getSelection</span>()?.<span class="property">focusNode</span>?.<span class="property">parentElement</span>;</span><br><span class="line">            <span class="keyword">while</span> (target &amp;&amp; !target.<span class="property">dataset</span>.<span class="property">nodeId</span>) &#123;</span><br><span class="line">                target = target.<span class="property">parentElement</span>;</span><br><span class="line">                <span class="keyword">if</span> (!target) <span class="keyword">break</span>; <span class="comment">// 避免空指针异常</span></span><br><span class="line">                <span class="keyword">if</span> (target.<span class="property">classList</span>.<span class="title function_">contains</span>(<span class="string">&#x27;NodeAttributeView&#x27;</span>)) &#123;</span><br><span class="line">                    target = <span class="literal">null</span>; <span class="comment">// 如果找到NodeAttributeView，则不处理该元素</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!target || target === focusedBlock) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (focusedBlock) &#123;</span><br><span class="line">        focusedBlock.<span class="property">classList</span>.<span class="title function_">remove</span>(<span class="string">&#x27;block-focus&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    focusedBlock = target;</span><br><span class="line">    focusedBlock.<span class="property">classList</span>.<span class="title function_">add</span>(<span class="string">&#x27;block-focus&#x27;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根据需要调用相关功能，例如：</span></span><br><span class="line">    <span class="comment">// setSelector(focusedBlock);</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化编辑器块缓存</span></span><br><span class="line"><span class="title function_">initEditorBlocksCache</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 绑定事件监听器</span></span><br><span class="line"><span class="variable language_">document</span>.<span class="title function_">addEventListener</span>(<span class="string">&#x27;mouseup&#x27;</span>, handleBlockFocus, <span class="literal">true</span>);</span><br><span class="line"><span class="variable language_">document</span>.<span class="title function_">addEventListener</span>(<span class="string">&#x27;keyup&#x27;</span>, handleBlockFocus, <span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 立即调用的异步函数表达式，执行handleBlockFocus并输出日志</span></span><br><span class="line">(<span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">    <span class="comment">// 这里我们调用handleBlockFocus函数，但由于它不返回Promise，所以不需要await</span></span><br><span class="line">    <span class="title function_">handleBlockFocus</span>(&#123; <span class="attr">type</span>: <span class="string">&#x27;dummy&#x27;</span> &#125;); <span class="comment">// 模拟事件调用</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;加载子弹线成功&#x27;</span>);</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure><p>添加以后，在点击多级列表的时候，会出现蓝色子弹线</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/09/41ae6bdf77a6165699c9d7ffb13e5de8.png" alt="image.png"></p><h2 id="4-CSS-给标签添加井号"><a href="#4-CSS-给标签添加井号" class="headerlink" title="4. CSS.给标签添加井号"></a>4. CSS.给标签添加井号</h2><p>默认的文内标签和文章标题标签都没有井号，看起来多少有点奇怪（特别是文内标签），可以用如下代码块来处理一下</p><p>来源：<a href="https://ld246.com/article/1725865228744">https://ld246.com/article/1725865228744</a></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 标题 标签 */</span></span><br><span class="line"><span class="selector-class">.b3-chip--secondary</span>, <span class="selector-class">.b3-chip--primary</span>, <span class="selector-class">.b3-chip--info</span>, <span class="selector-class">.b3-chip--success</span>, <span class="selector-class">.b3-chip--warning</span>, </span><br><span class="line"><span class="selector-class">.b3-chip--warning</span>, <span class="selector-class">.b3-chip--error</span>, <span class="selector-class">.b3-chip--pink</span> &#123;</span><br><span class="line">    <span class="attribute">mix-blend-mode</span>: normal <span class="meta">!important</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.b3-chip--secondary</span><span class="selector-pseudo">::before</span>, <span class="selector-class">.b3-chip--primary</span><span class="selector-pseudo">::before</span>, <span class="selector-class">.b3-chip--info</span><span class="selector-pseudo">::before</span>, <span class="selector-class">.b3-chip--success</span><span class="selector-pseudo">::before</span>, <span class="selector-class">.b3-chip--warning</span><span class="selector-pseudo">::before</span>, <span class="selector-class">.b3-chip--warning</span><span class="selector-pseudo">::before</span>, <span class="selector-class">.b3-chip--error</span><span class="selector-pseudo">::before</span>, <span class="selector-class">.b3-chip--pink</span><span class="selector-pseudo">::before</span> &#123;</span><br><span class="line">    <span class="attribute">content</span>: <span class="string">&quot;#&quot;</span> <span class="meta">!important</span>;</span><br><span class="line">    <span class="attribute">margin-right</span>: <span class="number">5px</span>;  <span class="comment">/* # 号距离文字的距离 */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.protyle-background</span> <span class="selector-class">.b3-chip--secondary</span> &#123;</span><br><span class="line">    <span class="attribute">color</span>: <span class="number">#fff</span> <span class="meta">!important</span>;</span><br><span class="line">    <span class="attribute">background-color</span>:  <span class="number">#d6ff0070</span> <span class="meta">!important</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.protyle-background</span> <span class="selector-class">.b3-chip--primary</span> &#123;</span><br><span class="line">    <span class="attribute">color</span>: <span class="number">#fff</span> <span class="meta">!important</span>;</span><br><span class="line">    <span class="attribute">background-color</span>: <span class="number">#0053f9c4</span> <span class="meta">!important</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.protyle-background</span> <span class="selector-class">.b3-chip--info</span> &#123;</span><br><span class="line">    <span class="attribute">color</span>: <span class="built_in">var</span>(--b3-card-info-color) <span class="meta">!important</span>;</span><br><span class="line">    <span class="attribute">background-color</span>: <span class="number">#28405c</span> <span class="meta">!important</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.protyle-background</span> <span class="selector-class">.b3-chip--success</span> &#123;</span><br><span class="line">    <span class="attribute">color</span>: <span class="built_in">var</span>(--b3-card-success-color) <span class="meta">!important</span>;</span><br><span class="line">    <span class="attribute">background-color</span>: <span class="number">#425347</span> <span class="meta">!important</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.protyle-background</span> <span class="selector-class">.b3-chip--warning</span> &#123;</span><br><span class="line">    <span class="attribute">color</span>: <span class="built_in">var</span>(--b3-card-warning-color) <span class="meta">!important</span>;</span><br><span class="line">    <span class="attribute">background-color</span>: <span class="number">#554636</span> <span class="meta">!important</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.protyle-background</span> <span class="selector-class">.b3-chip--error</span> &#123;</span><br><span class="line">    <span class="attribute">color</span>: <span class="built_in">var</span>(--b3-card-error-color) <span class="meta">!important</span>;</span><br><span class="line">    <span class="attribute">background-color</span>: <span class="number">#442724</span> <span class="meta">!important</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.protyle-background</span> <span class="selector-class">.b3-chip--pink</span> &#123;</span><br><span class="line">    <span class="attribute">color</span>: <span class="built_in">var</span>(--b3-theme-on-secondary) <span class="meta">!important</span>;</span><br><span class="line">    <span class="attribute">background-color</span>: <span class="number">#ea4aaa96</span> <span class="meta">!important</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 行内标签 */</span></span><br><span class="line"><span class="selector-class">.protyle-wysiwyg</span> <span class="selector-attr">[data-node-id]</span> <span class="selector-tag">span</span><span class="selector-attr">[data-type~=tag]</span> &#123;</span><br><span class="line">    <span class="attr">--tag-color</span>: <span class="number">#97B9DA</span>;</span><br><span class="line">    <span class="attribute">font-size</span>: <span class="number">80%</span>;</span><br><span class="line">    <span class="attribute">border-radius</span>: <span class="number">1em</span>;</span><br><span class="line">    <span class="attribute">padding</span>: .<span class="number">1em</span> .<span class="number">5em</span> .<span class="number">15em</span>;</span><br><span class="line">    <span class="attribute">border</span>: none;</span><br><span class="line">    <span class="attribute">box-shadow</span>: <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> .<span class="number">065em</span> inset <span class="built_in">var</span>(--tag-color);</span><br><span class="line">    <span class="attribute">background-color</span>: <span class="number">#28405c</span> <span class="meta">!important</span>;</span><br><span class="line">    <span class="attribute">color</span>: <span class="built_in">var</span>(--tag-color) ;</span><br><span class="line">    <span class="attribute">box-decoration-break</span>: clone;</span><br><span class="line">    -webkit-<span class="attribute">box-decoration-break</span>: clone;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.protyle-wysiwyg</span> <span class="selector-attr">[data-node-id]</span> <span class="selector-tag">span</span><span class="selector-attr">[data-type~=tag]</span><span class="selector-pseudo">::before</span> &#123;</span><br><span class="line">    <span class="attribute">content</span>: <span class="string">&quot;#&quot;</span> <span class="meta">!important</span>;</span><br><span class="line">    <span class="attribute">margin-right</span>: <span class="number">5px</span>;  <span class="comment">/* # 号距离文字的距离 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>修改前，行内标签那是完全看不出来</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/09/7804f4178591a505ec9d4072043e356e.png" alt="image.png"></p><p>修改后，正常多了</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/09/35c2f43414ed7ec4846d0068c0c5af62.png" alt="image.png"></p><p>这一点我觉得是思源本身默认主题的设置就有问题，就算没有井号，也不能是毫无辨识度的背景色吧。</p><h2 id="5-CSS-分割线加粗"><a href="#5-CSS-分割线加粗" class="headerlink" title="5. CSS.分割线加粗"></a>5. CSS.分割线加粗</h2><p>这一个真的非常需要，默认情况（如果不换主题）的分割线实在是看不出来！！</p><p>来源：<a href="https://ld246.com/article/1700551933609">https://ld246.com/article/1700551933609</a>;</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 更改分割线样式 CSS片段 */</span></span><br><span class="line"><span class="selector-class">.hr</span> &#123;</span><br><span class="line">  <span class="attribute">border</span>: none;</span><br><span class="line">  <span class="attribute">position</span>: relative;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.hr</span><span class="selector-pseudo">::before</span> &#123;</span><br><span class="line">  <span class="attribute">content</span>: <span class="string">&quot;&quot;</span>;</span><br><span class="line">  <span class="attribute">position</span>: absolute;</span><br><span class="line">  <span class="attribute">top</span>: <span class="number">50%</span>;</span><br><span class="line">  <span class="attribute">left</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">right</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">2px</span>; <span class="comment">/* 粗细 */</span></span><br><span class="line">  <span class="attribute">background-color</span>: white; <span class="comment">/* 颜色 */</span></span><br><span class="line">  <span class="attribute">transform</span>: <span class="built_in">translateY</span>(-<span class="number">50%</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>修改前</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/09/e68998e941f1653f8f91cbcf313df870.png" alt="image.png"></p><p>修改后</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/09/de310946863d053de10b25dc2523ddbd.png" alt="image.png"></p><h2 id="6-CSS-自定义荧光笔颜色"><a href="#6-CSS-自定义荧光笔颜色" class="headerlink" title="6. CSS.自定义荧光笔颜色"></a>6. CSS.自定义荧光笔颜色</h2><p>如题，这里的颜色是RGB的十六进制码，随便百度一个RGB颜色网站就能选你想要的颜色和对应的十六进制码了。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 自定义标记颜色 CSS片段 */</span></span><br><span class="line"><span class="selector-pseudo">:root</span>&#123;</span><br><span class="line"><span class="attr">--b3-protyle-inline-mark-background</span>: <span class="number">#F9FC093B</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>来源：<a href="https://ld246.com/article/1700551933609#%E8%87%AA%E5%AE%9A%E4%B9%89%E6%A0%87%E8%AE%B0%E9%A2%9C%E8%89%B2-CSS%E7%89%87%E6%AE%B5">https://ld246.com/article/1700551933609#%E8%87%AA%E5%AE%9A%E4%B9%89%E6%A0%87%E8%AE%B0%E9%A2%9C%E8%89%B2-CSS%E7%89%87%E6%AE%B5</a></p><h2 id="7-CSS-外观菜单字体变粗"><a href="#7-CSS-外观菜单字体变粗" class="headerlink" title="7. CSS.外观菜单字体变粗"></a>7. CSS.外观菜单字体变粗</h2><p>默认情况下思源的外观菜单（就是选字体颜色的哪一个）看不清，可以处理一下</p><p>来源：<a href="https://ld246.com/article/1702095793605/comment/1702105185880?r=a2930610542#comments">https://ld246.com/article/1702095793605/comment/1702105185880?r=a2930610542#comments</a></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.protyle-util</span> <span class="selector-class">.color__square</span><span class="selector-attr">[data-type=<span class="string">&quot;color&quot;</span>]</span>&#123;<span class="attribute">font-weight</span>:bold&#125;</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/09/2c3dbeaf4edf05a817c3546409e48ae0.png" alt="image.png"></p><p>不过，这种类markdown的编辑器，个人始终不建议修改文字的颜色和大小（特别是修改大小）。因为markdown本身生出来就是想让你别考虑排版的，有些人写的博客里面大大小小的字都有，原本作者是想突出一些重点，但是看上去是真不舒服！反而劣化了读者体验。</p><p>编辑markdown应该通过文字加粗、引用块、斜体、行内代码块来实现不同文字的强调或弱化，而不是用文字大小或者文字颜色来处理！这一观点嵌入到了我编辑markdown的基本思路中，所以本站的文章你是很难看到有什么特殊的字体颜色的（除了少数特别特别严重的说明我会用<font color=Red>红色</font>来标注）。</p><p>以上为个人想法，不适用于所有人，欢迎讨论。</p>]]></content>
    
    
    <summary type="html">在论坛上收集的有效的思源代码片段</summary>
    
    
    
    <category term="差生文具多" scheme="https://blog.musnow.top/categories/%E5%B7%AE%E7%94%9F%E6%96%87%E5%85%B7%E5%A4%9A/"/>
    
    <category term="编程工具" scheme="https://blog.musnow.top/categories/%E5%B7%AE%E7%94%9F%E6%96%87%E5%85%B7%E5%A4%9A/%E7%BC%96%E7%A8%8B%E5%B7%A5%E5%85%B7/"/>
    
    
    <category term="思源笔记" scheme="https://blog.musnow.top/tags/%E6%80%9D%E6%BA%90%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>【博客】记录一次针对本站评论系统的恶意攻击</title>
    <link href="https://blog.musnow.top/posts/4149071678/"/>
    <id>https://blog.musnow.top/posts/4149071678/</id>
    <published>2024-09-03T07:54:23.000Z</published>
    <updated>2024-09-05T23:06:38.000Z</updated>
    
    <content type="html"><![CDATA[<p>记录一次针对本站waline评论系统的恶意攻击。</p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>首先，本站在切换到butterfly主题之后，<strong>基本都是使用artalk评论系统进行评论</strong>，之前有一段时间使用了butterfly的多评论系统共存的功能，但是在我关闭该功能之前，waline没有收到任何新的评论。</p><p>本站的waline评论系统是采用vercel部署的，在hexo配置中虽然取消使用了该评论系统，但并没有取消vercel的部署和域名的解析，即本站旧的waline的服务依旧可用。</p><p>根据配置文件的git提交记录，2023.12.10的提交中，本站的waline评论系统被彻底隐藏，而且在keep主题留档站点中也没有开启评论系统。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">commit e7ca8edf4f2c0512bf654abed9b911e78871e32e</span><br><span class="line">Author: musnow &lt;muxue@musnow.top&gt;</span><br><span class="line">Date:   Sun Dec 10 15:05:13 2023 +0800</span><br><span class="line"></span><br><span class="line">    配置 取消waline选项，仅仅使用artalk</span><br></pre></td></tr></table></figure><p>也就是说，理论上在2023.12.10之后，waline系统不应该被本站的普通读者发现和使用。</p><h2 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h2><p>但是，在2024.09.03上午，也就是撰写这篇文章的同一天，本站的waline博客收到了不明生物的<strong>小规模</strong>“攻击”，主要情况如下：</p><p>该用户使用不存在的邮箱<code>test@example.com</code>在waline发送大量评论，触发邮件系统的大量邮件退信。因为waline需要用户注册才能以已登录用户的身份发送评论，此时会有用户注册的验证邮件，该验证邮件被退信，大约24条。</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/09/995abe1454328fff33c0930fceb8fc4b.png" alt="image.png"></p><p>该用户发送了大量只包含GIF动图的评论，尚且不清楚这些只包含图片的评论中是否暗藏玄机。它还发送了<strong>包含SQL语句</strong>的评论，尝试对评论系统后端进行SQL注入攻击。</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/09/5610909c1d18f1adb8a9e8001d8946c3.png" alt="image.png"></p><p>该用户尝试在waline的用户邮箱、用户名字、用户域名、甚至url处进行SQL注入攻击。</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/09/d09499da570c3ef73e0e26988c054bc6.png" alt="image.png"></p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/09/098cb6acbff9672fced4e63b4656cdea.png" alt="image.png"></p><h2 id="SQL注入攻击"><a href="#SQL注入攻击" class="headerlink" title="SQL注入攻击"></a>SQL注入攻击</h2><p>这里将<strong>评论</strong>中的这条sql语句剥离出来，问问GPT它的功能（我对SQL注入攻击不太懂）</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(<span class="keyword">select</span>(<span class="number">0</span>)<span class="keyword">from</span>(<span class="keyword">select</span>(sleep(<span class="number">15</span>)))v)<span class="comment">/*&#x27;+(select(0)from(select(sleep(15)))v)+&#x27;&quot;+(select(0)from(select(sleep(15)))v)+&quot;*/</span></span><br></pre></td></tr></table></figure><p>以下是GPT的原话：</p><ul><li>这段注入代码的主要部分是<code>(select(0)from(select(sleep(15)))v)</code>，这是一个子查询，使用SLEEP(15)函数来延迟SQL查询的执行15秒。<code>SELECT SLEEP(15)</code>会让数据库在执行该查询时暂停15秒，然后返回结果（在这里返回0）。</li><li><code>/* ... */</code>是SQL中的注释符号，用于忽略注释中的内容。在注入中，这可以用来闭合或注释掉原有的SQL代码，使得攻击者的代码得以执行。</li><li><code>&#39;+ ... +&#39;+</code>和<code>&quot;+ ... +&quot;</code>是用于拼接字符串的符号，分别针对单引号和双引号上下文。这些符号试图适应不同的SQL拼接方式，以确保注入代码能够在各种情况下都被正确执行。</li></ul><p>最终的基本理念就是，通过<code>sleep(15)</code>尝试让数据库进行休眠，根据接口返回的延迟，判断SQL注入是否成功。</p><p>再看看link中的SQL语句</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0</span><span class="string">&#x27;XOR(if(now()=sysdate(),sleep(15),0))XOR&#x27;</span>Z</span><br></pre></td></tr></table></figure><p>GPT原话：</p><ul><li><code>now()</code> 和 <code>sysdate()</code> 是SQL中的时间函数，通常返回当前的时间戳。尽管它们在大多数数据库中返回相同的结果，攻击者利用它们来测试是否可以执行代码。</li><li><code>if(now()=sysdate(),sleep(15),0)</code> 是一个条件判断语句：如果<code>now()</code>和<code>sysdate()</code>相等（几乎总是相等的），那么就执行 <code>SLEEP(15)</code>。否则，返回 0。</li><li>这个逻辑使用了 XOR 来试图绕过某些简单的SQL过滤机制。XOR 是一种位操作符，用于在两值之间执行异或操作。在这里，它被用于修改SQL查询的逻辑，试图绕过常规的过滤机制。</li></ul><p>这个注入代码的意图是通过引入条件语句和时间延迟函数来探测SQL注入漏洞。如果注入成功，数据库将执行 <code>SLEEP(15)</code>，导致查询延迟15秒，从而帮助攻击者判断注入是否成功。</p><h2 id="后话"><a href="#后话" class="headerlink" title="后话"></a>后话</h2><p>可惜了，<strong>waline用的数据库是leancloud，压根不存在SQL的操作</strong>，SQL注入自然是失败啦！</p><p>发现这个问题的时候，我使用腾讯云微信小程序紧急关闭了指向waline的子域名的DNS解析，但在关闭解析后对方仍然在不断地发送评论（因为此时对方已经知道服务器的IP地址了，请求并不存在DNS解析步骤），于是直接通过手机操作vercel，删除了waline的项目部署，恶意请求才得以消停。</p><p>感觉vercel应该出一个<code>停止服务</code>的按钮，这样就不用删除整个项目了，以后想用也不需要重新配置。可能vercel有这个功能，但是当时在手机上并没有找到。</p><blockquote><p>此次攻击，准确来说是攻击的尝试，规模较小，发送评论的时间间隔大，发送的内容差距大，慕雪认为这是一次<strong>人工操作</strong>，并非脚本自动化攻击。</p></blockquote><p>最后，还是希望大家不要去做这种没有任何意义，只会给别人造成损失，甚至违规违法的操作。切记，网络不是法外之地！</p>]]></content>
    
    
    <summary type="html">记录一次针对本站waline评论系统的恶意攻击</summary>
    
    
    
    <category term="差生文具多" scheme="https://blog.musnow.top/categories/%E5%B7%AE%E7%94%9F%E6%96%87%E5%85%B7%E5%A4%9A/"/>
    
    <category term="博客建站" scheme="https://blog.musnow.top/categories/%E5%B7%AE%E7%94%9F%E6%96%87%E5%85%B7%E5%A4%9A/%E5%8D%9A%E5%AE%A2%E5%BB%BA%E7%AB%99/"/>
    
    
    <category term="博客建站" scheme="https://blog.musnow.top/tags/%E5%8D%9A%E5%AE%A2%E5%BB%BA%E7%AB%99/"/>
    
    <category term="vercel" scheme="https://blog.musnow.top/tags/vercel/"/>
    
  </entry>
  
  <entry>
    <title>【Hexo】hexo-butterfly主题添加tag标签文章数量上下标</title>
    <link href="https://blog.musnow.top/posts/3905192158/"/>
    <id>https://blog.musnow.top/posts/3905192158/</id>
    <published>2024-09-01T02:03:00.000Z</published>
    <updated>2024-09-01T02:11:12.000Z</updated>
    
    <content type="html"><![CDATA[<p>hexo-butterfly主题添加tag标签文章数量上下标。</p><p>本文操作引用自<a href="https://blog.eurkon.com/post/6687849c.html">Butterfly 标签云增加文章数上下标</a>博客，故不声明为原创。</p><h2 id="需要修改的文件"><a href="#需要修改的文件" class="headerlink" title="需要修改的文件"></a>需要修改的文件</h2><p>找到<code>Blog\themes\butterfly\scripts\helpers\page.js</code>文件，定位其中<code>cloudTags</code>这个函数的注册处，这里用了一个类似C++中lambda表达式的方式注册了一个函数，用于处理彩色的标签云，你可以在butterfly主题中搜索，找到更多关于这个函数的调用处</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Blog\themes\butterfly\layout\includes\widget\card_tags.pug</span><br><span class="line">Blog\themes\butterfly\layout\includes\page\tags.pug</span><br></pre></td></tr></table></figure><p>我们需要修改的是这个函数中最终显示tag的位置，在后面追加一个上标<code>&lt;sup&gt;$&#123;tag.length&#125;&lt;/sup&gt;</code>或者下标<code>&lt;sub&gt;$&#123;tag.length&#125;&lt;/sub&gt;</code>即可！其中tag对象的length参数就是这个tag的文章数量。</p><p>修改前</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">result += <span class="string">`&lt;a href=&quot;<span class="subst">$&#123;env.url_for(tag.path)&#125;</span>&quot; style=&quot;<span class="subst">$&#123;style&#125;</span>&quot;&gt;<span class="subst">$&#123;tag.name&#125;</span>&lt;sup&gt;<span class="subst">$&#123;tag.length&#125;</span>&lt;/sup&gt;&lt;/a&gt;`</span></span><br></pre></td></tr></table></figure><p>修改后</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">result += <span class="string">`&lt;a href=&quot;<span class="subst">$&#123;env.url_for(tag.path)&#125;</span>&quot; style=&quot;<span class="subst">$&#123;style&#125;</span>&quot;&gt;<span class="subst">$&#123;tag.name&#125;</span>&lt;sup&gt;<span class="subst">$&#123;tag.length&#125;</span>&lt;/sup&gt;&lt;/a&gt;`</span></span><br></pre></td></tr></table></figure><h2 id="效果"><a href="#效果" class="headerlink" title="效果"></a>效果</h2><p>修改完成之后hexo三板斧操作一下</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo cl &amp;&amp; hexo s</span><br></pre></td></tr></table></figure><p>可以在本地预览到效果</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/09/4dfcb50a412147d592f8ef45a3282f75.png" alt="image.png"></p><p>侧边栏也是有的。</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/09/a575a521f99422158e6d35ac1956f035.png" alt="image.png"></p><p>这样就搞定啦！</p>]]></content>
    
    
    <summary type="html">hexo-butterfly主题添加tag标签文章数量上下标</summary>
    
    
    
    <category term="差生文具多" scheme="https://blog.musnow.top/categories/%E5%B7%AE%E7%94%9F%E6%96%87%E5%85%B7%E5%A4%9A/"/>
    
    <category term="博客建站" scheme="https://blog.musnow.top/categories/%E5%B7%AE%E7%94%9F%E6%96%87%E5%85%B7%E5%A4%9A/%E5%8D%9A%E5%AE%A2%E5%BB%BA%E7%AB%99/"/>
    
    
    <category term="博客建站" scheme="https://blog.musnow.top/tags/%E5%8D%9A%E5%AE%A2%E5%BB%BA%E7%AB%99/"/>
    
    <category term="Hexo" scheme="https://blog.musnow.top/tags/Hexo/"/>
    
  </entry>
  
  <entry>
    <title>【win】windows部署minio，实现内网S3同步思源</title>
    <link href="https://blog.musnow.top/posts/2869712310/"/>
    <id>https://blog.musnow.top/posts/2869712310/</id>
    <published>2024-08-24T00:40:27.000Z</published>
    <updated>2024-08-27T23:09:10.000Z</updated>
    
    <content type="html"><![CDATA[<p>windows部署minio，实现内网S3同步思源。</p><h2 id="1-什么是minio？"><a href="#1-什么是minio？" class="headerlink" title="1. 什么是minio？"></a>1. 什么是minio？</h2><p>关于minio和S3同步的介绍，可以看本站的这篇文章：<a href="https://blog.musnow.top/posts/1950951389">【docker】部署minio对象存储并用rclone同步</a>。</p><p>思源笔记支持S3同步，且比起webdav，<strong>始终更加推荐S3协议</strong>来同步思源笔记。</p><p>本文的内容适用于如下场景：</p><ol><li>我只想在内网的其他机器上同步思源笔记。比如我只是想有一个快捷的方式能把PC写的笔记同步到手机APP上，在手机上基本只作电脑不在身旁时的临时阅读使用。</li><li>我对同步的实时性要求不高，每天回家之后可以执行一次同步让手机的文档更新即可。</li></ol><p>在这个场景中，用户的需求并不是需要跨多个网络的云端同步，只是想用同步做一个中转站，能把数据从PC快捷导入到手机上而已。某种意义上说，我就是这类用户。</p><p><strong>由于对同步的实时性要求不高</strong>，完全可以通过在windows主机上自建minio的方式来实现内网的思源笔记S3同步，这样就不需要去购买云端的S3服务了。</p><blockquote><p>即便在这个场景下，云端S3的资费并不高，但这笔钱还是可以省下来嘛。</p></blockquote><p>在<a href="https://min.io/download?license=agpl&platform=windows">minio的官网</a>上，就贴出了在windows下部署minio的命令，还有更详细的<a href="https://min.io/docs/minio/windows/index.html">部署教程</a>。注意要选择的是非Enterprise的这个栏目，Enterprise的是企业专业版，需要购买授权。</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/08/28e0f104efc9a54c5f4b968b11e570d3.png" alt="image.png"></p><p>本文将用一个win10的虚拟机带大家走一遍这个安装流程，毕竟我之前也没部署过windows下的。</p><p>在部署了之后，我会切换到宿主机（模拟内网中的另外一台机器）和手机app，尝试用思源笔记进行同步操作，以确认该方案的可行性。</p><p>使用的思源笔记版本为<code>v3.1.3</code>。</p><h2 id="2-开整"><a href="#2-开整" class="headerlink" title="2. 开整"></a>2. 开整</h2><p>把官方的命令copy过来，试试运行。</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">PS</span>&gt; <span class="built_in">Invoke-WebRequest</span> <span class="literal">-Uri</span> <span class="string">&quot;https://dl.min.io/server/minio/release/windows-amd64/minio.exe&quot;</span> <span class="literal">-OutFile</span> <span class="string">&quot;C:\minio.exe&quot;</span></span><br><span class="line"><span class="built_in">PS</span>&gt; setx MINIO_ROOT_USER admin</span><br><span class="line"><span class="built_in">PS</span>&gt; setx MINIO_ROOT_PASSWORD password</span><br><span class="line"><span class="built_in">PS</span>&gt; C:\minio.exe server F:\Data <span class="literal">--console-address</span> <span class="string">&quot;:9001&quot;</span></span><br></pre></td></tr></table></figure><p>注意，第一个命令是用来下载文件的，你可以直接在官网也没点击download下载<code>minio.exe</code>，这样就可以不用命令行了。edge会提示你“通常不会保留minio.exe”，点击更多选项里面的<strong>仍然保留</strong>即可。</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/08/516097d4a0c3ce6e5ebd703965d85245.png" alt="image.png"></p><p>这里我将其放到桌面的minio文件夹里面，然后用powershell命令行进入这个文件夹</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/08/3f36c5641ef79c690dc9603c0ee036e0.png" alt="image.png"></p><blockquote><p>备注：win10自带的powershell界面简陋，建议去微软商店下载最新版本的windows terminal终端工具，更好看。</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/08/fc940e311e149c35eed21fda56668f62.png" alt="image.png"></p></blockquote><p>win10在<strong>系统搜索栏</strong>里面搜索powershell，将其打开，输入如下命令进入桌面的minio文件夹。</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> C:\Users\用户名\Desktop\minio</span><br></pre></td></tr></table></figure><p>进入桌面的minio文件夹了以后，执行官方给出的三个命令，前两个命令是用来设置初试的管理员用户和密码的。第三个命令是启动minio服务端，这里我修改了原本给出的启动命令里面的F盘，<strong>那个是minio的文件保存目录</strong>，我将其修改成了和<code>minio.exe</code>同级目录中的data文件夹。</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> C:\Users\用户名\Desktop\minio</span><br><span class="line">setx MINIO_ROOT_USER muxue</span><br><span class="line">setx MINIO_ROOT_PASSWORD <span class="number">123456</span></span><br><span class="line">.\minio.exe server .\data <span class="literal">--console-address</span> <span class="string">&quot;:9001&quot;</span></span><br></pre></td></tr></table></figure><p>键入启动命令后，会弹出防火墙提示，点击允许访问即可。</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/08/0334cc4eb0d99db57f13d6a053b31a66.png" alt="image.png"></p><p>到这里，其实minio服务端就已经启动了。可以用<code>http://192.168.154.131:9001</code>放问控制台界面。</p><p><strong>但是，启动命令的输出最下方有一个警告</strong>。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">WARN: Detected default credentials &#x27;minioadmin:minioadmin&#x27;, we recommend that you change these values with &#x27;MINIO_ROOT_USER&#x27; and &#x27;MINIO_ROOT_PASSWORD&#x27; environment variables</span><br></pre></td></tr></table></figure><p>警告说默认的账户和密码并没有被修改，推荐使用<code>MINIO_ROOT_USER</code>和<code>MINIO_ROOT_PASSWORD</code>环境变量将其修改。这说明刚刚我执行过的两个<code>setx</code>命令并没有生效，即便命令的提示是“指定值已经保存”。我猜测是因为powershell没有用<strong>管理员身份</strong>执行，尝试用管理员身份重新启动一个powershell，再次执行如上命令。</p><p>果然，用管理员身份启动powershell，执行了<code>setx</code>命令后，重新启动minio，报错变成了下面这个：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">FATAL Unable to validate credentials inherited from the shell environment: Invalid credentials</span><br><span class="line">      &gt; Please provide correct credentials</span><br><span class="line">      HINT:</span><br><span class="line">        MINIO_ROOT_USER length should be at least 3, and MINIO_ROOT_PASSWORD length at least 8 characters</span><br></pre></td></tr></table></figure><p>这个报错的含义是，用户名至少3个字符，用户密码至少8个字符，而刚刚我只设置了6个字符的密码，需要重新修改一下密码。</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> C:\Users\用户名\Desktop\minio</span><br><span class="line">setx MINIO_ROOT_USER muxue</span><br><span class="line">setx MINIO_ROOT_PASSWORD <span class="number">12345678</span></span><br><span class="line">.\minio.exe server .\data <span class="literal">--console-address</span> <span class="string">&quot;:9001&quot;</span></span><br></pre></td></tr></table></figure><p>这一次命令执行就没有问题了，我们成功设置了用户名和密码。在minio文件夹里面也出现了data子文件夹。</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/08/0c86ef2a4c60dc3f1365dfac92115b5a.png" alt="image.png"></p><p>这里显示了两个URL路径：</p><ul><li>一个是9000端口（API端口，思源S3同步需要使用这个端口）。</li><li>另外一个是9001端口（WEB管理页面端口，登录和创建Bucket需要使用这个端口）。</li></ul><p>浏览器打开9001端口，进入minio的web界面，登录。</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/08/ca9be37bd81813610bf65628150ae83d.png" alt="image.png"></p><p>进入主页面了之后，分别在Bucket目录下创建一个存储桶，在Access Keys栏目下创建一个用户密钥。这部分操作和<a href="https://blog.musnow.top/posts/1950951389">【docker】部署minio对象存储并用rclone同步</a>里面提到过的完全一致。</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/08/5c0f6c82ff229d19e38a78eb66c2adf7.png" alt="image.png"></p><p>点击Buckets里面的Create Bucket，填写一个名字，下面的三个选项都不需要选，对于思源同步来说这三个选项没有作用。然后点击右下角的Create Bucket按钮创建这个桶。</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/08/52ec41db696e40a60d3c7f2ce2d6d043.png" alt="image.png"></p><p>Access Keys也是如此，创建一个，填写一下name即可。这里的Expriy是过期时间，不填写就是永不过期。点击Create创建，将AK和SK记录下来。</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/08/6d256c90488838abd9b1556b3db0028d.png" alt="image.png"></p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/08/3e82f75ddcc6107f0d6b2b2633494521.png" alt="image.png"></p><p>现在我们就创建好了思源同步需要的所有东西了，可以去思源客户端里面填写了。</p><h2 id="3-思源PC客户端填写密钥"><a href="#3-思源PC客户端填写密钥" class="headerlink" title="3. 思源PC客户端填写密钥"></a>3. 思源PC客户端填写密钥</h2><p>填写方式如下图所示：</p><ul><li>Endpoint填minio的API9000端口号的地址；</li><li>AK和SK填刚刚粘贴的；</li><li>Bucket填存储桶的名字；</li><li>Region默认是<code>us-east-1</code>；</li><li>Addressing改成<code>Path-style</code>；</li><li>TLS Verfiy改成<code>Skip</code>跳过，因为我们没有配置证书；</li></ul><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/08/ccb1830f7d596f696a1137d2c3bc1219.png" alt="image.png"></p><p>到这里就配置成功了，点击思源的云按钮，上传一次数据看看。没有问题，上传成功了。</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/08/6306c989631c00443d7bd69c983c68c2.png" alt="image.png"></p><p>在minio控制台的bucket一栏也能看到最新的数据。</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/08/420b15cf65dea96262c5c7cfa455f9cf.png" alt="image.png"></p><p>在桌面上的minio文件夹data目录中也有对应文件。</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/08/a05a5ca74e517a422772e406e30edde8.png" alt="image.png"></p><p>到这里，我们的配置就成功了！</p><h2 id="4-第二台设备配置思源同步"><a href="#4-第二台设备配置思源同步" class="headerlink" title="4. 第二台设备配置思源同步"></a>4. 第二台设备配置思源同步</h2><p>第二台设备中只需要能访问minio的控制台，那他就可以访问minio的API端口。</p><p>用另外一台设备（宿主机）打开局域网IP地址的时候，会发现是502，这代表我们的请求被windows的防火墙拦截了。可以参考本站的<a href="https://blog.musnow.top/posts/2580738879">【win】windows开启特定端口防火墙</a>教程开启防火墙。配置的时候，入站、出站规则都须同时配置，协议选择tcp，<strong>可以只允许9000API端口</strong>，也可以把9000和9001都允许了。</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/08/7c04d70c46aba130a2b5150b9ce8952b.png" alt="image.png"></p><p>不过，我发现我的宿主机还是没有办法访问虚拟机，就连ping都是不通的。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">正在 Ping 192.168.154.131 具有 32 字节的数据:</span><br><span class="line">请求超时。</span><br><span class="line"></span><br><span class="line">192.168.154.131 的 Ping 统计信息:</span><br><span class="line">    数据包: 已发送 = 1，已接收 = 0，丢失 = 1 (100% 丢失)，</span><br></pre></td></tr></table></figure><p>发现在虚拟机防火墙的入站规则中，ICMP（ping需要这个）默认是被禁用的。右键它们将其设置为启用。</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/08/d445a8397db0287d20700e03d79bd6ef.png" alt="image.png"></p><p>现在就可以被ping通了</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">正在 Ping 192.168.154.131 具有 32 字节的数据:</span><br><span class="line">来自 192.168.154.131 的回复: 字节=32 时间&lt;1ms TTL=128</span><br><span class="line">来自 192.168.154.131 的回复: 字节=32 时间&lt;1ms TTL=128</span><br><span class="line">来自 192.168.154.131 的回复: 字节=32 时间&lt;1ms TTL=128</span><br><span class="line">来自 192.168.154.131 的回复: 字节=32 时间&lt;1ms TTL=128</span><br><span class="line"></span><br><span class="line">192.168.154.131 的 Ping 统计信息:</span><br><span class="line">    数据包: 已发送 = 4，已接收 = 4，丢失 = 0 (0% 丢失)，</span><br><span class="line">往返行程的估计时间(以毫秒为单位):</span><br><span class="line">    最短 = 0ms，最长 = 0ms，平均 = 0ms</span><br></pre></td></tr></table></figure><p>不过，我还是没有办法访问minio的web页面。原因未知，不是防火墙问题。在宿主机上使用curl命令会得到如下输出，这是minio服务端发回的响应，这代表我们的宿主机已经可以访问到虚拟机的minio了，但是因为其他的原因导致控制台加载不出来。</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">PS</span>&gt; <span class="built_in">curl</span> http://<span class="number">192.168</span>.<span class="number">154.131</span>:<span class="number">9001</span>/</span><br><span class="line">&lt;!doctype html&gt;&lt;html lang=<span class="string">&quot;en&quot;</span>&gt;&lt;head&gt;&lt;meta charset=<span class="string">&quot;utf-8&quot;</span>/&gt;&lt;base href=<span class="string">&quot;/&quot;</span>/&gt;&lt;meta content=<span class="string">&quot;width=device-width,initial-scale=1&quot;</span> name=<span class="string">&quot;viewport&quot;</span>/&gt;&lt;meta content=<span class="string">&quot;#081C42&quot;</span> media=<span class="string">&quot;(prefers-color-scheme: light)&quot;</span> name=<span class="string">&quot;theme-color&quot;</span>/&gt;&lt;meta content=<span class="string">&quot;#081C42&quot;</span> media=<span class="string">&quot;(prefers-color-scheme: dark)&quot;</span> name=<span class="string">&quot;theme-color&quot;</span>/&gt;&lt;meta content=<span class="string">&quot;MinIO Console&quot;</span> name=<span class="string">&quot;description&quot;</span>/&gt;&lt;meta name=<span class="string">&quot;minio-license&quot;</span> content=<span class="string">&quot;agpl&quot;</span> /&gt;&lt;link href=<span class="string">&quot;./styles/root-styles.css&quot;</span> rel=<span class="string">&quot;stylesheet&quot;</span>/&gt;&lt;link href=<span class="string">&quot;./apple-icon-180x180.png&quot;</span> rel=<span class="string">&quot;apple-touch-icon&quot;</span> sizes=<span class="string">&quot;180x180&quot;</span>/&gt;&lt;link href=<span class="string">&quot;./favicon-32x32.png&quot;</span> rel=<span class="string">&quot;icon&quot;</span> sizes=<span class="string">&quot;32x32&quot;</span> <span class="built_in">type</span>=<span class="string">&quot;image/png&quot;</span>/&gt;&lt;link href=<span class="string">&quot;./favicon-96x96.png&quot;</span> rel=<span class="string">&quot;icon&quot;</span> sizes=<span class="string">&quot;96x96&quot;</span> <span class="built_in">type</span>=<span class="string">&quot;image/png&quot;</span>/&gt;&lt;link href=<span class="string">&quot;./favicon-16x16.png&quot;</span> rel=<span class="string">&quot;icon&quot;</span> sizes=<span class="string">&quot;16x16&quot;</span> <span class="built_in">type</span>=<span class="string">&quot;image/png&quot;</span>/&gt;&lt;link href=<span class="string">&quot;./manifest.json&quot;</span> rel=<span class="string">&quot;manifest&quot;</span>/&gt;&lt;link color=<span class="string">&quot;#3a4e54&quot;</span> href=<span class="string">&quot;./safari-pinned-tab.svg&quot;</span> rel=<span class="string">&quot;mask-icon&quot;</span>/&gt;&lt;title&gt;MinIO Console&lt;/title&gt;&lt;script defer=<span class="string">&quot;defer&quot;</span> src=<span class="string">&quot;./static/js/main.41754270.js&quot;</span>&gt;&lt;/script&gt;&lt;link href=<span class="string">&quot;./static/css/main.e60e4760.css&quot;</span> rel=<span class="string">&quot;stylesheet&quot;</span>&gt;&lt;/head&gt;&lt;body&gt;&lt;noscript&gt;You need to enable JavaScript to run this app.&lt;/noscript&gt;&lt;div id=<span class="string">&quot;root&quot;</span>&gt;&lt;div id=<span class="string">&quot;preload&quot;</span>&gt;&lt;img src=<span class="string">&quot;./images/background.svg&quot;</span>/&gt; &lt;img src=<span class="string">&quot;./images/background-wave-orig2.svg&quot;</span>/&gt;&lt;/div&gt;&lt;div id=<span class="string">&quot;loader-block&quot;</span>&gt;&lt;img src=<span class="string">&quot;./Loader.svg&quot;</span>/&gt;&lt;/div&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt;</span><br></pre></td></tr></table></figure><p>不过这不是问题，使用和虚拟机里面一样的S3配置，已经可以成功下载资料啦！右上角的工作空间名字和虚拟机内不一样，足以证明在另外一台电脑上配置成功了。</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/08/12d39a0b1fb135724fb21f97289a0615.png" alt="image.png"></p><h2 id="5-模拟手机app同步"><a href="#5-模拟手机app同步" class="headerlink" title="5. 模拟手机app同步"></a>5. 模拟手机app同步</h2><p>手机app我用模拟器装一个，也能实现同步！</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/08/33b80d82b7330c695dd67957286d65bf.png" alt="image.png"></p><h2 id="6-minio开机自启"><a href="#6-minio开机自启" class="headerlink" title="6. minio开机自启"></a>6. minio开机自启</h2><p>现在就剩下最后一个问题了，即把minio配置为开机自启，避免每次都得手动启动服务器程序。首先将如下内容写入一个<code>minio_server.bat</code>里面。</p><figure class="highlight bat"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">setx MINIO_ROOT_USER muxue</span><br><span class="line">setx MINIO_ROOT_PASSWORD <span class="number">12345678</span></span><br><span class="line"><span class="function">C:\<span class="title">Users</span>\用户名\<span class="title">Desktop</span>\<span class="title">minio</span>\<span class="title">minio.exe</span> <span class="title">server</span> <span class="title">C</span>:\<span class="title">Users</span>\用户名\<span class="title">Desktop</span>\<span class="title">minio</span>\<span class="title">data</span> --<span class="title">console</span>-<span class="title">address</span> &quot;:9001&quot;</span></span><br></pre></td></tr></table></figure><p>然后创建一个<code>.vbs</code>文件，写入如下内容，这样可以在启动bat的时候隐藏控制台。</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Set</span> WshShell = CreateObject(<span class="string">&quot;WScript.Shell&quot;</span>)</span><br><span class="line">WshShell.Run <span class="string">&quot;C:\Users\用户名\Desktop\minio\minio_server.bat&quot;</span>, <span class="number">0</span>, False</span><br></pre></td></tr></table></figure><p>将这个<code>.vbs</code>文件放入<code>C:\ProgramData\Microsoft\Windows\Start Menu\Programs\StartUp</code>里面，这个文件夹内的文件都会被开机自启。</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/08/5c1a1810eaf7cc10d42c8b363e90a2f5.png" alt="image.png"></p><p>在任务管理器的启动里面，也能看到这个新增的vbs文件</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/08/49126c47b97b44478d3f6614091e4467.png" alt="image.png"></p><p>重启虚拟机，看看是否能自动启动minio服务端。</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/08/59bd3bf411f8083dde1ddd46c1b312c6.png" alt="image.png"></p><p>没有问题，自动启动成功。而且账户和密码都是正确的，数据也正常。</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/08/32e52bf8c348f8a947b39f678537e464.png" alt="image.png"></p><h2 id="7-搞定"><a href="#7-搞定" class="headerlink" title="7. 搞定"></a>7. 搞定</h2><p>有啥问题，欢迎评论区留言交流！</p>]]></content>
    
    
    <summary type="html">windows部署minio，实现内网S3同步思源。</summary>
    
    
    
    <category term="编程学习" scheme="https://blog.musnow.top/categories/%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="Docker真好玩" scheme="https://blog.musnow.top/categories/%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0/Docker%E7%9C%9F%E5%A5%BD%E7%8E%A9/"/>
    
    
    <category term="Docker" scheme="https://blog.musnow.top/tags/Docker/"/>
    
    <category term="思源笔记" scheme="https://blog.musnow.top/tags/%E6%80%9D%E6%BA%90%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>【C++】单元测试覆盖率工具lcov的使用</title>
    <link href="https://blog.musnow.top/posts/2798538265/"/>
    <id>https://blog.musnow.top/posts/2798538265/</id>
    <published>2024-08-22T22:40:38.000Z</published>
    <updated>2024-09-01T04:42:15.000Z</updated>
    
    <content type="html"><![CDATA[<p>本文讲述了如何在C++代码中使用单元测试覆盖率工具lcov，以及gcov命令的使用。版本是<code>lcov 2.0</code>和<code>gcov 11.4.0</code>。</p><blockquote><p>写在前面：lcov是我在实习期间初次接触到的工具，当时在配置的时候就遇到了大量中文互联网没有任何记录的问题。<strong>绝大部分博客对lcov工具的介绍仅停留在安装，并没有对它的使用和报告分析做出更进一步的详解</strong>，这也是慕雪撰写本文的原因。希望这篇文章能对需要使用lcov工具却又苦于没有引导教程的老哥提供一丝丝帮助。</p></blockquote><h2 id="1-安装"><a href="#1-安装" class="headerlink" title="1. 安装"></a>1. 安装</h2><p>安装lcov的方式比较简单，去github上下载官方的安装包就可以了。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># ubuntu安装依赖项</span></span><br><span class="line">sudo apt-get install -y wget perl \</span><br><span class="line">libcapture-tiny-perl libdatetime-perl \</span><br><span class="line">libdatetime-format-dateparse-perl</span><br><span class="line"><span class="comment"># 下载</span></span><br><span class="line">wget https://github.com/linux-test-project/lcov/releases/download/v2.0/lcov-2.0.tar.gz</span><br><span class="line"><span class="comment"># 解压</span></span><br><span class="line">tar -zxvf lcov-2.0.tar.gz</span><br><span class="line"><span class="built_in">cd</span> lcov-2.0</span><br><span class="line"><span class="comment"># 安装</span></span><br><span class="line">sudo make install</span><br></pre></td></tr></table></figure><p>安装完毕后查看版本号，成功出现版本号则代表安装成功。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">❯ lcov --version</span><br><span class="line">lcov: LCOV version 2.0-1</span><br></pre></td></tr></table></figure><p>更详细的lcov安装教程详见本站<a href="https://blog.musnow.top/posts/1274282021">【Linux】lcov2.0安装和perl修改镜像源</a>一文。另外，本文演示所用的单元测试框架<a href="https://blog.musnow.top/posts/852447913">Gtest</a>也建议安装一下。需要说明的是，lcov的报告并不依赖于Gtest或任何测试框架，只要函数被调用、代码被运行了，它就可以生成覆盖率报告。</p><h2 id="2-基本命令"><a href="#2-基本命令" class="headerlink" title="2. 基本命令"></a>2. 基本命令</h2><h3 id="2-1-手工执行"><a href="#2-1-手工执行" class="headerlink" title="2.1. 手工执行"></a>2.1. 手工执行</h3><p>lcov的基本使用方式如下：</p><p>首先我们需要用g++命令编译gtest写出来的单元测试代码，使用<code>-lgtest -lgtest_main -pthread</code>链接gtest库和pthread库。选项<code>-ftest-coverage</code>可以让g++编译器在代码中插入额外的指令，来确认某部分的代码是否执行了，一般要和<code>-fprofile-arcs</code>连用才能产生完整的覆盖率报告。</p><p>程序运行后会产生<code>.gcda</code>、<code>.gcov</code>和<code>.gcno</code>文件，记录了覆盖率信息，lcov依赖于这些文件产生最终的html覆盖率报告。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">g++ -std=c++17 test.cpp -o <span class="built_in">test</span> \</span><br><span class="line">-lgtest -lgtest_main -pthread \</span><br><span class="line">-fprofile-arcs -ftest-coverage -fprofile-update=atomic</span><br></pre></td></tr></table></figure><p><code>g++</code>命令最后的<code>-fprofile-update=atomic</code>是lcov 2.0中需要新增的一个编译选项，否则运行lcov的时候会有告警（具体记不清了，最初的记录里面忘记写这一块的内容了）。</p><p>使用如上方式编译了单元测试的代码了之后，就可以执行lcov命令来生成报告了</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">lcov --capture \</span><br><span class="line"> --rc branch_coverage=1 \</span><br><span class="line"> --directory . \</span><br><span class="line"> --output-file coverage.info \</span><br><span class="line"> --ignore-errors mismatch</span><br></pre></td></tr></table></figure><p>这个命令最终会生成一个<code>coverage.info</code>信息文件。其中<code>--rc branch_coverage=1</code>是用于开启分支检测的，不指定这个选项，输出的文件中将不包含<strong>分支覆盖率</strong>信息，只会有行覆盖率信息。选项<code>--ignore-errors mismatch</code>是因为lcov 2.0版本出现了一些问题，经常会找不到某些函数的符号表（不知道啥情况，lcov 1.6没有此告警），会有mismatch错误，需要将其忽略。</p><p>生成了<code>coverage.info</code>文件之后，再使用genhtml命令将其转化为最终的html报告，输出到<code>coverage_report</code>目录中。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">genhtml coverage.info \</span><br><span class="line">--rc branch_coverage=1 \</span><br><span class="line">--output-directory coverage_report</span><br></pre></td></tr></table></figure><p>一切顺利的话，执行了这些命令，你就可以在当前目录下的<code>coverage_report</code>子目录中找到lcov的html报告了。</p><h3 id="2-2-makefile"><a href="#2-2-makefile" class="headerlink" title="2.2. makefile"></a>2.2. makefile</h3><p>我们可以把上述命令写入一个makefile中，这样可以方便我们执行命令。更新了测试源码之后，使用<code>make locv</code>就可以生成最新的覆盖率报告。</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">test:test.cpp</span></span><br><span class="line">g++ -std=c++17 test.cpp -o test -lgtest -lgtest_main -pthread -fprofile-arcs -ftest-coverage -fprofile-update=atomic</span><br><span class="line"></span><br><span class="line"><span class="section">lcov:test.cpp</span></span><br><span class="line">g++ -std=c++17 test.cpp -o test -lgtest -lgtest_main -pthread -fprofile-arcs -ftest-coverage -fprofile-update=atomic &amp;&amp; \</span><br><span class="line">./test &amp;&amp; \</span><br><span class="line">gcov -b -c -o . test.cpp &amp;&amp; \</span><br><span class="line">lcov --capture \</span><br><span class="line"> --rc branch_coverage=1 \</span><br><span class="line"> --directory . \</span><br><span class="line"> --output-file coverage_all.info \</span><br><span class="line"> --ignore-errors mismatch &amp;&amp; \</span><br><span class="line">genhtml coverage.info \</span><br><span class="line">--rc branch_coverage=1 \</span><br><span class="line">--ignore-errors mismatch \</span><br><span class="line">--output-directory coverage_report &amp;&amp; \</span><br><span class="line">rm *.info</span><br><span class="line"></span><br><span class="line"><span class="meta"><span class="keyword">.PHONY</span>:cl</span></span><br><span class="line"><span class="section">cl:</span></span><br><span class="line">sudo rm -rf test *.gcno *.gcda *.gcov out</span><br></pre></td></tr></table></figure><h2 id="3-Demo演示"><a href="#3-Demo演示" class="headerlink" title="3. Demo演示"></a>3. Demo演示</h2><h3 id="3-1-基本demo"><a href="#3-1-基本demo" class="headerlink" title="3.1. 基本demo"></a>3.1. 基本demo</h3><p>下面是一个最简单的C++代码，以及对应的测试处理，首先在<code>main.hpp</code>里面定义了一个最基础的相减函数</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 相减函数</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Sub</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (a &gt; b)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> a - b;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> b - a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>随后，在test.cpp中引用这个头文件并调用Sub函数</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;gtest/gtest.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;main.hpp&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="built_in">TEST</span>(SubTest, SubTest1)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">EXPECT_EQ</span>(<span class="built_in">Sub</span>(<span class="number">3</span>, <span class="number">2</span>), <span class="number">1</span>);  <span class="comment">// 期望 result 等于 1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ::testing::<span class="built_in">InitGoogleTest</span>(&amp;argc, argv);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">RUN_ALL_TESTS</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用上文提到的命令，编译和创建lcov报告。在lcov命令的最后输出中，会包含如下覆盖率信息</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Overall coverage rate:</span><br><span class="line">  lines......: 50.3% (83 of 165 lines)</span><br><span class="line">  functions......: 46.3% (44 of 95 functions)</span><br><span class="line">  branches......: 42.9% (24 of 56 branches)</span><br></pre></td></tr></table></figure><p>因为我用的是WSL2，可以方便的直接打开报告生成目录，查看<code>index.html</code>文件。</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/08/afa263d7fdbe9504b2c3940389dfc9e6.png" alt="image.png"></p><p>可以看到，报告中列出了所有涉及到的文件，以及这些文件的行覆盖率，分支覆盖率，执行次数。</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/08/3e84c04f97c1e99737fb034b8b75621e.png" alt="image.png"></p><p>但是！这里面有大量C++库函数以及gtest库的代码，我们自己的代码反而被掩盖过去了，这肯定不是我们想要的结果。毕竟不是自己写的代码都不需要测试覆盖率。所以我们需要做点操作，屏蔽掉所有库函数的报告。</p><p>将上文的lcov命令的最终输出文件改成<code>coverage_all.info</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">lcov --capture \</span><br><span class="line"> --rc branch_coverage=1 \</span><br><span class="line"> --directory . \</span><br><span class="line"> --output-file coverage_all.info \</span><br><span class="line"> --ignore-errors mismatch</span><br></pre></td></tr></table></figure><p>然后在genhtml命令<strong>之前</strong>，执行如下命令。这个命令会处理原本生成的全量数据，把里面我们不想要的东西全都删除掉，再生成一个<code>coverage.info</code>文件。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">lcov --remove coverage_all.info \</span><br><span class="line"><span class="string">&#x27;*/usr/include/*&#x27;</span> <span class="string">&#x27;*/usr/lib/*&#x27;</span> <span class="string">&#x27;*/usr/lib64/*&#x27;</span> \</span><br><span class="line"><span class="string">&#x27;*/usr/local/include/*&#x27;</span> <span class="string">&#x27;*/usr/local/lib/*&#x27;</span> <span class="string">&#x27;*/usr/local/lib64/*&#x27;</span> \</span><br><span class="line">--rc branch_coverage=1 \</span><br><span class="line">--output-file coverage.info \</span><br><span class="line">--ignore-errors unused \</span><br><span class="line">--ignore-errors mismatch </span><br></pre></td></tr></table></figure><p>随后再执行genhtml命令，这一次生成的报告文件就只有我们自己的代码了。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">genhtml coverage.info \</span><br><span class="line">--rc branch_coverage=1 \</span><br><span class="line">--output-directory coverage_report</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/08/73d2eafff451a7fd33b813b91ee6c1db.png" alt="image.png"></p><p>进入报告中看，其实这里还是有一个需要排除的项目的，即<code>test.cpp</code>是单元测试的文件，我们也不需要关注单元测试这个文件本身的覆盖率正常不，当前我们只需要关注<code>main.hpp</code>这个功能源码文件的覆盖率。</p><blockquote><p>可以将<code>test.cpp</code>也写入上文的<code>--remove</code>选项之后，这样它也会被过滤掉。实际项目中，直接过滤单元测试代码文件的目录即可。</p></blockquote><p>另外，使用这个命令，lcov会在输出中报告没有被匹配上的地址，可以用<code>--ignore-errors unused</code>来屏蔽这个告警。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">lcov: WARNING: (&#x27;unused&#x27;) &#x27;exclude&#x27; pattern &#x27;*/usr/lib/*&#x27; is unused.</span><br><span class="line">lcov: WARNING: (&#x27;unused&#x27;) &#x27;exclude&#x27; pattern &#x27;*/usr/lib64/*&#x27; is unused.</span><br><span class="line">        (use &quot;lcov --ignore-errors unused,unused ...&quot; to suppress this warning)</span><br><span class="line">lcov: WARNING: (&#x27;unused&#x27;) &#x27;exclude&#x27; pattern &#x27;*/usr/local/lib/*&#x27; is unused.</span><br><span class="line">        (use &quot;lcov --ignore-errors unused,unused ...&quot; to suppress this warning)</span><br><span class="line">lcov: WARNING: (&#x27;unused&#x27;) &#x27;exclude&#x27; pattern &#x27;*/usr/local/lib64/*&#x27; is unused.</span><br><span class="line">        (use &quot;lcov --ignore-errors unused,unused ...&quot; to suppress this warning)</span><br></pre></td></tr></table></figure><h3 id="3-2-报告基本分析"><a href="#3-2-报告基本分析" class="headerlink" title="3.2. 报告基本分析"></a>3.2. 报告基本分析</h3><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/08/342542383b05ef101160af2ec67d56ec.png" alt="image.png"></p><p>点开main.hpp文件，可以看到如下报告。其中右上角是当前文件的覆盖率信息，然后会展示文件的源码：</p><ul><li>源码每一行之前的数字是这一行被运行了几次；</li><li>底色为<strong>橙色</strong>标注的，就是没有被覆盖的行；</li><li>蓝色标注的，则是被覆盖了的行；</li></ul><p>在每一个if语句的分支点，也会产生一个<code>分支覆盖率</code>报告，这里显示的<code>[+,-]</code>代表if条件为true的分支被命中了，为false的分支没有命中。在测试代码中我使用的是<code>Sub(3, 2)</code>来调用该函数，参数a是大于b的（命中true分支），也和这里的分支覆盖报告相符。</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/08/eb3f39f58819afece3d6e975ae284ca6.png" alt="image.png"></p><p>这样我们就可以知道，当前需要怎么补充测试用例了。我们需要补充一个b比a大或者相等的测试用例，追加如下测试调用。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;gtest/gtest.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;main.hpp&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="built_in">TEST</span>(SubTest, SubTest1)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">EXPECT_EQ</span>(<span class="built_in">Sub</span>(<span class="number">3</span>, <span class="number">2</span>), <span class="number">1</span>);  <span class="comment">// 期望 result 等于 1</span></span><br><span class="line">    <span class="built_in">EXPECT_EQ</span>(<span class="built_in">Sub</span>(<span class="number">2</span>, <span class="number">4</span>), <span class="number">2</span>);  <span class="comment">// 期望 result 等于 2</span></span><br><span class="line">    <span class="built_in">EXPECT_EQ</span>(<span class="built_in">Sub</span>(<span class="number">3</span>, <span class="number">3</span>), <span class="number">0</span>);  <span class="comment">// 期望 result 等于 0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ::testing::<span class="built_in">InitGoogleTest</span>(&amp;argc, argv);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">RUN_ALL_TESTS</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再次编译执行，重新查看报告。此时可以看到，我们的main.hpp已经实现了100%的覆盖。</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/08/cd1515895dec2f7fe7463891169db879.png" alt="image.png"></p><p>删除其他测试，留一个b比a大的测试用例。此时可以看到，分支覆盖显示为<code>[-,+]</code>，代表我们当前分支的false条件被命中了，但是true条件没有。</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/08/2d3dc60e740e1bedbca1a621ed28cd7c.png" alt="image.png"></p><p>简单总结，单个分支覆盖率中<code>[]</code>的逗号左侧是true，右侧是false；<code>+</code>代表覆盖，<code>-</code>代表没有覆盖，<code>#</code>代表这个分支没有被执行。</p><h3 id="3-3-多条件判断"><a href="#3-3-多条件判断" class="headerlink" title="3.3. 多条件判断"></a>3.3. 多条件判断</h3><p>上面的if语句中我们只写了一个判断条件，实际场景中判断条件不止一个的情况还是经常出现的，给Sub函数新增一个参数，再来进行测试。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdbool&gt;</span></span></span><br><span class="line"><span class="comment">// 相减函数，默认是A-B，第三个参数为是否要返回绝对值</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Sub</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b, <span class="type">bool</span> isAbs)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (b &lt; a &amp;&amp; isAbs)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> b - a;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> a - b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试用例如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;gtest/gtest.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;main.hpp&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="built_in">TEST</span>(SubTest, SubTest1)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 传入false代表我们想a-b，不需要绝对值</span></span><br><span class="line">    <span class="built_in">EXPECT_EQ</span>(<span class="built_in">Sub</span>(<span class="number">2</span>, <span class="number">4</span>, <span class="literal">false</span>), <span class="number">-2</span>);  <span class="comment">// 期望 result 等于 -2</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ::testing::<span class="built_in">InitGoogleTest</span>(&amp;argc, argv);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">RUN_ALL_TESTS</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里可以看到，在if语句左侧的分支覆盖率条件的<code>[]</code>里面多了一对加减，这里多的就是isAbs这个判断条件，分支覆盖率中的每一个判断条件都有一个true&#x2F;false分支，两两一对，从左到右的顺序和我们的判断条件中的条件顺序是一致的。</p><p>在上面的测试用例中，我们传入了b大于a的值，同时isAbs是false，命中了<code>b &gt; a</code>为true的分支，和isAbs为false的分支。</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/08/4fe675914869911cb1ce874da9d8b983.png" alt="image.png"></p><p>新增一个测试用例，这一次命中的是isAbs为true的分支。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">EXPECT_EQ</span>(<span class="built_in">Sub</span>(<span class="number">2</span>, <span class="number">4</span>, <span class="literal">true</span>), <span class="number">2</span>);</span><br></pre></td></tr></table></figure><p>报告中，isAbs为true的分支也变成了<code>+</code>代表已命中，符合预期。</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/08/28e2285bf12013163ecd1b8572daf905.png" alt="image.png"></p><p>再添加一个a比b大的测试用例，即可将该函数的所有分支覆盖完毕。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EXPECT_EQ(Sub(6, 4, true), 2);</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/08/7cde5b3bdab0cb404d46a32175e53844.png" alt="image.png"></p><h2 id="4-引入gcov命令"><a href="#4-引入gcov命令" class="headerlink" title="4. 引入gcov命令"></a>4. 引入gcov命令</h2><h3 id="4-1-基本使用"><a href="#4-1-基本使用" class="headerlink" title="4.1. 基本使用"></a>4.1. 基本使用</h3><p>接下来给大家引入gcov命令的使用，gcov命令可以生成更加详细的关于某个分支为什么没有被覆盖的说明。比如未覆盖的异常分支在生成的<code>源文件.gcov</code>文件中就会显示出来。</p><p>gcov命令和gcc&#x2F;g++是同源的，只要你的系统上安装了gcc，那就会有gcov命令。二者的版本号输出都是一致的。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">❯ gcov --version          </span><br><span class="line">gcov (Ubuntu 11.4.0-1ubuntu1~22.04) 11.4.0</span><br><span class="line">Copyright (C) 2021 Free Software Foundation, Inc.</span><br><span class="line">This is free software; see the source for copying conditions.  There is NO</span><br><span class="line">warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.    </span><br><span class="line">❯ gcc --version </span><br><span class="line">gcc (Ubuntu 11.4.0-1ubuntu1~22.04) 11.4.0</span><br><span class="line">Copyright (C) 2021 Free Software Foundation, Inc.</span><br><span class="line">This is free software; see the source for copying conditions.  There is NO</span><br><span class="line">warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.</span><br></pre></td></tr></table></figure><p>执行过lcov命令后，在构建目录下会产生很多的<code>.gcov</code>文件，和我们自己的代码的<code>.gcda</code>文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">❯ <span class="built_in">ls</span></span><br><span class="line">alloc_traits.h.gcov    gtest-assertion-result.h.gcov  main.hpp              stl_iterator_base_funcs.h.gcov  test.gcda</span><br><span class="line">basic_string.h.gcov    gtest.h.gcov                   main.hpp.gcov         stl_iterator_base_types.h.gcov  test.gcno</span><br><span class="line">basic_string.tcc.gcov  gtest-internal.h.gcov          makefile              <span class="built_in">test</span>                            tuple.gcov</span><br><span class="line">char_traits.h.gcov     gtest-port.h.gcov              move.h.gcov           test.cpp                        type_traits.h.gcov</span><br><span class="line">coverage_report        gtest-printers.h.gcov          new_allocator.h.gcov  test.cpp.gcov                   unique_ptr.h.gcov</span><br></pre></td></tr></table></figure><p>我们可以使用gcov命令，把这些文件文件转换成可读报告。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcov -b -c -o .gcda文件所在路径 cpp源文件路径</span><br></pre></td></tr></table></figure><p>比如这里我们要处理的是<code>test.gcda</code>，命令如下。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcov -b -c -o . test.cpp</span><br></pre></td></tr></table></figure><p>这个命令会生成一个<code>源文件名.gcov</code>文件，文件中就会有详细的文字说明了。比如<code>main.hpp.gcov</code>文件中的描述如下，有每一个分支被命中的次数，后面有个括号是这个分支的说明。</p><p>文件中第一列的<code>-:</code>代表这一行不统计命中次数，第一列<code>数字:</code>代表这一行被执行的次数（注意要和第二列的代码行号区分开）。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">        -:    0:Source:main.hpp</span><br><span class="line">        -:    0:Graph:./test.gcno</span><br><span class="line">        -:    0:Data:./test.gcda</span><br><span class="line">        -:    0:Runs:1</span><br><span class="line">        -:    1:#include &lt;cstdbool&gt;</span><br><span class="line">        -:    2:// 相减函数，默认是A-B，第三个参数为是否要返回绝对值</span><br><span class="line">function _Z3Subiib called 3 returned 100% blocks executed 100%</span><br><span class="line">        3:    3:int Sub(int a, int b, bool isAbs)</span><br><span class="line">        -:    4:&#123;</span><br><span class="line">        3:    5:    if (b &gt; a &amp;&amp; isAbs)</span><br><span class="line">branch  0 taken 2 (fallthrough)</span><br><span class="line">branch  1 taken 1</span><br><span class="line">branch  2 taken 1 (fallthrough)</span><br><span class="line">branch  3 taken 1</span><br><span class="line">        -:    6:    &#123;</span><br><span class="line">        1:    7:        return b - a;</span><br><span class="line">        -:    8:    &#125;</span><br><span class="line">        2:    9:    return a - b;</span><br><span class="line">        -:   10:&#125;</span><br></pre></td></tr></table></figure><p>文件中的<code>(fallthrough)</code>代表当前if分支被跳过。比如下面的代码中，fallthrough的意思就是当<strong>a不等于b</strong>的时候，分支A会被跳过，走到分支B中。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (a == b)&#123;</span><br><span class="line"><span class="comment">// A</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// B</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上面的例子中，当b小于等于a或者isAbs为假的时候，<code>return b - a;</code>就会被跳过，落到<code>return a - b;</code>分支中。</p><p>这里将isAbs改成一个函数调用，函数本身参数不变</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdbool&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;exception&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isAbsFunc</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b, <span class="type">bool</span> isAbs)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 当a为100的时候抛出异常</span></span><br><span class="line">    <span class="keyword">if</span> (a == <span class="number">100</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">throw</span> std::<span class="built_in">invalid_argument</span>(<span class="string">&quot;a should not be 100.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> isAbs;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 相减函数，默认是A-B，第三个参数为是否要返回绝对值</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Sub</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b, <span class="type">bool</span> isAbs)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (b &gt; a &amp;&amp; <span class="built_in">isAbsFunc</span>(a, b, isAbs))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> b - a;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> a - b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时分支覆盖率报告如下。因为我们当前的a并不等于100，所以一直命中的都是<code>a == 100</code>为false的分支，符合预期。但是这里会有一个额外的分支未覆盖情况，即throw这一行也出现了一个分支，且<code>[]</code>里面的两个符号都是<code>#</code>，<strong>代表这一行没有被运行</strong>。</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/08/c518b73bd07a2cd0d7b9e66c6a8af84b.png" alt="image.png"></p><p>我们可以用gcov命令来看看throw这一行的分支覆盖情况。可以看到这里提示<code>never executed</code>，没有运行。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">        -:    0:Source:main.hpp</span><br><span class="line">        -:    0:Graph:./test.gcno</span><br><span class="line">        -:    0:Data:./test.gcda</span><br><span class="line">        -:    0:Runs:1</span><br><span class="line">        -:    1:#include &lt;cstdbool&gt;</span><br><span class="line">        -:    2:#include &lt;exception&gt;</span><br><span class="line">        -:    3:</span><br><span class="line">function _Z9isAbsFunciib called 2 returned 100% blocks executed 50%</span><br><span class="line">        2:    4:bool isAbsFunc(int a, int b, bool isAbs)</span><br><span class="line">        -:    5:&#123;</span><br><span class="line">        -:    6:    // 当a为100的时候抛出异常</span><br><span class="line">        2:    7:    if (a == 100)</span><br><span class="line">branch  0 taken 0 (fallthrough)</span><br><span class="line">branch  1 taken 2</span><br><span class="line">        -:    8:    &#123;</span><br><span class="line">    #####:    9:        throw std::invalid_argument(&quot;a should not be 100.&quot;);</span><br><span class="line">call    0 never executed</span><br><span class="line">call    1 never executed</span><br><span class="line">branch  2 never executed</span><br><span class="line">branch  3 never executed</span><br><span class="line">call    4 never executed</span><br><span class="line">call    5 never executed</span><br><span class="line">        -:   10:    &#125;</span><br><span class="line">        2:   11:    return isAbs;</span><br><span class="line">        -:   12:&#125;</span><br><span class="line">        -:   13:</span><br><span class="line">        -:   14:// 相减函数，默认是A-B，第三个参数为是否要返回绝对值</span><br><span class="line">function _Z3Subiib called 3 returned 100% blocks executed 100%</span><br><span class="line">        3:   15:int Sub(int a, int b, bool isAbs)</span><br><span class="line">        -:   16:&#123;</span><br><span class="line">        3:   17:    if (b &gt; a &amp;&amp; isAbsFunc(a, b, isAbs))</span><br><span class="line">branch  0 taken 2 (fallthrough)</span><br><span class="line">branch  1 taken 1</span><br><span class="line">call    2 returned 2</span><br><span class="line">branch  3 taken 1 (fallthrough)</span><br><span class="line">branch  4 taken 1</span><br><span class="line">branch  5 taken 1 (fallthrough)</span><br><span class="line">branch  6 taken 2</span><br><span class="line">        -:   18:    &#123;</span><br><span class="line">        1:   19:        return b - a;</span><br><span class="line">        -:   20:    &#125;</span><br><span class="line">        2:   21:    return a - b;</span><br><span class="line">        -:   22:&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>那我们加一个a等于100的测试用例呢？</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 期望抛出异常</span></span><br><span class="line"><span class="built_in">EXPECT_ANY_THROW</span>(<span class="built_in">Sub</span>(<span class="number">100</span>, <span class="number">400</span>, <span class="literal">true</span>));</span><br></pre></td></tr></table></figure><p>此时gcov文件会是如下模样，我们<code>a == 100</code>的两个分支都命中了，但是你会发现，它有一个<code>branch  3 taken 0 (throw)</code>为0次命中，没有被覆盖上。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">function _Z9isAbsFunciib called 3 returned 67% blocks executed 88%</span><br><span class="line">        3:    4:bool isAbsFunc(int a, int b, bool isAbs)</span><br><span class="line">        -:    5:&#123;</span><br><span class="line">        -:    6:    // 当a为100的时候抛出异常</span><br><span class="line">        3:    7:    if (a == 100)</span><br><span class="line">branch  0 taken 1 (fallthrough)</span><br><span class="line">branch  1 taken 2</span><br><span class="line">        -:    8:    &#123;</span><br><span class="line">        1:    9:        throw std::invalid_argument(&quot;a should not be 100.&quot;);</span><br><span class="line">call    0 returned 1</span><br><span class="line">call    1 returned 1</span><br><span class="line">branch  2 taken 1 (fallthrough)</span><br><span class="line">branch  3 taken 0 (throw)</span><br><span class="line">call    4 returned 0</span><br><span class="line">call    5 never executed</span><br><span class="line">        -:   10:    &#125;</span><br><span class="line">        2:   11:    return isAbs;</span><br><span class="line">        -:   12:&#125;</span><br></pre></td></tr></table></figure><p>在lcov报告中也是如此，会显示有一个没有覆盖的<code>(throw)</code>抛异常分支。</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/08/29453ec64b86aa692f958f1112c55dae.png" alt="image.png"></p><h3 id="4-2-lcov过滤std库函数造成的分支"><a href="#4-2-lcov过滤std库函数造成的分支" class="headerlink" title="4.2. lcov过滤std库函数造成的分支"></a>4.2. lcov过滤std库函数造成的分支</h3><p>这就涉及到lcov的一个不那么容易找到的设置了，当时百度了老久，最后还是去Github翻issue才得到的答案。下面贴出几个相关的issue</p><ul><li><a href="https://github.com/linux-test-project/lcov/issues/101">https://github.com/linux-test-project/lcov/issues/101</a>；</li><li><a href="https://github.com/linux-test-project/lcov/issues/108">https://github.com/linux-test-project/lcov/issues/108</a>；</li><li><a href="https://github.com/linux-test-project/lcov/issues/75">https://github.com/linux-test-project/lcov/issues/75</a>；</li></ul><p>简而言之，lcov支持过滤掉这类由<strong>std库</strong>造成的无法覆盖的异常分支。只需要在lcov命令和genhtml命令中加上<code>--filter branch</code>选项即可。添加了这个命令后，可以看到throw这一行的分支被过滤不显示了。</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/08/436d28f60749041f428ee212424f722c.png" alt="image.png"></p><p>即便我们没有命中<code>a == 100</code>的情况，throw这一行也不会出现<code>[##]</code>的未命中分支。</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/08/d3d968b2bd533aa5749867c5a4c6c142.png" alt="image.png"></p><p>再举个map的emplace的例子，代码如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">EmplaceMap</span><span class="params">(<span class="type">int</span> key, <span class="type">int</span> value)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">static</span> std::map&lt;<span class="type">int</span>, std::set&lt;<span class="type">int</span>&gt;&gt; mapValue;</span><br><span class="line">    mapValue[key].<span class="built_in">emplace</span>(value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试代码</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">TEST</span>(EmplaceMapTest,EmplaceMapTest1)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">EXPECT_NO_THROW</span>(<span class="built_in">EmplaceMap</span>(<span class="number">1</span>,<span class="number">2</span>));</span><br><span class="line">    <span class="built_in">EXPECT_NO_THROW</span>(<span class="built_in">EmplaceMap</span>(<span class="number">1</span>,<span class="number">3</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，如果不加上<code>--filter branch</code>过滤选项，在lcov报告中，即便这一行是完全不存在任何分支的，也会出现一个未覆盖的情况。</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/08/cc8f129e5571bceeff92a784dea4fcb0.png" alt="image.png"></p><p>生成的gcov文件如下，这里会有一个不知道什么由来的branch 4没有被覆盖到。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">function _Z10EmplaceMapii called 2 returned 100% blocks executed 100%</span><br><span class="line">        2:    6:void EmplaceMap(int key, int value)</span><br><span class="line">        -:    7:&#123;</span><br><span class="line">        2:    8:    static std::map&lt;int, std::set&lt;int&gt;&gt; mapValue;</span><br><span class="line">branch  0 taken 1 (fallthrough)</span><br><span class="line">branch  1 taken 1</span><br><span class="line">call    2 returned 1</span><br><span class="line">branch  3 taken 1 (fallthrough)</span><br><span class="line">branch  4 taken 0</span><br><span class="line">call    5 returned 1</span><br><span class="line">call    6 returned 1</span><br><span class="line">call    7 returned 1</span><br><span class="line">        2:    9:    mapValue[key].emplace(value);</span><br><span class="line">call    0 returned 2</span><br><span class="line">call    1 returned 2</span><br><span class="line">        2:   10:&#125;</span><br><span class="line">        -:   11:</span><br></pre></td></tr></table></figure><p>加上了<code>--filter branch</code>过滤选项之后，这一行则完全不会有分支覆盖率信息。这才是我们预期的输出，因为我们不应该关注不是我们自己写的代码（比如std库和第三方库）中的分支。</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/08/c924d7688fb335b82519ff717a0c69b0.png" alt="image.png"></p><p>另外，过滤选项默认只对常见的cpp头文件起效。对诸如<code>.inl</code>这种头文件是不起效果的。可以使用如下命令，修改默认的<code>c_file_extensions</code>后缀名配置，添加你需要的文件后缀。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">--rc c_file_extensions=c,cpp,hpp,h,inl</span><br></pre></td></tr></table></figure><p>关联issue：<a href="https://github.com/linux-test-project/lcov/issues/250">https://github.com/linux-test-project/lcov/issues/250</a>。</p><h2 id="5-一些lcov报告问题的记录"><a href="#5-一些lcov报告问题的记录" class="headerlink" title="5. 一些lcov报告问题的记录"></a>5. 一些lcov报告问题的记录</h2><p>经过上面的步骤，想必你已经知道怎么去使用lcov了。下面是我在使用lcov过程中遇到的一些报告的共性问题，记录于此，经供参考。</p><h3 id="5-1-lcov屏蔽语法"><a href="#5-1-lcov屏蔽语法" class="headerlink" title="5.1. lcov屏蔽语法"></a>5.1. lcov屏蔽语法</h3><p>lcov本身也支持通过在代码中添加注释的方式来屏蔽一些代码的覆盖率检测。屏蔽的语法分为单行代码和多行屏蔽。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// LCOV_EXCL_BR_START</span></span><br><span class="line">   多行代码</span><br><span class="line"><span class="comment">// LCOV_EXCL_BR_STOP</span></span><br><span class="line"></span><br><span class="line">单行代码 <span class="comment">// LCOV_EXCL_BR_LINE</span></span><br></pre></td></tr></table></figure><p>在实际代码中，<strong>可能会有一些linux库函数调用这类难以复现失败场景</strong>的函数调用，又没有办法被过滤掉的分支。这种情况就可以在注明原因以后，使用lcov的屏蔽注释将其屏蔽掉，让最终生成的报告里面没有这些难以覆盖的错误情况。</p><h3 id="5-2-assert假分支无法覆盖"><a href="#5-2-assert假分支无法覆盖" class="headerlink" title="5.2. assert假分支无法覆盖"></a>5.2. assert假分支无法覆盖</h3><p>如下图所示，lcov的assert始终只会覆盖假的分支，因为分支为真的时候就直接程序终止了。</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/08/132c099cc167184439efe27f27df9d26.png" alt="image.png"></p><p>Gtest中有一个<code>EXPECT_DEATH</code>可以用来测试assert为真的情况，但即便使用了这个宏，lcov和gcov依旧无法生成命中的报告。所以，推荐的做法是在编译<strong>单元测试代码</strong>的时候使用<code>-DNDEBUG</code>宏直接禁用所有assert，这样就不会有关于assert的分支覆盖率报告了。</p><h3 id="5-3-trylock分支覆盖"><a href="#5-3-trylock分支覆盖" class="headerlink" title="5.3. trylock分支覆盖"></a>5.3. trylock分支覆盖</h3><p>一般情况下，在我们的测试场景中不太好复现<code>try_lock()</code>函数调用失败的分支，这需要有一个多线程的场景，但多线程操作共享资源的运行顺序本身就是不可预知的，不太好在单元测试中构建出一个一定冲突的场景来。</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/08/c473277ea997e4fe20d5d2ef5acffe4e.png" alt="image.png"></p><p>这时候可以用一种黑魔法，在单元测试中，<strong>取出类的私有成员变量mutex</strong>，将其lock了之后，再去调用包含<code>try_lock()</code>调用和判断的函数。函数调用完毕后，再unlock解锁。</p><p>如下是这个黑魔法的源码和使用示例，注意只有g++使用<code>-std=c++17</code>之后才支持编译这个代码。在windows的vs2019下这个特性是编译不过的，即便设置了C++17也不行，可能是我的配置不对。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="comment">// C++17才支持，通过友元和元组，取出任意成员变量</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>, <span class="keyword">auto</span>... Member&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">StealMember</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">friend</span> <span class="keyword">auto</span> <span class="title">StealClass</span><span class="params">(T &amp;t)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> std::<span class="built_in">make_tuple</span>(Member...);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用示例：</span></span><br><span class="line"><span class="comment">// // 1.友元函数声明，TestClass是我们需要操作的目标类。</span></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">StealClass</span><span class="params">(TestClass &amp;t)</span></span>;</span><br><span class="line"><span class="comment">// // 2.在下面的模板中添加需要的私有函数或成员。</span></span><br><span class="line"><span class="keyword">template</span> <span class="keyword">class</span> <span class="title class_">StealMember</span>&lt;TestClass,</span><br><span class="line">                         &amp;TestClass::GetA, &amp;TestClass::_a, &amp;TestClass::_b&gt;;</span><br><span class="line"><span class="comment">// // 3.在需要的函数中使用如下方式取成员变量。</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">TestFunc</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="function">TestClass <span class="title">t1</span><span class="params">(<span class="number">20</span>, <span class="number">300.23</span>)</span></span>;</span><br><span class="line"><span class="keyword">auto</span> tp = <span class="built_in">StealClass</span>(t1); <span class="comment">// 构建元组</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;GetA: &quot;</span> &lt;&lt; (t1.*(std::<span class="built_in">get</span>&lt;<span class="number">0</span>&gt;(tp)))() &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;_a:   &quot;</span> &lt;&lt; (t1.*(std::<span class="built_in">get</span>&lt;<span class="number">1</span>&gt;(tp))) &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个代码首先声明了友元函数，StealClass会被声明成TestClass的友元函数，从而可以读取到该类的私有成员。随后在实例化StealMember模板的时候，指定了目标类和其私有成员，这样StealClass函数就可以在调用的时候，给我们返回一个包含私有成员指针的<strong>元组</strong>。</p><blockquote><p>重点来了：C++在实例化模板的时候，不会去检查成员的访问限定符。</p></blockquote><p>有了元组，就可以用<code>std::get&lt;元组内元素下标&gt;(元组对象)</code>的方式取出元组的某一个成员，即私有成员的指针。有了私有成员的指针之后，我们就可以使用<code>对象.(*私有成员指针)</code>的方式访问到一个私有成员变量或者成员函数了。</p><p>关于这个特性的更多介绍，可以参考下面的资料</p><ul><li><a href="https://www.bilibili.com/video/BV11x4y1i7ed/">【C++】C++私有成员劫持技巧-哔哩哔哩</a>;</li><li><a href="https://mp.weixin.qq.com/s/hTKOBFLmwPoBD7_o7QYlRw">访问私有成员——从技术实现的角度破坏”封装” 性</a>;</li></ul><p>咋样，是不是很“黑魔法”呢？</p><h3 id="5-4-string相加的时候会有大量无法覆盖的异常分支"><a href="#5-4-string相加的时候会有大量无法覆盖的异常分支" class="headerlink" title="5.4. string相加的时候会有大量无法覆盖的异常分支"></a>5.4. string相加的时候会有大量无法覆盖的异常分支</h3><p>如下图所示，这个函数中调用了string的相加操作，造成了大量的没有覆盖的异常分支。</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/08/4e58d444cdb736c0d66eabec081911ac.png" alt="image.png"></p><p>在gcov报告中可以更详细的看到没有被覆盖的分支都是什么，大多都是和<code>throw</code>有关的。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">function _Z16test_string_plusRKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEES6_ called 2 returned 100% blocks executed 69%</span><br><span class="line">        2:   48:void test_string_plus(const string&amp; local ,const string&amp; remote)</span><br><span class="line">        -:   49:&#123;</span><br><span class="line">        2:   50:    static string recv_msg;</span><br><span class="line">branch  0 taken 1 (fallthrough)</span><br><span class="line">branch  1 taken 1</span><br><span class="line">call    2 returned 1</span><br><span class="line">branch  3 taken 1 (fallthrough)</span><br><span class="line">branch  4 taken 0</span><br><span class="line">call    5 returned 1</span><br><span class="line">call    6 returned 1</span><br><span class="line">call    7 returned 1</span><br><span class="line">        2:   51:    static_cast&lt;void&gt;(recv_msg.assign(&quot;/&quot; + (local &lt; remote ? local + &quot;_&quot; + remote : remote + &quot;_&quot; + local)));</span><br><span class="line">call    0 returned 2</span><br><span class="line">branch  1 taken 1 (fallthrough)</span><br><span class="line">branch  2 taken 1</span><br><span class="line">call    3 returned 1</span><br><span class="line">branch  4 taken 1 (fallthrough)</span><br><span class="line">branch  5 taken 0 (throw)</span><br><span class="line">call    6 returned 1</span><br><span class="line">branch  7 taken 1 (fallthrough)</span><br><span class="line">branch  8 taken 0 (throw)</span><br><span class="line">call    9 returned 1</span><br><span class="line">branch 10 taken 1 (fallthrough)</span><br><span class="line">branch 11 taken 0 (throw)</span><br><span class="line">call   12 returned 1</span><br><span class="line">branch 13 taken 1 (fallthrough)</span><br><span class="line">branch 14 taken 0 (throw)</span><br><span class="line">call   15 returned 2</span><br><span class="line">branch 16 taken 2 (fallthrough)</span><br><span class="line">branch 17 taken 0 (throw)</span><br><span class="line">call   18 returned 2</span><br><span class="line">call   19 returned 2</span><br><span class="line">call   20 returned 2</span><br><span class="line">branch 21 taken 1 (fallthrough)</span><br><span class="line">branch 22 taken 1</span><br><span class="line">call   23 returned 1</span><br><span class="line">branch 24 taken 1 (fallthrough)</span><br><span class="line">branch 25 taken 1</span><br><span class="line">call   26 returned 1</span><br><span class="line">call   27 never executed</span><br><span class="line">branch 28 never executed</span><br><span class="line">branch 29 never executed</span><br><span class="line">call   30 never executed</span><br><span class="line">branch 31 never executed</span><br><span class="line">branch 32 never executed</span><br><span class="line">call   33 never executed</span><br><span class="line">        2:   52:&#125;</span><br></pre></td></tr></table></figure><p>可当前我已经添加了过滤命令了，为什么没有生效呢？</p><p>实际上，将上面的代码改成下面的if&#x2F;else逻辑，就不会有这么多的异常分支了。</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/08/7bb5ccefabbda783aa2a00c33682a38e.png" alt="image.png"></p><p>这是我的猜想：lcov的过滤命令在检测到某一行中有用户定义的判断条件<code>local &lt; remote</code>的时候就会失效，<strong>因为可能会错误过滤掉用户自己的分支</strong>。与其错报一万不可少报一个，于是就把所有的异常分支都展现出来了。</p><p>将<strong>三目运算符</strong>改成if&#x2F;else了之后，用户定义的判断条件和string的相加操作隔离开了，就能正常进行过滤了。所以，在编写优化分支覆盖率的代码的时候，可以考虑将</p><h2 id="6-The-end"><a href="#6-The-end" class="headerlink" title="6. The end"></a>6. The end</h2><p>其实在最开始的时候我记录了更多lcov相关的错误，但大部分错误都可以使用<code>--filter branch</code>选项过滤掉，且有一部分错误在我当前的环境中并没有被复现出来，故此不记录于本文中。</p><p>如果你遇到了本文没有记录的问题，欢迎在评论区留言交流。</p>]]></content>
    
    
    <summary type="html">本文讲述了如何在C++代码中使用单元测试覆盖率工具lcov，以及gcov命令的使用。</summary>
    
    
    
    <category term="编程学习" scheme="https://blog.musnow.top/categories/%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="C++" scheme="https://blog.musnow.top/categories/%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0/C/"/>
    
    
    <category term="Linux" scheme="https://blog.musnow.top/tags/Linux/"/>
    
    <category term="Cpp" scheme="https://blog.musnow.top/tags/Cpp/"/>
    
    <category term="Cpp17" scheme="https://blog.musnow.top/tags/Cpp17/"/>
    
    <category term="单元测试" scheme="https://blog.musnow.top/tags/%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>【leetcode】44.通配符匹配</title>
    <link href="https://blog.musnow.top/posts/1431516729/"/>
    <id>https://blog.musnow.top/posts/1431516729/</id>
    <published>2024-08-18T07:22:47.000Z</published>
    <updated>2024-08-18T07:44:11.000Z</updated>
    
    <content type="html"><![CDATA[<p>本题和<strong>leetcode10.正则表达式</strong>类似，本站也有关于第10题的题解。相比于第十题，本地的情况少一些，更加简单。</p><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><blockquote><p><a href="https://leetcode.cn/problems/wildcard-matching/">https://leetcode.cn/problems/wildcard-matching/</a></p></blockquote><p>给你一个输入字符串 (s) 和一个字符模式 (p) ，请你实现一个支持 <code>&#39;?&#39;</code> 和 <code>&#39;*&#39;</code> 匹配规则的通配符匹配：</p><ul><li><code>&#39;?&#39;</code> 可以匹配任何单个字符。</li><li><code>&#39;*&#39;</code> 可以匹配任意字符序列（包括空字符序列）。</li></ul><p>判定匹配成功的充要条件是：字符模式必须能够 完全匹配 输入字符串（而不是部分匹配）。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">示例 1：</span><br><span class="line">输入：s = &quot;aa&quot;, p = &quot;a&quot;</span><br><span class="line">输出：false</span><br><span class="line">解释：&quot;a&quot; 无法匹配 &quot;aa&quot; 整个字符串。</span><br><span class="line"></span><br><span class="line">示例 2：</span><br><span class="line">输入：s = &quot;aa&quot;, p = &quot;*&quot;</span><br><span class="line">输出：true</span><br><span class="line">解释：&#x27;*&#x27; 可以匹配任意字符串。</span><br><span class="line"></span><br><span class="line">示例 3：</span><br><span class="line">输入：s = &quot;cb&quot;, p = &quot;?a&quot;</span><br><span class="line">输出：false</span><br><span class="line">解释：&#x27;?&#x27; 可以匹配 &#x27;c&#x27;, 但第二个 &#x27;a&#x27; 无法匹配 &#x27;b&#x27;。</span><br></pre></td></tr></table></figure><p>提示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">0 &lt;= s.length, p.length &lt;= 2000</span><br><span class="line">s 仅由小写英文字母组成</span><br><span class="line">p 仅由小写英文字母、&#x27;?&#x27; 或 &#x27;*&#x27; 组成</span><br></pre></td></tr></table></figure><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>本题的星号独立存在，不再像第十题一样是和前一个匹配符绑定的了。所以最终的情况就少了一些。下面的题解是基于第十题之上进行的修改。</p><p>本题可以用动态规划的思路，先定义dp数组，用的是非常常见的定义方式，在很多动态规划的题目中都是用这个方式定义的：</p><ul><li><code>dp[i][j]</code> 为s中i之前，p中j之前（不包括i、j）的字符串能否匹配成功；</li><li>换句话说： <code>dp[i][j]</code>为s中前i个和p中前j个字符能否匹配成功；</li></ul><p>根据这个定义，需要将dp数组构建如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// dp[i][j]代表s中i之前（不包括i）和p中j之前（不包括j）的是否能匹配</span></span><br><span class="line">vector&lt;vector&lt;<span class="type">bool</span>&gt;&gt; <span class="built_in">dp</span>(s.<span class="built_in">size</span>() + <span class="number">1</span>,</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="type">bool</span>&gt;(p.<span class="built_in">size</span>() + <span class="number">1</span>, <span class="literal">false</span>));</span><br></pre></td></tr></table></figure><p>随后是定义递归方程，分为三种情况：</p><ul><li><code>p[j-1]</code>是字母。</li></ul><p>这种情况的递归方程比较简单，我们判断<code>s[i-1] == p[j-1]</code>就能知道当前是否能继续往后匹配了。规划方程如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>] &amp;&amp; s[i - <span class="number">1</span>] == p[j - <span class="number">1</span>];</span><br></pre></td></tr></table></figure><p>其中<code>dp[i - 1][j - 1]</code>代表的是s中前i-1个字符和p中前j-1个字符是否能成功匹配，是“上一次”计算的结果。</p><ul><li><code>p[j-1]</code>是<code>&#39;?&#39;</code>。</li></ul><p>这种情况其实和是字母没区别，因为<code>&#39;?&#39;</code>可以当作任意一个字母来判断。规划方程如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>] &amp;&amp; p[j - <span class="number">1</span>] == <span class="string">&#x27;?&#x27;</span>;</span><br></pre></td></tr></table></figure><ul><li><code>p[j-1]</code>是<code>&#39;*&#39;</code>。</li></ul><p>此时就需要分类讨论了，分为两种情况</p><ul><li>星号匹配0个字符；</li><li>星号匹配1个字符；</li></ul><p>理论上来说还会有匹配2个及以上字符的情况，但是我们这里不需要讨论这种情况，因为我们dp数组在单次循环中，s和p里面的字符都是只会增长1个的，<strong>只是引入了1个新的字符</strong>，那里有匹配俩个及以上字符的情况呢？</p><ul><li>当我们匹配0个字符的时候，就相当于是把星号<code>p[j-1]</code>从p字符串中删除，此时能否匹配就取决于<code>dp[i][j-1]</code>是否为真了。</li><li>当我们匹配1个字符的时候，就相当于使用星号匹配了<code>s[i-1]</code>，此时能否继续匹配就取决于<code>dp[i-1][j]</code>是否为真了。</li></ul><p>思考匹配和不匹配时需要沿用哪一个dp结果，可以走这个思路：我们不使用当前的星号进行匹配的时候，相当于从p里面删除当前<code>p[j-1]</code>星号，所以结果是<code>dp[i][j-1]</code>（j前一位，i不变）；如果我们使用当前星号进行匹配，就相当于从s中删除<code>s[i-1]</code>，所以结果是<code>dp[i-1][j]</code>（i前一位，j不变）；</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>最终的完整代码如下所示</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isMatch</span><span class="params">(string s, string p)</span> </span>&#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">bool</span>&gt;&gt; <span class="built_in">dp</span>(s.<span class="built_in">size</span>() + <span class="number">1</span>,</span><br><span class="line">                                <span class="built_in">vector</span>&lt;<span class="type">bool</span>&gt;(p.<span class="built_in">size</span>() + <span class="number">1</span>, <span class="literal">false</span>));</span><br><span class="line">        <span class="comment">// 初始化</span></span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="literal">true</span>;</span><br><span class="line">        <span class="comment">// 初试化</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">size_t</span> j = <span class="number">1</span>; j &lt; dp[<span class="number">0</span>].<span class="built_in">size</span>(); j++) &#123;</span><br><span class="line">            <span class="comment">// 如果是*则可以匹配，只要有不是*的就没办法匹配</span></span><br><span class="line">            dp[<span class="number">0</span>][j] = p[j - <span class="number">1</span>] == <span class="string">&#x27;*&#x27;</span> &amp;&amp; dp[<span class="number">0</span>][j - <span class="number">1</span>];</span><br><span class="line">            <span class="comment">// cout &lt;&lt; j &lt;&lt; &quot; &quot; &lt;&lt; dp[0][j] &lt;&lt; endl;</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 本题和leetcode10有些区别。主要在于*的处理。</span></span><br><span class="line">        <span class="comment">// 1.字符串是?可以匹配一个</span></span><br><span class="line">        <span class="comment">// 2.字符串是字母，直接比较</span></span><br><span class="line">        <span class="comment">// 3.字符串是*，不需要和前一个配对，直接进行比较</span></span><br><span class="line">        <span class="comment">//      1）匹配0个，则相当于当前字符不存在，沿用dp[i][j-1]</span></span><br><span class="line">        <span class="comment">//      2）匹配1个，相当于?，直接进行匹配，沿用dp[i-1][j]</span></span><br><span class="line">        <span class="comment">//      3）匹配2个以上，不存在这种情况。</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">1</span>; i &lt; dp.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">size_t</span> j = <span class="number">1</span>; j &lt; dp[i].<span class="built_in">size</span>(); j++) &#123;</span><br><span class="line">                <span class="comment">// 情况1，p[j-1] == &#x27;*&#x27;</span></span><br><span class="line">                <span class="keyword">if</span> (p[j - <span class="number">1</span>] == <span class="string">&#x27;*&#x27;</span>) &#123;</span><br><span class="line">                    <span class="comment">// 1. &#x27;*&#x27;只匹配0个字符（相当于删除*）</span></span><br><span class="line">                    <span class="type">bool</span> result1 = dp[i][j - <span class="number">1</span>];</span><br><span class="line">                    <span class="comment">// 2. &#x27;*&#x27;匹配1个字符。</span></span><br><span class="line">                    <span class="type">bool</span> result2 = dp[i - <span class="number">1</span>][j];</span><br><span class="line">                    <span class="comment">// 3. &#x27;*&#x27;匹配2个和以上的字符</span></span><br><span class="line">                    <span class="comment">//    这种情况不用考虑！因为每次dp循环s只新增了一个字符，那里来的两个字符以上的匹配？</span></span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 最终dp只要有一个情况为true就行</span></span><br><span class="line">                    dp[i][j] = result1 || result2;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 情况2，p[j-1] == &#x27;?&#x27; 或者是个字母</span></span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// 1. 是一个字母，直接判断二者是否相等</span></span><br><span class="line">                    <span class="type">bool</span> result1 = dp[i - <span class="number">1</span>][j - <span class="number">1</span>] &amp;&amp; s[i - <span class="number">1</span>] == p[j - <span class="number">1</span>];</span><br><span class="line">                    <span class="comment">// 2. 是一个&#x27;.&#x27;，那和二者相等也是没区别的</span></span><br><span class="line">                    <span class="type">bool</span> result2 = dp[i - <span class="number">1</span>][j - <span class="number">1</span>] &amp;&amp; p[j - <span class="number">1</span>] == <span class="string">&#x27;?&#x27;</span>;</span><br><span class="line">                    dp[i][j] = result1 || result2;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dp[s.<span class="built_in">size</span>()][p.<span class="built_in">size</span>()];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/08/f5997fc1e3ec06d3972dbd3f74883463.png" alt="image.png"></p><p>这里顺带给出降重成一维数组之后的代码，合并了部分状态的判断。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isMatch</span><span class="params">(string s, string p)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 降重</span></span><br><span class="line">        <span class="function">vector&lt;<span class="type">bool</span>&gt; <span class="title">dp</span><span class="params">(p.size() + <span class="number">1</span>, <span class="literal">false</span>)</span></span>;</span><br><span class="line">        <span class="comment">// 初始化</span></span><br><span class="line">        dp[<span class="number">0</span>] = <span class="literal">true</span>;</span><br><span class="line">        <span class="comment">// 初试化</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">size_t</span> j = <span class="number">1</span>; j &lt; dp.<span class="built_in">size</span>(); j++) &#123;</span><br><span class="line">            <span class="comment">// 如果是*则可以匹配，只要有不是*的就没办法匹配</span></span><br><span class="line">            dp[j] = p[j - <span class="number">1</span>] == <span class="string">&#x27;*&#x27;</span> &amp;&amp; dp[j - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 本题和leetcode10有些区别。主要在于*的处理。</span></span><br><span class="line">        <span class="comment">// 1.字符串是?可以匹配一个</span></span><br><span class="line">        <span class="comment">// 2.字符串是字母，直接比较</span></span><br><span class="line">        <span class="comment">// 3.字符串是*，不需要和前一个配对，直接进行比较</span></span><br><span class="line">        <span class="comment">//      1）匹配0个，则相当于当前字符不存在，沿用dp[j-1]</span></span><br><span class="line">        <span class="comment">//      2）匹配1个，相当于?，直接进行匹配，沿用dp[j]</span></span><br><span class="line">        <span class="comment">//      3）匹配2个以上，不存在这种情况。</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">1</span>; i &lt;= s.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="comment">// 用于保存上一轮 dp 的状态</span></span><br><span class="line">            <span class="type">bool</span> prev = dp[<span class="number">0</span>];</span><br><span class="line">            dp[<span class="number">0</span>] = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= p.<span class="built_in">size</span>(); j++) &#123;</span><br><span class="line">                <span class="type">bool</span> temp = dp[j]; <span class="comment">// 保存当前 dp[j]，用于下一次迭代</span></span><br><span class="line">                <span class="keyword">if</span> (p[j - <span class="number">1</span>] == <span class="string">&#x27;*&#x27;</span>) &#123;</span><br><span class="line">                    dp[j] = dp[j - <span class="number">1</span>] || dp[j]; <span class="comment">// 匹配 0 个或 1 个字符</span></span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    dp[j] = prev &amp;&amp; (p[j - <span class="number">1</span>] == <span class="string">&#x27;?&#x27;</span> || s[i - <span class="number">1</span>] == p[j - <span class="number">1</span>]);</span><br><span class="line">                &#125;</span><br><span class="line">                prev = temp; <span class="comment">// 更新 prev</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dp[p.<span class="built_in">size</span>()];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/08/0c77dfda4551b4dd17d7aed4377fd4e5.png" alt="image.png"></p>]]></content>
    
    
    <summary type="html">leetcode刷题笔记-44.通配符匹配</summary>
    
    
    
    <category term="编程学习" scheme="https://blog.musnow.top/categories/%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="把题目都给刷干净" scheme="https://blog.musnow.top/categories/%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0/%E6%8A%8A%E9%A2%98%E7%9B%AE%E9%83%BD%E7%BB%99%E5%88%B7%E5%B9%B2%E5%87%80/"/>
    
    
    <category term="OJ刷题" scheme="https://blog.musnow.top/tags/OJ%E5%88%B7%E9%A2%98/"/>
    
    <category term="leetcode" scheme="https://blog.musnow.top/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>【leetcode】10.正则表达式匹配</title>
    <link href="https://blog.musnow.top/posts/266952207/"/>
    <id>https://blog.musnow.top/posts/266952207/</id>
    <published>2024-08-18T01:49:42.000Z</published>
    <updated>2024-08-18T07:26:06.000Z</updated>
    
    <content type="html"><![CDATA[<p>leetcode刷题笔记-10.正则表达式匹配。</p><p>2024年秋招<strong>柠檬微趣C++开发</strong>和<strong>B站测开</strong>笔试都出现了这道题。</p><p>本题和<strong>leetcode 44.通配符匹配</strong>类似，做完本题后，您可以继续做44题。本站也有关于44题的题解。</p><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><blockquote><p><a href="https://leetcode.cn/problems/regular-expression-matching/description/">https://leetcode.cn/problems/regular-expression-matching/description/</a></p></blockquote><p>给你一个字符串 s 和一个字符规律 p，请你来实现一个支持 <code>&#39;.&#39;</code> 和 <code>&#39;*&#39;</code> 的正则表达式匹配。</p><ul><li><code>&#39;.&#39;</code> 匹配任意单个字符;</li><li><code>&#39;*&#39;</code> 匹配零个或多个前面的那一个元素;</li></ul><p>所谓匹配，是要涵盖 整个 字符串 s 的，而不是部分字符串。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">示例 1：</span><br><span class="line">输入：s = &quot;aa&quot;, p = &quot;a&quot;</span><br><span class="line">输出：false</span><br><span class="line">解释：&quot;a&quot; 无法匹配 &quot;aa&quot; 整个字符串。</span><br><span class="line"></span><br><span class="line">示例 2:</span><br><span class="line">输入：s = &quot;aa&quot;, p = &quot;a*&quot;</span><br><span class="line">输出：true</span><br><span class="line">解释：因为 &#x27;*&#x27; 代表可以匹配零个或多个前面的那一个元素, 在这里前面的元素就是 &#x27;a&#x27;。因此，字符串 &quot;aa&quot; 可被视为 &#x27;a&#x27; 重复了一次。</span><br><span class="line"></span><br><span class="line">示例 3：</span><br><span class="line">输入：s = &quot;ab&quot;, p = &quot;.*&quot;</span><br><span class="line">输出：true</span><br><span class="line">解释：&quot;.*&quot; 表示可匹配零个或多个（&#x27;*&#x27;）任意字符（&#x27;.&#x27;）。</span><br></pre></td></tr></table></figure><p>提示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1 &lt;= s.length &lt;= 20</span><br><span class="line">1 &lt;= p.length &lt;= 20</span><br><span class="line">s 只包含从 a-z 的小写字母。</span><br><span class="line">p 只包含从 a-z 的小写字母，以及字符 . 和 *。</span><br><span class="line">保证每次出现字符 * 时，前面都匹配到有效的字符</span><br></pre></td></tr></table></figure><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><h3 id="对题目的解释"><a href="#对题目的解释" class="headerlink" title="对题目的解释"></a>对题目的解释</h3><p>这道题的描述很烂很烂，主要是关于<code>&#39;*&#39;</code>的描述，说的是“匹配零个或多个前面的那一个元素”。这个描述应该改成“<code>&#39;*&#39;</code>匹配零个前面那一个元素，或多个前面的那一个元素”。</p><p>举个例子，当我们有一个匹配字符串<code>p = &quot;ab*&quot;</code>的时候，最后一个<code>*</code>需要和前面的b绑定使用，即<code>&quot;b*&quot;</code>，含义是匹配0个b或者无数个b。而如果匹配字符串是<code>&quot;.*&quot;</code>，比如题目里面的示例三，那就是等于有0个<code>&#39;.&#39;</code>或者无数个<code>&#39;.&#39;</code>，相当于可以匹配0个或者无数个随机字符（<code>&#39;.&#39;</code>本身可以匹配任何单个字符，合起来就是随机字符匹配了），所以示例三里面才能匹配上ab。</p><p>在题目的提示里面也说到了，保证每次出现<code>*</code>的时候都能匹配到有效的字符，即不可能会出现<code>*</code>之前没有其他字母的情况，也不应该出现两个<code>**</code>连着的情况。</p><p>现在我们了解了题目这个令人琢磨不透的描述了，可以来写代码了。</p><h3 id="思路说明"><a href="#思路说明" class="headerlink" title="思路说明"></a>思路说明</h3><p>本题可以用动态规划的思路，先定义dp数组，用的是非常常见的定义方式，在很多动态规划的题目中都是用这个方式定义的：</p><ul><li><code>dp[i][j]</code> 为s中i之前，p中j之前（不包括i、j）的字符串能否匹配成功；</li><li>换句话说： <code>dp[i][j]</code>为s中前i个和p中前j个字符能否匹配成功；</li></ul><p>根据这个定义，需要将dp数组构建如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// dp[i][j]代表s中i之前（不包括i）和p中j之前（不包括j）的是否能匹配</span></span><br><span class="line">vector&lt;vector&lt;<span class="type">bool</span>&gt;&gt; <span class="built_in">dp</span>(s.<span class="built_in">size</span>() + <span class="number">1</span>,</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="type">bool</span>&gt;(p.<span class="built_in">size</span>() + <span class="number">1</span>, <span class="literal">false</span>));</span><br></pre></td></tr></table></figure><p>随后是定义递归方程，分为三种情况：</p><ul><li><code>p[j-1]</code>是字母。</li></ul><p>这种情况的递归方程比较简单，我们判断<code>s[i-1] == p[j-1]</code>就能知道当前是否能继续往后匹配了。规划方程如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>] &amp;&amp; s[i - <span class="number">1</span>] == p[j - <span class="number">1</span>];</span><br></pre></td></tr></table></figure><p>其中<code>dp[i - 1][j - 1]</code>代表的是s中前i-1个字符和p中前j-1个字符是否能成功匹配，是“上一次”计算的结果。</p><ul><li><code>p[j-1]</code>是<code>&#39;.&#39;</code>。</li></ul><p>这种情况其实和是字母没区别，因为<code>&#39;.&#39;</code>可以当作任意一个字母来判断。规划方程如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>] &amp;&amp; p[j - <span class="number">1</span>] == <span class="string">&#x27;.&#x27;</span>;</span><br></pre></td></tr></table></figure><ul><li><code>p[j-1]</code>是<code>&#39;*&#39;</code>。</li></ul><p>此时就需要分类讨论了，分为两种情况</p><ul><li>星号和前一个字符配对，一起匹配0个字符；</li><li>星号和前一个字符配对，一起匹配1个字符；</li></ul><p>理论上来说还会有匹配2个及以上字符的情况，但是我们这里不需要讨论这种情况，因为我们dp数组在单次循环中，s和p里面的字符都是只会增长1个的，<strong>只是引入了1个新的字符</strong>，那里有匹配俩个及以上字符的情况呢？</p><p>当我们匹配0个字符的时候，就相当于是把<code>p[j-1]</code>和<code>p[j-2]</code>从p字符串中删除，此时能否匹配就取决于<code>dp[i][j-2]</code>是否为真了。</p><p>当我们匹配1个字符的时候，就需要将<code>p[j-2]</code>和<code>*</code>组成的配对串和s进行比较，分为两种子情况：</p><ul><li>当<code>p[j-2]</code>是字符的时候，判断<code>p[j-2]</code>和<code>s[i-1]</code>是否相同，是则沿用<code>dp[i - 1][j]</code>的结果；</li><li>当<code>p[j-2]</code>是<code>&#39;.&#39;</code>的时候，不需要判断（用<code>&#39;.&#39;</code>去匹配<code>s[i-1]</code>），沿用<code>dp[i - 1][j]</code>的结果；</li></ul><p>这里沿用<code>dp[i-1][j]</code>的原因是，我们当前判断的是匹配串<code>p[j-2]*</code>能否继续于与<code>s[i-1]</code>进行匹配，<code>dp[i-1][j]</code>表示<code>s[0:i-1]</code> 可以与 <code>p[0:j]</code> 匹配（即当前字符匹配完成）。而<code>dp[i-1][j-1]</code>的含义是匹配完毕上一个字符就停下了，和当前需要使用<code>p[j-2]*</code>的情况不符合。</p><p>最终<code>p[j-1] == &#39;*&#39;</code>合并起来是三种情况，规划方程如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. &#x27;x*&#x27;只匹配0个字符（相当于删除x）</span></span><br><span class="line"><span class="type">bool</span> result1 = dp[i][j - <span class="number">2</span>];</span><br><span class="line"><span class="comment">// 2.&#x27;x*&#x27;匹配1个字符，此时需要判断s[i-1]和p[j-2]是否相同。</span></span><br><span class="line"><span class="comment">//    这里判断p[j-2]是判断*前面的那一个字符。</span></span><br><span class="line"><span class="comment">//    注意p[j-2]是&#x27;.&#x27;的时候和s[i-1]==p[j-2]等价。</span></span><br><span class="line"><span class="type">bool</span> result2 = dp[i - <span class="number">1</span>][j] &amp;&amp; s[i - <span class="number">1</span>] == p[j - <span class="number">2</span>];</span><br><span class="line"><span class="comment">// 3. &#x27;x*&#x27;匹配一个字符，且p[j-2]是&#x27;.&#x27;，和情况二等价</span></span><br><span class="line"><span class="type">bool</span> result3 = dp[i - <span class="number">1</span>][j] &amp;&amp; p[j - <span class="number">2</span>] == <span class="string">&#x27;.&#x27;</span>;</span><br><span class="line"><span class="comment">// 4. &#x27;x*&#x27;匹配2个和以上的字符</span></span><br><span class="line"><span class="comment">//    这种情况不用考虑！因为每次dp循环s只新增了一个字符，那里来的两个字符以上的匹配？</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 最终dp只要有一个情况为true就行</span></span><br><span class="line">dp[i][j] = result1 || result2 || result3;</span><br></pre></td></tr></table></figure><p>规划方程有了，下面要做的是初始化了。首先显而易见的是<code>dp[0][0] = true</code>，因为s和p都为空串的时候肯定能匹配成功。</p><p>然后就是第一行<code>dp[0]</code>的初始化了，假设我们的输入是<code>s=&quot;&quot;,p=&quot;a*&quot;</code>，这种情况下是能让p成功匹配s的，所以需要对第一行进行初始化。初始化沿用的是<code>p[j-1] == &#39;*&#39;</code>的思路，具体代码如下，说明详见注释。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 初始化，dp[0][0]代表s和p两个都是空，可以匹配。</span></span><br><span class="line">dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="literal">true</span>;</span><br><span class="line"><span class="comment">// 继续初始化第一行，只有出现了x*(x是任意字符)的时候才可以匹配空字符串s；</span></span><br><span class="line"><span class="comment">// 这个时候我们相当于使用*的匹配0个前一个字符的功能。</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">size_t</span> j = <span class="number">2</span>; j &lt; dp[<span class="number">0</span>].<span class="built_in">size</span>(); j += <span class="number">2</span>) &#123;</span><br><span class="line"><span class="comment">// 比如&#x27;b*&#x27;我们就认为是匹配0个b，相当于匹配空串。</span></span><br><span class="line"><span class="comment">// 此时dp就依赖于dp[0][j-2]是否为true了，即抛弃了&#x27;b*&#x27;中的b还能不能匹配的上。</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// 注意dp数组的定义是i和j之前的元素是否能匹配，不包括i和j自己！</span></span><br><span class="line"><span class="comment">// 所以当前我们判断的是p[j-1]，而dp[0][j-2]对应的就是p中下标j-3和j-3之前的字符能否匹配。</span></span><br><span class="line"><span class="comment">// 而&#x27;b*&#x27;数组为两个元素，当p[j-1]等于*时（j-1=1，j=2）；</span></span><br><span class="line"><span class="comment">// j-3是负数，即我们希望判断-1和-1之前的字符串p是否能和s匹配；</span></span><br><span class="line"><span class="comment">// 这个含义就是空字符串p，所以可以和s匹配的上，此时为true。</span></span><br><span class="line">dp[<span class="number">0</span>][j] = dp[<span class="number">0</span>][j - <span class="number">2</span>] &amp;&amp; p[j - <span class="number">1</span>] == <span class="string">&#x27;*&#x27;</span>;</span><br><span class="line"><span class="comment">// 一定要根据dp数组的定义来思考这个问题：</span></span><br><span class="line"><span class="comment">// 假设j-3=0，这时候的含义就变成了判断下标0和0之前的字符是否能匹配，字符串p不是空串，无法和s匹配上。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h2><p>完整代码如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isMatch</span><span class="params">(string s, string p)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// dp[i][j]代表s中i之前（不包括i）和p中j之前（不包括j）的是否能匹配</span></span><br><span class="line">        vector&lt;vector&lt;<span class="type">bool</span>&gt;&gt; <span class="built_in">dp</span>(s.<span class="built_in">size</span>() + <span class="number">1</span>,</span><br><span class="line">                                <span class="built_in">vector</span>&lt;<span class="type">bool</span>&gt;(p.<span class="built_in">size</span>() + <span class="number">1</span>, <span class="literal">false</span>));</span><br><span class="line">        <span class="comment">// 初始化，dp[0][0]代表s和p两个都是空，可以匹配。</span></span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="literal">true</span>;</span><br><span class="line">        <span class="comment">// 继续初始化第一行，只有出现了x*(x是任意字符)的时候才可以匹配空字符串s；</span></span><br><span class="line">        <span class="comment">// 这个时候我们相当于使用*的匹配0个前一个字符的功能。</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">size_t</span> j = <span class="number">2</span>; j &lt; dp[<span class="number">0</span>].<span class="built_in">size</span>(); j += <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="comment">// 比如&#x27;b*&#x27;我们就认为是匹配0个b，相当于匹配空串。</span></span><br><span class="line">            <span class="comment">// 此时dp就依赖于dp[0][j-2]是否为true了，即抛弃了&#x27;b*&#x27;中的b还能不能匹配的上。</span></span><br><span class="line">            <span class="comment">//</span></span><br><span class="line">            <span class="comment">// 注意dp数组的定义是i和j之前的元素是否能匹配，不包括i和j自己！</span></span><br><span class="line">            <span class="comment">// 所以当前我们判断的是p[j-1]，而dp[0][j-2]对应的就是p中下标j-3和j-3之前的字符能否匹配。</span></span><br><span class="line">            <span class="comment">// 而&#x27;b*&#x27;数组为两个元素，当p[j-1]等于*时（j-1=1，j=2）；</span></span><br><span class="line">            <span class="comment">// j-3是负数，即我们希望判断-1和-1之前的字符串p是否能和s匹配；</span></span><br><span class="line">            <span class="comment">// 这个含义就是空字符串p，所以可以和s匹配的上，此时为true。</span></span><br><span class="line">            dp[<span class="number">0</span>][j] = dp[<span class="number">0</span>][j - <span class="number">2</span>] &amp;&amp; p[j - <span class="number">1</span>] == <span class="string">&#x27;*&#x27;</span>;</span><br><span class="line">            <span class="comment">// 一定要根据dp数组的定义来思考这个问题：</span></span><br><span class="line">            <span class="comment">// 假设j-3=0，这时候的含义就变成了判断下标0和0之前的字符是否能匹配，字符串p不是空串，无法和s匹配上。</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// i从1开始遍历（相当于从s的下标0开始处理）</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">1</span>; i &lt; dp.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">size_t</span> j = <span class="number">1</span>; j &lt; dp[i].<span class="built_in">size</span>(); j++) &#123;</span><br><span class="line">                <span class="comment">// 情况1，p[j-1] == &#x27;*&#x27;</span></span><br><span class="line">                <span class="keyword">if</span> (p[j - <span class="number">1</span>] == <span class="string">&#x27;*&#x27;</span>) &#123;</span><br><span class="line">                    <span class="comment">// 1. &#x27;x*&#x27;只匹配0个字符（相当于删除x）</span></span><br><span class="line">                    <span class="type">bool</span> result1 = dp[i][j - <span class="number">2</span>];</span><br><span class="line">                    <span class="comment">// 2.&#x27;x*&#x27;匹配1个字符，此时需要判断s[i-1]和p[j-2]是否相同。</span></span><br><span class="line">                    <span class="comment">//    这里判断p[j-2]是判断*前面的那一个字符。</span></span><br><span class="line">                    <span class="comment">//    注意p[j-2]是&#x27;.&#x27;的时候和s[i-1]==p[j-2]等价。</span></span><br><span class="line">                    <span class="type">bool</span> result2 = dp[i - <span class="number">1</span>][j] &amp;&amp; s[i - <span class="number">1</span>] == p[j - <span class="number">2</span>];</span><br><span class="line">                    <span class="comment">// 3. &#x27;x*&#x27;匹配一个字符，且p[j-2]是&#x27;.&#x27;，和情况二等价</span></span><br><span class="line">                    <span class="type">bool</span> result3 = dp[i - <span class="number">1</span>][j] &amp;&amp; p[j - <span class="number">2</span>] == <span class="string">&#x27;.&#x27;</span>;</span><br><span class="line">                    <span class="comment">// 4. &#x27;x*&#x27;匹配2个和以上的字符</span></span><br><span class="line">                    <span class="comment">//    这种情况不用考虑！因为每次dp循环s只新增了一个字符，那里来的两个字符以上的匹配？</span></span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 最终dp只要有一个情况为true就行</span></span><br><span class="line">                    dp[i][j] = result1 || result2 || result3;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 情况2，p[j-1] == &#x27;.&#x27; 或者是个字母</span></span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// 1. 是一个字母，直接判断二者是否相等</span></span><br><span class="line">                    <span class="type">bool</span> result1 = dp[i - <span class="number">1</span>][j - <span class="number">1</span>] &amp;&amp; s[i - <span class="number">1</span>] == p[j - <span class="number">1</span>];</span><br><span class="line">                    <span class="comment">// 2. 是一个&#x27;.&#x27;，那和二者相等也是没区别的</span></span><br><span class="line">                    <span class="type">bool</span> result2 = dp[i - <span class="number">1</span>][j - <span class="number">1</span>] &amp;&amp; p[j - <span class="number">1</span>] == <span class="string">&#x27;.&#x27;</span>;</span><br><span class="line">                    dp[i][j] = result1 || result2;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 返回右下角的值得到是否完成匹配</span></span><br><span class="line">        <span class="keyword">return</span> dp[s.<span class="built_in">size</span>()][p.<span class="built_in">size</span>()];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/08/9979a5a4b900f15d3ba2084bccb02c22.png" alt="image.png"></p>]]></content>
    
    
    <summary type="html">leetcode刷题笔记-10.正则表达式匹配</summary>
    
    
    
    <category term="编程学习" scheme="https://blog.musnow.top/categories/%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="把题目都给刷干净" scheme="https://blog.musnow.top/categories/%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0/%E6%8A%8A%E9%A2%98%E7%9B%AE%E9%83%BD%E7%BB%99%E5%88%B7%E5%B9%B2%E5%87%80/"/>
    
    
    <category term="OJ刷题" scheme="https://blog.musnow.top/tags/OJ%E5%88%B7%E9%A2%98/"/>
    
    <category term="leetcode" scheme="https://blog.musnow.top/tags/leetcode/"/>
    
    <category term="动态规划" scheme="https://blog.musnow.top/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>【算法】单调栈</title>
    <link href="https://blog.musnow.top/posts/1452956128/"/>
    <id>https://blog.musnow.top/posts/1452956128/</id>
    <published>2024-08-14T22:40:27.000Z</published>
    <updated>2024-08-16T02:53:49.000Z</updated>
    
    <content type="html"><![CDATA[<p>leetcode刷题笔记，单调栈系列。</p><h2 id="739-每日温度"><a href="#739-每日温度" class="headerlink" title="739.每日温度"></a>739.每日温度</h2><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><blockquote><p><a href="https://leetcode.cn/problems/daily-temperatures/">https://leetcode.cn/problems/daily-temperatures/</a></p></blockquote><p>给定一个整数数组 temperatures ，表示每天的温度，返回一个数组 answer ，其中 <code>answer[i]</code> 是指对于第 i 天，下一个更高温度出现在几天后。如果气温在这之后都不会升高，请在该位置用 0 来代替。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">示例 1:</span><br><span class="line">输入: temperatures = [73,74,75,71,69,72,76,73]</span><br><span class="line">输出: [1,1,4,2,1,1,0,0]</span><br><span class="line"></span><br><span class="line">示例 2:</span><br><span class="line">输入: temperatures = [30,40,50,60]</span><br><span class="line">输出: [1,1,1,0]</span><br><span class="line"></span><br><span class="line">示例 3:</span><br><span class="line">输入: temperatures = [30,60,90]</span><br><span class="line">输出: [1,1,0]</span><br></pre></td></tr></table></figure><p>提示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1 &lt;= temperatures.length &lt;= 105</span><br><span class="line">30 &lt;= temperatures[i] &lt;= 100</span><br></pre></td></tr></table></figure><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>这是单调栈系列的入门题目，可以让我们很好的了解单调栈的特性。</p><p>首先，题目要求的是返回一个结果集（我一般定义为<code>retV</code>），结果集中的每一位是当前温度下一个比他大的温度在“几天后”，也就是在数组中相隔的举例。比如下标1的下一个比他大的温度是下标3，那么就是2天后，也可以用<code>3-1</code>这种下标相减的方式直接计算出来。</p><p>为了能直接更新出这个距离，我们需要一个栈，这个栈维护的是元素下标，概念是对应的元素在栈内是<strong>单调递增</strong>的（从栈顶到栈底）。</p><blockquote><p>如果单调栈直接维护数组中的元素的话，我们就没有办法直接算出两个下标直接的距离得出相差的天数，那样就没有什么意义了。我们维护下标，相当于同时维护了一个“距离”和元素本身的值（毕竟下标可以从原数组中取出值来）。</p></blockquote><p>当我们遍历i的时候，i之前的元素已经按栈顶到栈底<strong>升序</strong>的方式放入栈内了，我们取栈顶得到的一定是i之前的某一个元素的下标，当<code>temperatures[i]</code>比栈顶下标对应的元素<code>temperatures[st.top()]</code>的元素<strong>更大</strong>，说明i是<strong>栈顶元素之后第一个比他大的元素</strong>。此时就可以通过<code>i-st.top()</code>得出距离，写入到<code>retV[st.top()]</code>结果集中。</p><p>注意，这个判断操作是一个循环，因为我们当前的元素<code>temperatures[i]</code>可能会匹配很多之前元素的条件。比如数组<code>2 1 3</code>中，3就是比2和1都大的元素，此时2和1都需要把<code>下一个比自己大的元素</code>更新为3。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 只要栈内有元素，就需要继续弹出，不断判断是否比栈顶元素大</span></span><br><span class="line"><span class="keyword">while</span> (!st.<span class="built_in">empty</span>() &amp;&amp;</span><br><span class="line">   temperatures[i] &gt; temperatures[st.<span class="built_in">top</span>()])</span><br><span class="line">&#123;&#125;</span><br></pre></td></tr></table></figure><p>如果当<code>temperatures[i]</code>比栈顶下标对应的元素<code>temperatures[st.top()]</code>更小，此时只需要将i下标入栈，相当于维护了单调栈从<strong>栈顶到栈底单调递增</strong>的特性，继续后续的比较。</p><p>另外，题目要求如果某一天之后没有比他温度更高的，则在结果集中写为0。这个可以直接用vector的构造函数来把整个数组初始化为0。如果某一天之后没有比他温度更高的，在循环中就不会被赋值，保留了构造函数初始化的0，也符合题目的预期结果。</p><h3 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dailyTemperatures</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; temperatures)</span> </span>&#123;</span><br><span class="line">        stack&lt;<span class="type">int</span>&gt; st; <span class="comment">// 单调栈</span></span><br><span class="line">        <span class="comment">// 这里初试化为全0，默认每个元素右边都么有比自己大的，这样结尾的元素不需要单独处理</span></span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">retV</span><span class="params">(temperatures.size(), <span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="comment">// 思路如下，遍历的时候，将下标入栈</span></span><br><span class="line">        <span class="comment">// 1.当前元素大于栈顶元素（用下标访问得到元素大小），出栈顶元素</span></span><br><span class="line">        <span class="comment">//   并使用当前元素下标-栈顶元素下标得到距离，写入结果集</span></span><br><span class="line">        <span class="comment">// 2.当前元素小于等于栈顶元素，将下标入栈</span></span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        <span class="comment">// 这样能保障栈顶到栈底是递增的，也就能找到右边第一个比当前元素大的元素</span></span><br><span class="line">        <span class="comment">// 第一个元素直接入栈</span></span><br><span class="line">        st.<span class="built_in">push</span>(<span class="number">0</span>);</span><br><span class="line">        <span class="comment">// 从第二个元素开始遍历</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; temperatures.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="comment">// 大于</span></span><br><span class="line">            <span class="keyword">if</span> (temperatures[i] &gt; temperatures[st.<span class="built_in">top</span>()]) &#123;</span><br><span class="line">                <span class="comment">// 只要栈内有元素，就需要继续弹出，不断判断是否比栈顶元素大</span></span><br><span class="line">                <span class="keyword">while</span> (!st.<span class="built_in">empty</span>() &amp;&amp;</span><br><span class="line">                       temperatures[i] &gt; temperatures[st.<span class="built_in">top</span>()]) &#123;</span><br><span class="line">                    <span class="type">int</span> topIndex = st.<span class="built_in">top</span>();</span><br><span class="line">                    st.<span class="built_in">pop</span>();</span><br><span class="line">                    retV[topIndex] = i - topIndex; <span class="comment">// 赋值距离</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 栈为空，或者当前元素小于栈顶元素，可以入栈</span></span><br><span class="line">                <span class="keyword">if</span> (st.<span class="built_in">empty</span>() || temperatures[i] &lt;= temperatures[st.<span class="built_in">top</span>()]) &#123;</span><br><span class="line">                    <span class="comment">// cout &lt;&lt; &quot;push &quot; &lt;&lt; i &lt;&lt; endl;</span></span><br><span class="line">                    st.<span class="built_in">push</span>(i);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="comment">// 小于等于</span></span><br><span class="line">            &#123;</span><br><span class="line">                st.<span class="built_in">push</span>(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 到这里遍历结束了，但是栈里面还有元素</span></span><br><span class="line">        <span class="comment">// 此时栈里面的元素右边都不会有比自己更大的元素了，因为从栈顶到栈底是递增的</span></span><br><span class="line">        <span class="comment">// 而我们在初始化vector的时候已经初始化为全0了，也就不需要对这种情况单独处理</span></span><br><span class="line">        <span class="keyword">return</span> retV;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/08/a5d1f984d343cdb8a906d013d7361516.png" alt="image.png"></p><h2 id="496-下一个更大元素-I"><a href="#496-下一个更大元素-I" class="headerlink" title="496. 下一个更大元素 I"></a>496. 下一个更大元素 I</h2><h3 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h3><blockquote><p><a href="https://leetcode.cn/problems/next-greater-element-i/description/">https://leetcode.cn/problems/next-greater-element-i/description/</a></p></blockquote><p>nums1 中数字 x 的 下一个更大元素 是指 x 在 nums2 中对应位置 右侧 的 第一个 比 x 大的元素。</p><p>给你两个 没有重复元素 的数组 nums1 和 nums2 ，下标从 0 开始计数，其中nums1 是 nums2 的子集。</p><p>对于每个 <code>0 &lt;= i &lt; nums1.length</code> ，找出满足 <code>nums1[i] == nums2[j]</code> 的下标 j ，并且在 nums2 确定 <code>nums2[j]</code> 的 下一个更大元素 。如果不存在下一个更大元素，那么本次查询的答案是 -1 。</p><p>返回一个长度为 <code>nums1.length</code> 的数组 ans 作为答案，满足 <code>ans[i]</code> 是如上所述的 下一个更大元素 。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">示例 1：</span><br><span class="line">输入：nums1 = [4,1,2], nums2 = [1,3,4,2].</span><br><span class="line">输出：[-1,3,-1]</span><br><span class="line">解释：nums1 中每个值的下一个更大元素如下所述：</span><br><span class="line">- 4 ，用加粗斜体标识，nums2 = [1,3,4,2]。不存在下一个更大元素，所以答案是 -1 。</span><br><span class="line">- 1 ，用加粗斜体标识，nums2 = [1,3,4,2]。下一个更大元素是 3 。</span><br><span class="line">- 2 ，用加粗斜体标识，nums2 = [1,3,4,2]。不存在下一个更大元素，所以答案是 -1 。</span><br><span class="line">- </span><br><span class="line">示例 2：</span><br><span class="line">输入：nums1 = [2,4], nums2 = [1,2,3,4].</span><br><span class="line">输出：[3,-1]</span><br><span class="line">解释：nums1 中每个值的下一个更大元素如下所述：</span><br><span class="line">- 2 ，用加粗斜体标识，nums2 = [1,2,3,4]。下一个更大元素是 3 。</span><br><span class="line">- 4 ，用加粗斜体标识，nums2 = [1,2,3,4]。不存在下一个更大元素，所以答案是 -1 。</span><br></pre></td></tr></table></figure><p>提示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1 &lt;= nums1.length &lt;= nums2.length &lt;= 1000</span><br><span class="line">0 &lt;= nums1[i], nums2[i] &lt;= 104</span><br><span class="line">nums1和nums2中所有整数 互不相同</span><br><span class="line">nums1 中的所有整数同样出现在 nums2 中</span><br></pre></td></tr></table></figure><p>进阶：你可以设计一个时间复杂度为 <code>O(nums1.length + nums2.length)</code> 的解决方案吗？</p><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><p>这道题其实和739没有什么区别，但是我们得理清楚题目要求的是什么，以及nums1和nums2的含义。</p><p>nums1是nums2的子集，代表nums1的元素都可以在nums2中找到。</p><blockquote><p>nums1 中数字 x 的 下一个更大元素 是指 x 在 nums2 中对应位置 右侧 的 第一个 比 x 大的元素。</p></blockquote><p>这个描述的意思是，我们需要返回一个基于nums1的数组，数组中的每一个元素，是<code>nums1[i]</code>在nums2中对应的下一个比他大的元素。注意不再是下标距离了，而是下一个比他大的元素本身。</p><p>说白了就是，这道题让我们基于nums2找每一个元素下一个比他大的元素是谁。但是最终的结果集只需要包含nums1中存在的元素就可以了。</p><p>这样思路就简单了，我们可以用一个map来维护nums1中出现的元素和他们在nums1中对应的下标。方便在最终的结果集里面设置。然后直接和739题目一样遍历nums2就可以了。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用map来映射1中的元素和1中的下标，方便设置结果</span></span><br><span class="line">unordered_map&lt;<span class="type">int</span>, <span class="type">size_t</span>&gt; index1Map;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; nums1.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">    index1Map[nums1[i]] = i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>你甚至可以先直接按739的方式把所有nums2元素的下一个比他更大的元素找出来存放到map里面，然后再遍历nums1把对应元素的下一个比他大的元素设置进结果集里面。这样本题和739想必就不存在逻辑代码的大的改变了。</p><h3 id="完整代码-1"><a href="#完整代码-1" class="headerlink" title="完整代码"></a>完整代码</h3><p>核心思路和739题目那是一样一样的。只不过在while循环中，我们需要判断当前栈顶元素是否出现在nums1中了，出现过才需要设置到结果集里面。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">nextGreaterElement</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums1, vector&lt;<span class="type">int</span>&gt;&amp; nums2)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 题目说1和2数组都没有重复元素，意思是单个数组中没有重复的。</span></span><br><span class="line">        <span class="comment">// 注意，题目要求的是1中的元素，在2里面对应的下一个更大元素是谁</span></span><br><span class="line">        <span class="comment">// 本质上是让我们求2中的某一个元素的下一个更大元素是谁，这里的“某一个元素”被nums1固定了。</span></span><br><span class="line">        <span class="comment">// 所以结果的数量是nums1。</span></span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">retV</span><span class="params">(nums1.size(), <span class="number">-1</span>)</span></span>;</span><br><span class="line">        <span class="comment">// 使用map来映射1中的元素和1中的下标，方便设置结果</span></span><br><span class="line">        unordered_map&lt;<span class="type">int</span>, <span class="type">size_t</span>&gt; index1Map;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; nums1.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            index1Map[nums1[i]] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// nums1只是一个给出的要找下一个更大元素的集合，真的要找的东西都在2里面，得遍历2。</span></span><br><span class="line">        stack&lt;<span class="type">int</span>&gt; st; <span class="comment">// 同样是从栈顶到栈底单调递增的栈，存放2中的下标。</span></span><br><span class="line">        st.<span class="built_in">push</span>(<span class="number">0</span>); <span class="comment">// 第一个元素直接入栈</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">1</span>; i &lt; nums2.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="comment">// 因为求的是下一个比当前元素大的，所以小于等于的都直接入栈</span></span><br><span class="line">            <span class="keyword">if</span> (nums2[i] &lt;= nums2[st.<span class="built_in">top</span>()]) &#123;</span><br><span class="line">                st.<span class="built_in">push</span>(i);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// while循环一直判断是否比当前元素小</span></span><br><span class="line">                <span class="keyword">while</span> (!st.<span class="built_in">empty</span>() &amp;&amp; nums2[i] &gt; nums2[st.<span class="built_in">top</span>()]) &#123;</span><br><span class="line">                    <span class="comment">// 判断这个栈顶元素是否被nums1选中需要处理</span></span><br><span class="line">                    <span class="keyword">auto</span> ret = index1Map.<span class="built_in">find</span>(nums2[st.<span class="built_in">top</span>()]);</span><br><span class="line">                    <span class="keyword">if</span> (ret != index1Map.<span class="built_in">end</span>()) &#123;</span><br><span class="line">                        <span class="comment">// 取下标</span></span><br><span class="line">                        <span class="type">size_t</span> indexIn1 = ret-&gt;second;</span><br><span class="line">                        <span class="comment">// 设置下一个更大的元素是谁（不是设置距离了）</span></span><br><span class="line">                        retV[indexIn1] = nums2[i];</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// 不管有没有被选中都须出栈</span></span><br><span class="line">                    st.<span class="built_in">pop</span>();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 当前元素入栈</span></span><br><span class="line">                st.<span class="built_in">push</span>(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> retV;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/08/fcebd4980d1482b36709b52b18536877.png" alt="image.png"></p><p>这里顺带贴出上文提到过的把2中所有元素下一个比他大的元素弄出来再遍历nums1的方法</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">nextGreaterElement</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums1, vector&lt;<span class="type">int</span>&gt;&amp; nums2)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 使用map来映射2中的元素下一个比他大的元素。</span></span><br><span class="line">        unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; biggerMap;</span><br><span class="line">        <span class="comment">// nums1只是一个给出的要找下一个更大元素的集合，真的要找的东西都在2里面，得遍历2。</span></span><br><span class="line">        stack&lt;<span class="type">int</span>&gt; st; <span class="comment">// 同样是从栈顶到栈底单调递增的栈，存放2中的下标。</span></span><br><span class="line">        st.<span class="built_in">push</span>(<span class="number">0</span>); <span class="comment">// 第一个元素直接入栈</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">1</span>; i &lt; nums2.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="comment">// 因为求的是下一个比当前元素大的，所以小于等于的都直接入栈</span></span><br><span class="line">            <span class="keyword">if</span> (nums2[i] &lt;= nums2[st.<span class="built_in">top</span>()]) &#123;</span><br><span class="line">                st.<span class="built_in">push</span>(i);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// while循环一直判断是否比当前元素小</span></span><br><span class="line">                <span class="keyword">while</span> (!st.<span class="built_in">empty</span>() &amp;&amp; nums2[i] &gt; nums2[st.<span class="built_in">top</span>()]) &#123;</span><br><span class="line">                    biggerMap[nums2[st.<span class="built_in">top</span>()]] = nums2[i];</span><br><span class="line">                    st.<span class="built_in">pop</span>();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 当前元素入栈</span></span><br><span class="line">                st.<span class="built_in">push</span>(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 题目说1和2数组都没有重复元素，意思是单个数组中没有重复的，但是两个数组之间会有。</span></span><br><span class="line">        <span class="comment">// 注意，题目要求的是1中的元素，在2里面对应的下一个更大元素是谁</span></span><br><span class="line">        <span class="comment">// 本质上是让我们求2中的某一个元素的下一个更大元素是谁，这里的“某一个元素”被nums1固定了。</span></span><br><span class="line">        <span class="comment">// 所以结果的数量是nums1。</span></span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">retV</span><span class="params">(nums1.size(), <span class="number">-1</span>)</span></span>;</span><br><span class="line">        <span class="comment">// 重新遍历nums1，找map中该元素下一个比他大的元素是啥，设置进结果集里面</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; nums1.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="comment">// 注意，有些元素不存在下一个比他更大的，此时不能直接[]取，会取出来int默认值0；</span></span><br><span class="line">            <span class="keyword">if</span> (biggerMap.<span class="built_in">count</span>(nums1[i]) != <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="type">int</span> nextBigger = biggerMap[nums1[i]];</span><br><span class="line">                retV[i] = nextBigger;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> retV;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>效果都是一样的，也符合题目对时间复杂度的进阶要求</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/08/b02f3098b0fd395810200197b0804fe3.png" alt="image.png"></p><h2 id="503-下一个更大元素-II"><a href="#503-下一个更大元素-II" class="headerlink" title="503. 下一个更大元素 II"></a>503. 下一个更大元素 II</h2><h3 id="题目-2"><a href="#题目-2" class="headerlink" title="题目"></a>题目</h3><blockquote><p><a href="https://leetcode.cn/problems/next-greater-element-ii/description/">https://leetcode.cn/problems/next-greater-element-ii/description/</a></p></blockquote><p>给定一个循环数组 nums （ <code>nums[nums.length - 1]</code> 的下一个元素是 <code>nums[0]</code> ），返回 nums 中每个元素的 下一个更大元素 。</p><p>数字 x 的 下一个更大的元素 是按数组遍历顺序，这个数字之后的第一个比它更大的数，这意味着你应该循环地搜索它的下一个更大的数。如果不存在，则输出 -1 。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">示例 1:</span><br><span class="line">输入: nums = [1,2,1]</span><br><span class="line">输出: [2,-1,2]</span><br><span class="line">解释: 第一个 1 的下一个更大的数是 2；</span><br><span class="line">数字 2 找不到下一个更大的数； </span><br><span class="line">第二个 1 的下一个最大的数需要循环搜索，结果也是 2。</span><br><span class="line"></span><br><span class="line">示例 2:</span><br><span class="line">输入: nums = [1,2,3,4,3]</span><br><span class="line">输出: [2,3,4,-1,4]</span><br></pre></td></tr></table></figure><p>提示:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1 &lt;= nums.length &lt;= 104</span><br><span class="line">-109 &lt;= nums[i] &lt;= 109</span><br></pre></td></tr></table></figure><h3 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h3><p>这道题咋一看引入了循环数组，有点难，但实际上因为题目没有说让我们计算距离，可以直接把原本的数组弄成两份合并成一个大数组，然后用739题目的方式把这个大数组遍历完毕，就能得到每一个数的下一个更大的元素是什么了。</p><p>可以用如下的方式，构建一个目标数组，把原数组两次插入进去即可。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">nums1</span><span class="params">(nums.begin(), nums.end())</span></span>;</span><br><span class="line">nums1.<span class="built_in">insert</span>(nums1.<span class="built_in">end</span>(), nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>());</span><br></pre></td></tr></table></figure><p>但是这样做会有一个额外的<code>O(N)</code>的时间复杂度消耗，虽然最终我们的时间复杂度是定格在了<code>O(2N)</code>量级，但我们还是可以想办法把这个多出来的时间复杂度和空间复杂度给优化一下的。</p><p>解决方式如下，我们直接把for循环的遍历区间乘2，然后每一次模一下数组的长度来得到实际的下标，这样就模拟出了遍历两次nums数组了！</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">1</span>; k &lt; nums.<span class="built_in">size</span>() * <span class="number">2</span>; k++) &#123;</span><br><span class="line"><span class="type">int</span> i = k % nums.<span class="built_in">size</span>(); <span class="comment">// 实际的下标</span></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>后续的操作步骤和739题一模一样，此处不做讲解。</p><h3 id="完整代码-2"><a href="#完整代码-2" class="headerlink" title="完整代码"></a>完整代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">nextGreaterElements</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 这到题和739完全一样，只不过是循环数组；</span></span><br><span class="line">        <span class="comment">// 因为结果不需要我们写距离，而是记录元素，那么问题就很好解决了；</span></span><br><span class="line">        <span class="comment">// 我们可以把原本数组拼接一次，然后直接进行判断，再把判断结果resize为原数组大小即可。</span></span><br><span class="line">        <span class="comment">// vector&lt;int&gt; nums1(nums.begin(), nums.end());</span></span><br><span class="line">        <span class="comment">// nums1.insert(nums1.end(), nums.begin(), nums.end());</span></span><br><span class="line">        <span class="comment">// 但是这样会有额外的扩容拼接的消耗，我们还不如直接用for循环模拟两次遍历nums；</span></span><br><span class="line">        stack&lt;<span class="type">int</span>&gt; st;</span><br><span class="line">        st.<span class="built_in">push</span>(<span class="number">0</span>); <span class="comment">// 下标</span></span><br><span class="line">        <span class="comment">// 结果集</span></span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">retV</span><span class="params">(nums.size(), <span class="number">-1</span>)</span></span>;</span><br><span class="line">        <span class="comment">// 从1开始遍历</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">1</span>; k &lt; nums.<span class="built_in">size</span>() * <span class="number">2</span>; k++) &#123;</span><br><span class="line">            <span class="type">int</span> i = k % nums.<span class="built_in">size</span>(); <span class="comment">// 实际的下标</span></span><br><span class="line">            <span class="keyword">if</span> (nums[i] &lt;= nums[st.<span class="built_in">top</span>()]) &#123;</span><br><span class="line">                st.<span class="built_in">push</span>(i);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">while</span> (!st.<span class="built_in">empty</span>() &amp;&amp; nums[i] &gt; nums[st.<span class="built_in">top</span>()]) &#123;</span><br><span class="line">                    retV[st.<span class="built_in">top</span>()] = nums[i];</span><br><span class="line">                    st.<span class="built_in">pop</span>();</span><br><span class="line">                &#125;</span><br><span class="line">                st.<span class="built_in">push</span>(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> retV;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/08/2b96f8dc4f270a6491e7636a82b9dab2.png" alt="image.png"></p><h2 id="42-接雨水"><a href="#42-接雨水" class="headerlink" title="42. 接雨水"></a>42. 接雨水</h2><h3 id="题目-3"><a href="#题目-3" class="headerlink" title="题目"></a>题目</h3><blockquote><p><a href="https://leetcode.cn/problems/trapping-rain-water/">https://leetcode.cn/problems/trapping-rain-water/</a></p></blockquote><p>给定 n 个非负整数表示每个宽度为 1 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。</p><p> <img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/08/10ec85fb0e96f594b69d8f2b8110abe6.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">示例 1：</span><br><span class="line">输入：height = [0,1,0,2,1,0,1,3,2,1,2,1]</span><br><span class="line">输出：6</span><br><span class="line">解释：上面是由数组 [0,1,0,2,1,0,1,3,2,1,2,1] 表示的高度图，在这种情况下，可以接 6 个单位的雨水（蓝色部分表示雨水）。 </span><br><span class="line"></span><br><span class="line">示例 2：</span><br><span class="line">输入：height = [4,2,0,3,2,5]</span><br><span class="line">输出：9</span><br></pre></td></tr></table></figure><p>提示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">n == height.length</span><br><span class="line">1 &lt;= n &lt;= 2 * 104</span><br><span class="line">0 &lt;= height[i] &lt;= 105</span><br></pre></td></tr></table></figure><h3 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h3><p>这道题可是火热的很，面试笔试常考题，也是单调栈的经典题目。虽然它可以用双指针或暴力方式实现，但是暴力和双指针方法个人感觉比单调栈的思路还难理解，因为会有很多边界情况，真让面试上手写了估计会压力山大汗流浃背啥都写不出来。不如把单调栈的思路背熟了直接上去就是啪啪一顿敲。</p><p>首先还是要记住739题目这个单调栈的入门题目。来分析一下接雨水需要记录什么数据。根据图片，我们知道，接雨水需要记录一个左边界、右边界、以及凹槽的高度，这样才能用长乘宽计算出雨水的面积。</p><p>比如下面这个图中，雨水的面积是中间这一块蓝色区域。要计算这个凹槽的面积，我们需要得到左边和右边两个柱子的高度，还需要知道中间凹槽底部有多高。</p><ul><li>高度依据木桶原理，2和3中取最小的2，还需要减去底部的高度1，得到最终的高度为1；</li><li>宽度使用3的下标减去2的下标，再减去1（因为我们只需要中间部分），得到宽度是1；</li></ul><p>最终的结果是<code>1*1=1</code>，雨水的面积是1。</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/08/4d8bf7417d00a9fd9bac76fac147c47f.png" alt="image.png"></p><p>这是比较普遍的情况，但是还有没那么普遍的情况，比如示例一中图片中间如同俄罗斯方块的这个部分，它要怎么计算出面积呢？</p><p> <img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/08/10ec85fb0e96f594b69d8f2b8110abe6.png" alt="image.png"></p><p>别急，我们先来分解一下接雨水的三种情况，然后你就知道上面这个俄罗斯方块的面积是怎么算出来的了。</p><hr><p>和739题目一样，接雨水需要一个从栈顶到栈底单调递增的栈，存放的是下标。因为我们需要通过下标相减得出凹槽的宽度，高度可以直接通过下标访问原数组得到。</p><p>每次判断的时候有三种情况：</p><ul><li>当前遍历的元素<strong>小于</strong>栈顶元素，入栈；</li><li>当前遍历的元素<strong>大于</strong>栈顶元素，开始比较和计算凹槽的面积；<ul><li>取栈顶元素作为凹槽底部高度，并弹出栈顶元素；</li><li>栈的第二个元素作为凹槽左侧边界，<strong>该元素不能弹出</strong>；</li><li>凹槽的高度：<code>min(左侧边界,当前元素为右侧边界) - 凹槽底部高度</code>；</li><li>凹槽的宽度：<code>当前下标 - 左边界下标 - 1</code>；</li><li>通过高度和宽度相乘计算出雨水面积，加到结果中；</li><li>这里需要注意，刚开始的时候栈里面只有一个元素，所以我们在取了栈顶元素之后还需要<strong>判断栈里面是否有其他元素才能继续取左侧边界</strong>。可能会出现有一个高度柱没有左边界构成不了凹槽的情况（题目的示例一就是这种情况，左侧和坐标边界是不算数的，装不了雨水）；</li><li>这是一个循环<code>while (!st.empty() &amp;&amp; height[i] &gt; height[st.top()])</code>，一直到当前元素不大于栈顶元素或栈为空了才退出循环，和739题目是一样的。</li></ul></li><li>当前遍历的元素<strong>等于</strong>栈顶元素，将栈顶元素弹出后将当前元素下标入栈；</li></ul><p>当前元素大于栈顶元素的情况已经写清楚了，来看看为啥当前元素等于栈顶元素的时候需要将栈顶元素弹出再入当前元素的下标。</p><p>见下图，当我们遍历到第二个高度为4的柱子的时候，栈顶元素就是第一个高度为4的柱子，此时这两个柱子之间是没有凹槽的，装不了雨水，后续我们要计算凹槽宽度的时候，也应该拿第二个高度为4的柱子来计算，通过下标计算宽度<code>3-1-1=1</code>，如果用第一个高度为4的柱子计算，宽度就会多一位，计算出来的体积就不对了。</p><p>所以，当我们遍历到下标1的时候，栈顶元素和当前遍历元素相同，需要把栈顶的下标0弹出，入新的下标1，才能让后续计算得到正确的结果。</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/08/a3646429ad600ad3a750d1901405b52b.png" alt="image.png"></p><p>另外再根据思路解释一下为什么取出左边界后不能将这个元素出栈吧。见示例一的图，我给他标出了下标。</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/08/cb803c3c21e81d9ec58c07ff7b6bb04a.png" alt="image.png"></p><p>当我们遍历到下标6的时候，当前元素的高度大于栈顶元素，需要开始计算体积了，此时操作如下</p><ul><li>取栈顶元素（下标5）作为凹槽底部，高度为0，下标5出栈；</li><li>取栈顶元素（下标4）作为凹槽左侧，高度为1；</li><li>高度：<code>min(height[4],height[6]) - height[5] = 1</code>;</li><li>宽度：<code>6 - 4 - 1 = 1</code>；</li><li>面积：<code>1 * 1 = 1</code>；</li></ul><p>此时一次计算就完成了，算是这这个俄罗斯方块的凸出来的那一部分。注意我们取出来的凹槽左侧高度（下标4）这个元素还是当前单调栈的栈顶，<strong>这个元素是不能出栈的</strong>，来看看下一次循环中的遍历会做什么吧！</p><p>首先是进入了“当前元素大于栈顶元素”这个if条件里面的while循环，此时当前元素已经不大于栈顶元素了（和栈顶元素相同），会终止这个循环，并将当前元素（下标6）入栈。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (!st.<span class="built_in">empty</span>() &amp;&amp; height[i] &gt; height[st.<span class="built_in">top</span>()])</span><br></pre></td></tr></table></figure><p>下一次遍历，下标7的高度是3，大于栈顶元素，再次命中“当前元素大于栈顶元素”的if条件，进入循环内：</p><ul><li>取栈顶元素（下标6）作为凹槽底部，高度为1，下标6出栈；</li><li>取栈顶元素（下标4）作为凹槽左侧，高度为1；</li><li>高度：<code>min(height[4],height[7]) - height[6] = 0</code>;</li><li>宽度：<code>7 - 4 - 1 = 2</code>；</li><li>面积：<code>0 * 2 = 0</code>；</li></ul><p>实际上这几个元素是构成不了一个凹槽的，因为底部和左边界的高度一致，计算出来的结果和预期相同，面积是0。然后继续if里面的while循环：</p><ul><li>取栈顶元素（下标4）作为凹槽底部，高度为1，下标4出栈；</li><li>取栈顶元素（下标3）作为凹槽左侧，高度为2；</li><li>高度：<code>min(height[3],height[7]) - height[4] = 1</code>;</li><li>宽度：<code>7 - 3 - 1 = 3</code>；</li><li>面积：<code>3 * 1 = 3</code>；</li></ul><p>此时就能看出来为什么下标4不能出栈了。如果在while循环中将其出栈，到这里的循环就会错误的将下标3（高度为2）作为凹槽底部的高度，结果就大错特错啦！</p><p>执行到这里，我们就算出来了俄罗斯方块长的这<code>3 * 1</code>的雨水面积，整个俄罗斯方块就搞定啦。</p><h3 id="完整代码-3"><a href="#完整代码-3" class="headerlink" title="完整代码"></a>完整代码</h3><p>完整代码如下，里面部分注释用英文是因为我写OJ的时候喜欢切成ENG语言避免不小心按shift导致输入法换来换去，所以就干脆用三脚猫英语写注释了。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">trap</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; height)</span> </span>&#123;</span><br><span class="line">        stack&lt;<span class="type">int</span>&gt; st;</span><br><span class="line">        <span class="comment">// 栈里面存下标，栈顶到栈底单调递增</span></span><br><span class="line">        st.<span class="built_in">push</span>(<span class="number">0</span>);</span><br><span class="line">        <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">1</span>; i &lt; height.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="keyword">auto</span>&amp; cur = height[i];</span><br><span class="line">            <span class="comment">// 1.direct push to stack</span></span><br><span class="line">            <span class="keyword">if</span> (cur &lt; height[st.<span class="built_in">top</span>()]) &#123;</span><br><span class="line">                st.<span class="built_in">push</span>(i);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 2.replace index of top</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (cur == height[st.<span class="built_in">top</span>()]) &#123;</span><br><span class="line">                st.<span class="built_in">pop</span>();</span><br><span class="line">                st.<span class="built_in">push</span>(i);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 3.clac space of rain</span></span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">while</span> (!st.<span class="built_in">empty</span>() &amp;&amp; cur &gt; height[st.<span class="built_in">top</span>()]) &#123;</span><br><span class="line">                    <span class="type">int</span> bottomIndex = st.<span class="built_in">top</span>();</span><br><span class="line">                    st.<span class="built_in">pop</span>();</span><br><span class="line">                    <span class="comment">// 注意刚开始的时候可能只有一个元素</span></span><br><span class="line">                    <span class="keyword">if</span> (!st.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">                        <span class="type">int</span> leftIndex = st.<span class="built_in">top</span>();</span><br><span class="line">                        <span class="comment">// 错误！左边的元素不能被pop掉，因为它可能是下一个凹槽要用的底部值！</span></span><br><span class="line">                        <span class="comment">// st.pop();</span></span><br><span class="line">                        <span class="comment">// 计算凹槽高度和宽度</span></span><br><span class="line">                        <span class="type">int</span> h =</span><br><span class="line">                            <span class="built_in">min</span>(height[leftIndex], cur) - height[bottomIndex];</span><br><span class="line">                        <span class="type">int</span> w = i - leftIndex - <span class="number">1</span>;</span><br><span class="line">                        <span class="comment">// 雨水体积</span></span><br><span class="line">                        sum += h * w;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                st.<span class="built_in">push</span>(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/08/fcaca67d9ee036a0122f5e883f0c7034.png" alt="image.png"></p>]]></content>
    
    
    <summary type="html">leetcode刷题笔记，单调栈系列。</summary>
    
    
    
    <category term="编程学习" scheme="https://blog.musnow.top/categories/%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="把题目都给刷干净" scheme="https://blog.musnow.top/categories/%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0/%E6%8A%8A%E9%A2%98%E7%9B%AE%E9%83%BD%E7%BB%99%E5%88%B7%E5%B9%B2%E5%87%80/"/>
    
    
    <category term="OJ刷题" scheme="https://blog.musnow.top/tags/OJ%E5%88%B7%E9%A2%98/"/>
    
    <category term="leetcode" scheme="https://blog.musnow.top/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>【win】windows开启特定端口防火墙</title>
    <link href="https://blog.musnow.top/posts/2580738879/"/>
    <id>https://blog.musnow.top/posts/2580738879/</id>
    <published>2024-08-09T14:52:44.000Z</published>
    <updated>2024-09-05T23:11:50.000Z</updated>
    
    <content type="html"><![CDATA[<p>使用vmware的NAT模式的时候，如果想让局域网内的其他主机能访问你的虚拟机端口，需要做两个操作</p><ul><li>在vmware的虚拟网络编辑器中，开启宿主机端口到虚拟机端口的端口映射，这部分在安装虚拟机的教程里面有，本文不赘述；</li><li>在windows的防火墙里面，设置端口的出站和入站规则。注意，不建议直接关闭防火墙；</li></ul><p>如何确定是防火墙的问题？如果你在另外一台主机上，能ping通当前主机，但是没有办法访问你映射到宿主机的端口时，那就是被windows的防火墙拦住了。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh: connect to host 192.168.0.115 port 22: Connection timed out</span><br></pre></td></tr></table></figure><p>顺带一提，你可以在windows下用<code>ipconfig</code>命令查看当前主机的IP地址，在Linux系统中是使用<code>ifconfig</code>命令查看IP地址。</p><p>进入windows11的设置搜索防火墙，打开防火墙与网络防护。</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/08/6f4d6b8793ed89d96009dad0f257eb2e.png" alt="image.png"></p><p>一些教程会让你直接在这个页面关掉防火墙，不建议哦，我们只需要开启要用的端口就行了，关掉防火墙那就是100%裸奔了。不过家庭局域网一般也没有那么容易被入侵，问题也不算很大。但还是不建议完全关闭防火墙。</p><p>直接点高级设置</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/08/6c59d8431ebd757086f0732bc47f107a.png" alt="image.png"></p><p>在控制面板中有入站和出战规则，我们两个规则都需要添加一下，这里以入站规则为例（设置界面一模一样），点击入站规则，点击新建规则</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/08/e656910197f193ccc3ba7ac91bef26da.png" alt="image.png"></p><p>选择按端口号新建规则，协议按你需要的选，比如我需要SSH，选择TCP，设置为22<br>端口。</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/08/0cb22059fa94330a5e51d49bea74080f.png" alt="image.png"></p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/08/3a8ea9e81db457270a403a1edf076d46.png" alt="image.png"></p><p>选择允许连接</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/08/3e5b42fb3852f5e0e75cec3efb260569.png" alt="image.png"></p><p>这里会有网络类型，全勾上，因为windows下的网络类型就是一个薛定谔，哪怕是家庭局域网他可能也会认为是公用网络。</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/08/50dc98e53903ccce5e5bba73b6b7dcea.png" alt="image.png"></p><p>然后写个名称，点击确定就可以了。这样就配置好了。然后你还需要用相同的方式配置<strong>出站规则</strong>。</p><p>配置好了之后，在另外一台电脑上用这个windows主机的ip来ssh试试，能登录上就是OK了。</p>]]></content>
    
    
    <summary type="html">windows开启特定端口防火墙，实现虚拟机NAT端口可被局域网访问。</summary>
    
    
    
    <category term="差生文具多" scheme="https://blog.musnow.top/categories/%E5%B7%AE%E7%94%9F%E6%96%87%E5%85%B7%E5%A4%9A/"/>
    
    <category term="电脑使用小贴士" scheme="https://blog.musnow.top/categories/%E5%B7%AE%E7%94%9F%E6%96%87%E5%85%B7%E5%A4%9A/%E7%94%B5%E8%84%91%E4%BD%BF%E7%94%A8%E5%B0%8F%E8%B4%B4%E5%A3%AB/"/>
    
    
    <category term="windows" scheme="https://blog.musnow.top/tags/windows/"/>
    
    <category term="虚拟机" scheme="https://blog.musnow.top/tags/%E8%99%9A%E6%8B%9F%E6%9C%BA/"/>
    
  </entry>
  
  <entry>
    <title>【Docker】Linux系统以及威联通QNAP部署思源笔记的通用教程</title>
    <link href="https://blog.musnow.top/posts/3021867507/"/>
    <id>https://blog.musnow.top/posts/3021867507/</id>
    <published>2024-07-31T13:20:15.000Z</published>
    <updated>2024-08-24T00:41:11.000Z</updated>
    
    <content type="html"><![CDATA[<p>本文测试的是旧版本<code>v2.11.4</code>的部署方式，实测当前（2024.08.15）最新的<code>v3.1.3</code>版本也可以用相同的方式部署。本文的部署方式共写了三种，非qnap的linux系统也可以参考本文部署思源笔记。</p><p>阅读本文之前，先明确两个名词：</p><ul><li>“宿主机”指的是部署docker服务的主机，本文所述是qnap的nas本体；</li><li>“容器内”是思源docker容器内部的路径或端口；</li></ul><p>这是部署docker服务时最常遇到的两个描述，写在这里避免大家对基本概念不了解而导致的误操作。另外，<strong>强烈建议您在学习了docker容器化的基本配置逻辑和docker的基本技术概念之后</strong>，再去使用docker。这会对您理解和配置所有docker容器服务都会有很大的帮助！您可以阅读本站的<a href="https://blog.musnow.top/categories/%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0/docker%E5%AD%A6%E4%B9%A0/">编程学习&#x2F;docker学习</a>专栏，有任何问题都可评论区提出。</p><p>思源的论坛中隔三岔五就会有人因为不理解docker的配置几何导致出现种种问题，其中因为宿主机路径映射失败导致所有笔记文件丢失还不做备份的也不在少数！</p><h2 id="1-部署容器"><a href="#1-部署容器" class="headerlink" title="1. 部署容器"></a>1. 部署容器</h2><h3 id="1-1-在威联通container-station3上部署"><a href="#1-1-在威联通container-station3上部署" class="headerlink" title="1.1. 在威联通container-station3上部署"></a>1.1. 在威联通container-station3上部署</h3><p>这个版本是我从2024年年初一直用到现在的版本，没遇到过任何问题，个人感觉没有必要升级。如果你想部署其他版本，可以修改冒号右侧的版本号。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">b3log/siyuan:v2.11.4</span><br></pre></td></tr></table></figure><p>拉取镜像后，创建容器。这里我使用的是最新的<code>container station 3</code>。</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/07/89bb0a64866dbde8c8deec9d14194457.png" alt="image"></p><p>先配置容器的端口，主机端口设置为一个未被使用的端口即可，重启策略改成始终重启。</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/07/521b03293faba1531c3c187e2ad72ae7.png" alt="image"></p><p>添加存储映射，在nas上新建一个文件夹来存放思源笔记的数据。冒号左侧是你的qnap上的共享文件夹路径，必须新建一个文件夹作为宿主机路径进行映射。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/Public/docker/data/synote/data:/home/siyuan/sy</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/07/279d5efab3a78315d75e336d30286874.png" alt="image"></p><p>然后是修改启动命令，在命令中选择覆盖，然后键入如下内容。如果你的docker需要外网访问，则一定要把accessAuthCode密码设置的复杂一些！</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">--workspace=/home/siyuan/sy --lang=zh_CN --accessAuthCode=你的密码</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/07/b525a2b5f58d471c8fe4f57519207539.png" alt="image"></p><p>然后创建容器就可以了。</p><p>创建完毕容器一定要去检查日志，看工作空间有没有问题。如下所示，日志的路径中提到了<code>/home/siyuan/sy</code>，即代表当前使用的就是我们设置好的路径，那就是没有问题的。</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/07/f8ea69957b82b5254b0f40f9d5120c4a.png" alt="image"></p><p>包括检查本地的映射路径中是否有对应的文件，<strong>如果没有下面的这些文件，一定要去确认你的docker路径映射有没有问题</strong>！</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/07/d27e4dba576464a31db0b92cc41ec9cd.png" alt="image"></p><p>最终访问本地IP:端口，显示下面的内容，就是部署成功了。</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/07/0f1e778960259df896104336d53445d2.png" alt="image"></p><h3 id="1-2-使用docker-cli命令部署"><a href="#1-2-使用docker-cli命令部署" class="headerlink" title="1.2. 使用docker-cli命令部署"></a>1.2. 使用docker-cli命令部署</h3><p>使用docker命令部署参考如下设置，最新版本3.1.0也是一样的命令，我已经测试过了，修改镜像的tag就可以了。其中你可以修改的是<code>-v</code>选项冒号左侧的宿主机目录，以及<code>-p</code>选项后冒号左侧的宿主机端口号。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">sudo docker run -d \</span><br><span class="line">    --name siyuan \</span><br><span class="line">    -v 你需要绑定的宿主机目录:/home/siyuan/sy \</span><br><span class="line">    -p 你需要绑定的宿主机端口:6806 \</span><br><span class="line">    --restart=always \</span><br><span class="line">    b3log/siyuan:v2.11.4 \</span><br><span class="line">    --workspace=/home/siyuan/sy \</span><br><span class="line">    --lang=zh_CN \</span><br><span class="line">    --accessAuthCode=123456</span><br></pre></td></tr></table></figure><p>部署完毕后，一定要检查你绑定的宿主机目录下是否有文件！没有文件是有问题的！比如我使用<code>-v /home/wsl/synote/data:/home/siyuan/sy</code>命令创建了思源容器，此时<code>ls -l</code>查看宿主机该路径下会有如下文件，这才是正常情况。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">❯ ls -l /home/wsl/synote/data</span><br><span class="line">total 12K</span><br><span class="line">drwxr-xr-x  3 wsl wsl 4.0K May 25 18:23 conf</span><br><span class="line">drwxr-xr-x 11 wsl wsl 4.0K May 25 18:23 data</span><br><span class="line">drwxr-xr-x  4 wsl wsl 4.0K May 25 18:21 temp</span><br></pre></td></tr></table></figure><h3 id="1-3-使用docker-compose部署"><a href="#1-3-使用docker-compose部署" class="headerlink" title="1.3. 使用docker-compose部署"></a>1.3. 使用docker-compose部署</h3><p>在威联通container-station-3中支持docker-compose，就是界面中的<code>应用程序</code>这一栏。真的得吐槽一下qnap的国内翻译组，一股机翻的味道，你还不如不翻译，直接用stack或者docker-compose还更好让人理解一些，最开始我都不知道应用程序是嘛玩意，还以为container-station从2变成3后不支持docker-compose了。</p><p>这里给出qnap可以使用的<code>docker-compose.yml</code>，其实也是所有Linux通用的。</p><p>该yml文件的注意事项在注释里面提到了。其中volumes的配置一定要注意，我们在container-station-3里面可以选择我们的文件夹，但是这些我们创建的共享文件夹的绝对路径都是在<code>/share</code>下的，比如我的共享文件夹名称为Public，那么最终需要在docker-compose里面写的绝对路径就是<code>/share/Public</code>。如果你不注意这一点，直接从<code>/Public</code>开始写，就会发现无论如何配置，思源容器都无法启动，会提示权限不够。说白了还是宿主机目录映射错位置了。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">&#x27;3&#x27;</span></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="attr">siyuan_compose:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">b3log/siyuan:v2.11.4</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">siyuan-compose</span></span><br><span class="line">    <span class="attr">restart:</span> <span class="string">unless-stopped</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="attr">PGID:</span> <span class="number">1000</span></span><br><span class="line">      <span class="attr">PUID:</span> <span class="number">1000</span></span><br><span class="line">      <span class="attr">TZ:</span> <span class="string">&quot;Asia/Shanghai&quot;</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="comment"># 本地端口改冒号左边的。</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;20000:6806&quot;</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">  <span class="comment"># 本地映射路径改冒号左边的。</span></span><br><span class="line">      <span class="comment"># 注意qnap的docker-compose采用绝对路径，需要在前面加上/share才是共享文件夹！</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">/share/Public/docker/data/synote/data:/home/siyuan/sy</span> </span><br><span class="line">    <span class="comment"># 登录密码改最后一个accessAuthCode命令等号之后的，其他的别改。</span></span><br><span class="line">    <span class="attr">command:</span> [<span class="string">&quot;--workspace=/home/siyuan/sy&quot;</span>,<span class="string">&quot;--lang=zh_CN&quot;</span>,<span class="string">&quot;--accessAuthCode=123456&quot;</span>]</span><br><span class="line">    <span class="attr">stdin_open:</span> <span class="literal">true</span>  <span class="comment">## 相当于 -i</span></span><br><span class="line">    <span class="attr">tty:</span> <span class="literal">true</span>         <span class="comment">## 相当于 -t</span></span><br></pre></td></tr></table></figure><p>写进去后点击创建，即可创建思源容器。</p><p>请进入容器日志检查是否成功启动，以及进入本地映射的目录检查是否有文件！一定要检查一定要检查，不要等你到时候容器出问题了发现本地目录没有文件！</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/07/4ed6cee1bb9a4dc7df7ef80fb39c18f3.png" alt="image.png"></p><p>比如日志中不应该出现报错，工作空间路径和我们配置的一致，以及<code>/share/Public/docker/data/synote/data</code>路径下应该出现conf、data、temp等文件夹。</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/07/93d2bffd767f9c2e1c6e47a6b981024b.png" alt="image.png"></p><p>如果是其他Linux主机，将上述内容修改成你的配置之后，在你的linux主机上将上述内容写入一个<code>docker-compose.yml</code>文件，然后使用如下方式启动思源容器</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo docker-compose up -d</span><br></pre></td></tr></table></figure><p>如果提示<code>docker-compose</code>命令不存在，可以试试<code>docker compose</code>命令，如果还是提示不存在，则需要去安装<code>docker-compose</code>，本站有<a href="https://blog.musnow.top/posts/2069190154">相关博客</a>。</p><h2 id="2-如何设置镜像源？"><a href="#2-如何设置镜像源？" class="headerlink" title="2. 如何设置镜像源？"></a>2. 如何设置镜像源？</h2><blockquote><p>PS: 因为一些原因，各大服务商提供的公开docker镜像源都下架了，您可以尝试自建镜像源或百度一下目前仍然可用的免费公开镜像源。注意，目前可用的公开镜像源大多是互联网用户主动提供的，可能会存在安全风险！</p></blockquote><h3 id="2-1-contianer-station3如何添加镜像源？"><a href="#2-1-contianer-station3如何添加镜像源？" class="headerlink" title="2.1. contianer station3如何添加镜像源？"></a>2.1. contianer station3如何添加镜像源？</h3><p>默认情况下dockerhub的连通性并不是很好，可能没有办法pull镜像，所以需要设置docker的镜像源。</p><p>设置方法如下。</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/07/83f0747dbeb13c915db424c412de804a.png" alt="image"></p><p>点击添加存储库，提供商选择其他，然后URL是填镜像源的名称。</p><p>推荐使用南京大学的镜像<code>https://docker.nju.edu.cn</code>，速度不错。</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/07/21dc1ade931119c537a4021eb8046be3.png" alt="image"></p><p>填好了之后点击测试链接，成功就OK了，点击应用。</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/07/20b6b14c405a28ed8d0dc1bdbb0f8081.png" alt="image"></p><p>设置了之后，在映像中就可以使用这个镜像源来pull容器了。</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/07/bfa2ea010625c07c0586fdbd7397f4e7.png" alt="image"></p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/07/317689490c33f04ff4dcb8f548bd1247.png" alt="image"></p><p>不过没有办法通过镜像源来搜容器，自带的搜索只能使用dockerhub来pull镜像。每次需要镜像的时候，都得去找容器的镜像名字是什么，还是有点不方便。</p><h3 id="2-2-docker命令行如何添加镜像源？"><a href="#2-2-docker命令行如何添加镜像源？" class="headerlink" title="2.2. docker命令行如何添加镜像源？"></a>2.2. docker命令行如何添加镜像源？</h3><p>docker的命令行需要修改系统的配置来设置镜像源，对应的文件是<code>/etc/docker/daemon.json</code>。修改这个文件之前，建议先备份一份（如果原本有这个文件的话）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo <span class="built_in">cp</span> /etc/docker/daemon.json ./docker-daemon.json.bak</span><br></pre></td></tr></table></figure><p>然后使用nano或vim编辑器修改这个文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo vim /etc/docker/daemon.json</span><br></pre></td></tr></table></figure><p>往文件中复制粘贴如下内容</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line"> <span class="attr">&quot;registry-mirrors&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="string">&quot;https://docker.nju.edu.cn&quot;</span><span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>随后重启docker服务就可以了，如果无法重启docker服务，也可以直接重启整个主机。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo systemctl restart docker</span><br></pre></td></tr></table></figure><h2 id="3-部署思源后可能遇到的问题"><a href="#3-部署思源后可能遇到的问题" class="headerlink" title="3. 部署思源后可能遇到的问题"></a>3. 部署思源后可能遇到的问题</h2><h3 id="3-1-工作空间不一致问题"><a href="#3-1-工作空间不一致问题" class="headerlink" title="3.1. 工作空间不一致问题"></a>3.1. 工作空间不一致问题</h3><p>在下面的这个命令中，我们将使用<code>-v</code>命令映射的<strong>容器内的目录</strong>（冒号右侧）和<code>--workspace</code>的选项都设置为了<code>/home/siyuan/sy</code>。在部署的时候<strong>一定要确认二者的设置是一致的</strong>，否则思源会因为找不到容器内的目录，而采用默认的工作空间。<strong>相当于路径映射失败</strong>。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">docker run -d \</span><br><span class="line">    --name siyuan \</span><br><span class="line">    -v 你需要绑定的宿主机目录:/home/siyuan/sy \</span><br><span class="line">    -p 你需要绑定的宿主机端口:6806 \</span><br><span class="line">    --restart=always \</span><br><span class="line">    b3log/siyuan:v2.11.4 \</span><br><span class="line">    --workspace=/home/siyuan/sy \</span><br><span class="line">    --lang=zh_CN \</span><br><span class="line">    --accessAuthCode=123456</span><br></pre></td></tr></table></figure><p>对于不太了解docker机制的用户而言，此时删除了该容器，<strong>你的数据就很难找回来了</strong>！！这也是为什么前文一直强调，创建了容器后，要去检查自己的本地路径中是否有对应的文件。</p><p>比如你使用了如下映射，那么在创建容器后，<strong>一定、一定、一定</strong>要去宿主机本地的<code>/home/mu/synote</code>路径下检查是否多出了思源创建的文件！！！！验证方法很简单，你可以给思源单独创建一个新的文件夹，当思源容器启动后，这个文件夹里面多出了repo、data、temp等目录，那么就是映射成功了。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-v /home/mu/synote:/home/siyuan/sy</span><br></pre></td></tr></table></figure><p>如果没有出现新的目录，那就需要去检查思源容器日志，看看工作空间是否正常，以及宿主机目录是否有权限问题导致容器内无法访问。</p><h3 id="3-2-权限问题"><a href="#3-2-权限问题" class="headerlink" title="3.2. 权限问题"></a>3.2. 权限问题</h3><p>思源容器是使用1000用户来创建和访问文件的，所以如果你映射的宿主机路径无法被1000用户或用户组访问，此时日志中就会出现<code>Permission Deny</code>字眼，代表思源<strong>缺少权限</strong>，没有办法在你映射的工作空间中创建和访问文件。</p><p>你可以通过<code>docker logs</code>命令查看容器的日志。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker logs 思源容器名字</span><br></pre></td></tr></table></figure><p>下面是一个思源的日志，来源于<a href="https://ld246.com/article/1721820989275/comment/1721822535073#comments">社区帖子</a>。在这个日志中出现了<code>[lstat /root/document/fllsynote: permission denied]</code>的输出，代表当前思源没有办法访问<code>/root/document/fllsynote</code>这个路径，因为它是一个root用户的路径，权限组不是1000，无法被思源容器的1000用户组访问。</p><p>然后日志中的第二行输出的意思是，思源发现你提供的工作路径<code>/root/document/fllsynote</code>压根没有办法访问，不是个路径（因为思源没有权限访问），所以它会去使用默认的工作路径<code>/home/siyuan/SiYuan</code>。这个时候问题就来了，如果你没有去检查容器日志和本地文件，你会发现思源是正常启动且可以使用的，但它把你的笔记都写入了容器内部，如果后续你的docker出现问题或者你想升级思源镜像版本的时候，把当前容器删除了，<strong>数据就丢了</strong>！</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">fllsiyuan | W 2024/07/24 19:23:09 file.go:210: determines whether [/root/document/fllsynote] is a directory failed: [lstat /root/document/fllsynote: permission denied]</span><br><span class="line">fllsiyuan | W 2024/07/24 19:23:09 working.go:258: use the default workspace [/home/siyuan/SiYuan] since the specified workspace [/root/document/fllsynote] is not a dir</span><br></pre></td></tr></table></figure><p>考虑到真的有很多很多很多人压根没有备份的习惯（即便思源提供了非常方便的导出DATA备份方式），本文再三强调了检查本地映射路径是否有文件的重要性。</p><p>解决这个权限问题的办法有几种：</p><ol><li>不要使用root用户来操作docker命令，而是使用一个子用户+sudo的方式操作docker命令，因为子用户创建出来的文件夹权限是ok的。</li><li><strong>手动使用chown和chgrp命令将创建出来的宿主机文件夹用户组改成1000</strong>（推荐）。</li><li>对于qnap来说，第一个注册的非admin用户就是1000用户，你可以用第一个注册的用户来配置这里的docker容器，并设置映射到qnap的文件夹目录的可读可写权限。理论上也只有第一个注册的用户是默认的管理员，能使用container-station；</li></ol><p>针对第二点做个说明，chown命令是修改文件夹的所属用户，chgrp命令是修改文件夹的所属组。<code>-R</code>选项代表同时修改这个文件夹内部的子文件夹权限。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo <span class="built_in">chown</span> -R 1000 文件夹</span><br><span class="line">sudo <span class="built_in">chgrp</span> -R 1000 文件夹</span><br></pre></td></tr></table></figure><p>比如我使用了<code>-v /root/siyuan:/home/siyuan/sy</code>进行映射，此时我映射的宿主机目录是在root用户下，大概率是没有办法被容器内直接访问的。此时思源日志中就会出现<code>Permission Deny</code>错误</p><p>这样操作了之后，这个文件夹就可以被容器内访问了，不过你还是需要去检查日志或该文件夹判断是否成功。</p><p>还是那句话，创建了容器后，一定要去检查自己的本地路径中是否有对应的文件！</p><h2 id="4-写在最后"><a href="#4-写在最后" class="headerlink" title="4. 写在最后"></a>4. 写在最后</h2><p>不管你采用什么方式部署的容器，请一定要确认你映射的本地路径中有对应的文件！数据无价哦！</p><p>‍</p>]]></content>
    
    
    <summary type="html">Linux系统及威联通QNAP使用container-station-3或docker命令行部署思源笔记的通用教程。</summary>
    
    
    
    <category term="编程学习" scheme="https://blog.musnow.top/categories/%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="Docker真好玩" scheme="https://blog.musnow.top/categories/%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0/Docker%E7%9C%9F%E5%A5%BD%E7%8E%A9/"/>
    
    
    <category term="Docker" scheme="https://blog.musnow.top/tags/Docker/"/>
    
    <category term="思源笔记" scheme="https://blog.musnow.top/tags/%E6%80%9D%E6%BA%90%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>【Docker】以思源笔记为例，谈谈什么是端到端加密</title>
    <link href="https://blog.musnow.top/posts/1936212186/"/>
    <id>https://blog.musnow.top/posts/1936212186/</id>
    <published>2024-07-27T23:31:24.000Z</published>
    <updated>2024-08-24T00:41:14.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本文首发于 <a href="https://blog.musnow.top/">❄️慕雪的寒舍</a>。</p></blockquote><p>链滴（思源笔记社区）里面有不少老哥似乎不太了解思源使用的端到端加密功能，以及云同步功能背后的机制。本文将以思源笔记为例，谈谈什么是端到端加密，以及思源的同步功能中用到了什么计算机网络相关的技术。</p><h2 id="1-思源笔记如何进行跨设备同步？"><a href="#1-思源笔记如何进行跨设备同步？" class="headerlink" title="1. 思源笔记如何进行跨设备同步？"></a>1. 思源笔记如何进行跨设备同步？</h2><p>下面这张图比较直观的展示了思源笔记客户端是如何进行云端同步的。</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/07/16e335bfa9f613a7449e038713b6823a.png" alt="image.png"></p><p>这里假设设备A是第一个使用思源笔记的客户端，设备B是需要从设备A同步数据的客户端。举个栗子：设备A是一台电脑，用户在上面编辑笔记，且希望在自己的手机（设备B）上能访问、阅读自己的笔记。是非常常见的笔记软件使用场景。</p><p>为了让大家有个更清晰的认识，我们一步一步谈起，力求让不是程序员的朋友也能简单了解一下这个同步机制是怎么运作的。</p><h2 id="2-AES加密"><a href="#2-AES加密" class="headerlink" title="2. AES加密"></a>2. AES加密</h2><p>在描述思源采用的加密算法之前，先和大家明确一下加密、解密的概念：</p><ul><li>加密：通过一系列操作，将能被直接阅读的数据，加密成不可阅读的数据；</li><li>解密：通过一系列操作，从不可阅读的加密数据中，解密还原出原本的可读数据；</li><li>加密后的数据被称为密文，能被直接阅读的数据被称为明文。</li></ul><p>你可以百度一个<a href="https://www.toolhelper.cn/SymmetricEncryption/AES">在线AES加密网站</a>来试试加密和解密，如下图所示，我使用了一个随机的密钥对“你好”进行加密，得到的结果是<code>Oru2UtIlrV+qpmKudjZAxQ==</code>这串不知道是什么鬼的密文数据。这便是加密的作用。</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/07/e7440b424500b543ea6bacc57078e4a3.png" alt="image.png"></p><p>解密就是通过相同的密钥，将<code>Oru2UtIlrV+qpmKudjZAxQ==</code>这个鬼东西还原出“你好”的过程。</p><hr><p>思源笔记在启用云端同步之前，都会配置一个密钥。这个密钥是用于AES加密的，AES是目前广泛使用的一个加密算法，他是用于替代现在已不再可靠的DES加密算法的。</p><p>在AES加密算法没有被攻破之前，想解密被AES加密后的内容，只有一种方式，那便是暴力<strong>穷举</strong>加密时使用的密钥。</p><p>在《网络安全基础：应用与标准（白国强 译）》的AES章节中，会有下面这一张图，是穷举密钥需要用的时间。当使用128位（16字节，也就是长度为16的字符串）的密钥作为AES加密的输入时，就已经需要<code>10^17</code>年这个量级才能完成解密的，已经远远大于了这个数据有意义的时间了。</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/07/d88919ff7f5f69a2b7b708e3e5b91623.png" alt="image.png"></p><p>你想想，你今天偷到了一个机密资料，结果发现解密这个机密资料需要的时间，比地球他老人家的年龄都大，甚至比宇宙大爆炸到现在的时间都长，哪还有解密的必要？等暴力破解出来，这个资料早就没有参考价值了。这便是当下密码学算法希望达成的一个目标，即算法<strong>理论上</strong>能被暴力穷举破解出密钥，但穷举的耗时和成本（运算解密程序需要算力、电费、人力维护等等）会让做这件事毫无意义。</p><blockquote><p>关于这一点，在<a href="https://www.sdnlab.com/21145.html">暴力解决一切？破解AES也是妄想！</a>一文中有更详细的解释，本文不再拓展。</p></blockquote><h2 id="3-HTTPS和TLS-Verify"><a href="#3-HTTPS和TLS-Verify" class="headerlink" title="3. HTTPS和TLS Verify"></a>3. HTTPS和TLS Verify</h2><p>可能有老哥就想问了，既然AES加密算法那么牛逼，为啥只有思源笔记在云同步功能里面加上了这个东西，其他软件会使用AES加密吗？</p><p>当然也会了！现在互联网通信中最重要的也是最最常用的协议之一：HTTPS，背后就用到了TLS和AES加密。现在几乎所有APP、网站，背后都多少会用到HTTPS或者TLS来保障数据传输时的机密性。</p><p>当你访问一个HTTPS的网站时，以<code>https://www.baidu.com/</code>为例，TLS握手协议能保障你现在访问的服务器肯定是百度官方的服务器，而不是某个坏蛋设置的假冒服务器。TLS握手协议完成后，你的浏览器就会和百度的服务器协定一个共享密钥，并使用AES对称加密进行数据通信。最后在网络中流动的实际数据，比如你查询的一个关键词的结果，也已经是加密后的内容了。</p><p>这整个过程都是浏览器或者应用软件自行处理的，并不需要用户做额外的配置。</p><blockquote><p>HTTPS中会使用到的一个东西叫做SSL&#x2F;TLS证书，这是由<strong>可信CA</strong>颁发的用于验证服务器身份和进行密钥交换的必要组件，HTTPS可以避免中间人攻击正是靠证书实现的。如果你使用过nginx，或宝塔这类服务器管理面板，里面配置HTTPS部分一定会有一个证书的配置项。由于这部分的知识比较深奥，涉及环节较多，不太好对小白解释，本文跳过此知识点。</p></blockquote><p>细心的朋友可能会发现，在思源的云端配置中，也是有TLS Verify这个选项的，它的作用就是和提供S3&#x2F;WEBDAV服务的目标服务器进行身份验证。</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/07/558c4af5861174d3b18345a9ed04b164.png" alt="image.png"></p><p>TLS Verify在这里和Endpoint使用的HTTPS协议是绑定的。如果你使用了一个HTTP的Endpoint，即便开启TLS Verify也是没有意义的，因为HTTP协议是不包含TLS握手环节的。不过，现在很多服务器都会<strong>强制将HTTP的协议流量重定向到HTTPS</strong>。除非你本地不支持HTTPS和TLS协议，否则最终都会走HTTPS协议进行数据通信。</p><p>也就是说，如果你使用了一个HTTPS协议的Endpoint，也开启了TLS Verify，最终思源笔记和S3存储商之间的数据传输，其实是经过了<strong>两层加密</strong>的，一层是思源笔记本身配置的数据库加密密钥，另外一层是本地和S3&#x2F;WEBDAV服务器通信时使用的HTTPS协议。</p><p>如果某一个服务器使用的是自签名的证书来进行HTTPS传输，此时TLS Verify肯定会失败，因为服务器使用的证书并不是可信CA颁布的，当前主机认为这个证书不值得信任，在TLS握手的证书验证环节中会失败，从而拒绝连接。此时您可以把TLS Verify选项关闭，使用HTTP协议或者不可信的HTTPS协议继续传输数据，但我<strong>不建议这么做</strong>。虽然思源笔记本身数据就会有一层加密，但最终你和服务器之间的通信<strong>可能会被中间人窃取</strong>，从而获取到你使用的S3协议用户密钥等等信息，即便对方没有办法解密你的笔记内容，但是他人可以使用你的S3用户密钥去访问你使用的S3服务，从而获取到你的其他未加密信息。</p><p>不过，如果您是在局域网内使用nas上自建的minio、webdav服务，此时就不需要考虑HTTPS了，可以直接使用HTTP。除非您的局域网内有可以联网的设备被入侵了，才有可能被中间人攻击。当然，如果您的nas使用了ddns之类的方式暴露在公网上了，那就和上文所述的情况一致，得考虑中间人攻击问题了。</p><h2 id="4-同步到云端，从云端同步"><a href="#4-同步到云端，从云端同步" class="headerlink" title="4. 同步到云端，从云端同步"></a>4. 同步到云端，从云端同步</h2><p>现在我们已经知道了AES加密和HTTPS协议是怎么保障我们数据通信的机密性了，下面给大家阐述一下思源从设备A将数据同步到设备B会做的全流程操作。</p><ol><li>用户在<strong>设备A</strong>按下同步按钮，思源开始处理本地数据库数据，和云端已有数据进行对比，找出云端不存在的数据。</li><li>设备A的思源将这部分只有本地存在的数据使用配置好的<strong>数据库密钥K</strong>进行加密，并通过配置的S3&#x2F;WEBDAV协议上传至云端。这个过程中会涉及上文所述的HTTPS和TLS，但都是思源笔记客户端依照协议特性自动完成了所有操作，和用户配置的密钥K没有什么关系。</li><li>数据上传完毕，思源会校验云端数据是否和本地一致，以确认同步是否成功。</li><li>云端S3&#x2F;WEBDAV存储服务商存储的是已经加密过的用户笔记数据。</li><li>用户在<strong>设备B</strong>按下同步按钮，思源开始处理本地数据库数据，和云端已有数据进行对比，发现云端数据更新，存在云端有而本地没有的数据，并将这部分本地不存在的数据找出来。</li><li>设备B的思源从云端下载数据，并使用<strong>数据库密钥K</strong>对数据进行解密，还原出笔记内容。</li><li>下载完毕后，再次检查本地和云端数据快照，确认同步完成。</li></ol><p>其实思源笔记不能实时多设备同步的原因从这个流程就能看得出来。</p><ul><li>假设用户在设备A上写了新文档甲和新文档乙，按下同步按钮，设备A执行上传操作；</li><li>用户又在设备B按同步按钮，设备B执行下载操作；</li><li>此时就出现了两台设备都在访问云端仓库，而云端仓库中的数据还在不断的被A更新；</li><li>这就出现问题了！到时候B下载的数据要么是缺胳膊断腿的，要么是因为损坏无法被正常解密的无效数据，比如文档甲只下了一半的加密内容下来；</li><li>假设用户没有发现这个问题，有一天设备A上的某某文件丢失或者被误删了，用户打算从设备B上把数据全量同步到云，此时就会把设备B上可能存在损坏的文档甲和乙同步到云，从而导致文档甲和乙的数据丢失！</li></ul><p>所以，思源笔记使用的同步流程，就决定了它不能实现完全实时的同步，也不能在多台设备上同时操作同步。如果没记错的话，思源在同步之前会去锁定云端目录，保证同一时间只有同一个设备在上传&#x2F;下载云端数据，来避免另外一台设备触发同步操作而导致的数据一致性问题。</p><h2 id="The-end"><a href="#The-end" class="headerlink" title="The end"></a>The end</h2><p>那flowus、语雀是怎么实现在线编辑、实时同步和多用户协作编辑的呢？这就涉及到编程中多线程里面会涉及到的一个锁机制：乐观锁。</p><blockquote><p>不过这部分内容对于非程序员来说恐怕比HTTPS证书是怎么保证数据不被中间人窃取解释起来还要费劲，就不提啦！</p></blockquote><p>看完本文，不知道你对思源笔记的端到端加密同步功能是否有了一个更清晰的认识呢？如果文章有什么描述你没有看懂，或者大佬发现我的表述有误，都可以在评论区提出来。感谢大家的阅读！</p>]]></content>
    
    
    <summary type="html">以思源笔记为例，谈谈什么是端到端加密</summary>
    
    
    
    <category term="编程学习" scheme="https://blog.musnow.top/categories/%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="Docker真好玩" scheme="https://blog.musnow.top/categories/%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0/Docker%E7%9C%9F%E5%A5%BD%E7%8E%A9/"/>
    
    
    <category term="计算机网络" scheme="https://blog.musnow.top/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    <category term="http" scheme="https://blog.musnow.top/tags/http/"/>
    
    <category term="Docker" scheme="https://blog.musnow.top/tags/Docker/"/>
    
    <category term="思源笔记" scheme="https://blog.musnow.top/tags/%E6%80%9D%E6%BA%90%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>【C语言】字符串 | 回顾C语言005</title>
    <link href="https://blog.musnow.top/posts/321211845/"/>
    <id>https://blog.musnow.top/posts/321211845/</id>
    <published>2024-07-27T22:07:48.000Z</published>
    <updated>2024-08-22T22:41:06.000Z</updated>
    
    <content type="html"><![CDATA[<p>字符串，就是一长串的字符类型，每一个位上都是一个单独的char字符，连起来组合成了字符串。</p><p>你在各个客户端&#x2F;网页里面看到的文字，在编程语言中都可以认为是一个<strong>字符串</strong>。</p><p>在C语言中，字符串对应的是<code>const char*</code>和<code>char*</code>类型；其本质上是一个<strong>char字符数组</strong>。</p><h2 id="1-常量字符串"><a href="#1-常量字符串" class="headerlink" title="1.常量字符串"></a>1.常量字符串</h2><p>常量字符串的类型是<code>const char*</code>，我们直接使用的<code>&quot;字符串&quot;</code>，就是常量字符串。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">char</span>* str = <span class="string">&quot;hello world&quot;</span>; <span class="comment">// 常量字符串</span></span><br></pre></td></tr></table></figure><p>常量字符串<strong>不能被修改</strong>，但可以像数组一样通过下标和指针的方式访问字符串的单个字符</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">char</span>* str = <span class="string">&quot;hello world&quot;</span>; <span class="comment">// 常量字符串</span></span><br><span class="line"><span class="type">char</span> c1 = str[<span class="number">0</span>];  <span class="comment">// 访问字符h</span></span><br><span class="line"><span class="type">char</span> c2 = (*str+<span class="number">4</span>); <span class="comment">// 访问字符o</span></span><br></pre></td></tr></table></figure><p>而没有const修饰的<code>char*</code>类型，是不能直接接受常量字符串赋值的</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span>* str = <span class="string">&quot;hello world&quot;</span>; <span class="comment">// 无法接受常量字符串，这行代码有误</span></span><br></pre></td></tr></table></figure><p>虽然这行代码在VS2019中没有报错，在Linux下的g++也仅仅是报了warning警告，但其本质是<strong>有问题</strong>的！</p><p>下面的文字就是Linux下g++编译时的警告，翻译过来是禁止将<strong>常量字符串</strong>转换为<code>char *</code>类型。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ g++ test.cpp -o test</span><br><span class="line">test.cpp: In function ‘int main()’:</span><br><span class="line">test.cpp:137:17: warning: ISO C++ forbids converting a string constant to ‘char*’ [-Wwrite-strings]</span><br><span class="line">     char *str = &quot;hello world\n&quot;; // 无法接受常量字符串</span><br><span class="line">                 ^~~~~~~~~~~~~~~</span><br></pre></td></tr></table></figure><h2 id="2-普通字符串"><a href="#2-普通字符串" class="headerlink" title="2.普通字符串"></a>2.普通字符串</h2><p>前面提到，字符串就是一个字符的数组。但我们想定义一个字符串<strong>数组</strong>，也不能用<code>char*</code>，而需要用另外一种方式。</p><p>下面这种在变量名后带<code>[]</code>的写法，就是定义<strong>数组</strong>的语法，在前文已经介绍过了。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> str[] = <span class="string">&quot;hello world&quot;</span>; <span class="comment">// 普通字符串的基本定义方式</span></span><br></pre></td></tr></table></figure><p>上方是声明时赋值的写法，编译器在识别到这一行代码后，会自动帮我们创建字符串对应大小的空间，并让str指向这片空间的起始地址。</p><p>需要注意的是，只有初始化的时候能这么写。后续如果想修改这个字符串，需要使用strcpy函数，而不能用&#x3D;直接赋值。strcpy函数会在后文介绍。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> str[] = <span class="string">&quot;hello world&quot;</span>;</span><br><span class="line">str = <span class="string">&quot;hello&quot;</span>; <span class="comment">//错误，不能通过=直接修改</span></span><br><span class="line"><span class="built_in">strcpy</span>(str,<span class="string">&quot;hello&quot;</span>); <span class="comment">// 正确修改方式</span></span><br></pre></td></tr></table></figure><blockquote><p>这里的str变量本质上是<code>char*</code>类型，是一个字符指针。所有数组变量都是对应类型的指针。</p></blockquote><p>如果想在声明时不赋初值，可以用下面的办法来定义一个字符串。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> str1[<span class="number">15</span>];  <span class="comment">// 定义一个长度为15的字符串数组</span></span><br><span class="line">str1[<span class="number">0</span>] = <span class="string">&#x27;h&#x27;</span>;  <span class="comment">// 通过下标访问的方式赋值</span></span><br><span class="line">str1[<span class="number">1</span>] = <span class="string">&#x27;e&#x27;</span>;</span><br><span class="line">str1[<span class="number">2</span>] = <span class="string">&#x27;l&#x27;</span>;</span><br><span class="line">str1[<span class="number">3</span>] = <span class="string">&#x27;l&#x27;</span>;</span><br><span class="line">str1[<span class="number">4</span>] = <span class="string">&#x27;o&#x27;</span>;</span><br><span class="line">str1[<span class="number">5</span>] = <span class="string">&#x27;\0&#x27;</span>; <span class="comment">// 最后需要加上字符串的结束标志</span></span><br><span class="line"><span class="built_in">printf</span>(str1);  <span class="comment">// 打印字符串</span></span><br></pre></td></tr></table></figure><p>运行结果如下，成功打印出hello字符串。</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/07/8e7656db84608af3560cd242027d9527.png"></p><h3 id="2-1-字符串结束标志-0"><a href="#2-1-字符串结束标志-0" class="headerlink" title="2.1 字符串结束标志\0"></a>2.1 字符串结束标志\0</h3><p>请注意，所有字符串数组最后都会带上一个隐藏的<code>&#39;\0&#39;</code>作为字符串的结束标志，该结束标志也需要占用一个字节的空间。</p><p>如果缺少了这个结束标志，那么程序就无法确定字符串什么时候结束，字符串就不完整了。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> str4[] = <span class="string">&quot;hello world&quot;</span>; <span class="comment">// 该字符串末尾会自动带上一个\0</span></span><br><span class="line">str4[<span class="number">11</span>] = <span class="string">&#x27;a&#x27;</span>; <span class="comment">// 尝试删掉最末尾的\0，看看会发生什么？</span></span><br><span class="line"><span class="built_in">printf</span>(str4);  <span class="comment">// 打印字符串</span></span><br></pre></td></tr></table></figure><p>可以看到，原本应该打印完毕 <code>hello worlda</code>就停止的程序，却继续往后打印了非常“经典”的乱码字符<code>烫烫</code>🤣。这也是初学者经常遇到的错误之一。这就是缺少<code>\0</code>结束标志的后果。</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/07/9884e40a6ed20e33ceeec7c3bdb35f9e.png"></p><p>可能又有初学者在这里会犯第二个错误：越界访问。</p><blockquote><p>在数组章节中，我们已经介绍过越界访问的概念。访问了不属于用户的数组空间就是越界访问。</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> str4[] = <span class="string">&quot;hello world&quot;</span>; <span class="comment">// 该字符串末尾会自动带上一个\0</span></span><br><span class="line">str4[<span class="number">11</span>] = <span class="string">&#x27;a&#x27;</span>; <span class="comment">// 尝试删掉最末尾的\0</span></span><br><span class="line">str4[<span class="number">12</span>] = <span class="string">&#x27;\0&#x27;</span>;<span class="comment">// 既然删掉了，我给他加上一个不就行了？</span></span><br><span class="line"><span class="built_in">printf</span>(str4);  <span class="comment">// 打印字符串</span></span><br></pre></td></tr></table></figure><p>但实际上，我们的str4字符串，在定义的时候赋值了<code>&quot;hello world&quot;</code>，这个字符串的长度是12。分别是可见的<code>hello world</code>一共11个字符（空格也算入字符中），和末尾隐藏的<code>\0</code>字符。</p><p>编译器会自动为我们开长度12的char数组，即等价于<code>char str4[12] = &quot;hello world&quot;;</code></p><p>数组<code>[]</code>里面的数字是通过<strong>下标</strong>访问的，<strong>下标是从0开始的</strong>，数组中的第一位的下标是0。所以，<code>str4[11]</code>访问的实际上是第十二个位置的<code>\0</code>，而<code>str4[12]</code>访问的数组的第十三个位置，该位置的空间实际上并不属于我们，此时的访问就是<strong>越界访问</strong>了！</p><p>在windows下，这份代码会因为错误提前退出；在linux下，运行会报段错误；</p><p>下图中就是windows下异常退出的情况，可以看到进程退出代码是<strong>负数</strong>，而且最后一行的<code>printf</code>也并没有打印出结果，这是因为代码在下图第24行中的<code>str4[12] = &#39;\0&#39;;</code>就已经因为越界访问提前异常退出程序了。</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/07/5bd424adf0fb711d2c68b0635ecf8e9f.png"></p><p>正常程序中，如果运行正常，程序终止后的退出代码应该是0；非零值都代表运行出错！</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/07/3d5bd309b5cc469a4508df0c026f8f05.png"></p><h3 id="2-2-strcpy函数"><a href="#2-2-strcpy函数" class="headerlink" title="2.2 strcpy函数"></a>2.2 strcpy函数</h3><p>除了一个一个通过下标访问的方式来赋值外，还可以用库函数strcpy，<a href="https://legacy.cplusplus.com/reference/cstring/strcpy/?kw=strcpy">点我查看文档</a></p><p>strcpy函数的使用比较简单，只有两个参数，分别是源字符串和目标字符串。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">char</span> * <span class="title">strcpy</span> <span class="params">( <span class="type">char</span> * destination, <span class="type">const</span> <span class="type">char</span> * source )</span></span>;</span><br></pre></td></tr></table></figure><p>该函数有几点说明:</p><ul><li>拷贝的时候，会把源字符串末尾的<code>\0</code>也拷贝过去；</li><li>目标字符串所能容纳的长度必须大于源字符串（长度要包括<code>\0</code>），否则会有越界访问；</li><li>返回值是目标字符串的指针，即返回<code>destination</code>；</li></ul><p>在当前场景中，我们可以用下面的方式使用strcpy，只要保证我们自己设定的字符数组空间大于源字符串即可。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> str5[<span class="number">15</span>]; <span class="comment">// 定义一个长度为15的字符串数组</span></span><br><span class="line"><span class="built_in">strcpy</span>(str5,<span class="string">&quot;hello world&quot;</span>); <span class="comment">// 使用strcpy函数，拷贝数据过去</span></span><br></pre></td></tr></table></figure><h3 id="2-3-为什么会打印乱码字符？"><a href="#2-3-为什么会打印乱码字符？" class="headerlink" title="2.3 为什么会打印乱码字符？"></a>2.3 为什么会打印乱码字符？</h3><p>前文中的这份代码，我们将原有的<code>&#39;\0&#39;</code>截止字符替换掉后，因为没有结束标志，printf函数就会一直往后打印，于是就出现了一些常见越界访问和未定义空间才会出现的生僻汉字。</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/07/9884e40a6ed20e33ceeec7c3bdb35f9e.png"></p><blockquote><p>你可能会疑惑，理论上后续的空间是没有人使用的空间，那为什么会打印出这些不知道哪里冒出来的字符呢？那最后又为什么停止了？</p></blockquote><p>其实这个问题的答案很简单：在一个程序中，所有<strong>未使用的内存空间</strong>，内部都存放的是<strong>随机值</strong>。这些随机值组合起来，和GBK&#x2F;UTF-8这类<strong>文字编码</strong>的部分编码对应，就会打印出这些生僻字，也就是网络上俗称的“乱码字符”。</p><blockquote><p>所谓“文字编码”，就是将语言里面的文字转为机器可识别的二进制的一个转换表。ASCII码就是一个文字编码表，但其内部只包含了英语字母和部分符号的转换，于是就会有各类的文字编码，将各国语言以规定的格式转换成机器可以识别的二进制。比较常用的文字编码是UTF-8；</p></blockquote><p>至于为什么会停止？回到ASCII码表上，查表可知，<code>&#39;\0&#39;</code>字符对应的<strong>十进制是0</strong>。</p><p>也就是说，只要我们原本定义的字符串，后续的内存空间中出现了一个<strong>随机值为0</strong>的位置，那么printf打印到这里就会把他当作截止标志，停止打印了。</p><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>对字符串的介绍到这里就over了。总结一下，字符串中最需要关注的两个问题：</p><ul><li>字符串（字符数组）的空间长度，注意不要越界访问；</li><li>末尾的这个<code>&#39;\0&#39;</code>一定不能漏，否则没有结束标志了。</li></ul><p>在OJ刷题中，经常会有拼接字符串相关的题目，如果字符串结束标志控制不到位，就容易把自己弄进一个很难找到的混乱BUG中。说多了都是泪，后续等你开始OJ刷题了，就知道慕雪所言何物了。</p>]]></content>
    
    
    <summary type="html">C语言的字符串</summary>
    
    
    
    <category term="编程学习" scheme="https://blog.musnow.top/categories/%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="回顾C和Cpp" scheme="https://blog.musnow.top/categories/%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0/%E5%9B%9E%E9%A1%BEC%E5%92%8CCpp/"/>
    
    
    <category term="C语言" scheme="https://blog.musnow.top/tags/C%E8%AF%AD%E8%A8%80/"/>
    
    <category term="回顾C和Cpp" scheme="https://blog.musnow.top/tags/%E5%9B%9E%E9%A1%BEC%E5%92%8CCpp/"/>
    
  </entry>
  
  <entry>
    <title>【C语言】何为数组？| 回顾C语言004</title>
    <link href="https://blog.musnow.top/posts/3142768460/"/>
    <id>https://blog.musnow.top/posts/3142768460/</id>
    <published>2024-07-27T21:59:59.000Z</published>
    <updated>2024-08-22T22:41:18.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-何为数组？"><a href="#1-何为数组？" class="headerlink" title="1.何为数组？"></a>1.何为数组？</h2><p>数，代表数据；组，代表小组、集合。</p><p>数组，就是<strong>一堆数据的集合</strong>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span> <span class="comment">// 一个数据</span></span><br><span class="line">&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125; <span class="comment">// 一个数组（数据的集合）</span></span><br></pre></td></tr></table></figure><p>上面的<code>&#123;1,2,3,4&#125;</code>，就是一个<code>int</code>类型的数组。</p><h2 id="2-数组定义语法"><a href="#2-数组定义语法" class="headerlink" title="2.数组定义语法"></a>2.数组定义语法</h2><p>数组的声明语法如下，在变量名后带上中括号<code>[]</code>，即代表这是一个数组。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">类型名 数组名[数组长度]; // 声明一个对应类型的数组</span><br></pre></td></tr></table></figure><p>下面是几个数组声明的例子</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> arr1[<span class="number">10</span>];    <span class="comment">// 声明一个能存放10个int类型的整形数组</span></span><br><span class="line"><span class="type">char</span> arr2[<span class="number">20</span>];   <span class="comment">// 声明一个能存放20个char类型的字符数组</span></span><br><span class="line"><span class="type">double</span> arr3[<span class="number">30</span>]; <span class="comment">// 声明一个能存放30个double类型的浮点数数组</span></span><br></pre></td></tr></table></figure><p>除了上方的方式，在声明数组的时候，我们还可以不带中括号中的数字，让操作系统根据我们的赋值来自动初始化对应长度的空间；</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 编译器会自动创建一个能存放4个int类型的数组，等价于int arr4[4]</span></span><br><span class="line"><span class="type">int</span> arr4[] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125;;</span><br><span class="line"><span class="comment">// 编译器会自动创建一个能存放6个char类型的数组，等价于char arr5[6]</span></span><br><span class="line"><span class="type">char</span> arr5[] = <span class="string">&quot;hello&quot;</span>; <span class="comment">// 这里末尾还有一个隐藏的\0，会在字符串章节详解</span></span><br><span class="line"><span class="comment">// 编译器会自动创建一个能存放3个float类型的数组，等价于float arr6[6]</span></span><br><span class="line"><span class="type">float</span> arr6[] = &#123;<span class="number">1.2</span>,<span class="number">3.4</span>,<span class="number">5.4</span>&#125;;</span><br></pre></td></tr></table></figure><p>另外，我们还能带上中括号中的长度数字，再赋值一部分，或完全赋值；</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> arr7[<span class="number">10</span>] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;  <span class="comment">// 只初始化5个数字</span></span><br></pre></td></tr></table></figure><p>需要注意的是，这里相当于只初始化了前5个值，此时后5个空间是未初始化的，存放的是<strong>随机值</strong>（也有编译器会优化为存放0，比如VS2019就会将后续未赋值的空间初始化为0）</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/07/1b1b150568107d941b16289b01d3eea4.png"></p><h2 id="3-数组的访问"><a href="#3-数组的访问" class="headerlink" title="3.数组的访问"></a>3.数组的访问</h2><p>有了数组后，我们应该如何访问数组中的成员呢？</p><h3 id="3-1-数组下标"><a href="#3-1-数组下标" class="headerlink" title="3.1 数组下标"></a>3.1 数组下标</h3><p>答案是通过<strong>数组下标</strong>的方式来访问。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">类型名 数组名[数组长度]; // 声明数组</span><br><span class="line">数组名[数组下标]; // 下标访问数组成员</span><br></pre></td></tr></table></figure><p>所谓数组下标，其实就是对应数据在数组中的位置。下标从<strong>零</strong>开始，最大值是<strong>数组长度-1</strong>；</p><p>长度为5的数组，下标范围是0到4；长度为10的数组，下标范围是0到9；</p><p>比如下面的数组，假设我们想访问第7位的数据，就需要用下标6访问；想访问第十位的数据，就要用下标9来访问；</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> arr8[<span class="number">10</span>] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>&#125;;</span><br><span class="line"><span class="type">int</span> a1 = arr8[<span class="number">5</span>]; <span class="comment">// 访问第六位的数据</span></span><br><span class="line"><span class="type">int</span> a2 = arr8[<span class="number">9</span>]; <span class="comment">// 访问第十位的数据</span></span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/07/933d5328a4a42dfa9831b49d8e52e466.png"></p><p>而下标10就已经是<strong>越界访问</strong>了，因为下标10对应的是<strong>第十一位</strong>，而这份空间并不属于我们开辟的这个数组。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> arr8[<span class="number">10</span>] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>&#125;;</span><br><span class="line"><span class="type">int</span> a3 = arr8[<span class="number">10</span>]; <span class="comment">// 错误！下标10对应第十一位，越界了！</span></span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/07/2a82e33d3a5fe9b202830e8002af4794.png"></p><h3 id="3-2-越界访问"><a href="#3-2-越界访问" class="headerlink" title="3.2 越界访问"></a>3.2 越界访问</h3><p>所谓<strong>越界访问</strong>，就是访问了数组中不属于用户自己的空间。是一种BUG。</p><p>比如用户定义了一个长度为5的数组，却尝试访问第10个元素，就会出现越界访问。<strong>这是新手常犯的错误之一，下标控制也是C语言中比较麻烦的一环，大家需要注意</strong>。</p><p>不同编译器对越界访问的检查也是不确定的，部分编译器能做到检测到越界访问后发出警告，比如VS2019。有些程序在运行到越界访问地方之时，会发生<strong>段错误</strong>（段错误即访问未定义和不属于用户自己的值）</p><h3 id="3-3-通过指针访问数组"><a href="#3-3-通过指针访问数组" class="headerlink" title="3.3 通过指针访问数组"></a>3.3 通过指针访问数组</h3><p>所有<strong>数组</strong>变量的本质，其实都是对应数据类型的<strong>一级指针</strong>；</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// arr9就是一个int*的一级指针</span></span><br><span class="line"><span class="type">int</span> arr9[<span class="number">10</span>] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>&#125;;</span><br></pre></td></tr></table></figure><p>既然是指针，我们就可以通过指针的解引用方式来访问数组中的元素。实际上的<code>[]</code>下标访问，也会被编译器自动转成下面的指针访问形式来访问数组中的元素。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a = (*arr9); <span class="comment">// 等价于 arr9[0]</span></span><br><span class="line"><span class="type">int</span> b = (*(arr9+<span class="number">1</span>)); <span class="comment">// 等价于 arr9[1]</span></span><br><span class="line"><span class="comment">// 以此类推...</span></span><br><span class="line"><span class="type">int</span> c = (*(arr9+<span class="number">9</span>)); <span class="comment">// 等价于 arr9[9]</span></span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/07/a74949671b38c7b9588f6bf221b544c2.png"></p><h2 id="4-多维数组"><a href="#4-多维数组" class="headerlink" title="4.多维数组"></a>4.多维数组</h2><p>数组本质上是指针，指针分为一级和二级，数组也有一维和多维</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> arr10[<span class="number">10</span>]; <span class="comment">// 一维数组</span></span><br><span class="line"><span class="type">int</span> arr11[<span class="number">10</span>][<span class="number">10</span>]; <span class="comment">// 二维数组，一个10x10的矩阵</span></span><br><span class="line"><span class="type">int</span> arr12[<span class="number">10</span>][<span class="number">10</span>][<span class="number">10</span>]; <span class="comment">// 三维数组</span></span><br><span class="line"><span class="comment">// 依此类推...</span></span><br></pre></td></tr></table></figure><p>多维数组的访问方式，和一维数组是相同的，比如如下代码访问的就是数组中第二行第三列的数据</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> k1 = arr11[<span class="number">1</span>][<span class="number">2</span>]; <span class="comment">// 下标访问，第二行第三列</span></span><br></pre></td></tr></table></figure><p>如果想用指针来访问多维数组，需要注意<strong>操作符的优先级</strong>问题，作为初学者，我们先用括号来括起来以避免优先级问题。这里可能有点绕，后续指针章节会讲解指针的寻址方式，到时候大家就能理解下面这行代码的深层含义了。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> k2 = *(*(arr11+<span class="number">1</span>)+<span class="number">2</span>); <span class="comment">// 指针访问，第二行第三列</span></span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/07/5c48901f79fa3ad576f14cc59ca268de.png"></p>]]></content>
    
    
    <summary type="html">认识一下C语言的数组</summary>
    
    
    
    <category term="编程学习" scheme="https://blog.musnow.top/categories/%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="回顾C和Cpp" scheme="https://blog.musnow.top/categories/%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0/%E5%9B%9E%E9%A1%BEC%E5%92%8CCpp/"/>
    
    
    <category term="C语言" scheme="https://blog.musnow.top/tags/C%E8%AF%AD%E8%A8%80/"/>
    
    <category term="回顾C和Cpp" scheme="https://blog.musnow.top/tags/%E5%9B%9E%E9%A1%BEC%E5%92%8CCpp/"/>
    
  </entry>
  
  <entry>
    <title>【C语言】变量和数据类型 | 回顾C语言003</title>
    <link href="https://blog.musnow.top/posts/4094051573/"/>
    <id>https://blog.musnow.top/posts/4094051573/</id>
    <published>2024-07-27T21:53:34.000Z</published>
    <updated>2024-08-22T22:41:40.000Z</updated>
    
    <content type="html"><![CDATA[<p>前面我们已经见识过一个简单的完整C语言程序了，下面让我们来认识一下如何在C语言中定义变量，以及C语言中存在哪些数据类型吧！</p><p>前置知识：计算机中都是用二进制0和1来存放数据的。我们把一个二进制位称作一个比特或比特位，<code>1字节=8比特</code>；</p><h2 id="1-定义变量"><a href="#1-定义变量" class="headerlink" title="1.定义变量"></a>1.定义变量</h2><p>基本语法如下，和我们日常语言认知中的赋值是一样的思维逻辑。只不过在编程语言中，我们定义一个变量需要告诉编译器它是什么数据类型的。这也是C&#x2F;C++作为强类型语言的特性之一（变量的数据类型固定，不可以修改数据类型）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">数据类型 变量名1 = 初始值; // 声明并赋值（声明并定义）</span><br><span class="line">数据类型 变量名2; // 只声明，不赋值（声明和定义分离）</span><br><span class="line">变量名2 = 参数值; // 给变量2赋值</span><br></pre></td></tr></table></figure><p>下面给出对应的示例</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">10</span>;  <span class="comment">// 声明并赋值</span></span><br><span class="line"><span class="type">int</span> b;  <span class="comment">// 只声明，不赋值</span></span><br><span class="line">b = <span class="number">20</span>; <span class="comment">// 给变量赋值</span></span><br></pre></td></tr></table></figure><h2 id="2-数据类型"><a href="#2-数据类型" class="headerlink" title="2.数据类型"></a>2.数据类型</h2><p>C语言支持的数据类型如下</p><h3 id="2-1-整形"><a href="#2-1-整形" class="headerlink" title="2.1 整形"></a>2.1 整形</h3><table><thead><tr><th>类型</th><th>存储大小</th><th>值范围</th></tr></thead><tbody><tr><td>char</td><td>1 字节</td><td>-128 到 127 <strong>或</strong> 0 到 255</td></tr><tr><td>unsigned char</td><td>1 字节</td><td>0 到 255</td></tr><tr><td>signed char</td><td>1 字节</td><td>-128 到 127</td></tr><tr><td>int</td><td>2 或 4 字节</td><td>-32,768 到 32,767 <strong>或</strong> -2,147,483,648 到 2,147,483,647</td></tr><tr><td>unsigned int</td><td>2 或 4 字节</td><td>0 到 65,535 <strong>或</strong> 0 到 4,294,967,295</td></tr><tr><td>short</td><td>2 字节</td><td>-32,768 到 32,767</td></tr><tr><td>unsigned short</td><td>2 字节</td><td>0 到 65,535</td></tr><tr><td>long</td><td>4 或 8 字节</td><td>-2,147,483,648 到 2,147,483,647 <strong>或</strong> -9,223,372,036,854,775,808 到 +9,223,372,036,854,775,807</td></tr><tr><td>unsigned long</td><td>4 或 8 字节</td><td>0 到 4,294,967,295 <strong>或</strong> 0 到 +18,446,744,073,709,551,616</td></tr><tr><td>long long</td><td>8 字节</td><td>-9,223,372,036,854,775,808 到 +9,223,372,036,854,775,807</td></tr><tr><td>unsigned long long</td><td>8 字节</td><td>0 到 +18,446,744,073,709,551,616</td></tr></tbody></table><p>上面的所有数据类型，都是整形家族的成员。</p><p><code>long</code>和<code>long long</code>本质上是<code>long int</code>和<code>long long int</code>，写的时候可以省略<code>int</code>。</p><p>在很多项目&#x2F;库函数源码中，你还会看到下面两种整数类型。他们都是基础类型的一个别名。</p><table><thead><tr><th>类型</th><th>实际对应的类型</th><th>操作系统</th></tr></thead><tbody><tr><td>szie_t</td><td>unsigned int</td><td>windows 11</td></tr><tr><td>szie_t</td><td>long unsigned int</td><td>Linux (CentOS8)</td></tr><tr><td>sszie_t</td><td>windows不支持</td><td>windows 11</td></tr><tr><td>sszie_t</td><td>long</td><td>Linux (CentOS8)</td></tr></tbody></table><h4 id="2-1-1-char也是整形"><a href="#2-1-1-char也是整形" class="headerlink" title="2.1.1 char也是整形"></a>2.1.1 char也是整形</h4><p>char字符类型也是整形家族的一员，其底层和整形int的存放方式是一模一样的，只不过其只占用了1个字节。</p><p>在printf函数中，我们也可以用<code>%d</code>来打印char类型，最终输出的结果是char对应的数字。</p><blockquote><p>在计算机底层中，会使用ASCII码表来进行数字和char字符之间的转换，将该表粘贴如下</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/07/a15bb7f7a8b6b6003421589a527b5d8d.jpeg"></p></blockquote><p>定义字符的时候，我们需要给字符带上单引号作为标识，不能删除单引号，否则会被识别为变量名；也不能用双引号，双引号代表的是字符串。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> a = <span class="string">&#x27;A&#x27;</span>; <span class="comment">// 字符A需要带上单引号</span></span><br><span class="line"><span class="type">char</span> b;</span><br><span class="line">b = <span class="string">&#x27;B&#x27;</span>;</span><br></pre></td></tr></table></figure><h4 id="2-1-2-long和int的区别"><a href="#2-1-2-long和int的区别" class="headerlink" title="2.1.2 long和int的区别"></a>2.1.2 long和int的区别</h4><p>这里对int和long做一定说明：在32位操作系统上，<strong>int和long都是4个字节</strong>。</p><p>这时，你可能和初学的我会有一样的疑惑：既然存放大小一样，能存放的长度也一样，那int和long有什么区别？</p><p>这是因为不同操作系统&#x2F;编译器会有不同的默认策略，在一些很古早的操作系统上，可能会出现下面的情况：</p><ul><li>int只有2个字节</li><li>long是4个字节</li></ul><p>long类型的含义，就是告知使用者，不管在什么操作系统上，<strong>其至少能达到和int一样的长度</strong>，或比int更长。这样只要我们需要的数据长度在2~4个字节之间，那就可以使用long来保证该变量一定会用4个字节来存储。<strong>避免不同平台中int的默认策略不同而导致的异常</strong>。</p><blockquote><p>比如我们有一个占用了3字节的整数，在int为4字节的平台上代码能正常运行，但在int只有2字节的平台上，就无法正常运行该代码。用long就能避免这个问题</p></blockquote><p>当然，如果你所编写的项目对内存占用不敏感，也可以无脑用<code>long long</code>。</p><p>在64位操作系统下，<code>int</code>类型是4个字节，<code>long</code>和<code>long long</code>都是8个字节。</p><h4 id="2-1-3-确定长度的int类型"><a href="#2-1-3-确定长度的int类型" class="headerlink" title="2.1.3 确定长度的int类型"></a>2.1.3 确定长度的int类型</h4><p>前文提到了：“只要我们需要的数据长度在2~4个字节之间，那就可以使用long来保证该变量一定会用4个字节来存储。”，但实际上这种需要确定长度来存放整形的时候，还有更合适的做法。</p><p>C语言在<code>ISO C99</code>中引入了定长整形的数据类型名，使用这一批数据类型来代替<code>int/long</code>，能确保我们的数字一定会用指定二进制位数来存放。</p><p>这一批数据类型和上文提到的<code>szie_t/sszie_t</code>一样，都是在不同操作系统环境下对已有的<code>int/long/short</code>的重命名，也就是说，底层会根据当前操作系统的不同，来自己帮我们重名这些带具体位数的整形类型，只要我们用了这个数据类型，那么代码不管在任何操作系统上，只要这个操作系统支持<code>C99</code>标准，就一定能以符合我们预期的数据长度来存放对应的整形数字。</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/07/a28e912b72640c8a0fd6b4c9f603d79d.png"></p><p>比如我们在需要4个字节（32位）来存放一个有符号整数数据时，可以用<code>int32_t</code>来替代<code>int/long</code>，这样就能从语言层面彻底确保我们的数字会用32个二进制位来存储。</p><blockquote><p>更多信息可以参考博客：<a href="https://blog.csdn.net/chongbin007/article/details/123766387">C语言 —— int32_t uint32_t 及size_t</a></p></blockquote><h3 id="2-3-浮点型"><a href="#2-3-浮点型" class="headerlink" title="2.3 浮点型"></a>2.3 浮点型</h3><p>所谓浮点型，即C语言中的小数。</p><p>下表中的E代表是科学计数法，E+38 &#x3D; 10<sup>38</sup>，E-38 &#x3D; 10<sup>-38</sup>；</p><table><thead><tr><th>类型</th><th>存储大小</th><th>值范围</th><th>精度</th></tr></thead><tbody><tr><td>float</td><td>4 字节</td><td>1.2E-38 到 3.4E+38</td><td>6 位有效位</td></tr><tr><td>double</td><td>8 字节</td><td>2.3E-308 到 1.7E+308</td><td>15 位有效位</td></tr><tr><td>long double</td><td>16 字节</td><td>3.4E-4932 到 1.1E+4932</td><td>19 位有效位</td></tr></tbody></table><p>在库函数头文件 <code>&lt;float.h&gt;</code> 存放了浮点数的最大值和最小值的宏。这里我们采用<code>%E</code>科学计数法的方式打印出浮点数float类型的最大值和最小值。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;float.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;float 存储最大字节数 : %d \n&quot;</span>, <span class="built_in">sizeof</span>(<span class="type">float</span>));</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;float 最小值: %E\n&quot;</span>, FLT_MIN );</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;float 最大值: %E\n&quot;</span>, FLT_MAX );</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;精度值: %d\n&quot;</span>, FLT_DIG );</span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码输出结果如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">float 存储最大字节数 : 4</span><br><span class="line">float 最小值: 1.175494E-38</span><br><span class="line">float 最大值: 3.402823E+38</span><br><span class="line">精度值: 6</span><br></pre></td></tr></table></figure><h3 id="2-4-指针类型"><a href="#2-4-指针类型" class="headerlink" title="2.4 指针类型"></a>2.4 指针类型</h3><p>指针类型是C&#x2F;C++中比较难懂的一环，这里我们暂时只学习基础的指针变量声明。对指针的深入学习会有专门的文档。</p><p>指针的基本格式就是<code>*</code>，只要在原有数据类型后加一个<code>*</code>，就代表是该类型的指针。在原有的变量前面加上取地址符号<code>&amp;</code>，就代表获取该变量的地址（指针）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int a = 10;</span><br><span class="line">// ptr就是一个int*的指针；&amp;a代表获取a变量的地址，赋值给ptr指针</span><br><span class="line">int* ptr = &amp;a;</span><br></pre></td></tr></table></figure><p>要想使用指针来访问变量a中的数据，我们需要用到解引用，符号也是<code>*</code>；</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int b = *ptr; // 通过解引用，获取到ptr指针指向的地址中的值，赋值给b</span><br></pre></td></tr></table></figure><p>执行完毕这个代码后，变量b就获取到了ptr指针指向的地址中的值，即变量a的值。</p><p>指针变量中，星号<code>*</code>的个数代表指针的等级，一个<code>*</code>就代表是一级指针，两个<code>*</code>就代表是二级指针，依此类推。不同等级的指针具体的区别，会在指针章节再谈，本文档只是让大家认识数据类型的。</p><h3 id="2-5-bool类型"><a href="#2-5-bool类型" class="headerlink" title="2.5 bool类型"></a>2.5 bool类型</h3><p>C&#x2F;C++中还有一个特殊的类型，布尔类型，即bool类型。</p><p>这个类型只有两个预定义的值，分别是false和true，聪明的你肯定已经明白它的作用了。主要就是用于函数的返回值，亦或者是用做flag标记变量，来<strong>标定真和假</strong>的。</p><blockquote><p>比如：通过函数判断一个字符串是否为一个数字，是返回true，不是返回false</p></blockquote><p>在C语言中使用这个变量需要引用头文件 <code>stdbool.h</code>，代码示例如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdbool.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">bool</span> a = <span class="literal">true</span>;  <span class="comment">// 真</span></span><br><span class="line"><span class="type">bool</span> b = <span class="literal">false</span>; <span class="comment">// 假</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该变量大小为1个字节，也能算作整形家族的一员（底层其实就是一个宏，分别对应0和1两个数字）</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/07/3940e18986c71adff1982e27bc7a8281.png"></p><p>头文件<code>stdbool.h</code>非常短，这里顺带将完整的内容粘贴出来。其中出现了define和ifdef这些宏定义语法，在本站后文中都会介绍到。我们只需要关注核心：可以看到，true是0，false是1，二者就是数字罢了。</p><blockquote><p><code>#define 名字 内容</code> 后文出现该<strong>名字</strong>的位置，全都会被替换成<strong>内容</strong>；<br><code>#define true 0</code> 引用头文件后，后文出现的所有true都会在预编译阶段替换成0；</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// stdbool.h</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//      Copyright (c) Microsoft Corporation. All rights reserved.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// The C Standard Library &lt;stdbool.h&gt; header.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> _STDBOOL</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _STDBOOL</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __bool_true_false_are_defined 1</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __cplusplus</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> bool  _Bool</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> false 0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> true  1</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* __cplusplus */</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* _STDBOOL */</span></span></span><br></pre></td></tr></table></figure><h2 id="3-const关键字"><a href="#3-const关键字" class="headerlink" title="3.const关键字"></a>3.const关键字</h2><p>在继续介绍其他数据类型之前，需要先带大家认识一下<code>const</code>关键字。</p><p>这个关键字的作用是将数据类型添加<strong>常量</strong>属性，被<code>const</code>关键字修饰后的属性，将具有常量属性，即<strong>不可以被修改</strong>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> a = <span class="number">10</span>; <span class="comment">// 常量变量，a不可以被修改</span></span><br></pre></td></tr></table></figure><p>当我们尝试修改这个变量的时候，会报错，无法通过编译。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> a = <span class="number">10</span>; <span class="comment">// 常量变量，a不可以被修改</span></span><br><span class="line">a = <span class="number">10</span>; <span class="comment">// 错误！修改常量会报错</span></span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/07/402b0d61057106d88ce00d167f4fbc24.png"></p><p>后文将介绍数组类型和字符串类型，请继续阅读本专栏。</p>]]></content>
    
    
    <summary type="html">C语言的变量和数据类型</summary>
    
    
    
    <category term="编程学习" scheme="https://blog.musnow.top/categories/%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="回顾C和Cpp" scheme="https://blog.musnow.top/categories/%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0/%E5%9B%9E%E9%A1%BEC%E5%92%8CCpp/"/>
    
    
    <category term="C语言" scheme="https://blog.musnow.top/tags/C%E8%AF%AD%E8%A8%80/"/>
    
    <category term="回顾C和Cpp" scheme="https://blog.musnow.top/tags/%E5%9B%9E%E9%A1%BEC%E5%92%8CCpp/"/>
    
  </entry>
  
  <entry>
    <title>【C语言】第一个HelloWorld程序 | 回顾C语言002</title>
    <link href="https://blog.musnow.top/posts/1642707893/"/>
    <id>https://blog.musnow.top/posts/1642707893/</id>
    <published>2024-07-27T21:50:12.000Z</published>
    <updated>2024-08-22T22:41:38.000Z</updated>
    
    <content type="html"><![CDATA[<p>对于大多数编程语言来说，我们第一个编写的程序都是一个打印 <code>hello world</code> 的代码，其本质是让编程语言与系统交互，在控制台中打印字符串。</p><p>让我们来看看C语言中，想要在控制台里面输出内容，应该怎么做吧！</p><h1 id="1-hello-world源码"><a href="#1-hello-world源码" class="headerlink" title="1. hello world源码"></a>1. hello world源码</h1><p>对于大部分编程语言初学者而言，这是最熟悉的代码了。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span> </span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;hello world\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="2-第一次运行代码"><a href="#2-第一次运行代码" class="headerlink" title="2. 第一次运行代码"></a>2. 第一次运行代码</h1><p>写到 VS2019 中后，我们使用键盘上的<code>CTRL+S</code>快捷键保存代码，再按 <code>CTRL+F5</code> 就可以运行代码了。</p><blockquote><p>部分笔记本电脑上，F开头的功能键默认按下是调节亮度&#x2F;声音等一些快捷功能，并不是F键本身的功能。这时候你需要使用<code>FN+F功能键</code>才能使用出<code>F功能键</code>原本的功能；比如<code>CTRL+FN+F5</code>来运行代码。</p><p>很多笔记本都可以用<code>FN+ESC</code>来锁定FN键，让<code>F功能键</code>恢复原本功能（不需要按FN），而调节亮度&#x2F;声音等快捷控制方式变回<code>FN+F功能键</code>；如果你的笔记本不是用<code>FN+ESC</code>来锁定FN键，那可以百度一下你这台型号&#x2F;品牌的笔记本如何锁定FN键（应该都有这个功能吧？没有就算了）</p><p>对于编程学习者来说，更建议你锁定FN键，避免每次 <code>CTRL+F5</code> 都得带上FN。</p></blockquote><p>运行代码后，VS2019会执行编译流程，在项目路径生成一个可执行文件，并直接执行这个文件。看到的效果就是一个黑框（windows下的终端）弹出，显示出了我们代码的结果。即<code>&quot;hello world\n&quot;</code>字符串被打印到了终端上。</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/07/0aa11cafafbc513d3bfed560f4c9a3df.png"></p><p>除了使用快捷键<code>CTRL+F5</code>运行代码，你还可以在 VS2019 的界面上方，点击<code>调试-开始执行(不调试)</code>，后续的文档中将会解释什么是调试。现在你只需要知道这里也可以执行代码就行了。</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/07/60170513fe8ce2c5f543ec7c820c6199.png"></p><h1 id="3-代码逐行解释"><a href="#3-代码逐行解释" class="headerlink" title="3. 代码逐行解释"></a>3. 代码逐行解释</h1><p>下面让我来逐行解释一下这份代码吧！</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span> <span class="comment">// 1.printf库函数需要使用的头文件</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> <span class="comment">// 2.入口函数</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;hello world\n&quot;</span>); <span class="comment">// 3.调用printf函数，打印字符串</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>; <span class="comment">// 4.return是返回值并退出函数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>先说明一下，C语言中，每一行代码后都需要跟着一个英文的分号<code>;</code>作为这一行代码的结束标记。一定不要忘记这个分号，也一定不要在不对的地方加上这个分号（不然就会出一些很难找的bug）</p><h2 id="3-1-函数的基本格式和main函数"><a href="#3-1-函数的基本格式和main函数" class="headerlink" title="3.1. 函数的基本格式和main函数"></a>3.1. 函数的基本格式和main函数</h2><p>在C&#x2F;C++中，main函数是作为函数的入口，程序是从main函数开始运行的。</p><p>C语言中，函数的基本格式如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">函数返回值 函数名(函数参数类型 函数参数1, 函数参数类型 函数参数2, ...)</span><br><span class="line">&#123;</span><br><span class="line">函数体</span><br><span class="line">return 返回值（需要和函数返回值的类型对应）</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对应的，main函数是C语言中程序的入口，长下面这样。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// 函数体</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>; <span class="comment">// 返回值是0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个main函数中：</p><ul><li>函数的返回值是int（整数类型）</li><li><code>main()</code>括号内为空，代表main函数没有参数</li><li>函数体自行编写</li><li><code>return 0;</code>代表main函数的返回值是0</li></ul><p>运行程序的时候，编译器会自动找到你的main函数，开始执行这个代码。这也是为什么我们的main函数可以不写参数。</p><p>而其他函数，都需要我们手动调用。</p><blockquote><p>关于main函数的参数和返回值，还有很多可以聊的。后续的学习中再深入学习吧。</p></blockquote><h2 id="3-2-函数注释"><a href="#3-2-函数注释" class="headerlink" title="3.2. 函数注释"></a>3.2. 函数注释</h2><p>在C&#x2F;C++中，函数注释是以<code>//</code>开头，在这之后的文字都是函数注释，和实际代码没有任何关系。</p><p>所谓注释，就是对函数这部分功能的描述，或函数参数的描述。避免其他人看不懂你代码的意图，亦或者是自己以后回来也看不明白自己写的是啥了。</p><blockquote><p>虽然网上有段子说：“最讨厌不写注释的人，和让我写注释的人”，但实际上，该写的注释还是得写的。段子图一乐就行了。</p></blockquote><p>对于初学者来说，多写注释能让后续你复习代码的时候，明确这部分学习的内容。注释并不需要做到行行都有，但是基本流程还是要写上的。</p><h2 id="3-3-include"><a href="#3-3-include" class="headerlink" title="3.3. #include"></a>3.3. #include</h2><p>在上面的打印代码中，第一行如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br></pre></td></tr></table></figure><p>这里的<code>#include</code>的作用是引用一个头文件，头文件一般以<code>.h</code>结尾，<code>&lt;&gt;</code>中的便是头文件的文件名。</p><blockquote><p>你可以理解为，头文件是另外一个包含C语言代码的文本文件。</p></blockquote><p>当我们引用了这个头文件后，这个头文件的内容会在当前文件<strong>被展开</strong>。</p><p>假设我们将下面的代码写入到<code>Add.h</code>文件</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">Add</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> a+b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再在<code>test.c</code>文件中写如下代码</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Add.h&quot;</span> <span class="comment">// 引用我们自己的头文件</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> num = <span class="built_in">Add</span>(<span class="number">1</span>,<span class="number">3</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最终，编译器会在<strong>预编译</strong>阶段（这是编译的阶段之一）展开<code>Add.h</code>头文件，整个代码会自动变成如下模样。即<code>#include &quot;Add.h&quot;</code>被替换成了<code>Add.h</code>头文件中的内容。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">Add</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> a+b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> num = <span class="built_in">Add</span>(<span class="number">1</span>,<span class="number">3</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-3-1-include中-lt-gt-和””的区别"><a href="#3-3-1-include中-lt-gt-和””的区别" class="headerlink" title="3.3.1. include中&lt;&gt;和””的区别"></a>3.3.1. include中&lt;&gt;和””的区别</h3><p>细心的你应该发现了，<code>#include</code>后面出现了两种不同的符号，分别是<code>&lt;&gt;</code>和<code>&quot;&quot;</code>；区别如下</p><ul><li><code>&lt;&gt;</code> <strong>只能</strong>引用官方的头文件，比如<code>stdio.h</code>就是C语言本身提供的头文件；</li><li><code>&quot;&quot;</code> 引用我们自己写的头文件，比如上文中的<code>Add.h</code>就是我们自己写的一个头文件。</li></ul><p>而<code>&quot;&quot;</code>既可以引用官方的头文件，又可以引用自己写的头文件。它的查找逻辑不同，假设我们有如下的一个文件路径：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">测试代码(文件夹)</span><br><span class="line">- Add.h</span><br><span class="line">- test.c</span><br></pre></td></tr></table></figure><p>依照上面的代码，我们运行代码是从<code>test.c</code>开始的，执行到第一行的<code>#include &quot;Add.h&quot;</code>时，因为我们使用的是<code>&quot;&quot;</code>，所以编译器会执行如下流程：</p><ul><li>从当前<code>test.c</code>文件夹所在的路径，开始找这个<code>Add.h</code>，找到了，就将头文件中的内容展开（本例子中存在<code>Add.h</code>头文件，所以可以正常找到头文件并展开）；</li><li>如果找不到，就会去编程语言的<strong>安装路径</strong>中，找C语言官方提供的头文件；</li><li>如果还找不到，代表这个头文件不存在，报错退出编译流程，编译失败。</li></ul><p>而如果使用<code>&lt;&gt;</code>引用头文件，则<strong>只会</strong>去编程语言的安装路径中找官方提供的头文件。找不到，则编译失败。比如我们用<code>#include &lt;Add.h&gt;</code>来引用上文我们自己写的头文件，就会编译出错。</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/07/9728b266086f08c9676e48a3886272ae.png"></p><blockquote><p>现在讲这部分，可能会有些抽象。你可以只记住两者的区别即可，最终头文件的引用这件事，还会在学习Linux的时候再谈，到时候就能给大家演示二者区别的实际例子，更方便理解。</p></blockquote><p>在日常编写代码中，我们应该做好区分，这也是代码规范的一部分：</p><ul><li>C语言内置的头文件，使用<code>&lt;&gt;</code>来引用，告知别人这是内置的头文件；</li><li>自己编写的头文件，使用<code>&quot;&quot;</code>来引用，告知别人这是我们自己写的头文件；</li></ul><p>保持良好的代码规范，是我们学习编程中不可或缺的一部分。</p><h2 id="3-4-printf函数"><a href="#3-4-printf函数" class="headerlink" title="3.4. printf函数"></a>3.4. printf函数</h2><h3 id="3-4-1-善用cplusplus-com文档网站"><a href="#3-4-1-善用cplusplus-com文档网站" class="headerlink" title="3.4.1. 善用cplusplus.com文档网站"></a>3.4.1. 善用cplusplus.com文档网站</h3><p><a href="https://legacy.cplusplus.com/">cplusplus.com</a>这个网站的作用是查找一些C&#x2F;C++库函数的定义和用法，现在就以printf函数为例，带大家来用用这个网站，并学习printf函数的使用。</p><p>进入网站后，在最上方的搜索框查找printf函数</p><p><a href="https://legacy.cplusplus.com/reference/cstdio/printf/?kw=printf">https://legacy.cplusplus.com/reference/cstdio/printf/?kw=printf</a></p><p>cplusplus.com的结果都是全英文的，但不要有畏难情绪，基本的介绍是不难读懂的。实在不行我们可以用翻译软件嘛！</p><p>下图中标注出了该网站搜索到的结果中的基本格式。包含函数的定义、说明、函数参数、返回值，最底部还有函数的使用示例</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/07/9df0a5a57afe4c23073869f29e8e10e0.png"></p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/07/dc8c82ffccd3710bdaaabdc96858392a.png"></p><h3 id="3-4-2-函数声明"><a href="#3-4-2-函数声明" class="headerlink" title="3.4.2. 函数声明"></a>3.4.2. 函数声明</h3><p>printf的函数的声明如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">printf</span> <span class="params">( <span class="type">const</span> <span class="type">char</span> * format, ... )</span></span>;</span><br></pre></td></tr></table></figure><h4 id="3-4-2-1-参数"><a href="#3-4-2-1-参数" class="headerlink" title="3.4.2.1. 参数"></a>3.4.2.1. 参数</h4><p>依照前文提到的函数的基本格式进行解读：</p><ul><li>返回值是int</li><li>函数名是printf</li><li>函数的第一个参数是<code>const char *</code>类型，参数名为format，意义是函数的打印格式</li><li>函数的后续参数用了<code>...</code>，这一点就比较深入了，是C语言中支持的<strong>可变参数列表</strong>（文档很后面才会深入介绍这个）</li></ul><p>printf函数会根据我们设置的第一个参数打印格式，将后续传入的可变参数列表中的参数，以我们传入的打印格式写入到<code>stdout</code>中；</p><blockquote><p><code>stdout</code>是C语言的标准输出流，在默认情况下，就是往控制台中输出。</p></blockquote><h4 id="3-4-2-2-返回值"><a href="#3-4-2-2-返回值" class="headerlink" title="3.4.2.2. 返回值"></a>3.4.2.2. 返回值</h4><p>在网站中，对返回值的介绍如下</p><figure class="highlight plaintext"><figcaption><span>text</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">On success, the total number of characters written is returned.</span><br><span class="line"></span><br><span class="line">If a writing error occurs, the error indicator (ferror) is set and a negative number is returned.</span><br><span class="line"></span><br><span class="line">If a multibyte character encoding error occurs while writing wide characters, errno is set to EILSEQ and a negative number is returned.</span><br></pre></td></tr></table></figure><p>翻译过来是这样的：</p><ul><li>函数执行成功，会返回成功打印了多少个字符</li><li>函数执行失败，会返回一个负数（更多的暂时不需要了解）</li></ul><h4 id="3-4-2-3-调用示例"><a href="#3-4-2-3-调用示例" class="headerlink" title="3.4.2.3. 调用示例"></a>3.4.2.3. 调用示例</h4><p>下面是几个printf的调用示例</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,<span class="number">10</span>); <span class="comment">// 打印整形 (int)</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%x&quot;</span>,<span class="number">10</span>); <span class="comment">// 以十六进制打印整形 (int)</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%lld&quot;</span>,<span class="number">100000000000000</span>); <span class="comment">// 打印长整形 (long long)</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%a&quot;</span>,<span class="string">&#x27;C&#x27;</span>); <span class="comment">// 打印单个字符 (char)</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;hello world&quot;</span>); <span class="comment">// 直接打印字符串 (char *)</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>,<span class="string">&quot;hello world&quot;</span>); <span class="comment">// 通过%s打印字符串 (char *)</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%f&quot;</span>,<span class="number">3.14</span>); <span class="comment">// 打印浮点数，即分数和小数 (float/double)</span></span><br><span class="line"><span class="type">int</span> ptr = <span class="number">30</span>; <span class="comment">// 定义一个int类型的变量ptr</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%p&quot;</span>,&amp;ptr); <span class="comment">// 打印地址（需要打印的是指针，后续会讲解指针类型）</span></span><br></pre></td></tr></table></figure><p>更多的格式化控制方式，可以在<a href="https://legacy.cplusplus.com/reference/cstdio/printf/?kw=printf">cplusplus.com</a>的参数介绍中找到，常用的上面基本都提到了。</p><p>后续会在输入输出操作的时候，更详细地介绍这个函数。</p><h1 id="4-结语"><a href="#4-结语" class="headerlink" title="4. 结语"></a>4. 结语</h1><p>看到这里，想毕你已经对我们刚刚编写的第一个C语言程序，有基本的理解啦！</p>]]></content>
    
    
    <summary type="html">第一个HelloWorld程序</summary>
    
    
    
    <category term="编程学习" scheme="https://blog.musnow.top/categories/%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="回顾C和Cpp" scheme="https://blog.musnow.top/categories/%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0/%E5%9B%9E%E9%A1%BEC%E5%92%8CCpp/"/>
    
    
    <category term="C语言" scheme="https://blog.musnow.top/tags/C%E8%AF%AD%E8%A8%80/"/>
    
    <category term="回顾C和Cpp" scheme="https://blog.musnow.top/tags/%E5%9B%9E%E9%A1%BEC%E5%92%8CCpp/"/>
    
  </entry>
  
  <entry>
    <title>【C语言】都2024年了，还适合学C语言吗？| 回顾C语言001</title>
    <link href="https://blog.musnow.top/posts/1114620238/"/>
    <id>https://blog.musnow.top/posts/1114620238/</id>
    <published>2024-07-27T21:46:55.000Z</published>
    <updated>2024-08-22T22:41:36.000Z</updated>
    
    <content type="html"><![CDATA[<p>都2023年了，还适合学C语言吗？</p><h2 id="C语言适合什么？"><a href="#C语言适合什么？" class="headerlink" title="C语言适合什么？"></a>C语言适合什么？</h2><p>不同编程语言都有不同的适用范围，比起其他语言，C语言更加适合比较底层的操作。比如在互联网行业中最广泛使用的服务器操作系统Linux，就是用C语言编写的。</p><ul><li>操作系统；</li><li>驱动软件；</li><li>编译器；</li><li>嵌入式编程（单片机）；</li><li>服务器后端程序（C和C++）；</li><li>基础架构平台；</li><li>用来写其他编程语言（比如Python的解释器就是用C语言实现的）；</li><li>…</li></ul><h2 id="C-x2F-C-的就业环境"><a href="#C-x2F-C-的就业环境" class="headerlink" title="C&#x2F;C++的就业环境"></a>C&#x2F;C++的就业环境</h2><p>但是，2023&#x2F;2024年的今天，作为已经在实习生求职中摸爬滚打的过来人，必须要提前告知编程初学者：当下C&#x2F;C++的岗位<strong>极其稀少</strong>，岗位数量甚至不足Java的50%，很多知名企业只有测开岗位的要求中才出现了C&#x2F;C++字样，而测开知识大多是Java&#x2F;Python方向才会学习的。这一点你可以在各大厂的校招官网中求证，搜索C++相关岗位，数量只有个位数，甚至完全没有C++岗位。目前看也就华为和腾讯对C++选手比较友好。</p><blockquote><p>可能有人会和你说，<strong>企业招聘并不看重语言</strong>。这句话只是<strong>部分正确</strong>。</p></blockquote><p>当下大中厂的HC和应聘者比例极度失衡，是<strong>僧多粥少</strong>的局面；既然人家能找到语言对口的应届生，除非你能做到<strong>特别优秀</strong>（学校比人家好、学历比人家高、C&#x2F;C++学的特别牛），那为何要来录取你一位语言不通的求职者？</p><p>企业追求的是效益，语言对口的应聘者绝对是更有优势的。这样能减少入职培训的时长，让新人更快进入实际项目岗位中打螺丝。所以，如果你决心学习C&#x2F;C++，并对操作系统、高性能后台开发、嵌入式编程感兴趣，那就要做好努力学习和接受更少岗位、更少HC的准备！</p><blockquote><p>至于多修编程语言，个人是<strong>非常不推荐</strong>的！</p></blockquote><p>除非你是学霸，能做到全知全能。否则我还是建议你慎重选择自己的主修语言，彻底深入学习该语言，并依照个人喜好辅修一俩门编程语言的基础语法即可。</p><h2 id="跟着慕雪一起回顾C-x2F-C-吧"><a href="#跟着慕雪一起回顾C-x2F-C-吧" class="headerlink" title="跟着慕雪一起回顾C&#x2F;C++吧"></a>跟着慕雪一起回顾C&#x2F;C++吧</h2><p>新开了一个随缘更新的专栏，为回顾C&#x2F;C++所设，日后有学弟学妹想学习C++方向了，我也可以直接把这个专栏丢给他们。如果你想和慕雪一起从0开始学习C语言，可以关注一下本站的<a href="https://blog.musnow.top/tags/%E5%9B%9E%E9%A1%BEc%E5%92%8Ccpp/">回顾C和Cpp</a>这个Tag。</p><p>在学习C语言之前，请安装VS2019或者VS2022编译器：</p><ul><li><a href="https://blog.musnow.top/posts/2731112594">【VS】如何下载VS2019并初始化C&#x2F;C++环境</a>；</li><li><a href="https://blog.musnow.top/posts/4009185516">【VS】如何解决VS编译器scanf报错问题</a>;</li></ul><p>感谢大家的支持！</p>]]></content>
    
    
    <summary type="html">都2024年了，还适合学C语言吗？</summary>
    
    
    
    <category term="编程学习" scheme="https://blog.musnow.top/categories/%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="回顾C和Cpp" scheme="https://blog.musnow.top/categories/%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0/%E5%9B%9E%E9%A1%BEC%E5%92%8CCpp/"/>
    
    
    <category term="C语言" scheme="https://blog.musnow.top/tags/C%E8%AF%AD%E8%A8%80/"/>
    
    <category term="回顾C和Cpp" scheme="https://blog.musnow.top/tags/%E5%9B%9E%E9%A1%BEC%E5%92%8CCpp/"/>
    
  </entry>
  
  <entry>
    <title>【Git】如何在已经提交内容中删除某个目录或文件</title>
    <link href="https://blog.musnow.top/posts/430272532/"/>
    <id>https://blog.musnow.top/posts/430272532/</id>
    <published>2024-07-26T14:55:07.000Z</published>
    <updated>2024-09-05T23:07:24.000Z</updated>
    
    <content type="html"><![CDATA[<p>有的时候，会出现git错误添加了某个目录或者某个文件，现在需要将这个文件从git中删除。</p><p>可以使用如下命令执行。其中<code>-r</code>代表递归删除文件，<code>--cached</code>代表只从git的索引中删除文件，而不会在磁盘上删除文件。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">rm</span> -r --cached path/to/directory</span><br></pre></td></tr></table></figure><p>调用这个命令后，目标目录和文件就不再被git追踪。如果你不想让这个文件再次被错误的包含，请将文件或者路径写入<code>.gitignore</code>中，并<code>git add .gitignore</code>使修改生效。</p><p>我一般容易出现这个问题的是错误的添加了<code>.vscode</code>和cmake build的路径，需要将其删除。</p><p>注意，修改后想提交到远端可能需要使用<code>-f</code>强制提交，请在提交之前确认您的操作无误！最好是先备份一下原有文件的git仓库。</p><hr><p>另外，如果一个仓库被强制提交了，正好覆盖了另外一个本地仓库中已有的commit，此时应该将这个仓库回滚到该强制提交commit之前的某一个commit，再执行<code>git pull</code>，这样可以避免出现merge操作。</p><p>这样说的可能不太清楚。假设我修改了commit A，并将其强制提交到了远端，将这个新的修改设为A1吧。此时我在另外一台<strong>设备甲</strong>上本地有原本的commit A。如果这时候你直接执行git pull，会出现一个merge操作，因为本地原有的commit A和现在远端新的commit A1是不兼容的。</p><p>需要做的操作是，将这个另外一台设备甲上的本次仓库，调用git log查看历史记录，使用<code>git reset --hard &lt;commit id&gt;</code>的方式回滚到另外一个早于commit A的提交，再执行git pull，此时就不会出现merge操作。</p>]]></content>
    
    
    <summary type="html">git如何删除已经提交的文件或目录。</summary>
    
    
    
    <category term="差生文具多" scheme="https://blog.musnow.top/categories/%E5%B7%AE%E7%94%9F%E6%96%87%E5%85%B7%E5%A4%9A/"/>
    
    <category term="编程工具" scheme="https://blog.musnow.top/categories/%E5%B7%AE%E7%94%9F%E6%96%87%E5%85%B7%E5%A4%9A/%E7%BC%96%E7%A8%8B%E5%B7%A5%E5%85%B7/"/>
    
    
    <category term="git" scheme="https://blog.musnow.top/tags/git/"/>
    
  </entry>
  
  <entry>
    <title>【Docker】Docker学习04 | dockerfile的编写</title>
    <link href="https://blog.musnow.top/posts/188682082/"/>
    <id>https://blog.musnow.top/posts/188682082/</id>
    <published>2024-07-21T06:04:27.000Z</published>
    <updated>2024-08-23T23:25:58.000Z</updated>
    
    <content type="html"><![CDATA[<p>dockerfile是构建docker镜像的基础，它规定了一系列语法，让我们可以在某个基础镜像之上，添加自己需要的操作，打包出一个自己的镜像。</p><h1 id="1-dockerfile基本语法"><a href="#1-dockerfile基本语法" class="headerlink" title="1. dockerfile基本语法"></a>1. dockerfile基本语法</h1><p>下面是dockerfile的基本语法和其对应的功能，dockerfile中的每一个指令都对应的<strong>镜像的一层</strong>。</p><p>除了这些构建语法外，在dockerfile中使用<code>#</code>开头的行代表注释行。注意，<strong>注释只能单成一行</strong>，不能在已有语句末尾追加。</p><table><thead><tr><th>语法</th><th>说明</th></tr></thead><tbody><tr><td>FROM</td><td>指定基础镜像</td></tr><tr><td>RUN</td><td>在基础镜像上需要执行的命令（构建命令）</td></tr><tr><td>WORKDIR</td><td>其实就是cd的意思，设置镜像的工作目录</td></tr><tr><td>VOLUME</td><td>设置需要挂载文件实现持久化的目录</td></tr><tr><td>EXPOSE</td><td>指定容器对外暴露的端口</td></tr><tr><td>ENV</td><td>设置镜像中的环境变量</td></tr><tr><td>ARG</td><td>设置dockerfile<strong>构建过程中</strong>的环境变量</td></tr><tr><td>ENTRYPOINT</td><td>设置默认的可执行文件</td></tr><tr><td>HEALTHCHECK</td><td>在容器启动的时候进行健康检查</td></tr><tr><td>MAINTAINER</td><td>设置维护者信息（弃用，推荐用LABEL替代）</td></tr><tr><td>LABEL</td><td>给镜像添加元数据（如镜像作者）</td></tr><tr><td>ADD</td><td>添加本地&#x2F;远程的目录或文件</td></tr><tr><td>COPY</td><td>拷贝文件&#x2F;目录</td></tr><tr><td>ONBUILD</td><td>只有FROM基于当前镜像的时候才会执行</td></tr><tr><td>SHELL</td><td>设置镜像默认使用的shell</td></tr><tr><td>STOPSIGNAL</td><td>设置特定的系统信号来让容器退出</td></tr><tr><td>USER</td><td>设置<strong>执行构建命令</strong>的用户和用户组ID</td></tr></tbody></table><p>本文对这些命令的解释只停留于基础，更详细的介绍建议查看<a href="https://docs.docker.com/reference/dockerfile/">dockerfile</a>文档。</p><h1 id="2-dockerfile语法详解"><a href="#2-dockerfile语法详解" class="headerlink" title="2. dockerfile语法详解"></a>2. dockerfile语法详解</h1><h2 id="2-1-FROM"><a href="#2-1-FROM" class="headerlink" title="2.1. FROM"></a>2.1. FROM</h2><p>这个是指定当前需要构建的镜像的<strong>基础镜像</strong>，dockerfile文件中必须要有FROM字段。</p><p>比如我们有一个项目，需要在ubuntu环境上运行，我们就可以指定当前镜像是基于ubuntu镜像的。</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> ubuntu:<span class="number">22.04</span></span><br></pre></td></tr></table></figure><p>这时候就出现了一个问题了，这些<strong>基础镜像</strong>是怎么制作出来的？以<a href="https://github.com/CentOS/sig-cloud-instance-images/blob/CentOS-7.6.1810/docker/Dockerfile">CentOS 7.6</a>为例，官方的dockerfile是这么写的。</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> scratch</span><br><span class="line"><span class="keyword">ADD</span><span class="language-bash"> centos-7-docker.tar.xz /</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">LABEL</span><span class="language-bash"> org.label-schema.schema-version=<span class="string">&quot;1.0&quot;</span> \</span></span><br><span class="line"><span class="language-bash">    org.label-schema.name=<span class="string">&quot;CentOS Base Image&quot;</span> \</span></span><br><span class="line"><span class="language-bash">    org.label-schema.vendor=<span class="string">&quot;CentOS&quot;</span> \</span></span><br><span class="line"><span class="language-bash">    org.label-schema.license=<span class="string">&quot;GPLv2&quot;</span> \</span></span><br><span class="line"><span class="language-bash">    org.label-schema.build-date=<span class="string">&quot;20181204&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">CMD</span><span class="language-bash"> [<span class="string">&quot;/bin/bash&quot;</span>]</span></span><br></pre></td></tr></table></figure><p>第一行的<code>FROM scratch</code>代表从“空”开始创建镜像，而第二行的ADD代表添加了一个文件。从Github仓库的<a href="https://github.com/CentOS/sig-cloud-instance-images/blob/CentOS-7.6.1810/docker/Dockerfile">文件路径</a>中可以看到，官方使用了一个centos的<code>tar.xz</code>系统包，这个压缩包里面是系统运行的必要二进制文件。</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/07/b6ef336c8962fcb547f8b3ae8b94953a.png" alt="image.png"></p><p>把这个<code>centos-7-docker.tar.xz</code>压缩包下载到本地，解压看看，内部其实就是一个centos系统的根路径下的必要内容。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">❯ tree -L 1 /tmp/centos7</span><br><span class="line">/tmp/centos7</span><br><span class="line">├── anaconda-post.log</span><br><span class="line">├── bin -&gt; usr/bin</span><br><span class="line">├── dev</span><br><span class="line">├── etc</span><br><span class="line">├── home</span><br><span class="line">├── lib -&gt; usr/lib</span><br><span class="line">├── lib64 -&gt; usr/lib64</span><br><span class="line">├── media</span><br><span class="line">├── mnt</span><br><span class="line">├── opt</span><br><span class="line">├── proc</span><br><span class="line">├── root</span><br><span class="line">├── run</span><br><span class="line">├── sbin -&gt; usr/sbin</span><br><span class="line">├── srv</span><br><span class="line">├── sys</span><br><span class="line">├── tmp</span><br><span class="line">├── usr</span><br><span class="line">└── var</span><br><span class="line"></span><br><span class="line">18 directories, 1 file</span><br></pre></td></tr></table></figure><p>至此可以明确一个概念，我们需要制作一个镜像，有两种方式：</p><ul><li>一个是基于开源的镜像的基础上二次构建；</li><li>第二种方式就是像centos官方一样，制作系统的二进制文件，从0开始构建镜像。</li></ul><p>如果不是有神马特殊需要，直接使用<strong>第一种方式</strong>，基于已有开源镜像的基础来构建镜像就够了。</p><h2 id="2-2-RUN"><a href="#2-2-RUN" class="headerlink" title="2.2. RUN"></a>2.2. RUN</h2><p>RUN字段指定了在基础镜像上需要执行的命令，通常用于安装环境。这些命令都等同于直接在基础镜像的shell中运行的命令。</p><p>RUN有两种语法格式，一种是直接写命令，另外一种是用exec的格式将命令和选项拼接起来。</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">RUN</span><span class="language-bash"> &lt;需要运行的命令&gt;</span></span><br><span class="line"><span class="comment"># 等价于直接运行命令</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> [<span class="string">&quot;apt&quot;</span>,<span class="string">&quot;install&quot;</span>,<span class="string">&quot;vim&quot;</span>] </span></span><br><span class="line"><span class="comment"># 等价于 RUN apt install vim</span></span><br></pre></td></tr></table></figure><p>比如我们创建一个ubuntu的容器，尝试在里面安装一个<code>net-tools</code>软件包，可以如下编写dockerfile。</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> ubuntu:<span class="number">22.04</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> apt intstall -y net-tools</span></span><br></pre></td></tr></table></figure><p>如果你需要执行多个环境配置的命令，使用<code>&amp;&amp;</code>将其连接，而不要写多个RUN命令</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> ubuntu:<span class="number">22.04</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> apt -y update &amp;&amp; \</span></span><br><span class="line"><span class="language-bash">apt intstall -y net-tools</span></span><br></pre></td></tr></table></figure><h2 id="2-3-MAINTAINER和LABEL"><a href="#2-3-MAINTAINER和LABEL" class="headerlink" title="2.3. MAINTAINER和LABEL"></a>2.3. MAINTAINER和LABEL</h2><p>MAINTAINER和LABEL都是用于给docker镜像打标签的。你可以理解为给他身上挂个名牌，这样其他人就可以从名牌上看到和这个镜像相关的一些信息。</p><p>使用<code>docker inspect ubuntu:22.04</code>命令，可以看到ubuntu镜像上挂着的一些名牌。</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line"><span class="attr">&quot;Labels&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">                <span class="attr">&quot;org.opencontainers.image.ref.name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;ubuntu&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;org.opencontainers.image.version&quot;</span><span class="punctuation">:</span> <span class="string">&quot;22.04&quot;</span></span><br><span class="line">            <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>而且我们基于<code>ubuntu:22.04</code>镜像构建的其他镜像，也会包含这个名牌。这可以让使用者在没有看到dockerfile的情况下，了解到你构建的镜像是基于ubuntu的。</p><p>下面的LABEL和MAINTAINER的语法格式，都是<code>key=value</code>的形式。</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">LABEL</span><span class="language-bash"> &lt;key&gt;=&lt;value&gt; &lt;key&gt;=&lt;value&gt; &lt;key&gt;=&lt;value&gt; ...</span></span><br><span class="line"><span class="comment"># MAINTAINER 会设置镜像详情中的Author字段</span></span><br><span class="line"><span class="keyword">MAINTAINER</span> &lt;name&gt;</span><br></pre></td></tr></table></figure><p>来简单试试吧</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> ubuntu:<span class="number">22.04</span></span><br><span class="line"><span class="keyword">MAINTAINER</span> musnows</span><br><span class="line"><span class="keyword">LABEL</span><span class="language-bash"> build.in=<span class="string">&quot;vmware-ubuntu&quot;</span></span></span><br></pre></td></tr></table></figure><p>使用这个dockerfile构建的镜像，会有下面的LABEL，且Author字段是<code>MAINTAINER</code>设置的musnows（ubuntu基础镜像中Author字段为空）</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line"><span class="attr">&quot;Author&quot;</span><span class="punctuation">:</span> <span class="string">&quot;musnows&quot;</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;Config&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line"><span class="attr">&quot;Labels&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">                <span class="attr">&quot;build.in&quot;</span><span class="punctuation">:</span> <span class="string">&quot;vmware-ubuntu&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;org.opencontainers.image.ref.name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;ubuntu&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;org.opencontainers.image.version&quot;</span><span class="punctuation">:</span> <span class="string">&quot;22.04&quot;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>另外，dockerfile的官方文档中提到，下面这个LABEL和MAINTAINER是对应的</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">LABEL</span><span class="language-bash"> org.opencontainers.image.authors=<span class="string">&quot;SvenDowideit@home.org.au&quot;</span></span></span><br></pre></td></tr></table></figure><p>但经过我的测试，这个LABEL不会修改Author字段（只有MAINTAINER会修改Author字段）。你可以根据自己的需要选择使用LABEL还是MAINTAINER。</p><h2 id="2-4-SHELL"><a href="#2-4-SHELL" class="headerlink" title="2.4. SHELL"></a>2.4. SHELL</h2><p>这个命令用于设置镜像默认使用的SHELL。</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SHELL</span><span class="language-bash"> [<span class="string">&quot;executable&quot;</span>, <span class="string">&quot;parameters&quot;</span>]</span></span><br></pre></td></tr></table></figure><p>在<a href="https://docs.docker.com/reference/dockerfile/#shell">官方文档</a>中，有列出Linux和Windows下默认使用的SHELL是什么。如果它们不符合你的要求，比如你需要使用<code>/bin/bash</code>作为你的shell，则可以自行更换。</p><blockquote><p>The SHELL instruction allows the default shell used for the shell form of commands to be overridden. The default shell on Linux is<code>[&quot;/bin/sh&quot;, &quot;-c&quot;]</code>, and on Windows is <code>[&quot;cmd&quot;, &quot;/S&quot;, &quot;/C&quot;]</code>. The SHELL instruction must be written in JSON form in a Dockerfile.</p></blockquote><h2 id="2-5-WORKDIR"><a href="#2-5-WORKDIR" class="headerlink" title="2.5. WORKDIR"></a>2.5. WORKDIR</h2><p>设置docker构建过程和最终程序运行使用的工作路径。默认的工作路径是<code>/</code>根路径。如果指定的WORKDIR路径不存在，则会被创建。</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">WORKDIR</span><span class="language-bash"> /path/to/workdir</span></span><br></pre></td></tr></table></figure><p>另外，工作路径采用的是追加的方式，比如下方设置了多个工作路径，那么最终的工作路径是<code>/a/b/c/</code>这个目录。你可以理解为它本质上就是一个CD命令。</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">WORKDIR</span><span class="language-bash"> /a</span></span><br><span class="line"><span class="keyword">WORKDIR</span><span class="language-bash"> b</span></span><br><span class="line"><span class="keyword">WORKDIR</span><span class="language-bash"> c</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> <span class="built_in">pwd</span></span></span><br></pre></td></tr></table></figure><p>工作路径可以使用环境变量，前提这个环境变量是在dockerfile中被显式设置的</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ENV</span> DIRPATH=/path</span><br><span class="line"><span class="keyword">WORKDIR</span><span class="language-bash"> <span class="variable">$DIRPATH</span>/<span class="variable">$DIRNAME</span></span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> <span class="built_in">pwd</span></span></span><br></pre></td></tr></table></figure><p>此时pwd命令的输出是<code>/path/$DIRNAME</code>。</p><h2 id="2-6-COPY"><a href="#2-6-COPY" class="headerlink" title="2.6. COPY"></a>2.6. COPY</h2><p>COPY命令有两种方式，如果路径中包含空格，则必须使用第二种形式（将路径使用英文双引号括起来）</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">COPY</span><span class="language-bash"> [OPTIONS] &lt;src&gt; ... &lt;dest&gt;</span></span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> [OPTIONS] [<span class="string">&quot;&lt;src&gt;&quot;</span>, ... <span class="string">&quot;&lt;dest&gt;&quot;</span>]</span></span><br></pre></td></tr></table></figure><p>COPY命令支持使用<code>*</code>来匹配任意字符，<code>?</code>匹配单个字符。如果需要拷贝名称中包含<code>[]</code>的特殊文件，则需要使用Golang转义规则对文件名进行转义。详见<a href="https://docs.docker.com/reference/dockerfile/#copy">官方文档</a>。</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 将本地文件 app.py 复制到镜像的 /app 目录</span></span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> app.py /app/</span></span><br><span class="line"><span class="comment"># 将整个本地目录 my_app 复制到镜像的 /app 目录</span></span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> my_app/ /app/</span></span><br><span class="line"><span class="comment"># 复制所有以 .py 结尾的文件到镜像的 /app 目录</span></span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> *.py /app/</span></span><br><span class="line"><span class="comment"># 将 src 目录中所有文件复制到 /app 目录</span></span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> src/* /app/</span></span><br></pre></td></tr></table></figure><h3 id="2-6-1-选项说明"><a href="#2-6-1-选项说明" class="headerlink" title="2.6.1. 选项说明"></a>2.6.1. 选项说明</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">--from</span><br><span class="line">--chown</span><br><span class="line">--chmod</span><br><span class="line">--link</span><br><span class="line">--parents</span><br><span class="line">--exclude</span><br></pre></td></tr></table></figure><h4 id="2-6-1-1-–from"><a href="#2-6-1-1-–from" class="headerlink" title="2.6.1.1. –from"></a>2.6.1.1. –from</h4><p><code>--from</code>选项允许COPY从多段构建中拷贝文件，或从其他镜像中拷贝文件。</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">COPY</span><span class="language-bash"> [--from=&lt;image|stage|context&gt;] &lt;src&gt; ... &lt;dest&gt;</span></span><br></pre></td></tr></table></figure><p>比如我们可以从nginx镜像中直接拷贝配置文件，对应选项中的image</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">COPY</span><span class="language-bash"> --from=nginx:latest /etc/nginx/nginx.conf /nginx.conf</span></span><br></pre></td></tr></table></figure><p>我们还可以从多段构建中拷贝文件，对应选项中的stage。</p><p>下面是官网中一个多段构建的dockefile，在基础镜像alpine中使用clang编译了<code>hello.c</code>的程序，随后将这个程序的可执行文件移动到一个空的镜像中。这就相当于空镜像里面直接添加了一个可执行文件。不过这只是个例子，经过我的测试，这个镜像并不能正常运行😑。</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># syntax=docker/dockerfile:1</span></span><br><span class="line"><span class="keyword">FROM</span> alpine AS build</span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> . .</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> apk add clang</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> clang -o /hello hello.c</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">FROM</span> scratch</span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> --from=build /hello /</span></span><br></pre></td></tr></table></figure><p>在docker build命令中，可以指定多个构建的上下文，并在dockerfile中选择其中某个上下文中的文件进行拷贝，对应选项中的context。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 运行 Docker 构建时，指定两个构建上下文</span></span><br><span class="line">docker build -t myapp \</span><br><span class="line">  --build-context source1=. \</span><br><span class="line">  --build-context source2=../other-folder \</span><br><span class="line">  -f Dockerfile .</span><br></pre></td></tr></table></figure><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 在 Dockerfile 中，从指定的构建上下文 &quot;source2&quot; 中复制文件</span></span><br><span class="line"><span class="keyword">FROM</span> alpine:latest</span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> --from=source2 /extra-files/ /app/</span></span><br></pre></td></tr></table></figure><h4 id="2-6-1-2-–chown-–chmod"><a href="#2-6-1-2-–chown-–chmod" class="headerlink" title="2.6.1.2. –chown,–chmod"></a>2.6.1.2. –chown,–chmod</h4><p>这两个选项只有在Linux中构建镜像的时候才有效</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">COPY</span><span class="language-bash"> [--<span class="built_in">chown</span>=&lt;user&gt;:&lt;group&gt;] [--<span class="built_in">chmod</span>=&lt;perms&gt; ...] &lt;src&gt; ... &lt;dest&gt;</span></span><br></pre></td></tr></table></figure><p>在COPY的时候，默认是使用0号PGID&#x2F;PUID进行操作的。如果你想避免默认的root权限，可以通过这两个选项进行修改。参数和linux本地的chown&#x2F;chmod命令一致。</p><h4 id="2-6-1-3-–link"><a href="#2-6-1-3-–link" class="headerlink" title="2.6.1.3. –link"></a>2.6.1.3. –link</h4><p>详见<a href="https://docs.docker.com/reference/dockerfile/#copy---link">官方文档</a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">COPY [--link[=&lt;boolean&gt;]] &lt;src&gt; ... &lt;dest&gt;</span><br></pre></td></tr></table></figure><p>下面的图片展示了添加<code>--link</code>选项和不添加这个选项时的区别，使用的dockerfile很简单</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> alpine</span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> foo /</span></span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> bar /</span></span><br></pre></td></tr></table></figure><p>使用link的时候，会从一个空镜像里面构建文件，再最终合并到原有镜像上。最终产生的是独立的blob镜像层，而不是<code>diff(快照1,快照2)</code>这种两个镜像层之间的diff文件。</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/07/919bea31fa7c37892d94c569cf17382b.png" alt="image.png"></p><h4 id="2-6-1-4-–parents"><a href="#2-6-1-4-–parents" class="headerlink" title="2.6.1.4. –parents"></a>2.6.1.4. –parents</h4><p>在拷贝文件的时候保留父目录。目前尚未在稳定版中推出此功能，需要使用<code>docker/dockerfile:1.7-labs</code>版本。</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">COPY</span><span class="language-bash"> [--parents[=&lt;boolean&gt;]] &lt;src&gt; ... &lt;dest&gt;</span></span><br></pre></td></tr></table></figure><p>举个例子，当我们使用如下语句，拷贝a.txt到镜像中时，最终会存在<code>/app/a.txt</code>文件</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">COPY</span><span class="language-bash"> ./b/a.txt /app/</span></span><br></pre></td></tr></table></figure><p>但如果加上了保留父目录的选项，则会保留这个txt文件的父目录b，最终会存在<code>/app/b/a.txt</code>文件</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">COPY</span><span class="language-bash"> --parents ./b/a.txt /app/</span></span><br></pre></td></tr></table></figure><p>在同时拷贝多个文件的时候，这样做就有效果了。如下所示，第一行的copy没有设置保留父目录，此时两个文件中的<code>a.txt</code>最终只在镜像内保留了一个（应该保留的是y的那一个），出现了文件被覆盖的问题。使用了<code>--parents</code>选项就不会有这个问题了。</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># syntax=docker/dockerfile:1.7-labs</span></span><br><span class="line"><span class="keyword">FROM</span> scratch</span><br><span class="line"></span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> ./x/a.txt ./y/a.txt /no_parents/</span></span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> --parents ./x/a.txt ./y/a.txt /parents/</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># /no_parents/a.txt</span></span><br><span class="line"><span class="comment"># /parents/x/a.txt</span></span><br><span class="line"><span class="comment"># /parents/y/a.txt</span></span><br></pre></td></tr></table></figure><h4 id="2-6-1-5-–excule"><a href="#2-6-1-5-–excule" class="headerlink" title="2.6.1.5. –excule"></a>2.6.1.5. –excule</h4><p>允许在拷贝的时候忽略某些路径中的内容。目前尚未在稳定版中推出此功能，需要使用<code>docker/dockerfile:1.7-labs</code>版本。</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">COPY</span><span class="language-bash"> [--exclude=&lt;path&gt; ...] &lt;src&gt; ... &lt;dest&gt;</span></span><br></pre></td></tr></table></figure><h2 id="2-7-ADD"><a href="#2-7-ADD" class="headerlink" title="2.7. ADD"></a>2.7. ADD</h2><p>ADD命令是更加高级的COPY命令，它有两种形式。如果路径中包含空格，则必须使用第二种形式（将路径使用英文双引号括起来）</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ADD</span><span class="language-bash"> [OPTIONS] &lt;src&gt; ... &lt;dest&gt;</span></span><br><span class="line"><span class="keyword">ADD</span><span class="language-bash"> [OPTIONS] [<span class="string">&quot;&lt;src&gt;&quot;</span>, ... <span class="string">&quot;&lt;dest&gt;&quot;</span>]</span></span><br></pre></td></tr></table></figure><p>当源文件是tar压缩文件，压缩方式为gzip、bzip或xz的情况下，ADD命令会自动将压缩包中的内容解压并复制到目标路径中。但是这个解压是不可以关闭的，即如果你不需要解压压缩包，则只能使用COPY命令。</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 将 archive.tar.gz 解压缩到镜像的 /app 目录</span></span><br><span class="line"><span class="keyword">ADD</span><span class="language-bash"> archive.tar.gz /app/</span></span><br><span class="line"><span class="comment"># 从 URL 下载文件并放在镜像的 /app 目录</span></span><br><span class="line"><span class="keyword">ADD</span><span class="language-bash"> https://example.com/file.txt /app/</span></span><br></pre></td></tr></table></figure><h3 id="2-7-1-选项说明"><a href="#2-7-1-选项说明" class="headerlink" title="2.7.1. 选项说明"></a>2.7.1. 选项说明</h3><p>下面是可选的OPTIONS</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">--keep-git-dir</span><br><span class="line">--checksum</span><br><span class="line">--chown</span><br><span class="line">--chmod</span><br><span class="line">--link</span><br><span class="line">--exclude</span><br></pre></td></tr></table></figure><h4 id="2-7-1-1-–keep-git-dir"><a href="#2-7-1-1-–keep-git-dir" class="headerlink" title="2.7.1.1. –keep-git-dir"></a>2.7.1.1. –keep-git-dir</h4><p> 默认情况下，如果src是一个git仓库连接，则ADD会忽略<code>.git</code>目录。将下面这个选项设置为true，则会保留<code>.git</code>目录</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">--keep-git-dir=&lt;boolean&gt; </span><br><span class="line"><span class="comment"># 示例</span></span><br><span class="line">ADD --keep-git-dir=<span class="literal">true</span> https://github.com/moby/buildkit.git<span class="comment">#v0.10.1 /buildkit</span></span><br></pre></td></tr></table></figure><h4 id="2-7-1-2-–checksum"><a href="#2-7-1-2-–checksum" class="headerlink" title="2.7.1.2. –checksum"></a>2.7.1.2. –checksum</h4><p>如果src是一个HTTP的连接（只支持HTTP&#x2F;HTTPS下载的文件），则可以使用checksum设置这个文件的校验和，ADD命令会在下载了文件之后自动进行校验，判断是否下载成功。</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ADD</span><span class="language-bash"> [--checksum=&lt;<span class="built_in">hash</span>&gt;] &lt;src&gt; ... &lt;<span class="built_in">dir</span>&gt;</span></span><br><span class="line"><span class="comment"># 示例</span></span><br><span class="line"><span class="keyword">ADD</span><span class="language-bash"> --checksum=sha256:24454f830cdb571e2c4ad15481119c43b3cafd48dd869a9b2945d1036d1dc68d https://mirrors.edge.kernel.org/pub/linux/kernel/Historic/linux-0.01.tar.gz /</span></span><br></pre></td></tr></table></figure><h4 id="2-7-1-3-剩余选项"><a href="#2-7-1-3-剩余选项" class="headerlink" title="2.7.1.3. 剩余选项"></a>2.7.1.3. 剩余选项</h4><p>剩下的几个选项，和COPY命令中的选项作用一致，详情可查看上文中对COPY命令的说明。</p><h2 id="2-8-CMD"><a href="#2-8-CMD" class="headerlink" title="2.8. CMD"></a>2.8. CMD</h2><p>CMD命令指定了容器以神马命令启动，同时它也可以是ENTRYPOINT的扩展</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 直接设置这个命令</span></span><br><span class="line"><span class="keyword">CMD</span><span class="language-bash"> executable param1 parma2</span></span><br><span class="line"><span class="comment"># 等价于上面这样直接设置</span></span><br><span class="line"><span class="keyword">CMD</span><span class="language-bash"> [<span class="string">&quot;executable&quot;</span>,<span class="string">&quot;param1&quot;</span>,<span class="string">&quot;param2&quot;</span>]</span></span><br><span class="line"><span class="comment"># 如果设置了ENTREPOINT，可以在后面使用CMD设置额外的命令选项（可以被docker run改变）</span></span><br><span class="line"><span class="comment"># 注意，ENTREPOINT必须采用exec格式才能使用CMD继续追加命令选项！</span></span><br><span class="line"><span class="keyword">CMD</span><span class="language-bash"> [<span class="string">&quot;param1&quot;</span>,<span class="string">&quot;param2&quot;</span>]</span></span><br></pre></td></tr></table></figure><p>如果一个容器没有指定ENTREPOINT或者CMD，则必须在docker run的时候指定才能正常运行。如果一个容器<strong>只指定了CMD</strong>，则可以被docker run指定的命令覆盖。</p><h2 id="2-9-ENTRYPOINT"><a href="#2-9-ENTRYPOINT" class="headerlink" title="2.9. ENTRYPOINT"></a>2.9. ENTRYPOINT</h2><p>ENTRYPOINT指定了容器以神马命令启动，同样有exec和shell两种格式。</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># exec格式</span></span><br><span class="line"><span class="comment"># 注意，ENTREPOINT必须采用exec格式才能使用CMD继续追加命令选项！</span></span><br><span class="line"><span class="keyword">ENTRYPOINT</span><span class="language-bash"> [<span class="string">&quot;executable&quot;</span>, <span class="string">&quot;param1&quot;</span>, <span class="string">&quot;param2&quot;</span>]</span></span><br><span class="line"><span class="comment"># shell格式</span></span><br><span class="line"><span class="keyword">ENTRYPOINT</span><span class="language-bash"> <span class="built_in">command</span> param1 param2</span></span><br></pre></td></tr></table></figure><p>设置了ENTRYPOINT后，在docker run里面提供的命令就不再是启动命令，而是发送给ENTRYPOINT命令的参数了。</p><p>前文提到了可以在ENTRYPOINT之后进一步设置CMD来启动进程，如下所示，下面这个dockerfile，最终启动进程使用的命令是<code>top -b -c</code>。其中<code>-c</code>选项会被docker run提供的命令覆盖（此时docker run提供的命令是发送给ENTRYPOINT命令的参数，会覆盖CMD）</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> ubuntu</span><br><span class="line"><span class="keyword">ENTRYPOINT</span><span class="language-bash"> [<span class="string">&quot;top&quot;</span>, <span class="string">&quot;-b&quot;</span>]</span></span><br><span class="line"><span class="keyword">CMD</span><span class="language-bash"> [<span class="string">&quot;-c&quot;</span>]</span></span><br></pre></td></tr></table></figure><p>我们可以写个自己的程序来验证一下这里的命令行参数</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc,<span class="type">char</span>*argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Run as: %s &quot;</span>,argv[<span class="number">0</span>]);</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i&lt;argc;i++)&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s &quot;</span>,argv[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个程序会把我们提供的命令行参数打印出来</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ gcc test.c -o test</span><br><span class="line">$ ./test -c -o</span><br><span class="line">Run as: ./test -c -o </span><br></pre></td></tr></table></figure><p>使用如下dockerfile来进行操作</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># syntax=docker/dockerfile:1</span></span><br><span class="line"><span class="keyword">FROM</span> alpine AS build</span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> . .</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> apk add clang</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> clang -o /test test.c</span></span><br><span class="line"><span class="keyword">ENTRYPOINT</span><span class="language-bash"> [<span class="string">&quot;/test&quot;</span>,<span class="string">&quot;-entry&quot;</span>]</span></span><br><span class="line"><span class="keyword">CMD</span><span class="language-bash"> [<span class="string">&quot;-cmd&quot;</span>]</span></span><br></pre></td></tr></table></figure><p>使用如下命令，可见CMD的参数会追加在原有命令行参数之后，而且会被docker run使用的命令覆盖。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ docker build . -t myub</span><br><span class="line">$ docker run myub</span><br><span class="line">Run as: /test -entry -cmd </span><br><span class="line">$ docker run myub -run -h</span><br><span class="line">Run as: /test -entry -run -h </span><br></pre></td></tr></table></figure><p>根据dockerfile的官方文档，你可以用ENTRYPOINT指定稳定的命令选项，并使用CMD指定一些可用的命令选项</p><blockquote><p>You can use the exec form of ENTRYPOINT to set fairly stable default commands and arguments and then use either form of CMD to set additional defaults that are more likely to be changed.</p></blockquote><h2 id="2-10-ARG和ENV"><a href="#2-10-ARG和ENV" class="headerlink" title="2.10. ARG和ENV"></a>2.10. ARG和ENV</h2><h3 id="2-10-1-介绍"><a href="#2-10-1-介绍" class="headerlink" title="2.10.1. 介绍"></a>2.10.1. 介绍</h3><p>在介绍的表格里面说明了这两个语法的区别</p><ul><li>ARG：设置镜像构建过程中使用的环境变量，只有构建过程中才有效，构建完成的镜像中不包括这个环境变量，可以在<code>docker build</code>中通过<code>--build-arg &lt;varname&gt;=&lt;value&gt;</code>覆盖；</li><li>ENV：构建过程和镜像中都会存在的环境变量，可以在<code>docker run</code>中通过<code>-e &lt;key&gt;=&lt;value&gt;</code>来覆盖；</li></ul><p>同时这两个命令的语法也有细微区别，即ARG可以省略环境变量的默认值（相当于要求build的时候传入）</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ARG</span> &lt;name&gt;[=&lt;default value&gt;]</span><br><span class="line"><span class="keyword">ENV</span> &lt;key&gt;=&lt;value&gt; ...</span><br></pre></td></tr></table></figure><h3 id="2-10-2-ENV测试"><a href="#2-10-2-ENV测试" class="headerlink" title="2.10.2. ENV测试"></a>2.10.2. ENV测试</h3><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> ubuntu:<span class="number">22.04</span></span><br><span class="line"><span class="comment"># env设置的环境变量，在构建过程和实际的容器中都会存在</span></span><br><span class="line"><span class="keyword">ENV</span> MY_VAR=from_dockerfile</span><br><span class="line"><span class="keyword">CMD</span><span class="language-bash"> <span class="built_in">echo</span> <span class="string">&quot;MY_VAR is <span class="variable">$&#123;MY_VAR&#125;</span>&quot;</span></span></span><br></pre></td></tr></table></figure><p>使用这个dockerfile构建一个镜像，并创建容器</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker build . -t myub:<span class="built_in">test</span> -f dockefile</span><br><span class="line">docker run --<span class="built_in">rm</span> myub:<span class="built_in">test</span>  <span class="comment"># --rm会在容器运行完毕后自动删除</span></span><br></pre></td></tr></table></figure><p>容器会在终端中输出我们刚刚设置的环境变量。注意这里我们是使用CMD命令来执行的这个echo语句，CMD是在容器创建之后，执行的命令，也就是ENV的设置已经保留到了容器中。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ docker run --rm myub:test</span><br><span class="line">MY_VAR is from_dockerfile</span><br></pre></td></tr></table></figure><p>使用<code>-it</code>交互式地创建这个容器，直接启动容器的bash终端。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -it --rm myub:test /bin/bash</span><br></pre></td></tr></table></figure><p>在容器内的终端中使用env命令也可以看到这个环境变量</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">root@7cab70963b65:/# env</span><br><span class="line">MY_VAR=from_dockerfile</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/07/42915bc3579a24611a1c599a5a34111f.png" alt="image.png"></p><p>在docker run命令中用<code>-e</code>选项，可以覆盖这个环境变量</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run --<span class="built_in">rm</span> -e MY_VAR=from_docker_run myub:<span class="built_in">test</span> </span><br></pre></td></tr></table></figure><p>执行效果如下，最终打印的环境变量是我们run命令中配置的了（容器内的环境变量也会被修改）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ docker run --rm -e MY_VAR=from_docker_run myub:test</span><br><span class="line">MY_VAR is from_docker_run</span><br></pre></td></tr></table></figure><p>修改dockerfile中的CMD为RUN，让echo命令在构建过程中执行</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> ubuntu:<span class="number">22.04</span></span><br><span class="line"><span class="comment"># env设置的环境变量，在构建过程和实际的容器中都会存在</span></span><br><span class="line"><span class="keyword">ENV</span> MY_VAR=from_dockerfile</span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> <span class="built_in">echo</span> <span class="string">&quot;MY_VAR is <span class="variable">$&#123;MY_VAR&#125;</span>&quot;</span></span></span><br></pre></td></tr></table></figure><p>可以看到，构建过程中，ENV环境变量也生效了，会打印一个<code>[RUN] echo &quot;RUN MY_VAR is from_dockerfile</code>。</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/07/178160d2912a0bdb3f056fada0ba1716.png" alt="image.png"></p><p>当然，生效的前提是ENV在RUN之前，如果ENV在RUN之后，那自然是无效了，打印的内容会变成<code>echo &quot;MY_VAR is $&#123;MY_VAR&#125;&quot;</code>这个原始内容。</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/07/c3270bc5e9800978ae8f56845f6d1797.png" alt="image.png"></p><p>另外，ENV指定的环境变量必须赋值初始值，否则语法会报错</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> ubuntu:<span class="number">22.04</span></span><br><span class="line"><span class="comment"># env设置的环境变量，在构建过程和实际的容器中都会存在</span></span><br><span class="line"><span class="comment"># 这里省略等于号是不支持的语法，如果不知道环境变量设置什么值，可以先等于空串</span></span><br><span class="line"><span class="keyword">ENV</span> MY_VAR </span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> <span class="built_in">echo</span> <span class="string">&quot;MY_VAR is <span class="variable">$&#123;MY_VAR&#125;</span>&quot;</span></span></span><br></pre></td></tr></table></figure><p>docker build的时候会提示语法错误，ENV必须要有两个参数（即必须要给定初始值）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">dockerfile:3</span><br><span class="line">--------------------</span><br><span class="line">   1 |     FROM ubuntu:22.04</span><br><span class="line">   2 |     # env设置的环境变量，在构建过程和实际的容器中都会存在</span><br><span class="line">   3 | &gt;&gt;&gt; ENV MY_VAR</span><br><span class="line">   4 |     RUN echo &quot;MY_VAR is $&#123;MY_VAR&#125;&quot;</span><br><span class="line">   5 |     </span><br><span class="line">--------------------</span><br><span class="line">ERROR: failed to solve: ENV must have two arguments</span><br></pre></td></tr></table></figure><h3 id="2-10-3-ARG测试"><a href="#2-10-3-ARG测试" class="headerlink" title="2.10.3. ARG测试"></a>2.10.3. ARG测试</h3><p>将ENV改成ARG，继续测试</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> ubuntu:<span class="number">22.04</span></span><br><span class="line"><span class="comment"># arg设置的环境变量，在构建过程中才会存在</span></span><br><span class="line"><span class="keyword">ARG</span> MY_VAR=from_dockerfile</span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> <span class="built_in">echo</span> <span class="string">&quot;MY_VAR is <span class="variable">$&#123;MY_VAR&#125;</span>&quot;</span></span></span><br></pre></td></tr></table></figure><p>可见环境变量在构建过程中生效了，打印<code>[RUN] echo &quot;RUN MY_VAR is from_dockerfile</code>。</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/07/0a9ed50597d6f6e35f426909a9f03b48.png" alt="image.png"></p><p>在docker build命令中可以覆盖dockerfile中设置的环境变量</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker build . -t myub --build-arg MY_VAR=from_docker_build</span><br></pre></td></tr></table></figure><p>可以观察到在build命令中设置的环境变量会覆盖dockerfile中的配置，打印的是<code>[RUN] echo &quot;RUN MY_VAR is from_docker_build</code>。</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/07/19045a7063d5d2b04c2a2c3f76b95184.png" alt="image.png"></p><p>另外，ARG设置的时候，环境变量之后是可以不带等于号的。此时相当于没有设置这个环境变量。</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> ubuntu:<span class="number">22.04</span></span><br><span class="line"><span class="comment"># arg设置的环境变量，在构建过程中才会存在</span></span><br><span class="line"><span class="keyword">ARG</span> MY_VAR</span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> <span class="built_in">echo</span> <span class="string">&quot;MY_VAR is <span class="variable">$&#123;MY_VAR&#125;</span>&quot;</span></span></span><br></pre></td></tr></table></figure><p>直接使用<code>docker build . -t myob</code>进行构建，打印的内容是<code>RUN echo &quot;MY_VAR is $&#123;MY_VAR&#125;&quot;</code>这个原始值，因为此时MY_VAR环境变量等于没有设置。必须通过build命令传值才会设置MY_VAR环境变量。</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/07/d456a37f4282fb622a60249fb4641a12.png" alt="image.png"></p><h2 id="2-11-VOLUME"><a href="#2-11-VOLUME" class="headerlink" title="2.11. VOLUME"></a>2.11. VOLUME</h2><p>在docker volume的解析中已经说明了数据卷的重要性。只要你的容器运行过程中，有需要持久化保存的重要数据，则都建议使用VOLUME在dockerfile中标出。这样即便用户没有主动绑定指定路径的数据卷，docker也会自动创建匿名数据卷来保存这里面的数据，不至于出现数据丢失问题。</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># exec格式</span></span><br><span class="line"><span class="keyword">VOLUME</span><span class="language-bash"> [<span class="string">&quot;/data&quot;</span>]</span></span><br><span class="line"><span class="comment"># shell格式，等价于[&quot;/data1&quot;,&quot;/data2&quot;]</span></span><br><span class="line"><span class="keyword">VOLUME</span><span class="language-bash"> /data1 /data2</span></span><br></pre></td></tr></table></figure><p>下面是官网上给出的一些说明。比如在json格式中，必须用双引号括起来目录名，不能使用单引号；volume的挂载是基于宿主机的，所以不能在dockerfile中指定最终挂载的host-dir，必须用户手动使用docker run命令来指定，或者由docker自行创建volume数据卷。</p><blockquote><p>Keep the following things in mind about volumes in the Dockerfile.</p><p>Volumes on Windows-based containers: When using Windows-based containers, the destination of a volume inside the container must be one of:</p><ul><li>a non-existing or empty directory</li><li>a drive other than <code>C:</code></li></ul><p>Changing the volume from within the Dockerfile: If any build steps change the data within the volume after it has been declared, those changes will be discarded.</p><p>JSON formatting: The list is parsed as a JSON array. You must enclose words with double quotes <code>(&quot;)</code> rather than single quotes <code>(&#39;)</code>.</p><p>The host directory is declared at container run-time: The host directory (the mountpoint) is, by its nature, host-dependent. This is to preserve image portability, since a given host directory can’t be guaranteed to be available on all hosts. For this reason, you can’t mount a host directory from within the Dockerfile. The VOLUME instruction does not support specifying a host-dir parameter. You must specify the mountpoint when you create or run the container.</p></blockquote><h2 id="2-12-EXPOSE"><a href="#2-12-EXPOSE" class="headerlink" title="2.12. EXPOSE"></a>2.12. EXPOSE</h2><p>指定容器需要对外提供服务的端口。比如nginx的80和443端口。且可以在dockerfile中设置默认绑定的端口值。</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">EXPOSE</span> &lt;port&gt; [&lt;port&gt;/&lt;protocol&gt;...]</span><br></pre></td></tr></table></figure><p>当一个EXPOSE的端口没有被用户设置，也没有默认值时，docker会自动绑定一个未被使用的端口给他。</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 暴露3000端口给外部（默认是tcp）</span></span><br><span class="line"><span class="keyword">EXPOSE</span> <span class="number">3000</span></span><br><span class="line"><span class="comment"># 暴露6000端口给外部，并设置默认绑定宿主机的60000端口</span></span><br><span class="line"><span class="keyword">EXPOSE</span> <span class="number">6000</span> <span class="number">60000</span>/tcp</span><br><span class="line"><span class="comment"># 暴露10000的udp端口给外部，并设置默认绑定宿主机的12000端口</span></span><br><span class="line"><span class="keyword">EXPOSE</span> <span class="number">10000</span>/udp <span class="number">12000</span>/udp</span><br></pre></td></tr></table></figure><p>注意，这里的默认绑定端口设置，只有在bridge模式创建容器的时候才会生效。如果用户使用host模式，那么就会采用<strong>原有端口</strong>（比如暴露6000端口，使用host模式就会直接绑定宿主机的6000端口，和默认值无关）绑定在宿主机上。</p><p>在host模式中，容器可以绑定宿主机的任意未使用端口，即便这些端口没有在EXPOSE中被设置。所以，如果你不想容器中的网络进程影响宿主机上的有效端口数量，则建议使用bridge模式来增强隔离性。</p><p>不管EXPOSE是如何设置的，在docker run中都可以被覆盖</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -p 80:80/tcp -p 80:80/udp ...</span><br></pre></td></tr></table></figure><p>另外，EXPOSE只是代表容器“想要”使用这些端口，最终端口的bind操作是由容器内的进程来处理的。当然，使用bridge选项时，docker引擎会帮容器先确认宿主机的端口可用并占用，再由容器内的进程bind容器内的端口，对外提供服务。</p><h2 id="2-13-ONBUILD"><a href="#2-13-ONBUILD" class="headerlink" title="2.13. ONBUILD"></a>2.13. ONBUILD</h2><p>ONBUILD指定的dockerfile语句会在尝试基于当前镜像构建镜像的时候被启用。</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ONBUILD</span> &lt;INSTRUCTION&gt;</span><br></pre></td></tr></table></figure><p>来测试一下</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> ubuntu:<span class="number">22.04</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> <span class="built_in">echo</span> <span class="string">&quot;running build&quot;</span></span></span><br><span class="line"><span class="keyword">ONBUILD</span> <span class="keyword">RUN</span><span class="language-bash"> <span class="built_in">echo</span> <span class="string">&quot;on build&quot;</span></span></span><br></pre></td></tr></table></figure><p>可以看到，构建的时候，只有不带<code>ONBUILD</code>选项的命令才被执行了，而带了ONBUILD的<code>echo &quot;on build&quot;</code>命令没有被执行。</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/07/769e9b38abe47a9d1a772a4775bbda6e.png" alt="image.png"></p><p>我们基于这个构建出来的镜像，再写一个dockerfile</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> myub:latest </span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> <span class="built_in">echo</span> <span class="string">&quot;running build from myub&quot;</span></span></span><br></pre></td></tr></table></figure><p>可以看到，构建过程会先执行父镜像ONBUILD设置的命令，再执行自己dockerfile中的命令，先打印的是<code>echo &quot;on build&quot;</code>，然后才打印<code>echo &quot;running build from myub&quot;</code>。</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/07/182ae6b6d386df0988ab3883ab8b9be6.png" alt="image.png"></p><h2 id="2-14-STOPSIGNAL"><a href="#2-14-STOPSIGNAL" class="headerlink" title="2.14. STOPSIGNAL"></a>2.14. STOPSIGNAL</h2><p>STOPSIGNAL设置docker内<strong>运行的进程</strong>在收到什么信号的时候会终止，即docker stop某个容器时，docker会给容器内进程发送的信号。</p><p>这里的signal可以是信号的名称（如<code>SIGKILL</code>）也可以是信号的编号。默认值是<code>SIGTERM</code>。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">STOPSIGNAL signal</span><br></pre></td></tr></table></figure><p>关于信号的编号和名称，可以在linux下使用<code>kill -l</code>命令查看</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">$ kill -l</span><br><span class="line"> 1) SIGHUP       2) SIGINT       3) SIGQUIT      4) SIGILL       5) SIGTRAP</span><br><span class="line"> 6) SIGABRT      7) SIGBUS       8) SIGFPE       9) SIGKILL     10) SIGUSR1</span><br><span class="line">11) SIGSEGV     12) SIGUSR2     13) SIGPIPE     14) SIGALRM     15) SIGTERM</span><br><span class="line">16) SIGSTKFLT   17) SIGCHLD     18) SIGCONT     19) SIGSTOP     20) SIGTSTP</span><br><span class="line">21) SIGTTIN     22) SIGTTOU     23) SIGURG      24) SIGXCPU     25) SIGXFSZ</span><br><span class="line">26) SIGVTALRM   27) SIGPROF     28) SIGWINCH    29) SIGIO       30) SIGPWR</span><br><span class="line">31) SIGSYS      34) SIGRTMIN    35) SIGRTMIN+1  36) SIGRTMIN+2  37) SIGRTMIN+3</span><br><span class="line">38) SIGRTMIN+4  39) SIGRTMIN+5  40) SIGRTMIN+6  41) SIGRTMIN+7  42) SIGRTMIN+8</span><br><span class="line">43) SIGRTMIN+9  44) SIGRTMIN+10 45) SIGRTMIN+11 46) SIGRTMIN+12 47) SIGRTMIN+13</span><br><span class="line">48) SIGRTMIN+14 49) SIGRTMIN+15 50) SIGRTMAX-14 51) SIGRTMAX-13 52) SIGRTMAX-12</span><br><span class="line">53) SIGRTMAX-11 54) SIGRTMAX-10 55) SIGRTMAX-9  56) SIGRTMAX-8  57) SIGRTMAX-7</span><br><span class="line">58) SIGRTMAX-6  59) SIGRTMAX-5  60) SIGRTMAX-4  61) SIGRTMAX-3  62) SIGRTMAX-2</span><br><span class="line">63) SIGRTMAX-1  64) SIGRTMAX</span><br></pre></td></tr></table></figure><p>在docker run和docker create中可以使用<code>--stop-signal</code>选项覆盖dockerfile中的设置。</p><h2 id="2-15-HEALTHCHECK"><a href="#2-15-HEALTHCHECK" class="headerlink" title="2.15. HEALTHCHECK"></a>2.15. HEALTHCHECK</h2><p><a href="https://docs.docker.com/reference/dockerfile/#healthcheck">https://docs.docker.com/reference/dockerfile/#healthcheck</a></p><p>用于检查容器的健康状态，如果检查失败（可以设置重试次数），则会将容器标记为<strong>不健康</strong>。这可以方便集群化管理，特别是解决某些容器内服务器进程虽然仍在运行，但因为某些原因已经无法提供服务的情况。</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 基础语法</span></span><br><span class="line"><span class="keyword">HEALTHCHECK</span><span class="language-bash"> [OPTIONS] CMD <span class="built_in">command</span></span></span><br><span class="line"><span class="comment"># 禁用健康检查，包括从父镜像继承下来的检查</span></span><br><span class="line"><span class="keyword">HEALTHCHECK</span><span class="language-bash"> NONE</span></span><br></pre></td></tr></table></figure><p>下面是一个示例，docker会每5分钟使用curl检查一下<code>http://localhost:8080/</code>是否可以被访问，如果超过3秒还没有反应，则认为它不能被访问。</p><p>当curl返回的状态码不是2xx&#x2F;3xx的时候，则exit 1表示不成功。告知HEALTHCHECK认为容器不健康。</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">HEALTHCHECK</span><span class="language-bash"> --interval=5m --<span class="built_in">timeout</span>=3s \</span></span><br><span class="line"><span class="language-bash">  CMD curl -f http://localhost:8080/ || <span class="built_in">exit</span> 1</span></span><br></pre></td></tr></table></figure><p>一次检查可能不太好，我们可以设置重试次数（<strong>默认会重试3次</strong>），下面就使用retries指定了重试两次</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">HEALTHCHECK</span><span class="language-bash"> --interval=5m --<span class="built_in">timeout</span>=3s --retries=2 \</span></span><br><span class="line"><span class="language-bash">  CMD curl -f http://localhost:8080/ || <span class="built_in">exit</span> 1</span></span><br></pre></td></tr></table></figure><h2 id="2-16-USER"><a href="#2-16-USER" class="headerlink" title="2.16. USER"></a>2.16. USER</h2><p>指定用于执行构建命令和最终执行CMD&#x2F;ENTRYPOINT命令使用的用户&#x2F;用户组。</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">USER</span> &lt;<span class="keyword">user</span>&gt;[:&lt;group&gt;]</span><br><span class="line"><span class="keyword">USER</span> UID[:GID]</span><br></pre></td></tr></table></figure><blockquote><p>Note that when specifying a group for the user, the user will have only the specified group membership. Any other configured group memberships will be ignored.</p></blockquote><h1 id="3-验证dockerfile命令对镜像层数的影响"><a href="#3-验证dockerfile命令对镜像层数的影响" class="headerlink" title="3. 验证dockerfile命令对镜像层数的影响"></a>3. 验证dockerfile命令对镜像层数的影响</h1><p>前文提到，dockerfile中的一条命令就是一层，如果冗余的命令过多，会让构建出来的dockerfile层级过多。下面通过一个例子来实际验证一下。</p><blockquote><p>参考 <a href="https://developer.aliyun.com/article/981453">Docker 进阶之镜像分层详解</a></p></blockquote><h2 id="3-1-查看基础镜像的层级"><a href="#3-1-查看基础镜像的层级" class="headerlink" title="3.1. 查看基础镜像的层级"></a>3.1. 查看基础镜像的层级</h2><p>测试基于<code>ubuntu:22.04</code>的镜像，首先使用<code>docker inspect</code>命令查看这个镜像的所有层</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker inspect ubuntu:22.04</span><br></pre></td></tr></table></figure><p>得到的结果如下，其中<code>RootFS/Layers</code>是这个镜像的所有层级。可见ubuntu的镜像只有一层。</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">[</span></span><br><span class="line">    <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;Id&quot;</span><span class="punctuation">:</span> <span class="string">&quot;sha256:52882761a72a60649edff9a2478835325d084fb640ea32a975e29e12a012025f&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;RepoTags&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">            <span class="string">&quot;ubuntu:22.04&quot;</span></span><br><span class="line">        <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;RepoDigests&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">            <span class="string">&quot;ubuntu@sha256:a6d2b38300ce017add71440577d5b0a90460d0e57fd7aec21dd0d1b0761bbfb2&quot;</span></span><br><span class="line">        <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;Parent&quot;</span><span class="punctuation">:</span> <span class="string">&quot;&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;Comment&quot;</span><span class="punctuation">:</span> <span class="string">&quot;&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;Created&quot;</span><span class="punctuation">:</span> <span class="string">&quot;2024-04-27T13:18:37.512234142Z&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;DockerVersion&quot;</span><span class="punctuation">:</span> <span class="string">&quot;24.0.5&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;Author&quot;</span><span class="punctuation">:</span> <span class="string">&quot;&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;Config&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;Hostname&quot;</span><span class="punctuation">:</span> <span class="string">&quot;&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;Domainname&quot;</span><span class="punctuation">:</span> <span class="string">&quot;&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;User&quot;</span><span class="punctuation">:</span> <span class="string">&quot;&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;AttachStdin&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">false</span></span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;AttachStdout&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">false</span></span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;AttachStderr&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">false</span></span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;Tty&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">false</span></span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;OpenStdin&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">false</span></span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;StdinOnce&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">false</span></span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;Env&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">                <span class="string">&quot;PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin&quot;</span></span><br><span class="line">            <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;Cmd&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">                <span class="string">&quot;/bin/bash&quot;</span></span><br><span class="line">            <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;Image&quot;</span><span class="punctuation">:</span> <span class="string">&quot;sha256:2252dc08ad59a3723b856050e7848a7fe152b469dd24cf30b0a910b7c615766c&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;Volumes&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">null</span></span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;WorkingDir&quot;</span><span class="punctuation">:</span> <span class="string">&quot;&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;Entrypoint&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">null</span></span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;OnBuild&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">null</span></span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;Labels&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">                <span class="attr">&quot;org.opencontainers.image.ref.name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;ubuntu&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;org.opencontainers.image.version&quot;</span><span class="punctuation">:</span> <span class="string">&quot;22.04&quot;</span></span><br><span class="line">            <span class="punctuation">&#125;</span></span><br><span class="line">        <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;Architecture&quot;</span><span class="punctuation">:</span> <span class="string">&quot;amd64&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;Os&quot;</span><span class="punctuation">:</span> <span class="string">&quot;linux&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;Size&quot;</span><span class="punctuation">:</span> <span class="number">77863352</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;GraphDriver&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;Data&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">                <span class="attr">&quot;MergedDir&quot;</span><span class="punctuation">:</span> <span class="string">&quot;/var/lib/docker/overlay2/fbc6cfc7d29a6660ebf2a172548649ec0ce6a2578f369a2076b13f6f8a1b375c/merged&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;UpperDir&quot;</span><span class="punctuation">:</span> <span class="string">&quot;/var/lib/docker/overlay2/fbc6cfc7d29a6660ebf2a172548649ec0ce6a2578f369a2076b13f6f8a1b375c/diff&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;WorkDir&quot;</span><span class="punctuation">:</span> <span class="string">&quot;/var/lib/docker/overlay2/fbc6cfc7d29a6660ebf2a172548649ec0ce6a2578f369a2076b13f6f8a1b375c/work&quot;</span></span><br><span class="line">            <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;Name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;overlay2&quot;</span></span><br><span class="line">        <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;RootFS&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;Type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;layers&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;Layers&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">                <span class="string">&quot;sha256:629ca62fb7c791374ce57626d6b8b62c76378be091a0daf1a60d32700b49add7&quot;</span></span><br><span class="line">            <span class="punctuation">]</span></span><br><span class="line">        <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;Metadata&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;LastTagTime&quot;</span><span class="punctuation">:</span> <span class="string">&quot;0001-01-01T00:00:00Z&quot;</span></span><br><span class="line">        <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">]</span></span><br></pre></td></tr></table></figure><p>通过docker history命令可以查看这个镜像的构建过程，虽然这里显示了多行，但实际上有效的行只有ADD了ubuntu的系统二进制文件的那一行，其他行都是对这个镜像的基础设置和元数据设置，并没有给镜像实际添加文件。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ docker history  ubuntu:22.04</span><br><span class="line">IMAGE          CREATED      CREATED BY                                      SIZE      COMMENT</span><br><span class="line">52882761a72a   9 days ago   /bin/sh -c #(nop)  CMD [&quot;/bin/bash&quot;]            0B        </span><br><span class="line">&lt;missing&gt;      9 days ago   /bin/sh -c #(nop) ADD file:a5d32dc2ab15ff0d7…   77.9MB    </span><br><span class="line">&lt;missing&gt;      9 days ago   /bin/sh -c #(nop)  LABEL org.opencontainers.…   0B        </span><br><span class="line">&lt;missing&gt;      9 days ago   /bin/sh -c #(nop)  LABEL org.opencontainers.…   0B        </span><br><span class="line">&lt;missing&gt;      9 days ago   /bin/sh -c #(nop)  ARG LAUNCHPAD_BUILD_ARCH     0B        </span><br><span class="line">&lt;missing&gt;      9 days ago   /bin/sh -c #(nop)  ARG RELEASE                  0B  </span><br></pre></td></tr></table></figure><h2 id="3-2-构建两个镜像"><a href="#3-2-构建两个镜像" class="headerlink" title="3.2. 构建两个镜像"></a>3.2. 构建两个镜像</h2><p>下面用两个dockerfile来基于ubuntu构建两个新的镜像。两个dockerfile执行的内容都是一致的，只不过第一个dockerfile中将命令都合并了，第二个dockerfile将命令拆分了。</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 构建myub:1</span></span><br><span class="line"><span class="keyword">FROM</span> ubuntu:<span class="number">22.04</span></span><br><span class="line"><span class="comment"># 在build-essential中会下载tzdata，会交互式的让用户选择时区</span></span><br><span class="line"><span class="comment"># 所以需要设置apt为非交互模式</span></span><br><span class="line"><span class="keyword">ARG</span> DEBIAN_FRONTEND=noninteractive</span><br><span class="line"><span class="keyword">ENV</span> TZ=Asia/Shanghai</span><br><span class="line"><span class="comment"># 更新和安装软件</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> apt-get -y update &amp;&amp; \</span></span><br><span class="line"><span class="language-bash">apt-get -y upgrade &amp;&amp; \</span></span><br><span class="line"><span class="language-bash">apt-get install -y \</span></span><br><span class="line"><span class="language-bash">cmake git vim curl wget \</span></span><br><span class="line"><span class="language-bash">net-tools \</span></span><br><span class="line"><span class="language-bash">openssh-server \</span></span><br><span class="line"><span class="language-bash">build-essential \</span></span><br><span class="line"><span class="language-bash">python3</span></span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/07/63b064c75ef93cd63201a46033c02e5b.png" alt="image.png"></p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 构建myub:2</span></span><br><span class="line"><span class="keyword">FROM</span> ubuntu:<span class="number">22.04</span></span><br><span class="line"><span class="comment"># 在build-essential中会下载tzdata，会交互式的让用户选择时区</span></span><br><span class="line"><span class="comment"># 所以需要设置apt为非交互模式</span></span><br><span class="line"><span class="keyword">ARG</span> DEBIAN_FRONTEND=noninteractive</span><br><span class="line"><span class="keyword">ENV</span> TZ=Asia/Shanghai</span><br><span class="line"><span class="comment"># 更新软件源</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> apt-get -y update</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> apt-get -y upgrade</span></span><br><span class="line"><span class="comment"># 安装一些常用工具</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> apt-get install -y \</span></span><br><span class="line"><span class="language-bash">cmake git vim curl wget \</span></span><br><span class="line"><span class="language-bash">net-tools openssh-server</span></span><br><span class="line"><span class="comment"># 安装依赖</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> apt-get install -y build-essential </span></span><br><span class="line"><span class="comment"># 安装python</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> apt-get install -y python3</span></span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/07/27c2753f592acd2b16e90f50c406c38d.png" alt="image.png"></p><h2 id="3-3-查看构建的两个镜像包含的层级"><a href="#3-3-查看构建的两个镜像包含的层级" class="headerlink" title="3.3. 查看构建的两个镜像包含的层级"></a>3.3. 查看构建的两个镜像包含的层级</h2><p>分别用<code>docker history</code>查看这两个镜像的层级，根据刚刚<code>docker build</code>命令的输出，以2b9f开头的是第一个镜像（命令都写一起了），以8156开头的是命令被拆分了的docker镜像。</p><p>这里能看到第一个现象，虽然两个镜像一个是被拆分的RUN构建出来的，另外一个并没有被拆分，但最终构建出来的镜像大小并没有明显的区别（其实只是本次测试的情况没有区别，其他情况下，一般合并命令构建出来的镜像会更小）。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ docker images</span><br><span class="line">REPOSITORY   TAG       IMAGE ID       CREATED         SIZE</span><br><span class="line">&lt;none&gt;       &lt;none&gt;    8156b17c21a3   2 minutes ago   598MB</span><br><span class="line">&lt;none&gt;       &lt;none&gt;    2b9f30d55cc3   9 minutes ago   596MB</span><br><span class="line">ubuntu       22.04     52882761a72a   9 days ago      77.9MB</span><br></pre></td></tr></table></figure><p>先给这两个镜像打个tag（最好是docker build的时候就用<code>-t</code>选项打tag，我忘记了）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker tag 2b9f30d55cc3 myub:1</span><br><span class="line">docker tag 8156b17c21a3 myub:2</span><br></pre></td></tr></table></figure><p>先来看命令合并的这个，可见它只在原有镜像的基础上，多了RUN命令的这一层。ARG&#x2F;ENV命令虽然会在history中被显示，但并不会增加层级。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">$ docker history myub:1</span><br><span class="line">IMAGE          CREATED          CREATED BY                                      SIZE      COMMENT</span><br><span class="line">2b9f30d55cc3   10 minutes ago   RUN |1 DEBIAN_FRONTEND=noninteractive /bin/s…   518MB     buildkit.dockerfile.v0</span><br><span class="line">&lt;missing&gt;      10 minutes ago   ENV TZ=Asia/Shanghai                            0B        buildkit.dockerfile.v0</span><br><span class="line">&lt;missing&gt;      10 minutes ago   ARG DEBIAN_FRONTEND=noninteractive              0B        buildkit.dockerfile.v0</span><br><span class="line">&lt;missing&gt;      9 days ago       /bin/sh -c #(nop)  CMD [&quot;/bin/bash&quot;]            0B        </span><br><span class="line">&lt;missing&gt;      9 days ago       /bin/sh -c #(nop) ADD file:a5d32dc2ab15ff0d7…   77.9MB    </span><br><span class="line">&lt;missing&gt;      9 days ago       /bin/sh -c #(nop)  LABEL org.opencontainers.…   0B        </span><br><span class="line">&lt;missing&gt;      9 days ago       /bin/sh -c #(nop)  LABEL org.opencontainers.…   0B        </span><br><span class="line">&lt;missing&gt;      9 days ago       /bin/sh -c #(nop)  ARG LAUNCHPAD_BUILD_ARCH     0B        </span><br><span class="line">&lt;missing&gt;      9 days ago       /bin/sh -c #(nop)  ARG RELEASE                  0B    </span><br></pre></td></tr></table></figure><p>通过docker inspect查看详细信息，在Layers中只能看到两层，即对应一条RUN命令创建出来的镜像层。</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line"><span class="attr">&quot;RootFS&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;Type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;layers&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;Layers&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">                <span class="string">&quot;sha256:629ca62fb7c791374ce57626d6b8b62c76378be091a0daf1a60d32700b49add7&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="string">&quot;sha256:2a381621675d1e9a462aa951211a3cf6938a480fcd82796cb18ef85234696014&quot;</span></span><br><span class="line">            <span class="punctuation">]</span></span><br><span class="line">        <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>再来看看命令被拆分的镜像，层数就多了起来</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">$ docker history myub:2</span><br><span class="line">IMAGE          CREATED         CREATED BY                                      SIZE      COMMENT</span><br><span class="line">8156b17c21a3   8 minutes ago   RUN |1 DEBIAN_FRONTEND=noninteractive /bin/s…   10.5kB    buildkit.dockerfile.v0</span><br><span class="line">&lt;missing&gt;      8 minutes ago   RUN |1 DEBIAN_FRONTEND=noninteractive /bin/s…   56.1MB    buildkit.dockerfile.v0</span><br><span class="line">&lt;missing&gt;      8 minutes ago   RUN |1 DEBIAN_FRONTEND=noninteractive /bin/s…   413MB     buildkit.dockerfile.v0</span><br><span class="line">&lt;missing&gt;      9 minutes ago   RUN |1 DEBIAN_FRONTEND=noninteractive /bin/s…   0B        buildkit.dockerfile.v0</span><br><span class="line">&lt;missing&gt;      9 minutes ago   RUN |1 DEBIAN_FRONTEND=noninteractive /bin/s…   50.9MB    buildkit.dockerfile.v0</span><br><span class="line">&lt;missing&gt;      9 minutes ago   ENV TZ=Asia/Shanghai                            0B        buildkit.dockerfile.v0</span><br><span class="line">&lt;missing&gt;      9 minutes ago   ARG DEBIAN_FRONTEND=noninteractive              0B        buildkit.dockerfile.v0</span><br><span class="line">&lt;missing&gt;      9 days ago      /bin/sh -c #(nop)  CMD [&quot;/bin/bash&quot;]            0B        </span><br><span class="line">&lt;missing&gt;      9 days ago      /bin/sh -c #(nop) ADD file:a5d32dc2ab15ff0d7…   77.9MB    </span><br><span class="line">&lt;missing&gt;      9 days ago      /bin/sh -c #(nop)  LABEL org.opencontainers.…   0B        </span><br><span class="line">&lt;missing&gt;      9 days ago      /bin/sh -c #(nop)  LABEL org.opencontainers.…   0B        </span><br><span class="line">&lt;missing&gt;      9 days ago      /bin/sh -c #(nop)  ARG LAUNCHPAD_BUILD_ARCH     0B        </span><br><span class="line">&lt;missing&gt;      9 days ago      /bin/sh -c #(nop)  ARG RELEASE                  0B  </span><br></pre></td></tr></table></figure><p><code>myub:2</code>相比<code>myub:1</code>额外多了4层，也对应的RUN命令的个数</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line"><span class="attr">&quot;RootFS&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;Type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;layers&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;Layers&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">                <span class="string">&quot;sha256:629ca62fb7c791374ce57626d6b8b62c76378be091a0daf1a60d32700b49add7&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="string">&quot;sha256:2ae784f0abd479326b00d2fbe2ba96a16e46056e386275d6f57988fe2ecf3034&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="string">&quot;sha256:fa903b82d02c9769bc58b795b9c1789a45dca63be57e81c7e15df3de2618bda0&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="string">&quot;sha256:3c2f1f7362025cbbb03b9a5760fc7fd72e940b1b768002ec6e15bc677e2657e4&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="string">&quot;sha256:86d0ee2ab97d64cee7d15598f4374bfe1ff940d89d945bbaf66e947e20068a1e&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="string">&quot;sha256:e72805c5ca21af8edf5f6d539da83e62c083436b1a58d00a394b2bf0b6be4a87&quot;</span></span><br><span class="line">            <span class="punctuation">]</span></span><br><span class="line">        <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><h2 id="3-4-分层的影响？"><a href="#3-4-分层的影响？" class="headerlink" title="3.4. 分层的影响？"></a>3.4. 分层的影响？</h2><p>先说结论：根据你的业务需要，选择合适的层数来构建docker镜像。</p><p>docker分层其中之一的目的，就是让构建镜像的时候能更多的<strong>用上缓存</strong>。假设构建容器A和容器B中有相同的操作，<strong>会构建出一个相同的镜像层</strong>，那么这个镜像层<strong>只需要存储一次就行了</strong>，而且下次执行相同的构建操作时，也可以直接使用这个缓存！容器运行的时候，这些镜像的<strong>只读层</strong>同样可以共享，节省了占用的空间。</p><p>所以，<strong>适当</strong>的加多RUN的层数，<strong>且将相同的构建命令放在同一个RUN中</strong>，是可以方便多个容器的构建的。因为单层RUN的缓存能被下一次相同的构建直接用上，构建效率提高！</p><p>同理，在pull拉取远程镜像的时候，如果某一层在本地已有了，也能直接使用本地已有缓存，避免重复拉取。这就好比APP的“增量更新”功能，镜像那么大，如果每一次都得全量下载，网络不好的时候就有的一等了。只拉取有变化的层数，能大大提高效率。</p><p>但是，如果层数太多，新增了太多的小层，那么每一个小层的变化都会使<strong>后续构建的缓存失效</strong>！具体场景也需要具体的考量！</p><h2 id="3-5-分层缓存测试"><a href="#3-5-分层缓存测试" class="headerlink" title="3.5. 分层缓存测试"></a>3.5. 分层缓存测试</h2><h3 id="3-5-1-拉取镜像缓存命中"><a href="#3-5-1-拉取镜像缓存命中" class="headerlink" title="3.5.1. 拉取镜像缓存命中"></a>3.5.1. 拉取镜像缓存命中</h3><p>当我们pull一个redis的6.2版本时，因为之前没有pull过，需要全量下载。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">$ docker pull redis:6.2                 </span><br><span class="line">6.2: Pulling from library/redis</span><br><span class="line">b0a0cf830b12: Pull complete </span><br><span class="line">57ad18570194: Pull complete </span><br><span class="line">056356a7a403: Pull complete </span><br><span class="line">c3351a5ba2a8: Pull complete </span><br><span class="line">1042efef0b42: Pull complete </span><br><span class="line">9f26115a8134: Pull complete </span><br><span class="line">4f4fb700ef54: Pull complete </span><br><span class="line">68d2d706a2f6: Pull complete </span><br><span class="line">Digest: sha256:d4948d011cc38e94f0aafb8f9a60309bd93034e07d10e0767af534512cf012a9</span><br><span class="line">Status: Downloaded newer image for redis:6.2</span><br><span class="line">docker.io/library/redis:6.2</span><br></pre></td></tr></table></figure><p>但当我们pull一个redis的7.0版本时，就不需要全量下载了，因为有一层和6.2版本是一致的，会显示<code>Already exists</code>，使用了本地缓存。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">$ docker pull redis:7.0</span><br><span class="line">7.0: Pulling from library/redis</span><br><span class="line">b0a0cf830b12: Already exists </span><br><span class="line">ea9699b63e68: Pull complete </span><br><span class="line">bf380b81aa96: Pull complete </span><br><span class="line">0164b64ea927: Pull complete </span><br><span class="line">e06189a3bd9d: Pull complete </span><br><span class="line">81fd2c0406f8: Pull complete </span><br><span class="line">4f4fb700ef54: Pull complete </span><br><span class="line">e3a29842ec15: Pull complete </span><br><span class="line">Digest: sha256:084f7275d9a3abc11d9f8905c3377e61e1464880af941b1eb68b8605863000e4</span><br><span class="line">Status: Downloaded newer image for redis:7.0</span><br><span class="line">docker.io/library/redis:7.0</span><br></pre></td></tr></table></figure><h3 id="3-5-2-构建缓存命中"><a href="#3-5-2-构建缓存命中" class="headerlink" title="3.5.2. 构建缓存命中"></a>3.5.2. 构建缓存命中</h3><p>先来看看构建缓存给命中的例子，来个dockerfile3，这里我们前几个命令都和上文构建<code>myub:2</code>使用的命令相同，但是最终安装的软件不同。</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 构建myub:3</span></span><br><span class="line"><span class="keyword">FROM</span> ubuntu:<span class="number">22.04</span></span><br><span class="line"><span class="comment"># 在build-essential中会下载tzdata，会交互式的让用户选择时区</span></span><br><span class="line"><span class="comment"># 所以需要设置apt为非交互模式</span></span><br><span class="line"><span class="keyword">ARG</span> DEBIAN_FRONTEND=noninteractive</span><br><span class="line"><span class="keyword">ENV</span> TZ=Asia/Shanghai</span><br><span class="line"><span class="comment"># 更新软件源</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> apt-get -y update</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> apt-get -y upgrade</span></span><br><span class="line"><span class="comment"># 安装一些常用工具</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> apt-get install -y \</span></span><br><span class="line"><span class="language-bash">python3 vim git cmake net-tools sqlite3</span></span><br></pre></td></tr></table></figure><p>在build的输出中可以看到，前两层<code>apt-get -y update</code>和<code>apt-get -y upgrade</code>直接命中了本地已有的缓存，会有一个<code>CACHED</code>的输出，代表此时无需再次构建！</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/07/89162d9895887d381a368e97f7926add.png" alt="image.png"></p><p>不过，<code>apt-get update/upgrade</code>这两个命令的结果是会随着ubuntu系统软件源的更新而进一步变化的。如果想获取最新的软件源，在docker build的时候，可以选择不使用本地的docker缓存，来构建最新的镜像。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker build --no-cache . -t imageName </span><br></pre></td></tr></table></figure><h3 id="3-5-3-构建缓存失效"><a href="#3-5-3-构建缓存失效" class="headerlink" title="3.5.3. 构建缓存失效"></a>3.5.3. 构建缓存失效</h3><p>再来看看什么时候缓存会失效。首先，如果将这里的<code>apt-get</code>命令合并，那么就无法使用本地的缓存了，还是需要重新拉取ubuntu的软件源，执行构建过程。</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 构建myub:4</span></span><br><span class="line"><span class="keyword">FROM</span> ubuntu:<span class="number">22.04</span></span><br><span class="line"><span class="comment"># 在build-essential中会下载tzdata，会交互式的让用户选择时区</span></span><br><span class="line"><span class="comment"># 所以需要设置apt为非交互模式</span></span><br><span class="line"><span class="keyword">ARG</span> DEBIAN_FRONTEND=noninteractive</span><br><span class="line"><span class="keyword">ENV</span> TZ=Asia/Shanghai</span><br><span class="line"><span class="comment"># 更新软件源</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> apt-get -y update &amp;&amp; \</span></span><br><span class="line"><span class="language-bash">apt-get -y upgrade &amp;&amp; \</span></span><br><span class="line"><span class="language-bash">apt-get install -y \</span></span><br><span class="line"><span class="language-bash">python3 vim git cmake net-tools sqlite3</span></span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/07/46f8a4287cf5627aa18fc67b179728df.png" alt="image.png"></p><p>而在原本构建<code>myub:2</code>的过程中，我们有很多的小层，这些小层的变化，同样会让这一层和下层的缓存都失效</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 构建myub:5</span></span><br><span class="line"><span class="keyword">FROM</span> ubuntu:<span class="number">22.04</span></span><br><span class="line"><span class="comment"># 在build-essential中会下载tzdata，会交互式的让用户选择时区</span></span><br><span class="line"><span class="comment"># 所以需要设置apt为非交互模式</span></span><br><span class="line"><span class="keyword">ARG</span> DEBIAN_FRONTEND=noninteractive</span><br><span class="line"><span class="keyword">ENV</span> TZ=Asia/Shanghai</span><br><span class="line"><span class="comment"># 更新软件源</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> apt-get -y update</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> apt-get -y upgrade</span></span><br><span class="line"><span class="comment"># 安装一些常用工具（这个小层和myub:2不同，多安装了sqlite3）</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> apt-get install -y \</span></span><br><span class="line"><span class="language-bash">cmake git vim curl wget \</span></span><br><span class="line"><span class="language-bash">net-tools openssh-server sqlite3</span></span><br><span class="line"><span class="comment"># 安装依赖</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> apt-get install -y build-essential </span></span><br><span class="line"><span class="comment"># 安装python</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> apt-get install -y python3</span></span><br></pre></td></tr></table></figure><p>可以看到，因为RUN命令中多安装了sqlite3，不光这一层需要重新构建，后面没有变动的两层同样需要重新构建，大大增加了构建耗时。</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/07/9243f568cf729a28fd1ae4f6f8f8c4f7.png" alt="image.png"></p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/07/95c6449bd4943ace8de5a4ea2f53a5e4.png" alt="image.png"></p><p>如果我们想新增一个sqlite3包，直接在最后添加一个新的命令，反而可以用上原本的缓存，飞速构建</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 构建myub:6</span></span><br><span class="line"><span class="keyword">FROM</span> ubuntu:<span class="number">22.04</span></span><br><span class="line"><span class="comment"># 在build-essential中会下载tzdata，会交互式的让用户选择时区</span></span><br><span class="line"><span class="comment"># 所以需要设置apt为非交互模式</span></span><br><span class="line"><span class="keyword">ARG</span> DEBIAN_FRONTEND=noninteractive</span><br><span class="line"><span class="keyword">ENV</span> TZ=Asia/Shanghai</span><br><span class="line"><span class="comment"># 更新软件源</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> apt-get -y update</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> apt-get -y upgrade</span></span><br><span class="line"><span class="comment"># 安装一些常用工具</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> apt-get install -y \</span></span><br><span class="line"><span class="language-bash">cmake git vim curl wget \</span></span><br><span class="line"><span class="language-bash">net-tools openssh-server</span></span><br><span class="line"><span class="comment"># 安装依赖</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> apt-get install -y build-essential </span></span><br><span class="line"><span class="comment"># 安装python</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> apt-get install -y python3</span></span><br><span class="line"><span class="comment"># 额外安装sqlite3</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> apt-get install -y sqlite3</span></span><br></pre></td></tr></table></figure><p>反应到结果上，就是前几层直接命中缓存，只有最后一个安装sqlite3的命令需要进行运行构建。</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/07/a40126981c119fc06da0912fc904fd6a.png" alt="image.png"></p><h1 id="4-如何减少docker构建镜像的大小？"><a href="#4-如何减少docker构建镜像的大小？" class="headerlink" title="4.如何减少docker构建镜像的大小？"></a>4.如何减少docker构建镜像的大小？</h1><p>参考：<a href="https://blog.csdn.net/qq_39213171/article/details/107789804">Dockerfile最小化构建镜像：减少层数、清理无用数据、多段构建</a></p>]]></content>
    
    
    <summary type="html">Docker学习第4话，学习编写dockerfile。</summary>
    
    
    
    <category term="编程学习" scheme="https://blog.musnow.top/categories/%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="Docker学习" scheme="https://blog.musnow.top/categories/%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0/Docker%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="Docker" scheme="https://blog.musnow.top/tags/Docker/"/>
    
  </entry>
  
  <entry>
    <title>【Docker】Docker学习03 | Docker的volume</title>
    <link href="https://blog.musnow.top/posts/2851039659/"/>
    <id>https://blog.musnow.top/posts/2851039659/</id>
    <published>2024-07-21T06:03:27.000Z</published>
    <updated>2024-07-25T12:22:38.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-引入"><a href="#1-引入" class="headerlink" title="1. 引入"></a>1. 引入</h1><p>在docker的基本知识讲解中，提到了docker镜像是由一层一层文件系统构成的。这一系列文件系统是一系列的<code>只读层</code>。当我们创建一个容器的时候，Docker会读取镜像（只读），并在镜像的顶部再添加一层<strong>读写层</strong>。</p><p>这种读写层和只读层的组合被称为<code>联合文件系统</code>（Union File System &#x2F; Unoin FS），结构抽象如下表所示，以防图片加载不出来。</p><table><thead><tr><th>层级</th><th>说明</th></tr></thead><tbody><tr><td>Running Container</td><td>正在运行的容器</td></tr><tr><td>Storage Driver</td><td>存储驱动层</td></tr><tr><td>write layer</td><td>读写层</td></tr><tr><td>image layer</td><td>镜像只读层</td></tr><tr><td>HOST</td><td>宿主机</td></tr></tbody></table><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/07/24a33dd11665a155144ee96587f745f4.png" alt="image.png"></p><p>如果正在运行的容器修改了现有的文件，这些文件会被拷贝出底层的只读层，放到最顶部的容器读写层中，读写层中文件的未修改版本仍然存放在镜像的只读层中。</p><table><thead><tr><th>层</th><th>文件</th><th>说明</th></tr></thead><tbody><tr><td>读写层</td><td>app.ini</td><td>当出现写操作的时候，从只读层中拷贝到读写层</td></tr><tr><td>只读层</td><td>app.ini</td><td></td></tr></tbody></table><p>当基于相同的镜像创建第二个容器时，还是会创建一个<strong>没有任何数据修改</strong>的全新容器。在之前的容器中的任何修改<strong>只会保留在原有容器</strong>中，实现了容器和镜像的隔离。</p><p>这种读写层的操作带来了以下的问题：</p><ol><li>当容器不再存在的时候，数据不持久化；</li><li>如果另外一个进程需要使用容器内的数据，难以将其从容器内取出；</li><li>容器的可写层与容器当前运行的宿主机紧密相连，难以将其移动到另外一台主机上；</li><li>写入容器的可写层需要存储驱动<code>Storage Dirver</code>来管理这个文件系统，存储驱动提供了一个使用Linux内核的联合文件系统；与直接将数据写入宿主机的文件系统的方式，这种额外的抽象层降低了性能。</li></ol><p>为了能持久化这些修改过的数据，并且能够很容易实现容器间进行数据的共享，docker提出了volume的概念，同时也提供了多种数据持久化的方式。</p><h1 id="2-docker提供的持久化策略"><a href="#2-docker提供的持久化策略" class="headerlink" title="2. docker提供的持久化策略"></a>2. docker提供的持久化策略</h1><p>docker提供两种文件持久化的策略，分别是volume和mount，其中mount还分为<code>bind mount</code>（将容器内路径和宿主机的文件路径绑定）和<code>tmpfs mount</code>（数据只存在于宿主机的内存中）。</p><p>通过volume和bind mount持久化的文件都可以称之为docker的数据卷。数据卷是在容器默认的联合文件系统之外的文件或目录，它可以在宿主机上直接被访问。即便容器删除，数据卷中的内容也不会丢失。</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/07/fdc07e592ab6ecbbe91ffcbdc1db123f.png" alt="image.png"></p><p>tips:</p><ul><li><strong>Volumes</strong> are stored in a part of the host filesystem which is managed by Docker (<code>/var/lib/docker/volumes/</code> on Linux). Non-Docker processes should not modify this part of the filesystem. Volumes are the best way to persist data in Docker.</li><li><strong>Bind mounts</strong> may be stored anywhere on the host system. They may even be important system files or directories. Non-Docker processes on the Docker host or a Docker container can modify them at any time.</li><li><strong>tmpfs mounts</strong> are stored in the host system’s memory only, and are never written to the host system’s filesystem.</li></ul><p>下文将对这三种不同的文件持久化方式进行测试</p><h1 id="3-volumes"><a href="#3-volumes" class="headerlink" title="3. volumes"></a>3. volumes</h1><h2 id="3-1-测试：自动创建的volume"><a href="#3-1-测试：自动创建的volume" class="headerlink" title="3.1. 测试：自动创建的volume"></a>3.1. 测试：自动创建的volume</h2><p>以<code>mysql:5.7</code>镜像为例，下面是一个创建容器的命令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">docker run -d \</span><br><span class="line">--name=<span class="string">&quot;testMysql&quot;</span> \</span><br><span class="line">-e MYSQL_ROOT_PASSWORD=<span class="string">&quot;123456&quot;</span> \</span><br><span class="line">mysql:5.7</span><br></pre></td></tr></table></figure><p>创建容器之前，先看看当前系统上的docker volume有哪些</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ docker volume ls</span><br><span class="line">DRIVER    VOLUME NAME</span><br><span class="line">local     53b8da5cc9f94a856e263d36ae69aea754be90a5a8b5b4848850af6e35503770</span><br><span class="line">local     act-toolcache</span><br></pre></td></tr></table></figure><p>执行了这个命令后，mysql容器被创建且正常运行，再次查看当前系统上的docker volume，可以发现多了一个新的volume。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">DRIVER    VOLUME NAME</span><br><span class="line">local     0cd65f1432c653ec08d7d8c3c50f645b97e0f26d139f1debb0c7fead3dafdfa4</span><br><span class="line">local     53b8da5cc9f94a856e263d36ae69aea754be90a5a8b5b4848850af6e35503770</span><br><span class="line">local     act-toolcache</span><br></pre></td></tr></table></figure><p>进入新创建的这个docker volume在宿主机上的路径，看看这里面有什么东西</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">❯ sudo ls -al /var/lib/docker/volumes/0cd65f1432c653ec08d7d8c3c50f645b97e0f26d139f1debb0c7fead3dafdfa4/_data</span><br><span class="line">total 188484</span><br><span class="line">drwxrwxrwt 5  999 docker     4096 May  6 16:56 .</span><br><span class="line">drwx-----x 3 root root       4096 May  6 16:56 ..</span><br><span class="line">-rw-r----- 1  999 docker       56 May  6 16:56 auto.cnf</span><br><span class="line">-rw------- 1  999 docker     1676 May  6 16:56 ca-key.pem</span><br><span class="line">-rw-r--r-- 1  999 docker     1112 May  6 16:56 ca.pem</span><br><span class="line">-rw-r--r-- 1  999 docker     1112 May  6 16:56 client-cert.pem</span><br><span class="line">-rw------- 1  999 docker     1676 May  6 16:56 client-key.pem</span><br><span class="line">-rw-r----- 1  999 docker     1318 May  6 16:56 ib_buffer_pool</span><br><span class="line">-rw-r----- 1  999 docker 79691776 May  6 16:56 ibdata1</span><br><span class="line">-rw-r----- 1  999 docker 50331648 May  6 16:56 ib_logfile0</span><br><span class="line">-rw-r----- 1  999 docker 50331648 May  6 16:56 ib_logfile1</span><br><span class="line">-rw-r----- 1  999 docker 12582912 May  6 16:56 ibtmp1</span><br><span class="line">drwxr-x--- 2  999 docker     4096 May  6 16:56 mysql</span><br><span class="line">lrwxrwxrwx 1  999 docker       27 May  6 16:56 mysql.sock -&gt; /var/run/mysqld/mysqld.sock</span><br><span class="line">drwxr-x--- 2  999 docker     4096 May  6 16:56 performance_schema</span><br><span class="line">-rw------- 1  999 docker     1680 May  6 16:56 private_key.pem</span><br><span class="line">-rw-r--r-- 1  999 docker      452 May  6 16:56 public_key.pem</span><br><span class="line">-rw-r--r-- 1  999 docker     1112 May  6 16:56 server-cert.pem</span><br><span class="line">-rw------- 1  999 docker     1676 May  6 16:56 server-key.pem</span><br><span class="line">drwxr-x--- 2  999 docker    12288 May  6 16:56 sys</span><br></pre></td></tr></table></figure><p>如果你对MySQL比较熟悉，应该就能认出来，这就是MySQL在<code>/var/lib/mysql</code>中存放的数据，我们可以做个简单的验证，使用如下命令，直接链接到这个新创建的容器的MySQL命令行中。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker <span class="built_in">exec</span> -it testMysql mysql -uroot -p123456</span><br></pre></td></tr></table></figure><p>我们在MySQL里面创建一个testdb数据库和一个stu表</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 创建数据库</span></span><br><span class="line"><span class="keyword">create</span> database testdb;</span><br><span class="line"><span class="comment">-- 进入testdb数据库</span></span><br><span class="line">use testdb;</span><br><span class="line"><span class="comment">-- 创建stu表</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> stu(</span><br><span class="line">id <span class="type">int</span> <span class="keyword">primary</span> key,</span><br><span class="line">name <span class="type">varchar</span>(<span class="number">30</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>操作完成后，exit退出容器，再次查看刚刚的volume目录。可以看到多了一个名为<code>testdb</code>的文件夹。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">❯ sudo ls -al /var/lib/docker/volumes/0cd65f1432c653ec08d7d8c3c50f645b97e0f26d139f1debb0c7fead3dafdfa4/_data</span><br><span class="line">total 188488</span><br><span class="line">drwxrwxrwt 6  999 docker     4096 May  6 17:15 .</span><br><span class="line">drwx-----x 3 root root       4096 May  6 16:56 ..</span><br><span class="line">-rw-r----- 1  999 docker       56 May  6 16:56 auto.cnf</span><br><span class="line">-rw------- 1  999 docker     1676 May  6 16:56 ca-key.pem</span><br><span class="line">-rw-r--r-- 1  999 docker     1112 May  6 16:56 ca.pem</span><br><span class="line">-rw-r--r-- 1  999 docker     1112 May  6 16:56 client-cert.pem</span><br><span class="line">-rw------- 1  999 docker     1676 May  6 16:56 client-key.pem</span><br><span class="line">-rw-r----- 1  999 docker     1318 May  6 16:56 ib_buffer_pool</span><br><span class="line">-rw-r----- 1  999 docker 79691776 May  6 17:15 ibdata1</span><br><span class="line">-rw-r----- 1  999 docker 50331648 May  6 17:15 ib_logfile0</span><br><span class="line">-rw-r----- 1  999 docker 50331648 May  6 16:56 ib_logfile1</span><br><span class="line">-rw-r----- 1  999 docker 12582912 May  6 16:56 ibtmp1</span><br><span class="line">drwxr-x--- 2  999 docker     4096 May  6 16:56 mysql</span><br><span class="line">lrwxrwxrwx 1  999 docker       27 May  6 16:56 mysql.sock -&gt; /var/run/mysqld/mysqld.sock</span><br><span class="line">drwxr-x--- 2  999 docker     4096 May  6 16:56 performance_schema</span><br><span class="line">-rw------- 1  999 docker     1680 May  6 16:56 private_key.pem</span><br><span class="line">-rw-r--r-- 1  999 docker      452 May  6 16:56 public_key.pem</span><br><span class="line">-rw-r--r-- 1  999 docker     1112 May  6 16:56 server-cert.pem</span><br><span class="line">-rw------- 1  999 docker     1676 May  6 16:56 server-key.pem</span><br><span class="line">drwxr-x--- 2  999 docker    12288 May  6 16:56 sys</span><br><span class="line">drwxr-x--- 2  999 docker     4096 May  6 17:15 testdb</span><br></pre></td></tr></table></figure><p>查看该文件夹，能看到刚刚我们创建的stu表的本地文件。可见这就是MySQL的本地路径。如果你在宿主机上直接使用apt安装一个MySQL&#x2F;MariaDB，也可以在宿主机的<code>/var/lib/mysql</code>中看到类似的文件。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">❯ sudo ls -al /var/lib/docker/volumes/0cd65f1432c653ec08d7d8c3c50f645b97e0f26d139f1debb0c7fead3dafdfa4/_data/testdb</span><br><span class="line">total 120</span><br><span class="line">drwxr-x--- 2 999 docker  4096 May  6 17:15 .</span><br><span class="line">drwxrwxrwt 6 999 docker  4096 May  6 17:15 ..</span><br><span class="line">-rw-r----- 1 999 docker    65 May  6 17:15 db.opt</span><br><span class="line">-rw-r----- 1 999 docker  8586 May  6 17:15 stu.frm</span><br><span class="line">-rw-r----- 1 999 docker 98304 May  6 17:15 stu.ibd</span><br></pre></td></tr></table></figure><p>通过<code>docker inspect testMysql</code>命令，可以查询到这个容器的配置详情，其中的Mount部分就有刚刚看到的volume，其中<code>Source</code>字段就是这个volume在宿主机上的路径，<code>Destination</code>字段是volume对应的容器内路径。</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;Mounts&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">            <span class="punctuation">&#123;</span></span><br><span class="line">                <span class="attr">&quot;Type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;volume&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;Name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;0cd65f1432c653ec08d7d8c3c50f645b97e0f26d139f1debb0c7fead3dafdfa4&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;Source&quot;</span><span class="punctuation">:</span> <span class="string">&quot;/var/lib/docker/volumes/0cd65f1432c653ec08d7d8c3c50f645b97e0f26d139f1debb0c7fead3dafdfa4/_data&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;Destination&quot;</span><span class="punctuation">:</span> <span class="string">&quot;/var/lib/mysql&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;Driver&quot;</span><span class="punctuation">:</span> <span class="string">&quot;local&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;Mode&quot;</span><span class="punctuation">:</span> <span class="string">&quot;&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;RW&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;Propagation&quot;</span><span class="punctuation">:</span> <span class="string">&quot;&quot;</span></span><br><span class="line">            <span class="punctuation">&#125;</span></span><br><span class="line">        <span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>再去找找<a href="https://github.com/docker-library/mysql/blob/master/Dockerfile.debian">MySQL容器的dockerfile</a>，也可以在里面看到一行关于<a href="https://github.com/docker-library/mysql/blob/e384941f162df943146e314f12097cf69c3609fa/Dockerfile.debian#L85">volume</a>的配置</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">VOLUME /var/lib/mysql</span><br></pre></td></tr></table></figure><p>由此可见，对于创建容器，如果没有在run命令中主动mount某个volume或路径时，docker会自动创建一个随机命名的volume（保持唯一性），并将容器内的路径和这个volume绑定。</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/07/6ef358884bc4f9af99bfc7ef5a530c4a.png" alt="image.png"></p><p>另外，一个volume的只能对应容器内的一个路径。如果容器在dockerfile中指定了多个不同路径的volume，则Docker也会创建多个volume与之对应。</p><h2 id="3-2-测试：主动指定volume"><a href="#3-2-测试：主动指定volume" class="headerlink" title="3.2. 测试：主动指定volume"></a>3.2. 测试：主动指定volume</h2><p>我们可以在run命令中指定容器路径和某个volume进行绑定，也可以写入一个volume的名字，在创建容器的同时创建这个volume。</p><p>下面这两种创建方式，都会在<code>/var/lib/docker/volumes</code>中创建一个名为<code>test_mysql_2</code>的volume。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建volume</span></span><br><span class="line">docker volume create test_mysql_2</span><br><span class="line"><span class="comment"># 绑定</span></span><br><span class="line">docker run -d \</span><br><span class="line">--name=<span class="string">&quot;testMysql2&quot;</span> \</span><br><span class="line">-v test_mysql_2:/var/lib/mysql \</span><br><span class="line">-e MYSQL_ROOT_PASSWORD=<span class="string">&quot;123456&quot;</span> \</span><br><span class="line">mysql:5.7</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建容器的时候直接创建volume</span></span><br><span class="line">docker run -d \</span><br><span class="line">--name=<span class="string">&quot;testMysql2&quot;</span> \</span><br><span class="line">-v test_mysql_2:/var/lib/mysql \</span><br><span class="line">-e MYSQL_ROOT_PASSWORD=<span class="string">&quot;123456&quot;</span> \</span><br><span class="line">mysql:5.7</span><br></pre></td></tr></table></figure><p>执行命令后，可以看到新创建出来的volume</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">❯ docker volume ls</span><br><span class="line">DRIVER    VOLUME NAME</span><br><span class="line">local     0cd65f1432c653ec08d7d8c3c50f645b97e0f26d139f1debb0c7fead3dafdfa4</span><br><span class="line">local     53b8da5cc9f94a856e263d36ae69aea754be90a5a8b5b4848850af6e35503770</span><br><span class="line">local     act-toolcache</span><br><span class="line">local     test_mysql_2</span><br></pre></td></tr></table></figure><p>通过<code>docker inspect testMysql2</code>命令，可以看到Mount中的信息</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;Mounts&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">            <span class="punctuation">&#123;</span></span><br><span class="line">                <span class="attr">&quot;Type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;volume&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;Name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;test_mysql_2&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;Source&quot;</span><span class="punctuation">:</span> <span class="string">&quot;/var/lib/docker/volumes/test_mysql_2/_data&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;Destination&quot;</span><span class="punctuation">:</span> <span class="string">&quot;/var/lib/mysql&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;Driver&quot;</span><span class="punctuation">:</span> <span class="string">&quot;local&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;Mode&quot;</span><span class="punctuation">:</span> <span class="string">&quot;z&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;RW&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;Propagation&quot;</span><span class="punctuation">:</span> <span class="string">&quot;&quot;</span></span><br><span class="line">            <span class="punctuation">&#125;</span></span><br><span class="line">        <span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><h2 id="3-3-绑定volume的权限选项"><a href="#3-3-绑定volume的权限选项" class="headerlink" title="3.3. 绑定volume的权限选项"></a>3.3. 绑定volume的权限选项</h2><p>这里能发现字段<code>Mode</code>有变化，由空串变成了小写的<code>z</code>。这个是什么意思呢？</p><ul><li><code>z</code>（小写）：代表绑定的目录由多个容器共享，其他容器也可以挂载这个volume；</li><li><code>Z</code>（大写）：代表绑定的目录由单个容器私有，其他容器无法挂载；</li></ul><p>在使用<code>-v</code>绑定某个路径的时候，可以在路径后面再添加一个选项，来指定权限和绑定模式。方式如下，在容器内路径后再追加一个冒号</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-v volume名字或宿主机路径:容器内路径:[权限选项]</span><br></pre></td></tr></table></figure><p>权限的可选项有四种，默认情况下，给定的是rw读写权限。</p><ul><li>大写Z</li><li>小写z</li><li>ro（只读）</li><li>rw（读写）</li></ul><p>其中<code>:z</code>和<code>:Z</code>选项是和SELinux有关的，具体可以参考<a href="https://docs.docker.com/reference/cli/docker/container/run/#volumes-from">官方文档</a>和<a href="https://linux.cn/article-14319-1.html">Linux中国</a>的文章。</p><blockquote><p>在Ubuntu上，SELinux工具集默认应该是没有启用的。</p></blockquote><p>注意，如果你使用<code>:Z</code>（大写）选项绑定了宿主机中诸如<code>/</code>、<code>/usr</code>、<code>/home</code>的目录，你可能会因为权限问题，直接无法使用宿主机！使用该选项的时候需要慎重！</p><h1 id="4-mount"><a href="#4-mount" class="headerlink" title="4. mount"></a>4. mount</h1><h2 id="4-1-bind-mount"><a href="#4-1-bind-mount" class="headerlink" title="4.1. bind mount"></a>4.1. bind mount</h2><h3 id="4-1-1-说明"><a href="#4-1-1-说明" class="headerlink" title="4.1.1. 说明"></a>4.1.1. 说明</h3><p>bind mount是docker早期就已经存在的数据持久化方式，其支持将容器的内的路径映射到某个宿主机上的路径，实现容器和宿主机文件的同步。绑定挂载直接使用了宿主机的文件系统，性能更佳。</p><p>绑定路径在docker run命令中和volume类似，都可以使用<code>-v</code>选项来实现</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-v 宿主机路径:容器内路径</span><br></pre></td></tr></table></figure><p>下面是一个示例</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用root用户，在宿主机上创建路径</span></span><br><span class="line"><span class="built_in">mkdir</span> /data/mysql</span><br><span class="line"><span class="comment"># docker容器绑定这个路径</span></span><br><span class="line">docker run -d \</span><br><span class="line">--name=<span class="string">&quot;testMysql3&quot;</span> \</span><br><span class="line">-v /data/mysql:/var/lib/mysql \</span><br><span class="line">-e MYSQL_ROOT_PASSWORD=<span class="string">&quot;123456&quot;</span> \</span><br><span class="line">mysql:5.7</span><br></pre></td></tr></table></figure><p>这样这个docker安装的MySQL容器内的所有数据都会被写入宿主机的<code>/data/mysql</code>路径中，我们可以直接备份这个路径实现对MySQL数据的保留。</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/07/04de1e3846636800c9e7f58c550065a3.png" alt="image.png"></p><h3 id="4-1-2-源路径的说明"><a href="#4-1-2-源路径的说明" class="headerlink" title="4.1.2. 源路径的说明"></a>4.1.2. 源路径的说明</h3><p>注意绑定挂载时<code>-v</code>选项中的<strong>路径</strong>和<strong>volume</strong>的区别。我们知道，在Linux命令行中，直接输入一个目录&#x2F;文件的名称，<strong>会默认是当前路径下的内容</strong>。</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd  folder   等价于 cd ./folder</span><br><span class="line">vim test.txt 等价于 vim ./test.txt</span><br></pre></td></tr></table></figure><p>而在docker run命令的<code>-v</code>选项中，源路径source输入直接为某个目录名的时候，会认为是volume的名称！而不是当前路径下的文件！</p><p>假设我们当前运行docker run的终端路径中有一个<strong>folder文件夹</strong>，我们想将这个文件夹映射到docker容器内的<code>/data</code>路径，推荐的写法如下（推荐使用绝对路径来设置源主机上的路径）。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-v $&#123;PWD&#125;/folder:/data</span><br></pre></td></tr></table></figure><p>错误的写法如下，直接写一个folder会以之为名<strong>创建一个新的volume</strong>，不符合我们的需要！</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-v folder:/data</span><br></pre></td></tr></table></figure><p>这一点在新建容器的时候一定要注意！个人推荐维持一个原则，即使用bind mount的时候一定要用<strong>绝对路径</strong>来设置宿主机上的文件路径。</p><h3 id="4-1-3-bind-mount的弊端"><a href="#4-1-3-bind-mount的弊端" class="headerlink" title="4.1.3. bind mount的弊端"></a>4.1.3. bind mount的弊端</h3><p>绑定挂载也有弊端</p><ul><li><strong>Bind mounts allow access to sensitive files</strong> One side effect of using bind mounts, for better or for worse, is that you can change the host filesystem via processes running in a container, including creating, modifying, or deleting important system files or directories. This is a powerful ability which can have security implications, including impacting non-Docker processes on the host system.</li></ul><p>翻译过来就是，绑定挂载（特别是以读写方式挂载）会让docker容器有权限修改宿主机的任何文件，甚至包括宿主机的系统文件。存在安全性问题。</p><p>这一点在<a href="https://linux.cn/article-14319-1.html">Linux中国</a>关于SELinux的文章中就有介绍，比如我们将宿主机的<code>/</code>路径直接绑定到容器的<code>/test</code>路径中时，使用<code>docker exec</code>进入这个容器的终端，我们会拥有<strong>容器内的root权限</strong>（即可以对当前登录的这个容器内的文件做任意修改），此时就直接可以通过编辑容器内的<code>/test</code>路径，来删除&#x2F;修改宿主机上的重要文件。</p><h3 id="4-1-4-docker-run-的-–mount-选项"><a href="#4-1-4-docker-run-的-–mount-选项" class="headerlink" title="4.1.4. docker run 的 –mount 选项"></a>4.1.4. docker run 的 –mount 选项</h3><p>除了<code>-v</code>选项，还可以用<code>--mount</code>选项来挂载数据卷，效果一致。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">docker run -d \</span><br><span class="line">--name=<span class="string">&quot;testMysql4&quot;</span> \</span><br><span class="line">--mount <span class="built_in">type</span>=<span class="built_in">bind</span>,<span class="built_in">source</span>=/data/mysql,target=/var/lib/mysql \</span><br><span class="line">-e MYSQL_ROOT_PASSWORD=<span class="string">&quot;123456&quot;</span> \</span><br><span class="line">mysql:5.7</span><br></pre></td></tr></table></figure><p>mount选项中，绑定的选项都用参数名写出来了，相对来说会更好理解，但是命令也变得复杂了。</p><table><thead><tr><th>key</th><th>value</th></tr></thead><tbody><tr><td>type</td><td>bind&#x2F;volume&#x2F;tmpfs</td></tr><tr><td>source&#x2F;src</td><td>docker host上的一个目录或文件</td></tr><tr><td>destination&#x2F;dst&#x2F;target</td><td>容器内的一个目录或文件</td></tr><tr><td>readonly</td><td>挂载为只读</td></tr><tr><td>option</td><td>额外选项</td></tr></tbody></table><p>如果需要指定readonly，直接在target后面添加该选项即可。添加了只读选项后，容器内对于这个路径就只能读，不能写入了。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">--mount type=bind,source=/data/mysql,target=/var/lib/mysql,readonly</span><br></pre></td></tr></table></figure><p>当使用mount选项来绑定volume的时候，<strong>可以省略type</strong>，此时docker会自动以source写入的字符串作为volume的名字，创建一个新volume并与当前容器进行绑定。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">docker run -d \</span><br><span class="line">--name=<span class="string">&quot;testMysql4&quot;</span> \</span><br><span class="line">--mount <span class="built_in">source</span>=mysql_vol,target=/var/lib/mysql \</span><br><span class="line">-e MYSQL_ROOT_PASSWORD=<span class="string">&quot;123456&quot;</span> \</span><br><span class="line">mysql:5.7</span><br></pre></td></tr></table></figure><h2 id="4-2-tmpfs-mount"><a href="#4-2-tmpfs-mount" class="headerlink" title="4.2. tmpfs mount"></a>4.2. tmpfs mount</h2><p>当容器为了性能原因，需要高频读写某些缓存文件（比如jellyfin镜像就有一个cache目录的volume，内部是一些缓存文件），或者为了安全性考虑不打算将一些数据写入磁盘的时候，我们可以使用tmpfs mount，将指定的路径绑定到宿主机的内存上。</p><p>对于nginx容器而言，其默认会有一个nginx的欢迎页面，存放在<code>/usr/share/nginx/html</code>路径中，这个欢迎页面可能会被经常的读取，占用空间也不大，所以我们可以将其放入内存中。</p><p>可以使用mount选项来进行绑定</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 直接绑定</span></span><br><span class="line">docker run -d -it \</span><br><span class="line">  -p 80:80 \</span><br><span class="line">  --name tmptest \</span><br><span class="line">  --mount <span class="built_in">type</span>=tmpfs,target=/usr/share/nginx/html \</span><br><span class="line">  nginx:latest</span><br><span class="line"><span class="comment"># 绑定时添加权限选项,1770代表全局可写</span></span><br><span class="line">docker run -d -it \</span><br><span class="line">  -p 80:80 \</span><br><span class="line">  --name tmptest \</span><br><span class="line">  --mount <span class="built_in">type</span>=tmpfs,target=/usr/share/nginx/html,tmpfs-mode=1770 \</span><br><span class="line">  nginx:latest</span><br></pre></td></tr></table></figure><p>也可以使用tmpfs选项来绑定</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">docker run -d -it \</span><br><span class="line">  -p 80:80 \</span><br><span class="line">  --name tmptest \</span><br><span class="line">  --tmpfs /usr/share/nginx/html \</span><br><span class="line">  nginx:latest</span><br></pre></td></tr></table></figure><p>更多相关的参数，可以参考docker的官方文档<a href="https://docs.docker.com/storage/tmpfs/">storage&#x2F;tmpfs</a>。</p><h2 id="4-3-bind-mount和volume的区别"><a href="#4-3-bind-mount和volume的区别" class="headerlink" title="4.3. bind mount和volume的区别"></a>4.3. bind mount和volume的区别</h2><p>docker官方其实一直都推荐我们使用volume来实现数据持久化，而不是使用bind mount。来看看二者的区别吧。</p><table><thead><tr><th>区别</th><th>bind mount</th><th>volume</th></tr></thead><tbody><tr><td>source位置</td><td>任意指定</td><td><code>/var/lib/docker/volumes</code></td></tr><tr><td>source路径为空</td><td>覆盖容器中的内容</td><td>容器内数据复制到volume</td></tr><tr><td>权限控制</td><td>读写&#x2F;只读</td><td>读写&#x2F;只读</td></tr><tr><td>单个文件</td><td>支持</td><td>不支持，只能是目录</td></tr><tr><td>移植性</td><td>弱,与hostpath绑定</td><td>强,无需指定hostpath</td></tr></tbody></table><h1 id="5-持久化和数据卷"><a href="#5-持久化和数据卷" class="headerlink" title="5. 持久化和数据卷"></a>5. 持久化和数据卷</h1><p>数据卷的最大特点是它的生命周期独立于容器的生命周期，即便容器被删除，<strong>数据卷中的内容也不会被删除</strong>（tmpfs除外，它的内容本来就没有写入磁盘）。当使用<code>docker rm</code>删除某个容器的时候，docker并不会主动删除和容器关联的数据卷。</p><ul><li>数据卷可在容器之间共享或重用数据。</li><li>数据卷的更改可以直接生效。</li><li>数据卷的生命周期一直持续到没有容器使用它为止。</li><li>对数据卷操作不会影响到镜像本身。</li><li>数据卷可以完成容器到宿主机、宿主机到容器以及容器到容器之间的数据共享。</li></ul><p>可见数据卷的好处还是多多的。所以，当你打算删除某个数据卷的时候，一定要确保这个数据卷里面的文件是完全无用了！</p><h1 id="6-参考文档"><a href="#6-参考文档" class="headerlink" title="6. 参考文档"></a>6. 参考文档</h1><ul><li><a href="https://colynn.github.io/2022-05-02-docker-volume/">理解并正确使用docker volume&#x2F;bind mount</a></li><li><a href="http://docker.baoshu.red/data_management/volume.html">docker volume详解</a></li><li><a href="https://blog.container-solutions.com/understanding-volumes-docker">Understanding Volumes in Docker</a></li></ul>]]></content>
    
    
    <summary type="html">Docker学习第3话，详解docker的volume</summary>
    
    
    
    <category term="编程学习" scheme="https://blog.musnow.top/categories/%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="Docker学习" scheme="https://blog.musnow.top/categories/%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0/Docker%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="Docker" scheme="https://blog.musnow.top/tags/Docker/"/>
    
  </entry>
  
  <entry>
    <title>【Docker】Docker学习02 | docker-cli的基本命令</title>
    <link href="https://blog.musnow.top/posts/347805151/"/>
    <id>https://blog.musnow.top/posts/347805151/</id>
    <published>2024-07-21T06:02:27.000Z</published>
    <updated>2024-08-23T23:11:39.000Z</updated>
    
    <content type="html"><![CDATA[<p>简单了解一下docker client的常用命令，更多命令可以查看<a href="https://www.runoob.com/docker/docker-command-manual.html">完整命令列表</a>。不同命令之间的关系，可以查看下图。</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/07/ae4ba91e6c24459450a04bf77a3208e4.png" alt="image.png"></p><p>如果你看不到图片，不用担心，后面对每个命令进行介绍的时候，会提到它们的作用的。</p><p>本文所述的所有命令都是<code>docker-cli</code>的命令（cli是client的缩写），它们本质上都是在和主机上的 docker engine 通信，获取结果。最终容器的运行管理，实际上都是由作为服务端的 docker engine 来处理的。所以在运行 docker-cli 命令之前，需要保证 docker engine  已经启动。一般的Linux系统上，都可以使用 systemctl 命令管理 docker engine 的服务。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl start docker</span><br></pre></td></tr></table></figure><h1 id="基础命令"><a href="#基础命令" class="headerlink" title="基础命令"></a>基础命令</h1><p>docker的帮助命令和基本信息</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker --<span class="built_in">help</span>  <span class="comment"># 查看帮助命令</span></span><br><span class="line">docker version <span class="comment"># 查看docker信息，会显示client和server的版本</span></span><br><span class="line">docker info <span class="comment"># 显示当前docker的详细信息，包括有几个容器等</span></span><br></pre></td></tr></table></figure><h1 id="镜像相关命令"><a href="#镜像相关命令" class="headerlink" title="镜像相关命令"></a>镜像相关命令</h1><h2 id="docker-pull"><a href="#docker-pull" class="headerlink" title="docker pull"></a>docker pull</h2><p>用于下载镜像，当不指定tag的时候，会默认拉取latest版本（大部分镜像都会维护一个tag为latest的镜像）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull 镜像名:tag</span><br></pre></td></tr></table></figure><p>如果你不知道某个镜像是否存在，可以用docker search命令来查询它。</p><h2 id="docker-images"><a href="#docker-images" class="headerlink" title="docker images"></a>docker images</h2><p>查看当前本地已有的镜像的相关信息</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker images</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/07/71334bf9b04c97e757138e3b39c651bd.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">❯ docker images</span><br><span class="line">REPOSITORY                TAG           IMAGE ID       CREATED         SIZE</span><br><span class="line">musnows/kook-ticket-bot   0.3.0         3033f09a7bb3   5 days ago      163MB</span><br><span class="line">musnows/kook-ticket-bot   latest        75f153e944da   5 days ago      163MB</span><br><span class="line">b3log/siyuan              v3.1.0        6498791aa636   2 weeks ago     225MB</span><br><span class="line">bitnami/minio             latest        02f75f2c3432   2 weeks ago     271MB</span><br><span class="line">neosmemo/memos            latest        5ddfb6978c7f   6 weeks ago     62.7MB</span><br></pre></td></tr></table></figure><p>另外，可以使用<code>docker images prune</code>快速删除所有未被容器使用且没有被tag的<strong>镜像层</strong>，如果想删除所有未被使用的镜像层，可以在这个命令后加上<code>-a</code>选项。</p><p>为什么需要清理呢？如果本地存在镜像层损坏，可能会影响新容器的构建和创建操作。可以尝试使用这个命令清理一下本地的镜像层。镜像层文件一般存放在<code>/var/lib/docker/overlay2</code>中。</p><p>注意，prune选项只是删除没有被使用的镜像层，但有些镜像的tag为none，但本身会和其他镜像共用镜像层，此时使用prune是不会清理掉这些镜像的。如果你想清理掉tag为none的镜像，可以使用如下命令快速清除。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker images -f <span class="string">&quot;dangling=true&quot;</span> -q | xargs docker rmi</span><br></pre></td></tr></table></figure><h2 id="docker-tag"><a href="#docker-tag" class="headerlink" title="docker tag"></a>docker tag</h2><p>该命令用于给一个已有的镜像设置一个tag（设置镜像的名字）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker tag 镜像id 命名镜像</span><br></pre></td></tr></table></figure><p>每个docker镜像都有个标识（镜像的完整名字），通常由仓库名、镜像名和标签组成。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">仓库名/镜像上传者名/镜像本身名字:tag</span><br></pre></td></tr></table></figure><p>且为了区分镜像的上传者，镜像名中通常以<strong>斜杠</strong>来分割镜像上传者和镜像本身的名字。默认情况下，使用的仓库都是官方的docker hub，所以镜像的<strong>仓库名会被省略</strong>。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">musnows/ImagesName:tag </span><br></pre></td></tr></table></figure><p>如果你使用了docker的镜像源（比如<a href="https://docker.nju.edu.cn/">南京大学</a>的镜像源），那么拉取下来的镜像中就会有仓库的名字。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker.nju.edu.cn/jellyfin/jellyfin:latest</span><br></pre></td></tr></table></figure><h2 id="docker-rmi"><a href="#docker-rmi" class="headerlink" title="docker rmi"></a>docker rmi</h2><p>可以使用<code>docker rmi</code>命令来删除某个镜像，需要提供镜像的<code>名字:tag</code>或者镜像的ID。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker rmi 镜像ID</span><br><span class="line">docker rmi 镜像名:tag</span><br></pre></td></tr></table></figure><p>如果要删除某个镜像，这个镜像必须没有关联的容器（需要先把关联的容器删除），才能被删除。否则删除请求会被拒绝。当然，可以使用<code>-f</code>选项来强制删除某个镜像。</p><p>另外，如果使用<code>镜像名:tag</code>的方式删除某个镜像时，并不一定会触发删除操作。因为同一个镜像可能会被打上多个tag，这时候只删除其中一个tag，相当于取消tag的操作。如果确定需要删除这个镜像，直接使用镜像的ID来删除是更好的办法。</p><p>如下所示，可以看到同一个镜像有两个不同的tag</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">REPOSITORY   TAG       IMAGE ID       CREATED        SIZE</span><br><span class="line">t            1         fa725ab19121   4 hours ago    432MB</span><br><span class="line">t            2         fa725ab19121   4 hours ago    432MB</span><br></pre></td></tr></table></figure><p>此时我们删除其中一个tag，可以看到返回的说明是<code>Untagged</code>，相当于是取消了对这个镜像的<code>t:1</code>这个tag。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ docker rmi t:1</span><br><span class="line">Untagged: t:1</span><br></pre></td></tr></table></figure><p>把<code>t:2</code>这个tag也给删除，才会真正删除镜像</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ docker rmi t:2 -f</span><br><span class="line">Untagged: t:2</span><br><span class="line">Deleted: sha256:fa725ab19121bd9c5628757049f5da5d4002f1ee10e41c4a87c33ab343d4ff28</span><br></pre></td></tr></table></figure><h2 id="docker-inspect"><a href="#docker-inspect" class="headerlink" title="docker inspect"></a>docker inspect</h2><p>这个命令用于查询某个容器&#x2F;镜像的元数据，会以json格式返回元数据</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker inspect [OPTIONS] NAME|ID [NAME|ID...]</span><br></pre></td></tr></table></figure><h2 id="docker-save-x2F-load"><a href="#docker-save-x2F-load" class="headerlink" title="docker save&#x2F;load"></a>docker save&#x2F;load</h2><p>docker save和docker load命令相对应，用于将一个镜像打包成tar格式的文件，方便在不同主机上进行传输。其他主机可以用load命令加载一个导出的镜像</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 打包本地镜像</span></span><br><span class="line">docker save linux:monitor -o linux-monitor.tar</span><br><span class="line"><span class="comment"># 在其他主机上加载镜像</span></span><br><span class="line">docker load -i linux-monitor.tar</span><br></pre></td></tr></table></figure><p>为了减少导出镜像的文件大小，还可以用gzip命令来压缩导出的镜像包的体积</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 通过管道，将docker save的结果传输给gzip工具，进行压缩</span></span><br><span class="line">docker save &lt;myimage&gt;:&lt;tag&gt; | gzip &gt; &lt;myimage&gt;_&lt;tag&gt;.tar.gz</span><br><span class="line"><span class="comment"># gzip解压之后，通过管道传输给docker load命令</span></span><br><span class="line">gunzip -c &lt;myimage&gt;_&lt;tag&gt;.tar.gz | docker load</span><br></pre></td></tr></table></figure><h2 id="【重点】docker-build"><a href="#【重点】docker-build" class="headerlink" title="【重点】docker build"></a>【重点】docker build</h2><p>docker build命令用于从docker file中构建一个docker的镜像，参考<a href="https://www.runoob.com/docker/docker-build-command.html">菜鸟教程</a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker build [OPTIONS] PATH | URL | -</span><br></pre></td></tr></table></figure><p>OPTIONS说明：</p><ul><li>–build-arg&#x3D;[] :设置镜像创建时的变量；</li><li>–cpu-shares :设置 cpu 使用权重；</li><li>–cpu-period :限制 CPU CFS周期；</li><li>–cpu-quota :限制 CPU CFS配额；</li><li>–cpuset-cpus :指定使用的CPU id；</li><li>–cpuset-mems :指定使用的内存 id；</li><li>–disable-content-trust :忽略校验，默认开启；</li><li>-f :指定要使用的Dockerfile路径；</li><li>–force-rm :设置镜像过程中删除中间容器；</li><li>–isolation :使用容器隔离技术；</li><li>–label&#x3D;[] :设置镜像使用的元数据；</li><li>-m :设置内存最大值；</li><li>–memory-swap :设置Swap的最大值为内存+swap，”-1”表示不限swap；</li><li><strong>–no-cache :创建镜像的过程不使用缓存</strong>；</li><li>–pull :尝试去更新镜像的新版本；</li><li>–quiet, -q :安静模式，成功后只输出镜像 ID；</li><li>–rm :设置镜像成功后删除中间容器；</li><li>–shm-size :设置&#x2F;dev&#x2F;shm的大小，默认值是64M；</li><li>–ulimit :Ulimit配置。</li><li>–squash :将 Dockerfile 中所有的操作压缩为一层。</li><li>–tag, -t: 镜像的名字及标签，通常 name:tag 或者 name 格式；可以在一次构建中为一个镜像设置多个标签。</li><li>–network: 默认 default。在构建期间设置RUN指令的默认网络模式；</li></ul><p>示例1：使用<code>.</code>当前路径下的dockerfile构建镜像，tag为<code>runoob/ubuntu:v1</code>。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker build -t runoob/ubuntu:v1 .</span><br></pre></td></tr></table></figure><p>示例2：使用指定路径<code>/path/to/a/Dockerfile</code>中的dockerfile，从<code>.</code>当前目录中<strong>指定上下文</strong>，【重点】Docker需要拷贝的内容是以命令中指定的<code>.</code><strong>当前目录</strong>为PWD进行dockerfile内相对路径计算的，构建镜像。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker build -f /path/to/a/Dockerfile .</span><br></pre></td></tr></table></figure><p>示例3：使用<code>-f</code>手动指定dockerfile的名字为<code>base.dockerfile</code>，并设置了docker镜像的默认网络模式是host，这个网络模式下docker容器会直接使用宿主机的端口。</p><p>如果没有指定dockerfile文件，默认会<strong>忽略大小写</strong>在当前目录下搜索名为<code>dockerfile</code>的文件。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker build --network host -f base.dockerfile .</span><br></pre></td></tr></table></figure><p>构建过程中可能遇到一些问题，比较常见的是和构建缓存还有上下文相关的，示例如下，报错中提到了<code>/install/grpc</code>文件不存在，这是因为当前指定的docker build上下文中没有办法被COPY到这个文件，需要检查你指定的docker构建上下文以及dockerfile中的相对路径是否正确。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ERROR: failed to solve: failed to compute cache key: failed to calculate checksum of ref 15c2f5bc-d5d7-4c81-9b8d-35af99494b3e::iuik026yg20qwxl8dajjkigru: <span class="string">&quot;/install/grpc&quot;</span>: not found</span><br></pre></td></tr></table></figure><p>还有另外一个问题是我在构建一个新镜像时遇到的，出现的场景在于上一次构建被我手动CTRL+C终止了，再次构建就会出现错误（即便build命令加上<code>--no-cache</code>选项也会失败）。这种大概率就是缓存损坏了，可以用如下方式清理一下本地的构建缓存。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 删除损害的构建缓存</span></span><br><span class="line">docker builder prune</span><br><span class="line"><span class="comment"># 删除所有未被使用的中间容器</span></span><br><span class="line">docker container prune</span><br><span class="line"><span class="comment"># 删除所有未被使用的镜像层</span></span><br><span class="line">docker image prune</span><br><span class="line"><span class="comment"># 删除所有tag为none的镜像</span></span><br><span class="line">docker images -f <span class="string">&quot;dangling=true&quot;</span> -q | xargs docker rmi</span><br></pre></td></tr></table></figure><h1 id="容器相关命令"><a href="#容器相关命令" class="headerlink" title="容器相关命令"></a>容器相关命令</h1><h2 id="docker-ps"><a href="#docker-ps" class="headerlink" title="docker ps"></a>docker ps</h2><p>查看当前正在运行的容器。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker ps</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/07/7212bae043d3d720edc43cd614582cab.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">❯ docker ps    </span><br><span class="line">CONTAINER ID   IMAGE                   COMMAND                  CREATED        STATUS          PORTS                                                                                      NAMES</span><br><span class="line">04fec1b6c345   b3log/siyuan:v3.1.0     &quot;/opt/siyuan/kernel …&quot;   2 weeks ago    Up 16 minutes   0.0.0.0:10060-&gt;6806/tcp, :::10060-&gt;6806/tcp, 0.0.0.0:10061-&gt;6808/tcp, :::10061-&gt;6808/tcp   siyuan</span><br><span class="line">69328f37ac26   bitnami/minio:latest    &quot;/opt/bitnami/script…&quot;   2 weeks ago    Up 16 minutes   0.0.0.0:9000-9001-&gt;9000-9001/tcp, :::9000-9001-&gt;9000-9001/tcp                              minio</span><br><span class="line">612786ac157c   neosmemo/memos:latest   &quot;./memos&quot;                5 weeks ago    Up 16 minutes   0.0.0.0:14710-&gt;5230/tcp, :::14710-&gt;5230/tcp                                                memos</span><br><span class="line">ffbdfb02af22   gitea/gitea:1.21.4      &quot;/usr/bin/entrypoint…&quot;   5 months ago   Up 16 minutes   127.0.0.1:2222-&gt;22/tcp, 0.0.0.0:30000-&gt;3000/tcp, :::30000-&gt;3000/tcp                        gitea                 </span><br></pre></td></tr></table></figure><p>使用<code>-a</code>选项可以看到所有容器，包括创建了但没有运行的容器（停止状态的容器）。</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/07/08a7b9e5f2885524380a9ed4b756fabb.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">❯ docker ps -a</span><br><span class="line">CONTAINER ID   IMAGE                          COMMAND                  CREATED        STATUS                      PORTS                                                                                      NAMES</span><br><span class="line">940156496e93   musnows/linux-monitor:latest   &quot;/bin/bash&quot;              24 hours ago   Exited (255) 13 hours ago                                                                                              linux_monitor</span><br><span class="line">04fec1b6c345   b3log/siyuan:v3.1.0            &quot;/opt/siyuan/kernel …&quot;   2 weeks ago    Up 16 minutes               0.0.0.0:10060-&gt;6806/tcp, :::10060-&gt;6806/tcp, 0.0.0.0:10061-&gt;6808/tcp, :::10061-&gt;6808/tcp   siyuan</span><br><span class="line">69328f37ac26   bitnami/minio:latest           &quot;/opt/bitnami/script…&quot;   2 weeks ago    Up 16 minutes               0.0.0.0:9000-9001-&gt;9000-9001/tcp, :::9000-9001-&gt;9000-9001/tcp                              minio</span><br><span class="line">612786ac157c   neosmemo/memos:latest          &quot;./memos&quot;                5 weeks ago    Up 16 minutes               0.0.0.0:14710-&gt;5230/tcp, :::14710-&gt;5230/tcp                                                memos</span><br><span class="line">e4c3decfa29d   halohub/halo:2.11.3            &quot;sh -c &#x27;java $&#123;JVM_O…&quot;   5 months ago   Exited (255) 5 months ago   0.0.0.0:18000-&gt;8090/tcp, :::18000-&gt;8090/tcp                                                halo</span><br><span class="line">ffbdfb02af22   gitea/gitea:1.21.4             &quot;/usr/bin/entrypoint…&quot;   5 months ago   Up 16 minutes               127.0.0.1:2222-&gt;22/tcp, 0.0.0.0:30000-&gt;3000/tcp, :::30000-&gt;3000/tcp                        gitea</span><br><span class="line">642c1a6c90d2   mysql:5.7                      &quot;docker-entrypoint.s…&quot;   5 months ago   Exited (255) 5 months ago   33060/tcp, 0.0.0.0:13306-&gt;3306/tcp, :::13306-&gt;3306/tcp                                     mysql57</span><br></pre></td></tr></table></figure><p>所有使用<strong>容器名</strong>操作的命令，都可以使用容器的<code>CONTAINER ID</code>进行操作，使用容器的<code>container id</code>是更好的选择，因为它是每个容器唯一的，不会重复。</p><h2 id="docker-start-x2F-stop-x2F-restart"><a href="#docker-start-x2F-stop-x2F-restart" class="headerlink" title="docker start&#x2F;stop&#x2F;restart"></a>docker start&#x2F;stop&#x2F;restart</h2><p>用于对某个容器进行操作，启动、停止、容器容器。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker start 容器名   <span class="comment"># 运行</span></span><br><span class="line">docker stop 容器名    <span class="comment"># 停止</span></span><br><span class="line">docker restart 容器名 <span class="comment"># 重启</span></span><br></pre></td></tr></table></figure><h2 id="docker-rm"><a href="#docker-rm" class="headerlink" title="docker rm"></a>docker rm</h2><p>这个命令用于删除某个容器。容器必须是停止状态才能被删除。同样可以使用<code>-f</code>选项强制删除某个正在运行的容器。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker <span class="built_in">rm</span> 容器名</span><br><span class="line">docker <span class="built_in">rm</span> 容器ID</span><br></pre></td></tr></table></figure><h2 id="docker-stats"><a href="#docker-stats" class="headerlink" title="docker stats"></a>docker stats</h2><p>这个命令可以查看当前正在运行的容器状态，包括容器占用的内存&#x2F;CPU百分比等性能信息</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker stats       <span class="comment"># 查看所有容器的运行状态</span></span><br><span class="line">docker stats 容器名 <span class="comment"># 查看某个容器的运行状态</span></span><br></pre></td></tr></table></figure><h2 id="docker-exec"><a href="#docker-exec" class="headerlink" title="docker exec"></a>docker exec</h2><p>这个命令用于进入某个正在运行的容器的终端，或者说是在某个容器中执行命令，<code>-it</code>选项代表以命令行交互与容器通信。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker <span class="built_in">exec</span> -it 容器名 需要执行的命令</span><br></pre></td></tr></table></figure><p>比如我们想进入<code>linux_monitor</code>容器的终端，使用的是如下命令。这个命令本质上是在容器内执行<code>/bin/bash</code>命令，相当于启动了一个容器内的bash终端。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker <span class="built_in">exec</span> -it linux_monitor /bin/bash</span><br></pre></td></tr></table></figure><p>如果我们想进入mysql容器内的mysql命令行，可以使用如下命令，相当于在名为<code>mysql57</code>的容器的终端中执行了<code>mysql -uroot -p123456</code>命令，这样能直接进入容器内的mysql终端。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker <span class="built_in">exec</span> -it mysql57 mysql -uroot -p123456</span><br></pre></td></tr></table></figure><p>如下所示，我们使用这个命令直接进入了mysql容器内的终端</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">❯ docker exec -it mysql57 mysql -uroot -p123456</span><br><span class="line">mysql: [Warning] Using a password on the command line interface can be insecure.</span><br><span class="line">Welcome to the MySQL monitor.  Commands end with ; or \g.</span><br><span class="line">Your MySQL connection id is 2</span><br><span class="line">Server version: 5.7.44 MySQL Community Server (GPL)</span><br><span class="line"></span><br><span class="line">Copyright (c) 2000, 2023, Oracle and/or its affiliates.</span><br><span class="line"></span><br><span class="line">Oracle is a registered trademark of Oracle Corporation and/or its</span><br><span class="line">affiliates. Other names may be trademarks of their respective</span><br><span class="line">owners.</span><br><span class="line"></span><br><span class="line">Type &#x27;help;&#x27; or &#x27;\h&#x27; for help. Type &#x27;\c&#x27; to clear the current input statement.</span><br><span class="line"></span><br><span class="line">mysql&gt; </span><br></pre></td></tr></table></figure><p>进入容器后，执行exit命令即会退出容器内的终端，回到宿主机的终端中。</p><p>注意，只有一个容器处于运行状态，才能使用 docker exec 进入到容器内终端中。</p><h2 id="docker-attach"><a href="#docker-attach" class="headerlink" title="docker attach"></a>docker attach</h2><p>想直接进入容器终端，还有另外一个命令。这个命令会直接进入容器内的终端。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker attach 容器名</span><br></pre></td></tr></table></figure><p>对比一下attach和exec命令</p><ul><li>attach 不会在容器中创建进程执行额外的命令，只是附着到容器上。</li><li>exec 会在运行的容器上<strong>创建进程执行新的命令</strong>。</li></ul><p>如果docker容器是使用<code>/bin/bash</code>作为shell启动的，则可以使用attach来直接访问它。如果不是，则需要在容器内创建一个bash的进程。</p><h2 id="docker-cp"><a href="#docker-cp" class="headerlink" title="docker cp"></a>docker cp</h2><p>从容器内拷贝文件到宿主机上，也可以从宿主机拷贝文件到容器内。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker <span class="built_in">cp</span> 容器<span class="built_in">id</span>:容器内路径 宿主机上的目的路径</span><br><span class="line">docker <span class="built_in">cp</span> 宿主机上的目的路径 容器<span class="built_in">id</span>:容器内路径</span><br></pre></td></tr></table></figure><h2 id="【重点】docker-run"><a href="#【重点】docker-run" class="headerlink" title="【重点】docker run"></a>【重点】docker run</h2><p>docker run 命令用于从镜像中创建一个容器，命令行参数参考<a href="https://www.runoob.com/docker/docker-run-command.html">菜鸟教程</a>。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run [OPTIONS] IMAGE [COMMAND] [ARG...]</span><br></pre></td></tr></table></figure><p>OPTIONS说明：</p><ul><li><strong>-a stdin:</strong> 指定标准输入输出内容类型，可选 STDIN&#x2F;STDOUT&#x2F;STDERR 三项；</li><li><strong>-d:</strong> 后台运行容器，并返回容器ID；</li><li><strong>-i:</strong> 以交互模式运行容器，通常与 -t 同时使用；</li><li><strong>-t:</strong> 为容器重新分配一个伪输入终端，通常与 -i 同时使用；</li><li><strong>-P:</strong> 随机端口映射，容器内部端口<strong>随机</strong>映射到主机的端口</li><li><strong>-p:</strong> 指定端口映射，格式为：主机(宿主)端口:容器端口</li><li><strong>–name&#x3D;”nginx-lb”:</strong> 为容器指定一个名称；</li><li><strong>–dns 8.8.8.8:</strong> 指定容器使用的DNS服务器，默认和宿主一致；</li><li><strong>–dns-search example.com:</strong> 指定容器DNS搜索域名，默认和宿主一致；</li><li><strong>-h “mars”:</strong> 指定容器的hostname；</li><li><strong>-e username&#x3D;”ritchie”:</strong> 设置环境变量；</li><li><strong>–env-file&#x3D;[]:</strong> 从指定文件读入环境变量；</li><li><strong>–cpuset&#x3D;”0-2” or –cpuset&#x3D;”0,1,2”:</strong> 绑定容器到指定CPU运行；</li><li><strong>-m</strong>:设置容器使用内存最大值；</li><li><strong>–net&#x3D;”bridge”:</strong> 指定容器的网络连接类型，支持 bridge&#x2F;host&#x2F;none&#x2F;container: 四种类型</li><li><strong>–link&#x3D;[]:</strong> 添加链接到另一个容器；</li><li><strong>–expose&#x3D;[]:</strong> 开放一个端口或一组端口；</li><li><strong>–volume , -v:</strong> 绑定一个卷</li><li><strong>–rm</strong>：当容器内程序退出的时候，自动删除容器，用于测试运行。不能和<code>-d</code>一起使用。</li></ul><p>示例：使用nginx镜像创建一个容器，并在后台运行。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker run -d \</span><br><span class="line">--name mynginx </span><br><span class="line">nginx:latest</span><br></pre></td></tr></table></figure><p>当默认创建一个容器的时候，docker会给这个容器创建一个卷（volumes），就好比虚拟机的虚拟磁盘。当某个容器被删除，和它关联的卷也就失效了。所以，如果你在容器内部对容器运行的程序做了配置上的修改，删除这个容器后就会失效。</p><p>为了避免这种情况，我们一般都会将容器中的某个存放配置文件和数据的路径给<strong>映射</strong>到宿主机，这样容器对这个路径的修改就会直接写入到宿主机的文件系统中（持久化），即便容器删除也不会影响。</p><p>比如nginx的配置文件都在<code>/etc/nginx</code>中，我们可以把这个目录映射到宿主机的<code>/root/docker/nginx</code>路径中（冒号左侧是宿主机的路径，冒号右侧是容器内的路径），这样就可以直接通过修改宿主机中的路径来修改容器中nginx的配置，同时nginx容器的配置也实现了持久化，即便容器删除也不会丢失。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">docker run -d \</span><br><span class="line">--name mynginx \</span><br><span class="line">-v /root/docker/nginx:/etc/nginx</span><br><span class="line">nginx:latest</span><br></pre></td></tr></table></figure><p>当前状态下我们没有设置这个容器的网络环境，一般情况下，容器都会以默认的bridge桥接网络链接到宿主机中，即容器是通过宿主机的网卡做桥接（类似于虚拟机的NAT模式）上网的。</p><p>比如上方配置的nginx容器，它并不会对宿主机的80&#x2F;443端口收到的请求做任何操作，因为它监听的是容器内的80和443端口，而这两个端口并没有映射到宿主机上。如果我们想让容器能处理宿主机收到的数据，则需要进行容器的<strong>端口映射</strong>。</p><p>如下所示，我们使用了两个<code>-p</code>选项，分别映射了80端口和443端口到宿主机的80和443端口（冒号左侧是宿主机的端口，右侧是容器内的端口），此时使用的是默认的bridge桥接方式接通了容器和宿主机的网络端口。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">docker run -d \</span><br><span class="line">--name mynginx \</span><br><span class="line">-v /root/docker/nginx:/etc/nginx \</span><br><span class="line">-p 80:80 \</span><br><span class="line">-p 443:443 \</span><br><span class="line">nginx:latest</span><br></pre></td></tr></table></figure><p>当然，也可以直接用host网络模式运行nginx容器，这样nginx默认绑定的80和443就是直接绑定的宿主机的端口了。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">docker run -d \</span><br><span class="line">--name mynginx \</span><br><span class="line">-v /root/docker/nginx:/etc/nginx \</span><br><span class="line">--net=&quot;host&quot; \</span><br><span class="line">nginx:latest</span><br></pre></td></tr></table></figure><p>关于docker run中<code>-v</code>命令和<code>--mount</code>命令以及绑定数据卷的说明，请参考<a href="https://blog.musnow.top/posts/2851039659">docker volume</a>中的介绍。</p><h2 id="docker-volume"><a href="#docker-volume" class="headerlink" title="docker volume"></a>docker volume</h2><p>volume是docker中的数据卷，可以用下方的命令来操作这些数据卷。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">docker volume <span class="built_in">ls</span>               <span class="comment"># 查看所有数据卷</span></span><br><span class="line">docker volume <span class="built_in">rm</span> 数据卷ID       <span class="comment"># 删除某个卷</span></span><br><span class="line">docker volume inspect 数据卷ID  <span class="comment"># 查看某个数据卷的详细信息</span></span><br><span class="line">docker volume prune            <span class="comment"># 删除没有使用的数据卷</span></span><br><span class="line">docker volume create 数据卷名字  <span class="comment"># 创建卷</span></span><br></pre></td></tr></table></figure><p>关于数据卷的知识，可以看<a href="https://blog.musnow.top/posts/2851039659">docker volume</a>的介绍。</p><h2 id="docker-logs"><a href="#docker-logs" class="headerlink" title="docker logs"></a>docker logs</h2><p>docker logs可以查看某个容器的日志输出，用于定位容器运行产生的问题。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker logs 容器ID</span><br><span class="line">docker logs 容器名</span><br></pre></td></tr></table></figure><p>比较常用的选项就是<code>--tail</code>，用于显示最新的几行命令，避免容器内的日志过长，打印耗时太久。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 只显示最新20行的日志</span></span><br><span class="line">docker logs 容器ID --<span class="built_in">tail</span>=20</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">Docker学习第2话，docker-cli的基本命令</summary>
    
    
    
    <category term="编程学习" scheme="https://blog.musnow.top/categories/%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="Docker学习" scheme="https://blog.musnow.top/categories/%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0/Docker%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="Docker" scheme="https://blog.musnow.top/tags/Docker/"/>
    
  </entry>
  
</feed>
