<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>慕雪的寒舍</title>
  
  <subtitle>雪下了一夜</subtitle>
  <link href="https://blog.musnow.top/atom.xml" rel="self"/>
  
  <link href="https://blog.musnow.top/"/>
  <updated>2023-09-01T10:12:55.000Z</updated>
  <id>https://blog.musnow.top/</id>
  
  <author>
    <name>慕雪年华</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>【Linux】root和子用户都能执行的命令，sudo无法执行（已解决）</title>
    <link href="https://blog.musnow.top/posts/2473452644/"/>
    <id>https://blog.musnow.top/posts/2473452644/</id>
    <published>2023-09-01T10:12:55.000Z</published>
    <updated>2023-09-01T10:12:55.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>全流程帖子 <a href="https://ask.oceanbase.com/t/topic/35604437/7">https://ask.oceanbase.com/t/topic/35604437/7</a></p></blockquote><h1 id="1-问题"><a href="#1-问题" class="headerlink" title="1.问题"></a>1.问题</h1><p>如题，在编译miniob的时候遇到如下错误</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[mu@vm-cnt8:~/code/miniob]$ sudo bash build.sh init</span><br><span class="line">build.sh init</span><br><span class="line">HEAD is now at 5df3037d Merge branch <span class="string">&#x27;release-2.1.12-stable-pull&#x27;</span> into patches-2.1</span><br><span class="line">build.sh: line 83: cmake: <span class="built_in">command</span> not found</span><br><span class="line">build.sh: line 91: cmake: <span class="built_in">command</span> not found</span><br><span class="line">build.sh: line 99: cmake: <span class="built_in">command</span> not found</span><br><span class="line">build.sh: line 107: cmake: <span class="built_in">command</span> not found</span><br></pre></td></tr></table></figure><p>根据字面意思，是cmake命令找不到，但是我的系统里面已经有了符合条件的环境；以下是gihub&#x2F;miniob仓库中docs里面<code>how_to_build.md</code>的内容</p><blockquote><p>MiniOB 需要使用：</p><ul><li>cmake 版本 &gt;&#x3D; 3.13</li><li>gcc&#x2F;clang gcc建议8.3以上，编译器需要支持c++20新标准</li><li>flex (2.5+), bison (3.7+) 用于生成词法语法分析代码</li></ul></blockquote><p>我使用的系统是centos8-steam的vmware虚拟机；当前使用的miniob的commit为</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">76221e46e66ef408771ce886aa0c586a09374b0d</span><br></pre></td></tr></table></figure><p>以下是我的系统中各个依赖项的版本号，可以看到在子用户中，依赖项的所有命令都可以正常执行</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">[mu@vm-cnt8:~/code/miniob]$ gcc --version</span><br><span class="line">gcc (GCC) 8.5.0 20210514 (Red Hat 8.5.0-20)</span><br><span class="line">Copyright (C) 2018 Free Software Foundation, Inc.</span><br><span class="line">This is free software; see the <span class="built_in">source</span> <span class="keyword">for</span> copying conditions.  There is NO</span><br><span class="line">warranty; not even <span class="keyword">for</span> MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.</span><br><span class="line"></span><br><span class="line">[mu@vm-cnt8:~/code/miniob]$ cmake --version</span><br><span class="line">cmake version 3.27.4</span><br><span class="line"></span><br><span class="line">CMake suite maintained and supported by Kitware (kitware.com/cmake).</span><br><span class="line">[mu@vm-cnt8:~/code/miniob]$ flex --version</span><br><span class="line">flex 2.6.1</span><br><span class="line">[mu@vm-cnt8:~/code/miniob]$ bison --version</span><br><span class="line">bison (GNU Bison) 3.8</span><br><span class="line">Written by Robert Corbett and Richard Stallman.</span><br><span class="line"></span><br><span class="line">Copyright (C) 2021 Free Software Foundation, Inc.</span><br><span class="line">This is free software; see the <span class="built_in">source</span> <span class="keyword">for</span> copying conditions.  There is NO</span><br><span class="line">warranty; not even <span class="keyword">for</span> MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.</span><br></pre></td></tr></table></figure><p>在root中，也可以正常执行这些命令</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">[root@vm-cnt8:~]# cmake --version</span><br><span class="line">cmake version 3.27.4</span><br><span class="line"></span><br><span class="line">CMake suite maintained and supported by Kitware (kitware.com/cmake).</span><br><span class="line">[root@vm-cnt8:~]# flex --version</span><br><span class="line">flex 2.6.1</span><br><span class="line">[root@vm-cnt8:~]# bison --version</span><br><span class="line">bison (GNU Bison) 3.8</span><br><span class="line">Written by Robert Corbett and Richard Stallman.</span><br><span class="line"></span><br><span class="line">Copyright (C) 2021 Free Software Foundation, Inc.</span><br><span class="line">This is free software; see the source for copying conditions.  There is NO</span><br><span class="line">warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.</span><br></pre></td></tr></table></figure><p>但是sudo执行miniob的安装脚本的时候，却找不到cmake命令</p><h1 id="2-debug过程"><a href="#2-debug过程" class="headerlink" title="2.debug过程"></a>2.debug过程</h1><p>经过大佬的教学，知道了一个新的sudo用法：<code>sudo -E</code></p><blockquote><p><code>sudo -E</code> 是继承当前用户的环境变量运行sudo后面的命令，否则环境变量会被清理掉；</p></blockquote><p>但是在初次使用的时候，依旧无法成功编译miniob，也找不到cmake命令</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">[mu@vm-cnt8:~/code/miniob]$ sudo -E bash build.sh init</span><br><span class="line">[sudo] password for mu: </span><br><span class="line">build.sh init</span><br><span class="line">HEAD is now at 5df3037d Merge branch &#x27;release-2.1.12-stable-pull&#x27; into patches-2.1</span><br><span class="line">build.sh: line 83: cmake: command not found</span><br><span class="line">build.sh: line 91: cmake: command not found</span><br><span class="line">build.sh: line 99: cmake: command not found</span><br><span class="line">build.sh: line 107: cmake: command not found</span><br><span class="line"></span><br><span class="line">[mu@vm-cnt8:~]$ sudo -E cmake --version</span><br><span class="line">[sudo] password for mu: </span><br><span class="line">sudo: cmake: command not found</span><br></pre></td></tr></table></figure><h1 id="3-最终解决：PATH环境变量"><a href="#3-最终解决：PATH环境变量" class="headerlink" title="3.最终解决：PATH环境变量"></a>3.最终解决：PATH环境变量</h1><p>最终的解决办法是我自己想出来的（大佬也回复了我这个解决方案）</p><p>当前在子用户使用 <code>sudo -E</code>是找不到cmake命令的。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[mu@vm-cnt8:~]$ sudo -E cmake --version</span><br><span class="line">[sudo] password for mu: </span><br><span class="line">sudo: cmake: command not found</span><br></pre></td></tr></table></figure><p>我的系统里面的PATH环境变量如下。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[mu@vm-cnt8:~]$ sudo <span class="built_in">env</span> | grep PATH</span><br><span class="line">PATH=/sbin:/bin:/usr/sbin:/usr/bin</span><br></pre></td></tr></table></figure><p>而cmake的路径如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[mu@vm-cnt8:~]$ type cmake</span><br><span class="line">cmake is /usr/local/bin/cmake</span><br><span class="line">[mu@vm-cnt8:~]$ whereis cmake</span><br><span class="line">cmake: /usr/local/bin/cmake /usr/share/cmake</span><br></pre></td></tr></table></figure><p>有没有可能，是因为cmake不在PATH环境变量里面，导致sudo的时候找不到命令呢？虽然在root和mu用户下都可以直接执行cmake。</p><p>于是我就去root里面执行了一下软连接</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@vm-cnt8:~]# ls /usr/bin | grep cmake</span><br><span class="line">[root@vm-cnt8:~]# ln -s /usr/local/bin/cmake /usr/bin/cmake</span><br><span class="line">[root@vm-cnt8:~]# ll /usr/bin | grep cmake</span><br><span class="line">lrwxrwxrwx. 1 root root          20 Sep  1 05:57 cmake -&gt; /usr/local/bin/cmake</span><br></pre></td></tr></table></figure><p>再来试试</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ sudo -E cmake --version</span><br><span class="line">cmake version 3.27.4</span><br><span class="line"></span><br><span class="line">CMake suite maintained and supported by Kitware (kitware.com/cmake).</span><br></pre></td></tr></table></figure><p>最后再来试试编译，应该是OK了，init成功执行，编译也通过了，没有报错</p><p><img src="https://img.musnow.top/i/2023/09/7e206210ba3f9ffa5df6a492ae7b457a.png" alt="image-20230901181050840"></p><p>感谢miniob社区大佬们的帮助！</p><h1 id="4-结论"><a href="#4-结论" class="headerlink" title="4.结论"></a>4.结论</h1><p>如果出现一个命令，root和子用户都可以执行，但是子用户中sudo却找不到此命令，可以尝试检查一下该命令所在路径是否与当前系统的PATH环境变量不符合！</p>]]></content>
    
    
    <summary type="html">root和子用户都能执行的命令，sudo却无法执行，如何解决？</summary>
    
    
    
    <category term="玩上Linux" scheme="https://blog.musnow.top/categories/%E7%8E%A9%E4%B8%8ALinux/"/>
    
    
    <category term="Linux" scheme="https://blog.musnow.top/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>【win】Windows下MSI Afterburner如何让其不在某个软件中显示帧数</title>
    <link href="https://blog.musnow.top/posts/4160666395/"/>
    <id>https://blog.musnow.top/posts/4160666395/</id>
    <published>2023-08-31T13:44:31.000Z</published>
    <updated>2023-08-31T13:44:31.000Z</updated>
    
    <content type="html"><![CDATA[<p>Windows下MSI Afterburner如何让其不在某个软件中显示帧数</p><span id="more"></span><h1 id="1-问题说明"><a href="#1-问题说明" class="headerlink" title="1.问题说明"></a>1.问题说明</h1><p>总所周知，<code>MSI Afterburner</code>这个软件可以在游戏里面展示你当前电脑的各项生命体征，包括GPU&#x2F;CPU功耗频率温度，内存占用，当前帧数等等数据，不管是用来监看电脑运行是否正常，还是用来小超一下显卡，都是很好用的东西，再加上毫无广告+免费，几乎是人手必备的PC良药</p><p><img src="https://img.musnow.top/i/2023/08/22a440a97052d98344faa1679af7e4a1.png" alt="image-20230831211541651"></p><p>但总有时候这个软件会抽风，比如我的电脑里面，最新版本的这个软件，就会把照片莫名其妙的也识别成了一个游戏，在里面显示帧数，最离谱的是，最下方的预览其他图片的小框框里面，也给你显示了帧数</p><p><img src="https://img.musnow.top/i/2023/08/33033ee6b815fd496aefff2db7b41983.png" alt="image-20230831211739693"></p><p>这肯定很恼火，我们要怎么样才能让他不在这里面显示呢？</p><h1 id="2-配置"><a href="#2-配置" class="headerlink" title="2.配置"></a>2.配置</h1><p>和<code>MSI Afterburner</code>捆绑下载的有这么一个软件，其实它才是负责将数据投屏到你的屏幕上的软件，在这里面，我们就可以设置在某个软件中不显示帧数</p><p><img src="https://img.musnow.top/i/2023/08/38ddd77df81cad02c8ac53f0834550f8.png" alt="image-20230831212031500"></p><p>对于正常安装的软件，我们都可以找到软件的安装路径，选中它的exe可执行文件，再设置一下把帧数器关闭，就可以避免错误地显示帧数影响软件自身的使用</p><p><img src="https://img.musnow.top/i/2023/08/952d106d45b52990e2bd63ae4ddc5534.png" alt="image-20230831212050181"></p><p>但是windows自带的相册就有点恼火了，<strong>我们压根不知道它的可执行文件在哪里</strong>！</p><h1 id="3-windows系统应用的可执行文件"><a href="#3-windows系统应用的可执行文件" class="headerlink" title="3.windows系统应用的可执行文件"></a>3.windows系统应用的可执行文件</h1><p>windows绝大部分的系统自带软件都在这里面，你需要打开显示隐藏文件夹才能看到此文件夹</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">C:\Program Files\WindowsApps\</span><br></pre></td></tr></table></figure><p>而<a href="https://zhidao.baidu.com/question/1550787637804576787.html">照片软件路径</a>如下（我的win11版本是<code>22H2 22621.963</code>）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">C:\Program Files\WindowsApps\Microsoft.Windows.Photos_2023.11080.4003.0_x64__8wekyb3d8bbwe</span><br></pre></td></tr></table></figure><p>这里面有一个<code>PhotosApp.exe</code>，就是windows自带照片的可执行文件了；</p><p>但是！你会发现你压根没有 <code>C:\Program Files\WindowsApps\</code>这个文件夹的进入权限，更别提找到这个照片软件的exe了！</p><p>百度了一下，找到了一个教程 <a href="https://www.bkqs.com.cn/content/kn928o443.html">Win10下WindowsApps权限怎么获取</a>；顺带一提，为了避免原文失效，这篇文章也转载到了本站。</p><blockquote><p>注意！毕竟这算是系统底层文件夹了，我不确定这样修改文件夹权限是否会出现问题！如果你担心出现问题，<strong>请不要操作</strong>，在不打游戏的时候不要启动MSI Afterbuner是更好的选择！</p><p>如果出现问题，参考 【<a href="https://blog.csdn.net/oh_futrue/article/details/91042020">WindowsApps 权限问题导致Microsoft Store及其下载的应用不能启动（闪退）的解决办法</a>】 复原权限！实在不行就恐怕要重装系统了 🤣</p><p><img src="https://img.musnow.top/i/2023/08/91c5e537eee80c51f1e2788b15a7d997.png" alt="image-20230831214242664"></p><p>目前我这边还么有出现异常情况，毕竟我修改为了<code>everyone</code>理论上来说是并不会出现权限不够而导致某个程序无法执行的问题的</p></blockquote><p>根据教程里面的步骤一步一步来，就可以获取到这个文件夹的进入权限</p><p><img src="https://img.musnow.top/i/2023/08/f35c62ab02b889383a3f88a3b9700629.png" alt="image-20230831212801573"></p><h1 id="4-禁用照片中的帧数显示"><a href="#4-禁用照片中的帧数显示" class="headerlink" title="4.禁用照片中的帧数显示"></a>4.禁用照片中的帧数显示</h1><p>找到这个<code>PhotosApp.exe</code>之后，在<code>RivaTuner</code>这个软件里面选中这个可执行文件，将其的display关闭</p><p><img src="https://img.musnow.top/i/2023/08/b98f245a377bbfe1369b7cb9809fc9a5.png" alt="image-20230831212557862"></p><p>好了，这下没有胡乱显示帧数了！</p><p><img src="https://img.musnow.top/i/2023/08/d0f3baad38aec23619141b8cf92b6292.png" alt="image-20230831212631268"></p>]]></content>
    
    
    <summary type="html">Windows下MSI Afterburner如何让其不在某个软件中显示帧数</summary>
    
    
    
    <category term="电脑使用小贴士" scheme="https://blog.musnow.top/categories/%E7%94%B5%E8%84%91%E4%BD%BF%E7%94%A8%E5%B0%8F%E8%B4%B4%E5%A3%AB/"/>
    
    
    <category term="windows" scheme="https://blog.musnow.top/tags/windows/"/>
    
  </entry>
  
  <entry>
    <title>【win】Windows下C盘里面的WindowsApps文件夹权限怎么获取</title>
    <link href="https://blog.musnow.top/posts/3712817486/"/>
    <id>https://blog.musnow.top/posts/3712817486/</id>
    <published>2023-08-31T13:34:31.000Z</published>
    <updated>2023-08-31T13:34:31.000Z</updated>
    
    <content type="html"><![CDATA[<p>避免原文失效，转载此文</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">原文 https://www.bkqs.com.cn/content/kn928o443.html</span><br></pre></td></tr></table></figure><h1 id="Win下WindowsApps权限怎么获取"><a href="#Win下WindowsApps权限怎么获取" class="headerlink" title="Win下WindowsApps权限怎么获取"></a>Win下WindowsApps权限怎么获取</h1><p><code>2023-01-31 14:32:17</code></p><p>Win10下WindowsApps权限怎么获取？WindowsApps安装的是Windows应用商店的应用程序，访问此文件夹需要获取权限才能进入。具体怎么设置呢？一起来了解下吧！</p><p><img src="https://img.musnow.top/i/2023/08/df83e62f3e53e132acb209f09a797b6f.png"></p><h2 id="操作方法"><a href="#操作方法" class="headerlink" title="操作方法"></a>操作方法</h2><ul><li><p>01</p><p>1、在计算机中，打开此电脑。点击查看选项，并勾选选项框中的“隐藏的项目”。如图所示；</p><p><img src="https://img.musnow.top/i/2023/08/ac1473123b0f35d32f01b7539023fb51.png"></p></li><li><p>02</p><p>2、在此电脑窗口中，找到系统盘下的“WindowsApps”（隐藏的文件夹），具体路径为“C:\Program Files\WindowsApps”。如图所示；</p><p><img src="https://img.musnow.top/i/2023/08/9a1d5608930d12c04e4303e3b923a747.png"></p></li><li><p>03</p><p>3、选中WindowsApps文件夹，并点击鼠标右键，在弹出的选项框中点击“属性”选项。如图所示；</p><p><img src="https://img.musnow.top/i/2023/08/32e95c80075f35fb9004e63797b1f1d7.png"></p></li><li><p>04</p><p>4、点击属性选项后，这个时候会打开“WindowsApps属性”对话框。如图所示；</p><p><img src="https://img.musnow.top/i/2023/08/5ede94735ea0e66cb1115012e795b0df.png"></p></li><li><p>05</p><p>5、在WindowsApps属性对话框中，切换到“安全”选项卡。如图所示；</p><p><img src="https://img.musnow.top/i/2023/08/b92921c8b6547e8a81e68752e96c830f.png"></p></li><li><p>06</p><p>6、在安全选项卡下，看到提示“必须具有读取权限才能查看对象属性”，并点击“高级”选项按钮。如图所示；</p><p><img src="https://img.musnow.top/i/2023/08/a13b0247ca7b99c1793189336e492c85.png"></p></li><li><p>07</p><p>7、点击高级选项后，这个时候会打开“WindowsApps的高级安全设置”对话窗口。如图所示；</p><p><img src="https://img.musnow.top/i/2023/08/434d13327223687c0ae808b9e5bd0226.png"></p></li><li><p>08</p><p>8、在WindowsApps的高级安全设置对话窗口中，点击所有者后的“更改”按钮。如图所示；</p><p><img src="https://img.musnow.top/i/2023/08/c7060a1aacb894d0ea904202291e9267.png"></p></li><li><p>09</p><p>9、点击更改后，这个时候会打开“选择用户或组”对话框。如图所示；</p><p><img src="https://img.musnow.top/i/2023/08/9b02a003b59c4ce73a72690fc414c038.png"></p></li><li><p>10</p><p>10、在输入要选择的对象名称输入框中，输入“Everyone”，并点击“确定”按钮。如图所示；</p><p><img src="https://img.musnow.top/i/2023/08/fa792f7c20c081c4079f02f6734e2e8d.png"></p></li><li><p>11</p><p>11、点击确定后，这个时候会跳转到WindowsApps的高级安全设置对话窗口。如图所示；</p><p><img src="https://img.musnow.top/i/2023/08/f132cedbea9f1c6677375c0661e68994.png"></p></li><li><p>12</p><p>12、接着勾选所有者下的“替换子容器和对象的所有者”，并点击“确定”按钮。如图所示；</p><p><img src="https://img.musnow.top/i/2023/08/bf8f5bb96b5daa6290850574d2258bb7.png"></p></li><li><p>13</p><p>13、点击确定后，这个时候会弹出Windows安全对话框，进行更改所有权。如图所示；</p><p><img src="https://img.musnow.top/i/2023/08/74051d49c0138f62d250c588acb0eaa4.png"></p></li><li><p>14</p><p>14、更改所有权完成后，这个时候就能正常访问“WindowsApps”文件夹了。如图所示；</p><p><img src="https://img.musnow.top/i/2023/08/c523ded7262708fbef624c1c742997f8.png"></p></li></ul>]]></content>
    
    
    <summary type="html">Win下C盘里面的WindowsApps权限怎么获取</summary>
    
    
    
    <category term="电脑使用小贴士" scheme="https://blog.musnow.top/categories/%E7%94%B5%E8%84%91%E4%BD%BF%E7%94%A8%E5%B0%8F%E8%B4%B4%E5%A3%AB/"/>
    
    
    <category term="windows" scheme="https://blog.musnow.top/tags/windows/"/>
    
  </entry>
  
  <entry>
    <title>【Linux】centos8安装bison3.8</title>
    <link href="https://blog.musnow.top/posts/1067381808/"/>
    <id>https://blog.musnow.top/posts/1067381808/</id>
    <published>2023-08-30T10:31:55.000Z</published>
    <updated>2023-08-30T10:31:55.000Z</updated>
    
    <content type="html"><![CDATA[<p>centos8安装<code>bison3.8</code>的教程，感觉这个软件包很<code>小众</code>啊，百度找不到安装教程，最终还是在起脚旮旯里面翻出来了很久之前的文档，好在没有过时；</p><span id="more"></span><blockquote><p><a href="https://linux.cn/lfs/LFS-BOOK-7.7-systemd/chapter06/bison.html">https://linux.cn/lfs/LFS-BOOK-7.7-systemd/chapter06/bison.html</a></p></blockquote><p><img src="https://img.musnow.top/i/2023/09/db6be01dbd28cd3371fdf8e5d657b968.png" alt="image-20230901215525821"></p><p>虽然centos8中你可以使用yum直接安装，但是哪个安装的版本太低了，达不到如今的需求</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install -y bison</span><br></pre></td></tr></table></figure><p>我这边直接用yum安装的是<code>3.0.4</code>的版本，已经是2015年的东西了，最新的版本已经到3.8了，而且我正在使用的新项目miniob就要求更高的版本，所以老版本肯定是不行的；</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">bison (GNU Bison) 3.0.4</span><br><span class="line">Written by Robert Corbett and Richard Stallman.</span><br><span class="line"></span><br><span class="line">Copyright (C) 2015 Free Software Foundation, Inc.</span><br><span class="line">This is free software; see the source for copying conditions.  There is NO</span><br><span class="line">warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.</span><br></pre></td></tr></table></figure><p>先用yum把安装好了的删掉</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum remove bison</span><br></pre></td></tr></table></figure><blockquote><p>我看有的文章说需要先安装前置依赖项<code>flex</code>，这里带上吧。因为我的系统里面不知道什么时候就已经安装好了这个东西了</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install flex</span><br></pre></td></tr></table></figure></blockquote><p>去官网 <a href="http://ftp.gnu.org/gnu/bison/">http://ftp.gnu.org/gnu/bison/</a> 下载最新的压缩包</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget http://ftp.gnu.org/gnu/bison/bison-3.8.tar.gz</span><br></pre></td></tr></table></figure><p>解压并进入文件夹</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">tar -zxvf bison-3.8.tar.gz</span><br><span class="line">cd bison-3.8</span><br></pre></td></tr></table></figure><p>配置安装路径，这里我使用了<code>/usr/local</code>这个目录，如果你查看过安装后的bison，你会发现它的安装包的逻辑是和<code>/usr/local</code>目录一致的，当然你也可以修改成你自己想要的目录</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># ls /usr/local/</span><br><span class="line">bin  doc  etc  games  include  lib  lib64  libexec  openssl-1.1.1  sbin  share  src</span><br></pre></td></tr></table></figure><p>使用如下命令配置安装路径为<code>/usr/local</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./configure -prefix=/usr/local/</span><br></pre></td></tr></table></figure><p>目录配置好了之后，make安装</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make install</span><br></pre></td></tr></table></figure><blockquote><p>如果要卸载，用<code>make uninstall</code></p></blockquote><p>安装好了之后执行<code>bison --version</code>，你会得到如下输出</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-bash: /usr/bin/bison: No such file or directory</span><br></pre></td></tr></table></figure><p>这是因为我们在<code>/usr/local</code>里面安装的东西没有在path中，没有办法直接执行，需要我们将其软链接到<code>/usr/bin</code>里面；</p><p>如果你的安装正确了，应该可以在<code>/usr/local/bin</code>里面找到<code>bison</code>; 如果你安装的路径不同，那就去你安装路径下找<code>bison</code>的可执行文件；</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># ls /usr/local/bin</span></span><br><span class="line">2to3-3.10  bison  cmake  cpack  ctest  docker-compose  idle3.10  pip3.10  pydoc3.10  python3.10  python3.10-config  yacc</span><br></pre></td></tr></table></figure><p>将其软连接一下就ok了</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># ln -s /usr/local/bin/bison /usr/bin/bison</span></span><br><span class="line"><span class="comment"># ls /usr/bin/bison</span></span><br><span class="line">/usr/bin/bison</span><br></pre></td></tr></table></figure><p>再次检查版本，安装<code>3.8</code>成功！</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># bison --version</span><br><span class="line">bison (GNU Bison) 3.8</span><br><span class="line">Written by Robert Corbett and Richard Stallman.</span><br><span class="line"></span><br><span class="line">Copyright (C) 2021 Free Software Foundation, Inc.</span><br><span class="line">This is free software; see the source for copying conditions.  There is NO</span><br><span class="line">warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;centos8安装&lt;code&gt;bison3.8&lt;/code&gt;的教程，感觉这个软件包很&lt;code&gt;小众&lt;/code&gt;啊，百度找不到安装教程，最终还是在起脚旮旯里面翻出来了很久之前的文档，好在没有过时；&lt;/p&gt;</summary>
    
    
    
    <category term="玩上Linux" scheme="https://blog.musnow.top/categories/%E7%8E%A9%E4%B8%8ALinux/"/>
    
    
    <category term="Linux" scheme="https://blog.musnow.top/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>【Linux】centos8安装cmake3.27.4</title>
    <link href="https://blog.musnow.top/posts/343476194/"/>
    <id>https://blog.musnow.top/posts/343476194/</id>
    <published>2023-08-30T10:30:55.000Z</published>
    <updated>2023-08-30T10:30:55.000Z</updated>
    
    <content type="html"><![CDATA[<p>第一步，去<a href="https://cmake.org/download/">官网</a>下安装包，一定不要下错了</p><p><img src="https://img.musnow.top/i/2023/08/a7b64c50664a8d69fb805fcbb17edcbe.png" alt="image-20230830175242958"></p><p>下好了之后，用ftp软件传到云服务器或者虚拟机上，我用的是centos8系统，安装之前先准备好这些依赖项</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">yum install -y gcc gcc-c++ make automake</span><br><span class="line">yum install -y openssl  openssl-devel</span><br></pre></td></tr></table></figure><p>把下载好的安装包传上去后，解压（在root用户下操作）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar -zxvf cmake-3.27.4.tar.gz </span><br></pre></td></tr></table></figure><p>解压完毕后进入文件夹</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cd cmake-3.27.4</span><br></pre></td></tr></table></figure><p>执行命令</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./bootstrap</span><br></pre></td></tr></table></figure><p>耐心等候完成后，依次运行下面两个命令</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">gmake</span><br><span class="line">gmake install</span><br></pre></td></tr></table></figure><p>最终判断是否安装成功</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cmake --version</span><br></pre></td></tr></table></figure><p>出现如下信息就是搞定了</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># cmake --version</span><br><span class="line">cmake version 3.27.4</span><br><span class="line"></span><br><span class="line">CMake suite maintained and supported by Kitware (kitware.com/cmake).</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;第一步，去&lt;a href=&quot;https://cmake.org/download/&quot;&gt;官网&lt;/a&gt;下安装包，一定不要下错了&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img.musnow.top/i/2023/08/a7b64c50664a8d69fb805fcbb</summary>
      
    
    
    
    <category term="玩上Linux" scheme="https://blog.musnow.top/categories/%E7%8E%A9%E4%B8%8ALinux/"/>
    
    
    <category term="Linux" scheme="https://blog.musnow.top/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>【C++】C++14的那些新特性</title>
    <link href="https://blog.musnow.top/posts/1184922698/"/>
    <id>https://blog.musnow.top/posts/1184922698/</id>
    <published>2023-08-28T14:40:46.000Z</published>
    <updated>2023-08-28T14:40:46.000Z</updated>
    
    <content type="html"><![CDATA[<p>学习C++14的那些新特性</p><span id="more"></span><p><img src="https://img.musnow.top/i/2023/08/0061de987afa3c3003cbfa4762397ac5.png" alt="v2-642fda8762a7dcda4556e14c8ff5c1ef_1440w"></p><p>为了方便指定使用C++14来编译代码，本文的测试都是在linux下进行的，g++版本如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ g++ --version</span><br><span class="line">g++ (GCC) 8.5.0 20210514 (Red Hat 8.5.0-4)</span><br></pre></td></tr></table></figure><p>如果你和我一样，也是使用VSC来链接linux进行代码编写，那一定要记得修改C++插件里面的CPP版本，否则默认以C++11来进行语法高亮的话，会把C++11不支持的语法标红，影响我们学习</p><p><img src="https://img.musnow.top/i/2023/08/8363f819fd562b1bd452551e970ff4a3.png" alt="image-20230828230838973"></p><blockquote><p>本文参考 <a href="https://zhuanlan.zhihu.com/p/588826142">https://zhuanlan.zhihu.com/p/588826142</a> 进行学习;</p><p>官方文档 <a href="https://zh.cppreference.com/w/cpp/14">https://zh.cppreference.com/w/cpp/14</a></p></blockquote><h1 id="1-lambda新特性"><a href="#1-lambda新特性" class="headerlink" title="1.lambda新特性"></a>1.lambda新特性</h1><p>C++14给lambda表达式添加了两个新功能</p><ul><li>参数推断（auto）</li><li>参数初始化后捕获（可以在<code>[]</code>对某个新参数进行赋值）</li></ul><p>先来复习一下C++11中学习的lambda捕获的基本方式</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[val]：表示值传递方式捕捉变量val</span><br><span class="line">[=]：表示值传递方式捕获所有父作用域中的变量(包括this)</span><br><span class="line">[&amp;val]：表示引用传递捕捉变量val</span><br><span class="line">[&amp;]：表示引用传递捕捉所有父作用域中的变量(包括this)</span><br><span class="line">[this]：表示值传递方式捕捉当前的this指针</span><br></pre></td></tr></table></figure><p>在C++14中，新增的是下面的这种情况</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">30</span>;</span><br><span class="line"><span class="comment">// [] 中赋值了一个参数</span></span><br><span class="line"><span class="comment">// () 中可以使用auto关键字来推断参数类型</span></span><br><span class="line"><span class="keyword">auto</span> func = [x = <span class="number">3</span>](<span class="keyword">auto</span> y) &#123;<span class="keyword">return</span> x + y; &#125;;</span><br><span class="line">cout &lt;&lt; <span class="built_in">func</span>(a) &lt;&lt; endl;</span><br></pre></td></tr></table></figure><p>运行测试，可以看到成功输出了结果</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ make</span><br><span class="line">g++ test.cpp -o test -std=c++14</span><br><span class="line">$ ./test</span><br><span class="line">33</span><br></pre></td></tr></table></figure><p>修改一下类型，也能正常调用</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">double</span> a = <span class="number">30.2</span>;</span><br><span class="line"><span class="keyword">auto</span> func = [x = <span class="number">3</span>](<span class="keyword">auto</span> y)</span><br><span class="line">&#123; <span class="keyword">return</span> x + y; &#125;;</span><br><span class="line">cout &lt;&lt; <span class="built_in">func</span>(a) &lt;&lt; endl;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ ./test</span><br><span class="line">33.2</span><br></pre></td></tr></table></figure><p>如果想将赋值参数和原本的捕获方式一起使用，则需要将<strong>赋值参数</strong>放在<code>[]</code>的最<strong>后面</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">test_lambda2</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">10</span>, b = <span class="number">20</span>;</span><br><span class="line">    <span class="type">int</span> c = <span class="number">1</span>, d = <span class="number">3</span>, e = <span class="number">5</span>;</span><br><span class="line">    <span class="comment">// 赋值的参数要放在[]的最后面，捕获方式放在前面</span></span><br><span class="line">    <span class="keyword">auto</span> func6 = [=, f = <span class="number">30</span>, g = <span class="number">40</span>]</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">return</span> (a + b + c + d + e + f + g);</span><br><span class="line">    &#125;;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">func6</span>() &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ ./test</span><br><span class="line">109</span><br></pre></td></tr></table></figure><p>初始化捕获的好处是可以支持<strong>移动捕获</strong>了；不然在C++11中，lambda就只能使用赋值捕获和引用捕获</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::unique_ptr&lt;Item&gt; <span class="title">item</span><span class="params">(<span class="keyword">new</span> Item())</span></span>;</span><br><span class="line"><span class="comment">// std::move改为右值进行赋值后捕获</span></span><br><span class="line"><span class="keyword">auto</span> func = [m = std::<span class="built_in">move</span>(item)] &#123; <span class="comment">/* do something */</span> &#125;;</span><br></pre></td></tr></table></figure><p>这个新特性的提出，也让lambda成功有了和bind比拼的能力。在C++11中，bind的优势就是在于<strong>移动捕获</strong>的支持；如今lambda也有了这份能力了，我们可以更灵活地根据场景选用lambda或者bind，而不是只能使用bind了。</p><h1 id="2-变量模板"><a href="#2-变量模板" class="headerlink" title="2.变量模板"></a>2.变量模板</h1><h2 id="2-1-示例"><a href="#2-1-示例" class="headerlink" title="2.1 示例"></a>2.1 示例</h2><p>看清楚这个名字啊！是<strong>变量模板</strong>，可不是什么函数模板哈！</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line">T pi = <span class="built_in">T</span>(<span class="number">3.1415926535897932385L</span>); <span class="comment">// variable template</span></span><br><span class="line"><span class="comment">// 数字最后的L代表这是一个长浮点型</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test_value_template</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; pi&lt;<span class="type">double</span>&gt; &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; pi&lt;<span class="type">float</span>&gt; &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; pi&lt;<span class="type">int</span>&gt; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如上就是一个最最最简单的变量模板，我们在传入对应的类型后，他就会转成我们需要的类型</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ make</span><br><span class="line">g++ test.cpp -o test -std=c++14</span><br><span class="line">$ ./test</span><br><span class="line">3.14159</span><br><span class="line">3.14159</span><br><span class="line">3</span><br></pre></td></tr></table></figure><h2 id="2-2-类中使用"><a href="#2-2-类中使用" class="headerlink" title="2.2 类中使用"></a>2.2 类中使用</h2><p>当你需要在类中使用模板变量的时候，这个变量必须定义为<code>static</code>；</p><p>因为它是模板，我们还可以接用模板本身就有的特性，将这个模板针对某一个类型进行<strong>特化</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Limits</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">    <span class="type">static</span> <span class="type">const</span> T min; <span class="comment">// 声明静态成员模板</span></span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">const</span> T Limits::min = &#123; &#125;; <span class="comment">// 定义静态成员模板，全部使用默认值</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 下面三个是模板变量的特化</span></span><br><span class="line"><span class="keyword">template</span>&lt;&gt;</span><br><span class="line"><span class="type">const</span> <span class="type">float</span> Limits::min&lt;<span class="type">float</span>&gt; = <span class="number">4.5</span>;</span><br><span class="line"><span class="keyword">template</span>&lt;&gt;</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> Limits::min&lt;<span class="type">double</span>&gt; = <span class="number">5.5</span>;</span><br><span class="line"><span class="keyword">template</span>&lt;&gt;</span><br><span class="line"><span class="type">const</span> std::string Limits::min&lt;std::string&gt; = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::cout &lt;&lt; Limits::min&lt;<span class="type">int</span>&gt; &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; Limits::min&lt;<span class="type">float</span>&gt; &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; Limits::min&lt;<span class="type">double</span>&gt; &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; Limits::min&lt;std::string&gt; &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ ./test</span><br><span class="line">0</span><br><span class="line">4.5</span><br><span class="line">5.5</span><br><span class="line">hello</span><br></pre></td></tr></table></figure><h2 id="2-3-和类型转换的区别"><a href="#2-3-和类型转换的区别" class="headerlink" title="2.3 和类型转换的区别"></a>2.3 和类型转换的区别</h2><p>这里我又直接定义了一个变量，使用<code>static_cast</code>直接转换变量，看看结果会不会有什么区别</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 数字最后的L代表这是一个长浮点型</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line">T pi = <span class="built_in">T</span>(<span class="number">3.1415926535897932385L</span>); <span class="comment">// 变量模板</span></span><br><span class="line"></span><br><span class="line"><span class="type">long</span> <span class="type">double</span> lpi = <span class="number">3.1415926535897932385L</span>; <span class="comment">// 直接定义长浮点型</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test_value_template</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; pi&lt;<span class="type">double</span>&gt; &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; pi&lt;<span class="type">float</span>&gt; &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; pi&lt;<span class="type">int</span>&gt; &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot; ----- \n&quot;</span>;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="built_in">static_cast</span>&lt;<span class="type">double</span>&gt;(lpi) &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">static_cast</span>&lt;<span class="type">float</span>&gt;(lpi) &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">static_cast</span>&lt;<span class="type">int</span>&gt;(lpi) &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看上去二者的结果完全相同，那么既然可以直接使用变量类型转换，为什么还要新增一个模板变量呢？</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ ./test</span><br><span class="line">3.14159</span><br><span class="line">3.14159</span><br><span class="line">3</span><br><span class="line"> ----- </span><br><span class="line">3.14159</span><br><span class="line">3.14159</span><br><span class="line">3</span><br></pre></td></tr></table></figure><blockquote><p>以下内容来自GPT，我觉得它说的很对</p></blockquote><p>定义一个变量并使用数据转换（类型转换）是一种常见的编程方式，但与变量模板有一些区别：</p><ol><li><strong>通用性：</strong> 变量模板允许你通过模板参数来生成多个不同类型的变量，从而在不同的上下文中使用。这使得代码更具通用性和可扩展性，因为你可以为多个类型生成相应的变量。相比之下，直接定义变量并使用数据转换通常只适用于特定的一种数据类型。</li><li><strong>模板化：</strong> 变量模板是一种模板化的方式来生成变量，它遵循 C++ 的模板机制，这意味着你可以使用模板<strong>特化</strong>、部分特化等技术来定制化生成的变量，以满足不同的需求。而使用数据转换时，你必须显式地执行类型转换，这可能会在代码中引入不必要的重复。</li><li><strong>编译时计算：</strong> 变量模板通常用于在编译时生成值，因此可以在编译阶段进行类型检查和计算。这有助于提高代码的性能和安全性。而数据转换可能在运行时进行，可能会引入一些运行时开销和类型错误的风险。</li><li><strong>抽象性：</strong> 变量模板可以在更高的抽象层次上操作数据，使代码更具表达力和可读性。它允许你以更自然的方式描述某个值与特定类型之间的关系，而不必显式进行类型转换。</li></ol><p>总之，变量模板提供了一种更灵活、通用和模板化的方式来生成变量，适用于需要在不同类型上工作的情况。当你需要为多个类型生成特定的变量或值时，变量模板是一种更优雅和强大的选择。</p><h1 id="3-constexpr限制放宽"><a href="#3-constexpr限制放宽" class="headerlink" title="3.constexpr限制放宽"></a>3.constexpr限制放宽</h1><p>在C++11中被引入的constexpr，可以让编译器在编译程序的期间，就将一部分工作完成，不必等到运行期间再做；在C++11中，constexpr的限制很严格，这导致它并不好用：</p><ul><li>constexpr修饰变量，要求变量必须可以在编译器推导出来</li><li>constexpr修饰函数（返回值），函数内除了可以包含using和typedef指令以及<code>static_asssert</code>断言外，只能包含一条<code>return</code>语句</li><li>constexpr同时可以修饰构造函数，但也会要求使用这个构造函数的时候，可以在编译器就把相关的内容全推导出来</li></ul><p>以下是一个比较基础的C++11中的用例，给该函数设置了<code>constexpr</code>关键字后，该函数就可以在编译期间被计算出结果，再用<code>static_assert</code>在编译期间断言结果是否正确；</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">constexpr</span> <span class="type">int</span> <span class="title">factorial</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (n &lt;= <span class="number">1</span>) ? <span class="number">1</span> : n * <span class="built_in">factorial</span>(n - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">test_constexpr1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constexpr</span> <span class="type">int</span> result = <span class="built_in">factorial</span>(<span class="number">5</span>); <span class="comment">// 编译时计算阶乘</span></span><br><span class="line">    <span class="built_in">static_assert</span>(result == <span class="number">120</span>, <span class="string">&quot;Factorial of 5 should be 120&quot;</span>); <span class="comment">// 编译时断言</span></span><br><span class="line">    cout &lt;&lt; result &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果在C++11中的constexpr函数内包含其他语句，编译的时候会报错，翻译过来是该函数内部不是一个return返回语句</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ g++ test.cpp -o test -std=c++11</span><br><span class="line">test.cpp: In function ‘constexpr int FuncNew(int)’:</span><br><span class="line">test.cpp:96:1: error: body of ‘constexpr’ function ‘constexpr int FuncNew(int)’ not a return-statement</span><br><span class="line"> &#125;</span><br><span class="line"> ^</span><br></pre></td></tr></table></figure><p>c++14中，对constexpr的限制放宽了，允许使用<strong>循环、if、switch</strong>等等语句，但是主旨还是一样的，需要在编译期间就可以计算出全部内容；限制放宽之后，这个关键字便可以更灵活的使用了。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 计算前n项和，C++11</span></span><br><span class="line"><span class="function"><span class="keyword">constexpr</span> <span class="type">int</span> <span class="title">Func</span><span class="params">(<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> n &gt; <span class="number">0</span> ? <span class="built_in">Func</span>(n - <span class="number">1</span>) + n : <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 计算前N项和，C++14</span></span><br><span class="line"><span class="function"><span class="keyword">constexpr</span> <span class="type">int</span> <span class="title">FuncNew</span><span class="params">(<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n &lt;= <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        sum += i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="4-二进制变量"><a href="#4-二进制变量" class="headerlink" title="4.二进制变量"></a>4.二进制变量</h1><p>可以使用<code>0b</code>或者<code>0B</code>开头直接定义二进制变量。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;    </span><br><span class="line">    <span class="type">int</span> bit1 = <span class="number">0b1001</span>;</span><br><span class="line">    <span class="type">int</span> bit2 = <span class="number">0B</span>1011;</span><br><span class="line">    std::cout &lt;&lt; bit1 &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; bit2 &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ g++ test.cpp -o test -std=c++14</span><br><span class="line">$ ./test</span><br><span class="line">9 11</span><br></pre></td></tr></table></figure><p>我在测试中发现，当我用C++11编译此代码的时候，似乎也没有引发编译错误，难道说0b是在C++11里面就支持了吗？</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ g++ test.cpp -o test -std=c++11</span><br><span class="line">$ ./test</span><br><span class="line">9 11</span><br></pre></td></tr></table></figure><p>GPT给出了0B这种二进制变量是在C++14中引入的确认，并提到了为什么会出现上述情况；虽然C++11看上去编译和运行都没有问题，但我们还是得遵循版本，选用正确的版本进行编译，才能根本上避免错误</p><blockquote><p>C++标准通常是向后兼容的，这意味着较新版本的编译器通常会继续支持较旧版本的标准。例如，如果你在使用支持C++11标准的编译器（如g++）时，使用了C++14或更高版本的特性，通常不会引发编译错误，因为这些编译器会尽量向后兼容，以保持现有代码的可编译性。</p><p>在你提到的情况下，即使你使用g++编译器以C++11标准编译，它仍然可以理解和接受C++14引入的二进制字面量特性。这是编译器开发者的一种设计选择，以便使代码的迁移更加平滑。但是，为了遵循最佳实践和保持代码的可读性，当你在使用特定C++标准的功能时，最好将编译器选项设置为该标准的版本，以确保代码的可移植性。</p></blockquote><h1 id="5-数字分隔符"><a href="#5-数字分隔符" class="headerlink" title="5.数字分隔符"></a>5.数字分隔符</h1><p>在日常生活中使用数字的时候，为了更好的可读性，我们会以3个数组或者4个数组为分割，打一个点</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1,0000,0000 一亿</span><br><span class="line">100,000,000</span><br></pre></td></tr></table></figure><p>C++14中，也支持了这样的打点，以方便我们更好的看出大数字的位数</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">test_num_div</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> big_num1 = <span class="number">100000000</span>;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> big_num2 = <span class="number">100&#x27;000&#x27;000</span>;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> big_num3 = <span class="number">1&#x27;0000&#x27;0000</span>;</span><br><span class="line">    cout &lt;&lt; big_num1 &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; big_num2 &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; big_num3 &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>需要注意，这样的操作不会对数字本身有任何影响</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ ./test</span><br><span class="line">100000000</span><br><span class="line">100000000</span><br><span class="line">100000000</span><br></pre></td></tr></table></figure><p>在C++11中这种语法是不支持的</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">$ g++ test.cpp -o test -std=c++11</span><br><span class="line">test.cpp:116:29: warning: multi-character character constant [-Wmultichar]</span><br><span class="line">     long long big_num2 = 100&#x27;000&#x27;000;</span><br><span class="line">                             ^~~~~</span><br><span class="line">test.cpp:117:27: warning: multi-character character constant [-Wmultichar]</span><br><span class="line">     long long big_num3 = 1&#x27;0000&#x27;0000;</span><br><span class="line">                           ^~~~~~</span><br><span class="line">test.cpp: In function ‘void test_num_div()’:</span><br><span class="line">test.cpp:116:29: error: expected ‘,’ or ‘;’ before &#x27;\x303030&#x27;</span><br><span class="line">     long long big_num2 = 100&#x27;000&#x27;000;</span><br><span class="line">                             ^~~~~</span><br><span class="line">test.cpp:117:27: error: expected ‘,’ or ‘;’ before &#x27;\x30303030&#x27;</span><br><span class="line">     long long big_num3 = 1&#x27;0000&#x27;0000;</span><br><span class="line">                           ^~~~~~</span><br></pre></td></tr></table></figure><h1 id="6-返回值auto推导"><a href="#6-返回值auto推导" class="headerlink" title="6.返回值auto推导"></a>6.返回值auto推导</h1><p>c++14新增了函数返回值的推导，当返回值声明为auto时，编译器会根据你的return语句推导出你的返回值类型。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">Func</span><span class="params">(T x, T y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="built_in">Func</span>(<span class="number">3</span>, <span class="number">4</span>) &lt;&lt; std::endl; <span class="comment">// 返回值推导为int</span></span><br><span class="line">    std::cout &lt;&lt; <span class="built_in">Func</span>(<span class="number">3.1</span>, <span class="number">4.2</span>) &lt;&lt; std::endl; <span class="comment">// 返回值推导为double</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ make</span><br><span class="line">g++ test.cpp -o test -std=c++14</span><br><span class="line">$ ./test</span><br><span class="line">7</span><br><span class="line">7.3</span><br></pre></td></tr></table></figure><p>这个推导是有限制条件的</p><p>1、如果有多个推导语句，那么多个推导的结果必须一致</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 编译报错，第一个return推导为int，第二个return推导为double，两次推导结果不一致</span></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">Func</span><span class="params">(<span class="type">int</span> flag)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (flag &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">3.14</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2、如果没有return或者return为void类型，那么auto会被推导为void。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">f</span><span class="params">()</span> </span>&#123;&#125;              <span class="comment">// returns void</span></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">g</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="built_in">f</span>(); &#125; <span class="comment">// returns void</span></span><br><span class="line"><span class="function"><span class="keyword">auto</span>* <span class="title">x</span><span class="params">()</span> </span>&#123;&#125;             <span class="comment">// error: cannot deduce auto* from void</span></span><br></pre></td></tr></table></figure><p>3、一旦在函数中看到return语句，从该语句推导出的返回类型就可以在函数的其余部分中使用，包括在其他return语句中。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">Sum</span><span class="params">(<span class="type">int</span> i)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (i &lt;= <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> i; <span class="comment">// 返回值被推导为int</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Sum</span>(i - <span class="number">1</span>) + i; <span class="comment">// sum的返回值已经被推导出来了，所以这里是没有问题的</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是如果还没被推导出来，那就不能使用。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">Sum</span><span class="params">(<span class="type">int</span> i)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (i &gt; <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Sum</span>(i - <span class="number">1</span>) + i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 编译报错，因为Sum的返回值还没有被推导出来，所以还不能使用</span></span><br><span class="line">error: use of ‘<span class="function"><span class="keyword">auto</span> <span class="title">Sum</span><span class="params">(<span class="type">int</span>)</span>’ before deduction of ‘<span class="keyword">auto</span>’</span></span><br></pre></td></tr></table></figure><p>4、不能推导初始化列表。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">func</span> <span class="params">()</span> </span>&#123; <span class="keyword">return</span> &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;; &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 编译报错</span></span><br><span class="line">error: returning initializer list</span><br></pre></td></tr></table></figure><p>5、虚函数不能使用返回值推导</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Item</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">auto</span> <span class="title">Func</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 编译报错</span></span><br><span class="line">error: <span class="keyword">virtual</span> function cannot have deduced <span class="keyword">return</span> type</span><br></pre></td></tr></table></figure><h1 id="7-deprecated-标记"><a href="#7-deprecated-标记" class="headerlink" title="7.[[deprecated]]标记"></a>7.<code>[[deprecated]]</code>标记</h1><p>这个标记的作用是告知其他人，某个函数被弃用了，不允许继续调用该函数；该字段的好处在于，如果一个方法已经在后续不需要使用了，你可以先给他加上这个关键字，然后再进行其他的代码检查，确认无误后，再将这个函数整体清除；</p><p>别人也不需要去检查函数的实现，因为在编译过程中编译器就会告诉你这个函数被弃用；<strong>但是编译依旧是成功的</strong>！</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">[[deprecated]]</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">test_return_auto</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="built_in">Func</span>(<span class="number">3</span>, <span class="number">4</span>) &lt;&lt; std::endl; <span class="comment">// 返回值推导为int</span></span><br><span class="line">    std::cout &lt;&lt; <span class="built_in">Func</span>(<span class="number">3.1</span>, <span class="number">4.2</span>) &lt;&lt; std::endl; <span class="comment">// 返回值推导为double</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">test_return_auto</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在编译的时候，编译器会警告你，这个函数已经被弃用了；但这里只是警告，编译依旧成功了，所以最终还是需要程序猿去瞅一眼各个警告到底是什么意思。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">$ make</span><br><span class="line">g++ test.cpp -o test -std=c++14</span><br><span class="line">test.cpp: In function ‘int main()’:</span><br><span class="line">test.cpp:145:22: warning: ‘int test_return_auto()’ is deprecated [-Wdeprecated-declarations]</span><br><span class="line">     test_return_auto();</span><br><span class="line">                      ^</span><br><span class="line">test.cpp:132:5: note: declared here</span><br><span class="line"> int test_return_auto()</span><br><span class="line">     ^~~~~~~~~~~~~~~~</span><br><span class="line">test.cpp:145:22: warning: ‘int test_return_auto()’ is deprecated [-Wdeprecated-declarations]</span><br><span class="line">     test_return_auto();</span><br><span class="line">                      ^</span><br><span class="line">test.cpp:132:5: note: declared here</span><br><span class="line"> int test_return_auto()</span><br><span class="line">     ^~~~~~~~~~~~~~~~</span><br></pre></td></tr></table></figure><hr><h1 id="std库的新特性"><a href="#std库的新特性" class="headerlink" title="std库的新特性"></a>std库的新特性</h1><p>以下是STD库的新增内容！</p><h2 id="8-std-make-unique"><a href="#8-std-make-unique" class="headerlink" title="8.std::make_unique"></a>8.std::make_unique</h2><p>这个东西在cplusplus网站上找不到释义，所以就去<a href="https://zh.cppreference.com/">cpp的官网</a>上找了</p><blockquote><p><a href="https://zh.cppreference.com/w/cpp/memory/unique_ptr/make_unique">https://zh.cppreference.com/w/cpp/memory/unique_ptr/make_unique</a></p></blockquote><p>该函数定义在<code>&lt;memory&gt;</code>头文件中</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt; <span class="keyword">class</span> T, <span class="keyword">class</span>... Args &gt;</span></span><br><span class="line"><span class="function">unique_ptr&lt;T&gt; <span class="title">make_unique</span><span class="params">( Args&amp;&amp;... args )</span></span>;</span><br><span class="line"><span class="comment">//(1)(C++14 起) (仅对非数组类型)</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt; <span class="keyword">class</span> T &gt;</span></span><br><span class="line"><span class="function">unique_ptr&lt;T&gt; <span class="title">make_unique</span><span class="params">( std::<span class="type">size_t</span> size )</span></span>;</span><br><span class="line"><span class="comment">//(2)(C++14 起) (仅对未知边界数组)</span></span><br><span class="line"><span class="keyword">template</span>&lt; <span class="keyword">class</span> <span class="title class_">T</span>, <span class="keyword">class</span>... Args &gt;</span><br><span class="line"><span class="comment">/* unspecified */</span> <span class="built_in">make_unique</span>( Args&amp;&amp;... args ) = <span class="keyword">delete</span>;</span><br><span class="line"><span class="comment">//(3)(C++14 起) (仅对已知边界数组)</span></span><br></pre></td></tr></table></figure><p>作用是构造 <code>T</code> 类型对象并将其包装进 <a href="https://zh.cppreference.com/w/cpp/memory/unique_ptr">std::unique_ptr</a>；</p><table><thead><tr><th>参数</th><th>说明</th></tr></thead><tbody><tr><td>args</td><td>将要构造的 <code>T</code> 实例所用的参数列表。</td></tr><tr><td>size</td><td>要构造的数组大小</td></tr></tbody></table><ol><li>构造非数组类型 <code>T</code> 对象。传递参数 <code>args</code> 给 <code>T</code> 的构造函数。此重载只有在 <code>T</code> 不是数组类型时才会参与重载决议。函数等价于：</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">unique_ptr</span>&lt;T&gt;(<span class="keyword">new</span> <span class="built_in">T</span>(std::forward&lt;Args&gt;(args)...))</span><br></pre></td></tr></table></figure><ol start="2"><li>构造拥有动态大小的数组。<a href="https://zh.cppreference.com/w/cpp/language/value_initialization">值初始化</a>数组元素。此重载只有在 <code>T</code> 是未知边界数组时才会参与重载决议。函数等价于：</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">unique_ptr</span>&lt;T&gt;(<span class="keyword">new</span> std::<span class="type">remove_extent_t</span>&lt;T&gt;[size]())</span><br></pre></td></tr></table></figure><p>使用示例</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">test_class</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">test_class</span>(<span class="type">int</span> a=<span class="number">-1</span>):_a(a)&#123;&#125;</span><br><span class="line">    <span class="type">int</span> _a;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::unique_ptr&lt;test_class&gt; pt = std::<span class="built_in">make_unique</span>&lt;test_class&gt;(<span class="number">3</span>);</span><br><span class="line">    cout &lt;&lt; pt-&gt;_a &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ make</span><br><span class="line">g++ test.cpp -o test -std=c++14</span><br><span class="line">$ ./test</span><br><span class="line">3</span><br></pre></td></tr></table></figure><h2 id="9-std-shared-timed-mutex与std-shared-lock"><a href="#9-std-shared-timed-mutex与std-shared-lock" class="headerlink" title="9.std::shared_timed_mutex与std::shared_lock"></a>9.std::shared_timed_mutex与std::shared_lock</h2><p>c++11引入了多线程线程的一些库，但是是没有读写锁的，因此在c++14引入了读写锁的相关实现（头文件shared_mutex），其实c++14读写锁也还不够完善，直到c++17读写锁这块才算是完备起来。</p><p><code>std::shared_timed_mutex</code>是带超时的读写锁对象，接口还算比较简洁易懂，和之前接触过的其他锁基本一致；内部成员中<code>lock()</code>是写锁，<code>lock_shared()</code>是读锁;</p><p><a href="https://zh.cppreference.com/w/cpp/thread/shared_timed_mutex">https://zh.cppreference.com/w/cpp/thread/shared_timed_mutex</a></p><p><img src="https://img.musnow.top/i/2023/08/9c8a79016b52e8d7845bdee6a98fc151.png" alt="image-20230829082045636"></p><p><code>std::shared_lock</code>是加锁的RAII实现，即构造时加锁，析构时解锁；我们使用<code>shared_lock/unique_lock</code>来从<code>shared_timed_mutex</code>中获取锁的时候，就会自动获取读锁和写锁；</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">std::shared_timed_mutex mutex;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">readOperation</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 读锁是多人可以获取的，所以要用shared_lock (读锁)</span></span><br><span class="line">    <span class="function">std::shared_lock&lt;std::shared_timed_mutex&gt; <span class="title">lock</span><span class="params">(mutex)</span></span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Read operation: &quot;</span> &lt;&lt; sharedResource &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">writeOperation</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 写锁互斥获取，用unique_lock (写锁)</span></span><br><span class="line">    <span class="function">std::unique_lock&lt;std::shared_timed_mutex&gt; <span class="title">lock</span><span class="params">(mutex)</span></span>;</span><br><span class="line">    sharedResource++;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Write operation: &quot;</span> &lt;&lt; sharedResource &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="10-std-exchange"><a href="#10-std-exchange" class="headerlink" title="10.std::exchange"></a>10.std::exchange</h2><p>c++14新增了一个接口<code>std::exchange</code>（头文件utility），其实这个也并不算是新增的，因为这个接口其实在c++11的时候就有了，只不过在c++11中作为一个内部函数，不暴露给用户使用，在c++14中才把它暴露出来给用户使用。使用方法也很简单。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::string s1 = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">    std::string s2 = <span class="string">&quot;world&quot;</span>;</span><br><span class="line">    std::<span class="built_in">exchange</span>(s1, s2);</span><br><span class="line">    std::cout &lt;&lt; s1 &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; s2 &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出结果</span></span><br><span class="line">world world</span><br></pre></td></tr></table></figure><p>我们可以看到，exchange会把第二个值赋值给第一个值，但是不会改变第二个值。我们来看下它的实现吧。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// Assign @p __new_val to @p __obj and return its previous value.</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> _Tp, <span class="keyword">typename</span> _Up = _Tp&gt;</span><br><span class="line">  _GLIBCXX20_CONSTEXPR</span><br><span class="line">  <span class="keyword">inline</span> _Tp</span><br><span class="line">  </span><br><span class="line">  <span class="built_in">exchange</span>(_Tp&amp; __obj, _Up&amp;&amp; __new_val)</span><br><span class="line">  <span class="built_in">noexcept</span>(__and_&lt;is_nothrow_move_constructible&lt;_Tp&gt;,</span><br><span class="line">    is_nothrow_assignable&lt;_Tp&amp;, _Up&gt;&gt;::value)</span><br><span class="line">  &#123; <span class="keyword">return</span> std::__exchange(__obj, std::forward&lt;_Up&gt;(__new_val)); &#125;  </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// C++11 version of std::exchange for internal use.</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> _Tp, <span class="keyword">typename</span> _Up = _Tp&gt;</span><br><span class="line">  _GLIBCXX20_CONSTEXPR</span><br><span class="line">  <span class="keyword">inline</span> _Tp</span><br><span class="line">  __exchange(_Tp&amp; __obj, _Up&amp;&amp; __new_val)</span><br><span class="line">  &#123;</span><br><span class="line">    _Tp __old_val = std::<span class="built_in">move</span>(__obj);</span><br><span class="line">    __obj = std::forward&lt;_Up&gt;(__new_val);</span><br><span class="line">    <span class="keyword">return</span> __old_val;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>通过注释我们可以明白含义，它的作用是把第二个值赋值给第一个值，同时返回第一个值的旧值。</p><p>除此之外，我们这里说明一个关键的点。exchange的第二个参数是万能引用，所以说他是既可以接收左值，也可以接收右值的，所以我们可以这样来使用。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::string s1 = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">    <span class="comment">// 第二个值是纯右值</span></span><br><span class="line">    std::<span class="built_in">exchange</span>(s1, <span class="string">&quot;world&quot;</span>);</span><br><span class="line">    std::cout &lt;&lt; s1 &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    std::string s2 = <span class="string">&quot;hello world&quot;</span>;</span><br><span class="line">    <span class="comment">// 第二个值通过move语义转成右值</span></span><br><span class="line">    std::<span class="built_in">exchange</span>(s1, std::<span class="built_in">move</span>(s2));</span><br><span class="line">    std::cout &lt;&lt; s1 &lt;&lt; <span class="string">&quot; | &quot;</span> &lt;&lt; s2 &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出结果，注意这里s2为空字符串，因为s2的东西已经被移动拷贝给s1了</span></span><br><span class="line">world</span><br><span class="line">hello world | </span><br></pre></td></tr></table></figure><h2 id="11-std-integer-sequence"><a href="#11-std-integer-sequence" class="headerlink" title="11.std::integer_sequence"></a>11.std::integer_sequence</h2><p>类模板 <code>std::integer_sequence</code> 表示一个编译时的整数序列。在用作<a href="https://zh.cppreference.com/w/cpp/language/function_template">函数模板</a>的实参时，能推导<a href="https://zh.cppreference.com/w/cpp/language/parameter_pack">参数包</a> <code>Ints</code> 并将它用于包展开。</p><p><a href="https://zh.cppreference.com/w/cpp/utility/integer_sequence">https://zh.cppreference.com/w/cpp/utility/integer_sequence</a></p><p>这个实在是太难懂了，搞不明白是干嘛的，放弃了😥</p><h2 id="12-std-quoted"><a href="#12-std-quoted" class="headerlink" title="12.std::quoted"></a>12.std::quoted</h2><p><a href="https://zh.cppreference.com/w/cpp/io/manip/quoted">https://zh.cppreference.com/w/cpp/io/manip/quoted</a></p><p>该函数模板位于 <code>&lt;iomanip&gt;</code> 头文件中，用于在输入输出流中处理被引号包围的字符串。它通常用于处理 CSV（逗号分隔值）文件或其他格式，其中字段被引号括起来以处理包含特殊字符（如逗号、换行符等）的情况。</p><p>对于<code>cout</code>而言，quoted会将字符串包围在双引号中输出</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">test_quorted</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::string data = <span class="string">&quot;Hello, \&quot;world\&quot;\n&quot;</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 输出流中使用 std::quoted，会将字符串在&quot;内包围输出</span></span><br><span class="line">    std::cout &lt;&lt; std::<span class="built_in">quoted</span>(data) &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ ./test</span><br><span class="line">&quot;Hello, \&quot;world\&quot;</span><br><span class="line">&quot;</span><br></pre></td></tr></table></figure><p>以下是官方给的一个示例</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iomanip&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sstream&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::stringstream ss;</span><br><span class="line">    std::string in = <span class="string">&quot;String with spaces, and embedded \&quot;quotes\&quot; too&quot;</span>;</span><br><span class="line">    std::string out;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">auto</span> show = [&amp;](<span class="type">const</span> <span class="keyword">auto</span>&amp; what) &#123;</span><br><span class="line">        &amp;what == &amp;in</span><br><span class="line">            ?   std::cout &lt;&lt; <span class="string">&quot;read in     [&quot;</span> &lt;&lt; in &lt;&lt; <span class="string">&quot;]\n&quot;</span></span><br><span class="line">                          &lt;&lt; <span class="string">&quot;stored as   [&quot;</span> &lt;&lt; ss.<span class="built_in">str</span>() &lt;&lt; <span class="string">&quot;]\n&quot;</span></span><br><span class="line">            :   std::cout &lt;&lt; <span class="string">&quot;written out [&quot;</span> &lt;&lt; out &lt;&lt; <span class="string">&quot;]\n\n&quot;</span>;</span><br><span class="line">    &#125;;</span><br><span class="line"> </span><br><span class="line">    ss &lt;&lt; std::<span class="built_in">quoted</span>(in);</span><br><span class="line">    <span class="built_in">show</span>(in);</span><br><span class="line">    ss &gt;&gt; std::<span class="built_in">quoted</span>(out);</span><br><span class="line">    <span class="built_in">show</span>(out);</span><br><span class="line"> </span><br><span class="line">    ss.<span class="built_in">str</span>(<span class="string">&quot;&quot;</span>); <span class="comment">// clear the stream buffer</span></span><br><span class="line"> </span><br><span class="line">    in = <span class="string">&quot;String with spaces, and embedded $quotes$ too&quot;</span>;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> delim &#123;<span class="string">&#x27;$&#x27;</span>&#125;;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> escape &#123;<span class="string">&#x27;%&#x27;</span>&#125;;</span><br><span class="line"> </span><br><span class="line">    ss &lt;&lt; std::<span class="built_in">quoted</span>(in, delim, escape);</span><br><span class="line">    <span class="built_in">show</span>(in);</span><br><span class="line">    ss &gt;&gt; std::<span class="built_in">quoted</span>(out, delim, escape);</span><br><span class="line">    <span class="built_in">show</span>(out);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">read in     [String with spaces, and embedded &quot;quotes&quot; too]</span><br><span class="line">stored as   [&quot;String with spaces, and embedded \&quot;quotes\&quot; too&quot;]</span><br><span class="line">written out [String with spaces, and embedded &quot;quotes&quot; too]</span><br><span class="line"> </span><br><span class="line">read in     [String with spaces, and embedded $quotes$ too]</span><br><span class="line">stored as   [$String with spaces, and embedded %$quotes%$ too$]</span><br><span class="line">written out [String with spaces, and embedded $quotes$ too]</span><br></pre></td></tr></table></figure><p>在给定的代码中，<code>delim</code> 和 <code>escape</code> 是用于指定自定义的分隔符和转义字符的参数。这些参数是用于 <code>std::quoted</code> 函数的重载形式，允许你指定不同于默认引号的字符来包围字符串，并指定一个不同于默认转义字符的字符来转义引号字符。以下是关于这两个参数的详细解释：</p><ol><li><code>delim</code>: 分隔符 在第一个用法中，<code>std::quoted</code> 函数使用了三个参数的重载形式：<code>std::quoted(in, delim, escape)</code>。<code>delim</code> 参数用于指定包围字符串的分隔符。通常情况下，<code>std::quoted</code> 使用双引号作为默认分隔符，但在某些情况下，你可能想要使用其他字符来包围字符串，以避免与字符串本身的字符冲突。在你的代码示例中，分隔符 <code>delim</code> 被设置为 <code>$</code>，这意味着字符串会被包围在 <code>$</code> 字符内。</li><li><code>escape</code>: 转义字符 <code>escape</code> 参数允许你指定一个字符，用于转义分隔符字符本身。在默认情况下，<code>std::quoted</code> 使用双引号 <code>&quot;</code> 作为转义字符，以确保在字符串中嵌入的引号不会被解释为结束引号。但如果你选择了自定义的分隔符，你可能还需要指定一个不同于默认转义字符的字符来进行转义。在你的代码示例中，转义字符 <code>escape</code> 被设置为 <code>%</code>，这意味着在字符串中，如果你想要表示分隔符 <code>$</code> 本身，你需要使用 <code>%$</code>。</li></ol><p>这部分也不是很容易搞明白它是干嘛的，如果面试官问道了就说我不会吧😭</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;学习C++14的那些新特性&lt;/p&gt;</summary>
    
    
    
    <category term="遇见C++" scheme="https://blog.musnow.top/categories/%E9%81%87%E8%A7%81C/"/>
    
    
    <category term="数据结构" scheme="https://blog.musnow.top/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    <category term="C++" scheme="https://blog.musnow.top/tags/C/"/>
    
    <category term="C++14" scheme="https://blog.musnow.top/tags/C-14/"/>
    
  </entry>
  
  <entry>
    <title>【leetcode】1137. 第 N 个泰波那契数</title>
    <link href="https://blog.musnow.top/posts/563921472/"/>
    <id>https://blog.musnow.top/posts/563921472/</id>
    <published>2023-08-27T09:32:44.000Z</published>
    <updated>2023-08-27T09:32:44.000Z</updated>
    
    <content type="html"><![CDATA[<p>今天是学习动归的第一天，先来一道简单题练练手吧！</p><h1 id="1-题目"><a href="#1-题目" class="headerlink" title="1.题目"></a>1.题目</h1><blockquote><p>leetcode <a href="https://leetcode.cn/problems/n-th-tribonacci-number/">1137. 第 N 个泰波那契数</a></p></blockquote><p>泰波那契序列 Tn 定义如下： </p><p>T0 &#x3D; 0, T1 &#x3D; 1, T2 &#x3D; 1, 且在 n &gt;&#x3D; 0 的条件下 <code>Tn+3 = Tn + Tn+1 + Tn+2</code></p><p>给你整数 <code>n</code>，请返回第 n 个泰波那契数 Tn 的值。</p><p>需要注意的是，这里的不是我们常用的斐波那契数列，哪个是 <code>Tn = Tn-1 + Tn-2</code>，而这里是三个；</p><h1 id="2-动归解法"><a href="#2-动归解法" class="headerlink" title="2.动归解法"></a>2.动归解法</h1><p>动态递归的思路是需要找到一个递归方程，本题中的递归方程已经给出来了。但是需要注意的是，当n小于3的时候，这个递归方程是不可用的（因为我们没有办法计算T<sub>负数</sub>的值）</p><h2 id="2-1-解法1-递归"><a href="#2-1-解法1-递归" class="headerlink" title="2.1 解法1-递归"></a>2.1 解法1-递归</h2><p>如下是我的第一个解法，通过递归函数计算数值，并提前写入0、1、2这三个数值到数组里面。</p><p>如果数组里面有值，直接取出来，如果没有值，在计算了之后再赋值到数组里面。这样就能保证在整个递归流程中，相同下标处的数据只会被计算一次（不这么做会超时）</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> DEF -1 <span class="comment">//默认值</span></span></span><br><span class="line">    <span class="comment">// 直接用递归会超时</span></span><br><span class="line">    <span class="comment">// 想法是将数据存到vector里面，避免针对某一个数的二次递归运算</span></span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> <span class="title function_">fib</span><span class="params">(<span class="type">int</span> n,<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;&amp; _map)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(_map[n] != DEF)&#123;</span><br><span class="line">            <span class="keyword">return</span> _map[n];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> ans = fib(n<span class="number">-1</span>,_map) + fib(n<span class="number">-2</span>,_map)+fib(n<span class="number">-3</span>,_map);</span><br><span class="line">        _map[n] = ans;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="title function_">tribonacci</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt; _map(<span class="number">40</span>,DEF);</span><br><span class="line">        _map[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        _map[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">        _map[<span class="number">2</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 初始化并传引用给递归函数</span></span><br><span class="line">        <span class="keyword">return</span> fib(n,_map);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>使用该方法的通过率如图</p><p><img src="https://img.musnow.top/i/2023/08/6da34c2bc594bf2893b2b0edaee08c21.png" alt="image-20230827172927657"></p><h2 id="2-2-方法2-迭代"><a href="#2-2-方法2-迭代" class="headerlink" title="2.2 方法2-迭代"></a>2.2 方法2-迭代</h2><p>还是相同的思路，只不过这次我们不用递归，而是用迭代来计算出数组里面对应下标的值，最后再返回给用户</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">tribonacci</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(n&lt;=<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> n;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt; _map(n+<span class="number">1</span>,DEF);</span><br><span class="line">    _map[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    _map[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    _map[<span class="number">2</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">3</span>;i&lt;_map.size();i++)&#123;</span><br><span class="line">        _map[i] = _map[i<span class="number">-3</span>] +_map[i<span class="number">-2</span>]+_map[i<span class="number">-1</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> _map[n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该办法的通过率如图，时间复杂度和空间复杂度都是<code>O(N)</code></p><p><img src="https://img.musnow.top/i/2023/08/eddf5511ea8346939633d018000e406f.png" alt="image-20230827173201195"></p><h2 id="2-3-迭代-变量"><a href="#2-3-迭代-变量" class="headerlink" title="2.3 迭代+变量"></a>2.3 迭代+变量</h2><p>既然在计算的时候我们只需要用到当前数据和该数据之前的3个变量，所以我们完全可以用固定的几个变量来实现这个操作，每次计算之后，都对变量进行一次轮换就ok了，官方的题解就是这么操作的</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">tribonacci</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (n &lt;= <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> p = <span class="number">0</span>, q = <span class="number">0</span>, r = <span class="number">1</span>, s = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">3</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        p = q;</span><br><span class="line">        q = r;</span><br><span class="line">        r = s;</span><br><span class="line">        s = p + q + r;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样操作，时间复杂度还是O(N)，但是空间复杂度就降到O(1)了！</p><p><img src="https://img.musnow.top/i/2023/08/0681a6444a756d58fe395a2202b0ce18.png" alt="image-20230827173339364"></p><h1 id="3-矩阵计算"><a href="#3-矩阵计算" class="headerlink" title="3.矩阵计算"></a>3.矩阵计算</h1><p>如果不用递归，还可以用矩阵乘法运算，该方法的时间复杂度是<code>O(LogN)</code></p><p><a href="https://leetcode.cn/problems/n-th-tribonacci-number/solutions/921898/di-n-ge-tai-bo-na-qi-shu-by-leetcode-sol-kn16/">https://leetcode.cn/problems/n-th-tribonacci-number/solutions/921898/di-n-ge-tai-bo-na-qi-shu-by-leetcode-sol-kn16/</a></p><p><img src="https://img.musnow.top/i/2023/08/a0431301252e331d1d2e9ac952358063.png" alt="image-20230827173653674"></p><p>奈何本人线代知识忘记了，完全看不懂</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">public:</span><br><span class="line">    <span class="type">int</span> <span class="title function_">tribonacci</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (n &lt;= <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="type">long</span>&gt;&gt; q = &#123;&#123;<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>&#125;, &#123;<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>&#125;, &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>&#125;&#125;;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="type">long</span>&gt;&gt; res = <span class="built_in">pow</span>(q, n);</span><br><span class="line">        <span class="keyword">return</span> res[<span class="number">0</span>][<span class="number">2</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="type">long</span>&gt;&gt; <span class="built_in">pow</span>(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="type">long</span>&gt;&gt;&amp; a, <span class="type">long</span> n) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="type">long</span>&gt;&gt; ret = &#123;&#123;<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>&#125;, &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>&#125;&#125;;</span><br><span class="line">        <span class="keyword">while</span> (n &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((n &amp; <span class="number">1</span>) == <span class="number">1</span>) &#123;</span><br><span class="line">                ret = multiply(ret, a);</span><br><span class="line">            &#125;</span><br><span class="line">            n &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">            a = multiply(a, a);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="type">long</span>&gt;&gt; multiply(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="type">long</span>&gt;&gt;&amp; a, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="type">long</span>&gt;&gt;&amp; b) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="type">long</span>&gt;&gt; c(<span class="number">3</span>, <span class="built_in">vector</span>&lt;<span class="type">long</span>&gt;(<span class="number">3</span>));</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">3</span>; j++) &#123;</span><br><span class="line">                c[i][j] = a[i][<span class="number">0</span>] * b[<span class="number">0</span>][j] + a[i][<span class="number">1</span>] * b[<span class="number">1</span>][j] + a[i][<span class="number">2</span>] * b[<span class="number">2</span>][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> c;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>测了一下效果，好像效率和使用2.3的办法没啥区别，那我还是用动归吧😭</p><p><img src="https://img.musnow.top/i/2023/08/858eede4f1ef9c10b2eb69f2150eae9d.png" alt="image-20230827173941225"></p><p>以后有时间了再来纠结这个答案的思路</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;今天是学习动归的第一天，先来一道简单题练练手吧！&lt;/p&gt;
&lt;h1 id=&quot;1-题目&quot;&gt;&lt;a href=&quot;#1-题目&quot; class=&quot;headerlink&quot; title=&quot;1.题目&quot;&gt;&lt;/a&gt;1.题目&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;leetcode &lt;a href=</summary>
      
    
    
    
    <category term="把题目都给刷干净" scheme="https://blog.musnow.top/categories/%E6%8A%8A%E9%A2%98%E7%9B%AE%E9%83%BD%E7%BB%99%E5%88%B7%E5%B9%B2%E5%87%80/"/>
    
    
    <category term="C++" scheme="https://blog.musnow.top/tags/C/"/>
    
    <category term="OJ刷题" scheme="https://blog.musnow.top/tags/OJ%E5%88%B7%E9%A2%98/"/>
    
    <category term="leetcode" scheme="https://blog.musnow.top/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>【技术】CDN/PCDN/SDN详解</title>
    <link href="https://blog.musnow.top/posts/292924834/"/>
    <id>https://blog.musnow.top/posts/292924834/</id>
    <published>2023-08-27T02:49:28.000Z</published>
    <updated>2023-08-27T02:49:28.000Z</updated>
    
    <content type="html"><![CDATA[<p>朴实的学习原因：京东实习生招聘条目上写了这些技术，那就给他学了！</p><span id="more"></span><blockquote><p>参考<br><a href="https://blog.csdn.net/baidu_41651554/article/details/122218513">https://blog.csdn.net/baidu_41651554/article/details/122218513</a></p></blockquote><p>嗨嗨嗨，直接上菜！</p><h1 id="1-CDN"><a href="#1-CDN" class="headerlink" title="1.CDN"></a>1.CDN</h1><p>CDN的全程是content delivery network，内容分发网络；说人话就是把网站产生的内容分发到各个用户请求的网络里去，具有 <strong>分布式</strong> 网络的特点！</p><h2 id="1-1-前置声明"><a href="#1-1-前置声明" class="headerlink" title="1.1 前置声明"></a>1.1 前置声明</h2><p>当代网络形势错综复杂，特别是视频、音频类网络服务的兴起，给互联网的贷款造成了很大的压力啊！</p><p>以之前很火的“延禧攻略”为例，当时曾经在某视频APP实现了1千万用户同时在线观看。如果大家观看的是1080p清晰度的视频（理论上需要4Mbps带宽），那么，累计需要的流量带宽是<br>$$<br>10,000,000×4Mbps&#x3D;40,000,000Mbps&#x3D;40Tbps<br>$$<br>这个数字老恐怖了！对于优酷、爱奇艺这样的互联网视频内容提供商来说，这无疑是非常巨大的流量压力。</p><p>如果按服务器用的10Gbps的万兆网卡来算，那也需要四千块万兆网卡才能顶得住这么大的流量消耗，更别提压根没有那么多地方给你插这么多网卡的事情了；</p><p>有这么一个说法：当用户打开一个页面，等待超过4秒，他就会关闭这个页面。也就是说，这个用户就会流失。用户流失对于公司来说可就是金钱流失！</p><p>所以，没有任何一家互联网服务提供商原因因为网络的问题而流失客户，那么我们就得像个办法来解决这种流量短时间暴发的问题！</p><p>而CDN，就是一项非常有效的<strong>缩短时延</strong>的技术。</p><h2 id="1-2-技术主体"><a href="#1-2-技术主体" class="headerlink" title="1.2 技术主体"></a>1.2 技术主体</h2><p>CDN缩短用户延时的办法也非常“简单”，其实就是将云服务部署到用户身边。在访问的时候，根据DNS的多线解析能力（即为不同地区提供不同的IP解析）选择离用户最近的服务器来为用户提供服务。</p><p><img src="https://img.musnow.top/i/2023/08/1298b6b472d89a0007ac82fb213b1aeb.png" alt="image-20230827105913951"></p><p>因为这样，CDN就在内容层面上进行了一定的筛选和分发，所以他就叫内容分发网络；</p><p>具体来说，CDN就是采用更多的缓存服务器（CDN边缘节点），布放在用户访问相对集中的地区或网络中。当用户访问网站时，利用全局负载技术，将用户的访问指向距离最近的缓存服务器上，由缓存服务器响应用户请求。（有点像电商的本地仓）</p><p>大家可能觉得，这个不就是“镜像服务器”嘛？其实不一样。镜像服务器是源内容服务器的完整复制。而CDN，是部分内容的缓存，智能程度更高。</p><p>确切地说，<strong>CDN&#x3D;更智能的镜像+缓存+流量导流</strong></p><p>而且还需要注意的是，CDN并不是只能缓存视频内容，它还可以对网站的静态资源（例如各类型图片、html、css、js等）进行分发，对移动应用APP的静态内容（例如安装包apk文件、APP内的图片视频等）进行分发。</p><p>CDN的具体工作流程。举个例子，如果某个用户想要访问优酷的视频点播内容，那么：</p><p><img src="https://img.musnow.top/i/2023/08/8ad3d099d1138c6b02472adeb5a2097c.png" alt="img"></p><p>具体步骤如下</p><ol><li>当用户点击对应资源内容，应用根据域名地址到底层触发DNS请求；</li><li>先是请求的本地运营商的DNS，再转发到CDN域名服务的DNS；</li><li>CDN域名服务的DNS会将CDN的<strong>全局均衡负载服务器</strong>的IP地址返回给用户；</li><li>用户向CDN的负载均衡设备发起URL的访问请求；</li><li>CDN的负载均衡设备根据用户IP地址，以及用户请求的内容URL，选择一台用户所属区域（离用户越近越好）的<strong>缓存服务器</strong>；</li><li>负载均衡设备告诉用户这台缓存服务器的IP地址，让用户向所选择的缓存服务器发起请求；</li><li>用户向缓存服务器发起请求，缓存服务器响应，将用户请求内容发送给用户</li><li>如果这台服务器上没有用户想要的内容，那就根据CDN设置的<strong>回源服务器</strong>（又称源站）来请求该URL</li><li>缓存服务器从<strong>源站</strong>拉取内容缓存到本地，并传输给用户；并根据用户设置的缓存策略来判断是否需要保留该资源到本地，是则进行缓存。</li></ol><p>在CDN工作的整个流程中，源站的服务器IP是对用户不可见的；CDN服务在实现了一定的资源访问加速的基础上，还附带了隐藏源站IP的功能，避免源站直接遭受火力打击（指服务器被攻击）</p><h2 id="1-3-静态加速"><a href="#1-3-静态加速" class="headerlink" title="1.3 静态加速"></a>1.3 静态加速</h2><p>所谓静态加速，是只加速源站所提供服务中的静态资源，包括js、html、css、图片、音视频等不会出现变动的资源文件。将这些资源在CDN云服务器内进行缓存，用户访问静态资源的时候从CDN传输给用户，访问asp、php、jsp等动态资源的时候，从源站抓取，既保证了数据的及时性，又提高了静态资源的加载速度。</p><p>相比于动态资源文件，静态资源，特别是图片，是访问过程中消耗流量较大的部分；使用静态资源加速能大大减轻源站的网络贷款和资源负载的压力，又减少了用户的加载速度，使得网络服务能更快的展现在用户面前；</p><h2 id="1-4-动态加速"><a href="#1-4-动态加速" class="headerlink" title="1.4 动态加速"></a>1.4 动态加速</h2><p>动态加速是指CDN的DNS解析中通过动态链路探测，监控网络环境的变化，监控各地网络延迟，寻找到一条最<strong>稳定、最高效、最快速</strong>的路径，回源动态资源，从而实现动态资源（如asp、php、jsp等）加速。然后构成链路列表，绑定到DNS解析上，更新到CDN的本地域名服务器上。简单架构见下图所示。</p><p><img src="https://img.musnow.top/i/2023/08/9b51e87fe04bacbd8591b55e5d62f679.png" alt="img"></p><h2 id="1-5-数据节点的更新和同步"><a href="#1-5-数据节点的更新和同步" class="headerlink" title="1.5 数据节点的更新和同步"></a>1.5 数据节点的更新和同步</h2><p>cdn分为推拉两种方式</p><ul><li>推是服务器将内容推到cdn节点上</li><li>拉是cdn在第一次接受请求的时候从服务器拉取资源进行响应并保存</li></ul><p>当资源在cdn缓存之后，如果服务器上的资源发生变化，cdn节点是不会知道的，除非缓存时间到期重新拉取或者修改新资源的访问。</p><p>动态资源的话，一般都是无延迟的。静态对于 css 和 js 来说，建议在编译生成的阶段，为文件名加上时间戳。而且最好是在文件名里面，而不是 querystring 里面加。这是最方便的方案，因为一旦发生了更新，每次去取的一定是新文件，不涉及缓存刷新的问题。</p><h2 id="1-6-CDN的好处"><a href="#1-6-CDN的好处" class="headerlink" title="1.6 CDN的好处"></a>1.6 CDN的好处</h2><h3 id="1-6-1-对服务商"><a href="#1-6-1-对服务商" class="headerlink" title="1.6.1 对服务商"></a>1.6.1 对服务商</h3><p>采用CDN技术，最大的好处，就是加速了网站的访问——用户与内容之间的物理距离缩短，用户的等待时间也得以缩短。</p><p>而且，分发至不同线路的缓存服务器，也让<strong>跨运营商</strong>之间的访问得以加速。例如中国移动手机用户访问中国电信网络的内容源，可以通过在中国移动假设CDN服务器，进行加速。效果是非常明显的。</p><p>此外，CDN还有安全方面的好处。内容进行分发后，<strong>源服务器的IP被隐藏</strong>，受到攻击的概率会大幅下降。而且，当某个服务器故障时，系统会调用临近的健康服务器，进行服务，避免对用户造成影响。</p><p>正因为CDN的好处很多，所以，目前所有主流的互联网服务提供商，都采用了CDN技术。所有的云服务提供商，也都提供了CDN服务（价格，按流量计费）</p><h3 id="1-6-2-对通信行业"><a href="#1-6-2-对通信行业" class="headerlink" title="1.6.2 对通信行业"></a>1.6.2 对通信行业</h3><ul><li><strong>互联网服务提供商</strong>采用CDN，是以存储换时延。花钱购置CDN服务器或云计算服务，以此换取更好的用户体验。</li><li><strong>通信运营商</strong>也追捧CDN，但它们的目的，是以存储换带宽 ——通过服务“下沉”，减轻上层骨干网络的流量压力，避免硬件扩容，降低网络建设成本。</li></ul><p>以上文提到的爱奇艺看视频的高带宽问题为例，如果不采用CDN，那就是巨大的流量流入同一个机房，这会导致这个机房入网&#x2F;出网的线路被拥塞，影响其他业务的进行！</p><p>同样的，如果大量的业务流量数据在骨干网跑来跑去，<strong>骨干网肯定吃不消，要拼命扩容</strong>。如果这些业务流量数据在底层就被解决了，那么，骨干网的带宽压力自然就减轻了。</p><p>很多运营商已经将CDN下沉到地市级，以此减轻压力，同时可以提升用户体验！可谓是一举两得的美事！</p><p><img src="https://img.musnow.top/i/2023/08/9806e61f7d240e45b2701d25668935e7.png" alt="img"></p><h1 id="2-PCDN"><a href="#2-PCDN" class="headerlink" title="2.PCDN"></a>2.PCDN</h1><p>PCDN技术是P2P技术+CDN技术的集和，在认识PCDN之前，我们首先要简单了解一下P2P技术</p><h2 id="2-1-P2P"><a href="#2-1-P2P" class="headerlink" title="2.1 P2P"></a>2.1 P2P</h2><p>P2P即<code>Peer to Peer</code>，纯P2P架构包含如下内容</p><ul><li>没有总是在线的服务器</li><li>任意端之间直接通信</li><li>对等放之间可以间断链接，并可以动态改变IP地址</li></ul><p>实际的用例如下</p><ul><li>文件分发（BT下载）</li><li>流媒体</li><li>VolP</li><li>内网穿透式访问（建立P2P链接，直接和内网主机通信）</li></ul><p><img src="https://img.musnow.top/i/2023/08/ebc51e20db9f5b31b0067fead78826ae.png" alt="image"></p><p>关于P2P想了解更多信息可以查看此文：<a href="https://cloud.tencent.com/developer/article/2095486">详解P2P技术</a></p><h2 id="2-2-PCDN"><a href="#2-2-PCDN" class="headerlink" title="2.2 PCDN"></a>2.2 PCDN</h2><h3 id="2-2-1-流程"><a href="#2-2-1-流程" class="headerlink" title="2.2.1 流程"></a>2.2.1 流程</h3><p>前面提到了，PCDN是P2P+CDN，那么其是如何将P2P技术和CDN结合起来的呢？</p><p>在阿里云官网上可以看到对PCDN的介绍：<a href="https://developer.aliyun.com/article/130907">一篇文章解读提速、降费黑科技：PCDN定义、功能、架构、场景和优势</a>；本文是对这篇文章的个人理解。</p><blockquote><p>PCDN产品是与传统CDN互补协作的关系，以P2P技术为核心的分布式PCDN系统可与传统CDN、云CDN无缝集成，形成互补协作，相对于CDN拥有成本更低、质量更好两方面的核心优势。</p></blockquote><p>P2P 内容分发网络（英文名：P2P CDN，以下简称PCDN）是以P2P技术为基础，通过挖掘利用边缘网络海量碎片化闲置资源而构建的低成本高品质内容分发网络服务。你可以通过集成PCDN SDK（以下简称SDK）接入该服务后能获得等同（或略高于）CDN的分发质量，同时显著降低分发成本。适用于<strong>视频点播、直播、大文件下载</strong>等业务场景。</p><p>使用PCDN后的http请求处理流程如下图：</p><p><img src="https://img.musnow.top/i/2023/08/d2bba1440e3c9b80ec949459fd8617a8.png" alt="image-20230827133437729"></p><p>P2P的加入，就是将一些数据<strong>预先留存在部分终端设备</strong>（比如家用路由器，个人电脑，个人NAS）等产品上，再通过P2P技术，从这些Peer做种端获取到一部分数据，以此为周边用户提供服务。</p><p>使用PCDN的SDK后，在请求DNS之后，还会去请求<strong>PCDN的调度系统</strong>，PCDN同时会返回可用的CDN服务器，和可用的P2P做种端，用户能同时从<strong>多端</strong>获取到数据（根据文件分块，从不同地方获取同一文件不同分块的数据，提高文件下载速度）</p><p>比如一个文件有1MB，那么使用PCDN，我们可能服务商的从<strong>CDN服务器</strong>拉取了500KB，再从上图中所示的两个peerid端获取到了500KB数据；因为使用的是个人的peer终端节点，不仅数量多，<strong>且分布比CDN服务器更广</strong>，理论上来说至少能获得<strong>等同于</strong>仅使用CDN技术的速度优势，如果用户可以连接到的peer较多，则速度就会<strong>大于</strong>仅使用CDN技术！</p><p>而这些作为peer的做种端，会定期从CDN缓存一部分热门数据到本地，并为其他与自己建立P2P链接的终端提供服务。</p><blockquote><p>京东云路由器、迅雷的网心云、百度云盘PC客户端的闲时带宽上传策略，其实都是使用了PCDN技术的终端产品，其会在占用一小部分用户带宽的基础上，给用户提供京豆&#x2F;现金奖励；但是PCDN似乎和运营商的政策冲突，具体的就不了解了，本文只是来学习技术的。</p></blockquote><h3 id="2-2-2-优点"><a href="#2-2-2-优点" class="headerlink" title="2.2.2 优点"></a>2.2.2 优点</h3><p>以下优点来自阿里云那篇文章</p><ul><li><p>价格低：通过P2P技术可为客户提供更低成本的内容分发服务，（以峰值带宽计价）为云CDN价格的1&#x2F;2，为传统CDN价格的1&#x2F;4，可显著降低客户的分发成本；</p><p>因为使用了更多P2P节点，减轻了CDN服务器、源站服务器的网络带宽压力，所以PCDN能在一定程度上起到降本增效的作用。</p></li><li><p>质量好：通过CDN+P2P多级节点调度，一个请求可由CDN和多个P2P源同时提供内容，通过资源冗余提高了服务可用性，播放流畅率高于纯CDN，在大文件下载场景中更是能极大提高下载速度；通过调用海量分布式P2P节点， 平均播放流畅率 &gt; 97%，平均首播时间小于1秒，用户体验得到有效提升。</p></li><li><p>成熟稳定：多年为优酷土豆提供优质的视频播放、下载等加速服务，接入带宽超10T，经历了海量用户规模的<strong>长时间验证</strong>。拥有内网穿透、缓存处理、种子管理、传输策略等各方面的核心技术和专利；（这是阿里云给自己打的广告）</p></li></ul><p><img src="https://img.musnow.top/i/2023/08/16fb75b6c4dae42f968da0e5510cd069.png" alt="image-20230827135320425"></p><h2 id="2-3-常见名词"><a href="#2-3-常见名词" class="headerlink" title="2.3 常见名词"></a>2.3 常见名词</h2><p>以下是PCDN中常见的名词；这里面漏了的一级节点指的应该是CDN服务器；</p><p><img src="https://img.musnow.top/i/2023/08/121f5a17dd247d2ba0cd17676bf53139.png" alt="image-20230827134515066"></p><p>由此可见，上文提到的京东云路由器、迅雷的网心云，这些客户端在用户的电脑启动后，其就是作为PCDN的<strong>三级节点</strong>接入整个PCDN的网络的，其提供的也是三级带宽；</p><h2 id="2-4-基础架构"><a href="#2-4-基础架构" class="headerlink" title="2.4 基础架构"></a>2.4 基础架构</h2><p>关键组件</p><ul><li>index服务：全局调度，把用户请求调度到最佳的机房</li><li>ZooKeeper (Global&amp;Local)：服务活动情况汇报给调度服务，动态配置更新</li><li>Nignx Proxy：支持私有协议的Nginx代理服务，针对不同文件一致性Hash到不同的Channel服务</li><li>Channel服务：记录文件和拥有文件的端点地址信息，为下载提供就近的端点地址</li><li>Realy服务：服务P2P建立连接和通讯</li><li>Hot服务：hot文件发现和推送</li></ul><p>以下是PCDN技术的架构图</p><p><img src="https://img.musnow.top/i/2023/08/459dd3bd580e337a248093066360ca91.png" alt="image-20230827135429913"></p><p>整个技术的流程在上文已经讲解过了。这里的架构图阿里云的文章并没有提供更多的说明，具体的就得在真正需要开发PCDN的时候在公司内部深入学习了。</p><h2 id="2-5-适用范围"><a href="#2-5-适用范围" class="headerlink" title="2.5 适用范围"></a>2.5 适用范围</h2><p>PCDN产品适用于视频点播、直播、大文件下载等业务领域。</p><ul><li>视频点播：长视频点播，热度集中的短视频点播。</li><li>视频直播：大型晚会赛事直播、地方网台直播、秀场互动直播。</li><li>大文件下载：超过1MB且热度集中的的文件分发，如应用市场分发、在线音频分发。</li></ul><h1 id="3-SDN"><a href="#3-SDN" class="headerlink" title="3.SDN"></a>3.SDN</h1><p>SDN全称<code>Software Defined Network</code>，概念最早由斯坦福大学的<code>Nick McKeown</code>教授于2009年提出；谷歌于2010到2012年建立的数据中心网络B4是SDN的成功案例；</p><p>该技术学习于b站<a href="https://www.bilibili.com/video/BV15L411E7eE/?share_source=copy_web&vd_source=7fc715db968d24a91828ac8fad0e1ad8">【408 计算机网络新增考点—软件定义网络SDN（字幕版）】</a></p><h2 id="3-1-看看路由器的功能"><a href="#3-1-看看路由器的功能" class="headerlink" title="3.1 看看路由器的功能"></a>3.1 看看路由器的功能</h2><p>路由器具备如下功能</p><ul><li>报文转发</li><li>路由选择</li></ul><p>在当前的路由器架构中，分为数据层面和控制层面。</p><ul><li>为了构建出自己的路由表，路由器必须要和周边的其他路由器定期通信，才能通过自己的路由算法设置出路由表，并选择正确的路由路径（这个耗时较长）</li><li>在数据层面，路由器采用硬件，查表进行转发（耗时低）</li></ul><p><img src="https://img.musnow.top/i/2023/08/f7ec770dd37e6f4a19c73cd9133cdf90.png" alt="image-20230827143545493"></p><blockquote><p><strong>分组</strong>是网络专有名词。大多数<a href="https://baike.baidu.com/item/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/18763?fromModule=lemma_inlink">计算机网络</a>都不能连续地传送任意长的数据，所以实际上网络系统把<a href="https://baike.baidu.com/item/%E6%95%B0%E6%8D%AE%E5%88%86%E5%89%B2/4395664?fromModule=lemma_inlink">数据分割</a>成小块，然后逐块地发送，这种小块就称作分组（packet）。也有些书籍把分组定义为网络层的<a href="https://baike.baidu.com/item/%E5%8D%8F%E8%AE%AE%E6%95%B0%E6%8D%AE%E5%8D%95%E5%85%83/8226389?fromModule=lemma_inlink">协议数据单元</a>。</p><p>说白了分组就是一个报文！</p></blockquote><h2 id="3-2-SDN核心思想"><a href="#3-2-SDN核心思想" class="headerlink" title="3.2 SDN核心思想"></a>3.2 SDN核心思想</h2><blockquote><p>SDN这种新型<strong>网络体系结构</strong>的核心思想，是将网络的控制层和数据层面玻璃，让控制层可以通过软件来控制数据层的较多设备</p></blockquote><p>在SDN体系中，路由器的路由软件被剥离开，路由器之间也不再需要交换路由信息。</p><ul><li>控制层面：有一个逻辑上集中的远程控制器，对多个交换机进行控制；该远程控制器可以由多台物理主机组成</li></ul><p>远程控制器会掌握各个主机和整个网络体系的状态，并为每一个路由分组计算出最佳的路由，和生成正确的转发表；这时候，底层的路由器硬件就仅仅需要进行查表转发，而不需要进行耗时的路由表生产和算法计算了，大大减轻了底层交换机和路由器硬件的压力。</p><p><img src="https://img.musnow.top/i/2023/08/feb23bbf0d7ea8acff297ff8111488fa.png" alt="image-20230827145453526"></p><h2 id="3-3-OpenFlow协议"><a href="#3-3-OpenFlow协议" class="headerlink" title="3.3 OpenFlow协议"></a>3.3 OpenFlow协议</h2><p>OpenFlow协议是一个受到高度认可的标准，其一般在SDN中进行使用，但SDN并不一定要用OpenFlow；</p><blockquote><p>OpenFlow协议由<strong>开放网络基金会ONF</strong>负责指定，该基金会致力于SDN的发展和标准化；OpenFlow协议目前较为成熟的是1.3版本</p></blockquote><p>OpenFlow协议是SDN体系结构中，控制层面和数据层面之间的通信接口，该协议可以允许控制层面的控制器对数据层面的物理设备进行直接的访问和控制。</p><p><img src="https://img.musnow.top/i/2023/08/0c9a0b49911c437a7d31a4090004fa1a.png" alt="image-20230827145816552"></p><h2 id="3-4-路由转发的区别"><a href="#3-4-路由转发的区别" class="headerlink" title="3.4 路由转发的区别"></a>3.4 路由转发的区别</h2><h3 id="3-4-1-传统路由表"><a href="#3-4-1-传统路由表" class="headerlink" title="3.4.1 传统路由表"></a>3.4.1 传统路由表</h3><p>传统的路由转发是查询路由表，根据地址掩码计算目的网络，判断是否与当前条目匹配，如果匹配，则从对应的「下一条」中发送出去。</p><p>路由转发这部分内容在我的IP协议详解博客中有所涉及：<a href="https://blog.musnow.top/posts/3482559497/">点我</a></p><p><img src="https://img.musnow.top/i/2023/08/e154eeaf46fb0ce68d4ca6c6ea946920.png" alt="image-20230827150215508"></p><h3 id="3-4-2-SDN广义转发"><a href="#3-4-2-SDN广义转发" class="headerlink" title="3.4.2 SDN广义转发"></a>3.4.2 SDN广义转发</h3><p>SDN在这基础上新增了更多的内容，称为<strong>广义转发</strong>：</p><ol><li>进行匹配：能够对网络体系结构中的各层（数据链路层，网络层，传输层）首部中的字段进行匹配</li><li>执行动作：不仅转发分组，还可以实现负载均衡、重写IP首部（类似NAT中的路由地址转换）、人为阻挡或丢弃一些分组（类似防火墙）</li></ol><p>在SDN广义转发中，完成这一操作的设备不再称为路由器，而是叫做OpenFlow交换机（或分组交换机），也可以简称为交换机。</p><h3 id="3-4-3-流表"><a href="#3-4-3-流表" class="headerlink" title="3.4.3 流表"></a>3.4.3 流表</h3><p>在SDN中替代 了传统路由表的是「流表（Flow Table）」</p><ul><li>一个流就是整个网络中的一组分组序列，在此序列中的每个分组都是<code>共享分组首部某些字段的值</code>，例如，某个流可以是共享相同的源IP和目的IP地址的一连串分组</li><li>OpenFlow交换机中的刘表是由SDN远程控制器来管理的，SDN远程控制器通过一个安全信道，通过OpenFlow协议来管理OpenFlow交换机中的流表</li></ul><p><img src="https://img.musnow.top/i/2023/08/da25636e91b2ab521809adc0d568a7d4.png" alt="image-20230827150934738"></p><ul><li>每个OpenFlow交换机必须有一个或者多个流表</li><li>每一个流表包含多个流表项目</li><li>每个流表项包含三个字段：首部字段值（匹配字段）、计数器、动作（类似下一跳）</li></ul><p>OpenFlow的首部字段值跨越了三个层次的首部，既可以处理数据链路层的MAC帧，又可以处理IP报文，或者是TCP&#x2F;UDP的端口</p><p><img src="https://img.musnow.top/i/2023/08/fa579c04d7c630a4b94a6158c1b0d384.png" alt="image-20230827151212669"></p><p>计数器字段包含一组计数器</p><ul><li>记录已经与该流表项匹配的分组数量的计数器；</li><li>记录该流表项上次更新到现在经历的时间的计数器</li></ul><p>动作字段是一族动作，当分组匹配到某个流表项时，执行下方的一个或者多个动作</p><ul><li>把分组转发到指定的端口</li><li>丢弃分组</li><li>把分组进行复制后，从多个端口转发出去</li><li>重写分组中的首部字段</li></ul><h3 id="3-4-4-VLAN"><a href="#3-4-4-VLAN" class="headerlink" title="3.4.4 VLAN"></a>3.4.4 VLAN</h3><blockquote><p>关于该报文中VLAN部分可以查看此博客：<a href="https://blog.csdn.net/LawssssCat/article/details/127204720">https://blog.csdn.net/LawssssCat/article/details/127204720</a></p></blockquote><p>VLAN是一种用于进一步虚拟化划分局域网的方式，假如一台路由器有4个网口，其可以通过将LAN1和LAN2设置成VLAN10，LAN3和LAN4设置成VLAN20来模拟出两个局域网</p><p><img src="https://img.musnow.top/i/2023/08/8cfceb7090ae21914683d034f680f485.png" alt="image-20230827153454860"></p><p>vlan（virtual lan）技术提供了一种灵活的解决方案；将交换机的接口根据业务需要添加到不同的vlan中，从而实现二层隔离。</p><ul><li>隔离广播域，即广播包只在本 vlan 中传播，从而在一定程度上可以提高整个网络的处理能力；</li><li>提高安全性，一个 vlan 内的用户和其他 vlan 内的用户不能互访，提高了网络的安全性；</li><li>增加带宽利用&#x2F;降低延迟&#x2F;管理作用</li></ul><h2 id="3-5-举例"><a href="#3-5-举例" class="headerlink" title="3.5 举例"></a>3.5 举例</h2><h3 id="3-5-1-简单转发"><a href="#3-5-1-简单转发" class="headerlink" title="3.5.1 简单转发"></a>3.5.1 简单转发</h3><p>通过不同的流表项来设置转发路径和转发动作，动作中的<code>转发(3)</code>代表从该交换机的3号端口转发出去。端口号在图中有标注；</p><p><img src="https://img.musnow.top/i/2023/08/6faaa19507feedb4784efd2c5a5ac376.png" alt="image-20230827151650945"></p><h3 id="3-5-2-负载均衡"><a href="#3-5-2-负载均衡" class="headerlink" title="3.5.2 负载均衡"></a>3.5.2 负载均衡</h3><p>第二个栗子是负载均衡的栗子，在下面的场景中，我们想要H3发送的分组通过<code>S2-S1-S3-H5/H6</code>，要H4发送的分组通过<code>S2-S3-H5/H6</code>；以达到负载均衡的目的。</p><p><img src="https://img.musnow.top/i/2023/08/5f152f13954536e40cb1b6b815f0c9ad.png" alt="image-20230827151718483"></p><p>使用传统的源IP和目的IP的转发方式，无法实现这样的负载均衡。在传统场景下，当S2在数据链路层发现目的MAC地址是S3的MAC地址的时候，无论如何都会直接发送给S3，而不是从S1处绕路。</p><p>但在SDN场景中，就可以通过两个不同的流表项来规定不同转发动作，实现这样的负载均衡（这里的<code>转发(4)</code>代表从S2的4号端口转发出去）</p><p><img src="https://img.musnow.top/i/2023/08/2d076ac5eca2dc6f7480020f2e0fd57f.png" alt="image-20230827151948106"></p><h3 id="3-5-3-防火墙"><a href="#3-5-3-防火墙" class="headerlink" title="3.5.3 防火墙"></a>3.5.3 防火墙</h3><p>如果我们想让S2主机只接收来自S1的数据而不接受S3的数据，就可以通过只设置S1的源IP地址的流表项，来丢弃S3发送的数据（匹配不上的数据就会被丢弃）</p><p><img src="https://img.musnow.top/i/2023/08/f7be65147a7d7897ae6d4402ad2d8f26.png" alt="image-20230827152217555"></p><h2 id="3-6-SDN体系结构的特征"><a href="#3-6-SDN体系结构的特征" class="headerlink" title="3.6 SDN体系结构的特征"></a>3.6 SDN体系结构的特征</h2><p>下图中包含了SDN的体系结构一览图和SDN的四个关键特征</p><ol><li>基于流的转发</li><li>数据层面与控制层面分离</li><li>位于数据层面分组交换机之外的网络控制功能</li><li>可编程的网络</li></ol><p>其中，SDN控制器是这个架构中最复杂的设备，其通过南向API控制底层的OpenFlow交换机，通过北向API接受其他网络控制器的策略配置。</p><p><img src="https://img.musnow.top/i/2023/08/a6678beda5464d34757501e8cc95580e.png" alt="image-20230827152358531"></p><h3 id="3-6-1-SDN控制器"><a href="#3-6-1-SDN控制器" class="headerlink" title="3.6.1 SDN控制器"></a>3.6.1 SDN控制器</h3><p>SDN控制器可以分成三个层次</p><ul><li>其通信层通过OpenFlow协议与交换机通信</li><li>中间间来根据各种策略管理各个交换机</li><li>北向API接收来自其他控制策略发起端的配置</li></ul><p><img src="https://img.musnow.top/i/2023/08/46dc0f081cfa38af5ea0d3d89e0ccc68.png" alt="image-20230827152554869"></p><p>这里使用的<code>RESTful API </code>是基于HTTP的API，也是我们较常见的API接口；</p><h3 id="3-6-2-开源SDN控制器"><a href="#3-6-2-开源SDN控制器" class="headerlink" title="3.6.2 开源SDN控制器"></a>3.6.2 开源SDN控制器</h3><p>常用的开源SDN控制器有OPEN DAYLIGHT和ONOS；</p><h3 id="3-6-3-SDN的优势"><a href="#3-6-3-SDN的优势" class="headerlink" title="3.6.3 SDN的优势"></a>3.6.3 SDN的优势</h3><blockquote><p>原文链接：<a href="https://blog.csdn.net/as12138/article/details/131273381">https://blog.csdn.net/as12138/article/details/131273381</a></p></blockquote><p>SDN相比于传统网络架构，有许多优点和优势。</p><ol><li><p>高度可编程性：SDN架构中的控制器负责管理交换机和路由器，使得网络更加可编程、可配置。管理员可以通过控制器实现灵活调整网络拓扑、管理流量和配置流调度策略，提升网络的可演变性、可定制化和可伸缩性。</p></li><li><p>网络智能集中化：在SDN中，网络智能被集中在控制器中，通过控制器进行集中式管理和控制。这种分离的模式避免了网络设备中任务的复杂，提升了网络的可管理性和可控制性。此外，集中化的管理方式也可以在网络中间件和应用中实现智能控制，如分布式存储、云计算等。</p></li><li><p>可扩展性：SDN中的网络设备是通用的硬件设备，不需要特定的功能区分，同时也不需要更新硬件，只需更新控制器即可实现拓扑可伸缩和灵活的网络管理。</p></li><li><p>自动化和提高效率：SDN中可以实现网络的自动化，通过控制器进行自动化的网络管理，可以避免手动管理网络的局限性和不确定性，从而提高网络的效率和稳定性，同时，自动化网络管理也可以降低网络维护的成本和时间。</p></li><li><p>安全可靠性提升：网络安全和可靠性是企业网络中最基本的需求。传统的网络安全往往需要通过一些特定设备和协议来实现。相比之下，SDN中的控制器可以根据网络实时状态自动优化管理策略，安全可靠的方式来提高网络的安全性。</p></li></ol><p>总之，SDN的优势在于其灵活的可编程性、集中式智能管理、高效的自动化网络管理和增强网络安全性。以上优势也是SDN技术应用广泛的主要原因，越来越多的企业和组织将SDN技术应用到自己的网络架构中，以满足未来网络的需求和挑战。</p><h2 id="3-6-4-SDN应用前景"><a href="#3-6-4-SDN应用前景" class="headerlink" title="3.6.4 SDN应用前景"></a>3.6.4 SDN应用前景</h2><p>SDN技术目前已经实现了基础网络配置、流控制、网络安全等功能。在未来，SDN技术还会面临更多的挑战和机遇。</p><ol><li><p>5G时代：5G技术将会改变网络的面貌，加速物联网应用的普及。SDN作为架构灵活、可编程的网络方式，将会在5G网络中发挥重要作用，实现网络的自动化和智能化管理。</p></li><li><p>IoT设备：物联网技术带来大量设备的连接，SDN技术的价值在于自动化了物联网设备的管理、安全和监控。未来，SDN技术将会成为物联网管理的重要工具。</p></li><li><p>AI：随着人工智能的发展，SDN的业界应用已经开始大规模落地。这将加速智能交通、智能城市和自动驾驶等领域的发展。</p></li><li><p>集成新技术：SDN可以很容易地与其他技术相结合，例如NFV（网络功能虚拟化）和AI（人工智能），以提高网络的效率和适应性。</p></li><li><p>云计算：SDN技术的灵活性和可编程性，也使得SDN与云计算等新技术的结合变得更加自然。在未来，SDN技术将与云技术紧密结合，实现业务流程的自动化、快速应用部署和弹性云资源管理。</p></li></ol><p>总而言之，SDN技术将为未来网络的发展和实现各种应用提供支撑。在日益增长的网络需求和复杂的网络技术背景下，SDN的灵活性和高可用性将会带来更大的发展空间和市场需求。SDN技术应当继续研究和发展，以满足更多的网络需求和挑战。</p><h2 id="3-7-总结"><a href="#3-7-总结" class="headerlink" title="3.7 总结"></a>3.7 总结</h2><p><img src="https://img.musnow.top/i/2023/08/3a0e7fd1ff2494f51ec6121d4a60e108.png" alt="image-20230827152810972"></p>]]></content>
    
    
    <summary type="html">朴实的学习原因：京东实习生招聘条目上写了这些技术，那就给他学了！</summary>
    
    
    
    <category term="差生文具多" scheme="https://blog.musnow.top/categories/%E5%B7%AE%E7%94%9F%E6%96%87%E5%85%B7%E5%A4%9A/"/>
    
    
    <category term="CDN" scheme="https://blog.musnow.top/tags/CDN/"/>
    
    <category term="SDN" scheme="https://blog.musnow.top/tags/SDN/"/>
    
  </entry>
  
  <entry>
    <title>【API】API的各种分类详解</title>
    <link href="https://blog.musnow.top/posts/73383828/"/>
    <id>https://blog.musnow.top/posts/73383828/</id>
    <published>2023-08-26T12:15:18.000Z</published>
    <updated>2023-08-26T12:15:18.000Z</updated>
    
    <content type="html"><![CDATA[<p>API，即应用程序编程接口，是为了方便应用程序之间的数据和功能交互而设计的一些标准方法。API 的分类可以从多个维度进行，我会对 API 的分类维度进行简单的介绍。</p><span id="more"></span><h2 id="根据使用方式的不同"><a href="#根据使用方式的不同" class="headerlink" title="根据使用方式的不同"></a>根据使用方式的不同</h2><p>通常情况下，API 可以分为两种使用方式：内部 API 和外部 API。</p><p>内部 API 是指供企业内部开发人员和应用所使用的 API。当企业需要一些定制化的应用程序或者集成特定的功能时，内部 API 可以提供更好的技术支持，同时也能保证数据的安全性和可靠性。</p><p>外部 API 则是供公众开发者使用的 API，通过提供数据和服务，使得外部的开发者可以构建丰富的应用程序并与当前的生态系统进行协作。越来越多的各类公司都开始向公众提供自己的 API，示例包括 Facebook、Twitter、Google 等。</p><h2 id="根据访问方式的不同"><a href="#根据访问方式的不同" class="headerlink" title="根据访问方式的不同"></a>根据访问方式的不同</h2><p>根据 API 的访问方式，API 可以分为以下几种：</p><ul><li>RESTful API REST（Representational State Transfer）是一种基于 HTTP 协议的 Web 应用程序架构标准。RESTful API 遵循 RESTful 架构的原则，通常由资源路径和请求方法组成，以达到可读性高、灵活性好的目的。</li><li>SOAP API SOAP（Simple Object Access Protocol）是一种基于 XML 编码的远程调用协议，比较复杂而且处理时间和网络资源使用率高。虽然 SOAP 技术已经逐渐淡出市场，但在某些特殊场景下仍然会有所应用。</li><li>GraphQL API GraphQL 是由 Facebook 公司开源的一种数据查询语言和 API 执行引擎，可以呈现出 XML schema 来表达整个数据的结构，并为前端工程师提供自由定义获取所需属性、代码重用等人性化的特色。</li><li>gRPC API gRPC 可以理解为 Google Remote Procedure Call，是 Google 最新开源的跨语言 RPC 框架。借助基于 HTTP&#x2F;2 的二进制传输协议，gRPC 提供了比 JSON 和 RESTful 更快速和更可靠的通讯方式。</li></ul><h2 id="根据功能的不同"><a href="#根据功能的不同" class="headerlink" title="根据功能的不同"></a>根据功能的不同</h2><p>根据 API 的功能性质，API 可以分为以下几类：</p><ul><li>Web API Web API 一般都针对 Web 应用程序，提供一些标准的接口，例如：W3C DOM 接口、HTTP 接口、WebSocket 接口、Web Worker 接口等。这些 API 帮助浏览器取得用户元素信息、发送 AJAX 请求等等。</li><li>操作系统 API 操作系统 API（如 Windows API 或 POSIX API）提供了与操作系统软件交互的方法，允许应用程序查询及控制硬件设备或操作系统内核任务等。此类 API 几乎适用于任何类型的环境。</li><li>数据库 API 数据库 API 可以使应用程序通过某些 API 实现对一些数据存储的操作，例如：SQL、NoSQL 等数据库里都有相关的 API 调用。</li></ul><p>在实际使用中，API 支持访问不同的功能模块，例如数据转换、数据分析、网络安全、门户管理、日历等等，还可以根据不同的需求进行客制化的开发。</p><p>总之，在开发过程中，根据实际需求选择合适的 API 类型是非常重要的，能够快速、高效地构建需要的应用程序。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">版权声明：本文为CSDN博主「luffy_fe」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。</span><br><span class="line">原文链接：https://blog.csdn.net/qq_42107247/article/details/130508490</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;API，即应用程序编程接口，是为了方便应用程序之间的数据和功能交互而设计的一些标准方法。API 的分类可以从多个维度进行，我会对 API 的分类维度进行简单的介绍。&lt;/p&gt;</summary>
    
    
    
    
    <category term="API" scheme="https://blog.musnow.top/tags/API/"/>
    
  </entry>
  
  <entry>
    <title>【Linux】高级IO和多路转接 | select/poll/epoll</title>
    <link href="https://blog.musnow.top/posts/3390191280/"/>
    <id>https://blog.musnow.top/posts/3390191280/</id>
    <published>2023-08-25T00:22:36.000Z</published>
    <updated>2023-08-25T04:05:36.000Z</updated>
    
    <content type="html"><![CDATA[<p>多路转接和高级IO</p><span id="more"></span><p>咳咳，写的时候出了点问题，标点符号全乱了（批量替换了几次），干脆就把全文的逗号和句号都改成英文的了（不然代码块里面的代码都是中文标点就跑不动了）</p><h1 id="1-高级IO"><a href="#1-高级IO" class="headerlink" title="1.高级IO"></a>1.高级IO</h1><h2 id="1-1-五种IO模型"><a href="#1-1-五种IO模型" class="headerlink" title="1.1 五种IO模型"></a>1.1 五种IO模型</h2><p>用钓鱼佬的栗子, 来看看五种不同的IO模型吧</p><ul><li>A, 拿着鱼竿去钓鱼, 一直盯着鱼漂, 鱼漂有动静就收钩</li><li>B, 拿着鱼竿去钓鱼, 时不时看看鱼漂, 有动静就收购</li><li>C, 拿着鱼竿去钓鱼, 在鱼漂上弄个铃铛, 然后干其他的事情, 听到铃铛的声音就收钩</li><li>D, 拿了一大堆鱼竿过来, 都摆弄好, 只要有一个鱼漂有动静, 就收钩</li><li>E是大老板, 直接叫人帮忙钓鱼, 钓到一定数量的🐟后通知自己, 自己过来取🐟（没有参与钓鱼过程）</li></ul><p>这五种钓鱼方式, 就对应了五种IO模型</p><ul><li>A, <strong>阻塞等待</strong>, 等待到数据就立即读取</li><li>B, <strong>轮询检测</strong>, 检测到数据的时候读取</li><li>C, 利用铃铛来作为通知方式, 听到了信号之后, 就去读取数据（<strong>信号驱动</strong>）</li><li>D, 一次性检测多个文件描述符（<strong>多路转接</strong>）</li><li>E, 没有自己参与钓鱼过程, 有别人帮忙监控文件描述符, 自己只关心拿走数据（<strong>异步IO</strong>）</li></ul><p>在这五种IO模式中, <strong>D的效率是最高的</strong>。因为它一次性监控了多个文件描述符, 这些文件描述符的IO在一定程度上重合了, 更容易等到数据。</p><p>要知道, D是过来钓鱼的, 他只要能钓到鱼就够了, 并不用关心到底是哪个鱼钩钓上来的鱼。同理, 我们的IO服务器也并不需要关心到底是哪个文件描述符在给自己传递信息, 我们只要每时每刻都在处理信息（都能钓到鱼）才是最高效率的体现。</p><p>换句话说, 在钓鱼（处理IO）的时候, 等的时间比例越低, 效率越高！</p><h2 id="1-2-阻塞和非阻塞"><a href="#1-2-阻塞和非阻塞" class="headerlink" title="1.2 阻塞和非阻塞"></a>1.2 阻塞和非阻塞</h2><p>这两个概念我们在先前对IO的学习中已经见过了</p><ul><li>阻塞：进程会在函数调用中卡住, 在没有成功调用之前不会继续向后运行</li><li>非阻塞：不管能否获取到数据, 函数都是直接返回结果;</li></ul><h2 id="1-3-异步与同步通信"><a href="#1-3-异步与同步通信" class="headerlink" title="1.3 异步与同步通信"></a>1.3 异步与同步通信</h2><ul><li>异步通信：在调用发出后, 这个调用直接返回, 并没有携带结果;类似<code>std::async/future</code>, 在调用发出后, 被调用着通过状态或通知来告知调用者, 亦或者是用回调函数来处理这个异步调用</li><li>同步通信：在发出调用后, 没有得到结果前, 该调用不返回;一旦返回就表明该调用成功获取到了返回值（调用者主动等待调用结果）</li></ul><p>这里的同步和线程&#x2F;进程同步并不是一个概念：</p><ul><li>线程和进程的同步指的是线程和进程之间有相互制约的关系, 需要在某些情况中协调他们的工作次序而进行等待</li></ul><hr><p>了解完IO模型和上方的知识后, 下面就让我们来认识一下第一个接口吧！</p><h1 id="2-fcntl"><a href="#2-fcntl" class="headerlink" title="2.fcntl"></a>2.fcntl</h1><p>这个是一个系统调用, 可以给文件描述符进行不同的策略设置。</p><p>当我们在linux中创建一个文件描述符的时候, 默认创建的都是阻塞的文件描述符。我们可以使用<code>fcntl</code>来将文件描述符设置成<strong>非阻塞</strong>的。</p><h2 id="2-1-接口"><a href="#2-1-接口" class="headerlink" title="2.1 接口"></a>2.1 接口</h2><p>该函数的原型如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">fcntl</span><span class="params">(<span class="type">int</span> fd, <span class="type">int</span> cmd, ... <span class="comment">/* arg */</span> )</span>;</span><br></pre></td></tr></table></figure><p>其中cmd是我们需要执行的策略, 下面是常见的几种选项</p><ul><li>复制一个现有的描述符（cmd&#x3D;F_DUPFD）</li><li>获得&#x2F;设置文件描述符标记(cmd&#x3D;F_GETFD或F_SETFD)</li><li>获得&#x2F;设置文件状态标记(cmd&#x3D;F_GETFL或F_SETFL)</li><li>获得&#x2F;设置异步I&#x2F;O所有权(cmd&#x3D;F_GETOWN或F_SETOWN)</li><li>获得&#x2F;设置记录锁(cmd&#x3D;F_GETLK, F_SETLK或F_SETLKW)</li></ul><p>这里我们使用的是第三个功能, 来获取和设置文件的状态标记, 就可以将文件描述符设置为非阻塞（这里要注意, 不是用第二种）</p><h2 id="2-2-设置非阻塞"><a href="#2-2-设置非阻塞" class="headerlink" title="2.2 设置非阻塞"></a>2.2 设置非阻塞</h2><p>我们需要先将文件描述符原本的属性给取出来, 然后再加上非阻塞的状态, 使用<code>fcntl</code>设置属性。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">SetNoBlock</span><span class="params">(<span class="type">int</span> fd)</span> </span><br><span class="line">&#123; </span><br><span class="line">    <span class="type">int</span> fl = fcntl(fd, F_GETFL);  <span class="comment">// 先获取文件已有状态</span></span><br><span class="line">    <span class="keyword">if</span> (fl &lt; <span class="number">0</span>) &#123; </span><br><span class="line">       perror(<span class="string">&quot;fcntl error&quot;</span>);</span><br><span class="line">       <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 在已有状态的基础上, 设置O_NONBLOCK非阻塞</span></span><br><span class="line">    fcntl(fd, F_SETFL, fl | O_NONBLOCK);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-3-stdin测试"><a href="#2-3-stdin测试" class="headerlink" title="2.3 stdin测试"></a>2.3 stdin测试</h2><p>然后, 我们还需要一个会出现阻塞的文件描述符来作为测试。但是, 如果是直接打开一个本地文件, 并不会出现阻塞态（因为文件流会被一次性读取出来）</p><p>不过, 在我们最常用的3个默认文件描述符中, 就有一个是能够实现进程阻塞的, 它就是<code>stdin</code>, 因为在控制台里面等待用户输入的时候, 进程就是处于阻塞状态的！</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ ./test</span><br><span class="line">请输入：</span><br></pre></td></tr></table></figure><p>所以我们就可以尝试将stdin设置为非阻塞, 来观察一下结果</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">SetNoBlock</span>(stdin-&gt;_fileno);</span><br><span class="line">    <span class="type">char</span> buf[<span class="number">1024</span>];</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">ssize_t</span> read_size = <span class="built_in">read</span>(stdin-&gt;_fileno, buf, <span class="built_in">sizeof</span>(buf) - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span>(read_size &lt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">perror</span>(<span class="string">&quot;read err&quot;</span>);</span><br><span class="line">            <span class="built_in">sleep</span>(<span class="number">2</span>);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;input:%s\n&quot;</span>, buf);</span><br><span class="line">        buf[<span class="number">0</span>] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译运行, 当没有读取到输入内容的时候, 并不会在<code>stdin</code>中阻塞, 而是会通过perror打印出资源暂时不可用的警告信息。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">$ ./test</span><br><span class="line">read err: Resource temporarily unavailable</span><br><span class="line">asdlfjklaf</span><br><span class="line">input:asdlfjklaf</span><br><span class="line"></span><br><span class="line">read err: Resource temporarily unavailable</span><br><span class="line">adslfkjaldfjklasjfa</span><br><span class="line">input:adslfkjaldfjklasjfa</span><br><span class="line">a</span><br><span class="line">read err: Resource temporarily unavailable</span><br><span class="line">ewqrqreqqrwer</span><br><span class="line">input:ewqrqreqqrwer</span><br><span class="line">asjfa</span><br><span class="line">a</span><br><span class="line">read err: Resource temporarily unavailable</span><br><span class="line">qweioruqoruioqewur</span><br><span class="line">input:qweioruqoruioqewur</span><br><span class="line"></span><br><span class="line">a</span><br><span class="line">read err: Resource temporarily unavailable</span><br><span class="line">weqioruqoieuotqitqwertq</span><br><span class="line">input:weqioruqoieuotqitqwertq</span><br><span class="line">����a</span><br><span class="line">read err: Resource temporarily unavailable</span><br><span class="line">^C</span><br></pre></td></tr></table></figure><h1 id="3-多路转接之select"><a href="#3-多路转接之select" class="headerlink" title="3.多路转接之select"></a>3.多路转接之select</h1><p>接下来就要进入我们的正题了, 关于<strong>多路转接</strong>的知识。</p><p>在之前的时候, 我们如果想在一个进程里面维护多个tcp链接, 就需要用到子线程或者子进程来单独为每一个用户提供服务。<strong>但一个进程可以开的线程是有数量限制的</strong>, 在32位系统中, 这个数字大概是2000。</p><p>对于一个高并发的服务器来说, 这点线程数是完全不够用的！如果你的网站一次性有2000个人访问, 你的服务器就会因为开不出更多的线程而无法为更多的用户提供服务！</p><p>所以, <strong>多路转接</strong>就出现了, 他能帮我们实现单个进程监控多个文件描述符, 同时为多个socket链接提供服务的操作！</p><blockquote><p>普通的本地文件描述符也是可以托管给多路转接的！</p></blockquote><h2 id="3-1-认识select"><a href="#3-1-认识select" class="headerlink" title="3.1 认识select"></a>3.1 认识select</h2><p>select的函数原型和我们之前接触过的linux系统调用接口都不大相似, 它的所有参数都是输入输出型参数, 而且还用到了一个我们平时较少接触的数据结构——位图</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* According to POSIX.1-2001, POSIX.1-2008 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/select.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">select</span><span class="params">(<span class="type">int</span> nfds, fd_set *readfds, fd_set *writefds, </span></span></span><br><span class="line"><span class="params"><span class="function">           fd_set *exceptfds, <span class="keyword">struct</span> timeval *timeout)</span></span>;</span><br></pre></td></tr></table></figure><p>先来依次说明一下每一个参数的作用吧</p><ul><li><code>nfds</code>：需要select帮我们监视的<code>最大文件描述符+1</code></li><li><code>readfds/writefds/exceptfds</code>, 需要select帮我们检测的读&#x2F;写&#x2F;异常文件描述符（通过<strong>位图</strong>来设定）</li><li><code>timeout</code>：阻塞监控的时长, 用来设置select单次阻塞等待的时间</li></ul><h3 id="3-1-1-timeval"><a href="#3-1-1-timeval" class="headerlink" title="3.1.1 timeval"></a>3.1.1 timeval</h3><p>首先来看看timeout的这个参数的<code>struct timeval</code>结构体框架, 内部包含两个成员变量, 一个表示秒数, 一个表示微秒数。最终select等待的时间是这两个参数的<strong>和</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> &#123;</span></span><br><span class="line">    <span class="type">long</span>    tv_sec;         <span class="comment">/* seconds */</span></span><br><span class="line">    <span class="type">long</span>    tv_usec;        <span class="comment">/* microseconds */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>如果设置成0, 则仅检测文件描述符的状态, 不管什么情况都会立即返回（完全非阻塞）</li><li>如果设置成指定的时间, 则会阻塞等待这端时间, 如果有文件事件则返回;如果没有等到文件时间, 那么时间到了就会返回</li><li>如果将<code>timeout</code>参数设置成<code>nullptr</code>, 则会<strong>阻塞等待</strong></li></ul><p>这个参数也是一个输入输出型参数, 返回值为剩余的秒数（如果等待成功的话）</p><h3 id="3-1-2-fd-set"><a href="#3-1-2-fd-set" class="headerlink" title="3.1.2 fd_set"></a>3.1.2 fd_set</h3><p>函数中有3个参数都是用到了这个<code>fd_set</code>结构, 它是一个位图结构, 同时也是一个输入输出参数</p><ul><li>输入：用户告诉操作系统, 需要帮我监控那几个文件描述符, 在需要监控的文件描述符上置1</li><li>输出：系统告诉用户, 那些文件描述符的相关事件就绪了</li></ul><p>虽然这是一个位图结构, 但其并不需要我们手动去设置, 操作系统顺便帮我们封装了相关的设置“函数”, 只需要传入fd和该结构体即可</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">FD_CLR</span><span class="params">(<span class="type">int</span> fd, fd_set *set)</span></span>;  <span class="comment">// 清空位图中对该文件描述符的设置</span></span><br><span class="line"><span class="function"><span class="type">int</span>  <span class="title">FD_ISSET</span><span class="params">(<span class="type">int</span> fd, fd_set *set)</span></span>;<span class="comment">// 判断是否被设置了</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">FD_SET</span><span class="params">(<span class="type">int</span> fd, fd_set *set)</span></span>;  <span class="comment">// 设置对应位置的文件描述符</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">FD_ZERO</span><span class="params">(fd_set *set)</span></span>;         <span class="comment">// 清空整个位图</span></span><br></pre></td></tr></table></figure><p>你可能回觉得奇怪, 为什么这些“函数”是大写的呢？Linux中大写的应该是宏才对吧？</p><p>答对了！这里的设置函数其实都是宏定义！</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Access macros for `fd_set&#x27;.  */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>FD_SET(fd, fdsetp)__FD_SET (fd, fdsetp)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>FD_CLR(fd, fdsetp)__FD_CLR (fd, fdsetp)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>FD_ISSET(fd, fdsetp)__FD_ISSET (fd, fdsetp)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>FD_ZERO(fdsetp)__FD_ZERO (fdsetp)</span></span><br></pre></td></tr></table></figure><p>既然是一个预定义好的位图, 那么它的长度就会收到操作系统底层的一定限制, 以下为源代码中<code>fd_set</code>结构体的定义</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 路径 usr/include/sys/select.h</span></span><br><span class="line"><span class="comment">/* The fd_set member is required to be an array of longs.  */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">int</span> __fd_mask;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Some versions of &lt;linux/posix_types.h&gt; define this macros.  */</span></span><br><span class="line"><span class="meta">#<span class="keyword">undef</span>__NFDBITS</span></span><br><span class="line"><span class="comment">/* It&#x27;s easier to assume 8-bit bytes than to get CHAR_BIT.  */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NFDBITS(8 * (int) sizeof (__fd_mask))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>__FD_ELT(d)((d) / __NFDBITS)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>__FD_MASK(d)((__fd_mask) (1UL &lt;&lt; ((d) % __NFDBITS)))</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* fd_set for select and pselect.  */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">  &#123;</span></span><br><span class="line">    <span class="comment">/* XPG4.2 requires this member name.  Otherwise avoid the name</span></span><br><span class="line"><span class="comment">       from the global namespace.  */</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> __USE_XOPEN</span></span><br><span class="line">    __fd_mask fds_bits[__FD_SETSIZE / __NFDBITS];</span><br><span class="line"><span class="meta"># <span class="keyword">define</span> __FDS_BITS(set) ((set)-&gt;fds_bits)</span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">    __fd_mask __fds_bits[__FD_SETSIZE / __NFDBITS];</span><br><span class="line"><span class="meta"># <span class="keyword">define</span> __FDS_BITS(set) ((set)-&gt;__fds_bits)</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">  &#125; fd_set;</span><br></pre></td></tr></table></figure><p>在另外一个头文件中, 可以找到<code>__FD_SETSIZE</code>这个宏的定义, 是1024;也就是说, <code>fd_set</code>这个位图最大的长度只有1024个比特位, 我们也只能监看这么多文件描述符！</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 路径 usr/include/bits/typesizes.h</span></span><br><span class="line"><span class="comment">/* Number of descriptors that can fit in an `fd_set&#x27;.  */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __FD_SETSIZE1024</span></span><br></pre></td></tr></table></figure><p>这也是<code>select</code>的缺点之一, 同时监看的文件描述符数量是<strong>有限制</strong>的！</p><h3 id="3-1-3-nfds"><a href="#3-1-3-nfds" class="headerlink" title="3.1.3 nfds"></a>3.1.3 nfds</h3><p>这个参数是select需要帮我们监看的最大文件描述符+1, 这是因为select在监看的过程中需要用循环来进行检测, 这个最大文件描述符+1相当于是一个循环的边界条件;</p><p>你只需根据当前已有的文件描述符号, 计算出最大文件描述符, 再加一传给这个函数即可。</p><h3 id="3-1-4-返回值"><a href="#3-1-4-返回值" class="headerlink" title="3.1.4 返回值"></a>3.1.4 返回值</h3><p>man手册中对返回值的描述如下</p><ul><li>成功的时候, 返回事件就绪的文件描述符数量</li><li>失败的时候返回<code>-1</code>, 并设置errno</li><li>如果已经<code>timeout</code>了还没有事件就绪, 返回0</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">RETURN VALUE</span><br><span class="line">       On success, select() and pselect() return the number of file descriptors contained in the three returned descriptor  sets  (that  is,  the total  number  of  bits that are set in readfds, writefds, exceptfds) which may be zero if the timeout expires before anything interesting happens.  On error, -1 is returned, and errno is set to indicate the error; the file descriptor sets are unmodified, and  timeout becomes undefined.</span><br></pre></td></tr></table></figure><h2 id="3-2-实例"><a href="#3-2-实例" class="headerlink" title="3.2 实例"></a>3.2 实例</h2><p>函数原型看完了, 得从实例出发来试试了</p><h3 id="3-2-1-socket"><a href="#3-2-1-socket" class="headerlink" title="3.2.1 socket"></a>3.2.1 socket</h3><p>这里先对<span id="jump-select">socket</span>做了一个简单的封装, 包括初始化, 绑定相关的接口, 只需要在另外一个文件里面调用这个头文件即可 !</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Sock.hpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cerrno&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cassert&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Sock</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">static</span> <span class="type">const</span> <span class="type">int</span> gbacklog = <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">SocketInit</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="type">int</span> listenSock = <span class="built_in">socket</span>(PF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span> (listenSock &lt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 设置端口复用, 避免timewait阻塞端口</span></span><br><span class="line">        <span class="type">int</span> opt = <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">setsockopt</span>(listenSock, SOL_SOCKET, SO_REUSEADDR | SO_REUSEPORT, &amp;opt, <span class="built_in">sizeof</span>(opt));</span><br><span class="line">        <span class="keyword">return</span> listenSock;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">Bind</span><span class="params">(<span class="type">int</span> socket, <span class="type">uint16_t</span> port)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> local; <span class="comment">// 用户栈</span></span><br><span class="line">        <span class="built_in">memset</span>(&amp;local, <span class="number">0</span>, <span class="keyword">sizeof</span> local);</span><br><span class="line">        local.sin_family = PF_INET;</span><br><span class="line">        local.sin_port = <span class="built_in">htons</span>(port);</span><br><span class="line">        local.sin_addr.s_addr = INADDR_ANY;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2.2 本地socket信息, 写入sock_对应的内核区域</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">bind</span>(socket, (<span class="type">const</span> <span class="keyword">struct</span> sockaddr *)&amp;local, <span class="built_in">sizeof</span>(local)) &lt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">2</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">Listen</span><span class="params">(<span class="type">int</span> socket)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">listen</span>(socket, gbacklog) &lt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">3</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">Accept</span><span class="params">(<span class="type">int</span> socket, std::string *clientip, <span class="type">uint16_t</span> *clientport)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> peer;</span><br><span class="line">        <span class="type">socklen_t</span> len = <span class="built_in">sizeof</span>(peer);</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> serviceSock = <span class="built_in">accept</span>(socket, (<span class="keyword">struct</span> sockaddr *)&amp;peer, &amp;len);</span><br><span class="line">        <span class="keyword">if</span> (serviceSock &lt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 获取链接失败</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(clientport) *clientport = <span class="built_in">ntohs</span>(peer.sin_port);</span><br><span class="line">        <span class="keyword">if</span>(clientip) *clientip = <span class="built_in">inet_ntoa</span>(peer.sin_addr);</span><br><span class="line">        <span class="keyword">return</span> serviceSock;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>另外重点说明一下这两行, 在之前学习tcp服务器的时候就提到过, 这里的<code>SO_REUSEADDR</code>是让端口可以被复用, 不会因为存在<code>TIME_WAIT</code>的链接而无法绑定端口。适用于服务器快速重启的情况。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 设置端口复用, 避免timewait阻塞端口</span></span><br><span class="line"><span class="type">int</span> opt = <span class="number">1</span>;</span><br><span class="line"><span class="built_in">setsockopt</span>(listenSock, SOL_SOCKET, SO_REUSEADDR | SO_REUSEPORT, &amp;opt, <span class="built_in">sizeof</span>(opt));</span><br></pre></td></tr></table></figure><h3 id="3-2-2-初始化"><a href="#3-2-2-初始化" class="headerlink" title="3.2.2 初始化"></a>3.2.2 初始化</h3><p>还是老一套, 通过命令行参数获取到端口号, 创建socket_fd并绑定端口和开始<code>listen</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (argc != <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="built_in">cmd_usage</span>(argv[<span class="number">0</span>]);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;   </span><br><span class="line">    <span class="comment">// 初始化socket, 获取socket fd并绑定端口</span></span><br><span class="line">    <span class="type">int</span> listensock = Sock::<span class="built_in">SocketInit</span>();</span><br><span class="line">    Sock::<span class="built_in">Bind</span>(listensock, <span class="built_in">atoi</span>(argv[<span class="number">1</span>]));</span><br><span class="line">    Sock::<span class="built_in">Listen</span>(listensock); <span class="comment">// 开始监听</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>需要注意的是, 在select中的文件描述符都只剩位图了, 所以我们必须要有一个单独的文件描述符数组来协助我们管理正在维护的文件描述符。</p><p>这里为了方便, 我设立了一个全局的数组变量, 长度为<code>sizeof(fd_set) * 8</code>, 是<code>fd_set</code>这个位图结构体能够支持的最大socket数量</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> fdsArray[<span class="built_in">sizeof</span>(fd_set) * <span class="number">8</span>] = &#123;<span class="number">0</span>&#125;; <span class="comment">// 保存历史上所有的合法fd</span></span><br><span class="line"><span class="type">int</span> fdsArraySz = <span class="built_in">sizeof</span>(fdsArray) / <span class="built_in">sizeof</span>(fdsArray[<span class="number">0</span>]);</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DFL_FD -1 <span class="comment">// 数组中默认值</span></span></span><br></pre></td></tr></table></figure><p>在main函数中, 我们需要通过遍历来将这个数组设置为默认的文件描述符<code>-1</code>来表明当前位置没有被使用, 并将0下标处设置为<code>listensock</code>;如果你使用的是vector, 则可以直接用构造函数来初始化;</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将数组里面的文件描述符都初始化为默认值, 并将第一个下标设置为listensocket</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; fdsArraySz; i++)&#123;</span><br><span class="line">    fdsArray[i] = DFL_FD;</span><br><span class="line">&#125;</span><br><span class="line">fdsArray[<span class="number">0</span>] = listensock;</span><br></pre></td></tr></table></figure><h3 id="3-2-3-监听"><a href="#3-2-3-监听" class="headerlink" title="3.2.3 监听"></a>3.2.3 监听</h3><p>初始化完毕数组后, 就可以开始循环调用<code>select</code>来进行监听了。</p><p>需要注意的是, 因为<code>select</code>的<code>fd_set</code>是一个位图, 而且是输入输出参数。每次的<code>select</code>调用之后, 这些位图就会被操作系统修改为已经就绪的文件描述符（即参数本身会被修改）所以我们下一次调用之前, <strong>需要重新设置位图参数</strong>！</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 开始监听</span></span><br><span class="line">fd_set readfds;</span><br><span class="line"><span class="keyword">while</span>(<span class="literal">true</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> maxFd = DFL_FD;</span><br><span class="line">    <span class="built_in">FD_ZERO</span>(&amp;readfds); <span class="comment">// 清空位图</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">timeval</span> timeout = &#123;<span class="number">5</span>, <span class="number">0</span>&#125;; <span class="comment">// 设置超时时间为5秒</span></span><br><span class="line">    <span class="comment">// 遍历全局数组, 将有效的fd都添加进去, 并更新maxfd</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; fdsArraySz; i++)</span><br><span class="line">    &#123;   </span><br><span class="line">        <span class="comment">// 1. 过滤不合法的fd</span></span><br><span class="line">        <span class="keyword">if</span> (fdsArray[i] == DFL_FD) <span class="keyword">continue</span>;   </span><br><span class="line">        <span class="comment">// 2. 添加所有的合法的fd到readfds中, 方便select统一进行就绪监听</span></span><br><span class="line">        <span class="built_in">FD_SET</span>(fdsArray[i], &amp;readfds); </span><br><span class="line">        <span class="keyword">if</span> (maxFd &lt; fdsArray[i]) &#123;</span><br><span class="line">            maxFd = fdsArray[i]; <span class="comment">// 3. 更新出fd最大值</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 调用select开始监听</span></span><br><span class="line">    <span class="type">int</span> sret = <span class="built_in">select</span>(maxFd+<span class="number">1</span>, &amp;readfds, <span class="literal">nullptr</span>, <span class="literal">nullptr</span>, &amp;timeout);</span><br><span class="line">    <span class="keyword">switch</span> (sret)</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">0</span>: <span class="comment">// 等待超时</span></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;time out ... : &quot;</span> &lt;&lt; (<span class="type">unsigned</span> <span class="type">long</span>)<span class="built_in">time</span>(<span class="literal">nullptr</span>) &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">-1</span>:<span class="comment">// 等待失败</span></span><br><span class="line">        cerr &lt;&lt; errno &lt;&lt; <span class="string">&quot; : &quot;</span> &lt;&lt; <span class="built_in">strerror</span>(errno) &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="comment">// 等待成功</span></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;wait success: &quot;</span> &lt;&lt; sret &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>基本框架搭起来了, 我们这时候就只需要实现等待成功后取出链接和IO信息的操作了;</p><p>先来测试一下当前的手脚架吧</p><h3 id="3-2-4-手脚架测试"><a href="#3-2-4-手脚架测试" class="headerlink" title="3.2.4 手脚架测试"></a>3.2.4 手脚架测试</h3><p>编译启动, 使用命令行参数来绑定端口, 在没有收到数据之前, 进程会在select中阻塞等待5秒, 随后因为超时跳出阻塞态, 返回0并打印当前时间戳</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ g++ main.cpp -o test</span><br><span class="line">$ ./test 10000</span><br><span class="line">time out ... : 1692955522</span><br><span class="line">time out ... : 1692955527</span><br><span class="line">time out ... : 1692955532</span><br><span class="line">time out ... : 1692955537</span><br><span class="line">time out ... : 1692955542</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>使用<code>telnet</code>命令来链接当前服务, <code>select</code>检测到listensock文件描述符就绪, 会立刻返回（对于listensock来说, 来了新链接就是读IO就绪）但因为我们没有写取走新socket的代码, 所以这里会一直打印事件就绪;</p><p>返回值为1, 代表有一个文件描述符的事件就绪。</p><p><img src="https://img.musnow.top/i/2023/08/bcd37076cf11a3ec0d3caac5f7f0501f.png" alt="image-20230825172642067"></p><h3 id="3-2-5-处理新连接"><a href="#3-2-5-处理新连接" class="headerlink" title="3.2.5 处理新连接"></a>3.2.5 处理新连接</h3><p>在<code>select</code>事件就绪后, 使用如下函数来处理新的链接</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">HandlerEvent</span><span class="params">(<span class="type">int</span> listensock, fd_set &amp;readfds)</span></span>;</span><br></pre></td></tr></table></figure><p>这里额外写了一个打印数组中元素的函数, 方便我们观察结果。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// @brief 打印数组中的文件描述符</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">ShowArray</span><span class="params">(<span class="type">int</span> arr[], <span class="type">int</span> num)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;当前合法sock list: &quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; num; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (arr[i] == DFL_FD )</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; arr[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先我们需要遍历整个链接数组, 并判断当前位置是否是有效的文件描述符。无效直接跳过。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; fdsArraySz; i++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (fdsArray[i] == DFL_FD)</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">    <span class="comment">// 处理新连接和已有链接</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>遍历的时候, 我们需要对listensock做单独的处理, 毕竟获取新连接和维护已有链接的流程是完全不同的。下面说说流程</p><ul><li>判断是否有在select中监听该文件描述符</li><li>有监听, 继续往后执行, 开始进行<code>accept</code>获取新的链接</li><li>获取失败, 直接跳出该函数, 结束该轮处理</li><li>获取成功, 不能直接read&#x2F;write, 而是应该通过数组交付给select帮我们监听事件</li><li>下一轮循环中, select便会帮我们监听该新链接的事件是否就绪</li></ul><p>因为走到这里的时候, 我们的<code>listensocket</code>里面是一定有新连接的, 所以对<code>accept</code>的调用是不会阻塞线程的！</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (i == <span class="number">0</span> &amp;&amp; fdsArray[i] == listensock)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 判断listensocket有没有事件监听</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">FD_ISSET</span>(listensock, &amp;readfds))&#123;</span><br><span class="line">        cerr &lt;&lt; <span class="string">&quot;listensocket not set in readfds&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 具有了一个新链接</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;get new connection&quot;</span> &lt;&lt; endl;</span><br><span class="line">    string clientip;</span><br><span class="line">    <span class="type">uint16_t</span> clientport = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> sock = Sock::<span class="built_in">Accept</span>(listensock, &amp;clientip, &amp;clientport); <span class="comment">// 不会阻塞</span></span><br><span class="line">    <span class="keyword">if</span> (sock &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span>; <span class="comment">// 出错了, 直接返回</span></span><br><span class="line">    <span class="comment">// 成功获取新连接</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;new conn:&quot;</span> &lt;&lt; clientip &lt;&lt; <span class="string">&quot;:&quot;</span> &lt;&lt; clientport &lt;&lt; <span class="string">&quot; | sock: &quot;</span> &lt;&lt; sock &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这里我们不能直接对这个socket进行独写, 因为新链接来了并不代表新数据一并过来了</span></span><br><span class="line">    <span class="comment">// 所以需要将新的文件描述符利用全局数组, 交付给select</span></span><br><span class="line">    <span class="comment">// select 帮我们监看socket上的读事件是否就绪</span></span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; fdsArraySz; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (fdsArray[i] == DFL_FD)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 达到上限了</span></span><br><span class="line">    <span class="keyword">if</span> (i == fdsArraySz)</span><br><span class="line">    &#123;</span><br><span class="line">        cerr &lt;&lt; <span class="string">&quot;reach the maximum number of connections&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="built_in">close</span>(sock);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="comment">// 没有达到</span></span><br><span class="line">    &#123;</span><br><span class="line">        fdsArray[i] = sock; <span class="comment">// 新的链接, 插入到数组中, 下次遍历就会添加到select监看中</span></span><br><span class="line">        <span class="built_in">ShowArray</span>(fdsArray, fdsArraySz);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-2-6-处理已有链接"><a href="#3-2-6-处理已有链接" class="headerlink" title="3.2.6 处理已有链接"></a>3.2.6 处理已有链接</h3><p>这里暂时只做了对读的操作, 当读事件就绪的时候, 我们通过read读取已有的数据。这里因为socket中肯定是有数据的, 所以也不会出现阻塞的情况。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// end if (i == 0 &amp;&amp; fdsArray[i] == listensock)</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 处理普通sock的IO事件</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">FD_ISSET</span>(fdsArray[i], &amp;readfds))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// read、recv读取即可</span></span><br><span class="line">        <span class="type">char</span> buffer[<span class="number">1024</span>];</span><br><span class="line">        <span class="type">ssize_t</span> s = <span class="built_in">recv</span>(fdsArray[i], buffer, <span class="built_in">sizeof</span>(buffer), <span class="number">0</span>); <span class="comment">// 不会阻塞</span></span><br><span class="line">        <span class="keyword">if</span> (s &gt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            buffer[s] = <span class="number">0</span>;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;client[&quot;</span> &lt;&lt; fdsArray[i] &lt;&lt; <span class="string">&quot;]# &quot;</span> &lt;&lt; buffer &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (s == <span class="number">0</span>) <span class="comment">// 对端关闭</span></span><br><span class="line">        &#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;client[&quot;</span> &lt;&lt; fdsArray[i] &lt;&lt; <span class="string">&quot;] quit, server close &quot;</span> &lt;&lt; fdsArray[i] &lt;&lt; endl;</span><br><span class="line">            <span class="built_in">close</span>(fdsArray[i]);</span><br><span class="line">            fdsArray[i] = DFL_FD; <span class="comment">// 去除对该文件描述符的select事件监听</span></span><br><span class="line">            <span class="built_in">ShowArray</span>(fdsArray, fdsArraySz);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="comment">// 异常了</span></span><br><span class="line">        &#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;client[&quot;</span> &lt;&lt; fdsArray[i] &lt;&lt; <span class="string">&quot;] error, server close &quot;</span> &lt;&lt; fdsArray[i] &lt;&lt; endl;</span><br><span class="line">            <span class="built_in">close</span>(fdsArray[i]);</span><br><span class="line">            fdsArray[i] = DFL_FD; <span class="comment">// 去除对该文件描述符的select事件监听</span></span><br><span class="line">            <span class="built_in">ShowArray</span>(fdsArray, fdsArraySz);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里我单次读取的时候, 最多只能读出1024字节的数据;如果想一次性读取完毕, 则需要使用循环+设置非阻塞来进行读取。后续在epoll的代码示例中会展示这种写法。</p><h3 id="3-2-7-实测"><a href="#3-2-7-实测" class="headerlink" title="3.2.7 实测"></a>3.2.7 实测</h3><p>到这里, 我们这套代码就基本完成了, 可以来测试一下能否实现单线程监听多个链接;</p><p>在本地使用telnet+多个终端进行测试, 可以看到我们成功实现了同时监听两个链接, 并接受这两个链接给自己发送的信息的功能。当telnet退出的时候, 也能成功回收文件描述符。</p><p><img src="https://img.musnow.top/i/2023/08/c14d2576fc599392522042a1bb12ddc5.png" alt="image-20230825183501900"></p><p>select的小实现暂时先看到这里, 如果想用select实现同时读+写, 其实是很复杂的。需要一套完整的逻辑。这就留着到最后epoll的时候再统一展现吧！</p><h2 id="3-3-socket就绪条件"><a href="#3-3-socket就绪条件" class="headerlink" title="3.3 socket就绪条件"></a>3.3 socket就绪条件</h2><p><span id="jump3">socket不同事件的就绪有各自的条件</span></p><h3 id="3-3-1-读就绪"><a href="#3-3-1-读就绪" class="headerlink" title="3.3.1 读就绪"></a>3.3.1 读就绪</h3><ul><li>socket内核中, 接收缓冲区中的字节数, 大于等于低水位标记<code>SO_RCVLOWAT</code>, 此时可以无阻塞的读该文件描述符, 并且返回值大于0; </li><li>socket在TCP通信中, 对端关闭连接, 此时对该socket读, 则返回0;</li><li>监听的socket上有新的连接请求;</li><li>socket上有未处理的错误;</li></ul><h3 id="3-3-2-写就绪"><a href="#3-3-2-写就绪" class="headerlink" title="3.3.2 写就绪"></a>3.3.2 写就绪</h3><ul><li>socket内核中,  发送缓冲区中的可用字节数(发送缓冲区的空闲位置大小),  大于等于低水位标记 <code>SO_SNDLOWAT</code>,  此时可以无阻塞的写,  并且返回值大于0;</li><li>socket的写操作被关闭(close或者shutdown). 对一个写操作被关闭的socket进行写操作,  会触发 <code>SIGPIPE</code> 信号;</li><li>socket使用非阻塞connect连接成功或失败之后;</li><li>socket上有未读取的错误;</li></ul><h3 id="3-3-3-异常就绪"><a href="#3-3-3-异常就绪" class="headerlink" title="3.3.3 异常就绪"></a>3.3.3 异常就绪</h3><p>socket上收到带外数据（TCP报头中的URG和紧急指针）</p><h2 id="3-4-select的特点"><a href="#3-4-select的特点" class="headerlink" title="3.4 select的特点"></a>3.4 select的特点</h2><ul><li>可监控的文件描述符有上限, 取决于<code>fd_set</code>位图结构体的配置</li><li>在监控文件描述符的时候, 需要用户额外的数组来维护文件描述符</li><li>每次循环都得遍历整个数组, 效率较低（可以优化为保证有效文件描述符都在数组的前方）</li></ul><p>一下是它在效率上的一些缺点</p><ul><li>每次调用select都得手动设置一边fd集和（因为<code>fd_set</code>也是输出型参数, 在内核中会被修改）</li><li>每次调用select, 都需要把所有fd从用户态拷贝到内核态, 小陆地</li><li>每次调用, 内核都须遍历传递进来的位图, 效率低</li><li>监控的文件描述符有上限, 数量小</li></ul><h1 id="4-多路转接之poll"><a href="#4-多路转接之poll" class="headerlink" title="4.多路转接之poll"></a>4.多路转接之poll</h1><h2 id="4-1-函数原型"><a href="#4-1-函数原型" class="headerlink" title="4.1 函数原型"></a>4.1 函数原型</h2><p>接下来我们要了解的是另外一个多路转接方案, <strong>poll</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;poll.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">poll</span><span class="params">(<span class="keyword">struct</span> pollfd *fds,  <span class="type">nfds_t</span> nfds,  <span class="type">int</span> timeout)</span></span>;</span><br></pre></td></tr></table></figure><h3 id="4-1-1-参数"><a href="#4-1-1-参数" class="headerlink" title="4.1.1 参数"></a>4.1.1 参数</h3><p>这里的参数就和select完全不同了, 出现了另外一个结构体</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pollfd</span> &#123;</span></span><br><span class="line">    <span class="type">int</span>   fd;         <span class="comment">/* file descriptor */</span></span><br><span class="line">    <span class="type">short</span> events;     <span class="comment">/* requested events */</span></span><br><span class="line">    <span class="type">short</span> revents;    <span class="comment">/* returned events */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这一个结构体分别包含了三个成员</p><ul><li>文件描述符fd;</li><li>用户告诉内核需要监看的事件events;</li><li>内核返回的就绪事件revents;</li></ul><p>但是从这个函数的参数上看来, 貌似它是一个只有一个元素的输入输出型参数, 难道说poll只能监看一个文件描述符吗？🧐</p><p>非也, 我们将函数原型改一下就能看明白了, 实际上, 第一个参数是一个<strong>结构体数组</strong>, 第二个参数是该结构体数组的<strong>长度</strong>！</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">poll</span><span class="params">(<span class="keyword">struct</span> pollfd fds[],  <span class="type">nfds_t</span> nfds,  <span class="type">int</span> timeout)</span>;</span><br></pre></td></tr></table></figure><p>第三个参数和select中的timeout的功能相同, 如果到达一定时间还没有获取到参数, 则直接返回;如果设置为<code>-1</code>则阻塞等待, 设置为0为完全非阻塞。</p><p>这里的timeout并非输入输出型号参数, 其只是一个输入参数, 单位为<strong>毫秒</strong>（记住, 不是秒, 是毫秒）</p><h3 id="4-1-2-返回值"><a href="#4-1-2-返回值" class="headerlink" title="4.1.2 返回值"></a>4.1.2 返回值</h3><ul><li>小于0, 出错</li><li>等于0, 等待超时</li><li>大于0, 文件描述符已经就绪的数量</li></ul><h3 id="4-1-3-事件"><a href="#4-1-3-事件" class="headerlink" title="4.1.3 事件"></a>4.1.3 事件</h3><p>这里需要了解一下poll包含的事件类型了, 我们需要根据不同情况来选择想要的事件, 并设置到结构体的<code>event</code>中;对于select&#x2F;poll&#x2F;epoll来说, 这些socket的就绪条件都是相同的。详见 <a href="#jump3">3.3 socket就绪条件</a>;</p><p><img src="https://img.musnow.top/i/2023/08/748d3a20ba69bb3b3671f5b344cba650.png" alt="img"></p><h2 id="4-2-poll优缺点"><a href="#4-2-poll优缺点" class="headerlink" title="4.2 poll优缺点"></a>4.2 poll优缺点</h2><h3 id="4-2-1-优点"><a href="#4-2-1-优点" class="headerlink" title="4.2.1 优点"></a>4.2.1 优点</h3><p>在poll中, 使用的是一个结构体数组来表示需要监听的文件描述符, 以及事件就绪的文件描述符</p><ul><li>因为结构体中用户需要监听的event和内核返回的就绪event并不在一个变量上, 所以只需要设置一次即可（如果需求没有变动的话）, 无需像select每次都得重新遍历来设置位图</li><li>poll没有最大文件描述符限制</li><li>poll无需用户额外维护一个单独的文件描述符数组, 直接沿用该结构体数组即可</li></ul><h3 id="4-2-2-缺点"><a href="#4-2-2-缺点" class="headerlink" title="4.2.2 缺点"></a>4.2.2 缺点</h3><ul><li>和select一样, poll也需要轮询检测就绪的fd和相关事件</li><li>每次调用poll需要把pollfd结构体从用户态拷贝到内核态</li><li>虽然poll没有最大文件描述符限制, 但是监看的多了后性能会线性下降</li></ul><h2 id="4-3-看看示例代码"><a href="#4-3-看看示例代码" class="headerlink" title="4.3 看看示例代码"></a>4.3 看看示例代码</h2><p>poll的代码部分的主机结构和select基本相同，这里我们主要来说一下不同的地方</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> NUM 1024</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DFL_FD -1</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pollfd</span> <span class="title">fdsArray</span>[<span class="title">NUM</span>];</span></span><br></pre></td></tr></table></figure><p>首先是全局的数组，这时候不需要自己维护一个int文件描述符数组了，直接使用这个结构体作为全局数组就OK了；在main函数里面还是老样子，我们得把整个数组的fd都设置成默认的fd作为标识</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; NUM; i++)</span><br><span class="line">&#123;</span><br><span class="line">    fdsArray[i].fd = DFL_FD;</span><br><span class="line">    fdsArray[i].events = <span class="number">0</span>;</span><br><span class="line">    fdsArray[i].revents = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">fdsArray[<span class="number">0</span>].fd = listensock;</span><br><span class="line">fdsArray[<span class="number">0</span>].events = POLLIN;</span><br></pre></td></tr></table></figure><p>在main函数的主循环中，也是用poll来依次监听事件，并判断poll函数的返回值</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> timeout = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> n = poll(fdsArray, NUM, timeout);</span><br><span class="line">    <span class="keyword">switch</span> (n)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;time out ... : &quot;</span> &lt;&lt; (<span class="type">unsigned</span> <span class="type">long</span>)time(nullptr) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">-1</span>:</span><br><span class="line">            <span class="built_in">cerr</span> &lt;&lt; errno &lt;&lt; <span class="string">&quot; : &quot;</span> &lt;&lt; strerror(errno) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            HandlerEvent(listensock);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在<code>HandlerEvent</code>函数中，我们通过判断结构体内部的<code>revent</code>来得知是否有事件就绪</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (fdsArray[i].revents &amp; POLLIN)&#123;&#125; <span class="comment">// 读事件是否就绪</span></span><br></pre></td></tr></table></figure><p>对于listensocket来说，就绪了就执行accept；并将新的文件描述符添加到数组中</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> j = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; NUM; j++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (fdsArray[j].fd == DFL_FD)</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 通过for循环找到当前位置是默认的结构体下标</span></span><br><span class="line"><span class="keyword">if</span> (j == NUM) <span class="comment">// 如果达到上限才break</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">cerr</span> &lt;&lt; <span class="string">&quot;我的服务器已经到了最大的上限了，无法在承载更多同时保持的连接了&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    close(sock);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">    fdsArray[j].fd = sock; <span class="comment">// 将sock添加到数组中</span></span><br><span class="line">    fdsArray[j].events = POLLIN;</span><br><span class="line">    fdsArray[j].revents = <span class="number">0</span>;</span><br><span class="line">    ShowArray(fdsArray, NUM);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于其他链接来说，就绪了就开始read。如果read异常或者对端关闭，那就将对应位置的结构体全部初始化（清空），相当于将这个链接从监听中去掉！</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">fdsArray[i].fd = DFL_FD; </span><br><span class="line">fdsArray[i].events = 0;</span><br><span class="line">fdsArray[i].revents = 0;</span><br></pre></td></tr></table></figure><p>其余的操作和select完全一致，在这里就不展示代码了！</p><h1 id="5-epoll"><a href="#5-epoll" class="headerlink" title="5.epoll"></a>5.epoll</h1><p>man手册中提到, epoll是为了处理大量socket文件描述符句柄而进行了一定改进的poll;</p><h2 id="5-1-接口"><a href="#5-1-接口" class="headerlink" title="5.1 接口"></a>5.1 接口</h2><p>epoll就不是只有一个函数接口了, 而是有3个相关的函数，使用过程就是三部曲：</p><ul><li>epoll_create 创建epoll文件句柄</li><li>epoll_ctl 将需要监控的文件描述符进行注册</li><li>epoll_wait 等待文件描述符就绪</li></ul><h3 id="5-1-1-epoll-create"><a href="#5-1-1-epoll-create" class="headerlink" title="5.1.1 epoll_create"></a>5.1.1 epoll_create</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/epoll.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">epoll_create</span><span class="params">(<span class="type">int</span> size)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">epoll_create1</span><span class="params">(<span class="type">int</span> flags)</span>;</span><br></pre></td></tr></table></figure><p>epoll在使用的时候, 我们需要用create函数创建一个epoll的句柄（本质上也是文件描述符）, 来管理当前进程需要操作系统帮我们监看的文件描述符</p><ul><li>自从<code>linux 2.6.8</code> 后, 这里的size参数是被胡咯的</li><li>epoll的句柄在使用完毕后也需要用<code>close()</code>函数关闭</li><li>错误的时候返回<code>-1</code>并设置errno, 正确的时候返回文件描述符</li></ul><h3 id="5-1-2-epoll-ctl"><a href="#5-1-2-epoll-ctl" class="headerlink" title="5.1.2 epoll_ctl"></a>5.1.2 epoll_ctl</h3><p>该函数是对epoll中需要监看的文件描述符进行设置</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/epoll.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">epoll_ctl</span><span class="params">(<span class="type">int</span> epfd,  <span class="type">int</span> op,  <span class="type">int</span> fd,  <span class="keyword">struct</span> epoll_event *event)</span>;</span><br></pre></td></tr></table></figure><ul><li>第一个参数是<code>epoll_create</code>的返回值</li><li>第二个参数是动作, 包含三个不同的选项<ul><li><code>EPOLL_CTL_ADD</code>：将新的文件描述符添加到<code>epfd</code>中</li><li><code>EPOLL_CTL_MOD</code>：修改已有文件描述符的监听事件</li><li><code>EPOLL_CTL_DEL</code>：删除已有文件描述符</li></ul></li><li>第三个参数是目标文件描述符</li><li>第四个参数是一个<code>epoll_event</code>结构体</li></ul><p>这个结构体的定义如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">union</span> <span class="title">epoll_data</span> &#123;</span></span><br><span class="line">    <span class="type">void</span>        *ptr;</span><br><span class="line">    <span class="type">int</span>          fd;</span><br><span class="line">    <span class="type">uint32_t</span>     u32;</span><br><span class="line">    <span class="type">uint64_t</span>     u64;</span><br><span class="line">&#125; <span class="type">epoll_data_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> &#123;</span></span><br><span class="line">    <span class="type">uint32_t</span>     events;      <span class="comment">/* Epoll events */</span></span><br><span class="line">    <span class="type">epoll_data_t</span> data;        <span class="comment">/* User data variable */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h4><p>事件<code>events</code>可以是下面的这些选项</p><table><thead><tr><th>事件</th><th>说明</th></tr></thead><tbody><tr><td>EPOLLIN</td><td>表示对应的文件描述符可以读 (包括对端SOCKET正常关闭);</td></tr><tr><td>EPOLLOUT</td><td>表示对应的文件描述符可以写;</td></tr><tr><td>EPOLLPRI</td><td>表示对应的文件描述符有紧急的数据可读 (这里应该表示有带外数据到来);</td></tr><tr><td>EPOLLERR</td><td>表示对应的文件描述符发生错误;</td></tr><tr><td>EPOLLHUP</td><td>表示对应的文件描述符被挂断;</td></tr><tr><td>EPOLLET</td><td>将EPOLL设为<strong>边缘触发 <strong>(Edge Triggered)模式,  这是相对于</strong>水平触发</strong>(Level Triggered) 来说的；</td></tr><tr><td>EPOLLONESHOT</td><td><strong>只监听一次事件,</strong>  当监听完这次事件之后,  如果还需要继续监听这个socket的话,  需要手动再次把这个socket加入到EPOLL队列里；</td></tr></tbody></table><h3 id="5-1-3-epoll-wait"><a href="#5-1-3-epoll-wait" class="headerlink" title="5.1.3 epoll_wait"></a>5.1.3 epoll_wait</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/epoll.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">epoll_wait</span><span class="params">(<span class="type">int</span> epfd,  <span class="keyword">struct</span> epoll_event *events, </span></span><br><span class="line"><span class="params">               <span class="type">int</span> maxevents,  <span class="type">int</span> timeout)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">epoll_pwait</span><span class="params">(<span class="type">int</span> epfd,  <span class="keyword">struct</span> epoll_event *events, </span></span><br><span class="line"><span class="params">                <span class="type">int</span> maxevents,  <span class="type">int</span> timeout, </span></span><br><span class="line"><span class="params">                <span class="type">const</span> <span class="type">sigset_t</span> *sigmask)</span>;</span><br></pre></td></tr></table></figure><p>改函数的作用是收集在epoll监控的事件中，已经就绪的事件</p><ul><li>第一个参数是epoll的文件描述符句柄</li><li>参数events是<code>epoll_events</code>结构体数组，是一个输出型参数。epoll会将就绪的事件赋值到events数组里面；</li><li>maxevents 告诉内核这个events的大小，其不可以超过<code>epoll_create</code>的size；</li><li>参数timeout是超时时间，也是毫秒（0非阻塞，-1永久阻塞）</li><li>返回值：成功返回IO事件就绪的文件描述符数目，0代表超时，负数代表失败</li></ul><h2 id="5-2-工作原理"><a href="#5-2-工作原理" class="headerlink" title="5.2 工作原理"></a>5.2 工作原理</h2><h3 id="5-2-1-从源码看流程"><a href="#5-2-1-从源码看流程" class="headerlink" title="5.2.1 从源码看流程"></a>5.2.1 从源码看流程</h3><p>我们知道，select通过位图来告诉操作系统需要管理的文件描述符，poll通过结构体数组来告诉操作系统需要管理的文件描述符。</p><p>但epoll里面，却变成了一个epfd文件句柄，我们只是给这个特定的句柄交付文件描述符。这说明底层肯定需要其他的数据结构，来管理某个进程的某个epfd交付给操作系统的文件描述符，以及需要监看的事件！</p><p>在<code>Linux 2.6.32.16</code>源码<code>fs/eventpoll.c</code>中，可以找到如下这个结构体</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// linux源码文件路径：fs/eventpoll.c</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * This structure is stored inside the &quot;private_data&quot; member of the file</span></span><br><span class="line"><span class="comment"> * structure and rapresent the main data sructure for the eventpoll</span></span><br><span class="line"><span class="comment"> * interface.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">eventpoll</span> &#123;</span></span><br><span class="line"><span class="comment">/* Protect the this structure access */</span></span><br><span class="line"><span class="type">spinlock_t</span> lock;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * This mutex is used to ensure that files are not removed</span></span><br><span class="line"><span class="comment"> * while epoll is using them. This is held during the event</span></span><br><span class="line"><span class="comment"> * collection loop, the file cleanup path, the epoll file exit</span></span><br><span class="line"><span class="comment"> * code and the ctl operations.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mutex</span> <span class="title">mtx</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Wait queue used by sys_epoll_wait() */</span></span><br><span class="line"><span class="type">wait_queue_head_t</span> wq;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Wait queue used by file-&gt;poll() */</span></span><br><span class="line"><span class="type">wait_queue_head_t</span> poll_wait;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* List of ready file descriptors */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">rdllist</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* RB tree root used to store monitored fd structs */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rb_root</span> <span class="title">rbr</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * This is a single linked list that chains all the &quot;struct epitem&quot; that</span></span><br><span class="line"><span class="comment"> * happened while transfering ready events to userspace w/out</span></span><br><span class="line"><span class="comment"> * holding -&gt;lock.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">epitem</span> *<span class="title">ovflist</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* The user that created the eventpoll descriptor */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">user_struct</span> *<span class="title">user</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在这里面，我们既可以看到熟悉的<code>mutex</code>锁，又可以看到一个<code>wait_queue</code>等待队列，一个双链表，和一个<code>rb_root</code>红黑树节点。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> &#123;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> *<span class="title">next</span>, *<span class="title">prev</span>;</span></span><br><span class="line">&#125;; <span class="comment">// 内核中的双链表</span></span><br></pre></td></tr></table></figure><p>抽象出来之后，其大概的结构图如下</p><p><img src="https://img.musnow.top/i/2023/08/6ca5fd02f9838c2ef2d41a014623262d.png" alt="image-20230826160246637"></p><p>当某一个进程调用<code>epoll_create</code>创建<code>epoll</code>的文件描述符句柄的时候，操作系统就会帮我们在底层创建一个<code>struct eventpoll</code>结构体，内部包含了就绪队列和一个红黑树（主要关注这两个成员）</p><ul><li>调用<code>epoll_ctl</code>的时候，操作系统就会将我们配置的文件描述符和对于的事件添加到红黑树节点中；</li><li>重复添加的事件也可以通过红黑树的键值唯一性检查出来（避免冗余）</li><li>所有添加到epoll中的事件都会与设备的<strong>网卡驱动程序</strong>建立回调消息，当某个文件描述符对应的链接有信息传来的时候，就会调用<strong>回调函数</strong>，告知epoll<ul><li>网卡收到消息</li><li>驱动程序处理，并调用对应的回调机制</li><li>epoll通过回调消息收到事件就绪，将其链入<code>rdllist</code>双链表中</li><li>上层只需要调回<code>epoll_wait</code>从该双链表中获取就绪事件</li></ul></li><li>该回调办法在底层为<code>ep_poll_callback</code>，它会将就绪的事件插入到<code>rdllist</code>双链表中</li><li>epoll中每一个事件都会建立一个对应的<code>epitem</code>结构体</li><li>当调用<code>epoll_wait</code>有事件发生的时候，只需要检查<code>eventpoll</code>对象的<code>rdllist</code>双链表中是否有<code>epitem</code>元素即可，有则取出；</li><li>如果<code>rdllist</code>不为空，则将发生的事件复制到用户态，并将事件数量返回给用户；对比需要遍历的<code>select/poll</code>，这个获取就绪事件的<strong>时间复杂度</strong>是<code>O(1)</code>的（直接判断并取出就可以了）</li></ul><p>这一大圈操作都是操作系统自行完成的，对于用户来说是无感知的！</p><p>关于epitem结构体，可以瞅一眼下面的注释，他也是在源码的<code>fs/eventpoll.c</code>文件中</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">epitem</span> &#123;</span><br><span class="line"><span class="comment">/* RB tree node used to link this structure to the eventpoll RB tree */</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">rb_node</span> rbn; <span class="comment">// 这个事件对应的红黑树节点</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* List header used to link this structure to the eventpoll ready list */</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">list_head</span> rdllink; <span class="comment">// 这个事件对应的双链表节点</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Works together &quot;struct eventpoll&quot;-&gt;ovflist in keeping the</span></span><br><span class="line"><span class="comment"> * single linked chain of items.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">epitem</span> *next; </span><br><span class="line"></span><br><span class="line"><span class="comment">/* The file descriptor information this item refers to */</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">epoll_filefd</span> ffd; <span class="comment">// 事件句柄信息</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Number of active wait queue attached to poll operations */</span></span><br><span class="line"><span class="type">int</span> nwait; </span><br><span class="line"></span><br><span class="line"><span class="comment">/* List containing poll wait queues */</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">list_head</span> pwqlist;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* The &quot;container&quot; of this item */</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">eventpoll</span> *ep; <span class="comment">// 指向其所属的epollevent对象</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* List header used to link this item to the &quot;struct file&quot; items list */</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">list_head</span> fllink;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* The structure that describe the interested events and the source fd */</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">epoll_event</span> event; <span class="comment">// 该fd关注的事件</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="5-2-2-PSH标记位"><a href="#5-2-2-PSH标记位" class="headerlink" title="5.2.2 PSH标记位"></a>5.2.2 PSH标记位</h3><p>在学习TCP的时候，我们了解过PSH这个标记位，它的作用是告诉对端的应用层，尽快取走缓冲区中的数据。</p><p>对于epoll而言，这个PSH的作用就是让epoll在<code>rdllist</code>里面新建一个就绪节点，这样上层就能知道这个文件描述符的事件就绪了（至于读不读取依旧是上层的问题）</p><ul><li>你可能会问，既然对方都发消息来催你取数据了，那不应该你的数据并没有被取走吗？这时候该文件描述符的就绪节点不应该已经存在了吗？为什么还需要额外创建一个就绪事件的节点来通知用户呢？</li></ul><p>这就涉及到epoll的两种工作策略LT&#x2F;ET了，后文会讲解；</p><blockquote><p>需要注意的是，epoll并没有对URG进行特殊处理，而是视之为正常的可读事件连入就绪队列，但是事件类型有所不同，可以用<code>EPOLLPRI</code>来关注紧急事件</p><p>（存疑，但是没有找到相关资料，暂且这么认为）</p></blockquote><h3 id="5-2-3-epoll优点"><a href="#5-2-3-epoll优点" class="headerlink" title="5.2.3 epoll优点"></a>5.2.3 epoll优点</h3><p>一下是epoll相比poll和select的优点</p><ul><li>接口使用方便，虽然拆分了3个函数，但是每个函数的功能非常明确；不需要每次使用都重新设置文件描述符，也实现了输入和输出参数的分离</li><li>数据拷贝轻量：在需要的时候调用epoll_ctl来处理文件描述符和事件，并不会每次调用都得大批量在用户和内核态之间拷贝数据（poll和select都需要）</li><li>事件回调机制：使用事件回调来替代遍历，回调函数将就绪的文件描述符结构加入到就绪队列中；<code>epoll_wait</code>直接使用就绪队列，就能知道那些文件描述符就绪；即便文件描述符较多的时候，也能快速知道就绪的文件描述符（省去了遍历的时间消耗）</li><li>无上限：文件描述符没有数量限制</li><li>线程安全：在<code>eventpoll</code>结构体里面，我们可以看到有一个<code>mutex</code>锁，在linux底层已经帮我维护了epoll相关操作的线程安全性！</li></ul><p>在有些博客里面说epoll使用了<strong>内存映射机制</strong>，这种说法是<strong>错误</strong>的！因为<code>epoll_event</code>结构体是在用户态创建的，我们势必还是需要进行一定的用户态到内核态的拷贝。</p><blockquote><p>内存映射机制：linux内核直接将就绪队列通过mmap的方式映射到用户态，避免拷贝消耗（你可以理解为用户态和内核态之间的共享内存）</p></blockquote><h2 id="5-3-工作模式"><a href="#5-3-工作模式" class="headerlink" title="5.3 工作模式"></a>5.3 工作模式</h2><p>在epoll的工作模式中，我们可以选择水平触发和边缘触发，这就好比物理实验中示波器的两种触发模式；</p><p>假设有这样一个tcp通信的栗子：</p><ul><li>对方给我发送了2kb数据</li><li>我通过epoll_wait成功获取到这个文件描述符的读事件就绪</li><li>我取出文件描述符，通过<code>recv</code>读取了1kb的数据</li><li>但缓冲区里面还有1kb……</li></ul><h3 id="5-3-1-水平触发-LT"><a href="#5-3-1-水平触发-LT" class="headerlink" title="5.3.1 水平触发 LT"></a>5.3.1 水平触发 LT</h3><p>所谓水平触发，就是只要fd的缓存区里面有数据，那么epoll就会一直认为这个fd的读事件是就绪的，并一直通知用户；</p><ul><li>上面的栗子中，因为用户只拿走了1kb数据，缓冲区里面还有1kb，在第二次调用<code>epoll_wait</code>的时候，epoll还是会报告该文件描述符的读事件就绪，让用户取走剩下的数据</li><li>只有所有的数据都被处理完毕，epoll才不会继续通知</li><li>LT支持阻塞和非阻塞读写</li></ul><p>因为LT模式只要缓冲区中还有剩余数据，epoll就会一直通知我们，这就允许上层不需要一次性取走所有数据，或者说不立刻处理当前缓冲区的数据。</p><p>因此，在LT模式中，只要是事件就绪，那么缓冲区里面一定会有数据。所以它是即支持阻塞，也支持非阻塞的文件读写的！</p><blockquote><p>select&#x2F;poll都是默认的LT模式，且不可以切换模式；epoll默认是LT，但可以切换到ET</p></blockquote><h3 id="5-3-2-边缘触发-ET"><a href="#5-3-2-边缘触发-ET" class="headerlink" title="5.3.2 边缘触发 ET"></a>5.3.2 边缘触发 ET</h3><p>边缘触发的含义，是只有某个文件描述符的数据变动的时候，才会通知用户；反应到读事件上，只有缓冲区数据增多了，才会通知用户；</p><ul><li>在上面的tcp通信栗子中，epoll会在数据到来的时候通知用户；但即便用户没有一次性读取完毕所有数据，epoll并不会继续通知了（除非有PSH信息到来）</li><li>在ET模式下，文件描述符的事件就绪后，只有一次处理机会。第二次你就无法得知这个文件描述符上是否还有没有读完的数据了</li><li>因为ET模式下<code>epoll_wait</code>返回的次数更少，所以ET的性能远高于LT（nginx默认采用ET模式的epoll）</li><li>因为我们只有一次机会，所以收到事件后必须立即处理</li><li>只支持非阻塞</li></ul><h3 id="5-3-3-LT和ET的区别"><a href="#5-3-3-LT和ET的区别" class="headerlink" title="5.3.3 LT和ET的区别"></a>5.3.3 LT和ET的区别</h3><p>因为ET模式下，epoll只会提示你一次事件就绪，所以就倒逼程序猿在收到这个事件之后，一次性处理完数据；</p><p>当然，LT模式下你也可以这么做（如果每次都能一次性取走数据，那么LT和ET的性能差距就不大了）。但ET模式就相当于告诉所有使用者，必须这么做，减少了容错率；</p><p>但ET的代码复杂度会增加；</p><h3 id="5-3-4-ET和非阻塞"><a href="#5-3-4-ET和非阻塞" class="headerlink" title="5.3.4 ET和非阻塞"></a>5.3.4 ET和非阻塞</h3><p>为什么ET必须要将文件描述符设置成非阻塞呢？</p><p>假设下面这个场景，客户端C给服务端S发送10kb数据，在没有收到服务端对这个数据的响应之前，不会继续发送数据；</p><p><img src="https://img.musnow.top/i/2023/08/1320c1d24627c05783f4d64dc6f43f21.png" alt="image-20230826180800176"></p><p>但服务器一次性只读取了1KB，剩下了9KB数据在缓冲区中；因为数据没有读完，所以不会给客户端发送响应。</p><p><img src="https://img.musnow.top/i/2023/08/42b5a34b96663a7b0314afd41e325896.png" alt="image-20230826180840435"></p><p>因为epoll设置了ET模式，所以并不会认为此时的文件描述符读就绪；<code>epoll_wait</code>不会针对这个文件描述符返回，剩下的9KB数据会一直留在缓冲区中；</p><ul><li>注意，服务端的代码逻辑是收到就绪事件就读取一次；并不存在再次读取的可能</li></ul><p>问题就来了！</p><ul><li>服务端必须要收到就绪事件才会把剩下的9kb数据给读取完毕</li><li>服务端想要收到就绪事件，就必须收到客户端C发来的新数据</li><li>但客户端C认为服务器没有给自己发送响应，不会继续发送数据</li></ul><p>这就相当于一个死循环了！</p><p><img src="https://img.musnow.top/i/2023/08/be296238e7cd395dabf1599602a8b193.png" alt="image-20230826181214987"></p><p>因此，服务端为了保证一次性能将数据全部取出，必须要采用循环读取+非阻塞的方式来将缓冲区读完！</p><p>如果采用阻塞式，那么在轮询读取的时候，就有可能因为缓冲区已经空了而阻塞！因为我们这个是一个单线程的模型，这样会直接导致整个服务器宕机了。</p><p>而LT则不会出现此问题，因为只要缓冲区中有数据就会通知你，所以我们可以一次读取定长，再将读到的数据拼接起来。</p><h3 id="5-3-5-epoll的使用场景"><a href="#5-3-5-epoll的使用场景" class="headerlink" title="5.3.5 epoll的使用场景"></a>5.3.5 epoll的使用场景</h3><p>epoll的高性能是有一定特殊场景的，如果场景不适合，epoll的性能可能表现不佳；</p><ul><li>对于多链接且链接中有一部分活跃的时候，适合使用epoll</li></ul><p>比如各种互联网APP的入口服务器，就很适合使用epoll来处理上万客户端的请求；</p><p>如果是系统内部处理服务器和服务器之间的通信，链接数较少的情况，这种时候使用epoll并不方便。得根据具体需要选择更加适合的IO模型。</p><h2 id="5-4-惊群效应"><a href="#5-4-惊群效应" class="headerlink" title="5.4 惊群效应"></a>5.4 惊群效应</h2><blockquote><p>参考 <a href="https://zhuanlan.zhihu.com/p/359774959">https://zhuanlan.zhihu.com/p/359774959</a></p></blockquote><h3 id="5-4-1-概念"><a href="#5-4-1-概念" class="headerlink" title="5.4.1 概念"></a>5.4.1 概念</h3><p>在多线程环境下，可能会遇到epoll的惊群效应；</p><ul><li>那么什么是惊群效应呢。其产生的原因是什么呢？</li></ul><p>惊群效应的具体情况是，当有多个线程或进程在 epoll 上等待某个事件（如套接字可读事件），当该事件发生时，所有等待的线程或进程都会被唤醒。然而，只有一个线程或进程可以成功地处理这个事件，而其他的线程或进程会进行不必要的竞争，可能会导致额外的上下文切换、锁竞争等问题，从而降低系统性能。</p><ul><li>以下是一个具体场景的说明</li></ul><p>在多线程或者多进程环境下，有些人为了提高程序的稳定性，往往会让<strong>多个线程</strong>或者<strong>多个进程</strong>同时在<code>epoll_wait</code>监听的socket描述符。当一个新的链接请求进来时，操作系统<strong>不知道</strong>选派那个线程或者进程处理此事件，则干脆将其中<strong>几个线程</strong>或者进程给唤醒，而实际上只有其中一个进程或者线程能够成功处理accept事件，其他线程都将失败，且errno错误码为<code>EAGAIN</code>。这种现象称为惊群效应。</p><p>结果是肯定的，惊群效应肯定会带来资源的消耗和性能的影响，因为你无端地多唤醒了几个线程，这些线程&#x2F;进程却没有活干。</p><h3 id="5-4-2-多线程环境下解决办法"><a href="#5-4-2-多线程环境下解决办法" class="headerlink" title="5.4.2 多线程环境下解决办法"></a>5.4.2 多线程环境下解决办法</h3><ul><li>专门的线程负责等待：在多线程场景下，不建议让多个线程进行<code>epoll_wait</code>，而用单个线程进行wait，并由该线程调用<code>accept</code>建立新链接，并将就绪的文件描述符交付给其他线程，来处理后续的读写操作。</li><li>使用线程池：不为每个链接都创立一个专门的线程，而是根据读写事件，将其交付给线程池中已有线程来处理；</li><li>使用ET模式：该模式下读写就绪的时候只会通知一次，再加上epoll本身是线程安全的，所以只会有一个线程可以拿到这个就绪事件，从而避免惊群现象；</li><li>互斥锁：同一时间只有一个线程进行等待和事件处理；</li></ul><h3 id="5-4-3-多进程下解决办法"><a href="#5-4-3-多进程下解决办法" class="headerlink" title="5.4.3 多进程下解决办法"></a>5.4.3 多进程下解决办法</h3><p>目前很多开源软件，如lighttpd和nginx等都采用<code>master/workers</code>的模式提高软件的吞吐能力及并发能力，在nginx中甚至还采用了<strong>负载均衡</strong>的技术，在某个子进程的处理能力达到一定负载之后，由其他<strong>负载较轻的子进程</strong>负责·的调用，那么nginx和Lighttpd是如何避免<code>epoll_wait</code>的惊群效用的呢？</p><ul><li>lighttpd的解决思路是<strong>无视</strong>惊群效应</li></ul><p>仍然采用<code>master/workers</code>模式，每个子进程仍然自己在监听的socket上调用<code>epoll_wait</code>，当有新的链接请求发生时，操作系统仍然只是唤醒其中部分的子进程来处理该事件，仍然只有一个子进程能够成功处理此事件，那么其他被惊醒的子进程捕获<code>EAGAIN</code>错误，并无视。</p><ul><li>nginx的解决思路是互斥锁</li></ul><p>在同一时刻，<strong>永远都只有一个</strong>子进程在监听的socket上<code>epoll_wait</code>，其做法是，创建一个全局的<code>pthread_mutex_t</code>，在子进程进行<code>epoll_wait</code>前，则先获取锁。当<code>epoll_wait</code>返回之后，nginx会调用accept把连接取出来，然后释放文件锁，让别的进程去监听。</p><p>这是一种折衷的办法，并没有很完美，首先进程间<strong>争抢锁</strong>会有性能开耗（即使是非阻塞的锁），中间可能会有小段时间没有进程去获取锁，比如A进程拿到锁，其他进程将会过一小段时间尝试再去获取锁，而这小段时间里面如果请求量很大，A仅接受一小部分请求就让出锁，则中间过程会有一些连接事件被hang住；</p><h3 id="5-4-4-内核解决了惊群效应了吗"><a href="#5-4-4-内核解决了惊群效应了吗" class="headerlink" title="5.4.4 内核解决了惊群效应了吗"></a>5.4.4 内核解决了惊群效应了吗</h3><p>惊群的根本原因在于epoll的默认行为是对于<strong>多进程监听同一文件不会设置互斥</strong>，进而将所有进程唤醒，后续的内核版本主要提供了两种解决方案</p><ol><li>既然默认不会设置互斥，那就加一个互斥功能好了，<code>linux 4.5</code>内核之后给epoll添加了一个<code>EPOLLEXCLUSIVE</code>的标志位，如果设置了这个标志位，那epoll将进程挂到等待队列时将会设置一下互斥标志位，这时实现跟内核原生accept一样的特性，只会唤醒队列中的一个进程</li><li>第二种方法：<code>linux 3.9</code>内核之后给socket提供<code>SO_REUSEPORT</code>标志，这种方式解决得更彻底，他允许不同进程的socket绑定到同一个端口，取代以往需要子进程共享socket监听的方式，这时候，每个进程的监听socket将指向<code>open_file_tables</code>下的不同节点，也就是说不同进程是在自己的设备等待队列下被挂起的，不存在共享fd的问题，也就不存在被同时唤醒的可能。而内核则在驱动中将设置了<code>SO_REUSEPORT</code>并且绑定同一端口的这些socket分到同一个group中，当有tcp连接事件到达的时候，内核将会对源<code>IP+源端口</code>取hash然后指定这个group中其中一个进程来接受连接，相当于在内核级别中实现了一个负载均衡</li></ol><p>基于以上两种方法，其实epoll生态在目前来说不存在所谓的惊群效应了。而新版本的nginx也采用了 <code>SO_REUSEPORT</code>来解决此问题。</p><p>除非你溢用epoll，比如多进程之间共享了同一个epfd（父进程创建epoll由多个子进程来调用），那就不能怪epoll了，因为这时候多个进程都被挂到这个epoll下，这种情况下，已经不是仅仅是惊群效应的问题了；比如说，A进程在epoll挂了socket1的连接事件，B进程调用了epoll_wait，由于属于同一个epfd，当socket1产生事件的时候，进程B也会被唤醒，而更严重的事情在于，在B进程的空间下并不存在socket1这个fd，从而把问题搞得很复杂。</p><p>总结：千万不要在多线程&#x2F;多进程之间共享epfd！</p><h1 id="6-Reactor模型"><a href="#6-Reactor模型" class="headerlink" title="6.Reactor模型"></a>6.Reactor模型</h1><p>接下来就让我们来用epoll编写一个基于Reactor模式的服务器吧！</p><h2 id="6-1-什么是Reactor？"><a href="#6-1-什么是Reactor？" class="headerlink" title="6.1 什么是Reactor？"></a>6.1 什么是Reactor？</h2><ul><li>Reactor模型是基于事件驱动的，通过一个或者多个输入同时传递给服务端进行处理</li><li>服务端请求程序处理传入的多个请求，并分发到相应的处理线程</li><li>基于IO多路转接（多路复用）模型：多个链接通用一个阻塞对象，引用程序只需要在一个阻塞对象等待，无需阻塞等待所有链接；当有新链接或者事件就绪的时候，由操作系统通知应用程序，开始进行业务处理</li><li>基于线程池复用线程资源：不必给每个链接单独创建线程，而是将链接完成后的业务处理交付给已有线程池中的线程进行处理，一个线程在生命周期中可以处理多个链接的业务。</li></ul><p>reactor模式有下面3种方式，<a href="https://blog.csdn.net/wlddhj/article/details/123872275">参考博客 @顽石九变</a></p><h3 id="6-1-1-主从Reactor多线程模型"><a href="#6-1-1-主从Reactor多线程模型" class="headerlink" title="6.1.1 主从Reactor多线程模型"></a>6.1.1 主从Reactor多线程模型</h3><p>第一种是多线程模式的，有不同的从属reactor来进行事件监控和处理</p><ul><li>Reactor主线程负责监听事件并进行链接的accept</li><li>accpet获取到链接后，分配给某一个从Reactor进行读写事件的监听</li><li>从Reactor进行事件监听，当有新事件发生的时候，创建Handler进行事件处理</li><li>Headler通过read读取数据，并处理数据（这里还可以将读取数据后的响应操作分发给线程池进行处理，线程池处理完毕后返回给Handler），通过send返回给客户端</li><li>Reactor主线程可以对应多个子线程</li></ul><p><img src="https://img.musnow.top/i/2023/08/9b1f1f0aec63e52ed44fca99f18d6e5a.png" alt="image-20230828085218401"></p><p><img src="https://img.musnow.top/i/2023/08/ecdd89978c73b286f89f29703c620c7e.png" alt="img"></p><h3 id="6-1-2-单Reactor多线程"><a href="#6-1-2-单Reactor多线程" class="headerlink" title="6.1.2 单Reactor多线程"></a>6.1.2 单Reactor多线程</h3><ul><li>Reactor通过多路转接监听客户端事件，收到事件后，进行分发</li><li>如果是建立链接的请求，则执行accept，建立链接后，创建一个Handler完成链接建立后的各个操作</li><li>如果不是链接请求（读写就绪）则由Reactor分发调用链接对应的读写Handler来进行处理</li><li>Handler只负责响应具体的事件，而不进行具体的业务处理</li><li>通过Handler中的read读取到数据后，分发给线程池子中的线程处理，处理完毕后返回Handler，再通过写方法发送给客户端</li></ul><p><img src="https://img.musnow.top/i/2023/08/18889218bcf8b973dd2140f84ee48c1d.png" alt="img"></p><h3 id="6-1-3-单Reactor单线程"><a href="#6-1-3-单Reactor单线程" class="headerlink" title="6.1.3 单Reactor单线程"></a>6.1.3 单Reactor单线程</h3><p>第三种是单线程模式下的（半异步半同步模型），当收到某个客户端的就绪事件，就去处理这个客户端的请求。此时Handler会完成read到业务处理到send的全流程；</p><p>本次主要写的是该模式下的操作，因为它基本是<strong>串行</strong>运行的，思路比较容易理解。但需要注意的是，这种模式支持的客户端量不应过多，否则会极大影响性能。</p><p><img src="https://img.musnow.top/i/2023/08/bd8688effc6efb18264e9785cc78b54e.png" alt="image-20230828085239238"></p><p><img src="https://img.musnow.top/i/2023/08/b057900a9b937973503f493cfa576711.png" alt="img"></p><h3 id="6-1-4-总结"><a href="#6-1-4-总结" class="headerlink" title="6.1.4 总结"></a>6.1.4 总结</h3><p><strong>三种模式用生活案例来理解</strong></p><ol><li><p>单Reactor单线程，前台接待员和服务员是同一个人，全程为顾客服务</p></li><li><p>单Reactor多线程，1个前台接待员，多个服务员，接待员只负责接待</p></li><li><p>主从Reactor多线程，多个前台接待员，多个服务员</p></li></ol><p><strong>Reactor模型具有如下优点</strong></p><ol><li><p>响应快，不必为单个同步事件所阻塞，虽然Reactor本身依然是同步的</p></li><li><p>可以最大程度的避免复杂的多线程及同步问题，并且避免了多线程&#x2F;进程的切换开销</p></li><li><p>扩展性好，可以方便的通过增加Reactor实例个数来充分利用CPU资源</p></li><li><p>复用性好，Reactor模型本身与具体事件处理逻辑无关，具有很高的复用性</p></li></ol><h2 id="6-2-代码分析"><a href="#6-2-代码分析" class="headerlink" title="6.2 代码分析"></a>6.2 代码分析</h2><p>话不多说，直接上代码吧！本次将所有处理模块都给拆分开来，一一进行说明</p><h3 id="6-2-1-Epoller-hpp"><a href="#6-2-1-Epoller-hpp" class="headerlink" title="6.2.1 Epoller.hpp"></a>6.2.1 Epoller.hpp</h3><p>首先是将对epoll的三个系统调用函数进行一定的封装，统一进行错误的判断处理。方便了其他模块的调用用；</p><p>这部分的代码非常简单，就只在注释里写一下解析吧！</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cerrno&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/epoll.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Log.hpp&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Epoller</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">static</span> <span class="type">const</span> <span class="type">int</span> gsize = <span class="number">128</span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">CreateEpoller</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="type">int</span> epfd = <span class="built_in">epoll_create</span>(gsize); <span class="comment">// 创建对应size的epfd</span></span><br><span class="line">        <span class="keyword">if</span> (epfd &lt; <span class="number">0</span>) <span class="comment">// 错误判断</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">logMessage</span>(FATAL, <span class="string">&quot;epoll_create : %d : %s&quot;</span>, errno, <span class="built_in">strerror</span>(errno));</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">3</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> epfd; <span class="comment">// 正确返回epfd</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">bool</span> <span class="title">AddEvent</span><span class="params">(<span class="type">int</span> epfd, <span class="type">int</span> sock, <span class="type">uint32_t</span> event)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">struct</span> <span class="title class_">epoll_event</span> ev;</span><br><span class="line">        ev.events = event; <span class="comment">// 设置event</span></span><br><span class="line">        ev.data.fd = sock;</span><br><span class="line">        <span class="comment">// 给对应的socket添加到epoll中</span></span><br><span class="line">        <span class="type">int</span> n = <span class="built_in">epoll_ctl</span>(epfd, EPOLL_CTL_ADD, sock, &amp;ev);</span><br><span class="line">        <span class="keyword">return</span> n == <span class="number">0</span>; <span class="comment">// 返回值是是否调用成功</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">bool</span> <span class="title">ModEvent</span><span class="params">(<span class="type">int</span> epfd, <span class="type">int</span> sock, <span class="type">uint32_t</span> event)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">struct</span> <span class="title class_">epoll_event</span> ev;</span><br><span class="line">        ev.events = event;</span><br><span class="line">        ev.data.fd = sock;</span><br><span class="line">        <span class="comment">// 修改已有scoket的event</span></span><br><span class="line">        <span class="comment">// 该socket必须先用ADD添加，否则无法修改，会返回ENOENT错误</span></span><br><span class="line">        <span class="type">int</span> n = <span class="built_in">epoll_ctl</span>(epfd, EPOLL_CTL_MOD, sock, &amp;ev);</span><br><span class="line">        <span class="keyword">return</span> n == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">bool</span> <span class="title">DelEvent</span><span class="params">(<span class="type">int</span> epfd, <span class="type">int</span> sock)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// 删除指定socket</span></span><br><span class="line">        <span class="type">int</span> n = <span class="built_in">epoll_ctl</span>(epfd, EPOLL_CTL_DEL, sock, <span class="literal">nullptr</span>);</span><br><span class="line">        <span class="keyword">return</span> n == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">LoopOnce</span><span class="params">(<span class="type">int</span> epfd, <span class="keyword">struct</span> epoll_event revs[], <span class="type">int</span> num)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// 单次wait的调用，从数组里面取回就绪的文件描述符</span></span><br><span class="line">        <span class="type">int</span> n = <span class="built_in">epoll_wait</span>(epfd, revs, num, <span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">logMessage</span>(FATAL, <span class="string">&quot;epoll_wait : %d : %s&quot;</span>, errno, <span class="built_in">strerror</span>(errno));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> n;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="6-2-2-Sock-hpp"><a href="#6-2-2-Sock-hpp" class="headerlink" title="6.2.2 Sock.hpp"></a>6.2.2 Sock.hpp</h3><p>同select，见上文 <a href="#jump-select">3.2.1 socket</a> 部分；</p><h3 id="6-2-3-Log-hpp"><a href="#6-2-3-Log-hpp" class="headerlink" title="6.2.3 Log.hpp"></a>6.2.3 Log.hpp</h3><p>一个巨简单的日志类</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ctime&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdarg&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cassert&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cassert&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cerrno&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DEBUG 0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NOTICE 1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> WARNING 2</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FATAL 3</span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">char</span> *log_level[] = &#123;<span class="string">&quot;DEBUG&quot;</span>, <span class="string">&quot;NOTICE&quot;</span>, <span class="string">&quot;WARINING&quot;</span>, <span class="string">&quot;FATAL&quot;</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LOGFILE <span class="string">&quot;serverTcp.log&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Log</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Log</span>():<span class="built_in">logFd</span>(<span class="number">-1</span>)</span><br><span class="line">    &#123;&#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">enable</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">umask</span>(<span class="number">0</span>);</span><br><span class="line">        logFd = <span class="built_in">open</span>(LOGFILE, O_WRONLY | O_CREAT | O_APPEND, <span class="number">0666</span>);</span><br><span class="line">        <span class="built_in">assert</span>(logFd != <span class="number">-1</span>);</span><br><span class="line">        <span class="built_in">dup2</span>(logFd, <span class="number">1</span>);</span><br><span class="line">        <span class="built_in">dup2</span>(logFd, <span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    ~<span class="built_in">Log</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(logFd != <span class="number">-1</span>) </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">fsync</span>(logFd);</span><br><span class="line">            <span class="built_in">close</span>(logFd);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> logFd;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// logMessage(DEBUG, &quot;%d&quot;, 10);</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">logMessage</span><span class="params">(<span class="type">int</span> level, <span class="type">const</span> <span class="type">char</span> *format, ...)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">assert</span>(level &gt;= DEBUG);</span><br><span class="line">    <span class="built_in">assert</span>(level &lt;= FATAL);</span><br><span class="line"></span><br><span class="line">    <span class="type">char</span> *name = <span class="built_in">getenv</span>(<span class="string">&quot;USER&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">char</span> logInfo[<span class="number">1024</span>];</span><br><span class="line">    va_list ap;</span><br><span class="line">    <span class="built_in">va_start</span>(ap, format);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">vsnprintf</span>(logInfo, <span class="built_in">sizeof</span>(logInfo) - <span class="number">1</span>, format, ap);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">va_end</span>(ap); <span class="comment">// ap = NULL</span></span><br><span class="line"></span><br><span class="line">    FILE *out = (level == FATAL) ? stderr : stdout;</span><br><span class="line">    <span class="built_in">fprintf</span>(out, <span class="string">&quot;%s | %u | %s | %s\n&quot;</span>,</span><br><span class="line">            log_level[level],</span><br><span class="line">            (<span class="type">unsigned</span> <span class="type">int</span>)<span class="built_in">time</span>(<span class="literal">nullptr</span>),</span><br><span class="line">            name == <span class="literal">nullptr</span> ? <span class="string">&quot;unknow&quot;</span> : name,</span><br><span class="line">            logInfo);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">fflush</span>(out); <span class="comment">// 将C语言缓冲区中的数据刷新到OS</span></span><br><span class="line">    <span class="built_in">fsync</span>(<span class="built_in">fileno</span>(out));   <span class="comment">// 将OS中的数据尽快写入硬盘</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="6-2-4-TcpServer"><a href="#6-2-4-TcpServer" class="headerlink" title="6.2.4 TcpServer"></a>6.2.4 TcpServer</h3><p>这是我们reactor模型的重点</p><h4 id="1-Connection类"><a href="#1-Connection类" class="headerlink" title="1.Connection类"></a>1.Connection类</h4><p>这里先定义了一个Connection链接类，比较重要的是类里面有3个回调方法的指针。在Reactor中，我们用回调方法来替代了主执行流直接调用函数的方式。线程只需要接收到这个<code>Connection</code>对象，就可以用回调方法来实现对链接的数据处理</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">using <span class="type">func_t</span> = <span class="built_in">std</span>::function&lt;<span class="type">int</span>(Connection *)&gt;;</span><br><span class="line">using <span class="type">callback_t</span> = <span class="built_in">std</span>::function&lt;<span class="type">int</span>(Connection *, <span class="built_in">std</span>::<span class="built_in">string</span> &amp;)&gt;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Connection</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">public:</span><br><span class="line">    <span class="comment">// 文件描述符</span></span><br><span class="line">    <span class="type">int</span> sock_;</span><br><span class="line">    TcpServer *R_;<span class="comment">// 主服务器的类指针</span></span><br><span class="line">    <span class="comment">// 自己的接受和发送缓冲区</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> inbuffer_;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> outbuffer_;</span><br><span class="line">    <span class="comment">// 读、写、异常的回调函数</span></span><br><span class="line">    <span class="type">func_t</span> recver_; </span><br><span class="line">    <span class="type">func_t</span> sender_;</span><br><span class="line">    <span class="type">func_t</span> excepter_;</span><br><span class="line"></span><br><span class="line">public:</span><br><span class="line">    Connection(<span class="type">int</span> sock, TcpServer *r) : sock_(sock), R_(r)</span><br><span class="line">    &#123;&#125;</span><br><span class="line">    <span class="type">void</span> <span class="title function_">SetRecver</span><span class="params">(<span class="type">func_t</span> recver)</span> &#123; recver_ = recver; &#125;</span><br><span class="line">    <span class="type">void</span> <span class="title function_">SetSender</span><span class="params">(<span class="type">func_t</span> sender)</span> &#123; sender_ = sender; &#125;</span><br><span class="line">    <span class="type">void</span> <span class="title function_">SetExcepter</span><span class="params">(<span class="type">func_t</span> excepter)</span> &#123; excepter_ = excepter; &#125;</span><br><span class="line">    ~Connection() &#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="2-TcpServer成员变量"><a href="#2-TcpServer成员变量" class="headerlink" title="2.TcpServer成员变量"></a>2.TcpServer成员变量</h4><p>再来看看tcpserver的成员变量有什么</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">private:</span><br><span class="line"><span class="comment">// 接收队列的长度</span></span><br><span class="line">    <span class="type">static</span> <span class="type">const</span> <span class="type">int</span> revs_num = <span class="number">64</span>;</span><br><span class="line">    <span class="comment">// 1. 网络socket</span></span><br><span class="line">    <span class="type">int</span> listensock_;</span><br><span class="line">    <span class="comment">// 2. epoll的fd</span></span><br><span class="line">    <span class="type">int</span> epfd_;</span><br><span class="line">    <span class="comment">// 3. 将epoll和上层代码进行结合，已有链接</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">unordered_map</span>&lt;<span class="type">int</span>, Connection *&gt; connections_;</span><br><span class="line">    <span class="comment">// 4. 就绪事件列表</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> *<span class="title">revs_</span>;</span></span><br><span class="line">    <span class="comment">// 5. 设置完整报文的处理回调方法</span></span><br><span class="line">    <span class="type">callback_t</span> cb_;</span><br></pre></td></tr></table></figure><h4 id="3-构造"><a href="#3-构造" class="headerlink" title="3.构造"></a>3.构造</h4><p>随后便是在构造函数中初始化这些成员变量，先是从<code>Sock.hpp</code>中获取到监听文件描述符，然后再通过Epoller类获取到epfd句柄，最后是将listensocket放入epoll的监听中；</p><p>这里的<code>std::bind</code>的作用，是将当前TcpServer的<code>this</code>指针绑定到<code>TcpServer::Accepter</code>函数的第一个参数上，否则在类外没有办法通过<code>Connection</code>类的回调指针来调用这个类的成员函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">TcpServer(<span class="type">callback_t</span> cb, <span class="type">int</span> port = <span class="number">8080</span>) : cb_(cb)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 当前监听的文件描述符及其事件</span></span><br><span class="line">    revs_ = new <span class="keyword">struct</span> epoll_event[revs_num]; </span><br><span class="line">    <span class="comment">// 网络功能</span></span><br><span class="line">    listensock_ = Sock::SocketInit();</span><br><span class="line">    Util::SetNonBlock(listensock_);</span><br><span class="line">    Sock::Bind(listensock_, port);</span><br><span class="line">    Sock::Listen(listensock_);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 多路转接</span></span><br><span class="line">    epfd_ = Epoller::CreateEpoller();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 添加listensock匹配的connection</span></span><br><span class="line">    AddConnection(listensock_, EPOLLIN | EPOLLET,</span><br><span class="line">                  <span class="built_in">std</span>::bind(&amp;TcpServer::Accepter, this, <span class="built_in">std</span>::placeholders::_1), nullptr, nullptr);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4-添加链接"><a href="#4-添加链接" class="headerlink" title="4.添加链接"></a>4.添加链接</h4><p>在<code>AddConnection</code>函数中，我们会将socket给添加到epfd中；如果这个epfd是使用了<code>EPOLLET</code>的ET模式，则还需要设置非阻塞；</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">AddConnection</span><span class="params">(<span class="type">int</span> sockfd, <span class="type">uint32_t</span> event, <span class="type">func_t</span> recver, <span class="type">func_t</span> sender, <span class="type">func_t</span> excepter)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (event &amp; EPOLLET)</span><br><span class="line">        Util::<span class="built_in">SetNonBlock</span>(sockfd);</span><br><span class="line">    <span class="comment">// 添加sockfd到epoll</span></span><br><span class="line">    Epoller::<span class="built_in">AddEvent</span>(epfd_, sockfd, event);</span><br><span class="line">    <span class="comment">// 将sockfd匹配的Connection也添加到当前的unordered_map中</span></span><br><span class="line">    Connection *conn = <span class="keyword">new</span> <span class="built_in">Connection</span>(sockfd, <span class="keyword">this</span>);</span><br><span class="line">    conn-&gt;<span class="built_in">SetRecver</span>(recver);</span><br><span class="line">    conn-&gt;<span class="built_in">SetSender</span>(sender);</span><br><span class="line">    conn-&gt;<span class="built_in">SetExcepter</span>(excepter);</span><br><span class="line"></span><br><span class="line">    connections_.<span class="built_in">insert</span>(std::<span class="built_in">make_pair</span>(sockfd, conn));</span><br><span class="line">    <span class="built_in">logMessage</span>(DEBUG, <span class="string">&quot;添加新链接到connections成功: %d&quot;</span>, sockfd);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>设置非阻塞的代码很简单，在前文已经演示过了</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Util</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">public:</span><br><span class="line">    <span class="type">static</span> <span class="type">void</span> <span class="title function_">SetNonBlock</span><span class="params">(<span class="type">int</span> fd)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> fl = fcntl(fd, F_GETFL);</span><br><span class="line">        fcntl(fd, F_SETFL, fl | O_NONBLOCK);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="5-析构"><a href="#5-析构" class="headerlink" title="5.析构"></a>5.析构</h4><p>在析构函数中，我们需要将listensocket和epfd两个文件描述符关闭，并析构掉链接数组</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">~<span class="built_in">TcpServer</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (listensock_ != <span class="number">-1</span>)</span><br><span class="line">        <span class="built_in">close</span>(listensock_);</span><br><span class="line">    <span class="keyword">if</span> (epfd_ != <span class="number">-1</span>)</span><br><span class="line">        <span class="built_in">close</span>(epfd_);</span><br><span class="line">    <span class="keyword">delete</span>[] revs_;</span><br><span class="line">    <span class="comment">// 还需要析构掉连接池中尚存在的connection对象</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span>&amp;c:connections_)&#123;</span><br><span class="line">        <span class="keyword">delete</span> c.second;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="6-获取新连接Accept"><a href="#6-获取新连接Accept" class="headerlink" title="6.获取新连接Accept"></a>6.获取新连接Accept</h4><p>在获取新连接这里，我们采用了一个死循环来获取。这是因为对于listensocket文件描述符而言，只要来了一个新链接，在ET模式下就会提示我们。但有可能会出现我们还没有来得及取走这个链接，就又来了一个新链接的情况（可以简化理解为一次性来了两个链接）</p><p>这时候因为ET的特性，我们就需要一次性取走所有链接；为了避免在Accept的时候，因为链接已经都被取走了而阻塞住，我们需要将listensocket设置为<strong>非阻塞</strong>；</p><blockquote><p>关于新链接为什么只关注读事件，在注释中有说明；</p></blockquote><p>对于listensocket来说，这个Accepter函数就是它的读事件回调，所以这个函数的参数也是一个<code>Connection *conn</code>对象，其是为了与其他事件处理函数统一（因为这个事件处理函数不在<code>Connection</code>类中，所以我们必须要获取一个对象才能访问到它的成员变量）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">Accepter</span><span class="params">(Connection *conn)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        std::string clientip;</span><br><span class="line">        <span class="type">uint16_t</span> clientport = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> sockfd = Sock::<span class="built_in">Accept</span>(conn-&gt;sock_, &amp;clientip, &amp;clientport);</span><br><span class="line">        <span class="keyword">if</span> (sockfd &lt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 接收函数被事件打断了</span></span><br><span class="line">            <span class="keyword">if</span> (errno == EINTR)</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            <span class="comment">// 本次数据没有准备好，可以理解为接收缓冲区空了</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (errno == EAGAIN || errno == EWOULDBLOCK)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">logMessage</span>(WARNING, <span class="string">&quot;accept error&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">logMessage</span>(DEBUG, <span class="string">&quot;get a new link: %d&quot;</span>, sockfd);</span><br><span class="line">        <span class="comment">// 注意：默认我们只设置了让epoll帮我们关心读事件，没有关心写事件</span></span><br><span class="line">        <span class="comment">// 为什么没有关注写事件：因为最开始的时候，写空间一定是就绪的！</span></span><br><span class="line">        <span class="comment">// 运行中可能才会存在写条件不满足 -- 写空间被写满了</span></span><br><span class="line">        <span class="built_in">AddConnection</span>(sockfd, EPOLLIN | EPOLLET,</span><br><span class="line">                      std::<span class="built_in">bind</span>(&amp;TcpServer::TcpRecver, <span class="keyword">this</span>, std::placeholders::_1),</span><br><span class="line">                      std::<span class="built_in">bind</span>(&amp;TcpServer::TcpSender, <span class="keyword">this</span>, std::placeholders::_1),</span><br><span class="line">                      std::<span class="built_in">bind</span>(&amp;TcpServer::TcpExcepter, <span class="keyword">this</span>, std::placeholders::_1));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">EAGAIN or EWOULDBLOCK</span><br><span class="line">The socket is marked nonblocking and the receive operation would block, or a receive timeout had been set and the timeout expired before data was received.  POSIX.1 allows either error to be returned for this case, and does not require these constants to have the same value, so  a  portable application should check for both possibilities.</span><br></pre></td></tr></table></figure><h4 id="7-链接的事件处理函数"><a href="#7-链接的事件处理函数" class="headerlink" title="7.链接的事件处理函数"></a>7.链接的事件处理函数</h4><p>其他链接的三个处理函数分别是<code>TcpRever/TcpSender/TcpExcepter</code>;</p><p>首先，在处理某一个链接的时候，我们必须要保证这个链接在已有的map里面，否则代表这个链接已经被关闭或者异常退出了；同理，在异常和关闭链接的处理流程中，我们也需要将链接从map中删除</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">IsExists</span><span class="params">(<span class="type">int</span> sock)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> iter = connections_.<span class="built_in">find</span>(sock);</span><br><span class="line">    <span class="keyword">if</span> (iter == connections_.<span class="built_in">end</span>())</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="读"><a href="#读" class="headerlink" title="读"></a>读</h5><p>对于读事件而言我们也是进行循环读取，该文件描述符也需要被设置为非阻塞。读取的内容拼接到该Connection对象的输入缓冲区string中；</p><p>在读取完毕后，我们需要在协议里面定义一个根据<strong>应用层协议字段</strong>来分离报文的函数（避免tcp的粘包问题），最终会得到一个string的数组，每个数组成员都是一个完整的报文；</p><p>最后，我们直接一个for循环，通过该tcpserver对象在初始化时候设置的<code>cb_</code>函数回调指针，来处理每一个报文（为每一个报文提供服务）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">TcpRecver</span><span class="params">(Connection *conn)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">char</span> buffer[<span class="number">1024</span>];</span><br><span class="line">        <span class="type">ssize_t</span> s = <span class="built_in">recv</span>(conn-&gt;sock_, buffer, <span class="built_in">sizeof</span>(buffer) - <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span> (s &gt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            buffer[s] = <span class="number">0</span>;</span><br><span class="line">            conn-&gt;inbuffer_ += buffer;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (s == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">logMessage</span>(DEBUG, <span class="string">&quot;client quit&quot;</span>);</span><br><span class="line">            conn-&gt;<span class="built_in">excepter_</span>(conn);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (errno == EINTR) <span class="comment">// 接收事件被打断</span></span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            <span class="comment">// 接收缓冲区空了</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (errno == EAGAIN || errno == EWOULDBLOCK)</span><br><span class="line">                <span class="keyword">break</span>; <span class="comment">// 跳出循环</span></span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// 出错了</span></span><br><span class="line">                <span class="built_in">logMessage</span>(DEBUG, <span class="string">&quot;recv error: %d:%s&quot;</span>, errno, <span class="built_in">strerror</span>(errno));</span><br><span class="line">                conn-&gt;<span class="built_in">excepter_</span>(conn);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 将本轮全部读取完毕</span></span><br><span class="line">    std::vector&lt;std::string&gt; result;</span><br><span class="line">    <span class="built_in">PackageSplit</span>(conn-&gt;inbuffer_, &amp;result);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;message : result)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cb_</span>(conn, message);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个框架的好处就在于，你可以单独实现不同协议的报文分离函数和数据服务函数，而不需要重写TcpServer的实现，相当于解耦；</p><h5 id="写"><a href="#写" class="headerlink" title="写"></a>写</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">TcpSender</span><span class="params">(Connection *conn)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">ssize_t</span> n = <span class="built_in">send</span>(conn-&gt;sock_, conn-&gt;outbuffer_.<span class="built_in">c_str</span>(), conn-&gt;outbuffer_.<span class="built_in">size</span>(), <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span>(n &gt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 去除已经成功发送的数据</span></span><br><span class="line">            conn-&gt;outbuffer_.<span class="built_in">erase</span>(<span class="number">0</span>, n);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 写入操作被打断</span></span><br><span class="line">            <span class="keyword">if</span>(errno == EINTR) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="comment">// 写入缓冲区满了，没办法继续写</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(errno == EAGAIN || errno == EWOULDBLOCK) <span class="keyword">break</span>; </span><br><span class="line">            <span class="keyword">else</span> <span class="comment">// 异常</span></span><br><span class="line">            &#123;</span><br><span class="line">                conn-&gt;<span class="built_in">excepter_</span>(conn);</span><br><span class="line">                <span class="built_in">logMessage</span>(DEBUG, <span class="string">&quot;send error: %d:%s&quot;</span>, errno, <span class="built_in">strerror</span>(errno));</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意，这里的写入如果遇到<code>(errno == EAGAIN || errno == EWOULDBLOCK)</code> 这两种情况，并不能确保输出缓冲区中的数据已经被全部写入了；有可能是写入缓冲区满了导致无法继续写入；</p><p>这种i情况下，我们需要判断<code>outbuffer</code>是否为空，如果不为空，则还是需要设置<code>EPOLLOUT</code>标记位，告知epoll继续帮我们关注写事件（这样epoll就会发信息告知Reactor，Reactor会重新调用写入函数，继续写入缓冲区的剩下数据）这个操作会在主执行流中进行统一判断</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 主执行流</span></span><br><span class="line">conn-&gt;<span class="built_in">sender_</span>(conn); <span class="comment">// 主执行流调用发送函数</span></span><br><span class="line"><span class="comment">// 判断本次是否发完毕了，没有发完毕还需要继续关心读写</span></span><br><span class="line"><span class="keyword">if</span>(conn-&gt;outbuffer_.<span class="built_in">empty</span>()) conn-&gt;R_-&gt;<span class="built_in">EnableReadWrite</span>(conn-&gt;sock_, <span class="literal">true</span>, <span class="literal">false</span>);</span><br><span class="line"><span class="keyword">else</span> conn-&gt;R_-&gt;<span class="built_in">EnableReadWrite</span>(conn-&gt;sock_, <span class="literal">true</span>, <span class="literal">true</span>);</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 打开或者关闭对于特定socket是否要关心读或者写</span></span><br><span class="line"><span class="comment">//- EnableReadWrite(sock, true, false); //只关心读</span></span><br><span class="line"><span class="comment">//- EnableReadWrite(sock, true, true);  //同时关心读写</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">EnableReadWrite</span><span class="params">(<span class="type">int</span> sock, <span class="type">bool</span> readable, <span class="type">bool</span> writeable)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">uint32_t</span> event = <span class="number">0</span>;</span><br><span class="line">    event |= (readable ? EPOLLIN : <span class="number">0</span>);</span><br><span class="line">    event |= (writeable ? EPOLLOUT : <span class="number">0</span>);</span><br><span class="line">    Epoller::<span class="built_in">ModEvent</span>(epfd_, sock, event);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h5><p>为了统一进行异常处理，在上文中当我们遇到读写出错的时候，都会调用这个函数；</p><p>在这个函数体内，会将链接从epoll中删除、关闭链接、释放connection对象、将文件描述符从map里面剔除；</p><p>需要注意的是，一定要先将socket从epoll里面剔除掉，再关闭socket！</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">TcpExcepter</span><span class="params">(Connection *conn)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 0. 判断有效性</span></span><br><span class="line">    <span class="keyword">if</span>(!<span class="built_in">IsExists</span>(conn-&gt;sock_)) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 所有的服务器异常，都会被归类到这里</span></span><br><span class="line">    <span class="comment">// 1. 删除epoll的监看</span></span><br><span class="line">    Epoller::<span class="built_in">DelEvent</span>(epfd_, conn-&gt;sock_);</span><br><span class="line">    <span class="built_in">logMessage</span>(DEBUG, <span class="string">&quot;remove epoll event!&quot;</span>);</span><br><span class="line">    <span class="comment">// 2. close</span></span><br><span class="line">    <span class="built_in">close</span>(conn-&gt;sock_);</span><br><span class="line">    <span class="built_in">logMessage</span>(DEBUG, <span class="string">&quot;close fd: %d&quot;</span>, conn-&gt;sock_);</span><br><span class="line">    <span class="comment">// 3. delete conn;</span></span><br><span class="line">    <span class="keyword">delete</span> connections_[conn-&gt;sock_];</span><br><span class="line">    <span class="built_in">logMessage</span>(DEBUG, <span class="string">&quot;delete connection object done&quot;</span>);</span><br><span class="line">    <span class="comment">// 4. erase conn;</span></span><br><span class="line">    connections_.<span class="built_in">erase</span>(conn-&gt;sock_);</span><br><span class="line">    <span class="built_in">logMessage</span>(DEBUG, <span class="string">&quot;erase connection from connections&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="8-运行"><a href="#8-运行" class="headerlink" title="8.运行"></a>8.运行</h4><p>对于TcpServer而言，一次的运行就是调用一次<code>epoll_wait</code>，再根据事件就绪的文件描述符，调用不同的事件处理函数</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Dispatcher</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n = Epoller::<span class="built_in">LoopOnce</span>(epfd_, revs_, revs_num);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> sock = revs_[i].data.fd;</span><br><span class="line">        <span class="type">uint32_t</span> revent = revs_[i].events;</span><br><span class="line">        <span class="comment">// 判断是否出现错误，如果出现了错误，那就把EPOLLIN和OUT都加上</span></span><br><span class="line">        <span class="comment">// 这样这个链接会进入下面的处理函数，并在处理函数中出现异常</span></span><br><span class="line">        <span class="comment">// 处理函数中出现异常回统一调用TcpExcpter函数</span></span><br><span class="line">        <span class="keyword">if</span>(revent &amp; EPOLLHUP) revent |= (EPOLLIN|EPOLLOUT);</span><br><span class="line">        <span class="keyword">if</span>(revent &amp; EPOLLERR) revent |= (EPOLLIN|EPOLLOUT);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (revent &amp; EPOLLIN)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">IsExists</span>(sock) &amp;&amp; connections_[sock]-&gt;recver_)</span><br><span class="line">                connections_[sock]-&gt;<span class="built_in">recver_</span>(connections_[sock]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 当链接的写事件被激活的时候，在这里就会触发写事件的处理</span></span><br><span class="line">        <span class="comment">// 所以并不需要在recv里面主动调用写事件处理函数</span></span><br><span class="line">        <span class="comment">// 只需要告诉epoll让它帮我们监控写事件，那么就会在这里触发写操作</span></span><br><span class="line">        <span class="keyword">if</span> (revent &amp; EPOLLOUT)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">IsExists</span>(sock) &amp;&amp; connections_[sock]-&gt;sender_)</span><br><span class="line">                connections_[sock]-&gt;<span class="built_in">sender_</span>(connections_[sock]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>整个服务器运行起来，就一直调用分发函数就OK啦~</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Run</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">Dispatcher</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="6-2-5-主执行流"><a href="#6-2-5-主执行流" class="headerlink" title="6.2.5 主执行流"></a>6.2.5 主执行流</h3><p>对于主执行流而言，要做的就是获取到命令行参数的端口，然后创建tcpserver对象并绑定事件处理函数</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;TcpServer.hpp&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Service.hpp&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">usage</span><span class="params">(std::string process)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cerr &lt;&lt; <span class="string">&quot;\nUsage: &quot;</span> &lt;&lt; process &lt;&lt; <span class="string">&quot; port\n&quot;</span></span><br><span class="line">         &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (argc != <span class="number">2</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">usage</span>(argv[<span class="number">0</span>]);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">TcpServer <span class="title">svr</span><span class="params">(HandlerRequest, atoi(argv[<span class="number">1</span>]))</span></span>;</span><br><span class="line">    svr.<span class="built_in">Run</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>事件处理函数可以做任意封装，来实现你自己想要的功能</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">HandlerRequest</span><span class="params">(Connection *conn, std::string &amp;message)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// beginhandler里面是具体的调用逻辑，calculator是本次事务处理函数</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">BeginHandler</span>(conn, message, calculator);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里就是我们单个完整报文的处理函数，在tcprecver方法里面被调用了；</p><p>根据上文描述的调用方法，我们可以确定，这里传入来的<code>message</code>肯定是一个完整的应用层报文，我们只需要创建一个属于我们自己的协议和协议中的数据处理函数就OK了！</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">BeginHandler</span><span class="params">(Connection *conn, std::string &amp;message, <span class="type">service_t</span> service)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// message一定是一个完整的报文，因为我们已经对它进行了解码</span></span><br><span class="line">    Request req;</span><br><span class="line">    <span class="comment">// 反序列化，进行处理的问题</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">Parser</span>(message, &amp;req))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 写回错误消息</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="comment">// 可以直接关闭连接</span></span><br><span class="line">        <span class="comment">// conn-&gt;excepter_(conn);</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 业务逻辑</span></span><br><span class="line">    Response resp = <span class="built_in">service</span>(req);</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; req.x &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; req.op &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; req.y &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; resp.code &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; resp.result &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 序列化</span></span><br><span class="line">    std::string sendstr;</span><br><span class="line">    <span class="built_in">Serialize</span>(resp, &amp;sendstr);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 处理完毕的结果，发送回给client</span></span><br><span class="line">    conn-&gt;outbuffer_ += sendstr;</span><br><span class="line">    conn-&gt;<span class="built_in">sender_</span>(conn);</span><br><span class="line">    <span class="keyword">if</span>(conn-&gt;outbuffer_.<span class="built_in">empty</span>()) conn-&gt;R_-&gt;<span class="built_in">EnableReadWrite</span>(conn-&gt;sock_, <span class="literal">true</span>, <span class="literal">false</span>);</span><br><span class="line">    <span class="keyword">else</span> conn-&gt;R_-&gt;<span class="built_in">EnableReadWrite</span>(conn-&gt;sock_, <span class="literal">true</span>, <span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;--- end ---&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="6-2-6-协议和数据处理"><a href="#6-2-6-协议和数据处理" class="headerlink" title="6.2.6 协议和数据处理"></a>6.2.6 协议和数据处理</h3><p>下面提供一个最基础的计算器协议，这个协议的好处是我们可以用telnet就模拟出请求，无需写一个tcp客户端。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">x 操作符 y#</span><br></pre></td></tr></table></figure><p>这个协议中，每个有效数据中都会带上一个空格，并以<code>#</code>作为单个报文的结尾；</p><p>响应和请求的结构体格式也非常简单，响应里面是状态码和计算结果；我们在协议中添加序列化和反序列化函数就可以将响应和请求结构体转成字符串</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Request</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line">    <span class="type">int</span> y;</span><br><span class="line">    <span class="type">char</span> op;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Response</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> code;</span><br><span class="line">    <span class="type">int</span> result;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>完整代码</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SEP <span class="string">&#x27;#&#x27;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SEP_LEN sizeof(SEP)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CRLF <span class="string">&quot;\r\n&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CRLF_LEN strlen(CRLF)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SPACE <span class="string">&quot; &quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SPACE_LEN strlen(SPACE)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 分离独立报文</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">PackageSplit</span><span class="params">(std::string &amp;inbuffer, std::vector&lt;std::string&gt; *result)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        std::<span class="type">size_t</span> pos = inbuffer.<span class="built_in">find</span>(SEP);</span><br><span class="line">        <span class="keyword">if</span> (pos == std::string::npos)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        result-&gt;<span class="built_in">push_back</span>(inbuffer.<span class="built_in">substr</span>(<span class="number">0</span>, pos));</span><br><span class="line">        inbuffer.<span class="built_in">erase</span>(<span class="number">0</span>, pos + SEP_LEN);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Request</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line">    <span class="type">int</span> y;</span><br><span class="line">    <span class="type">char</span> op;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Response</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> code;</span><br><span class="line">    <span class="type">int</span> result;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">Parser</span><span class="params">(std::string &amp;in, Request *req)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 1 + 1, 2 * 4, 5 * 9, 6 *1</span></span><br><span class="line">    std::<span class="type">size_t</span> spaceOne = in.<span class="built_in">find</span>(SPACE);</span><br><span class="line">    <span class="keyword">if</span> (std::string::npos == spaceOne)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    std::<span class="type">size_t</span> spaceTwo = in.<span class="built_in">rfind</span>(SPACE);</span><br><span class="line">    <span class="keyword">if</span> (std::string::npos == spaceTwo)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    std::string dataOne = in.<span class="built_in">substr</span>(<span class="number">0</span>, spaceOne);</span><br><span class="line">    std::string dataTwo = in.<span class="built_in">substr</span>(spaceTwo + SPACE_LEN);</span><br><span class="line">    std::string oper = in.<span class="built_in">substr</span>(spaceOne + SPACE_LEN, spaceTwo - (spaceOne + SPACE_LEN));</span><br><span class="line">    <span class="keyword">if</span> (oper.<span class="built_in">size</span>() != <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 转成内部成员</span></span><br><span class="line">    req-&gt;x = <span class="built_in">atoi</span>(dataOne.<span class="built_in">c_str</span>());</span><br><span class="line">    req-&gt;y = <span class="built_in">atoi</span>(dataTwo.<span class="built_in">c_str</span>());</span><br><span class="line">    req-&gt;op = oper[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Serialize</span><span class="params">(<span class="type">const</span> Response &amp;resp, std::string *out)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::string ec = std::<span class="built_in">to_string</span>(resp.code);</span><br><span class="line">    std::string res = std::<span class="built_in">to_string</span>(resp.result);</span><br><span class="line"></span><br><span class="line">    *out = ec;</span><br><span class="line">    *out += SPACE;</span><br><span class="line">    *out += res;</span><br><span class="line">    *out += CRLF;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在<code>service.hpp</code>里面则是数据处理的计算函数，通过我们传入的请求，计算出结构并构造响应返回给用户</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Protocol.hpp&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="type">service_t</span> = std::function&lt;<span class="built_in">Response</span> (<span class="type">const</span> Request &amp;req)&gt;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> Response <span class="title">calculator</span><span class="params">(<span class="type">const</span> Request &amp;req)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Response resp = &#123;<span class="number">0</span>, <span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">switch</span> (req.op)</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;+&#x27;</span>:</span><br><span class="line">        resp.result = req.x + req.y;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;-&#x27;</span>:</span><br><span class="line">        resp.result = req.x - req.y;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;*&#x27;</span>:</span><br><span class="line">        resp.result = req.x * req.y;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;/&#x27;</span>:</span><br><span class="line">    &#123; <span class="comment">// x_ / y_</span></span><br><span class="line">        <span class="keyword">if</span> (req.y == <span class="number">0</span>)</span><br><span class="line">            resp.code = <span class="number">-1</span>; <span class="comment">// -1. 除0</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            resp.result = req.x / req.y;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;%&#x27;</span>:</span><br><span class="line">    &#123; <span class="comment">// x_ / y_</span></span><br><span class="line">        <span class="keyword">if</span> (req.y == <span class="number">0</span>)</span><br><span class="line">            resp.code = <span class="number">-2</span>; <span class="comment">// -2. 模0</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            resp.result = req.x % req.y;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        resp.code = <span class="number">-3</span>; <span class="comment">// -3: 非法操作符</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> resp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="6-2-7-测试"><a href="#6-2-7-测试" class="headerlink" title="6.2.7 测试"></a>6.2.7 测试</h3><p>可以看到，我们的服务启动了之后，成功接收了一个链接，并计算出了我们发送的结果</p><p><img src="https://img.musnow.top/i/2023/08/5e164406ab4e280265a7fcd8fdc3de67.png" alt="image-20230828115411040"></p><p>多个链接也不在话下！</p><p><img src="https://img.musnow.top/i/2023/08/58a989acdf95c2dc2c89a1677f8a4d56.png" alt="image-20230828115525101"></p><h1 id="The-end"><a href="#The-end" class="headerlink" title="The end"></a>The end</h1><p>多路转接这部分是linux服务器最重要的一部分知识，因为大部分服务器都抛弃了最传统的一个线程维护一个链接这样的方式，而采用了多路转接来实现对大量进程的维护；</p><p>本文是学习阶段的产物，有错误在所难免，请大佬们指教！</p><p><img src="https://img.musnow.top/i/2023/08/56eecd58cac3b6593f83998c9f30eb4b.gif" alt="QQ图片20220413084241"></p>]]></content>
    
    
    <summary type="html">多路转接和高级IO</summary>
    
    
    
    <category term="玩上Linux" scheme="https://blog.musnow.top/categories/%E7%8E%A9%E4%B8%8ALinux/"/>
    
    
    <category term="Linux" scheme="https://blog.musnow.top/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>【C++】构造函数和初始化列表的性能差距</title>
    <link href="https://blog.musnow.top/posts/2628258650/"/>
    <id>https://blog.musnow.top/posts/2628258650/</id>
    <published>2023-08-24T13:55:38.000Z</published>
    <updated>2023-08-24T13:55:38.000Z</updated>
    
    <content type="html"><![CDATA[<p>构造函数和初始化列表的性能差距对比测试</p><span id="more"></span><h1 id="1-说明"><a href="#1-说明" class="headerlink" title="1.说明"></a>1.说明</h1><p>在C++类和对象中，你可能听到过更加推荐用初始化列表来初始化类内成员。如果类内成员是自定义类型，则只能在初始化列表中调用自定义类型的构造函数。</p><p>但初始化列表和在构造函数体内直接赋值有无性能差距呢？今天就用一份相对简单的代码来测试一下</p><h1 id="2-测试"><a href="#2-测试" class="headerlink" title="2.测试"></a>2.测试</h1><h2 id="2-1-代码说明"><a href="#2-1-代码说明" class="headerlink" title="2.1 代码说明"></a>2.1 代码说明</h2><p>首先是一个自定义类型，实现带缺省值的默认构造，拷贝构造和赋值重载这三个函数，并在内部新增打印来区分不同的函数</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">mytest</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">mytest</span>(<span class="type">int</span> a = <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        _a = a;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;mytest() &quot;</span> &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">mytest</span>(<span class="type">const</span> mytest&amp; st) &#123;</span><br><span class="line">        _a = st._a;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;mytest(copy) &quot;</span> &lt;&lt; st._a &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    mytest&amp; <span class="keyword">operator</span>=(<span class="type">const</span> mytest&amp; st)</span><br><span class="line">    &#123;</span><br><span class="line">        _a = st._a;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;mytest operator= &quot;</span> &lt;&lt; st._a &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> _a;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>再在另外一个类中使用这个自定义类型</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">myclass</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">myclass</span>(<span class="type">const</span> <span class="keyword">struct</span> mytest&amp; st, <span class="type">int</span> b)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;myclass() _b:&quot;</span> &lt;&lt; _b &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">mytest</span> _sa;</span><br><span class="line">    <span class="type">int</span> _b;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>此时构造函数就有两种写法，一种是在初始化列表中初始化这个自定义类型</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">myclass</span>(<span class="type">const</span> <span class="keyword">struct</span> mytest&amp; st, <span class="type">int</span> b)</span><br><span class="line">       :_sa(st),</span><br><span class="line">       _b(b)</span><br><span class="line">   &#123;</span><br><span class="line">       cout &lt;&lt; <span class="string">&quot;myclass() _b:&quot;</span> &lt;&lt; _b &lt;&lt; endl;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>另外一种是在构造函数体内通过赋值重载来初始化这个自定义类型</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">myclass</span>(<span class="type">const</span> <span class="keyword">struct</span> mytest&amp; st, <span class="type">int</span> b)</span><br><span class="line">&#123;</span><br><span class="line">     _sa = st;</span><br><span class="line">     _b = b;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;myclass() _b:&quot;</span> &lt;&lt; _b &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>需要注意的是，这里的自定义类型传参采用了引用传参，并不会因此产生额外的拷贝！</p><p>主函数体如下，为了区分第一个<code>mytest</code>的构造函数，我在其后新增了一行输出作为分割</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">mytest <span class="title">test_a</span><span class="params">(<span class="number">1</span>)</span></span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;------&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="function">myclass <span class="title">test</span><span class="params">(test_a, <span class="number">3</span>)</span></span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-2-测试"><a href="#2-2-测试" class="headerlink" title="2.2 测试"></a>2.2 测试</h2><p>先来看看使用赋值初始化的方式，可以看到，虽然我们在初始化列表中什么都没有写，但是这里<strong>依旧调用了默认的构造函数</strong>（因为默认构造函数的缺省值给的是<code>-1</code>，这里能通过参数判断出来这并不是我们显式调用的构造）</p><p>调用了默认构造后，又通过赋值重载来初始化了一遍<code>_sa</code>，相当于两次初始化</p><p><img src="https://img.musnow.top/i/2023/08/ce34a7ef5363f3de7ee7ee1034f75e04.png" alt="image-20230824212849577"></p><p>但如果调用初始化列表，则只会有一次拷贝构造，<strong>避免了额外的默认构造调用</strong>！</p><p><img src="https://img.musnow.top/i/2023/08/b9f31dd47442b86d7580fa6e779c1ef3.png" alt="image-20230824213021929"></p><p>在linux下也测试过了，结果和VS2019相同</p><h1 id="3-结论"><a href="#3-结论" class="headerlink" title="3.结论"></a>3.结论</h1><p>结论就出来了：初始化列表能节省一次默认构造的调用，优化性能！</p><h2 id="3-1-实际场景"><a href="#3-1-实际场景" class="headerlink" title="3.1 实际场景"></a>3.1 实际场景</h2><p>在上面的场景中，性能差距可能并不会特别大，但是在下面的场景中可能就不一样了</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">mytest</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">mytest</span>(<span class="type">int</span> sz = <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        _str = <span class="keyword">new</span> <span class="type">char</span>[sz];</span><br><span class="line">        _sz = sz;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;mytest() &quot;</span> &lt;&lt; sz &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">mytest</span>(<span class="type">const</span> mytest&amp; st) &#123;</span><br><span class="line">        <span class="keyword">delete</span> _str;<span class="comment">// 需要先销毁原视的数据</span></span><br><span class="line">        _str = <span class="keyword">new</span> <span class="type">char</span>[st._sz]; <span class="comment">// 再创建一个新的</span></span><br><span class="line">        _sz = st._sz;</span><br><span class="line">        <span class="comment">//省略拷贝数据的代码</span></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;mytest(copy) &quot;</span> &lt;&lt; st._sz &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    mytest&amp; <span class="keyword">operator</span>=(<span class="type">const</span> mytest&amp; st)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">delete</span> _str;<span class="comment">// 需要先销毁原视的数据</span></span><br><span class="line">        _str = <span class="keyword">new</span> <span class="type">char</span>[st._sz]; <span class="comment">// 再创建一个新的</span></span><br><span class="line">        <span class="comment">//省略拷贝数据的代码</span></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;mytest&amp; operator= &quot;</span> &lt;&lt; st._sz &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">char</span>* _str;</span><br><span class="line">    <span class="type">size_t</span> _sz;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">myclass</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">myclass</span>(<span class="type">const</span> <span class="keyword">struct</span> mytest&amp; st, <span class="type">int</span> b)</span><br><span class="line">        :_sa(st),</span><br><span class="line">        _b(b)</span><br><span class="line">    &#123;</span><br><span class="line">         <span class="comment">//_sa = st;</span></span><br><span class="line">         <span class="comment">//_b = b;</span></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;myclass() _b:&quot;</span> &lt;&lt; _b &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">mytest</span> _sa;</span><br><span class="line">    <span class="type">int</span> _b;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在这个场景中，因为<code>mytest</code>自定义类型的拷贝构造涉及到了深拷贝，此时就需要将已有的空间给销毁了，再new一片新的空间出来，再将数据给拷贝过去。</p><p>白白多了一层默认构造中的new空间的+拷贝构造中delete原有空间的消耗！</p><p>如果类中需要深拷贝的成员不止一个，那性能差距就更大！</p><p>所以在C++中，<strong>一律以初始化列表优先</strong>！</p><hr><p>这里顺带提一嘴初始化列表的小坑，也算是复习；</p><p>当你使用初始化列表来初始化类内成员的时候，初始化的顺序是类内成员声明的顺序，而<strong>不是初始化列表中的顺序</strong>！这点非常重要，如果顺序不对，可能会出现使用未定义（还没有初始化完成）的参数的bug！</p>]]></content>
    
    
    <summary type="html">构造函数和初始化列表的性能差距对比测试</summary>
    
    
    
    <category term="遇见C++" scheme="https://blog.musnow.top/categories/%E9%81%87%E8%A7%81C/"/>
    
    
    <category term="C++" scheme="https://blog.musnow.top/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>【牛客网】BM3链表中的节点每k个一组翻转</title>
    <link href="https://blog.musnow.top/posts/3391123821/"/>
    <id>https://blog.musnow.top/posts/3391123821/</id>
    <published>2023-08-24T06:05:28.000Z</published>
    <updated>2023-08-24T06:05:28.000Z</updated>
    
    <content type="html"><![CDATA[<p>BM3链表中的节点每k个一组翻转</p><span id="more"></span><h1 id="1-题目"><a href="#1-题目" class="headerlink" title="1.题目"></a>1.题目</h1><p><a href="https://www.nowcoder.com/practice/b49c3dc907814e9bbfa8437c251b028e?tpId=295&tqId=722&ru=/exam/company&qru=/ta/format-top101/question-ranking&sourceUrl=/exam/company"><strong>BM3 链表中的节点每k个一组翻转</strong></a></p><p>将给出的链表中的节点每 k 个一组翻转，返回翻转后的链表<br>如果链表中的节点数不是 k 的倍数，<strong>将最后剩下的节点保持原样</strong><br>你不能更改节点中的值，只能更改节点本身。</p><p><img src="https://img.musnow.top/i/2023/08/95cfbee58b6d1466bde50dd0daad2383.png" alt="image-20230824140620807"></p><h1 id="2-解析"><a href="#2-解析" class="headerlink" title="2.解析"></a>2.解析</h1><h2 id="2-1-链表逆置"><a href="#2-1-链表逆置" class="headerlink" title="2.1 链表逆置"></a>2.1 链表逆置</h2><p>其他部分其实很好解决，基于链表逆置的代码（即逆置整个链表的代码）</p><p>我们只需要将每一个需要逆置的小区间的开头给记下来，交付给链表逆置就可以了。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 无差别逆置</span></span><br><span class="line"><span class="function">ListNode* <span class="title">reverseNode</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="literal">nullptr</span> || head-&gt;next == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ListNode* ans = <span class="built_in">reverseNode</span>(head-&gt;next);</span><br><span class="line">    head-&gt;next-&gt;next = head;</span><br><span class="line">    head-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-2-记录每个需要逆置的区间"><a href="#2-2-记录每个需要逆置的区间" class="headerlink" title="2.2 记录每个需要逆置的区间"></a>2.2 记录每个需要逆置的区间</h2><p>比如如下部分代码，为了方便进行遍历和指针控制，我创建了一个头节点放置在了原本链表开头</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 头节点和遍历指针</span></span><br><span class="line"><span class="function">ListNode <span class="title">phead</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br><span class="line">phead.next = head;</span><br><span class="line">ListNode* cur = &amp;phead;</span><br><span class="line"><span class="comment">// 把每k个节点单独取出来，分别逆置后链接起来</span></span><br><span class="line">std::vector&lt;ListNode*&gt; begin_node_v,begin_node_prev_v;</span><br><span class="line"><span class="type">int</span> index = k<span class="number">-1</span>; <span class="comment">// 初始化为k-1(忽略头节点)，原有链表第一个节点始终入栈</span></span><br><span class="line"><span class="type">int</span> node_count = <span class="number">0</span>;<span class="comment">// 节点总数（包含头节点）</span></span><br><span class="line"><span class="keyword">while</span> (cur != <span class="literal">nullptr</span>) &#123; <span class="comment">// 不知道有多长，得死循环</span></span><br><span class="line">    <span class="keyword">if</span>(index+<span class="number">1</span> == k &amp;&amp; cur != &amp;phead)&#123;</span><br><span class="line">        begin_node_prev_v.<span class="built_in">push_back</span>(cur);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (index == k) &#123;</span><br><span class="line">        begin_node_v.<span class="built_in">push_back</span>(cur);</span><br><span class="line">        index = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cur = cur-&gt;next;</span><br><span class="line">    index++;</span><br><span class="line">    node_count ++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里还创建了两个vector数组</p><ul><li><code>begin_node_v</code>：待逆置区间的开头</li><li><code>begin_node_prev_v</code>：待逆置区间的开头的上一个</li></ul><p>下面是对这两个数组的说明，如果给出的示例是如下形式</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;1,2,3,4,5&#125;,2</span><br></pre></td></tr></table></figure><p>那么两个数组分别存储了如下值</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">begin_node_v:     &#123;1,3,5&#125;</span><br><span class="line">begin_node_prev_v: &#123;2,4&#125;</span><br></pre></td></tr></table></figure><p>这样一来，第一个数组实际上存放的是每个区间的<strong>开头</strong>，第二个数组存放的则是每个区间的<strong>结尾</strong>。<strong>逆置了之后</strong>:</p><ul><li>第二个数组就是新区间的开头</li><li>第一个数组就是新区间的结尾</li></ul><p>方便我们将逆置后的链表重新连起来！</p><h2 id="2-3-抛弃无需逆置的区间"><a href="#2-3-抛弃无需逆置的区间" class="headerlink" title="2.3 抛弃无需逆置的区间"></a>2.3 抛弃无需逆置的区间</h2><p>在上面的循环中，用了<code>node_count</code>来计算了整个链表的长度，减1剔除我自己添加的头节点，就是原始链表的长度。</p><p>题目有个特殊要求：如果原始链表的长度并非k的整数倍，那么最后一段区域的链表是不需要逆置的</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1 - 2 - 3 - 4 - 5</span><br><span class="line">当k=3的时候，只需要逆置 1-2-3</span><br><span class="line">            4-5不需要逆置</span><br><span class="line">3 - 2 - 1 - 4 - 5</span><br></pre></td></tr></table></figure><p>在这种情况，用例和两个数组存放的节点如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">用例 &#123;1,2,3,4,5&#125;,3</span><br><span class="line"></span><br><span class="line">begin_node_v:     &#123;1,4&#125;</span><br><span class="line">begin_node_prev_v: &#123;3&#125;</span><br></pre></td></tr></table></figure><p>如果我们直接将<code>begin_node_v</code>里面的节点交付给链表逆置函数，就会将<code>4-5</code>这一段夜给逆置，最终返回的结果是<code>3-2-1-5-4</code>，不符合题目要求！</p><p>所以在这种情况下，我们需要将4从第一个数组中删除！如果原视链表的节点数量已经小于k了，则也不需要逆置，直接返回即可。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 如果节点总数量小于k则不逆置直接返回</span></span><br><span class="line">node_count --;<span class="comment">//减-1 头节点</span></span><br><span class="line"><span class="keyword">if</span>(node_count &lt;k)&#123;</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 不是整数倍，代表最后一个是不要处理的</span></span><br><span class="line">ListNode* last_link = <span class="literal">nullptr</span>; </span><br><span class="line"><span class="keyword">if</span>((node_count %k) != <span class="number">0</span>) &#123;</span><br><span class="line">    last_link = begin_node_v[begin_node_v.<span class="built_in">size</span>()<span class="number">-1</span>];<span class="comment">// 最后一个</span></span><br><span class="line">    begin_node_v.<span class="built_in">pop_back</span>();<span class="comment">// 删除最后一个</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>另外，为了最终将这段么有逆置的链表和新链表连起来，我们还需用一个指针记录下这一段的开头；<code>last_link</code>初始化为空是方便后续的判断，如果为空代表不存在这一段链表，不需要链接。</p><h2 id="2-4-区间结束标识"><a href="#2-4-区间结束标识" class="headerlink" title="2.4 区间结束标识"></a>2.4 区间结束标识</h2><p>为了标识每次逆置的结束符，我们还需要将待逆置的每一个小区间的末尾都改成<code>nullptr</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将每个区间的末尾节点的next链接为Null作为递归标识</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span>&amp;n:begin_node_prev_v)&#123;</span><br><span class="line">    n-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-5-逆置和重新链接"><a href="#2-5-逆置和重新链接" class="headerlink" title="2.5 逆置和重新链接"></a>2.5 逆置和重新链接</h2><p>上面的步骤都敲定了之后，我们就可以将第一个数组<code>begin_node_v</code>的节点喂给链表逆置函数了，该逆置函数的返回值是新链表的开头。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将每个区间交付给递归开始逆置，并将逆置的返回值与上一个区间的开头连起来</span></span><br><span class="line">cur = &amp;phead;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span>&amp; n:begin_node_v)&#123;</span><br><span class="line">    ListNode* ptr=<span class="built_in">reverseNode</span>(n);</span><br><span class="line">    cur-&gt;next = ptr;</span><br><span class="line">    cur = n;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里说一下cur指针的作用，以用例<code>&#123;1,2,3,4,5&#125;,2</code>为栗子，此时<code>begin_node_v</code>数组中存放的是<code>&#123;1,3,5&#125;</code></p><ul><li>初始化为phead</li><li>第一次循环，n指向的是1，cur指向的是phead；逆置结束后，ptr指向的是2，刚好就是新链表的开头，将cur的next链接为它，并将cur更新为1</li><li>第二次循环，n指向的是3，cur指向的是1；逆置结束后，ptr指向的是4，此时cur的next指向它，就是将1的next链接为4，再次更新cur为3。</li><li>第三次循环，n指向的是5，cur指向的是3；逆置结束后，将3的next链接为5，cur更新为5</li><li>循环结束</li></ul><p>结束时，这个链表就已经完工了！我们只需要判断一下还没有剩下的没有逆置的节点，将其链接给<code>begin_node_v</code>数组中的最后一个节点（也是逆置部分的最后一个节点）的next就可以了</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 判断是否还有剩下的节点</span></span><br><span class="line"><span class="keyword">if</span>(last_link !=<span class="literal">nullptr</span>)&#123;</span><br><span class="line">    begin_node_v[begin_node_v.<span class="built_in">size</span>()<span class="number">-1</span>]-&gt;next = last_link;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="3-完整代码"><a href="#3-完整代码" class="headerlink" title="3.完整代码"></a>3.完整代码</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * @param head ListNode类</span></span><br><span class="line"><span class="comment">     * @param k int整型</span></span><br><span class="line"><span class="comment">     * @return ListNode类</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="comment">// 无差别逆置</span></span><br><span class="line">    <span class="function">ListNode* <span class="title">reverseNode</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="literal">nullptr</span> || head-&gt;next == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ListNode* ans = <span class="built_in">reverseNode</span>(head-&gt;next);</span><br><span class="line">        head-&gt;next-&gt;next = head;</span><br><span class="line">        head-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">cout_vector</span><span class="params">(std::vector&lt;ListNode*&gt;&amp; begin_node_v)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; e : begin_node_v) &#123;</span><br><span class="line">            cout &lt;&lt; e-&gt;val &lt;&lt; <span class="string">&quot; &quot;</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">ListNode* <span class="title">reverseKGroup</span><span class="params">(ListNode* head, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 只有一个节点，或者逆置区间为1的都不需要操作</span></span><br><span class="line">        <span class="keyword">if</span> (head == <span class="literal">nullptr</span> || head-&gt;next == <span class="literal">nullptr</span> || k &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 头节点和遍历指针</span></span><br><span class="line">        <span class="function">ListNode <span class="title">phead</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br><span class="line">        phead.next = head;</span><br><span class="line">        ListNode* cur = &amp;phead;</span><br><span class="line">        <span class="comment">// 把每k个节点单独取出来，分别逆置后链接起来</span></span><br><span class="line">        std::vector&lt;ListNode*&gt; begin_node_v,begin_node_prev_v;</span><br><span class="line">        <span class="type">int</span> index = k<span class="number">-1</span>; <span class="comment">// 初始化为k-1(忽略头节点)，原有链表第一个节点始终入栈</span></span><br><span class="line">        <span class="type">int</span> node_count = <span class="number">0</span>;<span class="comment">// 节点总数（包含头节点）</span></span><br><span class="line">        <span class="keyword">while</span> (cur != <span class="literal">nullptr</span>) &#123; <span class="comment">// 不知道有多长，得死循环</span></span><br><span class="line">            <span class="keyword">if</span>(index+<span class="number">1</span> == k &amp;&amp; cur != &amp;phead)&#123;</span><br><span class="line">                begin_node_prev_v.<span class="built_in">push_back</span>(cur);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (index == k) &#123;</span><br><span class="line">                begin_node_v.<span class="built_in">push_back</span>(cur);</span><br><span class="line">                index = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            cur = cur-&gt;next;</span><br><span class="line">            index++;</span><br><span class="line">            node_count ++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 走到这里已经把每个需要逆置的开头节点给记录下来了</span></span><br><span class="line">        <span class="comment">// 如果节点总数量小于k则不逆置直接返回</span></span><br><span class="line">        node_count --;<span class="comment">//减-1 头节点</span></span><br><span class="line">        <span class="keyword">if</span>(node_count &lt;k)&#123;</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 不是整数倍，代表最后一个是不要处理的</span></span><br><span class="line">        ListNode* last_link = <span class="literal">nullptr</span>; </span><br><span class="line">        <span class="keyword">if</span>((node_count %k) != <span class="number">0</span>) &#123;</span><br><span class="line">            last_link = begin_node_v[begin_node_v.<span class="built_in">size</span>()<span class="number">-1</span>];<span class="comment">// 最后一个</span></span><br><span class="line">            begin_node_v.<span class="built_in">pop_back</span>();<span class="comment">// 删除最后一个</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// cout_vector(begin_node_v);</span></span><br><span class="line">        <span class="comment">// cout_vector(begin_node_prev_v);</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将每个区间的末尾节点的next链接为Null作为递归标识</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span>&amp;n:begin_node_prev_v)&#123;</span><br><span class="line">            n-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 将每个区间交付给递归开始逆置，并将逆置的返回值与上一个区间的开头连起来</span></span><br><span class="line">        cur = &amp;phead;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; n:begin_node_v)&#123;</span><br><span class="line">            ListNode* ptr=<span class="built_in">reverseNode</span>(n);</span><br><span class="line">            cur-&gt;next = ptr;</span><br><span class="line">            cur = n;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 判断是否还有剩下的节点</span></span><br><span class="line">        <span class="keyword">if</span>(last_link !=<span class="literal">nullptr</span>)&#123;</span><br><span class="line">            begin_node_v[begin_node_v.<span class="built_in">size</span>()<span class="number">-1</span>]-&gt;next = last_link;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> phead.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>通过截图</p><p><img src="https://img.musnow.top/i/2023/08/591fcb7e890e13ec8638e0eb567790e9.png" alt="image-20230824142627806"></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;BM3链表中的节点每k个一组翻转&lt;/p&gt;</summary>
    
    
    
    <category term="把题目都给刷干净" scheme="https://blog.musnow.top/categories/%E6%8A%8A%E9%A2%98%E7%9B%AE%E9%83%BD%E7%BB%99%E5%88%B7%E5%B9%B2%E5%87%80/"/>
    
    
    <category term="C++" scheme="https://blog.musnow.top/tags/C/"/>
    
    <category term="OJ刷题" scheme="https://blog.musnow.top/tags/OJ%E5%88%B7%E9%A2%98/"/>
    
    <category term="牛客网" scheme="https://blog.musnow.top/tags/%E7%89%9B%E5%AE%A2%E7%BD%91/"/>
    
  </entry>
  
  <entry>
    <title>【C++】早绑定、析构与多态 | 一道关于多态的选择题记录</title>
    <link href="https://blog.musnow.top/posts/2254346194/"/>
    <id>https://blog.musnow.top/posts/2254346194/</id>
    <published>2023-08-22T13:14:28.000Z</published>
    <updated>2023-08-22T13:14:28.000Z</updated>
    
    <content type="html"><![CDATA[<p>今天在和群友聊天的时候看到了一道很坑的题目，分享给大家</p><span id="more"></span><h1 id="1-看题！"><a href="#1-看题！" class="headerlink" title="1.看题！"></a>1.看题！</h1><p>先来看看题目</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Dad</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Dad</span>()&#123; <span class="built_in">echo</span>();&#125;</span><br><span class="line">    ~<span class="built_in">Dad</span>()&#123; <span class="built_in">echo</span>();&#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">echo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;DAD &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Son</span>:Dad</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">echo</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;SON &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Son ss;</span><br></pre></td></tr></table></figure><p>请问这个的输出是什么？</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">A  &quot;DAD DAD &quot;</span><br><span class="line">B  &quot;DAD SON &quot;</span><br><span class="line">C  &quot;SON DAD &quot;</span><br><span class="line">D  &quot;SON SON &quot;</span><br><span class="line">E  编译出错</span><br><span class="line">F  运行出错</span><br></pre></td></tr></table></figure><blockquote><p>答案是E，编译出错！</p></blockquote><h1 id="2-涉及到的知识点"><a href="#2-涉及到的知识点" class="headerlink" title="2.涉及到的知识点"></a>2.涉及到的知识点</h1><h2 id="2-1-知识点"><a href="#2-1-知识点" class="headerlink" title="2.1 知识点"></a>2.1 知识点</h2><p>先来说说这道题目里面涉及到了什么知识点</p><ul><li>多态调用；</li><li>多态重写函数需要满足什么条件；</li><li>类内函数后加<code>const</code>的作用；</li><li>类内函数后加<code>override</code>的作用；</li><li>什么是早绑定和晚绑定</li></ul><p>一个一个复习吧！</p><ul><li>多态调用是父类指针&#x2F;引用指向子类时，调用虚函数会调用子类重写后的版本</li><li>多态重写函数的条件：函数名&#x2F;参数&#x2F;返回值都必须相同（注意还有协变）</li><li>类内函数后加<code>const</code>修饰的是这个对象的<code>this</code>指针，被修饰的函数中无法修改类内成员变量</li><li>类内函数后加<code>override</code>是让编译器来严格检查是否构成重载</li><li>早绑定：静态绑定；晚绑定：动态绑定（具体请看<a href="https://blog.musnow.top/posts/3933786088/">CPP多态</a>的博客）</li></ul><h2 id="2-2-分析题目"><a href="#2-2-分析题目" class="headerlink" title="2.2 分析题目"></a>2.2 分析题目</h2><p>注意看父类和子类中这两个<code>echo()</code>函数的区别</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">echo</span><span class="params">()</span></span>&#123;&#125;<span class="comment">//父类</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">echo</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">override</span> </span>&#123;&#125;<span class="comment">//子类</span></span><br></pre></td></tr></table></figure><p>首先需要说明的是，子类函数中<code>virtual</code>关键字是可以省略的，但即便省略了，这个函数依旧是个虚函数。</p><p>这里子类的函数中多了<code>const</code>修饰，而这个const修饰的就是函数中隐含的<code>this</code>指针，此时子类中<code>echo()</code>函数的参数就发生了变化！</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">echo</span><span class="params">(Son* <span class="keyword">this</span>)</span> </span>&#123; &#125; <span class="comment">// 不加const</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">echo</span><span class="params">(<span class="type">const</span> Son* <span class="keyword">this</span>)</span> </span>&#123; &#125; <span class="comment">// 加const</span></span><br></pre></td></tr></table></figure><p>正是因为这里的this指针出现了const的修饰，所以子类的echo和父类echo的参数类型不同，不构成虚函数重写！再加上<code>override</code>关键字的严格检查，会直接编译报错！</p><p>正确的写法是删除子类echo中的const或者给父类echo函数加上const</p><h1 id="3-再来看题"><a href="#3-再来看题" class="headerlink" title="3.再来看题"></a>3.再来看题</h1><p>好了，坑人的点看完了，再来看个「常规」的，就是把上面的题干改成能编译通过的。此时又应该选谁呢？</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Dad</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Dad</span>()&#123; <span class="built_in">echo</span>();&#125;</span><br><span class="line">    ~<span class="built_in">Dad</span>()&#123; <span class="built_in">echo</span>();&#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">echo</span><span class="params">()</span> <span class="type">const</span></span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;DAD &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Son</span>:Dad</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">echo</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;SON &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Son ss;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">A  &quot;DAD DAD &quot;</span><br><span class="line">B  &quot;DAD SON &quot;</span><br><span class="line">C  &quot;SON DAD &quot;</span><br><span class="line">D  &quot;SON SON &quot;</span><br></pre></td></tr></table></figure><p><img src="https://img.musnow.top/i/2023/08/e278c7b0a62e7383e4151067de284350.png" alt="image-20230822211806379"></p><p>编译运行，可以看到，结果是<code>DAD DAD</code>，应该选A</p><h2 id="3-1-分析"><a href="#3-1-分析" class="headerlink" title="3.1 分析"></a>3.1 分析</h2><p>在给 <code>Son</code> 类定义构造函数和析构函数时，没有指定调用父类的对应构造函数和析构函数。因此，在创建 <code>Son</code> 对象 <code>ss</code> 时，会默认调用 <code>Dad</code> 类的构造函数和析构函数。</p><p>由于 <code>Dad</code> 类中的构造函数和析构函数调用了虚函数 <code>echo()</code>，而这个虚函数在子类 <code>Son</code> 中被重写，所以会根据对象类型调用相应的重写函数。然而，在构造函数和析构函数中，虚函数机制不会按照预期工作。</p><p>构造函数中调用虚函数时，会忽略动态绑定机制，直接调用父类的函数版本。因此，在 <code>Dad</code> 的构造函数中调用 <code>echo()</code>，实际上调用的是 <code>Dad</code> 类中的 <code>echo()</code> 函数，而不是 <code>Son</code> 类中的重写版本。</p><p>同样地，析构函数中也会忽略动态绑定机制，直接调用父类的函数版本。所以，在 <code>Dad</code> 的析构函数中调用 <code>echo()</code>，依然调用的是 <code>Dad</code> 类中的 <code>echo()</code> 函数。</p><p>因此，当创建 <code>Son</code> 对象 <code>ss</code> 并打印输出时，会先调用 <code>Dad</code> 类的构造函数并打印 <code>&quot;DAD &quot;</code>，然后调用 <code>Dad</code> 类的析构函数并再次打印 <code>&quot;DAD &quot;</code>。</p><h2 id="3-2-结论"><a href="#3-2-结论" class="headerlink" title="3.2 结论"></a>3.2 结论</h2><p>在父类的构造和析构中，对象的版本都被确定为父类的版本，会采用<strong>早绑定</strong>来调用父类自己的函数，而不是子类的重写后的函数；</p><p>简单记忆：父类的构造和析构中如果出现虚函数，只会调用父类自己的函数！</p><hr><p>这是因为编译器需要保证正确的构造和析构顺序，<strong>如果父类析构里调用子类的虚函数</strong>，可能会出现下面的场景</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Dad</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Dad</span>()&#123; <span class="built_in">echo</span>();&#125;</span><br><span class="line">    ~<span class="built_in">Dad</span>()&#123; <span class="built_in">echo</span>();&#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">echo</span><span class="params">()</span> <span class="type">const</span></span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;DAD &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Son</span>:Dad</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Son</span>() &#123;</span><br><span class="line">        _a = <span class="keyword">new</span> <span class="built_in">int</span>(<span class="number">3</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    ~<span class="built_in">Son</span>() &#123;</span><br><span class="line">        <span class="keyword">delete</span> _a;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">echo</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;SON &quot;</span>;</span><br><span class="line">        <span class="keyword">delete</span> _a;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> _a;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Son ss;</span><br></pre></td></tr></table></figure><p>如果父类中的析构<code>echo()</code>调用子类重写的函数，此时就会出现子类已经被销毁（子类的析构函数早于父类析构调用）的<code>_a</code>被二次<code>delete</code>，两次<code>delete</code>同一片空间是会报错的！</p><p>所以为了避免这种情况，父类的析构中采用早绑定，子类重写的虚函数不会生效！</p><p>这种行为是为了确保在对象的构造和析构过程中，<strong>按照正确的顺序调用各个类的构造和析构函数</strong>，避免在对象处于未完全初始化或已部分销毁状态时调用子类的函数。</p><blockquote><p>包括父类的构造也可以这么理解，如果父类构造里面可以调用子类的虚函数，可能会出现两次对一个子类对象进行new空间，会产生内存泄露；</p><p>但构造函数还和虚函数表的初始化有关系，此时虚函数表还没有完全初始化，<strong>子类对象尚未构造完成</strong>，没有多态调用的条件，所以也不能调用到子类重写后的虚函数。</p></blockquote>]]></content>
    
    
    <summary type="html">&lt;p&gt;今天在和群友聊天的时候看到了一道很坑的题目，分享给大家&lt;/p&gt;</summary>
    
    
    
    <category term="把题目都给刷干净" scheme="https://blog.musnow.top/categories/%E6%8A%8A%E9%A2%98%E7%9B%AE%E9%83%BD%E7%BB%99%E5%88%B7%E5%B9%B2%E5%87%80/"/>
    
    
    <category term="C++" scheme="https://blog.musnow.top/tags/C/"/>
    
    <category term="OJ刷题" scheme="https://blog.musnow.top/tags/OJ%E5%88%B7%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>【网络】IP网络层和数据链路层</title>
    <link href="https://blog.musnow.top/posts/3482559497/"/>
    <id>https://blog.musnow.top/posts/3482559497/</id>
    <published>2023-08-21T12:22:36.000Z</published>
    <updated>2023-08-22T04:05:36.000Z</updated>
    
    <content type="html"><![CDATA[<p>IP协议详解</p><span id="more"></span><h1 id="1-概念"><a href="#1-概念" class="headerlink" title="1.概念"></a>1.概念</h1><h2 id="1-1-四层模型"><a href="#1-1-四层模型" class="headerlink" title="1.1 四层模型"></a>1.1 四层模型</h2><ul><li>应用层：解决如何传输数据（依照什么格式&#x2F;协议处理数据）的问题</li><li>传输层：解决可靠性问题</li><li>网络层：数据往哪里传，怎么找到目标主机</li><li>数据链路层（物理层）：数据在物理硬件层面上传输</li></ul><p>网络层的IP协议，就是让网络，拥有将数据从A主机发送到B主机的能力。</p><blockquote><p>注意：拥有此能力，并不代表每次都能成功送达！（即可靠性非100%）</p></blockquote><p>而失败的时候，就需要<strong>传输层</strong>来获取发生错误的原因，并进行错误重传或者超时重传等操作。</p><p>所以，在从网络层获取到信息成功送达到对方的反馈之前，传输层需要暂时保留已经发送的数据。如果网络层发送失败了，传输层需要进行重发操作，以保证可靠性。</p><p><img src="https://img.musnow.top/i/2023/02/2023e40723a2e8f8c6b0662d97d468537cbb.jpeg"></p><h2 id="1-2-主机、路由器、节点"><a href="#1-2-主机、路由器、节点" class="headerlink" title="1.2 主机、路由器、节点"></a>1.2 主机、路由器、节点</h2><ul><li>主机：拥有IP地址，但不进行路由控制的设备</li><li>路由器：拥有IP地址，并进行路由控制的设备</li><li>节点：主机和路由器的统称</li></ul><h1 id="2-IP报文"><a href="#2-IP报文" class="headerlink" title="2.IP报文"></a>2.IP报文</h1><h2 id="2-1-报文结构"><a href="#2-1-报文结构" class="headerlink" title="2.1 报文结构"></a>2.1 报文结构</h2><p>IP协议的报文与TCP的报文有一定程度上的相似</p><p>下图为IPV4中报文的格式（IPV6的报文和下图是不同的）</p><p><img src="https://img.musnow.top/i/2023/07/f93a3878d288a436d0a9f8320202f3c0.png" alt="image-20230724122812011"></p><ul><li>四位版本号：指定IP协议的版本，IPV4来说就是4</li><li>四位首部长度：IP报头的长度（和TCP的定义一样，标准长度需要用<code>四位首部长度 * 4字节</code>，即最大报头长度为<code>15*4=60</code>字节）</li><li>八位服务类型：包含3位优先权字段（已经弃用）、4位TOS字段和1位保留字段（必须置为0）四位TOS分别表示：<strong>最大吞吐量、最高可靠性、最小成本、最小延时</strong>。只能四选一，需要根据具体传输层的协议要求进行选择。</li><li>十六位总长度：包括报头的整个报文的长度，减去四位首部长度就能得出报文中数据字段的长度。</li><li>十六位首部校验和：使用CRC校验来判断报头是否有数据损坏</li><li>八位协议：上层协议类型（比如tcp、udp、ssh等）解决如何向上层交付的问题</li><li>八位生存时间（TTL）：用于控制IP报文能在网络层传输的时间（生命周期的限制）比如有些报文由于路由时出现了错误，陷入了路由的死循环；亦或者是路由程序出现了BUG，导致没办法被正常转发到正确的主机上；还有路由超时的问题。<strong>此时这个出错的报文就会在路由里面长时间游离而没办法抵达目的地</strong>（好比内存泄露）。规定了TTL之后，可以在IP报头中中记录报文的生命周期时间，当报文转发的耗时已经大于这个TTL之后，就将这个报文丢弃。</li><li>三十二位源地址和三十二位位目标地址：表示发送端IP和接收端IP</li><li>选项字段：不定长，最多40字节（这是因为首部默认是20字节，再加上首部长度最多只能表示60个字节，所以选项字段就是 <code>60-20=40</code>）</li><li>此处省略了几个字段，会在后文的<strong>分片</strong>中说明……</li></ul><p>IP协议的报文中没有端口号，因为端口号是<strong>传输层应该解决</strong>的事情（UDP和TCP的报头中才有端口号的字段）IP层只关注如何将报文发送给目标主机。也就是两个主机之间如何正常通信的问题。</p><h2 id="2-2-分片"><a href="#2-2-分片" class="headerlink" title="2.2 分片"></a>2.2 分片</h2><h3 id="2-2-1-认识MTU"><a href="#2-2-1-认识MTU" class="headerlink" title="2.2.1 认识MTU"></a>2.2.1 认识MTU</h3><p>MTU相<span id="jump1">当于</span>发快递时对包裹尺寸的限制，这个限制是不同的<strong>数据链路层</strong>对应的物理层产生的限制。</p><ul><li>以太网帧中的数据长度规定最小46字节，最大1500字节；</li><li>ARP数据包的长度不够46字节。要在后面补填充位；</li><li>最大值1500称为以太网的最大传输单元(MTU)，不同的网络类型有不同的MTU；</li><li>如果一个数据包从以太网路由到拨号链路上，数据包长度大于拨号链路的MTU了，则需要对数据包进行分片(fragmentation)；</li><li>不同的数据链路层标准的MTU是不同的；</li></ul><p>所以，数据链路层不支持过大的数据，这就需要在网络层对数据进行分片。</p><p>而网络层IP协议会<strong>自动</strong>帮我们分片，并在接收端组装。这个行为对传输层来说是不需要关注的，在<strong>四层模型</strong>中，每一层之间的功能需要进行解耦。</p><p>分片之后，只要有一个分片报文丢失，这个报文的整体就会认为丢失了（因为没有办法拼出完整的报文数据）</p><hr><p>但这样就引出了一个问题：<strong>分片会提高丢包的概率</strong>，影响传输速率（发一次快递和发三次快递，明显三次快递丢东西的可能性更高）</p><p>对于具有可靠性机制的TCP而言，丢包问题不大，我们可以在传输层进行重传。但UDP没有可靠性，此时出现分片后丢包了就没办法找回了。</p><p>所以，网络层进行分片并不是主流！相比之下，在传输层就进行分片才是更好的选择。</p><h3 id="2-2-2-如何分片"><a href="#2-2-2-如何分片" class="headerlink" title="2.2.2 如何分片"></a>2.2.2 如何分片</h3><p>在IP报头中，如下字段就是用于分片和组装操作的</p><p><img src="https://img.musnow.top/i/2023/07/4245674fedcf6b9d43b2845083017f26.png" alt="image-20230724185036181"></p><ul><li>十六位标识 (id): 唯一的标识主机发送的报文。如果IP报文在数据链路层被分片了，那么<strong>每一个片里面的这个id都是相同的</strong></li><li>三位标志字段: <ul><li>第一位保留 (保留的意思是现在不用， 但是还没想好说不定以后要用到)。 </li><li>第二位置为1表示“禁止分片”， 这时候如果报文长度超过MTU， IP模块就会丢弃报文。 </li><li>第三位表示”更多分片”， 如果分片了的话， <strong>最后一个分片置为0</strong>， 其他分片报文都是1；<strong>0就类似于一个分片的结束标记</strong></li></ul></li><li>十三位分片偏移 (framegament offset): 是分片相对于原始IP报文开始处的偏移。 其实就是在表示当前分片在原报文中处在哪个位置。实际偏移的字节数是这个值 <code>* 8 </code>得到的。因此， 除了最后一个报文之外， <strong>其他报文的长度必须是8的整数倍</strong> (否则报文就不连续了)</li></ul><p>此时，只要将三位标志字段中的<code>更多分片</code>置为1，就代表当前报文并不是一个完整的报文，而是已经被分片后的报文。</p><blockquote><ul><li>更多分片为0，且分片偏移为0，代表当前报文没有进行分片；</li><li>更多分片为1，且分片偏移为0，代表当前是分片后报文中的第一个；</li><li>更多分片为0，且分片偏移<strong>不为0</strong>，代表当前是分片报文中的最后一个；</li></ul></blockquote><p>此时就需要根据十六位标识来确定当前分片属于哪一个“组”，再将当前报文和后续收到的ID相同的报文集合在一起，通过十三位片偏移来进行排序，组装成完整数据！</p><p>比如，第一个报文的起始偏移量是0，第二个是1000，第三个是2000，这时候就根据片偏移排序进行拼接就可以了。（这只是个栗子）</p><ul><li>如何保证收完了？</li></ul><p>根据十六位标识，按照片偏移进行排序，排序后发现缺失了部分的报文，那就代表没有被收完。因为每一个报文的<code>偏移量+该报文长度</code>，就是下一个报文的<code>偏移量</code>！只要数据对不上，那就代表丢东西了。</p><p>而开头和结尾的报文，就能通过上面提到的根据<code>更多分片标记位+分片偏移</code>来确定有没有丢。</p><h3 id="2-2-3-如何减少分片"><a href="#2-2-3-如何减少分片" class="headerlink" title="2.2.3 如何减少分片"></a>2.2.3 如何减少分片</h3><p>虽然说IP网络层会自动帮我们分片，但是否分片是<strong>可以通过传输层</strong>来进行控制的</p><p>只要传输层一次交付的数据没有超过需要分片的阈值，那网络层在传输的时候就不会进行分片了！</p><p>减少分片的方式，那就是在传输层就进行一定的分片，这样能更好将<code>丢分片报文</code>这件事在传输层进行处理。而不是在网络层丢包后，没办法在传输层失败并处理。</p><hr><h4 id="传输层进行限制"><a href="#传输层进行限制" class="headerlink" title="传输层进行限制"></a>传输层进行限制</h4><p>如果是TCP协议，在三次握手的时候，就会协商双方单词传输数据的大小。从而避免网络层对数据进行分片，以规避数据链路层的MTU限制。同时也维护了滑动窗口，如果网络层的传输出现了丢包，由传输层来进行重传操作，以实现可靠传输。</p><ul><li>限制成多少好呢？</li></ul><p>一般建议将该大小设置为比网络中的最小MTU值小一些，以防止出现分片</p><blockquote><p>后续会补上更多信息</p></blockquote><h3 id="2-2-4-分片的限制"><a href="#2-2-4-分片的限制" class="headerlink" title="2.2.4 分片的限制"></a>2.2.4 分片的限制</h3><p>在上文中提到，MTU的限制是最大1500字节，这个数据长度是包含IP协议的报头的（数据是从IP网络层向下交付给数据链路层的）</p><p>假设我们有一个<strong>网络层的3000字节</strong>的数据，此时网络层要进行分片，并不是简单的<code>3000/1500=2</code>就能搞定了的。而是要计算上IP报头的长度（20字节）</p><p>每一个分片都是一个独立的IP报文，都会有自己独立的IP报头！否则缺少报头，在接收端没有办法进行数据组装操作。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">20+1480</span><br><span class="line">20+1480</span><br><span class="line">20+20</span><br></pre></td></tr></table></figure><p>一共需要分3片，才能将这网络层的3000字节的数据成功传输！</p><p>但是这里就有一个问题了，明明<code>1480+1480+20 = 2980</code>，并不是3000字节啊？</p><p>注意！上面提到的是网络层的3000字节数据。实际上，<strong>传输层只向下交付了2980字节</strong>，加上IP报头20字节才是<strong>网络层的3000字节</strong>数据。因为要进行分片，原本这3000字节的统一报头肯定是要丢弃的，我们需要操作的是传输层向下交付的<code>2980</code>字节数据，将其正确分片并添加上每一个分片的报头，再交给数据链路层。</p><h2 id="2-3-TTL"><a href="#2-3-TTL" class="headerlink" title="2.3 TTL"></a>2.3 TTL</h2><p>上文提到TTL是用来控制报文的生命周期的，其为了避免报文在路由中出现<strong>死循环</strong>。</p><p>比如下图中，假设有一个报文路由到了路由器D，原本他应该被正常交付给主机C，但路由器D出现了一些问题，将这个报文交付给了路由器I，路由器I给J，J给H，H给C，路由器C又给D，路由器D还是有bug，又转发给了路由器I。</p><p>这时候，就出现了一个报文路由的死循环。</p><p>如果没有TTL来控制生命周期，报文就会一直在这个死循环中跑，白白浪费路由器的性能！</p><p><img src="https://img.musnow.top/i/2023/07/cfb3fb1c0b8d2c1d8ae655d17a5e3fef.png" alt="image-20230726201220852"></p><p>规定了TTL之后，当报文的生命周期已经到了，但却还没有发送到目的地，那就需要将这个报文丢弃了。（即超了TTL的时间就认为报文无效）</p><h1 id="3-网段划分"><a href="#3-网段划分" class="headerlink" title="3.网段划分"></a>3.网段划分</h1><h2 id="3-1-IP如何找到对方主机？"><a href="#3-1-IP如何找到对方主机？" class="headerlink" title="3.1 IP如何找到对方主机？"></a>3.1 IP如何找到对方主机？</h2><p>IP如何找到对方主机呢？</p><ul><li>IP &#x3D; 目的网络 + 目的主机</li><li>由此还衍生出网段划分</li></ul><p>以IPV4的ip为例，其格式为<code>1.1.1.1</code>，可以认为是下面的划分</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1.1.1  .1</span><br><span class="line">网段   .主机</span><br></pre></td></tr></table></figure><p>这就好比你的学号，前X位里面是学院的代码，最后才是班级+班级内编号。先找到你所在学院，再找到班级，最后再找到你。</p><p>反馈到IP里面，就是先找到网段，再找到主机。</p><h3 id="3-1-1-发送数据的本质"><a href="#3-1-1-发送数据的本质" class="headerlink" title="3.1.1 发送数据的本质"></a>3.1.1 发送数据的本质</h3><p>IP就是先找到目的的<strong>网段</strong>，再找这个网段中的目的<strong>主机</strong>。（先根据目的网段进行路由，找到目的网络，再通过主机号找到目的主机）</p><p>而查找目的主机的过程，本质是一个<strong>排除</strong>的过程。</p><p>先通过网段排除一个大类，再通过主机号来排除该网段中的单个主机。这样就能避免我们<strong>一个一个遍历</strong>在全网中查找主机，<strong>提高了查找的效率</strong></p><blockquote><p>子网划分的目的：就是提高查找目标主机的效率</p></blockquote><p>这也是学校里面用学号的原因，除了为了给每个学生提供一个唯一标识，还能通过学号来提高查找到某一个学生的效率。</p><p>在全球互联网上，同样是通过IP地址的网段来划分国家，再划分到每个国家内部的不同区。这时候就会有一定IP地址资源的竞争。比如米国互联网发展早，下图中谷歌的服务器IP就老整齐了😂（不过这些服务器都在同一个地域，IP很接近是合理的）</p><p><img src="https://img.musnow.top/i/2023/07/5b872ab28b7ae44e7b57d513874d395c.png" alt="image-20230726132920408"></p><h3 id="3-1-2-网络号和主机号"><a href="#3-1-2-网络号和主机号" class="headerlink" title="3.1.2 网络号和主机号"></a>3.1.2 网络号和主机号</h3><ul><li>网络号：保证相互连接的两个网段具有不同的标识</li><li>主机号：在同一网段中，主机之间具有相同的网络号，但是主机号不同以进行区分</li></ul><p>具体框架可以查看下图，<code>192.168.128</code>就是这个局域网的网段 ，而最后的10和11是不同主机的两个主机标识。一般情况下，网段中的<code>1</code>号主机就是这个网段中的路由器。</p><blockquote><p>我们家里的路由器除了进行路由转发，还有子网划分的功能。</p></blockquote><p>如果出现了一个开头并非<code>192.168.128</code>的IP，主机就能知道这不是当前局域网的IP，于是就会将报文直接转发给<code>192.168.128.1</code>，让路由器去找这个IP的目标主机（进行跨局域网的下一层转发）</p><p><img src="https://img.musnow.top/i/2023/07/92a09c99e1a35e35157cd259802c2b75.jpeg" alt="img"></p><p>就好比我们的学号是学校的教务系统派发给每一位同学的，IP中的网段也被“某人”在一定程度上根据地区进行了划分。</p><h2 id="3-2-IP地址类别划分"><a href="#3-2-IP地址类别划分" class="headerlink" title="3.2 IP地址类别划分"></a>3.2 IP地址类别划分</h2><h3 id="3-2-1-ABCDE"><a href="#3-2-1-ABCDE" class="headerlink" title="3.2.1 ABCDE"></a>3.2.1 ABCDE</h3><p>通过A到E类不同的划分，会衍生出不同范围的IP号，然后再分配给不同的国家或地区</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">A类 0.0.0.0到127.255.255.255 </span><br><span class="line">B类 128.0.0.0到191.255.255.255 </span><br><span class="line">C类 192.0.0.0到223.255.255.255 </span><br><span class="line">D类 224.0.0.0到239.255.255.255 </span><br><span class="line">E类 240.0.0.0到247.255.255.255</span><br></pre></td></tr></table></figure><p><img src="https://img.musnow.top/i/2023/07/f3248796ffe4f8989ee68b52f3b2f7d7.png" alt="image-20230726110410094"></p><p>依照上面的划分，如果我是一个大型企业，申请了一个B类的IP地址。此时就能支持我的局域网内<code>2^16</code>台主机的ip分配。但实际上我顶多会有2w个主机，此时就出现了IP地址的浪费！</p><h3 id="3-2-2-CIDR和子网掩码"><a href="#3-2-2-CIDR和子网掩码" class="headerlink" title="3.2.2 CIDR和子网掩码"></a>3.2.2 CIDR和子网掩码</h3><p>为了避免上文中出现的IP浪费问题，CIDR（Classless Interdomain Routing）就出现了</p><ul><li>引入一个额外的子网掩码(subnet mask)来区分网络号和主机号；</li><li>子网掩码也是一个32位的正整数. 通常用一串 <code>0</code> 来结尾，一串 <code>1</code> 开头；</li><li>将IP地址和子网掩码进行 <strong>按位与</strong> 操作, 得到的结果就是网络号；</li><li>网络号和主机号的划分与这个IP地址是A类、B类还是C类<strong>无关</strong></li></ul><p>如果我们需要更多主机，就可以将子网掩码中最后一个1置0，就能适配更多局域网主机。</p><p>所以，现在已经不用<code>ABCDE</code>的类别划分方式了，都采用了<strong>子网掩码</strong>方式。</p><p><img src="https://img.musnow.top/i/2023/07/06b71c71fe5cee4bfd70781717f7f031.png" alt="image-20230726133558191"></p><p>根据上图可见，IP地址与子网掩码做与运算可以得到网络号，<strong>主机号</strong>的二进制位从全0到全1就是子网的地址范围； </p><p>IP地址和子网掩码还有一种更简洁的表示方法：例如<code>140.252.20.68/24</code>,表示IP地址为<code>140.252.20.68</code>, 子网掩码的<strong>高24位是1</strong>，也就是子网掩码<code>255.255.255.0</code></p><h2 id="3-3-基础设施"><a href="#3-3-基础设施" class="headerlink" title="3.3 基础设施"></a>3.3 基础设施</h2><p>有了网段划分，给不同国家和地区划分了IP之后，就需要有人来建设网络的<code>基础设施</code></p><p>在我们国家，搞基础设施就是三大运营商（移动 电信 联通）</p><p>比如几年前做的“光纤入户”就是基础设施建设的一部分。</p><p>基础设施搭建好了后，再通过子网掩码和已经获取到的IP的网段来划分不同省份、不同市区；最终再落到每个入网用户的头上。</p><h2 id="3-4-缓解IP地址不够用的办法"><a href="#3-4-缓解IP地址不够用的办法" class="headerlink" title="3.4 缓解IP地址不够用的办法"></a>3.4 缓解IP地址不够用的办法</h2><p>有人肯定会问了，现在公网IPV4的资源那么匮乏，大部分家宽都是没有公网ip的，那我们平时的上网是怎么实现的？</p><p>换句话说，如何缓解IP地址的匮乏？</p><ul><li>可以使用<code>动态IP分配</code>技术，只给直接接入公网的设备分配IP地址，每一个设备接入网络时，其获取到的IP地址不一定和上次相同。</li><li>NAT技术（重点）</li><li>IPV6（但是现在普及率有待提高）</li></ul><p>IPV6使用16字节（128位）来标识一个IP地址，目前看来，<code>2^128</code> 位能给“地球上每一粒沙子”都分配一个IP地址了。虽然迟早也会有不够用的那一天，但至少是一个很不错的解决方案。我们国家就在大力推广IPV6</p><p>通过前文的报文结构图可知，IPV4的IP地址只有4字节（32位）</p><hr><h1 id="4-私有IP"><a href="#4-私有IP" class="headerlink" title="4.私有IP"></a>4.私有IP</h1><h2 id="4-1-特殊的IP地址"><a href="#4-1-特殊的IP地址" class="headerlink" title="4.1 特殊的IP地址"></a>4.1 特殊的IP地址</h2><p>但是，直接采用CIDR的方式作为局域网控制的方式，就容易出现混乱。而且即便是采用了子网掩码的方式，依旧可能出现IP不够用的情况（一位网民很可能有多个设备， 再加上各类智能终端，现在需要上网的设备只会越来越多）</p><p>需要注意的是CIDR只能提高IP地址的利用率，并不能提高IP地址的上限。</p><p>所以，就衍生出了部分特殊的IP地址。这些IP地址被规定<strong>只能用于局域网</strong>，由此来减少对公网IP的地址消耗。</p><ul><li>将IP地址中的主机地址全设为0，就是该地址的网络号，代表当前局域网</li><li>将IP地址中的主机地址全设为1，就是广播地址，用于给同一个链路中相互连接的所有主机发送数据包。</li><li><code>127.*</code>的IP地址用于<strong>本机回环</strong>。我们通常使用<code>127.0.0.1</code>来进行本地服务的访问和测试，该IP地址是IPv4回环地址的标准规定，IPv6的回环地址为<code>::1</code>。</li></ul><p>我们在计算一个局域网中有多少设备的时候，需要减掉上文提到的网络号和广播地址。</p><hr><p>以下是特殊的只能用于局域网的私有IP地址，包含在这个范围中的， 都称为私有IP， 其余的则称为全局IP (或公网IP)</p><ul><li><code>10.*</code>, 前8位是网络号，共<code>16,777,216</code>个地址 </li><li><code>172.16.</code>到<code>172.31.</code>，前12位是网络号，共<code>1,048,576</code>个地址 </li><li><code>192.168.*</code>，前16位是网络号，共<code>65,536</code>个地址</li></ul><p>这里要记住2的16次方为<code>65536</code>，在网络的知识点里面经常会接触到这个数字。</p><h2 id="4-2-loopback环回"><a href="#4-2-loopback环回" class="headerlink" title="4.2 loopback环回"></a>4.2 loopback环回</h2><p>上文提到了<code>127.*</code>是用于本地环回的。下图是环回驱动程序针对IP地址的判断</p><p><img src="https://img.musnow.top/i/2023/07/94236a76f61d44ff8b9d1b6b0150aa79.jpeg" alt="img"></p><p>在云服务器上执行<code>ifconfig</code>，也能看到本地环回的配置项；这里我们能发现，本地环回的MTU是远高于网络的1500。毕竟是自己和自己通信，基本不会出现丢包，传输速度也是飞快，也就不用担心数据包太大的问题</p><p>同时也能发现，我们的云服务器被分配到的ip地址并不是云服务器的公网ip，这也就表明了我们的云服务器并没有被直接暴露在公网上，而是通过了云服务器厂家的入网服务器（或者也叫路由器）来进行公网ip的映射和数据包的转发操作。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">eth0: flags=4163&lt;UP,BROADCAST,RUNNING,MULTICAST&gt;  mtu 1500</span><br><span class="line">        inet 10.0.12.2  netmask 255.255.252.0  broadcast 10.0.15.255</span><br><span class="line">        inet6 fe80::5054:ff:fec9:274f  prefixlen 64  scopeid 0x20&lt;link&gt;</span><br><span class="line">        ether 52:54:00:c9:27:4f  txqueuelen 1000  (Ethernet)</span><br><span class="line">        RX packets 277674393  bytes 80031748700 (74.5 GiB)</span><br><span class="line">        RX errors 0  dropped 0  overruns 0  frame 0</span><br><span class="line">        TX packets 302405663  bytes 162670581730 (151.4 GiB)</span><br><span class="line">        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0</span><br><span class="line"></span><br><span class="line">lo: flags=73&lt;UP,LOOPBACK,RUNNING&gt;  mtu 65536</span><br><span class="line">        inet 127.0.0.1  netmask 255.0.0.0</span><br><span class="line">        inet6 ::1  prefixlen 128  scopeid 0x10&lt;host&gt;</span><br><span class="line">        loop  txqueuelen 1000  (Local Loopback)</span><br><span class="line">        RX packets 111135687  bytes 27644436547 (25.7 GiB)</span><br><span class="line">        RX errors 0  dropped 0  overruns 0  frame 0</span><br><span class="line">        TX packets 111135687  bytes 27644436547 (25.7 GiB)</span><br><span class="line">        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0</span><br></pre></td></tr></table></figure><h3 id="4-2-1-环回"><a href="#4-2-1-环回" class="headerlink" title="4.2.1 环回"></a>4.2.1 环回</h3><p>上图中的环回驱动程序会直接和IP协议的接收端（即IP输入函数）相连，当检测到 <code>127.0.0.1</code> 的IP访问请求的时候，会直接把这个报文转发给IP输入函数，而不将其插入到以太网中。</p><p>就相当于你知道 <code>127.0.0.1</code> 这个IP地址代表的就是你自己，你想访问自己电脑上8080端口的程序，即便么有接入互联网的状况下也是能正常访问的！</p><p>Loopback环回接口对于<strong>测试和诊断本地主机上的网络服务和应用程序</strong>非常有用，因为它可以模拟网络通信而不涉及实际的网络传输。</p><h3 id="4-2-2-ARP"><a href="#4-2-2-ARP" class="headerlink" title="4.2.2 ARP"></a>4.2.2 ARP</h3><p>ARP是一个在局域网数据链路层通过IP获取到局域网主机MAC地址的协议，具体请参考后文中的解析</p><hr><h2 id="4-3-访问广域网的步骤"><a href="#4-3-访问广域网的步骤" class="headerlink" title="4.3 访问广域网的步骤"></a>4.3 访问广域网的步骤</h2><h3 id="4-3-1-说明"><a href="#4-3-1-说明" class="headerlink" title="4.3.1 说明"></a>4.3.1 说明</h3><p>下图中能看到我们家用主机是怎么来进行广域网的访问的基本流程；</p><p>我们家里的路由器除了进行路由转发，还有子网划分的功能。可以看到左下角虽然是两个不同的家庭，但其可以分配出完全一样的局域网的子网ip <code>192.168.1.1</code>，和不同的WAN口IP（WAN口就是路由器连接互联网的口）</p><p>这是因为我们的设备是直接和<strong>当前路由器</strong>相连的，访问的时候也只能通过<strong>当前路由器</strong>来进行局域网IP的转发。不可能会出现我访问一个局域网IP，却跑到了别人家里的设备上的情况。因为这个局域网IP访问的报文并不会被转发到上层路由器上，也就不可能凭空飞到其他局域网中</p><p><img src="https://img.musnow.top/i/2023/07/1a3192c168e559aee56371f85945c32b.png" alt="image-20230726185645407"></p><p>图中的 <code>122.77.241.3</code> 就是一个公网IP的服务器，当我们需要访问这个主机的时候，局域网的家用路由器在检测到这个目的IP的时候，发现其并不是局域网的IP地址，于是就会将这个报文给转发给上层的运营商路由器。</p><p>运营商路由器是直接接入了公网IP的，其就能通过<code>网段划分+主机编号</code>来查找目标主机，将报文转发给 <code>122.77.241.3</code>  服务器，再将服务器返回的信息转发给你的家用路由器，再转发到你的主机上。</p><p>这也告诉我们，想绕过运营商直接获得公网IP是不可能的，因为从<strong>物理层面上</strong>，我们的家用路由器就不是接在公网IP上的！即便是可以申请到的家用公网IP，也和云服务器的入网服务器一样，是运营商的路由器分配给你的。</p><blockquote><p>你会发现，家用申请的公网ip，很多端口都是被屏蔽的（比如 <code>80/443/8080</code>）这些端口的屏蔽操作，以及海外网站的「墙」也是运营商的路由器进行检测和屏蔽的！</p></blockquote><h3 id="4-3-2-内网访问公网的流程"><a href="#4-3-2-内网访问公网的流程" class="headerlink" title="4.3.2 内网访问公网的流程"></a>4.3.2 内网访问公网的流程</h3><p>假设我们的模型如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">广域网</span><br><span class="line">  ↓</span><br><span class="line">运营商路由器C （公网IP是122.77.241.4）</span><br><span class="line">  ↓</span><br><span class="line">家用路由器B （运营商路由器分配私有IP 10.1.1.2）</span><br><span class="line">  ↓</span><br><span class="line">家用主机A （家用路由器分配私有IP 192.168.1.201）</span><br></pre></td></tr></table></figure><p>下面是一个家用主机A，访问公网IP的主机 <code>122.77.241.10</code> 的具体步骤；</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">本地主机A发送IP报文给家庭路由器B</span><br><span class="line">————————————————————————</span><br><span class="line">| 源IP：192.168.1.201   |</span><br><span class="line">| 目的IP：122.77.241.10 |</span><br><span class="line">————————————————————————</span><br><span class="line"></span><br><span class="line">路由器B收到报文后，检测目的IP，发现并不似局域网的IP</span><br><span class="line">于是交付给上层的运营商路由器C；</span><br><span class="line">报文的源IP被修改为家用路由器B的wan口IP</span><br><span class="line">————————————————————————</span><br><span class="line">| 源IP：10.1.1.2        |</span><br><span class="line">| 目的IP：122.77.241.10 |</span><br><span class="line">————————————————————————</span><br><span class="line"></span><br><span class="line">运营商路由器C收到报文后，发现其也不是自己所在内网 10.1.1.* 的局域网IP</span><br><span class="line">于是开始执行广域网IP寻址操作，找到目标公网IP的主机，再将报文发送给该主机；</span><br><span class="line">此时发送的报文又被改成了</span><br><span class="line">————————————————————————</span><br><span class="line">| 源IP：122.77.241.4    |</span><br><span class="line">| 目的IP：122.77.241.10 |</span><br><span class="line">————————————————————————</span><br></pre></td></tr></table></figure><h3 id="4-3-3-NAT技术"><a href="#4-3-3-NAT技术" class="headerlink" title="4.3.3 NAT技术"></a>4.3.3 NAT技术</h3><p>这种不断替换源IP来进行路由转发的过程，就是<strong>NAT技术</strong>！</p><p>也正是NAT技术的存在，让我们能通过多级局域网来让更多的设备上网，大大缓解了公网IP的不足。</p><p>也正是因为IPV4地址不足的问题被大大缓解，推广IPV6就没有我们想象中的那么顺利了。毕竟IPV6的IP格式和V4完全不同，需要每个层级的路由器都进行功能升级，这可是一个巨大的工程！</p><p><img src="https://img.musnow.top/i/2023/08/18a4c496be6f375256a5563b7ff537a2.png" alt="image-20230822092804992"></p><h3 id="4-3-4-NAT怎么回来？NAPT"><a href="#4-3-4-NAT怎么回来？NAPT" class="headerlink" title="4.3.4 NAT怎么回来？NAPT"></a>4.3.4 NAT怎么回来？NAPT</h3><p>当目标主机收到这个报文后，他的反馈报文如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">————————————————————————</span><br><span class="line">| 源IP：122.77.241.10   |</span><br><span class="line">| 目的IP：122.77.241.4  |</span><br><span class="line">————————————————————————</span><br></pre></td></tr></table></figure><p>同样是先到达运营商路由器，运营商路由器需要缓存每一个转发到公网的报文的来源信息；为此路由器会维护一个<strong>转换表</strong>，记录着局域网主机的<code>私有IP地址:端口号</code>与对应的<code>公网IP地址:NAT端口号</code>的映射关系。</p><p>比如此次TCP链接中，我将路由器公网IP的<code>122.77.241.4:30000</code>映射给了局域网<code>10.1.1.2:40000</code>；当从公网收到服务器的响应报文后，从<strong>转换表</strong>里面就能够查到这个映射（一次通信中这个NAT映射是不会变的）从而确定该报文的局域网流向。</p><blockquote><p>需要注意的是，NAT技术在端口映射的时候不一定会映射到和内网主机相同的端口，此时不仅需要修改IP报文中的来源IP，还需要进一步修改传输层（比如TCP和UDP）中的源端口号</p></blockquote><p>确定局域网IP后，就修改当前报文的目的IP，继续往局域网转发；后面的子路由器也是如此，不再赘述。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">————————————————————————</span><br><span class="line">| 源IP：122.77.241.10   |</span><br><span class="line">| 目的IP：10.1.1.2      |</span><br><span class="line">————————————————————————</span><br></pre></td></tr></table></figure><p>这种<code>IP:端口</code>的关联关系表，就是由支持NAT技术的路由器来维护的，这个转换表被称为<strong>NAPT</strong>；当这次链接结束后，这对映射关系就会从转换表中被删除。</p><p><img src="https://img.musnow.top/i/2023/08/b1d4032e4d2cfd4fad023cbd0ad0f6d8.png" alt="image-20230822093121691"></p><h3 id="4-3-5-NAT和代理服务器"><a href="#4-3-5-NAT和代理服务器" class="headerlink" title="4.3.5 NAT和代理服务器"></a>4.3.5 NAT和代理服务器</h3><p>代理服务器看上去和NAT设备有一定类似，客户端向代理服务器发送请求，代理服务器将请求转发给真正需要请求的服务器；服务器返回结果后，代理服务器把结果传回客户端。</p><h4 id="4-3-5-1-NAT和代理服务器的区别？"><a href="#4-3-5-1-NAT和代理服务器的区别？" class="headerlink" title="4.3.5.1 NAT和代理服务器的区别？"></a>4.3.5.1 NAT和代理服务器的区别？</h4><ul><li>从应用来说，NAT是属于网络基础设置，解决的是公网IP不足的问题；代理服务器更贴近具体应用，比如通过代理服务器进行“翻墙”和游戏加速；</li><li>从底层来讲，NAT在网络层工作，对IP地址进行替换；代理服务器是在应用层工作；</li><li>从使用范围来讲，NAT一般部署在局域网出口，代理服务器既可以在局域网又可以在广域网部署</li><li>从部署位置来看，NAT集成在路由器或者防火墙的硬件上；代理服务器本质上是一个应用层软件，部署在服务器上</li></ul><p>代理服务器应用相对来说也比较广</p><ul><li>翻墙：广域网代理</li><li>负载均衡：局域网代理</li></ul><h4 id="4-3-5-2-反向代理"><a href="#4-3-5-2-反向代理" class="headerlink" title="4.3.5.2 反向代理"></a>4.3.5.2 反向代理</h4><p>代理服务器分为正向代理和反向代理，这里来说说<strong>反向代理</strong>，反向代理处于目标服务器和客户端之间，客户端通过反向代理访问目标服务器，而不会直接连接到目标服务器</p><ul><li>通过反向代理服务器作为一个云服务器主机集群的入网服务器</li><li>举例，一个网站拥有10台提供服务的服务器和一台反向代理服务器</li><li>域名解析到反向代理服务器</li><li>反向代理服务器通过服务器监控程序，获取到10台服务器中负载最低的那个，并将报文转发给它</li><li>反向代理服务器还会识别10台服务器中是否有宕机的服务器，如果有，则会告警给维护人员，并不再给这个宕机的服务器转发报文</li><li>反向代理服务器还可以设置黑白名单，当遇到DDOS攻击的时候，将来源IP放入黑名单进行屏蔽，避免过多的访问让所有服务器都宕机影响业务；将本公司的其他服务器放入白名单（一般白名单都很短）</li></ul><p>反向代理的作用</p><ul><li>通过反向代理服务器实现了<strong>负载均衡</strong></li><li>便于<strong>统一管理</strong>服务器集群，提供统一入网服务器</li><li>避免了直接将提供服务的主机IP暴露在公网上而被直接攻击的问题，提高了<strong>安全性</strong>。</li><li>反向代理还能对网页内容进行一定的<strong>缓存</strong>，从而减轻后端服务器的负担（比如缓存网页前端的静态资源，当用户访问的时候，由代理服务器直接返回资源，而不需要去请求实际提供服务的服务器）</li></ul><p>总之好处多多！</p><h4 id="4-3-5-3-正向代理"><a href="#4-3-5-3-正向代理" class="headerlink" title="4.3.5.3 正向代理"></a>4.3.5.3 正向代理</h4><p>正向代理是位于客户端和目标服务器之间的中间服务器。客户端通过正向代理来访问互联网上的资源，而不是直接连接到目标服务器。正向代理的作用主要有以下几点：</p><ol><li><strong>访问控制和过滤：</strong> 正向代理可以用于限制用户访问特定网站或资源，以实施访问控制策略。它可以过滤不良内容，提供更好的安全性和隐私保护。</li><li><strong>隐藏客户端身份：</strong> 正向代理可以隐藏客户端的真实 IP 地址，从而保护用户的隐私和匿名性。目标服务器只能看到代理服务器的 IP 地址，而无法获取到真正的客户端信息。</li><li><strong>缓存和加速：</strong> 正向代理服务器可以缓存常用的内容，从而减少对目标服务器的请求，提高访问速度。</li><li><strong>突破防火墙限制：</strong> 在一些网络环境中，访问特定网站可能受到限制或封锁。使用正向代理可以绕过这些限制，访问被封锁的资源。</li></ol><h2 id="4-4-ISP检测宽带账户"><a href="#4-4-ISP检测宽带账户" class="headerlink" title="4.4 ISP检测宽带账户"></a>4.4 ISP检测宽带账户</h2><blockquote><p>下文中的部分内容来自chatgpt，我对里面的内容进行了补充和修改</p></blockquote><p>运营商的路由器还会检测我们的账户是否还有余额。我们的家用路由器一般是通过光猫登录了自己的宽带账户；也可以将光猫设置成桥接模式，<strong>将接入光猫的路由器设置为宽带帐号（PPPoE）上网方式</strong>，登录运营商提供的宽带账户和密码，来接入网络。</p><p>ISP的路由器检测你的宽带账户通常是通过以下步骤来完成的：</p><ol><li><strong>设备连接与识别：</strong> 当你的计算机或其他网络设备连接到ISP提供的路由器时，路由器会分配一个私有IP地址给你的设备。这个IP地址是由路由器动态分配的，并且通常处于特定的私有IP地址范围，比如<code>10.11.1.0/16</code>或<code>10.11.1.0/24</code>等。此时，你的设备与路由器建立了一个<em>大局域网</em>内的连接。（运营商并不会直接给你分配<code>192.168.*</code>这样的私有IP，因为这个IP一般是用于<strong>最底层局域网</strong>的，给你分配了，那家庭局域网的就没IP用了）</li><li><strong>认证过程：</strong> 在你尝试访问互联网时，ISP的路由器会引导你的设备进行认证过程。这通常涉及向ISP服务器发送你的宽带账户的登录凭据（例如，用户名和密码）。</li><li><strong>账户验证：</strong> ISP的服务器会验证你提供的登录凭据是否与其记录中的账户匹配。如果验证成功，说明你的宽带账户是有效的，路由器会为你的设备分配一个公共IP地址，这个IP地址是可供互联网访问的。</li><li><strong>IP地址分配：</strong> 一旦认证成功，ISP的路由器会为你的设备分配一个公共IP地址。这个IP地址是在互联网上唯一标识你的设备的地址，使你的设备可以与其他互联网设备进行通信。</li><li><strong>数据传输：</strong> 一旦有了公共IP地址，你的设备就可以与互联网上的其他设备进行通信，发送和接收数据。</li></ol><p>这样，通过认证和IP地址分配的过程，ISP的路由器可以检测并识别你的宽带账户，从而让你的设备能够访问互联网。</p><p>人话就是，<strong>登录了宽带账户</strong>以后，当我们路由器发送的报文交付到运营商路由器的时候，该路由器就会检测你这个宽带账户的余额。如果没有余额了，就会直接丢弃掉你的IP报文。我们看到的结果就是无法上网！</p><blockquote><p>这个操作并不是每次都会执行的，只要你的路由器能稳定的接入到运营商的路由器上，那就不会每次都进行宽带账户的验证，否则会增加网络的负担。</p><p>具体的验证流程都是运营商路由器和你的本地光猫自动完成的。</p></blockquote><p>而手机没有话费余额的时候，我们依旧能拨通诸如120、119等紧急号码，这也是运营商的服务对这些特殊的电话号码做了类似于<code>免费白名单</code>的操作（手机号码可以类比公网IP来理解）</p><h1 id="5-域名"><a href="#5-域名" class="headerlink" title="5.域名"></a>5.域名</h1><h2 id="5-1-DNS服务器"><a href="#5-1-DNS服务器" class="headerlink" title="5.1 DNS服务器"></a>5.1 DNS服务器</h2><p>上文讲述的都是关于IP协议的事情。但实际上我们日常生活中，一般都不会直接使用IP地址+端口号的方式来访问某一个服务，而是使用域名来访问。比如</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">www.baidu.com</span><br><span class="line">www.google.com</span><br></pre></td></tr></table></figure><p>所谓域名，就是这些<strong>英文字符串</strong>和IP的映射。</p><p>比如<code>baidu.com</code>就是一个域名，而<code>www.baidu.com</code>是该域名下的三级域名（几级域名可以看有几个点）</p><p>实际访问的时候，是百度在域名注册商哪里，将<code>www.baidu.com</code>指向了自己的服务器的地址(假设指向的是<code>1.1.1.1</code>) 我们访问百度，实际上访问的就是 IP地址 <code>1.1.1.1</code>；</p><ul><li>DNS是应用层协议，底层使用的是UDP</li><li>系统会缓存一部分DNS的结果</li></ul><p>在主机本地，有一个<code>hosts</code>文件，也可以用于设置主机到域名的映射，在linux里面就是<code>/etc/hosts</code>这个文件。 在访问域名的时候，操作系统会先检查自己本机器的hosts，如果本地没有，就请求DNS服务器来获取解析结果。</p><h2 id="5-2-域名访问主机流程"><a href="#5-2-域名访问主机流程" class="headerlink" title="5.2 域名访问主机流程"></a>5.2 域名访问主机流程</h2><p>当我们访问一个域名的时候，首先会去请求特殊的DNS服务器</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">8.8.8.8 谷歌公司的DNS服务器</span><br><span class="line">119.29.29.29 腾讯提供的公共DNS</span><br></pre></td></tr></table></figure><p>先请求这些DNS服务器，服务器内会针对域名查询对应的DNS解析，最后再访问该解析对应的IP地址</p><p>而使用域名的时候，默认访问的是该主机的 <code>80(HTTP)/443(HTTPS)</code> 端口 ，我们也可以像IP一样，在域名之后用<code>:端口</code> 来指定特定端口号进行访问，即<code>域名:端口</code>。</p><p>一般情况下，我们的主机都可以通过<strong>自动配置DNS</strong>从上层路由器中获取到DNS服务器的地址（比如运营商会在路由器基站中内置DNS服务器）</p><h3 id="5-2-1-DNS劫持"><a href="#5-2-1-DNS劫持" class="headerlink" title="5.2.1 DNS劫持"></a>5.2.1 DNS劫持</h3><p>所谓DNS污染和DNS劫持，就是因为我们访问的DNS服务器的时候，获取到的结果和预期不同，从而导致无法访问目标网站，或者访问了<strong>假</strong>的目标网站</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">www.baidu.com 明明应该指向 1.1.1.1</span><br><span class="line">但被坏蛋劫持了DNS解析，变成了指向 1.1.1.3</span><br></pre></td></tr></table></figure><p>坏蛋可以在 <code>1.1.1.3</code> 服务器上，搭建一个和百度「看起来」一模一样的页面，并将你的报文给转发到百度服务器上。此时他就通过中间转发，获取到了你报文中的用户信息、密码等等参数；</p><p>这时候因为这个<strong>假的服务器</strong>是直接给你提供服务了，使用的HTTPS证书也是这个假服务器的证书，对方可以直接通过自己的证书解密获取到你的信息，再转发给百度。</p><h3 id="5-2-2-DNS和负载均衡"><a href="#5-2-2-DNS和负载均衡" class="headerlink" title="5.2.2 DNS和负载均衡"></a>5.2.2 DNS和负载均衡</h3><p>对于大公司而言，DNS解析还有一个重要的作用，就是通过不同区域的设置来实现负载的均衡。</p><p>假设百度在每一个省份都设立了一个自己的机房，那么它就可以通过DNS服务器，当不同省份的用户请求服务器的时候，返回他当前所处省份的机房地址。这时候就实现了每个机房的负载均衡。</p><p>在现实中，就是将你的请求转接到离你最近的拥有机房的省份，这样既能保证所有服务器的负载均衡，又能保证你的访问能较快地获取到响应（广东访问广州的服务器，肯定比访问北京服务器的延迟低一些）</p><h2 id="5-3-DNS分层"><a href="#5-3-DNS分层" class="headerlink" title="5.3 DNS分层"></a>5.3 DNS分层</h2><p>DNS服务器不会存放所有已知域名的IP解析，因为互联网上存在大量的域名，数量庞大且不断增长，单一DNS服务器无法存储和处理所有域名的IP映射。</p><p>实际上，DNS服务器通过<strong>分层的架构</strong>来解决这个问题。在根DNS服务器层级，有一组全球性的顶级DNS服务器，它们存储顶级域名（例如<code>.com、.org、.net</code>等）的IP地址。然后，在每个顶级域名下，有其他DNS服务器，负责管理该顶级域名下的子域名（例如，<code>google.com、facebook.com</code>等）。这个过程继续向下，形成了一个层级结构。</p><p>当你的设备需要解析某个域名时，它首先会向本地DNS服务器（通常由你的ISP，即<strong>互联网服务提供商</strong>，人话就是国内的三大运营商提供）发起请求。如果本地DNS服务器知道所需域名的IP地址，它会直接返回该IP地址给你的设备。但如果本地DNS服务器不知道该域名的IP地址，它会向<strong>根DNS</strong>服务器发起请求。</p><p>根DNS服务器将指导本地DNS服务器转向相应的<strong>顶级DNS服务器</strong>。然后，顶级DNS服务器可能会进一步将请求转发给负责该<strong>特定域名的授权DNS</strong>服务器。最终，这个授权DNS服务器将返回所需域名的IP地址给本地DNS服务器，本地DNS服务器再将其返回给你的设备。</p><p>这个层级结构允许DNS系统更高效地处理大量的域名解析请求，并确保及时更新和管理域名与IP地址的映射。所以，单个DNS服务器并不会存放所有已知域名的IP解析，而是通过层级结构来分散和管理这些信息。</p><p><img src="https://img.musnow.top/i/2023/08/74893f7e207a52fc1a4c3c683ebb0976.png" alt="img"></p><h2 id="5-4-dig工具分析DNS解析过程"><a href="#5-4-dig工具分析DNS解析过程" class="headerlink" title="5.4 dig工具分析DNS解析过程"></a>5.4 dig工具分析DNS解析过程</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install bind-utils</span><br></pre></td></tr></table></figure><p>安装了之后就可以使用dig命令来查看域名解析过程了</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dig 域名</span><br></pre></td></tr></table></figure><h1 id="6-路由"><a href="#6-路由" class="headerlink" title="6.路由"></a>6.路由</h1><p>路由的过程，就是下图这样一跳一跳(Hop by Hop) “问路” 的过程</p><p>所谓 “一跳” 就是数据链路层中的一个区间。具体在以太网中，指从源MAC地址到目的MAC地址之间的帧传输区间。</p><p><img src="https://img.musnow.top/i/2023/07/f1a4a3b26f00fe29305bba853e830186.png" alt="image-20230726194559495"></p><h2 id="6-1-问路栗子（帮助理解）"><a href="#6-1-问路栗子（帮助理解）" class="headerlink" title="6.1 问路栗子（帮助理解）"></a>6.1 问路栗子（帮助理解）</h2><p>拿日常生活中问路来举例子（请屏蔽现在有导航这件事）一般问路，会得到三种结果：</p><ul><li>我不知道</li><li>我知道XXX知道</li><li>我不知道，但是给你乱指（在路由寻址的过程中，这个情况是不存在的）</li></ul><p>比如张三要去南京大学的仙林校区，他飞机落地南京后，不知道怎么走；他找了个机场的保安，问他“我是从xx省新来的大学生，应该怎么去南京大学？” 保安让他先坐xx路公交车去仙林大学城，到哪里再去问其他人。</p><p>张三到了仙林大学城后，又找到了路边的环卫工，又问“我从机场过来，应该怎么去南京大学。” 环卫工给他指了条明路，那里就是南京大学的教学楼，入口就在这附近。这时候张三获取了两个人（路由器）的帮助，成功递达了南京大学的仙林校区（目标主机）。</p><p>可以看到，问路和上面图示中IP报文的路由是很相似的，都是一个路由一个路由的“问路”，最终找到目标主机。</p><hr><h2 id="6-2-路由表"><a href="#6-2-路由表" class="headerlink" title="6.2 路由表"></a>6.2 路由表</h2><p>报文在各个路由器之间路由也是如此。当一个路由器遇到一个IP报文</p><ul><li>他首先检测这是不是自己分配的局域网中的IP，是则可以直接转发到目标主机；</li><li>不是则查看自己的<strong>路由表</strong>，看看自己是否保存了这个IP应该往哪里走；</li><li>如果它自己不知道，则可以和其他与自己相连的路由器通信（信息同步），问他们这个IP应该给谁（就好比你在公司里面问某一个工作应该交给谁去做）</li><li>如果周边的路由（旁边的路人）都不知道该往哪里去，则路由器会将其交付给自己的<code>默认路由</code>，报文继续转发，去下一个人那里问路了。</li></ul><p>这样的跳跃都会有一个前提条件：相邻的两个主机（或路由器）一定是在物理上相连，处于同一局域网之中。每次的跳跃，本质上是从一个子网跳到另外一个子网；广域网可以认为是最大的“子网”</p><p><img src="https://img.musnow.top/i/2023/07/2eb52f0f7cb80aeed61e8a17d8402688.png" alt="image-20230727085331798"></p><h2 id="6-3-route命令"><a href="#6-3-route命令" class="headerlink" title="6.3 route命令"></a>6.3 route命令</h2><blockquote><p>在windows电脑上可以使用 <code> route print</code> 命令打印路由表，本文不关注windows平台。</p></blockquote><p>在linux平台里面，可以通过<code>route</code>命令查看当前主机的路由表，在Centos8主机上，命令显示如下。</p><p>可以看到，路由表的名字叫做 <strong>内核IP路由表</strong>，这也是linux系统中的一个内核数据结构。内部维护了路由表的目的地、Gateway网关、Genmask掩码、Flags标志位、Metric、Ref、Use、Iface接口</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Kernel IP routing table</span><br><span class="line">Destination     Gateway         Genmask         Flags Metric Ref    Use Iface</span><br><span class="line">default         _gateway        0.0.0.0         UG    100    0        0 eth0</span><br><span class="line">172.16.0.0      0.0.0.0         255.255.0.0     U     100    0        0 eth0</span><br><span class="line">172.17.0.0      0.0.0.0         255.255.0.0     U     0      0        0 docker0</span><br><span class="line">172.18.0.0      0.0.0.0         255.255.0.0     U     0      0        0 br-96d69eeef1ac</span><br><span class="line">172.19.0.0      0.0.0.0         255.255.0.0     U     0      0        0 br-fa4aff4c583e</span><br></pre></td></tr></table></figure><ul><li>Flags中，U代表当前路由表的条目是有效的，G代表其是一个路由器。</li><li>Gateway中，<code>_gateway</code>以及<code>0.0.0.0</code>代表的都是默认网关</li><li>Iface中，只有<code>eth0</code>是一个真正的物理网络接口，而<code>docker0/br-*</code>都是docker容器虚拟出来的桥接网络接口</li></ul><p>假设我我们有一个目的IP是 <code>172.16.0.2</code>，获取到这个IP后，系统就会将其和路由表中的子网掩码依次进行<strong>按位与</strong>；</p><p>在linux环境下，可以使用如下代码来进行这两个IP的按位与操作。其中<code>inet_addr 和 inet_ntoa</code>是linux下的两个系统调用接口。用于IP字符串到无符号整数之间的转换，具体的介绍可以阅读我的 <a href="https://blog.musnow.top/posts/368672249/">UDP博客</a></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 将点分十进制的IP地址和子网掩码转换为无符号整数</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> ipAddress = <span class="built_in">inet_addr</span>(<span class="string">&quot;172.16.0.2&quot;</span>);</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> subnetMask = <span class="built_in">inet_addr</span>(<span class="string">&quot;255.255.0.0&quot;</span>);</span><br><span class="line">    <span class="comment">// 进行按位与操作得到网络地址</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> networkAddress = ipAddress &amp; subnetMask;</span><br><span class="line">    <span class="comment">// 将网络地址转换回点分十进制表示法并输出结果</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">in_addr</span> addr;</span><br><span class="line">    addr.s_addr = networkAddress;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;IP地址: &quot;</span> &lt;&lt; <span class="string">&quot;172.16.0.2&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;子网掩码: &quot;</span> &lt;&lt; <span class="string">&quot;255.255.0.0&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;网络地址: &quot;</span> &lt;&lt; <span class="built_in">inet_ntoa</span>(addr) &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 非linux环境可以使用下方的代码进行处理</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ip_and_gmask_test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> ipAddress = <span class="number">172</span> &lt;&lt; <span class="number">24</span> | <span class="number">16</span> &lt;&lt; <span class="number">16</span> | <span class="number">0</span> &lt;&lt; <span class="number">8</span> | <span class="number">2</span>; <span class="comment">// 将 IP 地址转换为 32 位无符号整数</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> subnetMask = <span class="number">255</span> &lt;&lt; <span class="number">24</span> | <span class="number">255</span> &lt;&lt; <span class="number">16</span> | <span class="number">0</span> &lt;&lt; <span class="number">8</span> | <span class="number">0</span>; <span class="comment">// 将子网掩码转换为 32 位无符号整数</span></span><br><span class="line"></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> networkAddress = ipAddress &amp; subnetMask; <span class="comment">// 按位与</span></span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;IP地址:  172.16.0.2&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;子网掩码: 255.255.0.0&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;网络地址: &quot;</span> &lt;&lt; (networkAddress &gt;&gt; <span class="number">24</span>) &lt;&lt; <span class="string">&quot;.&quot;</span> &lt;&lt; ((networkAddress &gt;&gt; <span class="number">16</span>) &amp; <span class="number">255</span>) &lt;&lt; <span class="string">&quot;.&quot;</span> &lt;&lt; ((networkAddress &gt;&gt; <span class="number">8</span>) &amp; <span class="number">255</span>) &lt;&lt; <span class="string">&quot;.&quot;</span> &lt;&lt; (networkAddress &amp; <span class="number">255</span>) &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>二者输出结果都是<code>172.16.0.0</code></p><p>得到输出结果后，再和路由表中该项的<code>Destination</code>进行对比，二者相等，代表当前IP就是需要通过该项进行路由，那就将这个报文通过<code>Iface</code>接口<code>eth0</code>发送出去就OK了</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Destination     Gateway         Genmask         Flags Metric Ref    Use Iface</span><br><span class="line">172.16.0.0      0.0.0.0         255.255.0.0     U     100    0        0 eth0</span><br></pre></td></tr></table></figure><p>如果按位与的结果与<code>Destination</code>匹配不上，那就继续往下一个条目的子网掩码进行按位与。如果整个表都按位与完毕了，还没找到该去的地方，那就将其通过<code>default</code>默认路由发送出去。</p><h1 id="7-数据链路层"><a href="#7-数据链路层" class="headerlink" title="7.数据链路层"></a>7.数据链路层</h1><p>前面谈了一大堆将数据从一个主机到路由器再跨越多个路由器递达目标主机的流程。</p><p>要想实现这一点，我们还需要数据链路层的帮助，即实现同一局域网内两台主机在物理层面上的相互通信。</p><ul><li>IP网络层：提供跨网络找到正确路由路径，并传输数据的能力</li><li>数据链路层：提供将数据在同一网络中传输的能力</li><li>物理层：实际上的数据在物理（网线）上传输</li></ul><p>数据链路层也有不同的传输方式，本文主要关注当前主流的<strong>以太网</strong>；</p><p>需要注意的是，以太网不是一种具体的网络，而是一种技术标准。它即包含了数据链路层的内容，也包含了一些物理层的规定，比如拓扑结构和访问控制方式，传输速率等。</p><hr><h2 id="7-1-认识局域网的基本情况"><a href="#7-1-认识局域网的基本情况" class="headerlink" title="7.1 认识局域网的基本情况"></a>7.1 认识局域网的基本情况</h2><h3 id="7-1-1-局域网认识"><a href="#7-1-1-局域网认识" class="headerlink" title="7.1.1 局域网认识"></a>7.1.1 局域网认识</h3><p>不过在认识以太网之前，我们需要先知道局域网通信的一个基本情况；假设下图中就是一个局域网，其中包含了不同的主机</p><p><img src="https://img.musnow.top/i/2023/08/ffd57666730e838d74d4c8c9af7d95cd.png" alt="image-20230821171017532"></p><p>首先，如果想要两台主机能够通信，我们就需要先将其链接到<strong>同一根网线</strong>上（在这里暂且不管WIFI，其实本质上也是连在了这根网线上）；这就好比进程间通信的时候，你需要先能看到同一份资源，才能实现对这份资源的共享访问。</p><p>虽然我们认为在局域网里面通信的时候，是两台主机直接交流，但实际上你可以把局域网当作一个教师，当张三和李四沟通的时候，其实会有很多其他的吃瓜群众都能接收到你发送的这个信息。</p><p>反馈到以太网报文上，因为每个主机都是知道自己的地址的，所以只要检测到以太网报头中的<code>目的地址</code>不是自己的时候，就可以丢弃掉这个报文。因为目标并不在和你说话。这就好比在教室里面，你隔壁有俩人在聊天，他们并没有和你交谈，所以你可以不用管他们聊了什么。</p><blockquote><p>这也反馈出了为什么某些公共WIFI会不安全，因为只要接入了这个WIFI，你就有办法检测到其他用户通过这个局域网发送了什么信息！</p></blockquote><p>因为局域网内的主机是通过目的地址判断有没有人和自己聊天的，所以即便我们的电脑开机后什么事情都没有干，在操作系统底层（数据链路层）其实一直都在从局域网中拿到新的数据链路层报文，并检测是否是发给自己的报文：</p><ul><li>是，向上交付</li><li>否，丢掉</li></ul><h3 id="7-1-2-碰撞域"><a href="#7-1-2-碰撞域" class="headerlink" title="7.1.2 碰撞域"></a>7.1.2 碰撞域</h3><p>由于数据链路层向下是直接交付给物理层的，在物理层（网线）中光电信号传输是不能同时传输多个数据的，这就要求我们同一个局域网的多台主机不能同时往局域网中发数据。为了解决这个问题，主机引入了休眠机制，通过不同时间的错开休眠，来避免两台主机同时往局域网中发数据的情况。</p><ul><li>理想情况：同一时间只有一台主机在局域网中发送数据</li><li>碰撞问题：如果出现了同时发送，数据出现冲突，就需要剔除掉这部分数据</li></ul><p>通过<code>碰撞域</code>解决数据冲突问题，尽量达到理想情况；</p><p>比如我们的交换机就有<strong>划分碰撞域</strong>的功能。接到交换机上的设备，除了通过交换机进行路由转发，如果在交换机的这部分设备中出现了数据碰撞，那么交换机就能把碰撞控制在当前这个小的碰撞域内，而不会向更大的局域网中传播。</p><blockquote><p>如果一个局域网里面只有一个交换机（路由器）那么这整个局域网共享碰撞域</p></blockquote><p>所以大公司内为了避免局域网因为碰撞问题而导致的网络卡顿，一般都会将几台电脑接入一个小的交换机中来<strong>划分碰撞域</strong>。</p><p>如上是物理层面的事情，软件层面上，一个<strong>MAC帧</strong>不要太大，否则会大大增加碰撞的概率。所以MAC帧必须要对上层交付的数据大小提一个要求，不能交付太大的数据，这就是MTU的由来（一般都是1500字节，至于为什么是1500，那就是学术层面的事情了）</p><h2 id="7-2-以太网帧格式"><a href="#7-2-以太网帧格式" class="headerlink" title="7.2 以太网帧格式"></a>7.2 以太网帧格式</h2><p><img src="https://img.musnow.top/i/2023/08/736bb377f1eb050bba42a13f153a435e.png" alt="image-20230803144819270"></p><p>这里需要知道一个小知识，虽然MAC地址在一定程度上可以认为是全球唯一的，但实际上只需要保证同一个局域网内的MAC地址是唯一的，就OK了</p><ul><li>目的地址&#x2F;源地址：48位的MAC地址，MAC是每个主机在局域网内唯一的身份标识</li><li>帧协议类型有三种值，分别对应<code>IP、ARP、RARP</code>，所以只需要2个字节</li><li>帧末尾是CRC校验码，4个字节</li></ul><p>这三个就是以太网固定添加的报头，在进行解包的时候，我们只需要取走数据最前面的14个字节（6+6+2），再丢弃末尾的4个字节，就能取到上层的原始数据。</p><h2 id="7-3-认识MAC地址"><a href="#7-3-认识MAC地址" class="headerlink" title="7.3 认识MAC地址"></a>7.3 认识MAC地址</h2><ul><li>MAC地址用来识别数据链路层中相连的节点；</li><li>MAC地址长度为48位（6个字节）一般用十六进制加上冒号的方式来表示，例如<code>08:00:27:03:fb:19</code></li><li>MAC地址在网卡出场的时候就确定了，不能被修改。虚拟机中的MAC地址并不是真实的MAC地址，可能会和已有的冲突（但虚拟机会检测冲突并及时修改，不然虚拟机就上不了网了）也有很少部分网卡支持用户配置MAC地址</li></ul><h3 id="7-3-1-MAC地址和IP协议的区别"><a href="#7-3-1-MAC地址和IP协议的区别" class="headerlink" title="7.3.1 MAC地址和IP协议的区别"></a>7.3.1 MAC地址和IP协议的区别</h3><p>MAC地址和IP地址的区别如下：</p><ul><li>IP地址描述的是路途总体的起点和终点</li><li>MAC地址描述的是路途上每一个小路由区间的起点和终点</li></ul><p>因为我们的主机不可能知道一个很远的内网主机的MAC地址，所以就需要MAC地址在小路由区间来标识起点和终点，并实现正确的数据传输。</p><h2 id="7-4-MTU对上层的影响"><a href="#7-4-MTU对上层的影响" class="headerlink" title="7.4 MTU对上层的影响"></a>7.4 MTU对上层的影响</h2><h3 id="7-4-1-MTU对IP的影响"><a href="#7-4-1-MTU对IP的影响" class="headerlink" title="7.4.1 MTU对IP的影响"></a>7.4.1 MTU对IP的影响</h3><p>在前文提到过，为了避免光电信号在物理层传输的时候出现冲突，需要限制网络层给数据链路层传输的单次的数据大小，MTU的具体说明可以参考本文 <a href="#jump1">2.2.1 认识MTU</a>；</p><p>因为MTU的存在，网络层IP协议中需要对较大的数据包进行分包（IP分片和组装问题在上文也谈过了，这里就不重复了）</p><p>但因为IP协议层分片和组装对于传输层来说是不可见的，如果IP分片后出现丢包导致数据丢失，那么传输层就必须得重传。所以传输层为了避免这种不受自己控制的事情，最终分片的操作应该是由<strong>传输层</strong>来进行处理才是最好的；</p><h3 id="7-4-2-MTU对UDP的影响"><a href="#7-4-2-MTU对UDP的影响" class="headerlink" title="7.4.2 MTU对UDP的影响"></a>7.4.2 MTU对UDP的影响</h3><p>UDP最大可以传输数据是 <code>2^16</code>字节，也就是<code>64KB</code>，而1500字节是<code>1.5KB</code>；也就是说，只要UDP携带的数据超过 <code>1472 (1500 - 20 IP首部 - 8 UDP首部)</code>，那么就会在网络层被分为多个IP数据报。</p><p>一旦这个数据报中有一个IP报文丢失了，那么整个UDP报文就会丢失。再加上UDP并没有超时重传机制（不过可以根据具体的协议来定制应答和重传机制来保证数据可靠性），UDP的报文在IP层中被分片后丢包的概率远大于TCP</p><h3 id="7-4-3-MTU对TCP的影响"><a href="#7-4-3-MTU对TCP的影响" class="headerlink" title="7.4.3 MTU对TCP的影响"></a>7.4.3 MTU对TCP的影响</h3><ul><li>TCP的一个数据报也不能无限大，还是受制于MTU</li><li>TCP的单个数据报的最大消息长度，称为<code>MSS(Max Segment Size)</code>; </li><li>TCP在建立连接的过程中，通信双方会进行MSS协商。最理想的情况， MSS的值正好是在IP不会被分片处理的最大长度(这个长度仍然是受制于数据链路层的 MTU)。</li><li>双方在发送SYN的时候会在TCP头部写入自己能支持的MSS值。然后双方得知对方的MSS值之后，选择较小的作为最终MSS，进行数据传输；</li><li>MSS的值在TCP首部的40字节变长选项中 <code>(kind=2)</code>；</li></ul><p><img src="https://img.musnow.top/i/2023/08/e1f2b9c52380a6bfb16d1e3ccb5c208d.png" alt="image-20230821185112918"></p><p><img src="https://img.musnow.top/i/2023/08/b4f7547b20f6d6207f43f2cee952dd35.png" alt="image-20230821202306869"></p><h2 id="7-5-ARP协议"><a href="#7-5-ARP协议" class="headerlink" title="7.5 ARP协议"></a>7.5 ARP协议</h2><h3 id="7-5-1-说明"><a href="#7-5-1-说明" class="headerlink" title="7.5.1 说明"></a>7.5.1 说明</h3><blockquote><p>ARP协议属于数据链路层，是MAC帧协议的上层</p></blockquote><p>因为在局域网内的传输时，我们是用mac地址来作为不同主机的标识符的，所以就必须存在一个IP地址到MAC地址的转换。</p><p>ARP协议也是包含在以太网帧格式中的，其中属于他自己的正文只有28个字节；因为MTU限制最小的数据长度是46字节，所以在发送ARP报文的时候，需要给这个28字节后面填补空位。</p><p><img src="https://img.musnow.top/i/2023/08/2e608f063bce6f728307d40d2aa275d3.png" alt="image-20230821192339835"></p><p>先来看看ARP请求&#x2F;应答中的各个字段的含义吧</p><ul><li>硬件类型：标定底层使用的是以太网还是其他帧格式，1为以太网</li><li>协议类型：指要转换的地址类型，<code>0X0800</code>为IP地址</li><li>硬件地址长度：对于以太网来说为6字节（这里填的是数字6，所以只需要占用1个字节）；</li><li>协议地址长度：对于IP地址来说为4字节（同上）；</li><li><code>op</code>字段为1表示ARP请求，2表示ARP应答</li></ul><p>当我们的主机开始发送报文之前，我们的主机是不知道某一个IP对于的目标主机的MAC地址的。所以就需要用ARP协议向局域网内发送一个请求，并得到目标主机的ARP响应，响应中就包含了该主机的MAC地址</p><h3 id="7-5-2-ARP请求-x2F-响应的流程"><a href="#7-5-2-ARP请求-x2F-响应的流程" class="headerlink" title="7.5.2 ARP请求&#x2F;响应的流程"></a>7.5.2 ARP请求&#x2F;响应的流程</h3><p>主机A需要给主机B发送数据，但是不知道主机B的MAC地址，它就需要发起一个ARP请求：</p><ul><li>以太网目的地址填为全F，代表广播；源地址填自己的MAC地址</li><li>帧类型填<code>0806</code>代表ARP协议</li><li>ARP中的OP填为1，代表是ARP请求</li><li>发送端以太网地址和IP地址填为<strong>主机A</strong>自己的MAC地址和自己的IP地址</li><li>目的以太网地址填为全F，IP地址填为目的的IP地址（注意我们是知道对方IP地址的）</li><li>向下交付给以太网的MAC帧，然后送入局域网</li></ul><p>这个ARP请求的报文就开始在局域网内进行<strong>广播</strong></p><ul><li>收到这个ARP请求的主机在MAC帧收到，并向上交付给自己的ARP层</li><li>ARP层先通过OP为1判断是ARP的请求</li><li>取出请求中的目的IP地址，判断是否为本机IP地址，不是则丢弃</li><li>是本机的IP地址，代表这个报文是发给自己的ARP请求，需要构造ARP响应</li></ul><p>于是<strong>主机B</strong>就收到了这个ARP请求，并开始构造ARP响应</p><ul><li>以太网目的地址填为ARP请求中的发送端MAC地址，源MAC地址填自己的</li><li>帧类型填<code>0806</code>代表ARP协议</li><li>ARP中的OP填2，代表ARP响应</li><li>发送端以太网地址和IP地址填为<strong>主机B</strong>自己的MAC地址和自己的IP地址</li><li>目的以太网地址填为A的MAC地址（在ARP请求中得知的）IP地址填为目的主机A的IP地址</li><li>向下交付给以太网的MAC帧，然后送入局域网</li></ul><p>此时这个ARP的响应就开始在局域网中传输，因为此时以太网的目的地址不再是全F，所以各个收到这个报文的主机，<strong>就可以直接通过MAC地址来判断是否是发给自己的MAC帧</strong>。如果不是就直接丢弃，不交付给上层；</p><p><strong>主机A</strong>判断目的MAC帧是自己的，交付给上层的ARP协议</p><ul><li>判断ARP中的OP为2，代表是ARP响应</li><li>因为前面已经判断过目的MAC地址是自己的了，所以这时候不需要判断ARP中的目的MAC和目的主机IP了</li><li>直接取出发送端主机MAC和主机IP，就能得到主机B的IP和MAC地址的映射关系</li></ul><p>这时候主机A就<strong>得到了主机B的MAC地址</strong>，可以正常进行数据的发送了！</p><h3 id="7-5-3-ARP缓存与更新"><a href="#7-5-3-ARP缓存与更新" class="headerlink" title="7.5.3 ARP缓存与更新"></a>7.5.3 ARP缓存与更新</h3><ul><li>任何一台主机发出的一定是ARP的请求；</li><li>接收到的ARP可能是对方向往发送的ARP请求，也可能是我发送的ARP请求的响应；</li></ul><p>但如果每台主机都不知道IP和MAC的映射关系，岂不是每次发送数据之前，都需要来个ARP请求和响应来获取对方MAC地址？这样整个局域网内就得被ARP请求和响应给塞满了。</p><p>所以，当我们发送了一个ARP请求后，应该需要将ARP响应给暂时<strong>缓存</strong>到本机上，避免下次发送的时候不知道对方的MAC地址。操作系统中就有一张ARP缓存表，保存了局域网内部分主机的IP和MAC地址的映射关系。</p><blockquote><p>如果一个主机想获取到局域网内所有的MAC地址，就可以写个循环，把局域网内的所有IP都发送一次ARP请求，再将收集到的ARP响应给缓存起来（因为局域网内的主机网络号都是相同的，主机号都是是从1到254，并不多，写个循环就行了）</p></blockquote><p>但这里会有一个问题：如果某台主机B离开了你这个局域网，主机C接入后，路由器给主机C分配了原本是给主机B用的IP，这时候主机A里面的ARP缓存表没有更新，还是填了主机B的MAC地址（但主机B其实已经不在局域网里面了），这时候这个报文岂不是找不到目标主机了？</p><p>所以ARP不仅仅需要缓存，还需要保有一定的<strong>更新机制</strong>：可以设置一个定时器，定时向缓存表中已有IP的主机发送一条ARP请求，并得到对方的ARP响应。这时候就可以比对返回的MAC地址是否有变动，有变动则更新。</p><p>如果一个ARP请求长时间没有得到响应，则可以认为该IP地址目前没有对应的主机，将其从缓存表中删除。</p><h3 id="7-5-4-中间人攻击"><a href="#7-5-4-中间人攻击" class="headerlink" title="7.5.4 中间人攻击"></a>7.5.4 中间人攻击</h3><p>上文讲述了ARP的请求和响应的格式，假设出现了下面的这个情况：</p><ul><li>主机A想获取主机B的MAC，发送ARP请求并获取到了响应</li><li>主机D把自己的IP伪装成主机B的IP，又给主机A发送了ARP响应</li><li>此时主机A更新了ARP缓存表，将主机B的IP B映射给了MAC D</li><li>主机D用同样的办法，将主机B的ARP缓存表中的IP A映射给了MAC D</li><li>此时主机A给B发送消息，填的是MAC D；B给A发消息，填的也是MAC D；</li><li>主机D在收到A和B双方通信的报文后，先交付给自己的上层，再转发给对方；</li><li>A和B的双方通信就出现了一个<strong>中间人D</strong>，此时如果你的信息不是加密的，那就可以被主机D所窃取！</li></ul><p>这也是为啥出现了https来避免中间人攻击！</p><h3 id="7-5-5-RARP"><a href="#7-5-5-RARP" class="headerlink" title="7.5.5  RARP"></a>7.5.5  RARP</h3><p>RARP（Reverse Address Resolution Protocol，逆地址解析协议）是一种网络协议，用于在局域网（LAN）中通过已知的物理地址查找相应的IP地址。</p><p>与前面讲述的ARP（Address Resolution Protocol，地址解析协议）不同，ARP用于通过已知的IP地址查找相应的物理地址，通常用于将网络层（IP）地址映射到链路层（MAC）地址。<strong>RARP则执行相反的操作</strong>，它允许主机在启动时使用其物理地址来请求分配给它的IP地址。</p><p>RARP协议在过去的计算机网络中用于在没有人工配置的情况下为计算机分配IP地址。当计算机启动时，它会向网络发送一个RARP请求包，其中包含它的物理地址（MAC地址），以请求分配一个IP地址。网络中的RARP服务器会接收这个请求并回复包含IP地址的RARP响应包。</p><p>然而，随着时间的推移，RARP的使用逐渐减少，主要是因为它的局限性，例如不太适用于大型网络，以及需要特定的服务器来管理地址分配。现代的网络通常使用DHCP（Dynamic Host Configuration Protocol，动态主机配置协议）来实现类似的功能，它更灵活且易于管理，可以自动分配IP地址以及其他网络配置参数给主机。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><h2 id="数据链路层"><a href="#数据链路层" class="headerlink" title="数据链路层"></a>数据链路层</h2><ul><li>数据链路层的作用：两个设备(同一种数据链路节点)之间进行传递数据；</li><li>以太网是一种技术标准；既包含了数据链路层的内容， 也包含了一些物理层的内容。 例如: 规定了网络拓扑结构, 访问控制方式, 传输速率等；</li><li>以太网帧格式</li><li>理解mac地址</li><li>理解arp协议</li><li>理解MTU</li></ul><h2 id="网络层"><a href="#网络层" class="headerlink" title="网络层"></a>网络层</h2><ul><li>网络层的作用: 在复杂的网络环境中确定一个合适的路径. </li><li>理解IP地址, 理解IP地址和MAC地址的区别</li><li>理解IP协议格式</li><li>了解网段划分方法</li><li>理解如何解决IP数目不足的问题, 掌握网段划分的两种方案</li><li>理解私有IP和公网IP</li><li>理解网络层的IP地址路由过程</li><li>理解一个数据包如何跨越网段到达最终目的地</li><li>理解IP数据包分包的原因</li><li>了解NAT设备的工作原理</li></ul><h2 id="传输层"><a href="#传输层" class="headerlink" title="传输层"></a>传输层</h2><ul><li>传输层的作用: 负责数据能够从发送端传输接收端</li><li>理解端口号的概念</li><li>认识UDP协议, 了解UDP协议的特点。</li><li>认识TCP协议，理解TCP协议的可靠性</li><li>理解TCP协议的状态转化</li><li>掌握TCP的连接管理，确认应答, 超时重传, 滑动窗口, 流量控制, 拥塞控制, 延迟应答, 捎带应答特性</li><li>理解TCP面向字节流, 理解粘包问题和解决方案</li><li>能够基于UDP实现可靠传输</li><li>理解MTU对UDP&#x2F;TCP的影响</li></ul><h2 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a>应用层</h2><ul><li>应用层的作用: 满足我们日常需求的网络程序, 都是在应用层</li><li>能够根据自己的需求，设计应用层协议</li><li>了解HTTP协议</li><li>理解DNS的原理和工作流程</li></ul>]]></content>
    
    
    <summary type="html">IP协议</summary>
    
    
    
    <category term="玩上Linux" scheme="https://blog.musnow.top/categories/%E7%8E%A9%E4%B8%8ALinux/"/>
    
    
    <category term="Linux" scheme="https://blog.musnow.top/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>【牛客网】BM001：翻转链表</title>
    <link href="https://blog.musnow.top/posts/3018206681/"/>
    <id>https://blog.musnow.top/posts/3018206681/</id>
    <published>2023-08-20T09:21:28.000Z</published>
    <updated>2023-08-20T09:21:28.000Z</updated>
    
    <content type="html"><![CDATA[<p>今天打算开启新一轮刷题了，必须得刷了，再不刷就得成废物了。</p><p>也希望看我博客的老哥能监督一下我，一起进步嘛！</p><span id="more"></span><h1 id="题目BM001"><a href="#题目BM001" class="headerlink" title="题目BM001"></a>题目BM001</h1><p>打算从<a href="https://www.nowcoder.com/exam/oj">牛客网的面试top101</a>开始刷起来，今天是<a href="https://www.nowcoder.com/practice/75e878df47f24fdc9dc3e400ec6058ca?tpId=295&tqId=23286&ru=/exam/oj&qru=/ta/format-top101/question-ranking&sourceUrl=/exam/oj">BM001反转链表</a></p><blockquote><p>给定一个单链表的头结点pHead(该头节点是有值的，比如在下图，它的val是1)，长度为n，反转该链表后，返回新链表的表头。</p><p>数据范围： <code>0≤n≤1000</code></p><p>要求：空间复杂度 <code>O(1)</code> ，时间复杂度 <code>O(n) </code>。</p></blockquote><h1 id="解法1：循环"><a href="#解法1：循环" class="headerlink" title="解法1：循环"></a>解法1：循环</h1><p>最简单的办法就是用指针来一个一个修改链接，每次都将当前节点的next链接为上一个节点，最终再将开头的节点（单独存一下原本的开头）的next链接为空，返回最后一个节点即可。</p><p>很常规的写法，参考注释</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode *<span class="title">ReverseList</span><span class="params">(ListNode *head)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// 因为需要O(1)空间复杂度，所以我们不能用很蠢的将数据遍历出来后倒序放回的办法</span></span><br><span class="line">        <span class="comment">// 时间复杂度是O(N) 也要求我们写的代码相对来说效率需要高一些</span></span><br><span class="line">        <span class="keyword">if</span> (head == <span class="literal">nullptr</span> || head-&gt;next == <span class="literal">nullptr</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> head; <span class="comment">// 只有一个或者为空的情况下，直接跳过</span></span><br><span class="line">        &#125;</span><br><span class="line">        ListNode *old_head = head; <span class="comment">// 单独存头</span></span><br><span class="line">        ListNode *A, *B, *C;       <span class="comment">// 三个指针</span></span><br><span class="line">        A = head;</span><br><span class="line">        B = head-&gt;next;</span><br><span class="line">        C = head-&gt;next-&gt;next;</span><br><span class="line">        <span class="keyword">while</span> (C != <span class="literal">nullptr</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// B修改链接为B的前一个（A在原视链表中是B的前一个）</span></span><br><span class="line">            B-&gt;next = A;</span><br><span class="line">            A = B;       <span class="comment">// A变成B（也相当于A在原视链表中，往后走一步）</span></span><br><span class="line">            B = C;       <span class="comment">// B往后走一步</span></span><br><span class="line">            C = C-&gt;next; <span class="comment">// C往后走一步</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 走到这里是B的下一个C已经为nullptr，代表B是最后一个节点</span></span><br><span class="line">        B-&gt;next = A; <span class="comment">// 依旧是链接</span></span><br><span class="line">        old_head-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">return</span> B; <span class="comment">// B是原视链表的最后一个节点，新链表的第一个节点</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="解法2：递归"><a href="#解法2：递归" class="headerlink" title="解法2：递归"></a>解法2：递归</h1><p>一般面试的时候，面试官更希望看到递归的办法，因为这样的代码更加简洁，思路也更加有挑战性（反正你就要往难的办法想）</p><p>递归的思路也是让下一个节点的next链接为当前节点。主要在于递归的末端条件应该是<code>head-&gt;next==nullptr</code>的时候就需要退出了，因为此时 <code>head-&gt;next-&gt;next</code>是无效的，没有办法进行链接。</p><p>整个过程大概就是下面这个简图了，其中方框代表的是节点，圆形代表每一步</p><p><img src="https://img.musnow.top/i/2023/08/4c5f69a4fcc4d859b3623b22ad5039fb.png" alt="image-20230820175040338"></p><p>上代码，这里将 <code>head-&gt;next = NULL;</code>是为了操作第一个节点（原视链表的首节点）的时候，将下一位改成空。而在中间节点的时候，因为当前节点的next会在<strong>上一层递归</strong>的时候被修改回去，所以设置为空不会出现问题。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ListNode *<span class="title">ReverseList</span><span class="params">(ListNode *head)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 特判：注意不要漏掉head-&gt;next==NULL的情况</span></span><br><span class="line">    <span class="keyword">if</span> (head == <span class="literal">NULL</span> || head-&gt;next == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 递归调用</span></span><br><span class="line">    ListNode *ans = <span class="built_in">ReverseList</span>(head-&gt;next);</span><br><span class="line">    <span class="comment">// 让当前结点的下一个结点的 next 指针指向当前节点</span></span><br><span class="line">    head-&gt;next-&gt;next = head;</span><br><span class="line">    <span class="comment">// 同时让当前结点的 next 指针指向NULL ，从而实现从链表尾部开始的局部反转</span></span><br><span class="line">    head-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;今天打算开启新一轮刷题了，必须得刷了，再不刷就得成废物了。&lt;/p&gt;
&lt;p&gt;也希望看我博客的老哥能监督一下我，一起进步嘛！&lt;/p&gt;</summary>
    
    
    
    <category term="把题目都给刷干净" scheme="https://blog.musnow.top/categories/%E6%8A%8A%E9%A2%98%E7%9B%AE%E9%83%BD%E7%BB%99%E5%88%B7%E5%B9%B2%E5%87%80/"/>
    
    
    <category term="C语言" scheme="https://blog.musnow.top/tags/C%E8%AF%AD%E8%A8%80/"/>
    
    <category term="OJ刷题" scheme="https://blog.musnow.top/tags/OJ%E5%88%B7%E9%A2%98/"/>
    
    <category term="牛客网" scheme="https://blog.musnow.top/tags/%E7%89%9B%E5%AE%A2%E7%BD%91/"/>
    
  </entry>
  
  <entry>
    <title>【C++11】future和async等</title>
    <link href="https://blog.musnow.top/posts/2885143113/"/>
    <id>https://blog.musnow.top/posts/2885143113/</id>
    <published>2023-08-19T02:55:38.000Z</published>
    <updated>2023-08-19T09:55:38.000Z</updated>
    
    <content type="html"><![CDATA[<p>C++11的future和async等关键字</p><span id="more"></span><h1 id="1-async和future的概念"><a href="#1-async和future的概念" class="headerlink" title="1.async和future的概念"></a>1.async和future的概念</h1><p><code>std::async</code> 和 <code>std::future</code> 是 C++11 引入的标准库功能，用于实现异步编程，使得在多线程环境中更容易处理并行任务。它们可以帮助你在不同线程中执行函数，并且能够方便地获取函数的结果。</p><p>在之前使用线程的时候，我们没有办法很好的获取到线程所执行函数的返回值。甚至更多时候，我们使用线程执行的都是不关心返回值的函数。如果真的想要获取线程函数的返回值，可以将一个指针作为输出型参数放入线程所执行的函数中。主执行流执行<code>t.join()</code>等待线程执行结束，并获取到这个返回值。</p><p>但这样并不是非常方便。于是C++11就引入了如上两个关键字来帮助我们获取到线程所执行函数的返回值。适用于异步执行某些耗时的函数，提高程序运行的效率：</p><ul><li>异步执行耗时函数</li><li>主执行流干其他事情</li><li>通过<code>std::future</code>获取到返回值</li><li>继续向后执行</li></ul><p>基本的并行概念在多线程部分都已经讲过了，这里就不多bb，直接上代码吧！</p><h1 id="2-使用"><a href="#2-使用" class="headerlink" title="2.使用"></a>2.使用</h1><h2 id="2-1-std-launch"><a href="#2-1-std-launch" class="headerlink" title="2.1 std::launch"></a>2.1 std::launch</h2><p>在使用<code>std::async</code>之前，还需要认识一个枚举类型 <a href="https://legacy.cplusplus.com/reference/future/launch/">launch</a>，在使用<code>std::async</code>的函数传参的时候会用到（这里先说一下，<code>std::async</code>是用来帮我们创建线程的）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum class</span> <span class="title class_">launch</span>; <span class="comment">// std::launch</span></span><br></pre></td></tr></table></figure><p>在 <code>cplusplus</code>网站上，有这个枚举类型的释义，这里面只有俩值</p><p><img src="https://img.musnow.top/i/2023/08/d4827a8d362281d078e27fea12c949c5.png" alt="image-20230819111941932"></p><p>说一下这俩值的区别</p><ul><li><code>launch::async</code>，立即创建一个线程来执行目标函数</li><li><code>launch::deferred</code>，不立即创建线程，而是等待调用<code>std::future</code>的<code>get()</code>函数时才调用（这个get函数是用来获取返回值的）</li></ul><p>好了知道这个就够了哈！</p><h2 id="2-2-std-result-of"><a href="#2-2-std-result-of" class="headerlink" title="2.2 std::result_of"></a>2.2 std::result_of</h2><p>这里还出现了另外一个关键字，就顺带也说说是干嘛的（其实我自己也不知道，现学现卖）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;type_traits&gt;</span> <span class="comment">// 头文件</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">Fn</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">result_of</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">Fn</span>, <span class="keyword">class</span>... ArgTypes&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">result_of</span>&lt;<span class="built_in">Fn</span>(ArgTypes...)&gt;;</span><br></pre></td></tr></table></figure><p>以下是 <code>std::result_of</code> 的基本用法和概念：</p><ol><li><strong>使用 <code>std::result_of</code> 获取函数调用的返回类型：</strong> 你可以通过将函数类型和参数类型传递给 <code>std::result_of</code> 来推导函数调用的返回类型。这使得你可以在编译时获取函数调用的结果类型，而不需要手动指定它。</li><li><strong>用法示例：</strong> 假设有一个函数 <code>int add(int a, int b)</code>，你可以使用 <code>std::result_of</code> 来获取该函数在给定参数下的返回类型。</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;type_traits&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::result_of&lt;<span class="keyword">decltype</span>(add) &amp;(<span class="type">int</span>, <span class="type">int</span>)&gt;::type result = <span class="built_in">add</span>(<span class="number">3</span>, <span class="number">5</span>);</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Result: &quot;</span> &lt;&lt; result &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ g++ test.cpp -o test -std=c++11</span><br><span class="line">$ ./test</span><br><span class="line">Result: 8</span><br></pre></td></tr></table></figure><p>需要注意的是，使用<code>decltype</code>关键字来指定函数指针的时候，函数名和函数参数之间需要加上<code>&amp;</code>，否则无法正确推导类型</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">decltype</span>(add) &amp;(<span class="type">int</span>, <span class="type">int</span>) <span class="comment">// 正确</span></span><br><span class="line"><span class="keyword">decltype</span>(add) (<span class="type">int</span>, <span class="type">int</span>) <span class="comment">// 错误    </span></span><br></pre></td></tr></table></figure><h2 id="2-3-async"><a href="#2-3-async" class="headerlink" title="2.3 async"></a>2.3 async</h2><p>先来看看async函数的样本，第一个情况是不显示传入 <code>std::launch</code>，第二个函数重载是传入了<code>std::launch</code>作为启动策略</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;future&gt;</span> <span class="comment">// 头文件</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// unspecified policy (1)</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">Fn</span>, <span class="keyword">class</span>... Args&gt;</span><br><span class="line">  future&lt;<span class="keyword">typename</span> result_of&lt;<span class="built_in">Fn</span>(Args...)&gt;::type&gt;</span><br><span class="line">    <span class="built_in">async</span> (Fn&amp;&amp; fn, Args&amp;&amp;... args);</span><br><span class="line"><span class="comment">// specific policy (2)</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">Fn</span>, <span class="keyword">class</span>... Args&gt;</span><br><span class="line">  future&lt;<span class="keyword">typename</span> result_of&lt;<span class="built_in">Fn</span>(Args...)&gt;::type&gt;</span><br><span class="line">    <span class="built_in">async</span> (launch policy, Fn&amp;&amp; fn, Args&amp;&amp;... args);</span><br></pre></td></tr></table></figure><p>在cplusplus网站上，说到了第一种情况是由编译器<strong>自主决定</strong>到底是采用 <code>std::launch::async</code> 或 <code>std::launch::deferred</code>，这就需要根据平台和编译器实现以及调用逻辑的不同来具体分析了。所以不建议使用第一个，还是直接指定<code>launch policy</code>（翻译过来是启动策略）的会好一点。</p><p>所以只看第二个👇</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">Fn</span>, <span class="keyword">class</span>... Args&gt;</span><br><span class="line">  future&lt;<span class="keyword">typename</span> result_of&lt;<span class="built_in">Fn</span>(Args...)&gt;::type&gt;</span><br><span class="line">    <span class="built_in">async</span> (launch policy, Fn&amp;&amp; fn, Args&amp;&amp;... args);</span><br></pre></td></tr></table></figure><p>这里采用了可变模板参数来接收多个函数参数，类似于可变参数列表。这里还使用了<code>typename</code>关键字来告知编译器<code>result_of&lt;Fn(Args...)&gt;::type</code>是一个参数类型，需要在模板实例化了之后再去获取确定的类型。而<code>class Fn</code>是一个函数指针的模板变量。</p><ul><li>第一个参数是<code>std::launch</code>，上文已经提到过两个不同选项的区别了</li><li>第二个参数是函数，直接丢函数名就可以了</li><li>第三个参数是这个函数的参数，也是直接丢参数就可以了</li></ul><p>如下是一个简单的调用示例（并非完整示例）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;future&gt;</span> <span class="comment">// 头文件</span></span></span><br><span class="line"><span class="comment">// 函数</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 调用</span></span><br><span class="line">std::<span class="built_in">async</span>(std::launch::async, add, <span class="number">3</span>, <span class="number">5</span>);</span><br></pre></td></tr></table></figure><p>调用了这个函数后，CPP会帮我们创建一个线程来执行函数，并根据第一个启动参数的不同，决定啥时候创建这个线程。最终我们可以通过<code>future</code>获取到线程执行函数的返回值。</p><h2 id="2-4-future"><a href="#2-4-future" class="headerlink" title="2.4 future"></a>2.4 future</h2><p>人如其名，这个类型是用来声明一个<code>未来</code>的变量的。因为<code>std::async</code>会帮我们创建一个线程来执行函数，此时该线程函数的返回值是未知的，这个未来变量就是提前的一个声明，当线程执行完毕函数并返回值的时候，这个变量的值才真正被初始化为我们真正需要的那个值。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;  future;</span><br><span class="line"><span class="comment">// specialization : T is a reference type (R&amp;)</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">R</span>&amp;&gt; future&lt;R&amp;&gt;;     </span><br><span class="line"><span class="comment">// specialization : T is void</span></span><br><span class="line"><span class="keyword">template</span> &lt;&gt;         future&lt;<span class="type">void</span>&gt;;  </span><br></pre></td></tr></table></figure><p>其有如下几个成员函数</p><ul><li>get：获取对应async所执行函数的返回值，如果函数没有执行完毕则阻塞等待</li><li>valid：bool，判断当前future类型到底有没有和一个async函数所对应</li><li>share：将<code>future</code>对象转成一个<code>std::shared_future</code>对象</li><li>wait：等待异步任务完成，但不获取结果</li><li>wait_for：等待异步任务完成，但有等待的时长（没等到就返回错误）</li><li>wait_until：等待异步任务完成，直到一个确定的时间（没等到就返回错误）</li></ul><p>后面三个wait函数和CPP线程中的wait函数如出一辙。</p><h2 id="2-5-share-future"><a href="#2-5-share-future" class="headerlink" title="2.5 share_future"></a>2.5 share_future</h2><p><code>share_future</code>就好比<code>share_ptr</code>智能指针，其让<code>future</code>对象从单一所有权变成了多人可用。本来是一个只能坐一人的餐桌，现在变成了可以坐很多人的大桌子。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;  shared_future;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">R</span>&amp;&gt; shared_future&lt;R&amp;&gt;;   <span class="comment">// specialization : T is a reference type (R&amp;)</span></span><br><span class="line"><span class="keyword">template</span> &lt;&gt;         shared_future&lt;<span class="type">void</span>&gt;; <span class="comment">// specialization : T is void</span></span><br></pre></td></tr></table></figure><p>成员函数和<code>future</code>完全一样（只不过么有<code>share()</code>函数）这里就不赘述了；</p><ul><li><code>future</code>是单人餐桌，一次只能有一个线程执行get函数；当get被执行后，这个future会<strong>失效</strong>。</li><li><code>share_future</code>是大桌子，所有人一起坐在这个桌子上等服务员上菜，互不干扰；</li></ul><h2 id="2-5-测试"><a href="#2-5-测试" class="headerlink" title="2.5 测试"></a>2.5 测试</h2><h3 id="2-5-1-正常测试"><a href="#2-5-1-正常测试" class="headerlink" title="2.5.1 正常测试"></a>2.5.1 正常测试</h3><p>如下代码是一个简单的使用示例，并且通过提供不同的<code>std::launch</code>启动策略，我们也能观察到不同的现象</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;future&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;type_traits&gt;</span> <span class="comment">// result_of</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/unistd.h&gt;</span> <span class="comment">//sleep</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Add  Thread &quot;</span> &lt;&lt; std::this_thread::<span class="built_in">get_id</span>() &lt;&lt; <span class="string">&quot; | Sleeping before add...&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="built_in">sleep</span>(<span class="number">4</span>);</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Main Thread &quot;</span> &lt;&lt; std::this_thread::<span class="built_in">get_id</span>() &lt;&lt; <span class="string">&quot; | Start&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="comment">//std::future&lt;int&gt; futureResult = std::async(std::launch::deferred, add, 3, 5); // 不会创建新线程</span></span><br><span class="line">    std::future&lt;<span class="type">int</span>&gt; futureResult = std::<span class="built_in">async</span>(std::launch::async, add, <span class="number">3</span>, <span class="number">5</span>); <span class="comment">// 创建新线程</span></span><br><span class="line">    <span class="built_in">sleep</span>(<span class="number">3</span>); </span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Main Thread &quot;</span> &lt;&lt; std::this_thread::<span class="built_in">get_id</span>() &lt;&lt; <span class="string">&quot; | Waiting for result...&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="type">int</span> result = futureResult.<span class="built_in">get</span>();  <span class="comment">// 等待异步任务完成并获取结果</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Main Thread &quot;</span> &lt;&lt; std::this_thread::<span class="built_in">get_id</span>() &lt;&lt; <span class="string">&quot; | Result: &quot;</span> &lt;&lt; result &lt;&lt; std::endl;</span><br><span class="line">    <span class="built_in">sleep</span>(<span class="number">3</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果使用<code>std::launch::async</code>作为启动策略，可以看到，执行add函数的线程id和主线程的id是不同的，通过linux下的<code>ps -aL</code>命令也能观察到出现两个线程</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> :; <span class="keyword">do</span> ps jax | <span class="built_in">head</span> -1 &amp;&amp; ps -aL |  grep -v grep;<span class="built_in">sleep</span> 1; <span class="built_in">echo</span> <span class="string">&quot;########################&quot;</span>; <span class="keyword">done</span></span><br></pre></td></tr></table></figure><p>程序执行输出结果</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Main Thread 139869475694400 | Start</span><br><span class="line">Add  Thread 139869457655552 | Sleeping before add...</span><br><span class="line">Main Thread 139869475694400 | Waiting for result...</span><br><span class="line">Main Thread 139869475694400 | Result: 8</span><br></pre></td></tr></table></figure><p>但如果使用<code>std::launch::deferred</code>作为启动策略，则会发现这两个线程的id是完全相同的，这代表实际上其执行了并行的策略</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Main Thread 139789724776256 | Start</span><br><span class="line">Main Thread 139789724776256 | Waiting for result...</span><br><span class="line">Add  Thread 139789724776256 | Sleeping before add...</span><br><span class="line">Main Thread 139789724776256 | Result: 8</span><br></pre></td></tr></table></figure><h3 id="2-5-2-多线程get一个future"><a href="#2-5-2-多线程get一个future" class="headerlink" title="2.5.2 多线程get一个future"></a>2.5.2 多线程get一个future</h3><p>在如下代码中，我写了一个<code>void future_get_func(std::future&lt;int&gt;&amp; fu)</code>的函数，尝试开一个线程来get，然后主执行流又get一次，看看会发生什么。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;future&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;type_traits&gt;</span> <span class="comment">// result_of</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/unistd.h&gt;</span> <span class="comment">// sleep</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Add  Thread &quot;</span> &lt;&lt; std::this_thread::<span class="built_in">get_id</span>() &lt;&lt; <span class="string">&quot; | Sleeping before add...&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="built_in">sleep</span>(<span class="number">4</span>);</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">future_get_func_shared</span><span class="params">(std::shared_future&lt;<span class="type">int</span>&gt;&amp; fu)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> result = fu.<span class="built_in">get</span>();  <span class="comment">// 等待异步任务完成并获取结果</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Func Thread &quot;</span> &lt;&lt; std::this_thread::<span class="built_in">get_id</span>() &lt;&lt; <span class="string">&quot; | Result: &quot;</span> &lt;&lt; result &lt;&lt; std::endl;</span><br><span class="line">    <span class="built_in">sleep</span>(<span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">future_get_func</span><span class="params">(std::future&lt;<span class="type">int</span>&gt;&amp; fu)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> result = fu.<span class="built_in">get</span>();  <span class="comment">// 等待异步任务完成并获取结果</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Func Thread &quot;</span> &lt;&lt; std::this_thread::<span class="built_in">get_id</span>() &lt;&lt; <span class="string">&quot; | Result: &quot;</span> &lt;&lt; result &lt;&lt; std::endl;</span><br><span class="line">    <span class="built_in">sleep</span>(<span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Main Thread &quot;</span> &lt;&lt; std::this_thread::<span class="built_in">get_id</span>() &lt;&lt; <span class="string">&quot; | Start&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="comment">//std::future&lt;int&gt; futureResult = std::async(std::launch::deferred, add, 3, 5); // 不会创建新线程</span></span><br><span class="line">    std::future&lt;<span class="type">int</span>&gt; futureResult = std::<span class="built_in">async</span>(std::launch::async, add, <span class="number">3</span>, <span class="number">5</span>); <span class="comment">// 创建新线程</span></span><br><span class="line">    <span class="built_in">sleep</span>(<span class="number">3</span>); </span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Main Thread &quot;</span> &lt;&lt; std::this_thread::<span class="built_in">get_id</span>() &lt;&lt; <span class="string">&quot; | Waiting for result...&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 尝试测试多线程get会发生什么</span></span><br><span class="line">    </span><br><span class="line">    <span class="function">std::thread <span class="title">t1</span><span class="params">(future_get_func, std::ref(futureResult))</span></span>; <span class="comment">// 开个线程来get</span></span><br><span class="line">    t1.<span class="built_in">detach</span>(); <span class="comment">// 直接分离线程</span></span><br><span class="line">    <span class="built_in">sleep</span>(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> result = futureResult.<span class="built_in">get</span>();  <span class="comment">// 等待异步任务完成并获取结果</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Main Thread &quot;</span> &lt;&lt; std::this_thread::<span class="built_in">get_id</span>() &lt;&lt; <span class="string">&quot; | Result: &quot;</span> &lt;&lt; result &lt;&lt; std::endl;</span><br><span class="line">    <span class="built_in">sleep</span>(<span class="number">3</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>需要注意的是，如下创建线程的传参必须要用<code>std::ref</code>包裹，来告知线程这是一个引用对象，否则编译会报错。因为 <code>std::thread</code> 要求参数可以在<strong>构造函数中被调用</strong>，而 <code>std::future</code> 并不能直接传递给 <code>std::thread</code>；</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::thread <span class="title">t1</span><span class="params">(future_get_func, std::ref(futureResult))</span></span>; <span class="comment">//正确</span></span><br><span class="line"><span class="function">std::thread <span class="title">t1</span><span class="params">(future_get_func, futureResult)</span></span>; <span class="comment">//错误</span></span><br></pre></td></tr></table></figure><p>编译通过后执行，会发现跑出来了一个<code>std::future_error</code>异常，代表我们在一个无效的<code>future</code>上调用了<code>get</code>函数。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Main Thread 139869577889600 | Start</span><br><span class="line">Add  Thread 139869559850752 | Sleeping before add...</span><br><span class="line">Main Thread 139869577889600 | Waiting for result...</span><br><span class="line">Func Thread 139869551458048 | Result: 8</span><br><span class="line">terminate called after throwing an instance of &#x27;std::future_error&#x27;</span><br><span class="line">  what():  std::future_error: No associated state</span><br><span class="line">Aborted</span><br></pre></td></tr></table></figure><p>记住了，<code>std::future</code>在调用了一次<code>get</code>之后将不再与对应的<code>std::async</code>关联，所以才会需要<code>share_future</code>的出现！</p><p>改成<code>share_future</code>再执行上面这套逻辑，就会发现成功跑起来了</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Main Thread 140369883957056 | Start</span><br><span class="line">Add  Thread 140369865918208 | Sleeping before add...</span><br><span class="line">Main Thread 140369883957056 | Waiting for result...</span><br><span class="line">Func Thread 140369857525504 | Result: 8</span><br><span class="line">Main Thread 140369883957056 | Result: 8</span><br></pre></td></tr></table></figure><h3 id="2-5-3-异常处理"><a href="#2-5-3-异常处理" class="headerlink" title="2.5.3 异常处理"></a>2.5.3 异常处理</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Add  Thread &quot;</span> &lt;&lt; std::this_thread::<span class="built_in">get_id</span>() &lt;&lt; <span class="string">&quot; | Sleeping before add...&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="built_in">sleep</span>(<span class="number">4</span>);</span><br><span class="line">    <span class="keyword">throw</span> std::<span class="built_in">runtime_error</span>(<span class="string">&quot;An error occurred&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果<code>async</code>执行的函数中抛出了异常，那么这个异常将会被传回主执行流，可以在主执行流中被处理。而如果直接使用线程来执行这个函数，其异常不会被捕捉，而是会导致整个进程退出。</p><p>下图，使用async运行，成功打印出异常（捕获成功）</p><p><img src="https://img.musnow.top/i/2023/08/b54e8cd394dd45ba670b272df2a385a3.png" alt="image-20230819141820459"></p><p>下图，使用线程运行，进程退出</p><p><img src="https://img.musnow.top/i/2023/08/4a36220784bc763e51be69552f6211d1.png" alt="image-20230819141716295"></p><h2 id="2-6-launch-deferred的真正意义"><a href="#2-6-launch-deferred的真正意义" class="headerlink" title="2.6 launch::deferred的真正意义"></a>2.6 launch::deferred的真正意义</h2><p>如果<code>std::launch::deferred</code>是同步执行，这样写不是多此一举吗？</p><p>NONONO 非也非也，和直接调用<code>Add</code>函数相比，用这样的方式调用<code>Add</code>函数还是有些区别的：</p><ul><li>推迟执行：直接调用Add函数是立马执行，但是用async可以推迟到调用get的时候才执行</li><li>延迟计算：有的时候我们并不是需要立马使用这个函数的返回值，所以就可以延迟一会再执行这个函数，先把函数的调用搞起来，后面只需要一个get就能获取到结果了</li><li>避免线程创建：并不是什么时候多线程都更好，有些时候创建一个线程的消耗还不如直接执行函数来的快（比如函数干的活很小的情况）</li></ul><p>所以，这个关键字多少还是有点作用了。</p><h2 id="2-7-future-error-x2F-errc-x2F-status"><a href="#2-7-future-error-x2F-errc-x2F-status" class="headerlink" title="2.7 future_error&#x2F;errc&#x2F;status"></a>2.7 future_error&#x2F;errc&#x2F;status</h2><p>除了<code>future</code>和<code>share_future</code>，还有如下几个类型</p><ol><li><strong><code>std::future_error</code>：</strong> <code>std::future_error</code> 是一个异常类，用于表示与 <code>std::future</code> 相关的错误。当在使用 <code>std::future</code> 时出现错误，例如获取结果时异步任务抛出了异常，就会抛出 <code>std::future_error</code> 异常。它是一个<strong>标准异常类型</strong>，通常通过捕获异常对象来处理异步任务执行过程中的问题。</li><li><strong><code>std::future_errc</code>：</strong> <code>std::future_errc</code> 是一个枚举类型，用于表示 <code>std::future_error</code> 中的不同错误情况。这样的枚举类型是为了在处理异常时更加明确和方便。它包含了一系列可能的错误，如 <code>broken_promise</code>（promise 被破坏，即 promise 对象的 set_value 或 set_exception 被多次调用）和 <code>future_already_retrieved</code>（future 对象已经被获取过一次）等。</li><li><strong><code>std::future_status</code>：</strong> <code>std::future_status</code> 是一个枚举类型，用于表示 <code>std::future</code> 的状态。它描述了一个 <code>std::future</code> 对象的当前情况，指示异步任务是否已完成、是否有效等。<code>std::future_status</code> 包含三个值：<code>ready</code>（异步任务已完成，可以获取结果）、<code>timeout</code>（等待超时，即异步任务还未完成）、<code>deferred</code>（异步任务延迟执行）。</li></ol><h1 id="3-为什么C-会出现futrue？"><a href="#3-为什么C-会出现futrue？" class="headerlink" title="3.为什么C++会出现futrue？"></a>3.为什么C++会出现futrue？</h1><p>为啥要出一个future？直接用老办法不也可以这么玩吗？</p><p>C++ 标准库引入 <code>std::future</code> 和相关的异步编程机制，是为了更好地支持并发编程和多线程环境。这些机制的出现有几个原因和动机：</p><ol><li><strong>并发性和性能提升：</strong> 在现代计算机体系结构中，多核处理器已经成为常态。为了充分利用这些多核资源，编写并发代码变得重要。<code>std::future</code> 提供了一种方式，可以在多个线程中同时执行任务，并且可以方便地获取任务的结果，从而允许程序在多核处理器上并行执行，提高性能。</li><li><strong>任务分离：</strong> 在很多情况下，我们希望将一个大的任务拆分成多个子任务，在不同的线程中并行执行，然后合并子任务的结果。<code>std::future</code> 允许你在一个线程中等待另一个线程的任务完成，从而支持这种任务分离和并行执行的模式。</li><li><strong>避免阻塞：</strong> 在传统的同步编程中，如果某个操作需要等待，会导致线程阻塞。而异步编程机制允许线程继续执行其他操作，而不必等待一个潜在的耗时操作完成。<code>std::future</code> 允许你在一个线程中发起异步操作，并在需要的时候获取操作的结果，从而避免了不必要的阻塞。</li><li><strong>异常处理：</strong> 在多线程环境中，处理异步任务的异常可能变得复杂，因为异步任务在不同的线程中执行。<code>std::future</code> 引入了异常传递机制，允许异步任务在执行过程中抛出异常，并将这些异常传递到等待结果的线程中。</li></ol><p>总之，C++ 的 <code>std::future</code> 和相关的异步编程机制提供了一种更高级别、更方便的方式来处理多线程并发编程。这些机制使得开发者能够更容易地利用多核处理器的性能，并更灵活地设计并发代码，从而在面对并发和异步任务时能够更好地管理资源、提高效率和处理异常。</p><h1 id="4-promise"><a href="#4-promise" class="headerlink" title="4.promise"></a>4.promise</h1><h2 id="4-1-概念"><a href="#4-1-概念" class="headerlink" title="4.1 概念"></a>4.1 概念</h2><p><code>std::promise</code> 是 C++ 标准库中用于在一个线程中产生结果，然后在另一个线程中获取结果的工具。它提供了一些成员函数来设置结果、处理异常以及获取关联的 <code>std::future</code> 对象等。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;  promise;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">R</span>&amp;&gt; promise&lt;R&amp;&gt;;     <span class="comment">// specialization : T is a reference type (R&amp;)</span></span><br><span class="line"><span class="keyword">template</span> &lt;&gt;         promise&lt;<span class="type">void</span>&gt;;   <span class="comment">// specialization : T is void</span></span><br></pre></td></tr></table></figure><p>下面是一些常用的 <code>std::promise</code> 成员函数及其用法：</p><ol><li><p><strong><code>set_value</code>：</strong> 用于设置结果值。如果你已经通过 <code>get_future()</code> 获取了一个 <code>std::future</code> 对象，调用 <code>set_value</code> 将会使等待结果的线程被唤醒并获取结果。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">std::promise&lt;<span class="type">int</span>&gt; promiseObj;</span><br><span class="line">std::future&lt;<span class="type">int</span>&gt; futureResult = promiseObj.<span class="built_in">get_future</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在某个线程中设置结果值</span></span><br><span class="line">promiseObj.<span class="built_in">set_value</span>(<span class="number">42</span>);</span><br></pre></td></tr></table></figure></li><li><p><strong><code>set_exception</code>：</strong> 用于设置异常，将在等待结果的线程中抛出。这允许你在产生结果的线程中处理异常情况。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 产生异常</span></span><br><span class="line">    <span class="keyword">throw</span> std::<span class="built_in">runtime_error</span>(<span class="string">&quot;An error occurred&quot;</span>);</span><br><span class="line">&#125; </span><br><span class="line"><span class="built_in">catch</span> (...) </span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 将异常设置到 promise 对象中</span></span><br><span class="line">    promiseObj.<span class="built_in">set_exception</span>(std::<span class="built_in">current_exception</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong><code>get_future</code>：</strong> 返回与 <code>std::promise</code> 关联的 <code>std::future</code> 对象。通过这个 <code>std::future</code>，你可以在另一个线程中等待并获取结果。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">std::promise&lt;<span class="type">int</span>&gt; promiseObj;</span><br><span class="line">std::future&lt;<span class="type">int</span>&gt; futureResult = promiseObj.<span class="built_in">get_future</span>();</span><br></pre></td></tr></table></figure></li><li><p><strong><code>swap</code>：</strong> 交换两个 <code>std::promise</code> 对象的状态，包括关联的 <code>std::future</code> 对象和设置的结果。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">std::promise&lt;<span class="type">int</span>&gt; promise1;</span><br><span class="line">std::promise&lt;<span class="type">int</span>&gt; promise2;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 交换两个 promise 对象的状态</span></span><br><span class="line">promise1.<span class="built_in">swap</span>(promise2);</span><br></pre></td></tr></table></figure></li><li><p><strong><code>valid</code>：</strong> 检查 <code>std::promise</code> 对象是否有效，即是否与一个 <code>std::future</code> 对象关联。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">std::promise&lt;<span class="type">int</span>&gt; promiseObj;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (promiseObj.<span class="built_in">valid</span>()) &#123;</span><br><span class="line">    <span class="comment">// promiseObj 有效</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// promiseObj 无效</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>还有下面这俩个成员函数，看名字也能猜出来它是干嘛的，就不多说了</p><ul><li><p><a href="https://legacy.cplusplus.com/reference/future/promise/set_value_at_thread_exit/"><strong>set_value_at_thread_exit</strong></a></p><p>Set value at thread exit (public member function )</p></li><li><p><a href="https://legacy.cplusplus.com/reference/future/promise/set_exception_at_thread_exit/"><strong>set_exception_at_thread_exit</strong></a></p><p>Set exception at thread exit (public member function )</p></li></ul><p>这些成员函数允许你在一个线程中产生结果或异常，<strong>并在另一个线程中等待和处理这些结果或异常</strong>。它们为多线程编程提供了一种可靠的方式来传递数据和控制流。请注意，在使用 <code>std::promise</code> 时，你需要仔细处理异常和线程同步，以确保正确的结果传递。</p><h2 id="4-2-示例"><a href="#4-2-示例" class="headerlink" title="4.2 示例"></a>4.2 示例</h2><p>然后下头是一个基本的使用示例；你可以理解为<code>promise</code>就是一个用来承担线程所执行函数的参数和异常的一个变量，我们可以通过<code>set_value</code>并在主执行流中使用<code>future.get</code>来获取到这个值，也可以设置异常，并在主执行流中处理这个异常；</p><p>不过<code>promise</code>和<code>future</code>一样，是<strong>一次性</strong>的，设置value和异常都只能设置一次，设置完毕后就不能再设置了</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;future&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">worker</span><span class="params">(std::promise&lt;<span class="type">int</span>&gt;&amp; p)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    p.<span class="built_in">set_value</span>(<span class="number">42</span>); <span class="comment">// 设置值</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::promise&lt;<span class="type">int</span>&gt; promiseObj;</span><br><span class="line">    std::future&lt;<span class="type">int</span>&gt; futureResult = promiseObj.<span class="built_in">get_future</span>();</span><br><span class="line"></span><br><span class="line">    <span class="function">std::thread <span class="title">t</span><span class="params">(worker, std::ref(promiseObj))</span></span>; <span class="comment">// 通过线程执行</span></span><br><span class="line">    t.<span class="built_in">join</span>();</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> result = futureResult.<span class="built_in">get</span>(); <span class="comment">// 主线程中获取值</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Result: &quot;</span> &lt;&lt; result &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="5-packaged-task"><a href="#5-packaged-task" class="headerlink" title="5.packaged_task"></a>5.packaged_task</h1><p><code>std::packaged_task</code> 是 C++ 标准库中的一个类模板，用于将一个可调用对象（函数、函数对象或可调用成员函数）封装成一个可以<strong>异步</strong>执行的任务，并且可以通过 <code>std::future</code> 获取任务的返回值。它在多线程编程中起到了连接异步任务和线程间通信的桥梁作用。</p><p><code>std::packaged_task</code> 的主要作用有以下几个方面：</p><ol><li><strong>封装任务：</strong> <code>std::packaged_task</code> 允许你将一个可调用对象封装成一个任务，这个任务可以在另一个线程中异步执行。你可以将函数、函数对象或可调用成员函数封装为一个 <code>std::packaged_task</code> 实例。</li><li><strong>异步执行：</strong> 通过将 <code>std::packaged_task</code> 实例传递给一个 <code>std::thread</code> 或其他支持异步执行的机制，你可以在新的线程中执行封装的任务，而不需要显式创建线程函数。</li><li><strong>获取返回值：</strong> <code>std::packaged_task</code> 可以与 <code>std::future</code> 一起使用，以获取异步任务的返回值。你可以通过 <code>packaged_task</code> 的 <code>get_future</code> 方法获取一个与任务关联的 <code>std::future</code> 对象，然后在适当的时候使用 <code>std::future</code> 的 <code>get</code> 方法来获取任务的返回值。</li><li><strong>线程池：</strong> <code>std::packaged_task</code> 结合线程池的使用，可以更灵活地控制任务的执行方式。线程池可以预先创建一组线程，然后将封装好的任务分配给这些线程执行，避免了频繁创建和销毁线程的开销。</li></ol><h2 id="5-1-示例"><a href="#5-1-示例" class="headerlink" title="5.1 示例"></a>5.1 示例</h2><p>下面是一个简单示例，演示了如何使用 <code>std::packaged_task</code> 来异步执行一个函数并获取其返回值</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;future&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">std::packaged_task&lt;<span class="title">int</span><span class="params">(<span class="type">int</span>, <span class="type">int</span>)</span>&gt; <span class="title">task</span><span class="params">(add)</span></span>;</span><br><span class="line">    std::future&lt;<span class="type">int</span>&gt; future = task.<span class="built_in">get_future</span>();</span><br><span class="line"></span><br><span class="line">    <span class="function">std::thread <span class="title">worker</span><span class="params">(std::move(task), <span class="number">3</span>, <span class="number">5</span>)</span></span>;</span><br><span class="line">    worker.<span class="built_in">join</span>(); <span class="comment">// 通过线程异步执行这个task</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> result = future.<span class="built_in">get</span>(); <span class="comment">// 等待返回值</span></span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Result: &quot;</span> &lt;&lt; result &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个例子中，<code>std::packaged_task</code> 封装了一个函数 <code>add</code>，然后通过 <code>std::thread</code> 异步执行，最后通过 <code>std::future</code> 获取异步任务的返回值。</p><h2 id="5-2-make-ready-at-thread-exit"><a href="#5-2-make-ready-at-thread-exit" class="headerlink" title="5.2 make_ready_at_thread_exit"></a>5.2 make_ready_at_thread_exit</h2><p><code>packaged_task</code>的成员函数中，主要还是这个需要单独说明；先看如下代码</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;future&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">std::packaged_task&lt;<span class="title">int</span><span class="params">()</span>&gt; <span class="title">task</span><span class="params">([]()&#123; <span class="keyword">return</span> <span class="number">42</span>; &#125;)</span></span>;</span><br><span class="line">    std::future&lt;<span class="type">int</span>&gt; future = task.<span class="built_in">get_future</span>();</span><br><span class="line"></span><br><span class="line">    <span class="function">std::thread <span class="title">worker</span><span class="params">([&amp;task]() &#123;</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="comment">// 模拟一些工作</span></span></span></span><br><span class="line"><span class="params"><span class="function">        std::this_thread::sleep_for(std::chrono::seconds(<span class="number">2</span>));</span></span></span><br><span class="line"><span class="params"><span class="function"></span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="comment">// 设置任务结果值</span></span></span></span><br><span class="line"><span class="params"><span class="function">        task.make_ready_at_thread_exit();</span></span></span><br><span class="line"><span class="params"><span class="function">    &#125;)</span></span>;</span><br><span class="line"></span><br><span class="line">    worker.<span class="built_in">detach</span>(); <span class="comment">// 分离线程，不等待其结束</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 等待任务结果</span></span><br><span class="line">    <span class="type">int</span> result = future.<span class="built_in">get</span>();</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Result: &quot;</span> &lt;&lt; result &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们让<code>packaged_task</code>执行的是一个<code>return 42</code>的函数，而线程里面还会进行其他处理。</p><p>而<code>make_ready_at_thread_exit()</code>的作用，就是确认当前的<code>worker</code>线程已经干完自己的活了，可以执行<code>packaged_task</code>封装的函数了！</p><p>相当于是一个确认<code>packaged_task</code>中封装的任务到底在什么时候执行的一个函数。调用这个函数的时候，就会开始执行其包装的异步函数，并返回结果给<code>future.get()</code>的执行流</p><h1 id="The-end"><a href="#The-end" class="headerlink" title="The end"></a>The end</h1><p>收工</p>]]></content>
    
    
    <summary type="html">C++11的future和async等</summary>
    
    
    
    <category term="遇见C++" scheme="https://blog.musnow.top/categories/%E9%81%87%E8%A7%81C/"/>
    
    
    <category term="Linux" scheme="https://blog.musnow.top/tags/Linux/"/>
    
    <category term="C++" scheme="https://blog.musnow.top/tags/C/"/>
    
    <category term="C++11" scheme="https://blog.musnow.top/tags/C-11/"/>
    
  </entry>
  
  <entry>
    <title>【面经】230816云账房一面</title>
    <link href="https://blog.musnow.top/posts/1199148787/"/>
    <id>https://blog.musnow.top/posts/1199148787/</id>
    <published>2023-08-16T10:32:14.000Z</published>
    <updated>2023-08-16T10:32:14.000Z</updated>
    
    <content type="html"><![CDATA[<p>230816云账房一面</p><span id="more"></span><h2 id="1-什么是移动构造"><a href="#1-什么是移动构造" class="headerlink" title="1.什么是移动构造"></a>1.什么是移动构造</h2><h2 id="2-循环链表如何实现"><a href="#2-循环链表如何实现" class="headerlink" title="2.循环链表如何实现"></a>2.循环链表如何实现</h2><h2 id="3-用了那些stl容器"><a href="#3-用了那些stl容器" class="headerlink" title="3.用了那些stl容器"></a>3.用了那些stl容器</h2><h2 id="4-树的类型"><a href="#4-树的类型" class="headerlink" title="4.树的类型"></a>4.树的类型</h2><p>这里问了我mysql用的是什么，我答了红黑树。但其实是B+树（没学）</p><h2 id="5-C-11新特性"><a href="#5-C-11新特性" class="headerlink" title="5.C++11新特性"></a>5.C++11新特性</h2><h2 id="6-C-11future"><a href="#6-C-11future" class="headerlink" title="6.C++11future"></a>6.C++11future</h2><p>没听说过，得学</p><h2 id="7-linux进程通信的方式"><a href="#7-linux进程通信的方式" class="headerlink" title="7.linux进程通信的方式"></a>7.linux进程通信的方式</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">管道 </span><br><span class="line">共享内存</span><br><span class="line">信号量</span><br><span class="line">socket</span><br><span class="line">本地文件</span><br></pre></td></tr></table></figure><p>全答出来了，还问了谁最快（共享内存最快）</p><p>然后又问了进程之间如何同步（不会）</p><p>tnnd现在才想起来。进程同步直接用信号量就可以啊！！！！！我怎么信号量答出来了不知到这玩意是干嘛的呢……说白了还是学艺不精</p><h2 id="8-git的基本命令"><a href="#8-git的基本命令" class="headerlink" title="8.git的基本命令"></a>8.git的基本命令</h2><p>我说了下面这些</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">git add </span><br><span class="line">git push</span><br><span class="line">git commit </span><br><span class="line">git log</span><br><span class="line">git reset </span><br><span class="line">git rebase</span><br><span class="line">git merge</span><br></pre></td></tr></table></figure><h2 id="9-版本号管理"><a href="#9-版本号管理" class="headerlink" title="9.版本号管理"></a>9.版本号管理</h2><p>我答我用了3个版本号</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">大版本.功能版本.bug修复版本</span><br></pre></td></tr></table></figure><h2 id="谢谢惠顾"><a href="#谢谢惠顾" class="headerlink" title="谢谢惠顾"></a>谢谢惠顾</h2><p>泻药，太多东西没答上来，已经发了感谢信了</p>]]></content>
    
    
    <summary type="html">230816云账房一面</summary>
    
    
    
    <category term="求职路上一去不复返" scheme="https://blog.musnow.top/categories/%E6%B1%82%E8%81%8C%E8%B7%AF%E4%B8%8A%E4%B8%80%E5%8E%BB%E4%B8%8D%E5%A4%8D%E8%BF%94/"/>
    
    
    <category term="面经" scheme="https://blog.musnow.top/tags/%E9%9D%A2%E7%BB%8F/"/>
    
  </entry>
  
  <entry>
    <title>【Python】元组/列表/集合的区别</title>
    <link href="https://blog.musnow.top/posts/1142930252/"/>
    <id>https://blog.musnow.top/posts/1142930252/</id>
    <published>2023-08-15T13:15:18.000Z</published>
    <updated>2023-08-15T13:15:18.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-说明"><a href="#1-说明" class="headerlink" title="1.说明"></a>1.说明</h1><p>元组（tuple）、列表（list）和集合（set）是Python中常见的数据结构，它们有一些重要的区别。</p><span id="more"></span><ol><li><p><strong>可变性</strong>：列表是可变的（mutable），可以对其进行添加、删除和修改操作。元组是不可变的（immutable），一旦创建就无法修改。集合也是可变的，但是它具有去重功能，不允许存在重复的元素，并且没有固定的顺序。</p></li><li><p><strong>语法</strong>：列表使用方括号<code>[]</code>来表示，元素之间用逗号<code>,</code>分隔；元组使用圆括号<code>()``来表示，元素之间同样用逗号</code>,<code>分隔；集合使用大括号</code>{}<code>来表示，元素之间也用逗号</code>,&#96;分隔。</p><p>例如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">my_list = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">my_tuple = (<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>)</span><br><span class="line">my_set = &#123;<span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>索引和切片</strong>：列表和元组都支持通过索引访问元素和切片操作。而集合是无序的，不支持索引和切片操作。</p></li><li><p><strong>重复元素</strong>：列表和元组允许存在重复的元素，而集合会自动去除重复的元素。</p><p>例如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">my_list = [<span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">3</span>]  <span class="comment"># 列表中可以有重复元素</span></span><br><span class="line">my_tuple = (<span class="number">4</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">5</span>)      <span class="comment"># 元组中也可以有重复元素</span></span><br><span class="line">my_set = &#123;<span class="number">6</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">7</span>&#125;        <span class="comment"># 集合会自动去除重复的元素</span></span><br><span class="line"><span class="comment"># 如上my_set = &#123;6,7&#125;</span></span><br></pre></td></tr></table></figure></li><li><p><strong>可哈希性</strong>：集合的元素必须是可哈希（hashable）的，而列表和元组的元素可以是可哈希或不可哈希的。可哈希的意思是该对象的值在其生命周期中不发生改变，且能够唯一地确定一个对象。</p></li></ol><p>总的来说</p><ul><li>元组适用于存储固定的、不可变的数据；</li><li>列表适用于需要频繁对其中的元素进行增删改操作的情况；</li><li>集合适用于需要确保元素唯一性且不关心元素的顺序的场景。</li></ul><p>选择使用哪种数据结构取决于具体的需求和问题的特点。</p><h1 id="2-可哈希性"><a href="#2-可哈希性" class="headerlink" title="2.可哈希性"></a>2.可哈希性</h1><h2 id="2-1-概念"><a href="#2-1-概念" class="headerlink" title="2.1 概念"></a>2.1 概念</h2><p>可哈希性（hashability）是指一个对象是否具有哈希值（hash value），并且能够保持不变。在Python中，可哈希的对象是指那些在其生命周期中不可变的对象。</p><p>哈希值是一个固定长度的整数，用于唯一标识一个对象。哈希值是通过将对象的内容转换为一个数字来计算得到的。可哈希的对象具有以下特点：</p><ol><li>哈希值不会改变：一个对象的哈希值在其生命周期中是不变的，即使对象的内容发生了改变。</li><li>相等的对象具有相同的哈希值：如果两个对象是相等的，则它们的哈希值也相等。</li></ol><p>可哈希性在Python中非常重要，主要体现在两个方面：</p><ol><li>字典的键（key）必须是可哈希的对象：因为字典是基于哈希表实现的，它使用键的哈希值来索引和快速查找对应的值。所以字典中的键必须是不可变的对象，例如整数、浮点数、字符串、元组等都是可哈希的。</li><li>集合的元素必须是可哈希的对象：集合也是基于哈希表实现的，它使用哈希值来确定元素是否存在于集合中，并且保证集合中的元素唯一性。所以集合中的元素也必须是不可变的对象。</li></ol><p>总结起来，可哈希性是指对象在其生命周期中不发生改变，并且能够通过哈希函数计算得到一个固定的、唯一的哈希值。可哈希的对象可以作为字典的键和集合的元素使用。</p><h2 id="2-2-自定义类型的可哈希性"><a href="#2-2-自定义类型的可哈希性" class="headerlink" title="2.2 自定义类型的可哈希性"></a>2.2 自定义类型的可哈希性</h2><p>自定义类型（Custom types）可以维护可哈希性，但需要满足一定的条件。</p><p>在Python中，对象的可哈希性是由其所属类的<code>__hash__()</code>方法和<code>__eq__()</code>方法共同决定的。下面是关于自定义类型维护可哈希性的条件：</p><ol><li><p><code>__hash__()</code>方法的实现：自定义类型必须定义<code>__hash__()</code>方法，该方法返回一个整数作为对象的哈希值。通常情况下，可使用内置函数<code>hash()</code>来计算哈希值，具体实现如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">__hash__</span>(<span class="params">self</span>):</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">hash</span>((self.attribute1, self.attribute2, ...))</span><br></pre></td></tr></table></figure><p>注意，<code>__hash__()</code>方法应该返回一个不可变的值，并且相等的对象应该具有相等的哈希值。</p></li><li><p><code>__eq__()</code>方法的实现：为了确保相等的对象具有相等的哈希值，自定义类型也必须定义<code>__eq__()</code>方法来比较两个对象是否相等。<code>__eq__()</code>方法通常与<code>__hash__()</code>方法配合使用，具体实现如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">__eq__</span>(<span class="params">self, other</span>):</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">isinstance</span>(other, self.__class__):</span><br><span class="line">        <span class="keyword">return</span> (self.attribute1 == other.attribute1) <span class="keyword">and</span> (self.attribute2 == other.attribute2) <span class="keyword">and</span> ...</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure><p>注意，<code>__eq__()</code>方法应该返回布尔值表示两个对象是否相等。</p></li></ol><p>通过正确实现<code>__hash__()</code>和<code>__eq__()</code>方法，自定义类型就可以维护可哈希性。这样，对象就可以作为字典的键或集合的元素，并能够保持不变性和相等性的判断。</p><p>然而，请注意，如果自定义类型中的属性是可变的（例如列表、集合等），则对象可能会发生改变，导致哈希值的改变。因此，在定义可哈希的自定义类型时，<strong>应该避免使用可变的属性</strong>。</p><h3 id="2-2-1-hash-自定义类型"><a href="#2-2-1-hash-自定义类型" class="headerlink" title="2.2.1 hash(自定义类型)"></a>2.2.1 hash(自定义类型)</h3><p>当我们使用 <code>hash</code>函数来处理自定义类型时，python就会调用这个自定义类型的 <code>__hash__()</code>函数</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">hash</span>(p1)</span><br><span class="line"><span class="comment"># 等价于</span></span><br><span class="line">p1.__hash__()</span><br></pre></td></tr></table></figure><p>默认情况下，<code>__hash__ </code>方法返回对象的标识符，而 <code>__eq__</code> 方法在两个对象相同时返回 True。如果想要覆盖这个默认行为，我们可以实现<code> __hash__</code> 方法和 <code>__eq__</code> 方法。</p><h3 id="2-2-2-只实现eq"><a href="#2-2-2-只实现eq" class="headerlink" title="2.2.2 只实现eq"></a>2.2.2 只实现eq</h3><p>如果一个自定义类型只实现了 <code>__eq__</code>而没有实现 <code>__hash__</code>，那么这个类型就不具备可哈希性，也就不能作为dict或者集和的键值</p><p>比如如下person对象只实现了 <code>__eq__</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, name, age</span>):</span><br><span class="line">        self.name = name</span><br><span class="line">        self.age = age</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__eq__</span>(<span class="params">self, other</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">isinstance</span>(other, Person) <span class="keyword">and</span> self.age == other.age</span><br></pre></td></tr></table></figure><p>如果尝试将这个对象放入set，就会报错</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">members = &#123;</span><br><span class="line">    Person(<span class="string">&#x27;John&#x27;</span>, <span class="number">22</span>),</span><br><span class="line">    Person(<span class="string">&#x27;Jane&#x27;</span>, <span class="number">22</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">TypeError: unhashable type: &#x27;Person&#x27;</span><br></pre></td></tr></table></figure><p>同时person对象失去了hash功能</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">hash</span>(Person(<span class="string">&#x27;John&#x27;</span>, <span class="number">22</span>))</span><br><span class="line"><span class="comment"># TypeError: unhashable type: &#x27;Person&#x27;</span></span><br></pre></td></tr></table></figure><p>为了使得 Person 类可哈希，我们还需要实现 <code>__hash__</code> 方法</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, name, age</span>):</span><br><span class="line">        self.name = name</span><br><span class="line">        self.age = age</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__eq__</span>(<span class="params">self, other</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">isinstance</span>(other, Person) <span class="keyword">and</span> self.age == other.age</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__hash__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">hash</span>(self.age)</span><br></pre></td></tr></table></figure><p>现在，Person 类既支持基于 age 的等值比较，又具有哈希功能。</p><p>为了使得 Person 能够正常用于字典这种数据结构，类的哈希值必须具有不可变性。为此，我们可以将 age 定义为只读属性</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, name, age</span>):</span><br><span class="line">        self.name = name</span><br><span class="line">        self._age = age</span><br><span class="line"></span><br><span class="line"><span class="meta">    @property</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">age</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> self._age</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__eq__</span>(<span class="params">self, other</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">isinstance</span>(other, Person) <span class="keyword">and</span> self.age == other.age</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__hash__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">hash</span>(self.age)</span><br></pre></td></tr></table></figure><h3 id="2-2-3-总结"><a href="#2-2-3-总结" class="headerlink" title="2.2.3 总结"></a>2.2.3 总结</h3><ul><li>默认情况下，<code>__hash__</code> 方法返回对象的 ID，<code>__eq__ </code>方法使用 is 操作符进行比较。</li><li>如果实现了 <code>__eq__</code> 方法，Python 会将<code> __hash__</code> 方法设置为 None，除非实现了自定义的<code> __hash__</code> 方法。</li></ul>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;1-说明&quot;&gt;&lt;a href=&quot;#1-说明&quot; class=&quot;headerlink&quot; title=&quot;1.说明&quot;&gt;&lt;/a&gt;1.说明&lt;/h1&gt;&lt;p&gt;元组（tuple）、列表（list）和集合（set）是Python中常见的数据结构，它们有一些重要的区别。&lt;/p&gt;</summary>
    
    
    
    <category term="速通Python" scheme="https://blog.musnow.top/categories/%E9%80%9F%E9%80%9APython/"/>
    
    
    <category term="Python" scheme="https://blog.musnow.top/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>【Python】selenium遇到ActionChains.move_to_element() takes 2 positional arguments but 4 were given报错</title>
    <link href="https://blog.musnow.top/posts/2142561511/"/>
    <id>https://blog.musnow.top/posts/2142561511/</id>
    <published>2023-08-15T04:06:19.000Z</published>
    <updated>2023-08-15T05:15:17.000Z</updated>
    
    <content type="html"><![CDATA[<p>刚开始学的时候，用火绒的selenium插件录制了一个操作，导出为了python文件；</p><span id="more"></span><p>使用如下的命令运行这个文件（如果没有pytest用pip安装一下就行）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pip install pytest</span><br><span class="line">pip install selenium</span><br></pre></td></tr></table></figure><p>用如下命令执行导出的文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pytest test_test01.py</span><br></pre></td></tr></table></figure><p>会得到这个报错</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">      actions = ActionChains(self.driver)</span><br><span class="line">&gt;     actions.move_to_element(element, 0, 0).perform()</span><br><span class="line">E     TypeError: ActionChains.move_to_element() takes 2 positional arguments but 4 were given</span><br><span class="line"></span><br><span class="line">test_test1.py:42: TypeError</span><br></pre></td></tr></table></figure><p>可我压根没有修改过导出的文件，这个报错是怎么来的呢？</p><p>目测是高低版本的python的selenium包中，报错的<code>ActionChains.move_to_element()</code>这个函数的传参被修改过；而插件生成的代码中，上方的这个就是正确的传参，下方的这个带<code>0,0</code>的传参是错误的</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 3 | mouseOver | css=.row:nth-child(5) &gt; .col-sm-3:nth-child(3) &gt; .xe-widget | </span></span><br><span class="line">element = self.driver.find_element(By.CSS_SELECTOR, <span class="string">&quot;.row:nth-child(5) &gt; .col-sm-3:nth-child(3) &gt; .xe-widget&quot;</span>)</span><br><span class="line">actions = ActionChains(self.driver)</span><br><span class="line">actions.move_to_element(element).perform()  <span class="comment"># 正确</span></span><br><span class="line"><span class="comment"># 4 | mouseOut | css=.row:nth-child(5) &gt; .col-sm-3:nth-child(3) &gt; .xe-widget | </span></span><br><span class="line">element = self.driver.find_element(By.CSS_SELECTOR, <span class="string">&quot;body&quot;</span>)</span><br><span class="line">actions = ActionChains(self.driver)</span><br><span class="line">actions.move_to_element(element, <span class="number">0</span>, <span class="number">0</span>).perform() <span class="comment"># 错误</span></span><br></pre></td></tr></table></figure><p><img src="https://img.musnow.top/i/2023/08/1585f2651b13965219be66828b1d5dbb.png" alt="image-20230815130034250"></p><p>可以查看函数定义，只接受一个参数</p><p><img src="https://img.musnow.top/i/2023/08/98f151c08184d9de59cdca2d7bc0aa14.png" alt="image-20230815130102297"></p><p>把这里的两个<code>0,0</code>删除掉就行了，运行的结果和我录制的效果相同，没有问题！</p><p><img src="https://img.musnow.top/i/2023/08/93101cc08b96ec6f3328e904dc331b31.png" alt="image-20230815130134022"></p><p>顺带附上本次debug的版本号</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">python             3.10.5</span><br><span class="line">pytest             7.4.0</span><br><span class="line">selenium           4.11.2</span><br><span class="line">火狐浏览器版本 116.0.2（64位）</span><br><span class="line">火狐浏览器Selenium IDE插件版本 3.17.4</span><br></pre></td></tr></table></figure><p>如果帮到了你，还请评论支持我一下，谢谢！</p>]]></content>
    
    
    <summary type="html">python的selenium遇到ActionChains.move_to_element() takes 2 positional arguments but 4 were given报错</summary>
    
    
    
    <category term="速通Python" scheme="https://blog.musnow.top/categories/%E9%80%9F%E9%80%9APython/"/>
    
    
    <category term="Python" scheme="https://blog.musnow.top/tags/Python/"/>
    
    <category term="selenium" scheme="https://blog.musnow.top/tags/selenium/"/>
    
  </entry>
  
  <entry>
    <title>【Python】自动化测试selenium</title>
    <link href="https://blog.musnow.top/posts/192617188/"/>
    <id>https://blog.musnow.top/posts/192617188/</id>
    <published>2023-08-14T04:15:19.000Z</published>
    <updated>2023-08-15T03:15:17.000Z</updated>
    
    <content type="html"><![CDATA[<p>学习自动化测试selenium的笔记</p><span id="more"></span><h1 id="1-什么是自动化测试"><a href="#1-什么是自动化测试" class="headerlink" title="1.什么是自动化测试"></a>1.什么是自动化测试</h1><p>自动化测试指软件测试的自动化，在预设状态下运行应用程序或者系统，预设条件包括正常和异常，最后评估运行结果。将人为驱动的测试行为转化为机器执行的过程。</p><p>说白了就是编写一系列代码来实现自动帮我们测试某一个功能是否有啥问题。比起自己弄，自动化测试能覆盖到更多情况，特别是某些在实际情况中不好通过人工模拟出的问题。</p><p>下图是自动化测试的金字塔模型，从下往上代表测试需要的时间和投入，单元测试应该是投入最大的测试。</p><p><img src="https://img.musnow.top/i/2023/08/5f7243ac0ec65b8cd62f68a8941bfb27.png" alt="img"></p><h2 id="1-1-单元测试"><a href="#1-1-单元测试" class="headerlink" title="1.1 单元测试"></a>1.1 单元测试</h2><p>所谓单元测试，就是我们代码中每一个函数、程序模块的测试。</p><p>单元测试通常遵循以下步骤：</p><ol><li><strong>编写测试用例</strong>：为每个函数、方法或类编写测试用例，这些用例包括输入数据、预期输出以及对应的函数调用。</li><li><strong>运行测试</strong>：使用单元测试框架运行编写的测试用例。测试框架会执行测试并报告每个测试的结果。</li><li><strong>断言测试结果</strong>：测试框架会自动比较实际输出与预期输出，如果不匹配则会产生错误报告。</li><li><strong>修复错误</strong>：如果测试失败，开发人员需要检查代码并修复问题，确保代码按预期工作。</li><li><strong>重复测试</strong>：在每次代码更改后，都需要重新运行相应的单元测试，以确保新的更改没有破坏现有的功能。</li></ol><p>单元测试的目标，就是保证我们写出来的函数是依照我们的预期运行的，能得到我们需要的结果。而最终目的，就是避免当一个函数已经投入使用了，才发现这个函数的运行与预期结果不符合。</p><h2 id="1-2-接口测试"><a href="#1-2-接口测试" class="headerlink" title="1.2 接口测试"></a>1.2 接口测试</h2><p>目前一般采用后端提供API接口，前端使用静态页面的方式来实现前后端分离。</p><p>而接口测试，就是保证我们后端提供的API接口能正确分离我们预期的参数，并提供与之相符合的返回结果。</p><p>当我们完成了后端接口的编写后，就能在产品前期进行接口测试，避免产品已经上线了才发现接口有问题的情况。</p><ul><li>产品前期接口完成后介入</li><li>用例维护量小</li><li>适合接口变动较小，界面变动频繁的项目</li></ul><p>常见的接口自动化测试工具有：RobotFramework，JMeter，SoapUI，TestNG+HttpClient，Postman 等。</p><h2 id="1-3-UI测试"><a href="#1-3-UI测试" class="headerlink" title="1.3 UI测试"></a>1.3 UI测试</h2><p>对于用户来说，他们接触到的其实还是UI（前端），在完成了接口测试后，我们需要对前端界面的操作进行测试。特点：</p><ul><li>用例维护量大</li><li>页面相关性强，需要完成后期项目开发后才介入</li><li>由于前端界面相对来说比较复杂，UI测试适合界面变动较小的项目</li></ul><p>UI自动化测试的好处</p><ul><li>减少重复测试的时间，实现快速回归测试</li><li>创建可靠的测试过程，避免测试过程中的人为错误</li><li>可以实现很多更加繁琐的测试，或者难以用人工实现的测试，减少人力成本</li><li>更好的利用资源和测试脚本</li></ul><p>UI层的测试框架比较多，比如Windows客户端测试的AutoIT，web测试的selenium以及TestPlant eggPlant，Robot framework，QTP等。</p><h2 id="1-4-自动化测试适用对象"><a href="#1-4-自动化测试适用对象" class="headerlink" title="1.4 自动化测试适用对象"></a>1.4 自动化测试适用对象</h2><ol><li>产品型项目。产品型的项目，新版本是在旧版本的基础上进行改进，功能变不大的项目，但项目的新老功能都必须重复的进行回归测试。<strong>回归测试是自动化测试的强项</strong>，它能够很好的验证你是否引入了新的缺陷，老的缺陷是否修改过来了。在某种程度上可以把自动化测试工具叫做回归测试工具。</li><li>机械频繁的测试。每次需要输入大量用例，并且在一个项目中运行的周期比较长。 比如兼容性测试。</li></ol><p>以下情况就不适用于自动化测试：</p><ol><li>需求变动频繁，自动化脚本不能很好的复用（写个测试脚本的时间都够人工测试了，自然不适合自动化测试）</li><li>项目周期短，自动化脚本编写完毕后使用次数不多（没啥时间写脚本）</li><li>交互性较强，需要人工干预的项目，自动化无法实施</li></ol><h2 id="1-5-如何实施自动化测试？"><a href="#1-5-如何实施自动化测试？" class="headerlink" title="1.5 如何实施自动化测试？"></a>1.5 如何实施自动化测试？</h2><p>单纯的讲，自动化测试的具体实现，应该是包含下面七个过程的。</p><ol><li>分析：总体把握系统逻辑，分析出系统的核心体系架构。</li><li>设计：设计测试用例，测试用例要足够明确和清晰，覆盖面广而精</li><li>实现：实现脚本，有两个要求一是断言，二是合理的运用参数化。</li><li>执行：执行脚本远远没有我们想象中那么简单。脚本执行过程中的异常需要我们仔细的去分析原因。</li><li>总结：测试结果的分析，和测试过程的总结是自动化测试的关键。</li><li>维护：自动化测试脚本的维护是一个难以解决但又必须要解决的问题。</li><li>分析：在自动化测试过程中深刻的分析自动化用例的覆盖风险和脚本维护的成本。</li></ol><p><img src="https://img.musnow.top/i/2023/08/a5e5ecae7b4936d6e5873bfab8420fab.jpeg" alt="img"></p><h1 id="2-安装Selenium环境"><a href="#2-安装Selenium环境" class="headerlink" title="2.安装Selenium环境"></a>2.安装Selenium环境</h1><p>本文使用各个软件的版本号</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">python             3.10.5</span><br><span class="line">pytest             7.4.0</span><br><span class="line">selenium           4.11.2</span><br><span class="line">火狐浏览器版本   116.0.2（64位）</span><br><span class="line">火狐浏览器Selenium IDE插件版本 3.17.4</span><br></pre></td></tr></table></figure><h2 id="2-1-火狐安装Selenium-IDE"><a href="#2-1-火狐安装Selenium-IDE" class="headerlink" title="2.1 火狐安装Selenium IDE"></a>2.1 火狐安装Selenium IDE</h2><p>打开火狐，点击右上角选择框，进入<code>扩展和主题</code></p><p><img src="https://img.musnow.top/i/2023/08/675970df60fdda1c5931a6e121a4bc00.png" alt="image-20230815131901498"></p><p>点击左侧扩展，搜索 <code>Selenium IDE</code></p><p><img src="https://img.musnow.top/i/2023/08/7704b53b2e4ac86a133773adc5af5a74.png" alt="image-20230815131919494"></p><p>第一个就是我们要的，图标是蓝色的，中间有一个Se字母</p><p><img src="https://img.musnow.top/i/2023/08/505fb45af8a3d4f3f13c1c9dc5e64f5e.png" alt="image-20230815132002494"></p><p>进入后，点击获取插件（这里我已经安装了，所以显示的是<code>移除</code>）</p><p><img src="https://img.musnow.top/i/2023/08/788ae4be22001f41bf790a034765fec3.png" alt="image-20230815132027959"></p><h2 id="2-2-windows安装python"><a href="#2-2-windows安装python" class="headerlink" title="2.2 windows安装python"></a>2.2 windows安装python</h2><p>在windows上python安装的基础步骤参考我的这篇博客：<a href="https://blog.musnow.top/posts/800910784/">【Python】在你的云服务&#x2F;电脑上搭建Python环境</a></p><blockquote><p>初次安装python的时候，一定要勾选<code>ADD PYTHON TO PATH</code>这个选项，这个在上文中有提及。因为非常重要所以多说几次！</p></blockquote><p>安装好python后，使用pip安装如下两个包</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pip install pytest</span><br><span class="line">pip install selenium</span><br></pre></td></tr></table></figure><p>如果按照的很慢可以加上镜像源</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pip install pytest -i https://pypi.tuna.tsinghua.edu.cn/simple</span><br><span class="line">pip install selenium  -i https://pypi.tuna.tsinghua.edu.cn/simple</span><br></pre></td></tr></table></figure><p>windows下如何配置pip镜像源参考：<a href="https://blog.musnow.top/posts/783373963/">【Python】pip下载使用国内镜像源</a></p><h2 id="2-3-安装火狐驱动geckodriver"><a href="#2-3-安装火狐驱动geckodriver" class="headerlink" title="2.3 安装火狐驱动geckodriver"></a>2.3 安装火狐驱动geckodriver</h2><p>如果你尝试直接运行selenium的代码，极有可能会遇到如下报错，这是因为你没有安装火狐对应的驱动</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">WebDriverException: Message: &#x27;geckodriver&#x27; executable needs to be in PATH.</span><br></pre></td></tr></table></figure><p>火狐驱动下载地址：<a href="https://github.com/mozilla/geckodriver/releases">https://github.com/mozilla/geckodriver/releases</a></p><blockquote><p>chrome驱动下载地址：<a href="https://registry.npmmirror.com/binary.html?path=chromedriver/">https://registry.npmmirror.com/binary.html?path=chromedriver/</a></p><p>因为本文操作用的都是火狐，所以不提及chrome的操作。请自行查阅其他文章</p></blockquote><p>下载好了之后，将其中的<strong>geckodriver.exe</strong>解压到windows下python的安装路径的Scripts文件夹下；</p><p><img src="https://img.musnow.top/i/2023/08/f98740f110e8fa5a23720fe182c5f4ec.png" alt="image-20230815133452659"></p><p>如果你用的是上面提到那片博客里面的安装方式，那么在windows平台下python默认的安装路径如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">C:\Users\moth\AppData\Local\Programs\Python\Python310</span><br></pre></td></tr></table></figure><p>如果你不知道你电脑上python的安装路径，可以在vscode的解析器中找到；当你在vscode中打开一个<code>test.py</code>文件，右下角就会显示当前使用的解析器</p><p><img src="https://img.musnow.top/i/2023/08/27c18246029010c4cba8bf021c591c4b.png" alt="image-20230815133144736"></p><p>点击它，就能看到你安装的python的路径</p><p><img src="https://img.musnow.top/i/2023/08/f6f36703a94c25baa339161db2b7620f.png" alt="image-20230815133218786"></p><p>注意：如果你的python是用windows商店安装的，那路径里面是没有<code>Scripts</code>文件夹的！所以强烈不推荐使用windows商店来安装python（虽然确实方便）</p><p>你可以在windows设置-软件里面找到微软商店安装的python，将其卸载，然后再用上面提到的办法重新安装你需要的版本的python！</p><p><img src="https://img.musnow.top/i/2023/08/19a0c5b80c517e0349dd13990cd0fa20.png" alt="image-20230815133414861"></p><h2 id="2-4-尝试录制一段操作"><a href="#2-4-尝试录制一段操作" class="headerlink" title="2.4 尝试录制一段操作"></a>2.4 尝试录制一段操作</h2><p>上面的安装都完成后，就可以来尝试录制一段操作了。这里我使用了我自己的导航页来测试，打开火狐后，点击右上角的这个拼图图标</p><p><img src="https://img.musnow.top/i/2023/08/fb90390f0aff1a2820c140b12077a854.png" alt="image-20230815134108580"></p><p>选择selenium IDE运行扩展</p><p><img src="https://img.musnow.top/i/2023/08/3ba9c91a72a965561c3fea6fbcdf1748.png" alt="image-20230815134140312"></p><p>点击第一个，在新项目中录制一个新操作</p><p><img src="https://img.musnow.top/i/2023/08/0563b92346edda8ceaff25c860021a28.png" alt="image-20230815134200268"></p><p>随便输入一个项目名字</p><p><img src="https://img.musnow.top/i/2023/08/fc89ef1ad4154870d475f18af9b6556e.png" alt="image-20230815134322768"></p><p>选择你需要录制的页面url，这里我填了我自己的主页 <code>web.musnow.top</code>，填写好了之后点击<code>START RECORDING</code>开始录制</p><p><img src="https://img.musnow.top/i/2023/08/8847799a1733896d2e5e4ae55f90d7e1.png" alt="image-20230815134406281"></p><p>开始录制后，右下角会出现正在录制的提示；以下是我录制了的操作。</p><p>这里我在我主页的输入框中输入了你好，点击回车</p><p><img src="https://img.musnow.top/i/2023/08/ff3b88eb18dab22c70b6c09921a5591d.png" alt="image-20230815134237407"></p><p>然后我又点击了第一个搜索结果，录制到这里就结束了</p><p><img src="https://img.musnow.top/i/2023/08/9f6a20e2c5fafc002b388bd88d269c09.png" alt="image-20230815134253921"></p><p>进入selenium IDE的页面，点击右上角的红色方框停止录制（下图中是已经停止录制后的样子）中间会显示你这次录制做了什么</p><p><img src="https://img.musnow.top/i/2023/08/72cf250e219008d0b84d630202c991e3.png" alt="image-20230815134532977"></p><p>将本次录制保存，随便起个名字，然后右键左侧的录制名，选择<code>export</code>导出</p><p><img src="https://img.musnow.top/i/2023/08/d7b0752110452ed307257ad03f6a2d27.png" alt="image-20230815134638917"></p><p>选择python代码，点击导出；弹出的框会让你选择导出路径</p><p><img src="https://img.musnow.top/i/2023/08/fe41c77fb7b5c7c3306313bc9c9798e9.png" alt="image-20230815134652459"></p><p>下面就是我导出后的代码，Selenium IDE会将文件命名为<code>项目名_录制名.py</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Generated by Selenium IDE</span></span><br><span class="line"><span class="keyword">import</span> pytest</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> json</span><br><span class="line"><span class="keyword">from</span> selenium <span class="keyword">import</span> webdriver</span><br><span class="line"><span class="keyword">from</span> selenium.webdriver.common.by <span class="keyword">import</span> By</span><br><span class="line"><span class="keyword">from</span> selenium.webdriver.common.action_chains <span class="keyword">import</span> ActionChains</span><br><span class="line"><span class="keyword">from</span> selenium.webdriver.support <span class="keyword">import</span> expected_conditions</span><br><span class="line"><span class="keyword">from</span> selenium.webdriver.support.wait <span class="keyword">import</span> WebDriverWait</span><br><span class="line"><span class="keyword">from</span> selenium.webdriver.common.keys <span class="keyword">import</span> Keys</span><br><span class="line"><span class="keyword">from</span> selenium.webdriver.common.desired_capabilities <span class="keyword">import</span> DesiredCapabilities</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TestTest1</span>():</span><br><span class="line">  <span class="keyword">def</span> <span class="title function_">setup_method</span>(<span class="params">self, method</span>):</span><br><span class="line">    self.driver = webdriver.Firefox()</span><br><span class="line">    self.<span class="built_in">vars</span> = &#123;&#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">def</span> <span class="title function_">teardown_method</span>(<span class="params">self, method</span>):</span><br><span class="line">    self.driver.quit()</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">def</span> <span class="title function_">wait_for_window</span>(<span class="params">self, timeout = <span class="number">2</span></span>):</span><br><span class="line">    time.sleep(<span class="built_in">round</span>(timeout / <span class="number">1000</span>))</span><br><span class="line">    wh_now = self.driver.window_handles</span><br><span class="line">    wh_then = self.<span class="built_in">vars</span>[<span class="string">&quot;window_handles&quot;</span>]</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(wh_now) &gt; <span class="built_in">len</span>(wh_then):</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">set</span>(wh_now).difference(<span class="built_in">set</span>(wh_then)).pop()</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">def</span> <span class="title function_">test_test1</span>(<span class="params">self</span>):</span><br><span class="line">    <span class="comment"># Test name: test1</span></span><br><span class="line">    <span class="comment"># Step # | name | target | value</span></span><br><span class="line">    <span class="comment"># 1 | open | / | </span></span><br><span class="line">    self.driver.get(<span class="string">&quot;https://web.musnow.top/&quot;</span>)</span><br><span class="line">    <span class="comment"># 2 | setWindowSize | 1721x935 | </span></span><br><span class="line">    self.driver.set_window_size(<span class="number">1721</span>, <span class="number">935</span>)</span><br><span class="line">    <span class="comment"># 3 | mouseOver | css=.row:nth-child(5) &gt; .col-sm-3:nth-child(3) &gt; .xe-widget | </span></span><br><span class="line">    element = self.driver.find_element(By.CSS_SELECTOR, <span class="string">&quot;.row:nth-child(5) &gt; .col-sm-3:nth-child(3) &gt; .xe-widget&quot;</span>)</span><br><span class="line">    actions = ActionChains(self.driver)</span><br><span class="line">    actions.move_to_element(element).perform()</span><br><span class="line">    <span class="comment"># 4 | mouseOut | css=.row:nth-child(5) &gt; .col-sm-3:nth-child(3) &gt; .xe-widget | </span></span><br><span class="line">    element = self.driver.find_element(By.CSS_SELECTOR, <span class="string">&quot;body&quot;</span>)</span><br><span class="line">    actions = ActionChains(self.driver)</span><br><span class="line">    actions.move_to_element(element, <span class="number">0</span>, <span class="number">0</span>).perform()</span><br><span class="line">    <span class="comment"># 5 | click | id=txt | </span></span><br><span class="line">    self.driver.find_element(By.ID, <span class="string">&quot;txt&quot;</span>).click()</span><br><span class="line">    <span class="comment"># 6 | type | id=txt | 你好</span></span><br><span class="line">    self.driver.find_element(By.ID, <span class="string">&quot;txt&quot;</span>).send_keys(<span class="string">&quot;你好&quot;</span>)</span><br><span class="line">    <span class="comment"># 7 | sendKeys | id=txt | $&#123;KEY_ENTER&#125;</span></span><br><span class="line">    self.<span class="built_in">vars</span>[<span class="string">&quot;window_handles&quot;</span>] = self.driver.window_handles</span><br><span class="line">    <span class="comment"># 8 | selectWindow | handle=$&#123;win5784&#125; | </span></span><br><span class="line">    self.driver.find_element(By.ID, <span class="string">&quot;txt&quot;</span>).send_keys(Keys.ENTER)</span><br><span class="line">    <span class="comment"># 9 | click | css=.\_paragraph_5yh6i_2 &gt; span &gt; span | </span></span><br><span class="line">    self.<span class="built_in">vars</span>[<span class="string">&quot;win5784&quot;</span>] = self.wait_for_window(<span class="number">2000</span>)</span><br><span class="line">    <span class="comment"># 10 | selectWindow | handle=$&#123;win5879&#125; | </span></span><br><span class="line">    self.driver.switch_to.window(self.<span class="built_in">vars</span>[<span class="string">&quot;win5784&quot;</span>])</span><br><span class="line">    self.<span class="built_in">vars</span>[<span class="string">&quot;window_handles&quot;</span>] = self.driver.window_handles</span><br><span class="line">    self.driver.find_element(By.CSS_SELECTOR, <span class="string">&quot;.\\_paragraph_5yh6i_2 &gt; span &gt; span&quot;</span>).click()</span><br><span class="line">    self.<span class="built_in">vars</span>[<span class="string">&quot;win5879&quot;</span>] = self.wait_for_window(<span class="number">2000</span>)</span><br><span class="line">    self.driver.switch_to.window(self.<span class="built_in">vars</span>[<span class="string">&quot;win5879&quot;</span>])</span><br><span class="line">  </span><br><span class="line"></span><br></pre></td></tr></table></figure><p>使用如下命令运行这个文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pytest 文件名</span><br></pre></td></tr></table></figure><p>直接运行会遇到如下的报错</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">      actions = ActionChains(self.driver)</span><br><span class="line">&gt;     actions.move_to_element(element, 0, 0).perform()</span><br><span class="line">E     TypeError: ActionChains.move_to_element() takes 2 positional arguments but 4 were given</span><br><span class="line"></span><br><span class="line">test_test1.py:42: TypeError</span><br></pre></td></tr></table></figure><p>报错的意思是 <code>ActionChains.move_to_element()</code>函数只需要接受两个参数，但却提供了4个参数，出错的是第四十二行的位置</p><p><img src="https://img.musnow.top/i/2023/08/d388df2e932b91864e089c1e81ee1fc4.png" alt="image-20230815135043228"></p><p>解决办法是将这里的<code>,0,0</code>给删除，类似38行，只传入<code>element</code>参数就可以了</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">actions.move_to_element(element).perform()</span><br></pre></td></tr></table></figure><p>完整解决办法参考：<a href="https://blog.csdn.net/muxuen/article/details/132296695?spm=1001.2014.3001.5501">【Python】selenium遇到ActionChains.move_to_element() takes 2 positional arguments but 4 were given报错</a></p><p>修改好了之后，再用<code>pytest</code>运行这个文件，其会弹出一个火狐的浏览器窗口，并在窗口里面复现我们刚刚录制的操作了！</p><h1 id="3-代码学习"><a href="#3-代码学习" class="headerlink" title="3.代码学习"></a>3.代码学习</h1><p>只会录制是不够的，我们还需要学会这个库的<strong>webdriver API</strong>基本使用；</p><blockquote><p>需要注意是，不同版本的python <code>selenium</code>包其内部函数有所区别，请确认您的版本和本文所使用的版本相同！否则会出问题的😶‍🌫️</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">selenium   4.11.2</span><br></pre></td></tr></table></figure></blockquote><h2 id="3-1-小试牛刀"><a href="#3-1-小试牛刀" class="headerlink" title="3.1 小试牛刀"></a>3.1 小试牛刀</h2><p>在<a href="https://www.baidu.com/">百度主页</a>，用F12打开开发者模式，选中搜索框，能定位到如下html代码</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">id</span>=<span class="string">&quot;kw&quot;</span> <span class="attr">name</span>=<span class="string">&quot;wd&quot;</span> <span class="attr">class</span>=<span class="string">&quot;s_ipt&quot;</span> <span class="attr">value</span>=<span class="string">&quot;&quot;</span> <span class="attr">maxlength</span>=<span class="string">&quot;255&quot;</span> <span class="attr">autocomplete</span>=<span class="string">&quot;off&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure><p>先来看看如下的示例代码吧，这个代码的作用是在百度里面搜索selenium；</p><p>这里我们选择了<code>webdriver.Firefox()</code>火狐作为驱动；随后使用了<code>By.ID</code>定位到了<code>kw</code>的位置，即这个搜索框，并在内部<code>send_keys</code>输入了<code>selenium</code>文字。</p><p>休眠了2秒后，又通过ID找到了<code>su</code>的html标签（这是确认搜素的按钮），并使用<code>click()</code>方法点击了这个按钮；</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># coding = utf-8</span></span><br><span class="line"><span class="keyword">from</span> selenium <span class="keyword">import</span> webdriver</span><br><span class="line"><span class="keyword">from</span> selenium.webdriver.common.by <span class="keyword">import</span> By</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line">browser = webdriver.Firefox()  <span class="comment"># 使用火狐的浏览器驱动（必须在python安装目录里面安装对应驱动）</span></span><br><span class="line">time.sleep(<span class="number">2</span>)</span><br><span class="line">browser.get(<span class="string">&quot;http://www.baidu.com&quot;</span>)  <span class="comment"># 打开网页</span></span><br><span class="line">time.sleep(<span class="number">2</span>)</span><br><span class="line">browser.find_element(By.ID,<span class="string">&quot;kw&quot;</span>).send_keys(<span class="string">&quot;selenium&quot;</span>)  <span class="comment"># 找到网页中的id为kw的地方，输入&quot;selenium&quot;</span></span><br><span class="line">time.sleep(<span class="number">2</span>)</span><br><span class="line">browser.find_element(By.ID,<span class="string">&quot;su&quot;</span>).click()  <span class="comment"># 点击id为su的按钮</span></span><br><span class="line">time.sleep(<span class="number">2</span>)</span><br><span class="line">browser.quit()  <span class="comment"># 退出网页</span></span><br></pre></td></tr></table></figure><p>除了<code>quit()</code>，还有<code>close()</code>办法也能关闭网页</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">browser.close() <span class="comment"># 也可以关闭窗口。</span></span><br><span class="line"><span class="comment"># 两者的区别是：</span></span><br><span class="line"><span class="comment"># close方法关闭当前的浏览器窗口，quit方法不仅关闭窗口，还会彻底的退出webdriver，释放与driver</span></span><br><span class="line"><span class="comment"># server之间的连接。所以简单来说quit是更加彻底的close，quit会更好的释放资源。</span></span><br></pre></td></tr></table></figure><p>最终运行的效果如下（录制的动图，效果可能不咋地）</p><p><img src="https://img.musnow.top/i/2023/08/d4c8fa950322bfc4a2afc519e76431e7.gif" alt="GIF"></p><h2 id="3-2-元素的定位"><a href="#3-2-元素的定位" class="headerlink" title="3.2 元素的定位"></a>3.2 元素的定位</h2><h3 id="3-2-1-基本说明"><a href="#3-2-1-基本说明" class="headerlink" title="3.2.1 基本说明"></a>3.2.1 基本说明</h3><p>在html中元素的定位是自动化测试的核心，脚本必须要知道你需要操作的是什么页面的元素，才能正常进行自动化处理；</p><p>而在html中，一个对象可以用不同的办法来定位到</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">id</span><br><span class="line">name</span><br><span class="line">class name</span><br><span class="line">link text</span><br><span class="line">partial link text</span><br><span class="line">tag name</span><br><span class="line">xpath</span><br><span class="line">css selector</span><br></pre></td></tr></table></figure><p>前面提到过，百度的输入框html是下面这样的。光是在这一行html代码中，就包含了id、name、class这三个可以用于我们来定位的元素，还有“看不到”的css也能定位到这里。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">id</span>=<span class="string">&quot;kw&quot;</span> <span class="attr">name</span>=<span class="string">&quot;wd&quot;</span> <span class="attr">class</span>=<span class="string">&quot;s_ipt&quot;</span> <span class="attr">value</span>=<span class="string">&quot;&quot;</span> <span class="attr">maxlength</span>=<span class="string">&quot;255&quot;</span> <span class="attr">autocomplete</span>=<span class="string">&quot;off&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure><p>浏览器开发者模式中，右侧就能看到和kw相关的css是<code>#kw</code></p><p><img src="https://img.musnow.top/i/2023/08/1edeb92795c9e4d2407c09bfbc396b53.png" alt="image-20230815142146714"></p><p>需要注意的是，要想定位到<strong>唯一元素</strong>，必须要保证这个元素的标识符在整个页面是唯一的！假设百度的主页有两个<code>id=&quot;kw&quot;</code>的元素，那就没有办法通过id来定位到输入框！这就要求写前端的朋友们，尽可能地为每一个需要测试的页面元素留下一个唯一的id或者name，保证自动化脚本能正常运行！</p><p>不同定位方式，我们只需要修改<code>By.</code>来自什么，以及传入对应的参数就可以了！</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#  通过id 方式定位</span></span><br><span class="line">browser.find_element(By.ID,<span class="string">&quot;kw&quot;</span>).send_keys(<span class="string">&quot;selenium1&quot;</span>) <span class="comment"># 找到网页中的id为kw的地方，输入&quot;selenium&quot;</span></span><br><span class="line"><span class="comment">#  通过name 方式定位</span></span><br><span class="line">browser.find_element(By.NAME,<span class="string">&quot;wd&quot;</span>).send_keys(<span class="string">&quot;selenium2&quot;</span>)</span><br><span class="line"><span class="comment">#  通过tag name 方式定位</span></span><br><span class="line">browser.find_element(By.TAG_NAME,<span class="string">&quot;input&quot;</span>).send_keys(<span class="string">&quot;selenium3&quot;</span>) <span class="comment"># 不能成功，因为input元素太多了，不唯一！</span></span><br><span class="line"><span class="comment">#  通过class name 方式定位</span></span><br><span class="line">browser.find_element(By.CLASS_NAME,<span class="string">&quot;s_ipt&quot;</span>).send_keys(<span class="string">&quot;selenium4&quot;</span>)</span><br><span class="line"><span class="comment">#  通过CSS 方式定位</span></span><br><span class="line">browser.find_element(By.CSS_SELECTOR,<span class="string">&quot;#kw&quot;</span>).send_keys(<span class="string">&quot;selenium5&quot;</span>)</span><br><span class="line"><span class="comment">#  通过XPATH 方式定位</span></span><br><span class="line">browser.find_element(By.XPATH,<span class="string">&quot;//*[@id=&#x27;kw&#x27;]&quot;</span>).send_keys(<span class="string">&quot;selenium6&quot;</span>)</span><br></pre></td></tr></table></figure><p>当运行到input定位的时候，由于定位不唯一，就会出现如下报错</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">selenium.common.exceptions.ElementNotInteractableException: Message: Element &lt;input name=&quot;ie&quot; type=&quot;hidden&quot;&gt; is not reachable by keyboard</span><br><span class="line">Stacktrace:</span><br><span class="line">RemoteError@chrome://remote/content/shared/RemoteError.sys.mjs:8:8</span><br><span class="line">WebDriverError@chrome://remote/content/shared/webdriver/Errors.sys.mjs:187:5</span><br><span class="line">ElementNotInteractableError@chrome://remote/content/shared/webdriver/Errors.sys.mjs:347:5</span><br><span class="line">webdriverSendKeysToElement@chrome://remote/content/marionette/interaction.sys.mjs:631:13</span><br><span class="line">interaction.sendKeysToElement@chrome://remote/content/marionette/interaction.sys.mjs:605:11</span><br><span class="line">sendKeysToElement@chrome://remote/content/marionette/actors/MarionetteCommandsChild.sys.mjs:535:29</span><br><span class="line">receiveMessage@chrome://remote/content/marionette/actors/MarionetteCommandsChild.sys.mjs:152:31</span><br></pre></td></tr></table></figure><p>这是因为有一个<code>&lt;input name=&quot;ie&quot; type=&quot;hidden&quot;&gt;</code> 标签被隐藏了，我们的<code>send_keys</code>函数（相当于键盘）是没有办法往这个标签里面输入信息的，整个进程也就此退出了。</p><h3 id="3-2-2-Xpath"><a href="#3-2-2-Xpath" class="headerlink" title="3.2.2 Xpath"></a>3.2.2 Xpath</h3><p>这里对XPATH做一个小小的解释</p><blockquote><p>XPath（XML Path Language）是一种用于在XML文档中定位元素和节点的语言。它是一种基于树结构的表达式语言，通常用于在XML文档中进行导航和搜索操作。XPath 可以帮助您根据元素的层次结构、属性和文本内容来精确定位特定的元素或节点。因为HTML可以看做XML的一种实现，所以我们可以用XPath来定位HTML中的元素。</p><p>你可以理解位Xpath类似于正则表达式，可以通过特定的表达式来匹配到我们想要的位置。这里只做了解即可，后续有需要再深入学习；</p></blockquote><h3 id="3-2-3-link-text"><a href="#3-2-3-link-text" class="headerlink" title="3.2.3 link text"></a>3.2.3 link text</h3><p>上面的栗子中，我们没有用到<code>link text / partial link text</code> 这两种方式来定位元素，</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;学习自动化测试selenium的笔记&lt;/p&gt;</summary>
    
    
    
    <category term="速通Python" scheme="https://blog.musnow.top/categories/%E9%80%9F%E9%80%9APython/"/>
    
    
    <category term="Python" scheme="https://blog.musnow.top/tags/Python/"/>
    
    <category term="selenium" scheme="https://blog.musnow.top/tags/selenium/"/>
    
  </entry>
  
</feed>
