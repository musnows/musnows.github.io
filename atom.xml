<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>慕雪的寒舍</title>
  
  <subtitle>雪下了一夜</subtitle>
  <link href="https://blog.musnow.top/atom.xml" rel="self"/>
  
  <link href="https://blog.musnow.top/"/>
  <updated>2024-04-24T06:17:48.000Z</updated>
  <id>https://blog.musnow.top/</id>
  
  <author>
    <name>慕雪年华</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>【leetcode】95.不同的二叉搜索树2</title>
    <link href="https://blog.musnow.top/posts/2470995449/"/>
    <id>https://blog.musnow.top/posts/2470995449/</id>
    <published>2024-04-23T04:42:36.000Z</published>
    <updated>2024-04-24T06:17:48.000Z</updated>
    
    <content type="html"><![CDATA[<p>leetcode刷题笔记-95.不同的二叉搜索树2</p><h1 id="95-不同的二叉搜索树2"><a href="#95-不同的二叉搜索树2" class="headerlink" title="95.不同的二叉搜索树2"></a>95.不同的二叉搜索树2</h1><blockquote><p><a href="https://leetcode.cn/problems/unique-binary-search-trees-ii/description/">https://leetcode.cn/problems/unique-binary-search-trees-ii/description/</a></p></blockquote><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给你一个整数 n ，请你生成并返回所有由 n 个节点组成且节点值从 1 到 n 互不相同的不同 二叉搜索树 。可以按 任意顺序 返回答案。</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/04/a74b8f2a30da6f406cc7cd01228c856d.png" alt="image.png"></p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>这道题需要在96题的基础上，构造这些不同的二叉树并返回。</p><p>乍一看好像是一个回溯的思路，但个人感觉更像是一个普通的分治递归，回溯的思想体现的不是很明显。</p><p>首先基本的想法还是要把这个树进行拆分，可以用区间作为递归函数的参数，区间越界的时候就返回。</p><p>在那之前，我们需要确定递归的返回值。注意本题的返回值是一个<code>vector&lt;TreeNode*&gt;</code>数组，而且并<strong>不能</strong>套用回溯题中在<strong>递归返回时插入结果集</strong>的思路，那样是在叶子节点插入，而本题需要的是根节点。</p><p>所以我们应该直接用<code>vector&lt;TreeNode*&gt;</code>作为递归函数的返回值，在每一层的循环结束后返回这个数组。数组值的含义是以本层区间为根节点，可以得到的不同子树集合。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;TreeNode*&gt; curTree; <span class="comment">// 当前层可能的树的集合</span></span><br></pre></td></tr></table></figure><p>确定了返回值，就可以写出递归的终止条件了，区间不合法的时候，返回一个包含nullptr的空数组。即代表空节点。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 两个区间越界，返回空</span></span><br><span class="line"><span class="keyword">if</span> (begin &gt; end) &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;<span class="literal">nullptr</span>&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在每一层循环中，我们尝试使用begin和end中的任意一个节点作为二叉搜索树的根节点，然后递归遍历左区间和右区间，构造符合条件的子树数组。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = begin; i &lt;= end; i++) &#123;</span><br><span class="line"><span class="comment">// 递归左右区间，注意begin和end都是闭区间，应该跳过i自己</span></span><br><span class="line">vector&lt;TreeNode*&gt; leftTree = _generateTrees(begin, i - <span class="number">1</span>);</span><br><span class="line">    vector&lt;TreeNode*&gt; rightTree = _generateTrees(i + <span class="number">1</span>, end);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后再将得到的子树数组拼起来。此时拼起来的树就可以插入当前层的完整树数组中了</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 遍历左右子树，构造可能的树的集合</span></span><br><span class="line"><span class="comment">// 如果是叶子节点，此时left和right应该都是一个&#123;nullptr&#125;</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span>&amp; left : leftTree) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span>&amp; right : rightTree) &#123;</span><br><span class="line"><span class="comment">// 直接用构造函数传参</span></span><br><span class="line">TreeNode* root = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(i, left, right);</span><br><span class="line">curTree.<span class="built_in">push_back</span>(root);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后循环终止，将得到的curTree数组返回。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>完整代码如下。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    vector&lt;TreeNode*&gt; _generateTrees(<span class="type">int</span> begin, <span class="type">int</span> end) &#123;</span><br><span class="line">        <span class="comment">// 两个区间越界，返回空</span></span><br><span class="line">        <span class="keyword">if</span> (begin &gt; end) &#123;</span><br><span class="line">            <span class="keyword">return</span> &#123;<span class="literal">nullptr</span>&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">        vector&lt;TreeNode*&gt; curTree; <span class="comment">// 当前层可能的树的集合</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = begin; i &lt;= end; i++) &#123;</span><br><span class="line">            <span class="comment">// 获取左右子树的可能的树的集合，而不是单个树（递归子区间的树集合，直到空节点）</span></span><br><span class="line">            vector&lt;TreeNode*&gt; leftTree = _generateTrees(begin, i - <span class="number">1</span>);</span><br><span class="line">            vector&lt;TreeNode*&gt; rightTree = _generateTrees(i + <span class="number">1</span>, end);</span><br><span class="line">            <span class="comment">// 遍历左右子树，构造可能的树的集合</span></span><br><span class="line">            <span class="comment">// 如果是叶子节点，此时left和right应该都是一个&#123;nullptr&#125;</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; left : leftTree) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; right : rightTree) &#123;</span><br><span class="line">                    <span class="comment">// 直接用构造函数传参</span></span><br><span class="line">                    TreeNode* root = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(i, left, right);</span><br><span class="line">                    curTree.<span class="built_in">push_back</span>(root);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 返回给上一层</span></span><br><span class="line">        <span class="keyword">return</span> curTree;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;TreeNode*&gt; <span class="title">generateTrees</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 递归生成1到n的树</span></span><br><span class="line">        <span class="keyword">return</span> _generateTrees(<span class="number">1</span>, n);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/04/0f4b773bcfd55124ac01f2de30d12606.png" alt="image.png"></p><p>这道题和其他题目的区别在于，之前写的二叉树题目，大多数是构建单科树，我们直接用<code>TreeNode*</code>作为返回值，而这道题需要的是符合条件的树的集合，所以返回值需要改成vector。</p>]]></content>
    
    
    <summary type="html">leetcode刷题笔记-95.不同的二叉搜索树2</summary>
    
    
    
    <category term="编程学习" scheme="https://blog.musnow.top/categories/%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="把题目都给刷干净" scheme="https://blog.musnow.top/categories/%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0/%E6%8A%8A%E9%A2%98%E7%9B%AE%E9%83%BD%E7%BB%99%E5%88%B7%E5%B9%B2%E5%87%80/"/>
    
    
    <category term="OJ刷题" scheme="https://blog.musnow.top/tags/OJ%E5%88%B7%E9%A2%98/"/>
    
    <category term="leetcode" scheme="https://blog.musnow.top/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>【leetcode】96.不同的二叉搜索树</title>
    <link href="https://blog.musnow.top/posts/3165124961/"/>
    <id>https://blog.musnow.top/posts/3165124961/</id>
    <published>2024-04-23T04:42:36.000Z</published>
    <updated>2024-04-23T05:14:56.000Z</updated>
    
    <content type="html"><![CDATA[<p>leetcode刷题笔记，96.不同的二叉搜索树。</p><h1 id="96-不同的二叉搜索树"><a href="#96-不同的二叉搜索树" class="headerlink" title="96.不同的二叉搜索树"></a>96.不同的二叉搜索树</h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><blockquote><p><a href="https://leetcode.cn/problems/unique-binary-search-trees/">https://leetcode.cn/problems/unique-binary-search-trees/</a></p></blockquote><p>给你一个整数 n ，求恰由 n 个节点组成且节点值从 1 到 n 互不相同的 二叉搜索树 有多少种？返回满足题意的二叉搜索树的种数。</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/04/eccdeb0edf954d5beeb65a50b53b2d8e.png" alt="image.png"></p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>这道题是道动态规划的题目，动态规划的最重要的就是找到迭代的方程。</p><p>可以先举例几个不同的二叉搜索树情况，再找找有没有啥规律可循。首先是最简单的单个节点和两个节点的树，单个节点的二叉树只有1种情况，两个节点的二叉树有2种情况。</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/04/9f1f0931587a1accb88aff60544e6597.png" alt="image.png"></p><p>如果是三个节点的二叉搜索树呢？以leetcode给出的示例图</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/04/c0ed905aa1b3549575006342a0fb7908.png" alt="image.png"></p><p>从图中可以总结出三种不同的情况，假设<code>f(x)</code>为有x元素的二叉搜索树的种类个数。</p><ul><li>当1为根节点的时候，左子树为空，右子树2个元素，那么当前树的形态数量就是 <code>f(0) * f(2)</code>，即只由右边的两个元素的树的形态数量决定；</li><li>当2为根节点的时候，左右子树都有1个元素，此时树的形态数量是 <code>f(1) * f(1)</code>，即由两个元素只有1的树的形态数量组合决定；</li><li>当3为根节点的时候，右子树为空，左子树2个元素，这和1为根节点的情况类似，即当前树只由左边两个元素的树的形态数量决定，<code>f(2) * f(0)</code>；</li></ul><p>由此可得x为3的时候二叉搜索树的种类的计算公式</p><p>$$<br>f(3) &#x3D; f(0) * f(2) + f(1) * f(1) + f(2) * f(0)<br>$$</p><p>这里就还需要确定一下<code>f(0)</code>应该是什么值了，<strong>因为空树也可以视作树的一种情况</strong>，再加上在当前的递推公式种涉及到了对<code>f(0)</code>的计算，所以应该将其初始化为1。否则计算的时候相关的值都为0了。</p><p>上面的这个公式结论，还可以推广到i个节点的树的情况：</p><p>$$<br>f(i) &#x3D; f(0) * f(i-1) + f(1) * f(i-2) + … + f(i-1) * f(0)<br>$$</p><p>我们需要计算有n个节点的二叉搜索树种类，可以用这个递推公式一直从1计算到n，即可得到最终的结果。<strong>其本质就是将一个大的二叉搜索树不断拆分成小的树</strong>。</p><blockquote><p>关于拆分这一点，可以参考一篇写的还不错的<a href="https://leetcode.cn/problems/unique-binary-search-trees/solutions/331743/er-cha-sou-suo-shu-fu-xi-li-zi-jie-shi-si-lu-by-xi/">题解</a>，详细介绍了整个拆分的思路。</p><p>我们可以认为我们需要遍历的是一个1到n的数组，那么从这个数组中，不管从哪一个位置“提起”这棵树，最终得到的都是一个符合二叉搜索树规定的树（可以参考<a href="https://leetcode.cn/problems/convert-sorted-array-to-binary-search-tree/">从有序数组构造二叉搜索树</a>的OJ题）。这样我们就可以使用二分的思想不断将树拆分，直到拆分成只有1个元素的树的情况。</p></blockquote><p>那么代码中应该怎么处理呢？这里需要多层循环，我们需要将计算公式改成<strong>循环的累加</strong>（总不可能一直写个很长的公式吧）</p><p>首先外层循环是从1递推到n，内层循环是进行每一次有i个元素的二叉搜索树的节点数量计算。这样就实现了递推的计算。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// i代表当前树中有几个节点</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">    <span class="comment">// j是单个循环中的处理，我们需要从0 * i-1 一直走到 i-1 * 0</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= i; j++) &#123;</span><br><span class="line">        v[i] += v[j - <span class="number">1</span>] * v[i - j];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>完整代码如下，注意vector中的所有元素需要初始化为0，否则无法正常进行累加。根据上述思路将<code>v[0]=1</code>初始化，然后用循环一直计算到n，最后<code>v[n]</code>就是我们需要的结果。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">numTrees</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">v</span><span class="params">(n + <span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">        v[<span class="number">0</span>] = <span class="number">1</span>; <span class="comment">// 没有节点的数也算一颗树</span></span><br><span class="line">        <span class="comment">// i代表当前树中有几个节点</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="comment">// j是单个循环中的处理，我们需要从0 * i-1 一直走到 i-1 * 0</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= i; j++) &#123;</span><br><span class="line">                v[i] += v[j - <span class="number">1</span>] * v[i - j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> v[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 下面这个题解比较好理解一些。首先要知道这个题目的答案是可以被缩小范围的</span></span><br><span class="line"><span class="comment">// https://leetcode.cn/problems/unique-binary-search-trees/solutions/331743/er-cha-sou-suo-shu-fu-xi-li-zi-jie-shi-si-lu-by-xi/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 需要得出某个值为根节点的时候，这颗树的形态个数是(左边节点数量时的形态个数)*(右边节点数量时的形态个数)</span></span><br><span class="line"><span class="comment">// 以[1,2,3]为例</span></span><br><span class="line"><span class="comment">// 当1为根节点的时候，左子树为空，右子树2个元素，那么当前树的形态数量就是 f(0) * f(2)，即只由右边的两个元素的树的形态数量决定</span></span><br><span class="line"><span class="comment">// 当2为根节点的时候，左右子树都有1个元素，此时树的形态数量是 f(1) * f(1)，即由两个元素只有1的树的形态数量组合决定</span></span><br><span class="line"><span class="comment">// 当3为根节点的时候，右子树为空，左子树2个元素，这和1为根节点的情况类似，即当前树只由左边两个元素的树的形态数量决定，f(2) * f(0)</span></span><br><span class="line"><span class="comment">// 这下就可以得到公式 f(3) = f(0) * f(2) + f(1) * f(1) + f(2) * f(0)</span></span><br><span class="line"><span class="comment">// 进一步得到i的公式 f(i) = f(0) * f(i-1) + f(1) * f(i-2) + ... + f(i-1) * f(0)</span></span><br><span class="line"><span class="comment">// 我们要做的就是把这个公式转换成一个循环中的累加，即上面代码中的for循环。</span></span><br><span class="line"><span class="comment">// 注意vector中的值应该都初始化为0，不然累加的时候会出问题。</span></span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/04/c99f72733da40e98adc4c08fdfd29207.png" alt="image.png"></p>]]></content>
    
    
    <summary type="html">leetcode刷题笔记-96.不同的二叉搜索树</summary>
    
    
    
    <category term="编程学习" scheme="https://blog.musnow.top/categories/%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="把题目都给刷干净" scheme="https://blog.musnow.top/categories/%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0/%E6%8A%8A%E9%A2%98%E7%9B%AE%E9%83%BD%E7%BB%99%E5%88%B7%E5%B9%B2%E5%87%80/"/>
    
    
    <category term="OJ刷题" scheme="https://blog.musnow.top/tags/OJ%E5%88%B7%E9%A2%98/"/>
    
    <category term="leetcode" scheme="https://blog.musnow.top/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>【Linux】如何用一条命令终止某个后台进程？</title>
    <link href="https://blog.musnow.top/posts/656037608/"/>
    <id>https://blog.musnow.top/posts/656037608/</id>
    <published>2024-04-23T01:14:50.000Z</published>
    <updated>2024-04-23T02:57:16.000Z</updated>
    
    <content type="html"><![CDATA[<p>在面试的时候被问道了这个问题，之前还从来没有了解过</p><h1 id="1-怎么终止某个进程？"><a href="#1-怎么终止某个进程？" class="headerlink" title="1.怎么终止某个进程？"></a>1.怎么终止某个进程？</h1><p>如果你学过Linux下的信号处理，这个问题应该不难答。在Linux下，使用kill命令发送信号给进程，其中9号信号<code>SIGKILL</code>就可以将进程终止。</p><p>还有很多其他信号也能终止进程，比如前台进程使用<code>CTRL+C</code>会发送2号信号，也能终止进程。但是9号信号<strong>是不能被自定义捕获</strong>的，进程收到9号信号后一定会被终止。</p><p>后台进程就需要我们知道这个进程的名字，然后查询这个进程的PID，再用kill发送信号将其终止。在之前我都是用下面这两个命令来处理的</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ps jax | grep 进程名 | grep -v grep</span><br><span class="line">kill -9 进程PID</span><br></pre></td></tr></table></figure><p>现在的问题就变成了，如何将这两条命令变成一条命令？</p><h1 id="2-如何用一条命令终止后台进程？"><a href="#2-如何用一条命令终止后台进程？" class="headerlink" title="2.如何用一条命令终止后台进程？"></a>2.如何用一条命令终止后台进程？</h1><h2 id="2-1-pkill-x2F-killall"><a href="#2-1-pkill-x2F-killall" class="headerlink" title="2.1 pkill&#x2F;killall"></a>2.1 pkill&#x2F;killall</h2><p>在Linux下除了kill命令，还有这两个命令，他们可以通过传入进程名字来删除某个进程</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pkill 进程名</span><br><span class="line">killall 进程名</span><br></pre></td></tr></table></figure><p>如下所示，我用c语言写了个死循环的程序，并让其后台运行。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">❯ ./test &amp;</span><br><span class="line">[1] 2578</span><br></pre></td></tr></table></figure><p>随后，可以使用pkill命令直接终止这个程序</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">❯ ps jax | grep test | grep -v grep</span><br><span class="line">   2265    2578    2578    2265 pts/5       3337 SN    1000   0:00 ./test</span><br><span class="line">❯ pkill test                       </span><br><span class="line">[1]  + 2578 terminated  ./test</span><br></pre></td></tr></table></figure><p>killall命令也是同理，需要注意的是，如果有两个同名的进程，这两个进程都会被终止。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">❯ killall test</span><br><span class="line">[1]  - 7309 terminated  ./test</span><br><span class="line">[2]  + 7327 terminated  ./test</span><br></pre></td></tr></table></figure><p>pkill和killall的区别在于，pkill是用正则捕获的方式来查询某个进程的，即输入test，实际上会删除所有进程名中包含test的进程。而killall则是完全捕获，必须是名字为test的进程才会被删除。</p><p>如下所示，使用<code>pkill est</code>命令，同样会删除test进程。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">❯ pkill est                        </span><br><span class="line">[1]  + 7664 terminated  ./test</span><br></pre></td></tr></table></figure><p>而killall则不会，会显示该进程名找不到对应进程。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">❯ killall est </span><br><span class="line">est: no process found</span><br></pre></td></tr></table></figure><h2 id="2-2-ps-kill-管道"><a href="#2-2-ps-kill-管道" class="headerlink" title="2.2 ps+kill+管道"></a>2.2 ps+kill+管道</h2><p>因为没有接触过上面的pkill命令，所以我当时面试的时候只能想到通过管道的方式来查询进程PID并将其传给kill命令。不过因为对linux下命令行的管道了解的并不多，具体怎么写命令也说不出来。</p><p>我们知道，使用ps命令的时候，显示的数据中第二列是该进程的PID，第一列是父进程的PID。即我们需要想办法把这个结果中第二列的值给取出来。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">❯ ps jax | grep test | grep -v grep                          </span><br><span class="line">   2265    9356    9356    2265 pts/5       9450 SN    1000   0:00 ./test</span><br></pre></td></tr></table></figure><p>使用awk命令就能做到这一点，从匹配的行中取出第二列，即得到了我们需要的进程PID。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">❯ ps jax | grep test | grep -v grep | awk &#x27;&#123;print $2&#125;&#x27;</span><br><span class="line">9356</span><br></pre></td></tr></table></figure><p>现在要做的就是用<code>$</code>号将这个命令的结果传给kill命令，这样就实现了用一条命令终止进程了。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">❯ kill -9 $(ps jax | grep test | grep -v grep | awk &#x27;&#123;print $2&#125;&#x27;)</span><br><span class="line">[1]  + 9356 killed     ./test  </span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">Linux下如何用一条命令终止某个后台进程？</summary>
    
    
    
    <category term="编程学习" scheme="https://blog.musnow.top/categories/%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="Linux" scheme="https://blog.musnow.top/categories/%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0/Linux/"/>
    
    
    <category term="Linux" scheme="https://blog.musnow.top/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>【leetcode】62不同路径和63不同路径2</title>
    <link href="https://blog.musnow.top/posts/4112588292/"/>
    <id>https://blog.musnow.top/posts/4112588292/</id>
    <published>2024-04-20T02:31:40.000Z</published>
    <updated>2024-04-21T10:15:09.000Z</updated>
    
    <content type="html"><![CDATA[<p>leetcode刷题笔记-62不同路径和63不同路径2</p><h1 id="62-不同路径"><a href="#62-不同路径" class="headerlink" title="62 不同路径"></a>62 不同路径</h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><blockquote><p><a href="https://leetcode.cn/problems/unique-paths/">https://leetcode.cn/problems/unique-paths/</a></p></blockquote><p>一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为 “Start” ）。</p><p>机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为 “Finish” ）。</p><p>问总共有多少条不同的路径？</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/04/5e4de878ae09ea64c4aab67e2e471800.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">示例 2：</span><br><span class="line">输入：m = 3, n = 2</span><br><span class="line">输出：3</span><br><span class="line">解释：</span><br><span class="line">从左上角开始，总共有 3 条路径可以到达右下角。</span><br><span class="line">1. 向右 -&gt; 向下 -&gt; 向下</span><br><span class="line">2. 向下 -&gt; 向下 -&gt; 向右</span><br><span class="line">3. 向下 -&gt; 向右 -&gt; 向下</span><br><span class="line"></span><br><span class="line">示例 3：</span><br><span class="line">输入：m = 7, n = 3</span><br><span class="line">输出：28</span><br><span class="line"></span><br><span class="line">示例 4：</span><br><span class="line">输入：m = 3, n = 3</span><br><span class="line">输出：6</span><br></pre></td></tr></table></figure><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>这道题需要用动态规划的方式来写。首先是确定递归数组每一位代表什么。根据题意可以想出来<code>dp[i][j]</code>代表走到<code>(i,j)</code>位置的可行步骤数量。</p><p>随后是考虑递归方程，因为机器人只能向右和向下走，很容易得到下面的方程。即能到达当前位置的方法是走到左边那位（下一步往右走）和上面那位（下一步向下走）的步骤数之和。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dp[i][j] = dp[i-1][j] + dp[i][j-1]</span><br></pre></td></tr></table></figure><p>再考虑怎么设置这个数组的初始值。因为机器人只能向下和向右走，即这个数组的第一行和第一列都只有一种办法可以抵达，即将第一行和第一列中的值都初始化为1。</p><p>再从<code>(1,1)</code>下标位置开始，使用公式计算出所有的值，并最终返回<code>dp[m-1][n-1]</code>作为答案。</p><h2 id="代码1：二维数组"><a href="#代码1：二维数组" class="headerlink" title="代码1：二维数组"></a>代码1：二维数组</h2><p>代码如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">uniquePaths</span><span class="params">(<span class="type">int</span> m, <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// m 是行，n是列</span></span><br><span class="line">        <span class="comment">// dp方程是 dp[i][j] = dp[i-1][j] + dp[i][j-1]</span></span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">v</span>(m, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(n));</span><br><span class="line">        <span class="comment">// 因为只能向右和向下走，从0,0开始</span></span><br><span class="line">        <span class="comment">// 所以能直接推出来一部分结果，将第一行和第一列都初始化为1</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">            v[i][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">            v[<span class="number">0</span>][j] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 其他部分是用dp计算</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; m; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt; n; j++) &#123;</span><br><span class="line">                <span class="comment">// 当前的路径数量是上一位往右（v[i][j-1]）和上一位往下（v[i - 1][j]）的和</span></span><br><span class="line">                v[i][j] = v[i - <span class="number">1</span>][j] + v[i][j - <span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> v[m - <span class="number">1</span>][n - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/04/2621d414d668164ac684f75daa9c1f94.png" alt="image.png"></p><h2 id="代码2：一维数组"><a href="#代码2：一维数组" class="headerlink" title="代码2：一维数组"></a>代码2：一维数组</h2><p>上述代码中的时间复杂度不好优化，但是空间复杂度是可以优化的。我们可以将这个二维数组改成一个n长度（每一行）的一维数组。</p><p>首先是将这个数组初始化为1（因为第一行只有1种方式可以到达）。</p><p>然后同样是从下标<code>(1,1)</code>位置开始遍历，此时的方程是<code>dp[i] += dp[i-1]</code>。</p><p>用这种方式，巧妙的将二维的操作改成了一维的。加等操作相当于保留了上一行的结果，加上<code>dp[i-1]</code>相当于保留了左边那位（下一步向右走）的结果。这个思路很巧妙，建议画个矩阵来自行理解一下。</p><p>最终的代码如下。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">uniquePaths</span><span class="params">(<span class="type">int</span> m, <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 初始化为1，相当于将第一行设置为1</span></span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(n, <span class="number">1</span>)</span></span>;</span><br><span class="line">        <span class="comment">// 从第二行开始</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; m; i++) &#123;</span><br><span class="line">            <span class="comment">// 从第二列开始，相当于保留第一列始终为1</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt; n; j++) &#123;</span><br><span class="line">                <span class="comment">// += 保留上一行的结果</span></span><br><span class="line">                <span class="comment">// 加上 dp[j-1] 等于左边的结果</span></span><br><span class="line">                dp[j] += dp[j - <span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 返回左下角的结果</span></span><br><span class="line">        <span class="keyword">return</span> dp[n - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/04/052de7e5d4df2cc9f20993a1500ff8d8.png" alt="image.png"></p><h1 id="63-不同路径2"><a href="#63-不同路径2" class="headerlink" title="63 不同路径2"></a>63 不同路径2</h1><h2 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h2><blockquote><p><a href="https://leetcode.cn/problems/unique-paths-ii/description/">https://leetcode.cn/problems/unique-paths-ii/description/</a></p></blockquote><p>一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为 “Start” ）。</p><p>机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为 “Finish”）。</p><p>现在考虑网格中有障碍物。那么从左上角到右下角将会有多少条不同的路径？</p><p>网格中的障碍物和空位置分别用 1 和 0 来表示。</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/04/f5be15ab447e49687ba1f38c75328b40.png" alt="image.png"></p><h2 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h2><p>这道题在62题的基础上多加了一个障碍物，遇到障碍物肯定就无法抵达了，需要我们针对障碍物进行处理。</p><p>先采用上一题的二维数组的思路，考虑遇到障碍物应该怎么处理。这里我想的办法是用<code>-1</code>来标识障碍物，即当前位置无法到达。</p><ul><li>第一行和第一列有障碍物，往后的位置都无法抵达，往后的位置都要初始化为<code>-1</code>；</li><li>判断<code>obstacleGrid[i][j]</code>是否有障碍物，有则<code>dp[i][j]</code>为<code>-1</code>，无法抵达；</li><li><code>dp[i][j]</code>需要判断<code>dp[i-1][j]</code> 和 <code>dp[i][j-1]</code> 这两个位置是否有障碍物<ul><li>如果两个位置都是负一，则代表<code>dp[i][j]</code>无法到达，初始化为<code>-1</code>；</li><li>只有一个位置是负一，则代表当前位置可以到达，值为不为负一的那一个；</li><li>两个位置都不为负一，则是正常的情况，值为<code>dp[i-1][j] + dp[i][j-1]</code>。</li></ul></li></ul><p>把这些情况都考虑上，只需要在原本的代码上修改一下就可以了</p><h2 id="代码1"><a href="#代码1" class="headerlink" title="代码1"></a>代码1</h2><p>特别要注意的是第一行和第一列的情况，因为他们都只有一条可行的路径，那只要遇到了一个阻碍，后面的位置就都到不了了！都需要赋值为0！</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">uniquePathsWithObstacles</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; obstacleGrid)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> m = obstacleGrid.<span class="built_in">size</span>(), n = obstacleGrid[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        <span class="comment">// m 是行，n是列</span></span><br><span class="line">        <span class="comment">// dp方程是 dp[i][j] = dp[i-1][j] + dp[i][j-1]</span></span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">v</span>(m, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(n));</span><br><span class="line">        <span class="comment">// 因为只能向右和向下走，从0,0开始</span></span><br><span class="line">        <span class="comment">// 所以能直接推出来一部分结果，将第一行和第一列都初始化为1</span></span><br><span class="line">        <span class="type">bool</span> isBlock = <span class="literal">false</span>; <span class="comment">// 是否有阻碍？</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (obstacleGrid[i][<span class="number">0</span>] == <span class="number">1</span> || isBlock) &#123;</span><br><span class="line">                v[i][<span class="number">0</span>] = <span class="number">-1</span>; <span class="comment">// 不能走的初始化为负一</span></span><br><span class="line">                isBlock = <span class="literal">true</span>; <span class="comment">// 注意，只要有一个阻碍，就不能往下走了</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                v[i][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        isBlock = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (obstacleGrid[<span class="number">0</span>][j] == <span class="number">1</span> || isBlock) &#123;</span><br><span class="line">                v[<span class="number">0</span>][j] = <span class="number">-1</span>; <span class="comment">// 不能走的初始化为负一</span></span><br><span class="line">                isBlock = <span class="literal">true</span>; <span class="comment">// 注意，只要有一个阻碍，就不能往下走了</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                v[<span class="number">0</span>][j] = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 其他部分是用dp计算</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; m; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt; n; j++) &#123;</span><br><span class="line">                <span class="comment">// 当前的路径数量是上一位往右（v[i][j-1]）和上一位往下（v[i-1][j]）的和</span></span><br><span class="line">                <span class="comment">// 但是需要判断能不能走到这里，如果两个路径都不能走，则跳过这个位置</span></span><br><span class="line">                <span class="type">int</span> left = v[i][j - <span class="number">1</span>];</span><br><span class="line">                <span class="type">int</span> up = v[i - <span class="number">1</span>][j];</span><br><span class="line">                <span class="comment">// 两个都不能走，或者当前位置有障碍，说明当前位置到不了</span></span><br><span class="line">                <span class="keyword">if</span> (obstacleGrid[i][j] == <span class="number">1</span> || (left &lt; <span class="number">0</span> &amp;&amp; up &lt; <span class="number">0</span>)) &#123;</span><br><span class="line">                    v[i][j] = <span class="number">-1</span>;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 到的了，修正值</span></span><br><span class="line">                <span class="keyword">if</span> (left &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                    left = <span class="number">0</span>; <span class="comment">// 不能走的初始化为0</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (up &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                    up = <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                v[i][j] = up + left;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 因为我是用-1来设置到不了的，最终就需要修正为0</span></span><br><span class="line">        <span class="keyword">return</span> v[m - <span class="number">1</span>][n - <span class="number">1</span>] == <span class="number">-1</span> ? <span class="number">0</span> : v[m - <span class="number">1</span>][n - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/04/51435a0609c3c9afd0ee358a29958919.png" alt="image.png"></p><h2 id="代码2"><a href="#代码2" class="headerlink" title="代码2"></a>代码2</h2><p>实际上完全不需要用负一来标识到不了，每一次还需要判断将其修正为0。我们直接用0代表到不了就行了，可以节省几个判断，代码看起来也会舒服一点。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">uniquePathsWithObstacles</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; obstacleGrid)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// m 是行，n是列</span></span><br><span class="line">        <span class="type">int</span> m = obstacleGrid.<span class="built_in">size</span>(), n = obstacleGrid[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">v</span>(m, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(n));</span><br><span class="line">        <span class="comment">// 因为只能向右和向下走，从0,0开始</span></span><br><span class="line">        <span class="comment">// 所以能直接推出来一部分结果，将第一行和第一列都初始化为1</span></span><br><span class="line">        <span class="type">bool</span> isBlock = <span class="literal">false</span>; <span class="comment">// 是否有阻碍？</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (obstacleGrid[i][<span class="number">0</span>] == <span class="number">1</span> || isBlock) &#123;</span><br><span class="line">                v[i][<span class="number">0</span>] = <span class="number">0</span>; <span class="comment">// 不能走的初始化为0</span></span><br><span class="line">                isBlock = <span class="literal">true</span>; <span class="comment">// 注意，只要有一个阻碍，就不能往下走了</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                v[i][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        isBlock = <span class="literal">false</span>; <span class="comment">// 是否有阻碍？</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (obstacleGrid[<span class="number">0</span>][j] == <span class="number">1</span> || isBlock) &#123;</span><br><span class="line">                v[<span class="number">0</span>][j] = <span class="number">0</span>; <span class="comment">// 不能走的初始化为0</span></span><br><span class="line">                isBlock = <span class="literal">true</span>; <span class="comment">// 注意，只要有一个阻碍，就不能往下走了</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                v[<span class="number">0</span>][j] = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 其他部分是用dp计算</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; m; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt; n; j++) &#123;</span><br><span class="line">                <span class="comment">// 当前的路径数量是上一位往右（v[i][j-1]）和上一位往下（v[i-1][j]）的和</span></span><br><span class="line">                <span class="comment">// 但是需要判断能不能走到这里，如果两个路径都不能走，则跳过这个位置</span></span><br><span class="line">                <span class="type">int</span> left = v[i][j - <span class="number">1</span>];</span><br><span class="line">                <span class="type">int</span> up = v[i - <span class="number">1</span>][j];</span><br><span class="line">                <span class="comment">// 两个都不能走，或者当前位置有障碍，说明当前位置到不了</span></span><br><span class="line">                <span class="keyword">if</span> (obstacleGrid[i][j] == <span class="number">1</span> || (left &lt;= <span class="number">0</span> &amp;&amp; up &lt;= <span class="number">0</span>)) &#123;</span><br><span class="line">                    v[i][j] = <span class="number">0</span>; <span class="comment">// 走不了</span></span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                v[i][j] = up + left;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> v[m - <span class="number">1</span>][n - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/04/4a5ed2590bcf1250401ea4c807849f15.png" alt="image.png"></p>]]></content>
    
    
    <summary type="html">leetcode刷题笔记-62不同路径和63不同路径2</summary>
    
    
    
    <category term="编程学习" scheme="https://blog.musnow.top/categories/%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="把题目都给刷干净" scheme="https://blog.musnow.top/categories/%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0/%E6%8A%8A%E9%A2%98%E7%9B%AE%E9%83%BD%E7%BB%99%E5%88%B7%E5%B9%B2%E5%87%80/"/>
    
    
    <category term="OJ刷题" scheme="https://blog.musnow.top/tags/OJ%E5%88%B7%E9%A2%98/"/>
    
    <category term="leetcode" scheme="https://blog.musnow.top/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>【C语言】static和extern的作用</title>
    <link href="https://blog.musnow.top/posts/3198614716/"/>
    <id>https://blog.musnow.top/posts/3198614716/</id>
    <published>2024-04-18T04:21:36.000Z</published>
    <updated>2024-04-19T05:11:05.000Z</updated>
    
    <content type="html"><![CDATA[<p>简单介绍C&#x2F;C++中static关键字和extern关键字的作用。</p><h1 id="1-简介"><a href="#1-简介" class="headerlink" title="1.简介"></a>1.简介</h1><p>在之前的博客中，提到过static的三个作用，但是没有详细说明这三个作用的场景，现在回过头来记录一下。</p><ol><li>修饰函数</li><li>修饰全局变量</li><li>修饰函数内变量</li></ol><p>static还有一个隐藏的特性，即变量会被默认设置为0，因为静态区&#x2F;全局区的内存区域在初始化的时候都是0。</p><p>在C++的类和对象中，static还多了一个作用，即修饰C++类的成员变量或函数。被修饰的成员属于整个类，可以直接通过类的作用域来访问（前提是公有），这不是本文的重点。</p><h1 id="2-static修饰函数-x2F-变量"><a href="#2-static修饰函数-x2F-变量" class="headerlink" title="2.static修饰函数&#x2F;变量"></a>2.static修饰函数&#x2F;变量</h1><p>对于修饰函数和变量而言，作用基本是一致的，即限制这个函数&#x2F;变量的作用域，让他只对当前文件可见。</p><h2 id="修饰变量"><a href="#修饰变量" class="headerlink" title="修饰变量"></a>修饰变量</h2><p>给定下面两个文件</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// a.cpp</span></span><br><span class="line"><span class="type">int</span> aGlobal = <span class="number">10</span>;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> bGlobal = <span class="number">20</span>;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// b.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 声明文件a.cpp中的全局变量</span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">int</span> aGlobal;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; aGlobal &lt;&lt; endl;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在<code>b.cpp</code>中，使用了extern关键字来声明属于另外一个cpp文件中的全局变量，用如下命令编译成可执行文件test。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">g++ b.cpp a.cpp -o test</span><br></pre></td></tr></table></figure><p>在Ubuntu上进行测试，编译成功，运行能成功打印出10，符合预期。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">❯ g++ a.cpp b.cpp -o test</span><br><span class="line">❯ ./test</span><br><span class="line">10</span><br></pre></td></tr></table></figure><p>而被static修饰过的bGlobal就不能用这种方式被另外一个文件访问了。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// b.cpp 修改后</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 声明文件a.cpp中的全局变量</span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">int</span> bGlobal;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; bGlobal &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用相同的命令进行编译，此时就会报错了。因为static关键字将bGlobal这个全局变量的作用域限制在了<code>a.cpp</code>文件中，其他文件无法访问！</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">❯ g++ a.cpp b.cpp -o test</span><br><span class="line">/usr/bin/ld: /tmp/ccj43Xl9.o: warning: relocation against `bGlobal&#x27; in read-only section `.text&#x27;</span><br><span class="line">/usr/bin/ld: /tmp/ccj43Xl9.o: in function `main&#x27;:</span><br><span class="line">b.cpp:(.text+0xa): undefined reference to `bGlobal&#x27;</span><br><span class="line">/usr/bin/ld: warning: creating DT_TEXTREL in a PIE</span><br><span class="line">collect2: error: ld returned 1 exit status</span><br></pre></td></tr></table></figure><p>这里有个必须要注意的点，我们在<code>b.cpp</code>中并没有<code>#include &quot;a.cpp&quot;</code>，如果添加了include，那么上面的结论就无效了。因为include会在预编译期间被展开，此时<code>a.cpp</code>中的全局变量定义直接被添加在了<code>b.cpp</code>上面，并不属于两个文件的情况。比如下面的代码就可以正常编译通过。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 错误的测试逻辑</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;a.cpp&quot;</span> <span class="comment">// 引用了a.cpp</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 声明文件a.cpp中的全局变量？此时a.cpp都已经被展开了，完全不是另外一个文件了！</span></span><br><span class="line"><span class="comment">// extern int bGlobal; // 这一行加不加没有任何区别</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; bGlobal &lt;&lt; endl;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如下所示，编译成功且打印了bGlobal的值</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">❯ g++ b.cpp -o test</span><br><span class="line">❯ ./test</span><br><span class="line">20</span><br></pre></td></tr></table></figure><p>注意这里编译的时候不能再添加<code>a.cpp</code>了，因为此时已经被展开到了<code>b.cpp</code>之前，如果这样编译就会报错aGlobal重定义。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">❯ g++ a.cpp b.cpp -o test</span><br><span class="line">/usr/bin/ld: /tmp/cckcj9a5.o:(.data+0x0): multiple definition of `aGlobal&#x27;; /tmp/ccsNnuaN.o:(.data+0x0): first defined here</span><br><span class="line">collect2: error: ld returned 1 exit status</span><br></pre></td></tr></table></figure><h2 id="修饰函数"><a href="#修饰函数" class="headerlink" title="修饰函数"></a>修饰函数</h2><p>修饰函数的作用同理，没有修饰的函数可以被另外一个文件extern后调用，修饰后的不可以。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// a.cpp</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Add</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a+b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// b.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 声明文件a.cpp中的函数</span></span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="type">int</span> <span class="title">Add</span><span class="params">(<span class="type">int</span>,<span class="type">int</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="built_in">Add</span>(<span class="number">10</span>,<span class="number">20</span>) &lt;&lt; endl;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译成功，且调用Add函数成功。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">❯ g++ a.cpp b.cpp -o test</span><br><span class="line">❯ ./test</span><br><span class="line">30</span><br></pre></td></tr></table></figure><p>Add函数添加了static后就无法被extern调用了</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">❯ g++ a.cpp b.cpp -o test</span><br><span class="line">/usr/bin/ld: /tmp/ccFe9oSW.o: in function `main&#x27;:</span><br><span class="line">b.cpp:(.text+0x13): undefined reference to `Add(int, int)&#x27;</span><br><span class="line">collect2: error: ld returned 1 exit status</span><br></pre></td></tr></table></figure><h1 id="3-static修饰函数内变量"><a href="#3-static修饰函数内变量" class="headerlink" title="3.static修饰函数内变量"></a>3.static修饰函数内变量</h1><p>你可能见过这样的写法，在函数内定义一个static变量，并作为返回值</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">char</span>* <span class="title">Add</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span></span>&#123;</span><br><span class="line"><span class="type">static</span> <span class="type">char</span> arr[<span class="number">2</span>];</span><br><span class="line">arr[<span class="number">0</span>] = (<span class="type">char</span>)a + <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">arr[<span class="number">1</span>] = (<span class="type">char</span>)b + <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line"><span class="keyword">return</span> arr; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用static修饰函数内的变量后，这个变量的作用域不再是函数体内了，而是扩展到了全局（可以理解为他就是一个全局变量）。</p><p>这种方式可以避免使用动态内存管理（malloc&#x2F;free）的空间作为返回值，因为那样可能会出现内存泄漏问题。比较常见的一个应用就是linux下的<code>inet_ntoa</code>函数，这个函数可以将IP地址的结构体转为IP的字符串，其内部就是用static的char数组作为返回值的，这也是为什么该函数不能在printf中连续调用，会导致后续的调用覆盖前面的结果。</p><blockquote><p>如果有函数是利用static作为返回值传参的，则应该用另外一个变量拷贝来保存这个结果，再执行下一次调用。</p></blockquote><p>需要注意的是，<strong>static的这一行定义只会在第一次进入函数的时候执行</strong>，后续不再会执行。比如下面的代码，如果你对static修饰的作用不太了解，你可能会认为isGood这个变量每次进入该函数都会被设置为false，从而只会让他进入if判断体的A区域，搞得这个if判断都没有意义了。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">TestFunc</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="type">static</span> <span class="type">bool</span> isGood = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">if</span>(!isGood)&#123;</span><br><span class="line"><span class="comment">// A...</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// B...</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但实际上，<strong>这个变量只有第一次调用这个函数的时候会被创建且赋值为false</strong>，后续不再会执行static这一行，所以函数体内（A区域和B区域可能会做一些处理再设置isGood变量的值）对isGood值的修改会沿用到下一次调用这个函数！</p><h1 id="4-static和编译"><a href="#4-static和编译" class="headerlink" title="4.static和编译"></a>4.static和编译</h1><p>为什么被static修饰的函数&#x2F;变量不会被其他文件看见？</p><p>因为在生成符号表的时候，每一个static变量即便变量名相同，也会<strong>生成不同的符号表项</strong>。所以在链接阶段符号表合并的时候，并不会将两个文件中同名的static变量合并在一起，所以其他文件也就没有办法访问到当前文件中被static修饰的函数&#x2F;变量。</p><p>而extern了一个static变量，<strong>就会因为符号表无法找到，而链接失败</strong>。注意观察G++的报错，都是ld和<code>.o</code>相关字样的，说明这个并不是编译器通过语法检查出来的错误，而是在链接<code>.o</code>目标文件的时候，发现无法链接该变量的时候因为错误而退出编译的。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">❯ g++ a.cpp b.cpp -o test</span><br><span class="line">/usr/bin/ld: /tmp/ccj43Xl9.o: warning: relocation against `bGlobal&#x27; in read-only section `.text&#x27;</span><br><span class="line">/usr/bin/ld: /tmp/ccj43Xl9.o: in function `main&#x27;:</span><br><span class="line">b.cpp:(.text+0xa): undefined reference to `bGlobal&#x27;</span><br><span class="line">/usr/bin/ld: warning: creating DT_TEXTREL in a PIE</span><br><span class="line">collect2: error: ld returned 1 exit status</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">简单介绍C中static关键字和extern关键字的作用。</summary>
    
    
    
    <category term="编程学习" scheme="https://blog.musnow.top/categories/%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="C语言" scheme="https://blog.musnow.top/categories/%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0/C%E8%AF%AD%E8%A8%80/"/>
    
    
    <category term="C语言" scheme="https://blog.musnow.top/tags/C%E8%AF%AD%E8%A8%80/"/>
    
    <category term="Cpp" scheme="https://blog.musnow.top/tags/Cpp/"/>
    
  </entry>
  
  <entry>
    <title>【leetcode】23.合并K个升序链表</title>
    <link href="https://blog.musnow.top/posts/788614935/"/>
    <id>https://blog.musnow.top/posts/788614935/</id>
    <published>2024-04-16T10:36:39.000Z</published>
    <updated>2024-04-17T07:13:29.000Z</updated>
    
    <content type="html"><![CDATA[<p>leetcode刷题笔记-23-合并K个升序链表</p><h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><blockquote><p><a href="https://leetcode.cn/problems/merge-k-sorted-lists/description/">https://leetcode.cn/problems/merge-k-sorted-lists/description/</a></p></blockquote><p>给你一个链表数组，每个链表都已经按升序排列。</p><p>请你将所有链表合并到一个升序链表中，返回合并后的链表。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">示例 1：</span><br><span class="line">输入：lists = [[1,4,5],[1,3,4],[2,6]]</span><br><span class="line">输出：[1,1,2,3,4,4,5,6]</span><br><span class="line">解释：链表数组如下：</span><br><span class="line">[</span><br><span class="line">  1-&gt;4-&gt;5,</span><br><span class="line">  1-&gt;3-&gt;4,</span><br><span class="line">  2-&gt;6</span><br><span class="line">]</span><br><span class="line">将它们合并到一个有序链表中得到。</span><br><span class="line">1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4-&gt;5-&gt;6</span><br><span class="line"></span><br><span class="line">示例 2：</span><br><span class="line">输入：lists = []</span><br><span class="line">输出：[]</span><br><span class="line"></span><br><span class="line">示例 3：</span><br><span class="line">输入：lists = [[]]</span><br><span class="line">输出：[]</span><br></pre></td></tr></table></figure><p>最简单的思路就是用一个数组记录所有链表，再用sort将这个数组重排序，最后连成一个完整的升序链表。</p><h1 id="思路1"><a href="#思路1" class="headerlink" title="思路1"></a>思路1</h1><p>思路1是用小堆来处理。</p><p>因为给出的链表已经是升序的，所以最终的有序链表的头节点，一定是给定的链表中的其中一个的头节点。</p><p>那么第二个节点呢？可能是另外一个链表的头节点，也有可能是当前选中的这个链表的第二个节点。比如下面的例子，第一个节点是2，第二个节点并不是其他链表的头节点，而是这一个链表的第二个节点3。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">10 - 23</span><br><span class="line">5 - 6 </span><br><span class="line">2 - 3 - 7</span><br></pre></td></tr></table></figure><p>所以我们需要用小堆来维护最终的大小关系，首先是遍历给出的链表数组，将所有链表的头节点插入小堆，随后取出堆顶元素，链入最终链表，如果这个节点还有下一个节点，那么就将下一个节点也插入小堆。</p><p>这样才能保证最终的顺序性。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>注意，使用小堆需要用STD提供的<code>priority_queue</code>容器，并自己写一个仿函数来比较两个链表节点的大小。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="comment">// 注意优先级队列的传参是一个仿函数类</span></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">MyCmp</span> &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(ListNode* l, ListNode* r)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> l-&gt;val &gt; r-&gt;val; <span class="comment">// 小堆</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">mergeKLists</span><span class="params">(vector&lt;ListNode*&gt;&amp; lists)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 用最小堆来实现，注意最小堆是大的往上题，cmp中是大于</span></span><br><span class="line">        priority_queue&lt;ListNode*, vector&lt;ListNode*&gt;, MyCmp&gt; que;</span><br><span class="line">        <span class="comment">// 把不为空的链表头节点插入，因为链表本来都是升序的</span></span><br><span class="line">        <span class="comment">// 那么最终的有序链表的第一个节点肯定是某一个链表的头节点</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; i : lists) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">                que.<span class="built_in">push</span>(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 新建一个烧饼节点</span></span><br><span class="line">        ListNode* phead = <span class="keyword">new</span> ListNode;</span><br><span class="line">        ListNode* cur = phead;</span><br><span class="line">        <span class="keyword">while</span> (!que.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="comment">// 取出头节点</span></span><br><span class="line">            ListNode* head = que.<span class="built_in">top</span>();</span><br><span class="line">            que.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="comment">// 如果有下一个节点，插入最小堆</span></span><br><span class="line">            <span class="keyword">if</span> (head-&gt;next != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">                que.<span class="built_in">push</span>(head-&gt;next);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 将其连入链表</span></span><br><span class="line">            cur-&gt;next = head;</span><br><span class="line">            cur = cur-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> phead-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/04/222f9ff8ab3420eed6c464aeb1babcc7.png" alt="image.png"></p><h1 id="思路2"><a href="#思路2" class="headerlink" title="思路2"></a>思路2</h1><p>方法2就是用之前写过的<a href="https://leetcode.cn/problems/merge-two-sorted-lists/description/">21.合并两个有序链表</a>的练习。每次都选中两个链表进行合并，直到最终合并所有链表。</p><p>这里可以采用分治的思路，将链表数组拆分后进行合并。</p><h2 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="function">ListNode* <span class="title">mergeTwoLists</span><span class="params">(ListNode* list1, ListNode* list2)</span> </span>&#123;</span><br><span class="line">        ListNode* head = <span class="keyword">new</span> ListNode;</span><br><span class="line">        ListNode* oldHead = head;</span><br><span class="line">        ListNode *cur1 = list1, *cur2 = list2;</span><br><span class="line">        <span class="keyword">while</span> (cur1 != <span class="literal">nullptr</span> &amp;&amp; cur2 != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (cur1-&gt;val &gt;= cur2-&gt;val) &#123;</span><br><span class="line">                head-&gt;next = cur2;</span><br><span class="line">                head = head-&gt;next;</span><br><span class="line">                cur2 = cur2-&gt;next;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                head-&gt;next = cur1;</span><br><span class="line">                head = head-&gt;next;</span><br><span class="line">                cur1 = cur1-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (cur1 == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            head-&gt;next = cur2;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            head-&gt;next = cur1;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> oldHead-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 合并从 lists[i] 到 lists[j-1] 的链表</span></span><br><span class="line">    <span class="function">ListNode* <span class="title">mergeKLists</span><span class="params">(vector&lt;ListNode*&gt;&amp; lists, <span class="type">int</span> i, <span class="type">int</span> j)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> m = j - i;</span><br><span class="line">        <span class="keyword">if</span> (m == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nullptr</span>; <span class="comment">// 注意输入的 lists 可能是空的</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (m == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> lists[i]; <span class="comment">// 无需合并，直接返回</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">auto</span> left = <span class="built_in">mergeKLists</span>(lists, i, i + m / <span class="number">2</span>);  <span class="comment">// 合并左半部分</span></span><br><span class="line">        <span class="keyword">auto</span> right = <span class="built_in">mergeKLists</span>(lists, i + m / <span class="number">2</span>, j); <span class="comment">// 合并右半部分</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">mergeTwoLists</span>(left, right); <span class="comment">// 最后把左半和右半合并</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">mergeKLists</span><span class="params">(vector&lt;ListNode*&gt;&amp; lists)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">mergeKLists</span>(lists, <span class="number">0</span>, lists.<span class="built_in">size</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">leetcode刷题笔记-23-合并K个升序链表</summary>
    
    
    
    <category term="编程学习" scheme="https://blog.musnow.top/categories/%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="把题目都给刷干净" scheme="https://blog.musnow.top/categories/%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0/%E6%8A%8A%E9%A2%98%E7%9B%AE%E9%83%BD%E7%BB%99%E5%88%B7%E5%B9%B2%E5%87%80/"/>
    
    
    <category term="OJ刷题" scheme="https://blog.musnow.top/tags/OJ%E5%88%B7%E9%A2%98/"/>
    
    <category term="链表" scheme="https://blog.musnow.top/tags/%E9%93%BE%E8%A1%A8/"/>
    
    <category term="堆" scheme="https://blog.musnow.top/tags/%E5%A0%86/"/>
    
    <category term="leetcode" scheme="https://blog.musnow.top/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>【leetcode】2两数相加和989数组数字的相加问题</title>
    <link href="https://blog.musnow.top/posts/1455984707/"/>
    <id>https://blog.musnow.top/posts/1455984707/</id>
    <published>2024-04-14T07:13:00.000Z</published>
    <updated>2024-04-14T07:50:40.000Z</updated>
    
    <content type="html"><![CDATA[<p>leetcode刷题笔记：2和989这类数字一位一位相加的问题</p><h1 id="通用模板"><a href="#通用模板" class="headerlink" title="通用模板"></a>通用模板</h1><p>对于数字一位一位相加的问题，一般就是leetcode第2题链表的形式，和第989题数组的形式。参考leetcode上大佬的题解，会有一个通用的<a href="https://leetcode.cn/problems/add-to-array-form-of-integer/solutions/570659/989-ji-zhu-zhe-ge-jia-fa-mo-ban-miao-sha-8y9r/">加法模板</a>。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">进位carry初始化为0</span><br><span class="line">while ( A 没完 || B 没完 )&#123;</span><br><span class="line">    A 的当前位</span><br><span class="line">    B 的当前位</span><br><span class="line"></span><br><span class="line">    和 = A 的当前位 + B 的当前位 + 进位carry</span><br><span class="line"></span><br><span class="line">    当前位 = 和 % 10;</span><br><span class="line">    进位 = 和 / 10;</span><br><span class="line">&#125;</span><br><span class="line">判断是否还有进位？</span><br></pre></td></tr></table></figure><p>只要依靠这个模板，就能把这两道题很轻松的写出来。</p><h1 id="989-数组形式的整数加法"><a href="#989-数组形式的整数加法" class="headerlink" title="989.数组形式的整数加法"></a>989.数组形式的整数加法</h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><blockquote><p><a href="https://leetcode.cn/problems/add-to-array-form-of-integer/">https://leetcode.cn/problems/add-to-array-form-of-integer/</a></p></blockquote><p>整数的 数组形式  num 是按照从左到右的顺序表示其数字的数组。</p><p>例如，对于 <code>num = 1321</code> ，数组形式是 <code>[1,3,2,1]</code> 。</p><p>给定 num ，整数的 数组形式 ，和整数 k ，返回 整数 num + k 的 数组形式 。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">示例 1：</span><br><span class="line">输入：num = [1,2,0,0], k = 34</span><br><span class="line">输出：[1,2,3,4]</span><br><span class="line">解释：1200 + 34 = 1234</span><br><span class="line"></span><br><span class="line">示例 2：</span><br><span class="line">输入：num = [2,7,4], k = 181</span><br><span class="line">输出：[4,5,5]</span><br><span class="line">解释：274 + 181 = 455</span><br><span class="line"></span><br><span class="line">示例 3：</span><br><span class="line">输入：num = [2,1,5], k = 806</span><br><span class="line">输出：[1,0,2,1]</span><br><span class="line">解释：215 + 806 = 1021</span><br></pre></td></tr></table></figure><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>按上文提供的模板，写这道题是比较容易的，因为数组本身是可以随机访问的，我们从后往前遍历数组，按位与k的当前位相加就可以了。</p><p>注意，使用vector做返回值时，我们应该采用先尾插最后逆置的方式，效率会远高于每次都头插。因为vector的头插涉及到了其他元素的移动。</p><p>当然，你也可以选择链表来进行头插，最终再转成vector返回。</p><p>这里面要注意的是，虽然while的判断条件中已经有了判断，但是两个判断条件是通过<code>||</code>或连接的，可能会出现数组已经结束了，但是k还有位数（或反之）的情况，在操作a和b的时候一定要先进行判断再赋值。</p><p>当然，也可以选择用<code>&amp;&amp;</code>与链接，并在while之后单独处理数组或k剩下的数。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">addToArrayForm</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; num, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; retV;</span><br><span class="line">        <span class="type">int</span> i = num.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> carry = <span class="number">0</span>; <span class="comment">// 进位</span></span><br><span class="line">        <span class="comment">// 有一个不为0就需要继续加</span></span><br><span class="line">        <span class="keyword">while</span> (i &gt;= <span class="number">0</span> || k != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 可能有一个已经结束了，需要判断</span></span><br><span class="line">            <span class="type">int</span> a = i &gt;= <span class="number">0</span> ? num[i] : <span class="number">0</span>;</span><br><span class="line">            <span class="type">int</span> b = k != <span class="number">0</span> ? k % <span class="number">10</span> : <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">            <span class="type">int</span> sum = a + b + carry;</span><br><span class="line">            <span class="type">int</span> cur = sum % <span class="number">10</span>;          <span class="comment">// 当前位</span></span><br><span class="line">            carry = (sum &gt;= <span class="number">10</span>) ? <span class="number">1</span> : <span class="number">0</span>; <span class="comment">// 如果超过10了需要进位</span></span><br><span class="line">            <span class="comment">// 插入数组</span></span><br><span class="line">            retV.<span class="built_in">push_back</span>(cur);</span><br><span class="line">            <span class="comment">// 走下一位去</span></span><br><span class="line">            i--;</span><br><span class="line">            k /= <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 还有进位，需要再插入一个</span></span><br><span class="line">        <span class="keyword">if</span> (carry != <span class="number">0</span>) &#123;</span><br><span class="line">            retV.<span class="built_in">push_back</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 注意，我们插入是尾插（vector头插效率很低），需要逆置</span></span><br><span class="line">        <span class="built_in">reverse</span>(retV.<span class="built_in">begin</span>(), retV.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">return</span> retV;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/04/3dd4d93b32c706b3a81670877ff35a1f.png" alt="image.png"></p><h1 id="2-两数相加"><a href="#2-两数相加" class="headerlink" title="2.两数相加"></a>2.两数相加</h1><blockquote><p><a href="https://leetcode.cn/problems/add-two-numbers/description/">https://leetcode.cn/problems/add-two-numbers/description/</a></p></blockquote><h2 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h2><p>给你两个 非空 的链表，表示两个非负的整数。它们每位数字都是按照 <strong>逆序</strong> 的方式存储的，并且每个节点只能存储 一位 数字。</p><p>请你将两个数相加，并以相同形式返回一个表示和的链表。</p><p>你可以假设除了数字 0 之外，这两个数都不会以 0 开头。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">示例 1：</span><br><span class="line">输入：l1 = [2,4,3], l2 = [5,6,4]</span><br><span class="line">输出：[7,0,8]</span><br><span class="line">解释：342 + 465 = 807.</span><br><span class="line"></span><br><span class="line">示例 2：</span><br><span class="line">输入：l1 = [0], l2 = [0]</span><br><span class="line">输出：[0]</span><br><span class="line"></span><br><span class="line">示例 3：</span><br><span class="line">输入：l1 = [9,9,9,9,9,9,9], l2 = [9,9,9,9]</span><br><span class="line">输出：[8,9,9,9,0,0,0,1]</span><br></pre></td></tr></table></figure><h2 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h2><p>这道题虽然给的是链表，无法随机访问，但是链表是逆序存放的数字，本就符合我们从低位往高位相加的思路。</p><p>基本代码和上文一致，当某个链表结束之后，就将其视作0继续操作。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">addTwoNumbers</span><span class="params">(ListNode* l1, ListNode* l2)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 有一个为空的时候可以直接返回另外一个</span></span><br><span class="line">        <span class="keyword">if</span>(l1 == <span class="literal">nullptr</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> l2;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(l2 == <span class="literal">nullptr</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> l1;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ListNode* phead = <span class="keyword">new</span> ListNode;</span><br><span class="line">        ListNode* cur = phead;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> carry = <span class="number">0</span>; <span class="comment">// 进位制</span></span><br><span class="line">        ListNode* left = l1,*right = l2;</span><br><span class="line">        <span class="comment">// 有一个不为空就需要继续</span></span><br><span class="line">        <span class="keyword">while</span>(left != <span class="literal">nullptr</span> || right !=<span class="literal">nullptr</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> a = left != <span class="literal">nullptr</span>?left-&gt;val:<span class="number">0</span>;</span><br><span class="line">            <span class="type">int</span> b = right != <span class="literal">nullptr</span>?right-&gt;val:<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">            <span class="type">int</span> sum = a+b+carry;</span><br><span class="line">            <span class="type">int</span> val = sum % <span class="number">10</span>; <span class="comment">// 当前值</span></span><br><span class="line">            carry = sum&gt;=<span class="number">10</span>?<span class="number">1</span>:<span class="number">0</span>;</span><br><span class="line">            <span class="comment">// 注意，题目要求的是按相同的方式（数字逆序存放）来返回一个链表</span></span><br><span class="line">            <span class="comment">// 所以我们需要进行尾插操作</span></span><br><span class="line">            cur-&gt;next = <span class="keyword">new</span> <span class="built_in">ListNode</span>(val);</span><br><span class="line">            cur = cur-&gt;next;</span><br><span class="line">            <span class="comment">// 去下一位</span></span><br><span class="line">            <span class="keyword">if</span>(left != <span class="literal">nullptr</span>)&#123;    </span><br><span class="line">                left=left-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(right != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">                right=right-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 还有值，需要再尾插一个。</span></span><br><span class="line">        <span class="keyword">if</span>(carry!=<span class="number">0</span>)&#123;</span><br><span class="line">            cur-&gt;next = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> phead-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>备注：上面的代码中，phead指针出现内存泄漏了，但是写OJ的时候并不关心内存泄漏问题。</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/04/f3c0df34a05e87a15ff126f081a3e91d.png" alt="image.png"></p><h1 id="165-比较版本号"><a href="#165-比较版本号" class="headerlink" title="165.比较版本号"></a>165.比较版本号</h1><h2 id="题目-2"><a href="#题目-2" class="headerlink" title="题目"></a>题目</h2><blockquote><p><a href="https://leetcode.cn/problems/compare-version-numbers/description/">https://leetcode.cn/problems/compare-version-numbers/description/</a></p></blockquote><p>给你两个版本号 version1 和 version2 ，请你比较它们。</p><p>版本号由一个或多个修订号组成，各修订号由一个 <code>&#39;.&#39;</code> 连接。每个修订号由 多位数字 组成，可能包含 前导零 。每个版本号至少包含一个字符。修订号从左到右编号，下标从 0 开始，最左边的修订号下标为 0 ，下一个修订号下标为 1 ，以此类推。例如，<code>2.5.33</code> 和 <code>0.1</code> 都是有效的版本号。</p><p>比较版本号时，请按从左到右的顺序依次比较它们的修订号。比较修订号时，只需比较 忽略任何前导零后的整数值 。也就是说，修订号 1 和修订号 001 相等 。如果版本号没有指定某个下标处的修订号，则该修订号视为 0 。例如，版本 1.0 小于版本 1.1 ，因为它们下标为 0 的修订号相同，而下标为 1 的修订号分别为 0 和 1 ，0 &lt; 1 。</p><p>返回规则如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">如果 version1 &gt; version2 返回 1，</span><br><span class="line">如果 version1 &lt; version2 返回 -1，</span><br><span class="line">除此之外返回 0。</span><br></pre></td></tr></table></figure><p>示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">示例 1：</span><br><span class="line">输入：version1 = &quot;1.01&quot;, version2 = &quot;1.001&quot;</span><br><span class="line">输出：0</span><br><span class="line">解释：忽略前导零，&quot;01&quot; 和 &quot;001&quot; 都表示相同的整数 &quot;1&quot;</span><br><span class="line"></span><br><span class="line">示例 2：</span><br><span class="line">输入：version1 = &quot;1.0&quot;, version2 = &quot;1.0.0&quot;</span><br><span class="line">输出：0</span><br><span class="line">解释：version1 没有指定下标为 2 的修订号，即视为 &quot;0&quot;</span><br><span class="line"></span><br><span class="line">示例 3：</span><br><span class="line">输入：version1 = &quot;0.1&quot;, version2 = &quot;1.1&quot;</span><br><span class="line">输出：-1</span><br><span class="line">解释：version1 中下标为 0 的修订号是 &quot;0&quot;，version2 中下标为 0 的修订号是 &quot;1&quot; 。0 &lt; 1，所以 version1 &lt; version2</span><br></pre></td></tr></table></figure><p>提示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1 &lt;= version1.length, version2.length &lt;= 500</span><br><span class="line">version1 和 version2 仅包含数字和 &#x27;.&#x27;</span><br><span class="line">version1 和 version2 都是 有效版本号</span><br><span class="line">version1 和 version2 的所有修订号都可以存储在 32 位整数 中</span><br></pre></td></tr></table></figure><h2 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h2><p>上文提到的累计相加的思路同样可以扩大到字符串比较的题目中。只要有一个没有结束就继续比较，直到两个字符串都结束或找到结果。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">compareVersion</span><span class="params">(string version1, string version2)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> left = <span class="number">0</span>, right = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (left &lt; version1.<span class="built_in">size</span>() || right &lt; version2.<span class="built_in">size</span>()) &#123;</span><br><span class="line">            <span class="comment">// version1求和</span></span><br><span class="line">            <span class="type">int</span> leftSum = <span class="number">0</span>;</span><br><span class="line">            <span class="comment">// 这里并不需要对前导0做任何判断，因为初始值就是0，前导0操作后还是0</span></span><br><span class="line">            <span class="keyword">for</span> (; left &lt; version1.<span class="built_in">size</span>() &amp;&amp; version1[left] != <span class="string">&#x27;.&#x27;</span>; left++) &#123;</span><br><span class="line">                leftSum = leftSum * <span class="number">10</span> + (version1[left] - <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            left++; <span class="comment">// 跳过点</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// version2求和</span></span><br><span class="line">            <span class="type">int</span> rightSum = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (; right &lt; version2.<span class="built_in">size</span>() &amp;&amp; version2[right] != <span class="string">&#x27;.&#x27;</span>; right++) &#123;</span><br><span class="line">                rightSum = rightSum * <span class="number">10</span> + (version2[right] - <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            right++; <span class="comment">// 跳过点</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 不相同就说明有一个大了，判断一下</span></span><br><span class="line">            <span class="keyword">if</span> (leftSum != rightSum) &#123;</span><br><span class="line">                <span class="keyword">return</span> leftSum &gt; rightSum ? <span class="number">1</span> : <span class="number">-1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/04/004f1d885560d3d71f86d7c8a79314a3.png" alt="image.png"></p><p>这道题的另外一个思路就是通过<code>&#39;.&#39;</code>字符将两个字符串切割出来，再依次比较版本号。但是那样会有更大的时间复杂度消耗，逻辑也不是很清晰，不如直接在循环内处理。</p>]]></content>
    
    
    <summary type="html">leetcode刷题笔记：2和989这类数字一位一位相加的问题</summary>
    
    
    
    <category term="编程学习" scheme="https://blog.musnow.top/categories/%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="把题目都给刷干净" scheme="https://blog.musnow.top/categories/%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0/%E6%8A%8A%E9%A2%98%E7%9B%AE%E9%83%BD%E7%BB%99%E5%88%B7%E5%B9%B2%E5%87%80/"/>
    
    
    <category term="OJ刷题" scheme="https://blog.musnow.top/tags/OJ%E5%88%B7%E9%A2%98/"/>
    
    <category term="leetcode" scheme="https://blog.musnow.top/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>【网络】QUIC协议和HTTP3</title>
    <link href="https://blog.musnow.top/posts/2259793534/"/>
    <id>https://blog.musnow.top/posts/2259793534/</id>
    <published>2024-04-11T03:17:57.000Z</published>
    <updated>2024-04-14T08:50:25.000Z</updated>
    
    <content type="html"><![CDATA[<p>面试常考，临时抱佛脚学一下</p><h1 id="HTTP2的升级"><a href="#HTTP2的升级" class="headerlink" title="HTTP2的升级"></a>HTTP2的升级</h1><p>总结就是：1：steam并发传输、2：哈夫曼编码HPACK压缩header为二进制后传输、3：服务器可以主动推送资源给客户端。</p><p><strong>并发传输</strong>就是在HTTP中添加一个steamID，通过ID来标识不同的HTTP请求报文，这样就能在同一个TCP传输流中并发传输多个HTTP报文。而在HTTP1.1中，虽然可以复用同一个TCP链接，但是HTTP1.1中在某个请求没有收到响应之前，是无法传输给其他</p><p><strong>压缩header</strong>：通过哈夫曼编码在双方建立一个动态表，其中包括61项常用header的静态表，同时可以对静态表进行动态扩展（需要使用但不在61项中的header），最终发送header的时候，会用序号来替代header的字符串，同时对header的value进行压缩，从而减少HTTP包的长度。</p><p><strong>服务器主动推送</strong>：请求一个资源后，服务器可以主动将其他客户端用的上的资源推送给客户端，而不需要等客户端主动请求。比如请求<code>index.html</code>后，将需要的js&#x2F;css也推送给客户端。</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/04/bdf5cbb21a7a3f384e42edc7e5d74c08.png" alt="image.png"></p><h1 id="QUIC可靠性保证"><a href="#QUIC可靠性保证" class="headerlink" title="QUIC可靠性保证"></a>QUIC可靠性保证</h1><p>其实这个问题就是UDP如何保证可靠性（加什么东西？），把TCP可靠性机制往里面加就行了。</p><ol><li>重传机制</li><li>确认机制</li><li>握手机制（快速握手）</li><li>拥塞控制（应用层处理的）</li><li>多路复用（多个stream并发）</li><li>前向纠错（校验码）</li></ol><h1 id="QUIC的特点"><a href="#QUIC的特点" class="headerlink" title="QUIC的特点"></a>QUIC的特点</h1><blockquote><p><a href="https://www.xiaolincoding.com/network/2_http/http3.html#%E6%9B%B4%E5%BF%AB%E7%9A%84%E8%BF%9E%E6%8E%A5%E5%BB%BA%E7%AB%8B">https://www.xiaolincoding.com/network/2_http/http3.html#%E6%9B%B4%E5%BF%AB%E7%9A%84%E8%BF%9E%E6%8E%A5%E5%BB%BA%E7%AB%8B</a></p></blockquote><h2 id="无队头阻塞"><a href="#无队头阻塞" class="headerlink" title="无队头阻塞"></a>无队头阻塞</h2><p>无队头阻塞：HTTP2中用tcp实现多stream并发传输，但是tcp本身需要保证数据到达应用层的有序性。假设有这样的报文到达顺序</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">stream1 tcp1</span><br><span class="line">stream2 tcp2</span><br><span class="line">stream1 tcp3 # 丢包</span><br><span class="line">stream2 tcp4</span><br><span class="line">stream3 tcp5</span><br></pre></td></tr></table></figure><p>此时tcp3出现了丢包，虽然我们客户端已经收到了服务器发送的stream2(tcp4)和stream3(tcp5)，但因为tcp协议栈<strong>需要维护序号有序性</strong>，没有收到tcp3之前，它不会把后序的数据交付给上层，这就导致了stream2&#x2F;3因为stream1的丢包而出现了阻塞，也就是<code>队头阻塞</code>的含义。</p><p>而QUIC基于UDP，因为UDP本身是无连接的，所以它不会出现队头阻塞的问题。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">stream1 udp3 # 丢包</span><br><span class="line">stream2 udp4</span><br><span class="line">stream3 udp5</span><br></pre></td></tr></table></figure><p>即便udp3丢包了，也不会影响udp4&#x2F;5，此时steam2&#x2F;3也能被正常交付给上层供HTTP使用。</p><p>反映到浏览器加载中，有可能这里的udp4&#x2F;5就是steam2&#x2F;3的最后一个分片，交付给上层后就已组成了一个完整的HTTP报文，表现在浏览器上就是某一个模块加载出来了，会让用户的体验更好。</p><h2 id="更快的链接建立"><a href="#更快的链接建立" class="headerlink" title="更快的链接建立"></a>更快的链接建立</h2><p>在通过TCP实现HTTPS的时候，需要涉及到TCP三次握手和TLS&#x2F;SSL握手。其中TCP三次握手和SSL握手都要进行3次数据传输，一共就是6次单向传输了（3RTT）。</p><p>而UDP实现的QUIC也需要握手，这个过程是1RTT。但是QUIC本身就是一个应用层实现的协议，它可以直接在第一次链接的时候就携带TLS&#x2F;SSL的相关信息，第二次链接的时候发送QUIC握手报文+TLS握手报文和数据载荷，同时完成TLS握手的功能，近似实现0RTT的握手。</p><blockquote><p>这里涉及到了TLS1.3，先暂且不去深入了解，知道大概就行。</p></blockquote><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/04/f97be469c526cb19338a066b1120c368.png" alt="image.png"></p><h2 id="链接迁移"><a href="#链接迁移" class="headerlink" title="链接迁移"></a>链接迁移</h2><p>在基于TCP的HTTP中，需要通过IP和TCP端口的四元组来定位客户端和服务端。</p><p>假设我们从WIFI切换成4G&#x2F;5G，此时客户端的ip和端口肯定会发生变化，而在旧版本中，这就需要使用TCP重新和服务器进行三次握手和TLS链接建立，才能重新开始数据传输。</p><p>而QUIC中，除了IP&#x2F;UDP的四元组外，还有个独特的QUIC会话ID来标识两边的传输。</p><p>假设一个客户端从WIFI切换成5G，发生了IP和端口的变化，但它发送的QUIC请求报文中，依旧包含了之前的<strong>QUIC会话ID</strong>，此时服务器可以通过这个会话ID定位之前的传输，并继续传输之前中断的时候的数据。</p><p>再加上前文提到的QUIC握手次数少，这两个相结合，客户端切换IP和端口的时间消耗就更少了！</p><h1 id="HTTP3的QPACK"><a href="#HTTP3的QPACK" class="headerlink" title="HTTP3的QPACK"></a>HTTP3的QPACK</h1><p>在HTTP2中，会用HPACK来将更新后的动态header表发送给对方，但是它的HPACK并没有确认机制。也就是说，如果你发送的一个新的HPACK更新丢包了，对方没有收到，也就不认识某个新的header序号，此时客户端发送的信息就没有办法被正常解码了，此时会出现阻塞。</p><p>而QPACK就是在HPACK的基础上加入了确认机制。有两个链接来进行</p><ul><li>一个叫 QPACK Encoder Stream，用于将一个字典（Key-Value）传递给对方，比如面对不属于静态表的 HTTP 请求头部，客户端可以通过这个 Stream 发送字典；</li><li>一个叫 QPACK Decoder Stream，用于响应对方，告诉它刚发的字典已经更新到自己的本地动态表了，后续就可以使用这个字典来编码了。</li></ul><p>这两个特殊的单向流是用来同步双方的动态表，编码方收到解码方更新确认的通知后，才使用动态表编码 HTTP 头部。</p><p>当A给B发送的动态表没有被收到时，A还不会对这个新的header进行压缩（以原始形式进行发送）。直到收到B对这个动态表的响应了，才会压缩传输。</p><p>这样就避免了HPACK中A会压缩发送一个<strong>B还不知道</strong>的动态表中的header的情况。</p>]]></content>
    
    
    <summary type="html">QUIC协议和HTTP3简介</summary>
    
    
    
    <category term="编程学习" scheme="https://blog.musnow.top/categories/%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="计算机网络" scheme="https://blog.musnow.top/categories/%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
    <category term="计算机网络" scheme="https://blog.musnow.top/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    <category term="面经" scheme="https://blog.musnow.top/tags/%E9%9D%A2%E7%BB%8F/"/>
    
  </entry>
  
  <entry>
    <title>【算法】贪心算法</title>
    <link href="https://blog.musnow.top/posts/3488338229/"/>
    <id>https://blog.musnow.top/posts/3488338229/</id>
    <published>2024-04-07T02:33:18.000Z</published>
    <updated>2024-04-16T01:14:54.000Z</updated>
    
    <content type="html"><![CDATA[<p>贪心算法学习</p><h1 id="基本理论"><a href="#基本理论" class="headerlink" title="基本理论"></a>基本理论</h1><p>贪心算法的基本理论是“从局部最优推出全局最优”。</p><p>每一次小操作都是在选择局部最优，最终得到的结果就是一个全局最优。</p><p>当一个题目能满足这个思路的时候，就可以尝试使用贪心了。</p><h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><h2 id="455-分发饼干"><a href="#455-分发饼干" class="headerlink" title="455 分发饼干"></a>455 分发饼干</h2><blockquote><p><a href="https://leetcode.cn/problems/assign-cookies/">https://leetcode.cn/problems/assign-cookies/</a></p></blockquote><h3 id="题目和思路"><a href="#题目和思路" class="headerlink" title="题目和思路"></a>题目和思路</h3><p>假设你是一位很棒的家长，想要给你的孩子们一些小饼干。但是，每个孩子最多只能给一块饼干。</p><p>对每个孩子 i，都有一个胃口值 <code>g[i]</code>，这是能让孩子们满足胃口的饼干的最小尺寸；并且每块饼干 j，都有一个尺寸 <code>s[j]</code> 。如果 <code>s[j] &gt;= g[i]</code>，我们可以将这个饼干 j 分配给孩子 i ，这个孩子会得到满足。你的目标是尽可能满足越多数量的孩子，并输出这个最大数值。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">示例 1:</span><br><span class="line">输入: g = [1,2,3], s = [1,1]</span><br><span class="line">输出: 1</span><br><span class="line">解释: </span><br><span class="line">你有三个孩子和两块小饼干，3个孩子的胃口值分别是：1,2,3。</span><br><span class="line">虽然你有两块小饼干，由于他们的尺寸都是1，你只能让胃口值是1的孩子满足。</span><br><span class="line">所以你应该输出1。</span><br><span class="line"></span><br><span class="line">示例 2:</span><br><span class="line">输入: g = [1,2], s = [1,2,3]</span><br><span class="line">输出: 2</span><br><span class="line">解释: </span><br><span class="line">你有两个孩子和三块小饼干，2个孩子的胃口值分别是1,2。</span><br><span class="line">你拥有的饼干数量和尺寸都足以让所有孩子满足。</span><br><span class="line">所以你应该输出2.</span><br></pre></td></tr></table></figure><p>这道题的思路其实很简单，即我们每次都应该选择大饼干满足大胃口的人，这样才能让最终可以吃到饼干的小孩最多。</p><p>直接排序两个数组，从右往左遍历，判断当前饼干是否能满足当前胃口的人，如果可以，则消耗一个饼干，并让计数器加一。不可以，则继续往左遍历胃口。</p><p>在这个例子中，局部最优是用大饼干满足大胃口的，全局最优是最终能吃上饼干的孩子最多。</p><h3 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h3><p>代码中需要注意对index的越界检查，特别是数组s为空的情况。当index已经越界的时候，就可以跳出循环了。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">findContentChildren</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; g, vector&lt;<span class="type">int</span>&gt;&amp; s)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">sort</span>(g.<span class="built_in">begin</span>(), g.<span class="built_in">end</span>());</span><br><span class="line">        <span class="built_in">sort</span>(s.<span class="built_in">begin</span>(), s.<span class="built_in">end</span>());</span><br><span class="line">        <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> index = s.<span class="built_in">size</span>() - <span class="number">1</span>; <span class="comment">// 饼干最后一个</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = g.<span class="built_in">size</span>() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="keyword">if</span> (index &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (s[index] &gt;= g[i]) &#123;</span><br><span class="line">                index--;</span><br><span class="line">                count++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="376-摆动序列"><a href="#376-摆动序列" class="headerlink" title="376 摆动序列"></a>376 摆动序列</h2><blockquote><p><a href="https://leetcode.cn/problems/wiggle-subsequence/description/">https://leetcode.cn/problems/wiggle-subsequence/description/</a></p></blockquote><h3 id="题目和思路-1"><a href="#题目和思路-1" class="headerlink" title="题目和思路"></a>题目和思路</h3><p>如果连续数字之间的差严格地在正数和负数之间交替，则数字序列称为 摆动序列 。第一个差（如果存在的话）可能是正数或负数。仅有一个元素或者含两个不等元素的序列也视作摆动序列。</p><p>例如， [1, 7, 4, 9, 2, 5] 是一个 摆动序列 ，因为差值 (6, -3, 5, -7, 3) 是正负交替出现的。</p><p>相反，[1, 4, 7, 2, 5] 和 [1, 7, 4, 5, 5] 不是摆动序列，第一个序列是因为它的前两个差值都是正数，第二个序列是因为它的最后一个差值为零。</p><p><strong>子序列</strong> 可以通过从原始序列中删除一些（也可以不删除）元素来获得，剩下的元素保持其原始顺序。</p><p>给你一个整数数组 nums ，返回 nums 中作为 摆动序列 的 最长子序列的长度 。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">示例 1：</span><br><span class="line">输入：nums = [1,7,4,9,2,5]</span><br><span class="line">输出：6</span><br><span class="line">解释：整个序列均为摆动序列，各元素之间的差值为 (6, -3, 5, -7, 3) 。</span><br><span class="line"></span><br><span class="line">示例 2：</span><br><span class="line">输入：nums = [1,17,5,10,13,15,10,5,16,8]</span><br><span class="line">输出：7</span><br><span class="line">解释：这个序列包含几个长度为 7 摆动序列。</span><br><span class="line">其中一个是 [1, 17, 10, 13, 10, 16, 8] ，各元素之间的差值为 (16, -7, 3, -3, 6, -8) 。</span><br><span class="line"></span><br><span class="line">示例 3：</span><br><span class="line">输入：nums = [1,2,3,4,5,6,7,8,9]</span><br><span class="line">输出：2</span><br></pre></td></tr></table></figure><p>首先需要拆分情况，除了正常的一上一下的折线图，还可能会出现下面的情况，这些情况都必须特别来处理。</p><ul><li>连续的上坡或连续的下坡</li><li>上坡下坡之间有平地</li><li>上坡和上坡之间有平地（下坡和下坡之间有平地）</li></ul><p>先来看第一个，<strong>连续的上坡或者连续的下坡的情况</strong>：这需要我们将连续的上坡只看作一个上坡，比如上坡有3个节点（包括坡底和坡顶），那么最终可以计算的只有一个（坡顶，坡底已经计算过了）。</p><p><strong>上坡下坡之间有平地的情况</strong>：将平地其他节点删除，只计算一个节点。</p><p><strong>上坡和上坡之间有平地</strong>：将平地删除成一个节点，此时就变成了情况1的连续上坡&#x2F;下坡。</p><blockquote><p>具体示意图的可以参考代码随想录：<a href="https://www.programmercarl.com/0376.%E6%91%86%E5%8A%A8%E5%BA%8F%E5%88%97.html#%E6%80%9D%E8%B7%AF">https://www.programmercarl.com/0376.%E6%91%86%E5%8A%A8%E5%BA%8F%E5%88%97.html#%E6%80%9D%E8%B7%AF</a></p></blockquote><h3 id="错误代码"><a href="#错误代码" class="headerlink" title="错误代码"></a>错误代码</h3><p>最开始的时候，我写出了这样一版代码，它的问题在于，只能处理子数组的情况（子数组是连续的），而不能处理子序列（中间可以不连续）。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">wiggleMaxLength</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 判断上一个diff是正数还是负数，正数设置为1，负数设置为-1</span></span><br><span class="line">        <span class="type">int</span> lastDiff = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> maxLength = <span class="number">-1</span>;</span><br><span class="line">        <span class="type">int</span> curLength = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; nums.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="type">int</span> diff = nums[i] - nums[i - <span class="number">1</span>];</span><br><span class="line">            cout &lt;&lt; nums[i] &lt;&lt; <span class="string">&quot; - &quot;</span> &lt;&lt; nums[i - <span class="number">1</span>] &lt;&lt; <span class="string">&quot; = &quot;</span> &lt;&lt; diff &lt;&lt; <span class="string">&quot; : &quot;</span></span><br><span class="line">                 &lt;&lt; curLength &lt;&lt; <span class="string">&quot;  f:&quot;</span> &lt;&lt; lastDiff &lt;&lt; endl;</span><br><span class="line">            <span class="keyword">if</span> (diff &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// 不符合条件，从当前位开始新算一个子数组</span></span><br><span class="line">                <span class="keyword">if</span> (lastDiff == <span class="number">1</span>) &#123;</span><br><span class="line">                    curLength = <span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 符合条件</span></span><br><span class="line">                curLength++;</span><br><span class="line">                maxLength = <span class="built_in">max</span>(curLength, maxLength);</span><br><span class="line">                <span class="comment">// 设置LastDiff</span></span><br><span class="line">                lastDiff = <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 不符合</span></span><br><span class="line">                <span class="keyword">if</span> (lastDiff == <span class="number">-1</span>) &#123;</span><br><span class="line">                    curLength = <span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 符合条件</span></span><br><span class="line">                curLength++;</span><br><span class="line">                maxLength = <span class="built_in">max</span>(curLength, maxLength);</span><br><span class="line">                <span class="comment">// 设置LastDiff</span></span><br><span class="line">                lastDiff = <span class="number">-1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxLength == <span class="number">-1</span> ? <span class="number">0</span> : maxLength;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="正确代码"><a href="#正确代码" class="headerlink" title="正确代码"></a>正确代码</h3><p>这里面，用curDiff记录当前的差值，preDiff记录上一个有变动的差值，result是返回值。</p><p>result初始化为1是因为判断是在<code>nums.size() - 2</code>就结束的（最后一个节点并没有被循环计入其中），而且当数组长度为2的时候，判断只会有一次，如果不置1就会漏掉一个值。</p><p>以下图为例，这是一个<strong>上坡和下坡之中有平坡</strong>的情况，如下的代码在循环中判断的是i和i+1，最终会在<code>nums.size() - 2</code>位置（图中已标注）跳出循环。此时<code>result++</code>是只加入了<code>nums.size() - 2</code>的这个点，而没有加入<code>nums.size() - 1</code>这个同样需要被加入的点，所以需要将result初始化为1来覆盖这种漏掉的情况。</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/04/feb535b0482c5164d16cec60ab748168.png" alt="image.png"></p><p>下面是详细的判断逻辑：</p><ul><li><code>preDiff &lt; 0 &amp;&amp; curDiff &gt; 0</code> 和 <code>preDiff &gt;0 &amp;&amp; curDiff &lt; 0</code> 是最基本的上坡和下坡情况，当前差值和之前的并非同正同负；</li><li><code>preDiff == 0 &amp;&amp; curDiff &gt; 0</code> 和 <code>preDiff == 0 &amp;&amp; curDiff &lt; 0</code> 的情况满足上文所述“上坡下坡之间有平地的情况，此时也需要记录摆动的变化。</li><li>只在摆动变化的时候记录preDiff就可以忽略“上坡和上坡之间有平地”的情况（如果不这么做，就会多记录一次节点）</li></ul><p>最终可以写出下面的代码。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">wiggleMaxLength</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (nums.<span class="built_in">size</span>() &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> nums.<span class="built_in">size</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> curDiff = <span class="number">0</span>; <span class="comment">// 当前一对差值</span></span><br><span class="line">        <span class="type">int</span> preDiff = <span class="number">0</span>; <span class="comment">// 前一对差值</span></span><br><span class="line">        <span class="type">int</span> result = <span class="number">1</span>; <span class="comment">// 记录峰值个数，序列默认序列最右边有一个峰值</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>() - <span class="number">1</span>; i++) &#123;</span><br><span class="line">            curDiff = nums[i + <span class="number">1</span>] - nums[i];</span><br><span class="line">            <span class="comment">// 出现峰值</span></span><br><span class="line">            <span class="keyword">if</span> ((preDiff &lt;= <span class="number">0</span> &amp;&amp; curDiff &gt; <span class="number">0</span>) ||</span><br><span class="line">                (preDiff &gt;= <span class="number">0</span> &amp;&amp; curDiff &lt; <span class="number">0</span>)) &#123;</span><br><span class="line">                result++;</span><br><span class="line">                preDiff = curDiff; <span class="comment">// 注意这里，只在摆动变化的时候更新prediff</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/04/49ffcd1cffbf381e29d94594decc9938.png" alt="image.png"></p><h2 id="122-买卖股票的最佳时机2"><a href="#122-买卖股票的最佳时机2" class="headerlink" title="122 买卖股票的最佳时机2"></a>122 买卖股票的最佳时机2</h2><h3 id="题目和思路-2"><a href="#题目和思路-2" class="headerlink" title="题目和思路"></a>题目和思路</h3><blockquote><p><a href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-ii/description/">https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-ii/description/</a></p></blockquote><p>给你一个整数数组 prices ，其中 <code>prices[i]</code> 表示某支股票第 i 天的价格。</p><p>在每一天，你可以决定是否购买和&#x2F;或出售股票。你在任何时候 最多 只能持有 一股 股票。你也可以先购买，然后在 同一天 出售。</p><p>返回 你能获得的 最大 利润 。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">示例 1：</span><br><span class="line">输入：prices = [7,1,5,3,6,4]</span><br><span class="line">输出：7</span><br><span class="line">解释：在第 2 天（股票价格 = 1）的时候买入，在第 3 天（股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5 - 1 = 4 。</span><br><span class="line">     随后，在第 4 天（股票价格 = 3）的时候买入，在第 5 天（股票价格 = 6）的时候卖出, 这笔交易所能获得利润 = 6 - 3 = 3 。</span><br><span class="line">     总利润为 4 + 3 = 7 。</span><br><span class="line">     </span><br><span class="line">示例 2：</span><br><span class="line">输入：prices = [1,2,3,4,5]</span><br><span class="line">输出：4</span><br><span class="line">解释：在第 1 天（股票价格 = 1）的时候买入，在第 5 天 （股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5 - 1 = 4 。</span><br><span class="line">     总利润为 4 。</span><br><span class="line">     </span><br><span class="line">示例 3：</span><br><span class="line">输入：prices = [7,6,4,3,1]</span><br><span class="line">输出：0</span><br><span class="line">解释：在这种情况下, 交易无法获得正利润，所以不参与交易可以获得最大利润，最大利润为 0 。</span><br></pre></td></tr></table></figure><p>首先需要想明白，这道题的利润是可以被分解的。第0天买，第3天卖的利润是 <code>prices[3]-prices[0]</code>，等价于 <code>(p[3]-p[2]) + (p[2]-p[1]) + (p[1]-p[0])</code>。想明白这一点后，这道题的解法就很明确了。</p><p>与其是动态计算咋样才能获得最高利润，还不如分解成一小块一小块的，<strong>只要昨天买入，今天卖出可以赚钱，那么就加入到最终的利润里面</strong>。因为你0天买3天卖，和每天都卖出昨日买入今日得到的钱是完全一致的。那么我们排除掉昨天买入今天卖出会亏钱的情况，就能计算出最终可以达到的最大利润。</p><h3 id="题目代码"><a href="#题目代码" class="headerlink" title="题目代码"></a>题目代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxProfit</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 第0天买，第3天卖的利润是prices[3]-prices[0]</span></span><br><span class="line">        <span class="comment">// 也等于 p[3]-p[2] + p[2]-p[1] + p[1]-p[0]</span></span><br><span class="line">        <span class="comment">// 所以最大利润其实就是每天利润之和（前提是利润都是正的）</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; prices.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="comment">// 计算昨天买今天卖能获得多少利润</span></span><br><span class="line">            <span class="comment">// 如果大于0就加入进去</span></span><br><span class="line">            count += <span class="built_in">max</span>(prices[i] - prices[i - <span class="number">1</span>], <span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/04/1d61dc355c9977d36978521b023b6129.png" alt="image.png"></p><h2 id="55-跳跃游戏"><a href="#55-跳跃游戏" class="headerlink" title="55 跳跃游戏"></a>55 跳跃游戏</h2><blockquote><p><a href="https://leetcode.cn/problems/jump-game/description/">https://leetcode.cn/problems/jump-game/description/</a></p></blockquote><h3 id="题目和思路-3"><a href="#题目和思路-3" class="headerlink" title="题目和思路"></a>题目和思路</h3><p>给你一个非负整数数组 nums ，你最初位于数组的 第一个下标 。数组中的每个元素代表你在该位置可以跳跃的最大长度。</p><p>判断你是否能够到达最后一个下标，如果可以，返回 true ；否则，返回 false 。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">示例 1：</span><br><span class="line">输入：nums = [2,3,1,1,4]</span><br><span class="line">输出：true</span><br><span class="line">解释：可以先跳 1 步，从下标 0 到达下标 1, 然后再从下标 1 跳 3 步到达最后一个下标。</span><br><span class="line"></span><br><span class="line">示例 2：</span><br><span class="line">输入：nums = [3,2,1,0,4]</span><br><span class="line">输出：false</span><br><span class="line">解释：无论怎样，总会到达下标为 3 的位置。但该下标的最大跳跃长度是 0 ， 所以永远不可能到达最后一个下标。</span><br></pre></td></tr></table></figure><p>这道题的思路主要在于判断当前下标加上可以跳的步数判断是否到了最后一位，到了就肯定能跳到。</p><h3 id="超时代码"><a href="#超时代码" class="headerlink" title="超时代码"></a>超时代码</h3><p>最开始我写出了这样的递归思路，本质是暴力求解。不出意外的超时了。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="type">bool</span> _canJump(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> index) &#123;</span><br><span class="line">        <span class="keyword">if</span> (index &gt;= nums.<span class="built_in">size</span>() - <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 判断当前是否包括了终点</span></span><br><span class="line">        <span class="keyword">if</span> (index + nums[index] &gt;= nums.<span class="built_in">size</span>() - <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>; <span class="comment">// 不需要跳了，肯定可以抵达终点</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 遍历进行递归</span></span><br><span class="line">        <span class="type">int</span> range = <span class="built_in">min</span>(index + nums[index], (<span class="type">int</span>)(nums.<span class="built_in">size</span>() - <span class="number">1</span>));</span><br><span class="line">        <span class="comment">// 要从index下一位开始，不然就死循环了</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = index + <span class="number">1</span>; i &lt;= range; i++) &#123;</span><br><span class="line">            <span class="comment">// 递归看看能不能跳到终点</span></span><br><span class="line">            <span class="keyword">if</span> (_canJump(nums, i)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 不可以，那就是无了</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">canJump</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123; <span class="keyword">return</span> _canJump(nums, <span class="number">0</span>); &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/04/c92d1741e6e228dc5ab4b49d9c1409c2.png" alt="image.png"></p><h3 id="正确代码-1"><a href="#正确代码-1" class="headerlink" title="正确代码"></a>正确代码</h3><p>代码随想录上提供了一个更好的办法，思路其实也是类似的，但是可以压缩在一个循环中。动态的改变当前for循环i的边界cover，直到cover大于等于最后一位下标的时候，就是可以跳到，返回true。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">canJump</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (nums.<span class="built_in">size</span>() == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="comment">// 只有一个元素，本来就是从这里起跳的，肯定可以达到</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>; </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> cover = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 注意这里是小于等于cover，cover是闭区间</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= cover; i++) &#123; </span><br><span class="line">            <span class="comment">// 判断当前能跳的范围和cover谁大</span></span><br><span class="line">            cover = <span class="built_in">max</span>(i + nums[i], cover);</span><br><span class="line">            <span class="keyword">if</span> (cover &gt;= nums.<span class="built_in">size</span>() - <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>; <span class="comment">// 说明可以覆盖到终点了</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/04/b7bf833dd954963861fc740c7c2517db.png" alt="image.png"></p><h2 id="45-跳跃游戏2"><a href="#45-跳跃游戏2" class="headerlink" title="45 跳跃游戏2"></a>45 跳跃游戏2</h2><h3 id="题目和思路-4"><a href="#题目和思路-4" class="headerlink" title="题目和思路"></a>题目和思路</h3><blockquote><p><a href="https://leetcode.cn/problems/jump-game-ii/description/">https://leetcode.cn/problems/jump-game-ii/description/</a></p></blockquote><p>给定一个长度为 n 的 0 索引整数数组 nums。初始位置为 nums[0]。</p><p>每个元素 nums[i] 表示从索引 i 向前跳转的最大长度。换句话说，如果你在 nums[i] 处，你可以跳转到任意 nums[i + j] 处:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">0 &lt;= j &lt;= nums[i] </span><br><span class="line">i + j &lt; n</span><br></pre></td></tr></table></figure><p>返回到达 nums[n - 1] 的最小跳跃次数。生成的测试用例可以到达 nums[n - 1]。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">示例 1:</span><br><span class="line">输入: nums = [2,3,1,1,4]</span><br><span class="line">输出: 2</span><br><span class="line">解释: 跳到最后一个位置的最小跳跃数是 2。</span><br><span class="line">     从下标为 0 跳到下标为 1 的位置，跳 1 步，然后跳 3 步到达数组的最后一个位置。</span><br><span class="line">     </span><br><span class="line">示例 2:</span><br><span class="line">输入: nums = [2,3,0,1,4]</span><br><span class="line">输出: 2</span><br></pre></td></tr></table></figure><p>这道题和上一题就不同了，上一题只是判断能不能跳到最后一个位置，这一题是在已经可以跳到最后一个位置的基础上，计算最小的跳跃次数。</p><p>不过基本思路还是一样的，就是判断cover的范围。</p><ul><li>在当前范围中，找到下一步能抵达的最大范围</li><li>i抵达当前范围的边界了，必须跳一步了<ul><li>步数加一</li><li>更新当前范围为下一步的最大范围</li><li>判断最大范围是否已经到了<code>nums.size()-1</code>，如果到了直接返回步数（只需要再跳一步就可以抵达末尾了）</li></ul></li></ul><p>不管当前怎么跳，当前范围都是可以跳到的，那么我们只需要找到当前范围中，下一步能抵达的最大位置，那么就是最好的选择。直到下一步抵达终点，返回步数。</p><h3 id="完整代码-1"><a href="#完整代码-1" class="headerlink" title="完整代码"></a>完整代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">jump</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (nums.<span class="built_in">size</span>() == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 当前的跳跃范围</span></span><br><span class="line">        <span class="type">int</span> curJump = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> maxJump = <span class="number">0</span>; <span class="comment">// 判断范围内可以跳的最大值</span></span><br><span class="line">        <span class="type">int</span> count = <span class="number">0</span>;   <span class="comment">// 跳了几次</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="comment">// 更新在[i,curJump]范围内下一步可以跳的最大范围</span></span><br><span class="line">            maxJump = <span class="built_in">max</span>(i + nums[i], maxJump);</span><br><span class="line">            <span class="comment">// 到达右边界了，必须再跳一步了。</span></span><br><span class="line">            <span class="keyword">if</span> (i == curJump) &#123;</span><br><span class="line">                count++;</span><br><span class="line">                curJump = maxJump;</span><br><span class="line">                <span class="comment">// 可以跳到下一步（这里提前count++就相当于跳了这一步）</span></span><br><span class="line">                <span class="keyword">if</span> (maxJump &gt;= nums.<span class="built_in">size</span>() - <span class="number">1</span>) &#123;</span><br><span class="line">                    <span class="keyword">return</span> count;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/04/3084162e56bfdd5cc3b6204357509ace.png" alt="image.png"></p><h2 id="1005-k次取反后的最大和"><a href="#1005-k次取反后的最大和" class="headerlink" title="1005 k次取反后的最大和"></a>1005 k次取反后的最大和</h2><blockquote><p><a href="https://leetcode.cn/problems/maximize-sum-of-array-after-k-negations/">https://leetcode.cn/problems/maximize-sum-of-array-after-k-negations/</a></p></blockquote><h3 id="题目和思路-5"><a href="#题目和思路-5" class="headerlink" title="题目和思路"></a>题目和思路</h3><p>给你一个整数数组 nums 和一个整数 k ，按以下方法修改该数组：</p><p>选择某个下标 i 并将 nums[i] 替换为 -nums[i] 。</p><p>重复这个过程恰好 k 次。可以多次选择同一个下标 i 。</p><p>以这种方式修改数组后，返回数组 可能的最大和 。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">示例 1：</span><br><span class="line">输入：nums = [4,2,3], k = 1</span><br><span class="line">输出：5</span><br><span class="line">解释：选择下标 1 ，nums 变为 [4,-2,3] 。</span><br><span class="line"></span><br><span class="line">示例 2：</span><br><span class="line">输入：nums = [3,-1,0,2], k = 3</span><br><span class="line">输出：6</span><br><span class="line">解释：选择下标 (1, 2, 2) ，nums 变为 [3,1,0,2] 。</span><br><span class="line"></span><br><span class="line">示例 3：</span><br><span class="line">输入：nums = [2,-3,-1,5,-4], k = 2</span><br><span class="line">输出：13</span><br><span class="line">解释：选择下标 (1, 4) ，nums 变为 [2,3,-1,5,4] </span><br></pre></td></tr></table></figure><p>这道题的思路很简单，首先我们肯定是先把负数反转成正的，都是正数了之后，再考虑反转最小的数。</p><p>本来我的想法是，反转完毕负数后，重排序，从最小的数开始一直往后反转，但是这样思考就忽略了题目中的一个要求。题目是<strong>允许在某个下标处重复反转</strong>的。</p><p>那么我们就没有必要从最小的数开始把它们都反转成负数了，而是一直操作最小的那个数，直到k用完。上面的示例2就是这样的，先把负数反转成正数，然后重复操作0。</p><h3 id="完整代码-2"><a href="#完整代码-2" class="headerlink" title="完整代码"></a>完整代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="comment">// 按绝对值从大到小排序</span></span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">bool</span> <span class="title">cmp</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123; <span class="keyword">return</span> <span class="built_in">abs</span>(a) &gt; <span class="built_in">abs</span>(b); &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">largestSumAfterKNegations</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 绝对值从大到小排列</span></span><br><span class="line">        <span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>(), cmp);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="comment">// 反转负数</span></span><br><span class="line">            <span class="keyword">if</span> (nums[i] &lt; <span class="number">0</span> &amp;&amp; k &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                nums[i] *= <span class="number">-1</span>;</span><br><span class="line">                k--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果k还没有用完，则反转绝对值最小的那个数，直到用完k</span></span><br><span class="line">        <span class="comment">// 这里直接判断k是奇数还是偶数，如果是奇数会多出来一次反转，只需要做这一次就可以了</span></span><br><span class="line">        <span class="keyword">if</span> (k % <span class="number">2</span> == <span class="number">1</span>) &#123;</span><br><span class="line">            nums[nums.<span class="built_in">size</span>() - <span class="number">1</span>] *= <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 求和</span></span><br><span class="line">        <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; e : nums) &#123;</span><br><span class="line">            sum += e;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="134-加油站"><a href="#134-加油站" class="headerlink" title="134 加油站"></a>134 加油站</h2><h3 id="题目和思路-6"><a href="#题目和思路-6" class="headerlink" title="题目和思路"></a>题目和思路</h3><blockquote><p><a href="https://leetcode.cn/problems/gas-station/">https://leetcode.cn/problems/gas-station/</a></p></blockquote><p>在一条环路上有 n 个加油站，其中第 i 个加油站有汽油 gas[i] 升。</p><p>你有一辆油箱容量无限的的汽车，从第 i 个加油站开往第 i+1 个加油站需要消耗汽油 cost[i] 升。你从其中的一个加油站出发，开始时油箱为空。</p><p>给定两个整数数组 gas 和 cost ，如果你可以按顺序绕环路行驶一周，则返回出发时加油站的编号，否则返回 -1 。如果存在解，则 保证 它是 唯一 的。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">示例 1:</span><br><span class="line">输入: gas = [1,2,3,4,5], cost = [3,4,5,1,2]</span><br><span class="line">输出: 3</span><br><span class="line">解释:</span><br><span class="line">从 3 号加油站(索引为 3 处)出发，可获得 4 升汽油。此时油箱有 = 0 + 4 = 4 升汽油</span><br><span class="line">开往 4 号加油站，此时油箱有 4 - 1 + 5 = 8 升汽油</span><br><span class="line">开往 0 号加油站，此时油箱有 8 - 2 + 1 = 7 升汽油</span><br><span class="line">开往 1 号加油站，此时油箱有 7 - 3 + 2 = 6 升汽油</span><br><span class="line">开往 2 号加油站，此时油箱有 6 - 4 + 3 = 5 升汽油</span><br><span class="line">开往 3 号加油站，你需要消耗 5 升汽油，正好足够你返回到 3 号加油站。</span><br><span class="line">因此，3 可为起始索引。</span><br><span class="line"></span><br><span class="line">示例 2:</span><br><span class="line">输入: gas = [2,3,4], cost = [3,4,3]</span><br><span class="line">输出: -1</span><br><span class="line">解释:</span><br><span class="line">你不能从 0 号或 1 号加油站出发，因为没有足够的汽油可以让你行驶到下一个加油站。</span><br><span class="line">我们从 2 号加油站出发，可以获得 4 升汽油。 此时油箱有 = 0 + 4 = 4 升汽油</span><br><span class="line">开往 0 号加油站，此时油箱有 4 - 3 + 2 = 3 升汽油</span><br><span class="line">开往 1 号加油站，此时油箱有 3 - 3 + 3 = 3 升汽油</span><br><span class="line">你无法返回 2 号加油站，因为返程需要消耗 4 升汽油，但是你的油箱只有 3 升汽油。</span><br><span class="line">因此，无论怎样，你都不可能绕环路行驶一周。</span><br></pre></td></tr></table></figure><p>这道题使用贪心的方式，找到局部最优：假设从start出发每次走一步，计算<code>gas[i]-cost[i]</code>得到剩余的油，如果剩余的油为负数，说明从<code>[start,i]</code>之中的任意位置出发，走到i的时候都会没油。那么就需要从i+1开始走（更新start）。</p><p>最终遍历完毕整个数组的时候，得到的start肯定是能走完整个区间的起始下标。因为其他下标开始走，都没有办法走完某一个区间。</p><h3 id="完整代码-3"><a href="#完整代码-3" class="headerlink" title="完整代码"></a>完整代码</h3><p>这里还有关于<code>start=i+1</code>是否会出现越界情况的说明，参考代码注释。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">canCompleteCircuit</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; gas, vector&lt;<span class="type">int</span>&gt;&amp; cost)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 1.所有油加起来没有距离长，说明永远走不到</span></span><br><span class="line">        <span class="comment">// 2.假设从0开始，走到i，如果剩余油为负数，说明[0,i]区间内，不管从哪里开始，都走不到i；</span></span><br><span class="line">        <span class="comment">//   那么就需要从i+1开始重新走，直到剩余油再次为负数或者走完整个区间</span></span><br><span class="line">        <span class="type">int</span> start = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> totalSum = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> leftGas = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; gas.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            leftGas += gas[i] - cost[i];</span><br><span class="line">            totalSum += gas[i] - cost[i];</span><br><span class="line">            <span class="keyword">if</span> (leftGas &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// 因为[start,i]区间内剩余油是负数，说明从这个区间任意位置开始都走不到i</span></span><br><span class="line">                <span class="comment">// 所以需要从i+1作为一个新的起点，继续往后走。</span></span><br><span class="line">                start = i + <span class="number">1</span>; </span><br><span class="line">                leftGas = <span class="number">0</span>; <span class="comment">// 重置剩余油</span></span><br><span class="line">                <span class="comment">// 会不会出现i+1越界了的情况？这种情况说明i=size-1的时候，leftGas小于0；</span></span><br><span class="line">                <span class="comment">// 同时也说明了[start,sz-1]还是无法走完，反应到全局说明油本来就是不够的；</span></span><br><span class="line">                <span class="comment">// 此时会在后面的totalSum的判断中返回-1，所以不会出现start越界的情况；</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果diff加起来最终是个负数，说明油是不够用的</span></span><br><span class="line">        <span class="keyword">if</span> (totalSum &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> start;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/04/7f32f785c9fdc45f7cb9296f24767696.png" alt="image.png"></p><h2 id="135-分发糖果"><a href="#135-分发糖果" class="headerlink" title="135 分发糖果"></a>135 分发糖果</h2><blockquote><p><a href="https://leetcode.cn/problems/candy/description/">https://leetcode.cn/problems/candy/description/</a></p></blockquote><h3 id="题目和思路-7"><a href="#题目和思路-7" class="headerlink" title="题目和思路"></a>题目和思路</h3><p>n 个孩子站成一排。给你一个整数数组 ratings 表示每个孩子的评分。</p><p>你需要按照以下要求，给这些孩子分发糖果：</p><p>每个孩子至少分配到 1 个糖果。<br>相邻两个孩子评分更高的孩子会获得更多的糖果。</p><p>请你给每个孩子分发糖果，计算并返回需要准备的 最少糖果数目 。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">示例 1：</span><br><span class="line">输入：ratings = [1,0,2]</span><br><span class="line">输出：5</span><br><span class="line">解释：你可以分别给第一个、第二个、第三个孩子分发 2、1、2 颗糖果。</span><br><span class="line"></span><br><span class="line">示例 2：</span><br><span class="line">输入：ratings = [1,2,2]</span><br><span class="line">输出：4</span><br><span class="line">解释：你可以分别给第一个、第二个、第三个孩子分发 1、2、1 颗糖果。</span><br><span class="line">     第三个孩子只得到 1 颗糖果，这满足题面中的两个条件。</span><br></pre></td></tr></table></figure><p>这道题的思路其实不难，但是我们不要一次性考虑某个小孩的两边，而是应该一次只考虑一边。</p><ul><li>初始化数组，每人一个糖果。</li><li>先从左往右遍历，如果当前孩子的分值高于左边，则当前孩子的糖果数量是左边孩子+1；</li><li>然后从右边往左边遍历，如果当前孩子的分值高于右边，则当前孩子的糖果数量是<code>max(右边孩子糖果数量+1,当前孩子糖果数量)</code></li></ul><p>为什么从右往左的时候需要进行max判断呢？因为题目需要的是最小的糖果数量，同时也需要满足条件，max判断能保证当前的孩子糖果大于右边，同时也满足大于左边的条件（如果直接等于右边的孩子糖果数量+1，可能会导致它不再满足高于左边孩子的糖果的情况）</p><h3 id="完整代码-4"><a href="#完整代码-4" class="headerlink" title="完整代码"></a>完整代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">candy</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; ratings)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 先给所有人分一个糖果</span></span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">candyArray</span><span class="params">(ratings.size(), <span class="number">1</span>)</span></span>;</span><br><span class="line">        <span class="comment">// 从左往右遍历，如果当前孩子比左边的孩子分数多，则让当前的孩子多分一个糖果</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; ratings.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (ratings[i] &gt; ratings[i - <span class="number">1</span>]) &#123;</span><br><span class="line">                candyArray[i] = candyArray[i - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 从右往左遍历，如果当前孩子比右边孩子分数多，则让当前孩子多分一个糖果</span></span><br><span class="line">        <span class="comment">// 注意这里我们需要从倒数第二个孩子开始，此时它的下标是sz-2</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = ratings.<span class="built_in">size</span>() - <span class="number">2</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="keyword">if</span> (ratings[i] &gt; ratings[i + <span class="number">1</span>]) &#123;</span><br><span class="line">                <span class="comment">// 因为前面已经操作过一次了，此时可能当前孩子的糖果已经比i+1多了，那么就需要判断</span></span><br><span class="line">                <span class="comment">// 不然右边孩子的糖果数量+1小于当前已有糖果时，直接赋值会导致左侧条件不满足。</span></span><br><span class="line">                candyArray[i] = <span class="built_in">max</span>(candyArray[i + <span class="number">1</span>] + <span class="number">1</span>, candyArray[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 计算糖果数量</span></span><br><span class="line">        <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; c : candyArray) &#123;</span><br><span class="line">            count += c;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/04/4090a2a83a429258083e07de6bae402a.png" alt="image.png"></p><h2 id="860-柠檬水找零"><a href="#860-柠檬水找零" class="headerlink" title="860 柠檬水找零"></a>860 柠檬水找零</h2><h3 id="题目和思路-8"><a href="#题目和思路-8" class="headerlink" title="题目和思路"></a>题目和思路</h3><blockquote><p><a href="https://leetcode.cn/problems/lemonade-change/description/">https://leetcode.cn/problems/lemonade-change/description/</a></p></blockquote><p>在柠檬水摊上，每一杯柠檬水的售价为 5 美元。顾客排队购买你的产品，（按账单 bills 支付的顺序）一次购买一杯。</p><p>每位顾客只买一杯柠檬水，然后向你付 5 美元、10 美元或 20 美元。你必须给每个顾客正确找零，也就是说净交易是每位顾客向你支付 5 美元。</p><p>注意，一开始你手头没有任何零钱。</p><p>给你一个整数数组 bills ，其中 bills[i] 是第 i 位顾客付的账。如果你能给每位顾客正确找零，返回 true ，否则返回 false 。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">示例 1：</span><br><span class="line">输入：bills = [5,5,5,10,20]</span><br><span class="line">输出：true</span><br><span class="line">解释：</span><br><span class="line">前 3 位顾客那里，我们按顺序收取 3 张 5 美元的钞票。</span><br><span class="line">第 4 位顾客那里，我们收取一张 10 美元的钞票，并返还 5 美元。</span><br><span class="line">第 5 位顾客那里，我们找还一张 10 美元的钞票和一张 5 美元的钞票。</span><br><span class="line">由于所有客户都得到了正确的找零，所以我们输出 true。</span><br><span class="line"></span><br><span class="line">示例 2：</span><br><span class="line">输入：bills = [5,5,10,10,20]</span><br><span class="line">输出：false</span><br><span class="line">解释：</span><br><span class="line">前 2 位顾客那里，我们按顺序收取 2 张 5 美元的钞票。</span><br><span class="line">对于接下来的 2 位顾客，我们收取一张 10 美元的钞票，然后返还 5 美元。</span><br><span class="line">对于最后一位顾客，我们无法退回 15 美元，因为我们现在只有两张 10 美元的钞票。</span><br><span class="line">由于不是每位顾客都得到了正确的找零，所以答案是 false。</span><br></pre></td></tr></table></figure><p>这道题其实是一个最最基本的数学问题。用到贪心的地方就是有<code>10+5</code>和<code>3*5</code>的时候应该先用哪一个进行找零。很明显我们需要用<code>10+5</code>来找零，因为10元只有这个地方能用上。如果优先用5元找零，后序有人用10元来买柠檬水的时候，可能零钱就不够了。</p><h3 id="完整代码-5"><a href="#完整代码-5" class="headerlink" title="完整代码"></a>完整代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">lemonadeChange</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; bills)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 剩余零钱初始化</span></span><br><span class="line">        unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; momenyMap;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> i : bills) &#123;</span><br><span class="line">            <span class="comment">// 先计入获得的零钱</span></span><br><span class="line">            momenyMap[i]++;</span><br><span class="line">            i -= <span class="number">5</span>;</span><br><span class="line">            <span class="comment">// 原本是10元</span></span><br><span class="line">            <span class="keyword">if</span> (i == <span class="number">5</span>) &#123;</span><br><span class="line">                <span class="comment">// 给她找5元</span></span><br><span class="line">                momenyMap[<span class="number">5</span>]--;</span><br><span class="line">                <span class="comment">// 没有零钱了，不行</span></span><br><span class="line">                <span class="keyword">if</span> (momenyMap[<span class="number">5</span>] &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 原本是20元</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (i == <span class="number">15</span>) &#123;</span><br><span class="line">                <span class="comment">// 先用10元的零钱，因为10元的零钱只有这时候可以用</span></span><br><span class="line">                <span class="keyword">if</span> (momenyMap[<span class="number">10</span>] &gt; <span class="number">0</span> &amp;&amp; momenyMap[<span class="number">5</span>] &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    momenyMap[<span class="number">5</span>]--;</span><br><span class="line">                    momenyMap[<span class="number">10</span>]--;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 如果没有十元的零钱，就用3个5元的零钱</span></span><br><span class="line">                <span class="comment">// 不够用，返回false</span></span><br><span class="line">                <span class="keyword">if</span> (momenyMap[<span class="number">5</span>] &lt; <span class="number">3</span>) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 扣掉零钱</span></span><br><span class="line">                momenyMap[<span class="number">5</span>] -= <span class="number">3</span>;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="452-用最少的箭引爆气球"><a href="#452-用最少的箭引爆气球" class="headerlink" title="452 用最少的箭引爆气球"></a>452 用最少的箭引爆气球</h2><h3 id="题目和思路-9"><a href="#题目和思路-9" class="headerlink" title="题目和思路"></a>题目和思路</h3><blockquote><p><a href="https://leetcode.cn/problems/minimum-number-of-arrows-to-burst-balloons/">https://leetcode.cn/problems/minimum-number-of-arrows-to-burst-balloons/</a></p></blockquote><p>有一些球形气球贴在一堵用 XY 平面表示的墙面上。墙面上的气球记录在整数数组 points ，其中<code>points[i] = [xstart, xend]</code> 表示水平直径在 xstart 和 xend之间的气球。你不知道气球的确切 y 坐标。</p><p>一支弓箭可以沿着 x 轴从不同点 完全垂直 地射出。在坐标 x 处射出一支箭，若有一个气球的直径的开始和结束坐标为<code> xstart，xend</code>， 且满足  <code>xstart ≤ x ≤ xend</code>，则该气球会被 引爆 。可以射出的弓箭的数量 没有限制 。 弓箭一旦被射出之后，可以无限地前进。</p><p>给你一个数组 points ，返回引爆所有气球所必须射出的 最小 弓箭数 。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">示例 1：</span><br><span class="line">输入：points = [[10,16],[2,8],[1,6],[7,12]]</span><br><span class="line">输出：2</span><br><span class="line">解释：气球可以用2支箭来爆破:</span><br><span class="line">-在x = 6处射出箭，击破气球[2,8]和[1,6]。</span><br><span class="line">-在x = 11处发射箭，击破气球[10,16]和[7,12]。</span><br><span class="line"></span><br><span class="line">示例 2：</span><br><span class="line">输入：points = [[1,2],[3,4],[5,6],[7,8]]</span><br><span class="line">输出：4</span><br><span class="line">解释：每个气球需要射出一支箭，总共需要4支箭。</span><br><span class="line"></span><br><span class="line">示例 3：</span><br><span class="line">输入：points = [[1,2],[2,3],[3,4],[4,5]]</span><br><span class="line">输出：2</span><br><span class="line">解释：气球可以用2支箭来爆破:</span><br><span class="line">- 在x = 2处发射箭，击破气球[1,2]和[2,3]。</span><br><span class="line">- 在x = 4处射出箭，击破气球[3,4]和[4,5]。</span><br></pre></td></tr></table></figure><p>首先我们需要对边界进行排序，这里选用左边界升序。</p><p>然后从左往右遍历，根据当前的左边界和上一个值的右边界，确定两个气球是否挨着。</p><ul><li>如果挨着，说明两个气球可以被一起射爆（注意边界值相等也视为重叠），此时需要更新当前值的右边界为<code>min(当前右边界,上一个气球的右边界)</code>，因为只有这样才能保证下一次遍历判断的时候得到的结果，能把之前的两个气球射爆</li><li>如果不挨着，说明前一个气球需要单独一箭，计数器加一。</li></ul><p>这里的贪心思想就是不断的更新边界值，来确保找到更多符合同一边界情况的气球，减少箭矢的使用。</p><h3 id="完整代码-6"><a href="#完整代码-6" class="headerlink" title="完整代码"></a>完整代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">bool</span> <span class="title">cmp</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; a, vector&lt;<span class="type">int</span>&gt;&amp; b)</span> </span>&#123; <span class="keyword">return</span> a[<span class="number">0</span>] &lt; b[<span class="number">0</span>]; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">findMinArrowShots</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; points)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (points.<span class="built_in">size</span>() == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 首先需要按左边界对区间排升序</span></span><br><span class="line">        <span class="built_in">sort</span>(points.<span class="built_in">begin</span>(), points.<span class="built_in">end</span>(), cmp);</span><br><span class="line">        <span class="type">int</span> arrow = <span class="number">1</span>; <span class="comment">// points 不为空至少需要一支箭</span></span><br><span class="line">        <span class="type">int</span> end = points[<span class="number">0</span>][<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; points.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="comment">// 重叠了，更新最小的子区间</span></span><br><span class="line">            <span class="keyword">if</span> (points[i][<span class="number">0</span>] &lt;= end) &#123;</span><br><span class="line">                end = <span class="built_in">min</span>(points[i][<span class="number">1</span>], end);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 不重叠，需要射箭</span></span><br><span class="line">                end = points[i][<span class="number">1</span>];</span><br><span class="line">                arrow++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> arrow;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/04/8279f8e0698fd1c921bf1eafedbed0a9.png" alt="image.png"></p><h2 id="406-根据身高重建队列"><a href="#406-根据身高重建队列" class="headerlink" title="406 根据身高重建队列"></a>406 根据身高重建队列</h2><blockquote><p><a href="https://leetcode.cn/problems/queue-reconstruction-by-height/description/">https://leetcode.cn/problems/queue-reconstruction-by-height/description/</a></p></blockquote><h3 id="题目和思路-10"><a href="#题目和思路-10" class="headerlink" title="题目和思路"></a>题目和思路</h3><p>假设有打乱顺序的一群人站成一个队列，数组 people 表示队列中一些人的属性（不一定按顺序）。每个 people[i] &#x3D; [hi, ki] 表示第 i 个人的身高为 hi ，前面 正好 有 ki 个身高大于或等于 hi 的人。</p><p>请你重新构造并返回输入数组 people 所表示的队列。返回的队列应该格式化为数组 queue ，其中 queue[j] &#x3D; [hj, kj] 是队列中第 j 个人的属性（queue[0] 是排在队列前面的人）。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">示例 1：</span><br><span class="line">输入：people = [[7,0],[4,4],[7,1],[5,0],[6,1],[5,2]]</span><br><span class="line">输出：[[5,0],[7,0],[5,2],[6,1],[4,4],[7,1]]</span><br><span class="line">解释：</span><br><span class="line">编号为 0 的人身高为 5 ，没有身高更高或者相同的人排在他前面。</span><br><span class="line">编号为 1 的人身高为 7 ，没有身高更高或者相同的人排在他前面。</span><br><span class="line">编号为 2 的人身高为 5 ，有 2 个身高更高或者相同的人排在他前面，即编号为 0 和 1 的人。</span><br><span class="line">编号为 3 的人身高为 6 ，有 1 个身高更高或者相同的人排在他前面，即编号为 1 的人。</span><br><span class="line">编号为 4 的人身高为 4 ，有 4 个身高更高或者相同的人排在他前面，即编号为 0、1、2、3 的人。</span><br><span class="line">编号为 5 的人身高为 7 ，有 1 个身高更高或者相同的人排在他前面，即编号为 1 的人。</span><br><span class="line">因此 [[5,0],[7,0],[5,2],[6,1],[4,4],[7,1]] 是重新构造后的队列。</span><br><span class="line"></span><br><span class="line">示例 2：</span><br><span class="line">输入：people = [[6,0],[5,0],[4,0],[3,2],[2,2],[1,4]]</span><br><span class="line">输出：[[4,0],[5,0],[2,2],[3,2],[1,4],[6,0]]</span><br></pre></td></tr></table></figure><p>这道题目和<code>135分发糖果</code>有一定相似，都需要从两个维度来考虑。但为了避免出错，我们一次只能考虑一个维度。</p><p>首先要做的就是对people进行排序，那么是根据身高排序，还是根据前面有几个人排序？</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">用例 [[7,0],[4,4],[7,1],[5,0],[6,1],[5,2]]</span><br><span class="line">身高 [[7,0],[7,1],[6,1],[5,0],[5,2],[4,4]]</span><br><span class="line">人数 [[7,0],[5,0],[7,1],[6,1],[5,2],[4,4]]</span><br></pre></td></tr></table></figure><p>会发现，如果按前面有几个人排序，最终得到的序列好像并没有用，也不是题目需要的序列。</p><p>但根据身高降序排序，会让这里的序列满足一个特性，即元素i之前的都比i高。</p><p>这时候我们就能直接根据元素i之前有几个比他高的人，将这个值视作下标，来构建出新的队列！前面有几个比他高的人，就往第几位之后插入。</p><h3 id="完整代码-7"><a href="#完整代码-7" class="headerlink" title="完整代码"></a>完整代码</h3><p>注意这里使用链表来进行插入操作，效率会更高。因为vector每次的insert都需要对元素进行移动，甚至会涉及到空间扩容的消耗（所以我提前reserve了），而list不会有这个问题。</p><p>我们可以先用list来进行插入操作，最后再用迭代器构造vector返回。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">bool</span> <span class="title">cmp</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; a, vector&lt;<span class="type">int</span>&gt;&amp; b)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 按身高升序排序</span></span><br><span class="line">        <span class="keyword">if</span> (a[<span class="number">0</span>] &gt; b[<span class="number">0</span>]) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果身高一样，前面的人少的排前面</span></span><br><span class="line">        <span class="keyword">if</span> (a[<span class="number">0</span>] == b[<span class="number">0</span>]) &#123;</span><br><span class="line">            <span class="keyword">return</span> a[<span class="number">1</span>] &lt; b[<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">reconstructQueue</span>(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; people) &#123;</span><br><span class="line">        <span class="comment">// 按身高降序+前面人的个数升序排列</span></span><br><span class="line">        <span class="built_in">sort</span>(people.<span class="built_in">begin</span>(), people.<span class="built_in">end</span>(), cmp);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; v : people) &#123;</span><br><span class="line">            cout &lt;&lt; v[<span class="number">0</span>] &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; v[<span class="number">1</span>] &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; que;</span><br><span class="line">        que.<span class="built_in">reserve</span>(people.<span class="built_in">size</span>()); <span class="comment">// 提前开空间</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; people.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="comment">// 前面有几个人，就往第几位插入</span></span><br><span class="line">            <span class="type">int</span> offset = people[i][<span class="number">1</span>];</span><br><span class="line">            que.<span class="built_in">insert</span>(que.<span class="built_in">begin</span>() + offset, people[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> que;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>链表版本</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">bool</span> <span class="title">cmp</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; a, vector&lt;<span class="type">int</span>&gt;&amp; b)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 按身高升序排序</span></span><br><span class="line">        <span class="keyword">if</span> (a[<span class="number">0</span>] &gt; b[<span class="number">0</span>]) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果身高一样，前面的人少的排前面</span></span><br><span class="line">        <span class="keyword">if</span> (a[<span class="number">0</span>] == b[<span class="number">0</span>]) &#123;</span><br><span class="line">            <span class="keyword">return</span> a[<span class="number">1</span>] &lt; b[<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">reconstructQueue</span>(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; people) &#123;</span><br><span class="line">        <span class="comment">// 按身高降序+前面人的个数升序排列</span></span><br><span class="line">        <span class="built_in">sort</span>(people.<span class="built_in">begin</span>(), people.<span class="built_in">end</span>(), cmp);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; v : people) &#123;</span><br><span class="line">            cout &lt;&lt; v[<span class="number">0</span>] &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; v[<span class="number">1</span>] &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        list&lt;vector&lt;<span class="type">int</span>&gt;&gt; que;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; people.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="comment">// 前面有几个人，就往第几位插入</span></span><br><span class="line">            <span class="type">int</span> offset = people[i][<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">auto</span> itr = que.<span class="built_in">begin</span>();</span><br><span class="line">            <span class="keyword">while</span>(offset--)&#123;</span><br><span class="line">                itr++;</span><br><span class="line">            &#125;</span><br><span class="line">            que.<span class="built_in">insert</span>(itr, people[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;(que.<span class="built_in">begin</span>(),que.<span class="built_in">end</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="435-无重叠区间"><a href="#435-无重叠区间" class="headerlink" title="435 无重叠区间"></a>435 无重叠区间</h2><h3 id="题目和思路-11"><a href="#题目和思路-11" class="headerlink" title="题目和思路"></a>题目和思路</h3><blockquote><p><a href="https://leetcode.cn/problems/non-overlapping-intervals/">https://leetcode.cn/problems/non-overlapping-intervals/</a></p></blockquote><p>给定一个区间的集合 intervals ，其中 <code>intervals[i] = [starti, endi]</code> 。返回 需要移除区间的最小数量，使剩余区间互不重叠 。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">示例 1:</span><br><span class="line">输入: intervals = [[1,2],[2,3],[3,4],[1,3]]</span><br><span class="line">输出: 1</span><br><span class="line">解释: 移除 [1,3] 后，剩下的区间没有重叠。</span><br><span class="line"></span><br><span class="line">示例 2:</span><br><span class="line">输入: intervals = [ [1,2], [1,2], [1,2] ]</span><br><span class="line">输出: 2</span><br><span class="line">解释: 你需要移除两个 [1,2] 来使剩下的区间没有重叠。</span><br><span class="line"></span><br><span class="line">示例 3:</span><br><span class="line">输入: intervals = [ [1,2], [2,3] ]</span><br><span class="line">输出: 0</span><br><span class="line">解释: 你不需要移除任何区间，因为它们已经是无重叠的了。</span><br></pre></td></tr></table></figure><p>这道题和前文射爆气球的题目很相似，但是需要注意，在射爆气球那道题中，边界值相同视作重叠。而本题边界值相同不视作重叠区间。</p><p>还是用左边界升序排序，记录重叠的区间的数量，即需要删除的区间数量。</p><p>判断到重叠区间的时候，也需要将边界值更新为区间最小右边界。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">end = <span class="built_in">min</span>(intervals[i][<span class="number">1</span>],end);</span><br></pre></td></tr></table></figure><p>因为我们发现两个区间重叠的时候，我们应该删除区间范围（只考虑右边界）最大的那个，才能尽可能的避免当前的这个重叠区间进一步和其他节点重叠。</p><p>题目需要求的是最少需要删除的区间数量，贪心的思想也是在此，每次都删除右边界更大的那个区间，才能保证最终删除的区间数量最少。</p><h3 id="完整代码-8"><a href="#完整代码-8" class="headerlink" title="完整代码"></a>完整代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">bool</span> <span class="title">cmp</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; a, vector&lt;<span class="type">int</span>&gt;&amp; b)</span> </span>&#123; <span class="keyword">return</span> a[<span class="number">0</span>] &lt; b[<span class="number">0</span>]; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">eraseOverlapIntervals</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; intervals)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (intervals.<span class="built_in">size</span>() &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 按左边界升序排序</span></span><br><span class="line">        <span class="built_in">sort</span>(intervals.<span class="built_in">begin</span>(), intervals.<span class="built_in">end</span>(), cmp);</span><br><span class="line">        <span class="comment">// 直接统计重叠区间有哪些</span></span><br><span class="line">        <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> end = intervals[<span class="number">0</span>][<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; intervals.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="comment">// 重叠区间</span></span><br><span class="line">            <span class="keyword">if</span> (intervals[i][<span class="number">0</span>] &lt; end) &#123;</span><br><span class="line">                count++;</span><br><span class="line">                <span class="comment">// 重叠的时候，需要更新最小的边界值</span></span><br><span class="line">                <span class="comment">// 因为我们假设移除那个边界值更大的节点，这样就能最大限度的避免重叠</span></span><br><span class="line">                <span class="comment">// 比如[[1,2],[2,3],[3,4],[1,3]]中，1,2和1,3重叠，我们应该移除1,3才是正确的</span></span><br><span class="line">                <span class="comment">// 此时就应该将2作为边界值继续判断，相当于保留1,2节点</span></span><br><span class="line">                end = <span class="built_in">min</span>(intervals[i][<span class="number">1</span>],end);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="comment">// 不重叠，更新边界值</span></span><br><span class="line">            &#123;</span><br><span class="line">                end = intervals[i][<span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/04/51943b3301f8319a3fdf388178a0ddf4.png" alt="image.png"></p><h2 id="763-划分字母区间"><a href="#763-划分字母区间" class="headerlink" title="763 划分字母区间"></a>763 划分字母区间</h2><h3 id="题目和思路-12"><a href="#题目和思路-12" class="headerlink" title="题目和思路"></a>题目和思路</h3><blockquote><p><a href="https://leetcode.cn/problems/partition-labels/description/">https://leetcode.cn/problems/partition-labels/description/</a></p></blockquote><p>给你一个字符串 s 。我们要把这个字符串划分为尽可能多的片段，同一字母最多出现在一个片段中。</p><p>注意，划分结果需要满足：将所有划分结果按顺序连接，得到的字符串仍然是 s 。</p><p>返回一个表示每个字符串片段的长度的列表。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">示例 1：</span><br><span class="line">输入：s = &quot;ababcbacadefegdehijhklij&quot;</span><br><span class="line">输出：[9,7,8]</span><br><span class="line">解释：</span><br><span class="line">划分结果为 &quot;ababcbaca&quot;、&quot;defegde&quot;、&quot;hijhklij&quot; 。</span><br><span class="line">每个字母最多出现在一个片段中。</span><br><span class="line">像 &quot;ababcbacadefegde&quot;, &quot;hijhklij&quot; 这样的划分是错误的，因为划分的片段数较少。 </span><br><span class="line"></span><br><span class="line">示例 2：</span><br><span class="line">输入：s = &quot;eccbbbbdec&quot;</span><br><span class="line">输出：[10]</span><br></pre></td></tr></table></figure><p>这道题的思路是，先遍历一次字符串，维护一个相同长度的字母最远出现位置（下标）的数组。</p><p>以题目给出的示例1为例，按照如上思路可以维护出一个这样的数组。</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/04/98c1a314b0c2c2f8be0f2012f0da26e2.png" alt="image.png"></p><p>再次遍历字符串，最开始start为0，以<code>[start,i]</code>为一个区间，维护一个这个<strong>区间中</strong>字母的<strong>最远出现位置</strong>，当i等于当前的“最远出现位置”时，说明已经得到了一个可分割的子区间，更新start为i+1，继续遍历下一个区间。</p><ul><li>为什么i等于当前最远出现位置时就找到了一个可分割的子序列呢？</li></ul><p>还是看示例1，观察图中被标红的位置，这些都是可以进行分割的位置。当我们遍历<code>[0,8]</code>这个区间时，维护的这个区间中字母最远出现位置就是8，当i等于8的时候，对应字符的最远出现位置也是8，说明在这个区间中，没有其他字符最远出现的位置大于8了，即符合题目中给出的“每个字母只在其中一个区间出现”的要求。</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/04/98c1a314b0c2c2f8be0f2012f0da26e2.png" alt="image.png"></p><p>这里并没有用到贪心思路，而是根据题意进行的一个模拟。</p><h3 id="完整代码-9"><a href="#完整代码-9" class="headerlink" title="完整代码"></a>完整代码</h3><p>注意这道题干说了字符串只包含因英文小写字母，所以使用一个定长的数组，效率会高于<code>unordered_map</code>数据结构。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">partitionLabels</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 统计每个字符最远出现的下标位置</span></span><br><span class="line">        <span class="comment">// unordered_map&lt;char, int&gt; indexMap;</span></span><br><span class="line">        <span class="type">int</span> indexMap[<span class="number">27</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; s.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            indexMap[s[i]-<span class="string">&#x27;a&#x27;</span>] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 遍历下标数组，如果当前数组的元素值和下标值相同，则找到了一个切割点</span></span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; retV;</span><br><span class="line">        <span class="type">int</span> start = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> end = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; s.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="comment">// 每一次都是在start,end范围内，找已经出现过的字符的最远出现位置</span></span><br><span class="line">            <span class="comment">// 如果最终i等于end了，说明当前字符是之前出现过的字符最后出现过的一个位置</span></span><br><span class="line">            <span class="comment">// 在当前字符之后，是不会有其他已经出现过的字符的，不然这里的max就没有意义了</span></span><br><span class="line">            end = <span class="built_in">max</span>(end, indexMap[s[i]-<span class="string">&#x27;a&#x27;</span>]);</span><br><span class="line">            <span class="keyword">if</span> (i == end) &#123;</span><br><span class="line">                retV.<span class="built_in">push_back</span>(i - start + <span class="number">1</span>); <span class="comment">// 插入长度</span></span><br><span class="line">                start = i + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> retV;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/04/591cb30a642d04b6003ca73436a1deb9.png" alt="image.png"></p><h2 id="56-合并区间"><a href="#56-合并区间" class="headerlink" title="56 合并区间"></a>56 合并区间</h2><blockquote><p><a href="https://leetcode.cn/problems/merge-intervals/">https://leetcode.cn/problems/merge-intervals/</a></p></blockquote><h3 id="题目和思路-13"><a href="#题目和思路-13" class="headerlink" title="题目和思路"></a>题目和思路</h3><p>以数组 intervals 表示若干个区间的集合，其中单个区间为 <code>intervals[i] = [starti, endi]</code> 。请你合并所有重叠的区间，并返回 一个不重叠的区间数组，该数组需恰好覆盖输入中的所有区间 。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">示例 1：</span><br><span class="line">输入：intervals = [[1,3],[2,6],[8,10],[15,18]]</span><br><span class="line">输出：[[1,6],[8,10],[15,18]]</span><br><span class="line">解释：区间 [1,3] 和 [2,6] 重叠, 将它们合并为 [1,6].</span><br><span class="line"></span><br><span class="line">示例 2：</span><br><span class="line">输入：intervals = [[1,4],[4,5]]</span><br><span class="line">输出：[[1,5]]</span><br><span class="line">解释：区间 [1,4] 和 [4,5] 可被视为重叠区间。</span><br></pre></td></tr></table></figure><p>这道题和前面遇到的几个区间重叠的问题一致，都是需要先对给出数组按左区间进行排序，再判断重叠区间，最终将重叠的区间进行合并。</p><p>当<code>intervals[i][0] &lt;= intervals[i-1][1]</code>的时候，视作两个区间重叠（相同也是重叠的情况），此时需要扩展原有区间为<code>max(intervals[i][1],intervals[i-1][1])</code>，再继续向后遍历。</p><h3 id="完整代码-10"><a href="#完整代码-10" class="headerlink" title="完整代码"></a>完整代码</h3><p>注意vector是有front&#x2F;back这两个函数来访问第一个&#x2F;最后一个元素的，<strong>且返回的是引用</strong>，写<code>retV.back()</code>的代码可读性会好于<code>retV[retV.size()-1]</code>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="comment">// 注意sort中升序是小于，降序是大于</span></span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">bool</span> <span class="title">cmp</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; a, vector&lt;<span class="type">int</span>&gt;&amp; b)</span> </span>&#123; <span class="keyword">return</span> a[<span class="number">0</span>] &lt; b[<span class="number">0</span>]; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">merge</span>(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; intervals) &#123;</span><br><span class="line">        <span class="keyword">if</span> (intervals.<span class="built_in">size</span>() &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> intervals;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">sort</span>(intervals.<span class="built_in">begin</span>(), intervals.<span class="built_in">end</span>(), cmp);</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; retV; <span class="comment">// 结果集</span></span><br><span class="line">        <span class="comment">// 先直接把第一个元素插入</span></span><br><span class="line">        retV.<span class="built_in">push_back</span>(intervals[<span class="number">0</span>]);</span><br><span class="line">        <span class="comment">// 从第二个元素开始遍历</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; intervals.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="comment">// 判断当前区间是否小于结果集中上一个的边界</span></span><br><span class="line">            <span class="keyword">if</span> (intervals[i][<span class="number">0</span>] &lt;= retV.<span class="built_in">back</span>()[<span class="number">1</span>]) &#123;</span><br><span class="line">                <span class="comment">// 如果小于，更新为两个值中更大的那个</span></span><br><span class="line">                retV.<span class="built_in">back</span>()[<span class="number">1</span>] = <span class="built_in">max</span>(intervals[i][<span class="number">1</span>], retV.<span class="built_in">back</span>()[<span class="number">1</span>]);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="comment">// 不小于，插入结果集</span></span><br><span class="line">            &#123;</span><br><span class="line">                retV.<span class="built_in">push_back</span>(intervals[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> retV;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/04/24f7470bf9f4043065640d9429b85037.png" alt="image.png"></p><h2 id="738-单调递增的数字"><a href="#738-单调递增的数字" class="headerlink" title="738 单调递增的数字"></a>738 单调递增的数字</h2><blockquote><p><a href="https://leetcode.cn/problems/monotone-increasing-digits/description/">https://leetcode.cn/problems/monotone-increasing-digits/description/</a></p></blockquote><h3 id="题目和思路-14"><a href="#题目和思路-14" class="headerlink" title="题目和思路"></a>题目和思路</h3><p>当且仅当每个相邻位数上的数字 x 和 y 满足 x &lt;&#x3D; y 时，我们称这个整数是单调递增的。</p><p>给定一个整数 n ，返回 小于或等于 n 的最大数字，且数字呈 单调递增 。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">示例 1:</span><br><span class="line">输入: n = 10</span><br><span class="line">输出: 9</span><br><span class="line"></span><br><span class="line">示例 2:</span><br><span class="line">输入: n = 1234</span><br><span class="line">输出: 1234</span><br><span class="line"></span><br><span class="line">示例 3:</span><br><span class="line">输入: n = 332</span><br><span class="line">输出: 299</span><br></pre></td></tr></table></figure><p>这道题需要我们<strong>从后往前</strong>遍历一个数字，方便处理，我们可以先把数字转成一个字符串（当然遍历一下写入到数组中也是可以的）。</p><ul><li>当前位大于上一位，不处理</li><li>当前位小于上一位，将上一位减一，当前位可以设置为9</li></ul><p>因为题目中给出的递增数字中，<code>x99999</code>也算做递增的情况，所以第二种情况，可以先记录一下当前的下标，并使用第二个循环从这个下标位置开始往后全部都设置为9。</p><h3 id="完整代码-11"><a href="#完整代码-11" class="headerlink" title="完整代码"></a>完整代码</h3><p>代码如下，不算难写。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">monotoneIncreasingDigits</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        string s = <span class="built_in">to_string</span>(n);</span><br><span class="line">        <span class="comment">// 从后往前遍历</span></span><br><span class="line">        <span class="type">int</span> start = s.<span class="built_in">size</span>() + <span class="number">1</span>; <span class="comment">// 初始化为不会进入第二个循环的值</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = s.<span class="built_in">size</span>() - <span class="number">1</span>; i &gt;= <span class="number">1</span>; i--) &#123;</span><br><span class="line">            <span class="comment">// 对于ascii来说也是增加的，所以可以直接判断</span></span><br><span class="line">            <span class="keyword">if</span> (s[i - <span class="number">1</span>] &gt; s[i]) &#123;</span><br><span class="line">                s[i - <span class="number">1</span>]--;</span><br><span class="line">                start = i; <span class="comment">// 从这一位开始设置9</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 从start开始遍历，设置9，注意x99999也视作递增序列</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = start; i &lt; s.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            s[i] = <span class="string">&#x27;9&#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">atoi</span>(s.<span class="built_in">c_str</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/04/a55a84276ea4632ff6f95b747c348bc0.png" alt="image.png"></p><p>写完这个代码后，我想到了一个问题，有没有可能<code>s[i-1]=&#39;0&#39;</code>，这样减减一下岂不是上一位就不是数字了？</p><p>实际上是不可能出现这个情况的，如果<code>s[i-1]=&#39;0&#39;</code>的情况，当前位<code>s[i]</code>是不可能小于他的，最多是等于的情况（两个都是零），所以不会出现操作0减减，自然不会有问题。</p><h2 id="968-监控二叉树"><a href="#968-监控二叉树" class="headerlink" title="968 监控二叉树"></a>968 监控二叉树</h2><blockquote><p><a href="https://leetcode.cn/problems/binary-tree-cameras/description/">https://leetcode.cn/problems/binary-tree-cameras/description/</a></p></blockquote><h3 id="题目和代码"><a href="#题目和代码" class="headerlink" title="题目和代码"></a>题目和代码</h3><p>给定一个二叉树，我们在树的节点上安装摄像头。</p><p>节点上的每个摄影头都可以监视其父对象、自身及其直接子对象。</p><p>计算监控树的所有节点所需的最小摄像头数量。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">这道题的示例建议看leetcode上给出的图例。</span><br><span class="line"></span><br><span class="line">输入：[0,0,null,0,0]</span><br><span class="line">输出：1</span><br><span class="line">解释：如图所示，一台摄像头足以监控所有节点。</span><br></pre></td></tr></table></figure><p>本题需要我们计算监控所有节点涉及到的最少的摄像头数量，那么一个摄像头最好是能同时监控下层和上层（没有漏掉的层），<strong>才是利用率最大化</strong>。这也是贪心的思想所在。首先可以确定的是，我们需要用<strong>后续遍历</strong>，从最底下开始往上遍历整个树。</p><p>根据这个思路，<strong>叶子节点肯定不能装摄像头</strong>。因为叶子节点没有子树，装摄像头相当于白白浪费了摄像头对下一层子树的监看，最终肯定不能达到最大的监控数量。</p><p>这个思路能帮我们确定递归的终止条件，即在空节点应该返回什么。不过在编写代码之前，我们应该先定义好三个状态值。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">0 没有监控也没有被覆盖上</span><br><span class="line">1 装了监控</span><br><span class="line">2 被覆盖上了（但是没有装监控）</span><br></pre></td></tr></table></figure><p>那么空节点应该返回哪一个状态码呢？先来考虑一下什么时候当前节点需要装摄像头</p><ul><li>左子树和右子树只要有其中一个装了摄像头（返回值为1），当前节点就能被覆盖上，不需要装摄像头；</li><li>右子树和左子树只要有一个没有被覆盖上（返回值为0），那么当前节点就必须装摄像头，<strong>否则会有子树无法被覆盖</strong>；</li></ul><p>由此可见，空节点不能返回1，因为这说明叶子节点被覆盖了，反馈到上一层会认为不需要装摄像头，导致最终叶子节点并没有被覆盖上，不符合题目条件。空节点也不能返回0，因为这说明叶子节点需要装摄像头。</p><p>所以，空节点只能返回2啦！</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(root == <span class="literal">nullptr</span>)&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其他情况就是上文提到的，采用后续遍历，用left&#x2F;right接受左右子树遍历的结果，只要有一个为0，那么就需要装摄像头，摄像头数量加一，函数返回1；</p><p>最后是只要有一个为1，就代表不用装摄像头，返回2；</p><h3 id="完整代码-12"><a href="#完整代码-12" class="headerlink" title="完整代码"></a>完整代码</h3><p>依照上述思路可以写出如下代码。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="comment">// 0代表没有被摄像头覆盖</span></span><br><span class="line">    <span class="comment">// 1代表有摄像头</span></span><br><span class="line">    <span class="comment">// 2代表被摄像头覆盖（但是没有装摄像头）</span></span><br><span class="line">    <span class="type">int</span> _minCameraCoverResult(TreeNode* root, <span class="type">int</span>&amp; result) &#123;</span><br><span class="line">        <span class="comment">// 空节点视作被摄像头覆盖了（题目不需要考虑空节点）</span></span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 后续遍历</span></span><br><span class="line">        <span class="type">int</span> left = _minCameraCoverResult(root-&gt;left, result);</span><br><span class="line">        <span class="type">int</span> right = _minCameraCoverResult(root-&gt;right, result);</span><br><span class="line">        <span class="comment">// 判断当前节点是否需要装摄像头</span></span><br><span class="line">        <span class="comment">// 1.如果两个都是2，代表当前节点不需要装摄像头（不然会损失一层覆盖），返回0</span></span><br><span class="line">        <span class="keyword">if</span> (left == <span class="number">2</span> &amp;&amp; right == <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">// 当前节点不装摄像头也没有被覆盖</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 2.如果两个节点中有一个是0，则代表当前节点必须装摄像头才能覆盖到下一层的节点</span></span><br><span class="line">        <span class="keyword">if</span> (left == <span class="number">0</span> || right == <span class="number">0</span>) &#123;</span><br><span class="line">            result++; <span class="comment">// 当前节点需要装摄像头</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 注意必须先判断两个其中有一个为0的情况，因为这种情况是必须装摄像头的；</span></span><br><span class="line">        <span class="comment">// 比如：一个为1一个为0，虽然此时本层已经被覆盖，但有一个子树没有覆盖上，本层必须装摄像头</span></span><br><span class="line">        <span class="comment">// 3.两个节点中其中一个是1，说明当前节点已经被覆盖上，不需要装摄像头</span></span><br><span class="line">        <span class="keyword">if</span> (left == <span class="number">1</span> || right == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">// 理论上不会走到这里</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">minCameraCover</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> result = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 如果当前位是0（没有覆盖上，即root节点没有被覆盖）</span></span><br><span class="line">        <span class="keyword">if</span> (_minCameraCoverResult(root, result) == <span class="number">0</span>) &#123;</span><br><span class="line">            result++; <span class="comment">// root节点装摄像头</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/04/eeedb0da2db9105ff8ce3ddc422ae219.png" alt="image.png"></p>]]></content>
    
    
    <summary type="html">学习贪心算法</summary>
    
    
    
    <category term="编程学习" scheme="https://blog.musnow.top/categories/%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="默认分组" scheme="https://blog.musnow.top/categories/%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0/%E9%BB%98%E8%AE%A4%E5%88%86%E7%BB%84/"/>
    
    
    <category term="算法" scheme="https://blog.musnow.top/tags/%E7%AE%97%E6%B3%95/"/>
    
    <category term="leetcode" scheme="https://blog.musnow.top/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>【win】windows11让蓝牙耳机不进入通话模式</title>
    <link href="https://blog.musnow.top/posts/137069193/"/>
    <id>https://blog.musnow.top/posts/137069193/</id>
    <published>2024-04-06T01:07:34.000Z</published>
    <updated>2024-04-06T01:16:18.000Z</updated>
    
    <content type="html"><![CDATA[<p>在windows上让蓝牙耳机不进入通话模式。</p><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>如果你在windows上使用过蓝牙耳机打游戏，你会发现在部分游戏中（比如战地2042），耳机会进入<strong>通话模式</strong>，音质巨差无比。</p><p>这是因为该游戏将麦克风设置为了蓝牙耳机，让耳机进入了通话模式。</p><blockquote><p>PS：作为娱乐玩家，蓝牙耳机的延迟对于我来说是无感的。</p></blockquote><p>实际上，win对蓝牙的支持本来就是一坨，即便用耳机麦克风也什么都听不清，还不如用笔记本电脑自己的麦克风。要知道，现在的笔记本（基本上）都有2到4个阵列麦克风，在正常使用场景下，笔记本麦大概率优于windows下使用蓝牙耳机的麦。</p><blockquote><p>如果你是台式，个人建议买带耳麦的有线&#x2F;2.4G游戏耳机或另购麦克风</p></blockquote><p>所以现在要解决的就是，如何让游戏无法使用蓝牙耳机的麦克风，避免蓝牙耳机进入通话模式。</p><h2 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h2><p>解决方法很粗暴：让windows不能将蓝牙耳机识别成音频输入设备，只能作为音频输出设备。</p><p>windows11进入系统<strong>设置-声音</strong>模块，在<code>输入</code>中找到你的蓝牙耳机，点击它，会进入属性页面，勾选不允许windows将设备用于音频（这只会关掉蓝牙耳机的麦克风）</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/04/0b8fcad25c745125217b5927502da036.png" alt="image.png"></p><p>勾选完毕后，回到<code>设置-声音</code>页面，你应该会发现输入设备中已经没有蓝牙耳机了</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/04/81e1f76aecdd6bf9ed90cb9c383af1d7.png" alt="image.png"></p><p>这样就OK了，你的蓝牙耳机再也不会进入通话模式了。</p>]]></content>
    
    
    <summary type="html">windows11让蓝牙耳机不进入通话模式</summary>
    
    
    
    <category term="差生文具多" scheme="https://blog.musnow.top/categories/%E5%B7%AE%E7%94%9F%E6%96%87%E5%85%B7%E5%A4%9A/"/>
    
    <category term="电脑使用小贴士" scheme="https://blog.musnow.top/categories/%E5%B7%AE%E7%94%9F%E6%96%87%E5%85%B7%E5%A4%9A/%E7%94%B5%E8%84%91%E4%BD%BF%E7%94%A8%E5%B0%8F%E8%B4%B4%E5%A3%AB/"/>
    
    
    <category term="windows" scheme="https://blog.musnow.top/tags/windows/"/>
    
  </entry>
  
  <entry>
    <title>【leetcode】295.数据流的中位数</title>
    <link href="https://blog.musnow.top/posts/196461022/"/>
    <id>https://blog.musnow.top/posts/196461022/</id>
    <published>2024-03-30T07:05:54.000Z</published>
    <updated>2024-03-30T07:05:54.000Z</updated>
    
    <content type="html"><![CDATA[<p> leetcode题295.数据流的中位数</p><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><blockquote><p><a href="https://leetcode.cn/problems/find-median-from-data-stream/">295. 数据流的中位数</a></p></blockquote><p><strong>中位数</strong>是有序整数列表中的中间值。如果列表的大小是偶数，则没有中间值，中位数是两个中间值的平均值。</p><ul><li>例如 <code>arr = [2,3,4]</code> 的中位数是 <code>3</code> 。</li><li>例如 <code>arr = [2,3]</code> 的中位数是 <code>(2 + 3) / 2 = 2.5</code> 。</li></ul><p>实现 MedianFinder 类:</p><ul><li><code>MedianFinder() </code>初始化 <code>MedianFinder</code> 对象。</li><li><code>void addNum(int num)</code> 将数据流中的整数 <code>num</code> 添加到数据结构中。</li><li><code>double findMedian()</code> 返回到目前为止所有元素的中位数。与实际答案相差 <code>10^-5</code> 以内的答案将被接受。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">示例 1：</span><br><span class="line">输入</span><br><span class="line">[&quot;MedianFinder&quot;, &quot;addNum&quot;, &quot;addNum&quot;, &quot;findMedian&quot;, &quot;addNum&quot;, &quot;findMedian&quot;]</span><br><span class="line">[[], [1], [2], [], [3], []]</span><br><span class="line">输出</span><br><span class="line">[null, null, null, 1.5, null, 2.0]</span><br><span class="line"></span><br><span class="line">解释</span><br><span class="line">MedianFinder medianFinder = new MedianFinder();</span><br><span class="line">medianFinder.addNum(1);    // arr = [1]</span><br><span class="line">medianFinder.addNum(2);    // arr = [1, 2]</span><br><span class="line">medianFinder.findMedian(); // 返回 1.5 ((1 + 2) / 2)</span><br><span class="line">medianFinder.addNum(3);    // arr[1, 2, 3]</span><br><span class="line">medianFinder.findMedian(); // return 2.0</span><br></pre></td></tr></table></figure><p><strong>提示:</strong></p><ul><li><code>-10^5 &lt;= num &lt;= 10^5</code>;</li><li>在调用 <code>findMedian</code> 之前，数据结构中至少有一个元素;</li><li>最多 <code>5 * 104</code> 次调用 <code>addNum</code> 和 <code>findMedian</code>;</li></ul><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>来自k神的题解 <a href="https://leetcode.cn/problems/find-median-from-data-stream/solutions/2361972/295-shu-ju-liu-de-zhong-wei-shu-dui-qing-gmdo/">https://leetcode.cn/problems/find-median-from-data-stream/solutions/2361972/295-shu-ju-liu-de-zhong-wei-shu-dui-qing-gmdo/</a> ，用两个堆来解决这个问题。</p><p>首要的思想是，我们需要将数组流存入一个有序的数组，再确定中位数。不用堆的情况下，我们可以利用插入排序的思想，将新数据插入到数组中的正确位置。这涉及到<code>O(N)</code>的数组中元素的移动，以及利用二分查找数组的插入位置<code>O(LogN)</code>。总的时间复杂度是<code>O(logN+N)</code></p><p>使用两个堆，就可以将整体的时间复杂度控制在<code>O(logN)</code>上，一定程度上能提高效率。</p><ul><li>小堆A用来存放数组大的那一部分数据（你可以理解为堆内元素是倒序，堆顶是最小的数）</li><li>大堆B用来存放数组小的那一部分的数据（堆内元素是正序，堆顶是最大的数）</li><li>A中的所有数据都必须大于B</li></ul><p>此时小堆A对着大堆B，就构成了一个完整的“有序数组”。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">小堆A [6,5,4]   [3,2,1] 大堆B</span><br><span class="line">   小堆堆顶4    大堆堆顶3</span><br></pre></td></tr></table></figure><p>插入的时候，约定小堆A的元素数量应该大于大堆B，分为奇数和偶数的情况</p><ul><li>A和B的大小相等，说明当前数据流数量是偶数，往A中插入元素<ul><li>需要先将待插入元素num和B的堆顶元素比较（确保A中是数组大的那一部分的数据）</li><li>如果num大于B的堆顶元素，则直接插入A；</li><li>如果num小于B的堆顶元素，则插入B后，往A内插入B的堆顶元素，再弹出B的堆顶元素；</li></ul></li><li>A的元素个数大于B，说明当前数据流数量是奇数，往B中插入元素<ul><li>将插入元素和A的堆顶元素比较</li><li>如果num大于A的堆顶元素，则将A的堆顶元素插入B，弹出A的堆顶元素，再将num插入A；</li><li>如果num小于A的堆顶元素，则将num直接插入B</li></ul></li></ul><p>查询中位数的时候，也分为奇数和偶数的情况，注意题目要求的返回值是double</p><ul><li>A和B的元素个数相等，说明是偶数，中位数为<code>(A堆顶元素+B堆顶元素)/2.0</code>；</li><li>A和B的元素个数不相等（肯定是A的元素多），说明是奇数，中位数为<code>A的堆顶元素*1.0</code>。</li></ul><p>思路会了，写代码就不难了。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>注意cpp中优先级队列默认是大堆，且std库中提供了less和greater作为堆的比较函数</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MedianFinder</span> &#123;</span><br><span class="line">    <span class="comment">// 注意优先级队列C++中默认的比较函数是less，存放的是大堆</span></span><br><span class="line">    priority_queue&lt;<span class="type">int</span>&gt; _queBig; <span class="comment">// 大堆，存放小半边数据</span></span><br><span class="line">    priority_queue&lt;<span class="type">int</span>, vector&lt;<span class="type">int</span>&gt;, std::greater&lt;<span class="type">int</span>&gt;&gt;</span><br><span class="line">        _queSm; <span class="comment">// 小堆，存放大半边数据</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MedianFinder</span>() &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 保证较大的一半数据更多</span></span><br><span class="line">    <span class="comment">// 奇数的时候较大的一半堆顶就是中位数</span></span><br><span class="line">    <span class="comment">// 偶数的时候，较小+较大堆顶/2就是中位数</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">addNum</span><span class="params">(<span class="type">int</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (_queBig.<span class="built_in">size</span>() == _queSm.<span class="built_in">size</span>()) &#123;</span><br><span class="line">            <span class="comment">// 注意sm存放的是大的那一半</span></span><br><span class="line">            <span class="comment">// _queSm.push(num);</span></span><br><span class="line">            <span class="comment">// error！不能直接插入!</span></span><br><span class="line">            <span class="comment">// 先把num插入到big里面，再把big里面最大的那个数插入到sm里面！</span></span><br><span class="line">            <span class="comment">// 因为需要保证有序，如果直接插入，此时num的值可能比big里面的堆顶元素小！</span></span><br><span class="line">            _queBig.<span class="built_in">push</span>(num);</span><br><span class="line">            _queSm.<span class="built_in">push</span>(_queBig.<span class="built_in">top</span>());</span><br><span class="line">            _queBig.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 大的那一半数据更多</span></span><br><span class="line">        <span class="comment">// 注意sm存放的是大的那一半</span></span><br><span class="line">        <span class="keyword">if</span> (_queBig.<span class="built_in">size</span>() &lt; _queSm.<span class="built_in">size</span>()) &#123;</span><br><span class="line">            <span class="comment">// 如果当前数比大堆堆顶的更大，则需要放到大的那一半中</span></span><br><span class="line">            <span class="keyword">if</span> (num &gt; _queSm.<span class="built_in">top</span>()) &#123;</span><br><span class="line">                _queBig.<span class="built_in">push</span>(_queSm.<span class="built_in">top</span>());</span><br><span class="line">                _queSm.<span class="built_in">pop</span>();</span><br><span class="line">                _queSm.<span class="built_in">push</span>(num);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 其他情况都往小的那一半里面插</span></span><br><span class="line">            _queBig.<span class="built_in">push</span>(num);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">double</span> <span class="title">findMedian</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (_queBig.<span class="built_in">size</span>() == _queSm.<span class="built_in">size</span>()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">double</span>((_queBig.<span class="built_in">top</span>() + _queSm.<span class="built_in">top</span>()) / <span class="number">2.0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// sm才是大的那一半</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">double</span>(_queSm.<span class="built_in">top</span>() * <span class="number">1.0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your MedianFinder object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * MedianFinder* obj = new MedianFinder();</span></span><br><span class="line"><span class="comment"> * obj-&gt;addNum(num);</span></span><br><span class="line"><span class="comment"> * double param_2 = obj-&gt;findMedian();</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/03/ab2c48575f9575470fc55b39f21268dc.png" alt="image-20240330163821849"></p>]]></content>
    
    
    <summary type="html">leetcode题295.数据流的中位数</summary>
    
    
    
    <category term="编程学习" scheme="https://blog.musnow.top/categories/%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="把题目都给刷干净" scheme="https://blog.musnow.top/categories/%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0/%E6%8A%8A%E9%A2%98%E7%9B%AE%E9%83%BD%E7%BB%99%E5%88%B7%E5%B9%B2%E5%87%80/"/>
    
    
    <category term="堆" scheme="https://blog.musnow.top/tags/%E5%A0%86/"/>
    
    <category term="leetcode" scheme="https://blog.musnow.top/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>【C++】布隆过滤器（海量数据处理）</title>
    <link href="https://blog.musnow.top/posts/3245288951/"/>
    <id>https://blog.musnow.top/posts/3245288951/</id>
    <published>2024-03-30T01:26:11.000Z</published>
    <updated>2024-04-14T02:31:36.000Z</updated>
    
    <content type="html"><![CDATA[<p>面试的时候可能会考到这种大数据处理的问题，如果不记得布隆过滤器是干嘛的，那就G喽！</p><blockquote><p>本文参考：<a href="https://blog.csdn.net/weixin_58450087/article/details/123512052">https://blog.csdn.net/weixin_58450087/article/details/123512052</a> 编写</p></blockquote><h1 id="1-什么是布隆过滤器？"><a href="#1-什么是布隆过滤器？" class="headerlink" title="1.什么是布隆过滤器？"></a>1.什么是布隆过滤器？</h1><p>布隆过滤器（Bloom Filter）是1970年由布隆提出的。它实际上是一个很长的二进制向量和一系列随机映射函数。它通过多个哈希函数将一个数据映射到位图的结构中（也就是一个数据映射位图的多个位置，这样就可以减少冲突的概率）。布隆过滤器可以用于检索一个元素是否在一个集合中。它的优点是空间效率和查询时间都比一般的算法要好的多，缺点是有一定的误识别率和删除困难。</p><h2 id="1-1-引入"><a href="#1-1-引入" class="headerlink" title="1.1 引入"></a>1.1 引入</h2><p>在认识布隆过滤器之前，我们先要认识一下哈希和位图的思想。</p><ul><li>哈希：通过哈希函数将value映射到数组中的某个key值下标的位置进行存储，方便查询；但对于海量数据来说占用空间大。</li><li>位图：通过比特0和1来代表某一位的状态，极致节省空间；但无法处理哈希冲突问题。</li></ul><p>布隆过滤器就是这两个思想的结合，可以帮助我们处理海量数据！</p><h2 id="1-2-思想"><a href="#1-2-思想" class="headerlink" title="1.2 思想"></a>1.2 思想</h2><p>在哈希中，我们一般只使用一个哈希函数来进行value和key的映射，哈希可以通过拉链法或者线性探测法来解决哈希冲突问题。</p><p>但在布隆过滤器中，因为需要使用<strong>位图</strong>来做底层的数据结构，此时一个哈希函数就不够了，我们需要多个哈希函数，同时针对一个value进行计算，并将计算出来的多个结果位都置1，以此来减少冲突的概率，同时节省空间。</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/03/60313e1ecb3c9654d752958cd39d83d5.png" alt="img"></p><p>比如我有字符串A、B、C和三个哈希函数</p><ul><li>A计算出来是10、29、39；</li><li>B计算出来是29、30、54；</li><li>C计算出来是30、34、44；</li></ul><p>那么就需要将位图中对应的比特置1，当查询B字符串的时候，判断29、30、54位是否为1，有一个不为1则可以确定B不在过滤器中，全为1的时候可以确定B<strong>可能</strong>在布隆过滤器中。</p><h3 id="“可能在”问题"><a href="#“可能在”问题" class="headerlink" title="“可能在”问题"></a>“可能在”问题</h3><p>为什么是<strong>可能在</strong>呢？看看下面的情况</p><ul><li>A计算出来1、2、3；</li><li>B计算出来4、5、6；</li></ul><p>将A和B放入布隆过滤器，假设来了一个C字符串，计算出来2、3、6。这时候问题就出现了，C字符串并不在布隆过滤器中，但它计算出来的对应位都被A和B置为1了，此时我们就只能得出一个<strong>C可能在布隆过滤器</strong>中的结论，没有办法确定C到底在不在。</p><p>如果C计算出来是2、6、9，可以确定C<strong>绝对不在</strong>布隆过滤器中！</p><p>这也是布隆过滤器的得名所在，它只是一个过滤器！并非100%能确定结果的！布隆过滤器只可以确定<strong>绝对不在</strong>和<strong>可能在</strong>。</p><h3 id="无法删除元素"><a href="#无法删除元素" class="headerlink" title="无法删除元素"></a>无法删除元素</h3><p>因为布隆过滤器是用位图记录1和0的，如果我们将一个元素的哈希函数对应的值全都从1置0来删除的话，可能会影响到其他元素。</p><p>比如A是1、2、6，B是5、6、8，删除A的时候将1、2、6置0，这就影响了B（因为B也需要第6位来判断他是否在）</p><p>解决方法是采用计数方式来代替删除：位图的每一位进行一定扩展，比如扩展到3个bit来表示，这样就有了一个最大值为7的计数器，遇到一位映射就加一，删除就减一。</p><p>但这会引出两个问题：</p><ol><li>位图的大小会成倍增加，可能会导致布隆过滤器的内存优势削弱；</li><li>如果计数器溢出了，会出现<strong>计数回绕</strong>问题；</li></ol><p>计数回绕问题：当实际出现次数超过计数器位数后，会导致溢出回归到初始值，无法确定计数器是否正确。比如上文说的用3个bit来计数，假设这一位的出现次数已经是8了，得到的二进制结果是1000，此时低三位变成了全0，下一次判断的时候会发现这一位压根没有值，造成了错误判断。</p><p>所以实际场景中，我们又需要判断到底用几位来做这个计数器，以达到一定的平衡性。不过鉴于布隆过滤器的使用场景大多都是个过滤，避免删除元素反而成了更好的措施。</p><h3 id="如何精确确认？"><a href="#如何精确确认？" class="headerlink" title="如何精确确认？"></a>如何精确确认？</h3><p>前文提到了，布隆过滤器无法100%确认某个元素一定存在。那如果某一个场景一定需要100%确认，咋办？</p><p>举个实际的例子，假设一个游戏，用户注册的时候给自己起个玩家昵称，此时游戏需要保证玩家昵称不能重复，这时候可以怎么做？</p><ul><li>玩家键入一个名字后，客户端发起API请求，向数据服务器申请检查该名字是否已经被使用。</li></ul><p>这是一个很简单的数据库查询（暂时不考虑数据库缓存的问题），但如果一个游戏刚刚开服或者做活动，大量新玩家涌入，一个玩家每输入一个名字的时候就需要发送一个API请求，数据库服务器还能接受的了这么海量的查询请求吗？</p><ul><li>在查询数据库之前设立一个布隆过滤器，将全服玩家昵称映射进去。</li><li>当新玩家注册的时候，访问布隆过滤器，判断玩家昵称是否存在</li><li>如果布隆过滤器判断不存在（百分百可靠），API直接返回结果，允许玩家用该昵称注册；</li><li>如果布隆过滤器判断存在，则回数据库查询到底是否存在，如果存在则要求玩家改昵称，如果不存在（误判）则允许玩家用该昵称注册。</li></ul><p>这时候，布隆过滤器的“过滤”功能就很明显的体现了。而且因为查询的时候都是读操作，这时候就可以用多线程并发的<code>读写锁</code>来对布隆过滤器进行加锁，一定程度上提高查询的并发效率。</p><p>当然，玩家昵称注册的这个功能还有其他的解决办法，比如拳头的瓦洛兰特和暴雪的游戏，玩家昵称后还会带有一个<code>#</code>以及四位数字标识，可以让这四位数字标识由服务端生成，来避免两个玩家完全重名。除非四位标识都用完了（0000到9999），才提示玩家该昵称不可用。这样也一定程度上进行了过滤，减少了对数据库的查询次数。</p><h2 id="1-3-优缺点"><a href="#1-3-优缺点" class="headerlink" title="1.3 优缺点"></a>1.3 优缺点</h2><p>优点</p><ul><li>增加和查询的时间复杂度都为<code>O(K)</code>，K为哈希函数的个数</li><li>多个哈希函数之间没有关系，方便进行并行计算（多线程）</li><li>布隆过滤器并不存储元素本身，所以占用空间小，特别是海量数据处理时</li><li>如果多个布隆过滤器使用的是相同的哈希函数，则可以进行并集\交集\差集的计算</li></ul><p>缺点</p><ul><li>没有办法百分百确定value一定在，只能确定<strong>一定不在</strong>；</li><li>无法从布隆过滤器中直接获得value；</li><li>不能从布隆过滤器中删除元素（用计数方式删除会有<strong>计数回绕</strong>问题）</li></ul><h2 id="1-4-布隆过滤器的位图长度选择"><a href="#1-4-布隆过滤器的位图长度选择" class="headerlink" title="1.4 布隆过滤器的位图长度选择"></a>1.4 布隆过滤器的位图长度选择</h2><p>对于布隆过滤器来说，M（位图长度）和K（哈希函数个数）越多的时候，冲突的概率就越少。可以根据具体场景的需求，选用更大的M和K来解决冲突，让冲突的概率变小，具体需要多小的冲突概率，是由业务需要来确定的。</p><p>布隆过滤器的哈希函数与位图长度的选择关系公式如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">m = - n * ln(p) / (ln(2)^2) </span><br><span class="line">k = m/n * ln(2)</span><br><span class="line"></span><br><span class="line">// k 为哈希函数个数</span><br><span class="line">// m 为布隆过滤器长度</span><br><span class="line">// n 为插入的元素个数</span><br><span class="line">// p 为可接受该容器的误报率（0-1）</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/03/d8dee57696510408455bf30cd55d8c1d.png" alt="img"></p><p>PS：GPT说最终位图的长度还需要<code>K*M</code>，感觉是在瞎说，查了不少资料，应该是不需要进行这一步的。</p><h1 id="2-代码"><a href="#2-代码" class="headerlink" title="2.代码"></a>2.代码</h1><h2 id="2-1-位图"><a href="#2-1-位图" class="headerlink" title="2.1 位图"></a>2.1 位图</h2><p>布隆过滤器的代码基于位图。位图就不单开博客记录了，本质就是一个整形数组，把每一个比特当作位图中的每一位进行处理，对应按位与和按位或操作就OK了，不是很难理解。</p><p>位图的底层可以用vector，也可以用原生的new&#x2F;delete的数组来处理。用原生的可以节省一定的空间消耗。</p><p>位图的优点是可以节省空间，查找和设置的耗时极低，都是<code>O(1)</code>的时间复杂度。缺点是没有办法处理冲突情况，且只支持整数数据。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">BitMaps</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="type">size_t</span> _bitCount; <span class="comment">// 位图中比特的个数</span></span><br><span class="line"><span class="comment">//std::vector&lt;uint32_t&gt; _bitMap; // 使用int32_t来确保长度</span></span><br><span class="line"><span class="type">uint32_t</span>* _bitMap; <span class="comment">// 用动态内存管理来节省一定空间，vector会有额外内存消耗</span></span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="type">uint8_t</span> _weight = <span class="number">32</span>; <span class="comment">// 用的int32，设置为32方便后序修改</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">size_t</span> <span class="title">GetIndex</span><span class="params">(<span class="type">size_t</span> bit)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> bit / _weight;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">size_t</span> <span class="title">GetOffset</span><span class="params">(<span class="type">size_t</span> bit)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> bit % _weight;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="comment">// 需要多少比特的空间</span></span><br><span class="line"><span class="built_in">BitMaps</span>(<span class="type">size_t</span> bitCount):_bitCount(bitCount),_bitMap(<span class="literal">nullptr</span>) &#123;</span><br><span class="line"><span class="comment">// 需要多少个int来存放空间</span></span><br><span class="line"><span class="type">size_t</span> arraySize = bitCount / _weight + <span class="number">1</span>;</span><br><span class="line"><span class="comment">// 用原生数组一定程度上节省空间</span></span><br><span class="line"><span class="comment">// _bitMap.resize(arraySize);</span></span><br><span class="line">_bitMap = <span class="keyword">new</span> <span class="type">uint32_t</span>[arraySize];</span><br><span class="line"><span class="comment">// 遍历初始化为全0</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; arraySize; i++)</span><br><span class="line">&#123;</span><br><span class="line">_bitMap[i] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用动态内存管理，需要delete</span></span><br><span class="line">~<span class="built_in">BitMaps</span>()</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (_bitMap != <span class="literal">nullptr</span>) &#123;</span><br><span class="line"><span class="keyword">delete</span>[] _bitMap;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将第几位的比特设置为1</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Set</span><span class="params">(<span class="type">size_t</span> bit)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// 超出范围的时候报错</span></span><br><span class="line"><span class="built_in">assert</span>(bit &lt;= _bitCount); </span><br><span class="line"></span><br><span class="line"><span class="comment">// 计算下标位置</span></span><br><span class="line"><span class="type">size_t</span> index = <span class="built_in">GetIndex</span>(bit);</span><br><span class="line"><span class="comment">// 计算是这个下标的第几位</span></span><br><span class="line"><span class="type">size_t</span> offset = <span class="built_in">GetOffset</span>(bit); <span class="comment">// 0 到 31</span></span><br><span class="line"><span class="comment">// 设置进位图，按位或（有1为1）</span></span><br><span class="line">_bitMap[index] |= (<span class="number">1</span> &lt;&lt; offset);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 将对应位设置为0</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Reset</span><span class="params">(<span class="type">size_t</span> bit)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// 超出范围的时候报错</span></span><br><span class="line"><span class="built_in">assert</span>(bit &lt;= _bitCount);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 计算下标位置</span></span><br><span class="line"><span class="type">size_t</span> index = <span class="built_in">GetIndex</span>(bit);</span><br><span class="line"><span class="comment">// 计算是这个下标的第几位</span></span><br><span class="line"><span class="type">size_t</span> offset = <span class="built_in">GetOffset</span>(bit); <span class="comment">// 0 到 31</span></span><br><span class="line"><span class="comment">// 设置进位图，按位与，此时对应位为0，与之后肯定是0</span></span><br><span class="line">_bitMap[index] &amp;= ~(<span class="number">1</span> &lt;&lt; offset);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断第几位是否存在</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">Test</span><span class="params">(<span class="type">size_t</span> bit)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// 超出范围，肯定不存在</span></span><br><span class="line"><span class="keyword">if</span> (bit &gt; _bitCount) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 计算下标位置</span></span><br><span class="line"><span class="type">size_t</span> index = <span class="built_in">GetIndex</span>(bit);</span><br><span class="line"><span class="comment">// 计算是这个下标的第几位</span></span><br><span class="line"><span class="type">size_t</span> offset = <span class="built_in">GetOffset</span>(bit); <span class="comment">// 0 到 31</span></span><br><span class="line"><span class="comment">// 判断是否为1，按位与</span></span><br><span class="line"><span class="type">uint32_t</span> num = (<span class="number">1</span> &lt;&lt; offset);</span><br><span class="line"><span class="comment">// 与位图中的值按位与，只有两个都是1，才是1</span></span><br><span class="line">num &amp;= _bitMap[index];</span><br><span class="line"><span class="comment">// 为0代表不存在</span></span><br><span class="line"><span class="keyword">return</span> num != <span class="number">0</span>; </span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="2-2-布隆过滤器"><a href="#2-2-布隆过滤器" class="headerlink" title="2.2 布隆过滤器"></a>2.2 布隆过滤器</h2><h3 id="基本框架"><a href="#基本框架" class="headerlink" title="基本框架"></a>基本框架</h3><p>布隆过滤器需要指定哈希函数，有两种实现方式</p><ul><li>通过模板参数来指定哈希函数（但是只能固定个数）</li><li>通过函数来添加哈希函数（内部可以用一个function的vector来遍历调用）</li></ul><p>这里为了实现方便且以思路实现为主，采用第一种方式来处理。</p><h3 id="常用字符串哈希函数"><a href="#常用字符串哈希函数" class="headerlink" title="常用字符串哈希函数"></a>常用字符串哈希函数</h3><p>下面是三个比较常用的字符串哈希函数，由它们帮我们计算一个子串对应的三个位图下标。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">BKDRHash</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="function"><span class="type">size_t</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">const</span> std::string&amp; str)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">register</span> <span class="type">size_t</span> hash = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; str.<span class="built_in">size</span>(); ++i)</span><br><span class="line">&#123;</span><br><span class="line">hash = hash * <span class="number">131</span> + str[i];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> hash;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">SDBHash</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="function"><span class="type">size_t</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">const</span> std::string&amp; str)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">register</span> <span class="type">size_t</span> hash = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; str.<span class="built_in">size</span>(); ++i)</span><br><span class="line">&#123;</span><br><span class="line">hash = <span class="number">65599</span> * hash + str[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> hash;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">RSHash</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="function"><span class="type">size_t</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">const</span> std::string&amp; str)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">register</span> <span class="type">size_t</span> hash = <span class="number">0</span>;</span><br><span class="line"><span class="type">size_t</span> magic = <span class="number">63689</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; str.<span class="built_in">size</span>(); ++i)</span><br><span class="line">&#123;</span><br><span class="line">hash = hash * magic + str[i];</span><br><span class="line">magic *= <span class="number">378551</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> hash;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="类构造"><a href="#类构造" class="headerlink" title="类构造"></a>类构造</h3><p>布隆过滤器直接复用位图的实现即可，模板参数用缺省值来指定为字符串。如果需要存放其他类型的成员，不仅需要修改T参数，还需要修改三个哈希函数来适配该参数。</p><p>这里为了方便，直接用乘6来替代布隆过滤器的长度计算公式。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>= std::string, <span class="keyword">class</span> Hash1 = BKDRHash, <span class="keyword">class</span> Hash2 = SDBHash, <span class="keyword">class</span> Hash3 = RSHash&gt;</span><br><span class="line"><span class="keyword">class</span> BloomFilter</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="comment">// 长度计算公式 m = - n * ln(p) / (ln(2)^2) </span></span><br><span class="line"><span class="comment">// 为了实现方便，暂时用6来替代</span></span><br><span class="line"><span class="built_in">BloomFilter</span>(<span class="type">size_t</span> size)</span><br><span class="line">:_bs(<span class="number">6</span> * size)</span><br><span class="line">, _bitSize(<span class="number">6</span> * size)</span><br><span class="line">&#123;&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">BitMaps _bs; <span class="comment">// 位图</span></span><br><span class="line"><span class="type">size_t</span> _bitSize;<span class="comment">// 能够映射bit个数 </span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="设置元素"><a href="#设置元素" class="headerlink" title="设置元素"></a>设置元素</h3><p>设置元素的时候，通过三个哈希函数计算不同的下标值，设置进位图里面就行了。注意这里哈希函数的返回结果需要模一下位图的长度，避免越界。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 设置</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Set</span><span class="params">(<span class="type">const</span> T&amp; t)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">size_t</span> hash1 = <span class="built_in">Hash1</span>()(t) % _bitSize;</span><br><span class="line"><span class="type">size_t</span> hash2 = <span class="built_in">Hash2</span>()(t) % _bitSize;</span><br><span class="line"><span class="type">size_t</span> hash3 = <span class="built_in">Hash3</span>()(t) % _bitSize;</span><br><span class="line"></span><br><span class="line">_bs.<span class="built_in">Set</span>(hash1);</span><br><span class="line">_bs.<span class="built_in">Set</span>(hash2);</span><br><span class="line">_bs.<span class="built_in">Set</span>(hash3);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="查找元素"><a href="#查找元素" class="headerlink" title="查找元素"></a>查找元素</h3><p>同样是调用位图的test函数，只有三个都在的时候，才是元素可能在布隆过滤器中。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 判断</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">Test</span><span class="params">(<span class="type">const</span> T&amp; t)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">size_t</span> hash1 = <span class="built_in">Hash1</span>()(t) % _bitSize;</span><br><span class="line"><span class="type">size_t</span> hash2 = <span class="built_in">Hash2</span>()(t) % _bitSize;</span><br><span class="line"><span class="type">size_t</span> hash3 = <span class="built_in">Hash3</span>()(t) % _bitSize;</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> ret1 = _bs.<span class="built_in">Test</span>(hash1);</span><br><span class="line"><span class="type">bool</span> ret2 = _bs.<span class="built_in">Test</span>(hash2);</span><br><span class="line"><span class="type">bool</span> ret2 = _bs.<span class="built_in">Test</span>(hash3);</span><br><span class="line"><span class="comment">// 只有三个都为true才是可能在</span></span><br><span class="line"><span class="keyword">return</span> ret1 &amp;&amp; ret2 &amp;&amp; ret3;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="删除元素"><a href="#删除元素" class="headerlink" title="删除元素"></a>删除元素</h3><p>前文提到了，布隆过滤器的删除可以用计数器的方式来实现，但是会有计数回绕问题。所以这里布隆过滤器的实现先不管删除啦。</p><h2 id="2-3-测试布隆过滤器"><a href="#2-3-测试布隆过滤器" class="headerlink" title="2.3 测试布隆过滤器"></a>2.3 测试布隆过滤器</h2><p>测试一下set和test有么有什么问题。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">TestBloomFilter</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">BloomFilter&lt;&gt; <span class="built_in">bf</span>(<span class="number">100</span>);</span><br><span class="line"></span><br><span class="line">bf.<span class="built_in">Set</span>(<span class="string">&quot;test1&quot;</span>);</span><br><span class="line">bf.<span class="built_in">Set</span>(<span class="string">&quot;test2&quot;</span>);</span><br><span class="line">bf.<span class="built_in">Set</span>(<span class="string">&quot;test3&quot;</span>);</span><br><span class="line">bf.<span class="built_in">Set</span>(<span class="string">&quot;test4&quot;</span>);</span><br><span class="line"></span><br><span class="line">std::cout &lt;&lt; bf.<span class="built_in">Test</span>(<span class="string">&quot;test1&quot;</span>) &lt;&lt; std::endl;</span><br><span class="line">std::cout &lt;&lt; bf.<span class="built_in">Test</span>(<span class="string">&quot;test2&quot;</span>) &lt;&lt; std::endl;</span><br><span class="line">std::cout &lt;&lt; bf.<span class="built_in">Test</span>(<span class="string">&quot;test3&quot;</span>) &lt;&lt; std::endl;</span><br><span class="line">std::cout &lt;&lt; bf.<span class="built_in">Test</span>(<span class="string">&quot;test4&quot;</span>) &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">std::cout &lt;&lt; bf.<span class="built_in">Test</span>(<span class="string">&quot;test6&quot;</span>) &lt;&lt; std::endl;</span><br><span class="line">std::cout &lt;&lt; bf.<span class="built_in">Test</span>(<span class="string">&quot;tsdfaba&quot;</span>) &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出如下，符合预期</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">0</span></span><br><span class="line"><span class="number">0</span></span><br></pre></td></tr></table></figure><p>这里还可以构造一部分海量数据来测试这个布隆过滤器的准确度如何。但是构造海量的字符串用例感觉很是麻烦，暂时不弄了。</p><h1 id="3-实际场景问题"><a href="#3-实际场景问题" class="headerlink" title="3.实际场景问题"></a>3.实际场景问题</h1><h2 id="3-1-给一个巨大的logFile，内部存放IP地址，设计算法找到TOPK的IP或出现频率最多的IP？"><a href="#3-1-给一个巨大的logFile，内部存放IP地址，设计算法找到TOPK的IP或出现频率最多的IP？" class="headerlink" title="3.1 给一个巨大的logFile，内部存放IP地址，设计算法找到TOPK的IP或出现频率最多的IP？"></a>3.1 给一个巨大的logFile，内部存放IP地址，设计算法找到TOPK的IP或出现频率最多的IP？</h2><p>先创建1000个小文件，然后通过一个哈希函数<code>i = hash(IP) % 1000</code>计算出IP地址存放的位置（这样相同的IP地址会存入一个文件），随后依次读取这些小文件，使用一个<code>uordered_map&lt;string,long long&gt;</code>来计算每一个IP地址出现的次数。</p><p>因为相同的IP地址肯定在同一个小文件内，所以每次<code>unordered_map</code>得到的IP计数肯定是准确的。</p><blockquote><p>这里注意内存的消耗，如果1000个小文件后内存还是会爆，则将文件数量进一步扩大到10000个，以此类推。</p></blockquote><p>再用一个<strong>小根堆</strong>来存放整体TopK的IP地址：因为我们需要出现频率最高的IP地址，所以用小堆可以将<strong>堆内</strong>出现频率<strong>最低的放在堆顶</strong>。这样只要得到一个比堆顶出现次数更多的IP地址，就弹出堆顶将其插入。</p><ul><li>使用哈希函数将logFile中的IP地址映射到不同的小文件中（一行一个IP，直接在文件尾部写入即可）；</li><li>遍历小文件，使用<code>uordered_map&lt;string,long long&gt;</code>来计算IP地址出现频次；</li><li>每次遍历一个小文件后，遍历<code>unordered_map</code>，将IP地址出现频次高于堆顶元素的IP插入小根堆（弹出堆顶后插入）；</li><li>遍历完毕一个小文件，清空<code>unordered_map</code>（避免爆内存）；</li></ul><p>遍历完毕所有小文件后，得到的就是TopK出现频率最多的IP地址。此时堆顶元素就是出现频率<strong>从高到低</strong>在第K个的IP地址，堆内元素是出现频次在前K个的IP地址。</p><h2 id="3-2-给出两个50亿行的文件，一行是一个128字节的字符串，如何找到这两个文件中同时出现过的字符串？"><a href="#3-2-给出两个50亿行的文件，一行是一个128字节的字符串，如何找到这两个文件中同时出现过的字符串？" class="headerlink" title="3.2 给出两个50亿行的文件，一行是一个128字节的字符串，如何找到这两个文件中同时出现过的字符串？"></a>3.2 给出两个50亿行的文件，一行是一个128字节的字符串，如何找到这两个文件中同时出现过的字符串？</h2><blockquote><p>面大厂的时候遇到了这个问题，当时忘记布隆过滤器了，没有答出来，哭死。</p></blockquote><h3 id="布隆过滤器"><a href="#布隆过滤器" class="headerlink" title="布隆过滤器"></a>布隆过滤器</h3><p><strong>使用一个布隆过滤器来实现</strong>：</p><ul><li>创建一个布隆过滤器</li><li>按行读取文件A，计算字符串哈希，映射进布隆过滤器中</li><li>按行读取文件B，计算字符处哈希，判断是否在布隆过滤器中，在则存放至交集内。</li></ul><p>注意，因为布隆过滤器不能保证100%的准确性，所以需要根据准确度的要求扩大布隆过滤器的位图长度或增加哈希函数。</p><p>这里可以来计算一下这样做的内存消耗。用下面的python函数来计算位图的长度</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> math</span><br><span class="line"></span><br><span class="line">n = <span class="number">50</span> * <span class="number">10</span>**<span class="number">8</span>  <span class="comment"># 预期的元素数量</span></span><br><span class="line">p = <span class="number">0.005</span>       <span class="comment"># 期望的误判率</span></span><br><span class="line">k = <span class="number">4</span>           <span class="comment"># 哈希函数数量</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># math.log默认的底就是e</span></span><br><span class="line">m = -n * math.log(p) / (math.log(<span class="number">2</span>)**<span class="number">2</span>)  <span class="comment"># 计算位图长度</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;位图长度m：&quot;</span>, m)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;占用内存GB：&quot;</span>,m/(<span class="number">8</span>*<span class="number">1024</span>*<span class="number">1024</span>*<span class="number">1024</span>))</span><br></pre></td></tr></table></figure><p>输出结果如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">位图长度m： 55138767091.28201</span><br><span class="line">占用内存GB： 6.418997316071998</span><br></pre></td></tr></table></figure><p>还可以用这个网站来在线计算，<a href="https://hur.st/bloomfilter/?n=5000M&p=0.0005&m=&k=4">hur.st&#x2F;bloomfilter</a>。这个网站使用的公式和上文不同。</p><p>由图可知，当n为50亿的，哈希函数4个，误报率0.005（千分之5）的时候，需要7.5GB的空间来存放布隆过滤器。</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/03/c7d2deebb836931d50da4fc64fa7fb36.png" alt="image-20240330111317153"></p><p>虽然<code>6.41GB</code>和<code>7.53GB</code>看上去还是一个很大的内存占用，但是对于服务器动则128GB起步的物理内存大小而言，这已经是相对来说可以接受的占用了。哪怕如今一台16GB内存的家用电脑，理论上也能完成这样的工作。</p><p>如果直接将50亿个128字节的字符串加载到内存里面，要多少空间呢？</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(5 * 10^9 * 128) / (8*1024*1024*1024)</span><br><span class="line">结果是 74.506GB</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/03/9fde90ad5414b9f39b5ce62f112689e0.png" alt="image-20240330103449933"></p><p>74.5GB和7.5GB是将近10倍的内存占用差距，更别提这里只是计算了加载字符串的内存占用，还没有计算如果使用哈希或者红黑树来保存这些字符串的额外内存占用呢，如果算上至少奔着80GB+去了。</p><h3 id="精确算法"><a href="#精确算法" class="headerlink" title="精确算法"></a>精确算法</h3><p>精确算法就还是需要使用<strong>哈希切分</strong>加<strong>set对比</strong>的思路了，设定一万个或者十万个小文件，遍历原始文件，通过哈希<code>i = hash(IP) % 小文件数量</code>映射字符串到第i个小文件中，对A和B都做如此操作，得到A1到Ai个和B1到Bi个小文件。</p><p>因为求的是字符串交集，使用相同哈希函数的情况下，A和B的相同字符串肯定会在<strong>同一个i的小文件</strong>中，此时就可以通过对A1小文件建立一个<code>unordered_set</code>，遍历B1小文件判断是否在set中，再处理A2和B2，以此类推，得到最终的交集。</p><p>注意，如果题目给出了内存限制，我们还需要进一步计算切割出来的小文件的大小是否大于了内存的限制。如果大于了，则采用上述思路对这个小文件再进行一次切分，直到切出来的小文件可以完整的在<strong>内存限制之内</strong>即可。</p><h2 id="3-3-给定10亿个int整数，如何设计算法找到只出现了一次的数（不重复的整数）"><a href="#3-3-给定10亿个int整数，如何设计算法找到只出现了一次的数（不重复的整数）" class="headerlink" title="3.3 给定10亿个int整数，如何设计算法找到只出现了一次的数（不重复的整数）"></a>3.3 给定10亿个int整数，如何设计算法找到只出现了一次的数（不重复的整数）</h2><p>10亿个整数肯定没有办法都load到内存里面，这里需要用到位图来实现。</p><p>方法一：扩展位图，使用2个比特来记录一个数，00代表没出现，01代表出现一次，10代表出现2次及以上。最终位图操作完毕后，重新遍历位图即可得到结果。</p><p>方法二：用两个位图同时操作，数字第一次出现的时候，在第一个位图置1，第二次出现的时候，在第二个位图置1。最终只有一个位图中置1的数就是只出现了一次的数。思路同上。</p><p>这两种方法的消耗空间 <code>(2*4*(10^9))/(8*1024*1024*1024) ≈ 0.931GB</code>，足够在内存中处理了。</p><blockquote><p>1个文件有10亿个int，限定1G内存，设计算法找到出现<strong>次数不超过2次</strong>的所有整数。这个问题也能用上述方法来处理。</p></blockquote><h2 id="3-4-给两个文件，分别有100亿个整数，我们只有1G内存，如何找到两个文件交集？"><a href="#3-4-给两个文件，分别有100亿个整数，我们只有1G内存，如何找到两个文件交集？" class="headerlink" title="3.4 给两个文件，分别有100亿个整数，我们只有1G内存，如何找到两个文件交集？"></a>3.4 给两个文件，分别有100亿个整数，我们只有1G内存，如何找到两个文件交集？</h2><p>方案一： 将文件1的整数映射到一个位图中，然后读取文件2中的数据，判断是否在位图中，在就是交集。（位图的长度取决于这些整数的数据范围）</p><p>方案二： 将文件1的整数映射到一个位图中， 将文件2的整数映射到另一个位图中，然后将两个位图进行按位与（遍历按位与），与之后位图中为1的位就是两个文件的交集。</p><h2 id="3-5-已知某个文件内包含一些电话号码，每个号码为-8-位数字，统计不同号码的个数"><a href="#3-5-已知某个文件内包含一些电话号码，每个号码为-8-位数字，统计不同号码的个数" class="headerlink" title="3.5 已知某个文件内包含一些电话号码，每个号码为 8 位数字，统计不同号码的个数"></a>3.5 已知某个文件内包含一些电话号码，每个号码为 8 位数字，统计不同号码的个数</h2><p>每个号码八位数，不考虑电话号码的实际情况，8位最多<code>99,999,999</code>，一共有<code>10^8</code>种情况。也就是需要<code>10^8</code>位bit，大概12.5M内存即可。</p><p>申请一个数组，遍历所有号码，将号码对应的bit置为1，最后统计bit位1的数量即为不同的号码数。</p><h2 id="3-6-5亿个int整数找它们的中位数"><a href="#3-6-5亿个int整数找它们的中位数" class="headerlink" title="3.6 5亿个int整数找它们的中位数"></a>3.6 5亿个int整数找它们的中位数</h2><blockquote><p>参考：<a href="https://www.nowcoder.com/discuss/384700130958602240">https://www.nowcoder.com/discuss/384700130958602240</a></p></blockquote><p><strong>解法一：</strong>当内存不足以存放5亿个int整数时，我们依然使用分而治之的方法，但hash映射分成小文件的时候需要注意，我们要保证把数据分散到不同文件中时仍然保持着顺序，即按数值大小进行分流，这样才能找到正确的中位数。 </p><ul><li>我们遍历这5亿个int整数时，考虑其二进制的最高位，按照最高位（符号位，0表示正数，1表示负数）进行二分，即最高位为1存入文件a，最高位为0存入文件b，这样文件a中的数是一定比文件b中的数小。    </li><li>统计文件a和文件b中的整数个数，如果文件a和文件b中的整数个数相同，那么中位数则是文件a中的最小值和文件b中的最大值的平均值。如果文件a中的整数个数小于文件b，那么中位数肯定在文件b中，反之亦然。    </li><li>如果文件a或文件b中的整数还是无法直接读取进内存中，那么继续使用上个步骤的方法进行分流，并判断中位数所处的位置，直到中位数所在的那部分数据大小可以直接放到内存中，然后对这部分排序，计算出中位数的值。</li></ul><p>解法二：用堆来解决这个问题，前提是整数能被全部加载到内存中。</p><p>思路可以参考leetcode题目 <a href="https://leetcode.cn/problems/find-median-from-data-stream/">295. 数据流的中位数</a>，为了方便后序归档和复习，对这到题单独开一篇题解。思路还是K神的【<a href="https://leetcode.cn/problems/find-median-from-data-stream/solutions/2361972/295-shu-ju-liu-de-zhong-wei-shu-dui-qing-gmdo/">点我看思路</a>】。</p><h2 id="3-7-海量数据进行排序"><a href="#3-7-海量数据进行排序" class="headerlink" title="3.7 海量数据进行排序"></a>3.7 海量数据进行排序</h2><p>这个是涉及到外排序相关的知识了，也算大数据处理，干脆一起记录在这里。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">https://blog.csdn.net/qq_43915356/article/details/106877167</span><br><span class="line">https://blog.csdn.net/ailunlee/article/details/84548950</span><br></pre></td></tr></table></figure><p>问：假设给你8GB数据，内存只有2GB，如何排序？</p><p>首先我们需要将8GB分为4个2GB的小文件，依次读取每个小文件对其进行排序并存入一个排序好的文件中。得到其中一个有序子串。</p><p>随后，同时读取两个2GB的文件（每一次都只从两个文件中读取一个内容），对比，将小的那个输出到目标文件中。直到遍历完毕两个2GB的文件，即得到了一个4GB的有序子串。</p><p>对两个有序的4GB子串做同样的处理，输出成最终的8GB文件。</p><blockquote><p>N个有序子串的归并叫做N路归并。</p></blockquote><p>但是这里会有一个磁盘IO的问题，我们两两归并的时候，会涉及到从两个文件中读取一次，再输出到最终文件中的一次。归并的次数越多，IO的次数也就越多，速度也就越慢。</p><p>所以可以适当的增加归并文件的数量，比如同时读取三个2GB的文件，对三个数进行排序，输出到目标文件中。但是这里需要注意有序性的问题。比如文件A和B中的第一个记录小于C的记录，此时会以A0\B0\C0输出到目标文件中，但有可能会出现A1和B1还是小于C0的情况，这种就比较麻烦了（俺没想出好的解决办法）。</p><h1 id="The-end"><a href="#The-end" class="headerlink" title="The end"></a>The end</h1><p>布隆过滤器和位图，以及哈希分而治之的思想在大数据梳理中非常有用，一定要记住！</p>]]></content>
    
    
    <summary type="html">学习如何使用布隆过滤器来处理海量数据</summary>
    
    
    
    <category term="编程学习" scheme="https://blog.musnow.top/categories/%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="C++" scheme="https://blog.musnow.top/categories/%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0/C/"/>
    
    
    <category term="Cpp" scheme="https://blog.musnow.top/tags/Cpp/"/>
    
    <category term="数据结构" scheme="https://blog.musnow.top/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    <category term="哈希" scheme="https://blog.musnow.top/tags/%E5%93%88%E5%B8%8C/"/>
    
  </entry>
  
  <entry>
    <title>【leetcode】233.数字1的个数</title>
    <link href="https://blog.musnow.top/posts/2123053741/"/>
    <id>https://blog.musnow.top/posts/2123053741/</id>
    <published>2024-03-29T11:06:22.000Z</published>
    <updated>2024-03-30T01:26:06.000Z</updated>
    
    <content type="html"><![CDATA[<p>面tx的时候上来就是这道题，我只想出来暴力的思路，肯定不得分了，赶快学习一下正确的解法。</p><h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><blockquote><p><a href="https://leetcode.cn/problems/number-of-digit-one/description/">https://leetcode.cn/problems/number-of-digit-one/description/</a></p></blockquote><p>给定一个整数 n，计算所有小于等于 n 的非负整数中数字 1 出现的个数。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">示例 1：</span><br><span class="line"></span><br><span class="line">输入：n = 13</span><br><span class="line">输出：6</span><br><span class="line"></span><br><span class="line">示例 2：</span><br><span class="line">输入：n = 0</span><br><span class="line">输出：0</span><br><span class="line"></span><br><span class="line">提示：</span><br><span class="line">0 &lt;= n &lt;= 10^9</span><br></pre></td></tr></table></figure><p>注意题目的意思，比如给定的数字n是13，那么1到13中，1一共出现了6次，分别是1、10、11（两个1）、12、13。</p><p>暴力的办法就是直接两层循环计算每一位是不是1，是1就count++，最终返回count就行；</p><h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><h2 id="基本说明"><a href="#基本说明" class="headerlink" title="基本说明"></a>基本说明</h2><blockquote><p>这里学习一下Krahets大佬的思路：<a href="https://leetcode.cn/problems/number-of-digit-one/solutions/2362053/233-shu-zi-1-de-ge-shu-qing-xi-tu-jie-by-pgb1/">https://leetcode.cn/problems/number-of-digit-one/solutions/2362053/233-shu-zi-1-de-ge-shu-qing-xi-tu-jie-by-pgb1/</a></p></blockquote><p>思路是将每一位置1后，其他的位会有多少种组合，加起来就是总的1的数量。</p><p>比如三位数中，1的个数是：个位数为1时组合的个数+十位数为1时其他数的个数+百位数为1时其他位的组合个数。更多位的数也是这个思路，以此类推。</p><p>假设n&#x3D;22时，1的个数是<code>[1,22]</code>中<code>X1</code>的个数（1、11、21）+<code>[1,22]</code>中<code>1X</code>的个数（10-19，注意这里的11只关注十位数的1）</p><h2 id="实例图"><a href="#实例图" class="headerlink" title="实例图"></a>实例图</h2><p>提供的数是n，一共有k位，我们可以把n当作<code>Nk N(k-1) ... N1 N0</code>（Nk代表每一位的数）；</p><ul><li>cur是当前遍历到的第i个数，<code>Ni</code>（下标）;</li><li>high是当前数高位的数，<code>Nk N(k-1) N(k-2) ... N(i+1)</code>;</li><li>low是当前数低位的数，<code>N(i-1) N(i-2) ... N1 N0</code>;</li><li>dights是当前的权值，为<code>10^i</code>；</li></ul><p>这个权值是<strong>当前位为1时</strong>，<strong>往后</strong>会出现多少个组合，比如cur为<strong>十位</strong>的时候，其他位和这一位能构成的1的组合是10到19，即10个1（注意这里不关注11的个位数的1），和<code>10^1</code>的结果一致。<strong>百位</strong>也是如此，能构成1的组合是100到199，一共100个1，也是<code>10^2</code>的值。</p><p>具体的分为下面三个情况</p><ol><li>cur为0；</li><li>cur为1；</li><li>cur大于1，即2到9；</li></ol><h3 id="1-cur为0"><a href="#1-cur为0" class="headerlink" title="1.cur为0"></a>1.cur为0</h3><p>假设<strong>n&#x3D;3404</strong>，cur为第1位（从右往左数第二个），hight为34，low为4，dights为10^1&#x3D;10；此时1出现的次数只和high和dights有关。公式如下<br>$$<br>high * dights<br>$$<br>你可以把3404想象成一个4位的拨动密码锁，当cur位固定为1了之后，我们需要想办法将这个密码锁拨动到不大于n的最大位置3319。对应high的变动位置是<strong>0到33</strong>（一共有34个），low的变动位置是<strong>0到9</strong>（一共10个）。</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/03/9ba40985cc005b5818b0989cbdac2ffe.png" alt="image-20240330090831427"></p><p>可得，0到33中，每一次high的变化都会出现10个1（<code>xx10~xx19</code>）。所以得出公式 <code>high * dights</code>，本例子中即为<code>34*10 = 340</code>个1。</p><ul><li>cur为0，<strong>所以1的个数只与high有关</strong>，与low位无关，为什么？</li></ul><p>因为十位的cur为0的时候，密码锁不可能拨动到341x的位置（超出范围了），此时不管low位是多少，都不会有更多1的组合，组合被锁定在了低于3404的<code>0010~3319</code>之中。和下文cur为1的情况对照能更好的理解这个情况。</p><h3 id="2-cur为1"><a href="#2-cur为1" class="headerlink" title="2.cur为1"></a>2.cur为1</h3><p>假设n&#x3D;3414。十位的cur为1的时候，密码锁就可以拨动到341x的位置了，此时1的个数和high&#x2F;low都有关系。</p><p>high包括<code>00~33</code>的34个<code>10~19</code>（340个1，和上文一致），low包括<code>3410~341x</code>的1的个数，例子中low为4，低位可决定的1的范围是3410到3414，一共有5个数，对应<code>low+1</code>。</p><p>此时可以得到公式如下<br>$$<br>higt * dights + (low + 1)<br>$$<br>下为这种情况的示意图</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/03/23c25b69ea783cc79f130cc83c650630.png" alt="image-20240330090913430"></p><h3 id="3-cur大于1"><a href="#3-cur大于1" class="headerlink" title="3.cur大于1"></a>3.cur大于1</h3><p>假设n&#x3D;3434，十位的cur大于1了，可选值已经超过了3419。此时密码锁的拨动还是只和high有关系，可以拨动的范围已经包揽了<code>00~34</code>，一共是35个<code>10~19</code>，公式如下<br>$$<br>(high + 1) * dights<br>$$</p><p>下为这种情况的示意图</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/03/cffd5e76633b7fc2873c5f6cac542577.png" alt="image-20240330091149401"></p><p>最终我们只需要遍历每一位的数，将值给加起来，就是题目的和。</p><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><p>有了每一种情况的公式，代码就很容易写出来了。这里需要注意的就是high&#x2F;low&#x2F;cur是如何移动到下一位的，以及什么时候需要跳出循环。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">countDigitOne</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> count = <span class="number">0</span>; <span class="comment">// 结果</span></span><br><span class="line">        <span class="comment">// 不大于10的时候只会有一个</span></span><br><span class="line">        <span class="keyword">if</span> (n &lt; <span class="number">10</span> &amp;&amp; n &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 个位数 dights = 10^0 = 1</span></span><br><span class="line">        <span class="type">long</span> dights = <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// high/cur/low 初始化为个位时的取值</span></span><br><span class="line">        <span class="type">long</span> high = n / <span class="number">10</span>; <span class="comment">// 除去个位的其他值</span></span><br><span class="line">        <span class="type">long</span> cur = n % <span class="number">10</span>;  <span class="comment">// 当前位是个位</span></span><br><span class="line">        <span class="type">long</span> low = <span class="number">0</span>;       <span class="comment">// 个位没有low</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// high和cur同时为0代表遍历结束</span></span><br><span class="line">        <span class="keyword">while</span> (high != <span class="number">0</span> || cur != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (cur == <span class="number">0</span>) &#123;</span><br><span class="line">                count += high * dights;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (cur == <span class="number">1</span>) &#123;</span><br><span class="line">                count += high * dights + low + <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (cur &gt; <span class="number">1</span>) &#123;</span><br><span class="line">                count += (high + <span class="number">1</span>) * dights;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 倍增，dights = 10^i</span></span><br><span class="line">            dights *= <span class="number">10</span>;</span><br><span class="line">            <span class="comment">// 移动到下一位</span></span><br><span class="line">            <span class="comment">// 当cur为十位的时候，high是n/100</span></span><br><span class="line">            <span class="comment">// 当cur为百位的时候，high是n/1000</span></span><br><span class="line">            high = n / (dights * <span class="number">10</span>);</span><br><span class="line">            <span class="comment">// 当cur为十位的时候，cur是(n/10)%10计算出来的</span></span><br><span class="line">            <span class="comment">// 当cur为百位的时候，cur是(n/100)%10计算出来的</span></span><br><span class="line">            cur = (n / dights) % <span class="number">10</span>;</span><br><span class="line">            <span class="comment">// 当cur为十位的时候，low是%10计算出来的</span></span><br><span class="line">            <span class="comment">// 当cur为百位的时候，low是%100计算出来的</span></span><br><span class="line">            low = n % dights;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/03/26e321e14e47ab27b3c3951a1556a98c.png" alt="image-20240330092321043"></p><h1 id="The-end"><a href="#The-end" class="headerlink" title="The end"></a>The end</h1><p>这道题还有数位DP的解法，但是我还没有学习到DP，此时只学一道题还不如不学。所以后续再补充其他思路吧！</p>]]></content>
    
    
    <summary type="html">leetcode刷题笔记-233.数字1的个数</summary>
    
    
    
    <category term="编程学习" scheme="https://blog.musnow.top/categories/%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="把题目都给刷干净" scheme="https://blog.musnow.top/categories/%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0/%E6%8A%8A%E9%A2%98%E7%9B%AE%E9%83%BD%E7%BB%99%E5%88%B7%E5%B9%B2%E5%87%80/"/>
    
    
    <category term="OJ刷题" scheme="https://blog.musnow.top/tags/OJ%E5%88%B7%E9%A2%98/"/>
    
    <category term="leetcode" scheme="https://blog.musnow.top/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>【leetcode】53.最大子数组和</title>
    <link href="https://blog.musnow.top/posts/4261184242/"/>
    <id>https://blog.musnow.top/posts/4261184242/</id>
    <published>2024-03-26T10:15:05.000Z</published>
    <updated>2024-04-07T07:28:31.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><blockquote><p><a href="https://leetcode.cn/problems/maximum-subarray/description/">53. 最大子数组和</a></p></blockquote><p>给你一个整数数组 nums ，请你找出一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。</p><p>子数组 是数组中的一个连续部分。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">示例 1：</span><br><span class="line">输入：nums = [-2,1,-3,4,-1,2,1,-5,4]</span><br><span class="line">输出：6</span><br><span class="line">解释：连续子数组 [4,-1,2,1] 的和最大，为 6 。</span><br><span class="line"></span><br><span class="line">示例 2：</span><br><span class="line">输入：nums = [1]</span><br><span class="line">输出：1</span><br><span class="line"></span><br><span class="line">示例 3：</span><br><span class="line">输入：nums = [5,4,-1,7,8]</span><br><span class="line">输出：23</span><br></pre></td></tr></table></figure><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>最简单的方式可以用一个三层的嵌套遍历找到这个最大值，时间复杂度是<code>O(N^3)</code>。但这样写肯定是不好的。</p><p>题目要求的是一个连续子数组的和，我们可以认为遍历到某一个数的时候，这个子数组的和就是<code>到前一位的子数组和+当前值</code>，这时候就会出现两种情况</p><ul><li><code>前一位的数组和+当前值 &lt; 当前值</code>，这说明前一位的子数组和是一个负数，那还不如当前值自己大，所以直接选用当前值作为新一轮子数组的开始。</li><li><code>前一位的数组和+当前值 &gt;= 当前值</code>，可以将当前值算到前一位的这个子数组中，继续扩张。</li></ul><p>每一次操作之后都需要更新最大和。</p><p>我们可以另外开辟一个数组来存放每一位的最大子数组和，再通过下标访问前一位的数组和。但实际上每一次遍历<strong>只和前一位的子数组和有关</strong>系，所以直接用int来存放前一位的子数组和就够了，不需要额外开辟数组的空间复杂度消耗了。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><h3 id="代码1"><a href="#代码1" class="headerlink" title="代码1"></a>代码1</h3><p>代码比较简单，理解了思路就能写出来</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxSubArray</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> prev = <span class="number">0</span>;         <span class="comment">// 之前的最大子数组和，初始值0</span></span><br><span class="line">        <span class="type">int</span> maxNum = nums[<span class="number">0</span>]; <span class="comment">// 从数组中选一个值</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; i : nums) &#123;</span><br><span class="line">            <span class="comment">// 如果之前的最大子数组和还没有我自己大，则从我自己开始新列一个子数组</span></span><br><span class="line">            prev = <span class="built_in">max</span>(prev + i, i);</span><br><span class="line">            <span class="comment">// 更新最大值</span></span><br><span class="line">            maxNum = <span class="built_in">max</span>(maxNum, prev);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxNum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/03/3e465f2252d1a16767bf00bab2ab4644.png" alt="image.png"></p><p>时间复杂度<code>O(N)</code>，空间复杂度<code>O(1)</code>；</p><h3 id="代码2"><a href="#代码2" class="headerlink" title="代码2"></a>代码2</h3><p>上面这个代码乍一看可能不好理解，我们可以按下面的方式写</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxSubArray</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> ret = INT32_MIN;</span><br><span class="line">        <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; i : nums) &#123;</span><br><span class="line">            sum += i;</span><br><span class="line">            <span class="comment">// 更新最大值</span></span><br><span class="line">            <span class="keyword">if</span> (sum &gt; ret) &#123;</span><br><span class="line">                ret = sum;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 如果当前sum为负数，那么需要重新开子数组了</span></span><br><span class="line">            <span class="comment">// 因为当前的sum加上下一位后，肯定没有下一位本身大！</span></span><br><span class="line">            <span class="keyword">if</span> (sum &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                sum = <span class="number">0</span>; <span class="comment">// 重置为0</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这个思路也是一样，只不过将判断换到了当前位之后就处理了</p><ul><li>维护一个sum，作为当前子数组的和；</li><li>每一次都让<code>sum+=i</code>，并更新最大值；</li><li>如果当前sum小于等于0了，当前<strong>子数组的和+下一位</strong>肯定会<strong>小于下一位本身</strong>，此时置为0，从下一位开始重新计算一个新的子数组和；</li><li>直到遍历完毕返回维护的最大值。</li></ul><p>两个写法都能过，重点还是理解思路啦！</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/04/041b930158ef5066677b199f9b715449.png" alt="image.png"></p><h2 id="The-end"><a href="#The-end" class="headerlink" title="The end"></a>The end</h2><p>这道题还有很多不同的解法，可以参考这个博客：<a href="https://blog.csdn.net/Supreme7/article/details/117398880">https://blog.csdn.net/Supreme7/article/details/117398880</a></p>]]></content>
    
    
    <summary type="html">leetcode刷题笔记-53.最大子数组和</summary>
    
    
    
    <category term="编程学习" scheme="https://blog.musnow.top/categories/%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="把题目都给刷干净" scheme="https://blog.musnow.top/categories/%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0/%E6%8A%8A%E9%A2%98%E7%9B%AE%E9%83%BD%E7%BB%99%E5%88%B7%E5%B9%B2%E5%87%80/"/>
    
    
    <category term="OJ刷题" scheme="https://blog.musnow.top/tags/OJ%E5%88%B7%E9%A2%98/"/>
    
    <category term="leetcode" scheme="https://blog.musnow.top/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>【面试】浏览器输入URL到出现网页的全过程</title>
    <link href="https://blog.musnow.top/posts/2270595544/"/>
    <id>https://blog.musnow.top/posts/2270595544/</id>
    <published>2024-03-26T02:09:43.000Z</published>
    <updated>2024-04-10T04:58:34.000Z</updated>
    
    <content type="html"><![CDATA[<p>面试总是考这个，虽然我能说出个大概，但总是卡壳，还是重新记录一下。</p><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><p>首先要知道这里面会涉及到什么协议，以HTTP的网页为例，会涉及到下面这些协议</p><ul><li>HTTP&#x2F;HTTPS</li><li>TCP</li><li>IP</li><li>ARP</li><li>DNS</li><li>NAT</li></ul><p>当然，更底层的还有路由选择协议OSPF等，但这些一般情况下不会考察到（除非你面试的是网络工程师相关岗位），所以能把上面的这些协议的步骤说清楚就基本够了。</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/03/200e1efb4783410ed6d8dc834e0cc459.png" alt="image.png"></p><h2 id="步骤一：URL解析"><a href="#步骤一：URL解析" class="headerlink" title="步骤一：URL解析"></a>步骤一：URL解析</h2><p>浏览器首先是需要解析你访问的URL，从里面提取当前使用的网络协议（以HTTP协议为例），目标的域名，以及域名后的请求路径与参数。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http(s)://&lt;host&gt;:&lt;port&gt;/&lt;path&gt;?&lt;query&gt;#&lt;frag&gt;</span><br></pre></td></tr></table></figure><p>随后浏览器会将这里面的信息封装成一个HTTP请求报文。因为是在浏览器中输入的URL，所以是GET请求。假设你访问的是某个网页的主页，那么浏览器就会构造一个GET请求报文，去请求根路径下的<code>index.html</code>文件。</p><h2 id="步骤二：DNS解析"><a href="#步骤二：DNS解析" class="headerlink" title="步骤二：DNS解析"></a>步骤二：DNS解析</h2><p>知道了域名，还需要知道这个域名对应的IP地址，才能发起网络请求。<strong>浏览器</strong>会进行DNS查询（基于UDP），来找到域名的IP地址。</p><ul><li>查询浏览器本地缓存；</li><li>查询PC主机本地缓存；</li><li>查询主机HOSTS文件；</li><li>本地缓存找不到，向默认DNS服务器（通常是ISP的DNS服务器）发起<strong>递归</strong>查询；</li><li>ISP的DNS服务器使用<strong>迭代</strong>的方式依次从根域名服务器、顶级域名服务器……直到找到该域名映射的IP地址。</li><li>ISP的DNS服务器向客户端返回IP地址（服务器一般有<strong>负载均衡</strong>，同一个域名每一次查询到的IP地址可能不一样）</li></ul><p>DNS是基于UDP的，底层依旧是IP协议，当前的主机一般是<strong>知道DNS服务器的IP地址的</strong>（可以手动配置公共DNS服务器，或者自动选择时默认ISP的DNS服务器），所以不存在还需要查询DNS服务器的IP地址的情况。</p><ul><li>如果找不到，会返回失败，此时浏览器会显示 <code>DNS_PROBE_FINISHED_NXDOMAIN</code>，提示用户该域名找不到IP地址（没有成功解析）</li><li>如果找到了，浏览器会将这个域名和IP的对应关系放入自己的缓存，方便下一次请求。</li></ul><p>本地的DNS缓存也会有一个过期计时器，避免目标域名和IP的映射关系发生变化。</p><h2 id="步骤三：TCP握手"><a href="#步骤三：TCP握手" class="headerlink" title="步骤三：TCP握手"></a>步骤三：TCP握手</h2><p>现在我们知道目标主机的IP地址了，也知道端口号（HTTP协议是80端口，HTTPS是443端口），现在浏览器会调用系统接口，发起TCP三次握手的请求。下面的工作就是操作系统的网络协议栈来处理的了啦！</p><blockquote><p>这里可能会追问为什么TCP握手是三次：三次握手是<strong>保证双方通信能力的最小握手次数</strong>，同时也一定程度上避免了一次和二次握手中客户端只需要发送一次SYN就能攻击服务器的情况。</p></blockquote><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/03/87c2006ec4c2d6e3394f0e90b99493d0.png" alt="image.png"></p><p>TCP的握手报文向下层IP层交付，IP层封装源IP和目的服务器IP（刚刚通过DNS获得的），并将TCP报文封装到IP报文的数据部分，向下层数据链路层交付。</p><p>数据链路层通过ARP协议查询IP地址对应的MAC地址</p><ul><li>如果是家庭局域网，查询不到目的IP地址，主机会用默认的下一跳（一般是路由器）发送这个报文（后序还涉及到NAT协议）</li><li>如果两个主机都在公网，发送端路由器进行路由查找，查询目标IP地址的目的网络，并转发到下一跳。</li></ul><p>注意，如果面试官没有要求，可以先忽略IP层的处理（只说通过IP协议来传输），这部分是最容易说岔的！</p><h2 id="步骤四：服务器接收请求"><a href="#步骤四：服务器接收请求" class="headerlink" title="步骤四：服务器接收请求"></a>步骤四：服务器接收请求</h2><p>服务器收到客户端发送的报文，从下往上交付，得到HTTP的GET请求，并根据请求中的路径和参数，将客户端需要的资源（html&#x2F;js&#x2F;css）封装并封装在HTTP响应报文中，传回客户端。</p><h2 id="步骤五：客户端接收响应"><a href="#步骤五：客户端接收响应" class="headerlink" title="步骤五：客户端接收响应"></a>步骤五：客户端接收响应</h2><p>客户端收到响应，解析HTTP响应中的数据，并交付<strong>浏览器进行页面渲染</strong>。</p><p>此时根据双方的约定，决定保持链接还是终止TCP链接（终止需要进行四次挥手）</p><h2 id="额外步骤：HTTPS的SSL握手"><a href="#额外步骤：HTTPS的SSL握手" class="headerlink" title="额外步骤：HTTPS的SSL握手"></a>额外步骤：HTTPS的SSL握手</h2><p>如果是HTTPS协议，在正式发送请求之前，还需要进行SSL证书的握手。</p><blockquote><p> 引用：<a href="https://zhuanlan.zhihu.com/p/58955297">https://zhuanlan.zhihu.com/p/58955297</a></p></blockquote><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/03/d2a2828867b502a52ec189aea35994d9.png" alt="image.png"></p><p>需要通过证书握手，确定双方使用的对称加密密钥，再加密进行HTTP请求&#x2F;响应的传输。</p>]]></content>
    
    
    <summary type="html">面试常考-浏览器输入URL到出现网页的全过程</summary>
    
    
    
    <category term="编程学习" scheme="https://blog.musnow.top/categories/%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="默认分组" scheme="https://blog.musnow.top/categories/%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0/%E9%BB%98%E8%AE%A4%E5%88%86%E7%BB%84/"/>
    
    
    <category term="计算机网络" scheme="https://blog.musnow.top/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    <category term="http" scheme="https://blog.musnow.top/tags/http/"/>
    
    <category term="tcp" scheme="https://blog.musnow.top/tags/tcp/"/>
    
  </entry>
  
  <entry>
    <title>【leetcode】221最大正方形</title>
    <link href="https://blog.musnow.top/posts/2287991438/"/>
    <id>https://blog.musnow.top/posts/2287991438/</id>
    <published>2024-03-25T10:13:29.000Z</published>
    <updated>2024-04-16T10:36:31.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><blockquote><p><a href="https://leetcode.cn/problems/maximal-square/description/">221. 最大正方形</a></p></blockquote><p>在一个由 ‘0’ 和 ‘1’ 组成的二维矩阵内，找到只包含 ‘1’ 的最大正方形，并返回其面积。</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/03/8d21cc06d7ecb1b257bc127a35cf0277.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">m == matrix.length</span><br><span class="line">n == matrix[i].length</span><br><span class="line">1 &lt;= m, n &lt;= 300</span><br><span class="line">matrix[i][j] 为 &#x27;0&#x27; 或 &#x27;1&#x27;</span><br></pre></td></tr></table></figure><h2 id="思路1-前缀和"><a href="#思路1-前缀和" class="headerlink" title="思路1-前缀和"></a>思路1-前缀和</h2><h3 id="思路1说明"><a href="#思路1说明" class="headerlink" title="思路1说明"></a>思路1说明</h3><p>面试的时候遇到了这道题，当时只想得出来遍历的办法，后来面试官提示了一下想出来了另外一个思路，不过没时间写了。</p><p>思路是这样的，开另外一个和题目所给矩阵一样的二维数组<code>vector&lt;vector&lt;pair&lt;int, int&gt;&gt;&gt;</code>，用于存放每一位的往前1的个数和往上1的个数（不包括该数自己）。</p><p>以题目给的矩阵为例</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">[&quot;1&quot;,&quot;0&quot;,&quot;1&quot;,&quot;0&quot;,&quot;0&quot;],</span><br><span class="line">[&quot;1&quot;,&quot;0&quot;,&quot;1&quot;,&quot;1&quot;,&quot;1&quot;],</span><br><span class="line">[&quot;1&quot;,&quot;1&quot;,&quot;1&quot;,&quot;1&quot;,&quot;1&quot;],</span><br><span class="line">[&quot;1&quot;,&quot;0&quot;,&quot;0&quot;,&quot;1&quot;,&quot;0&quot;]</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>可以得到下面的前缀和矩阵，每一位的左侧代表该位置行之前的1的个数，右侧代表该位置列往上1的个数（不包括该数自己）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;0,0&#125; &#123;1,0&#125; &#123;1,0&#125; &#123;2,0&#125; &#123;2,0&#125;</span><br><span class="line">&#123;0,1&#125; &#123;1,0&#125; &#123;1,1&#125; &#123;2,0&#125; &#123;3,0&#125;</span><br><span class="line">&#123;0,2&#125; &#123;1,0&#125; &#123;2,2&#125; &#123;3,1&#125; &#123;4,1&#125;</span><br><span class="line">&#123;0,3&#125; &#123;0,1&#125; &#123;1,3&#125; &#123;1,2&#125; &#123;2,2&#125;</span><br></pre></td></tr></table></figure><p>此时要确定一个正方形，以示例图中下标<code>(1,2)</code>到<code>(2,3)</code>的这个2x2的正方形为例，我们只需要判断正方形对角线上的数的前缀和是否符合条件即可。一个符合条件的正方形，假设下标从<code>(0,0)</code>开始，它的对角线上的前缀和应该是这样的，分别代表该位置之前和之上1的数量。</p><table><thead><tr><th>(0,0)</th><th></th><th></th><th></th></tr></thead><tbody><tr><td></td><td>(1,1)</td><td></td><td></td></tr><tr><td></td><td></td><td>(2,2)</td><td></td></tr><tr><td></td><td></td><td></td><td>……</td></tr></tbody></table><p>但我们需要找的下标<code>(1,2)</code>到<code>(2,3)</code>的正方形并不是从<code>(0,0)</code>开始的，所以还需要对这个前缀和矩阵中的值进行一定处理来得到结果。过程如下</p><ul><li>下标<code>(1,2)</code>是1，开始处理（判断从这个坐标开始往左下角的最大正方形）；</li><li>正方形边长初始化为1（因为起始下标位置为1，就是一个1x1的正方形）；</li><li>判断<code>(1+1,2+1)</code>下标处的值是否为1；为1继续判断前缀和，值是<code>&#123;3,1&#125;</code>；</li><li>这里前缀和的3代表这一行前面还有3个1，1代表这一列上面还有1个1；</li><li>行需要和下标<code>(2,2)</code>处的前缀和<code>&#123;2.2&#125;</code>第一位相减；列需要和下标<code>(1,2)</code>处的前缀和<code>&#123;2,0&#125;</code>第二位相减。即<code>&#123;3-2,1-0&#125;</code>，最终得到的结果是<code>1,1</code>，符合正方形对角线上的条件，边长加一为2。</li><li>继续判断<code>(2+1,3+1)</code>下标处的值是否为1，此时发现已不为1，停止匹配；</li><li>得到最大正方形边长2，面积为4；</li></ul><p>如果是下面这样的矩阵（相比上面的矩阵只修改了左下角的两个0为1）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">[&quot;1&quot;,&quot;0&quot;,&quot;1&quot;,&quot;0&quot;,&quot;0&quot;],</span><br><span class="line">[&quot;1&quot;,&quot;0&quot;,&quot;1&quot;,&quot;1&quot;,&quot;1&quot;],</span><br><span class="line">[&quot;1&quot;,&quot;1&quot;,&quot;1&quot;,&quot;1&quot;,&quot;1&quot;],</span><br><span class="line">[&quot;1&quot;,&quot;0&quot;,&quot;1&quot;,&quot;1&quot;,&quot;1&quot;]</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>对应前缀和矩阵如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;0,0&#125; &#123;1,0&#125; &#123;1,0&#125; &#123;2,0&#125; &#123;2,0&#125;</span><br><span class="line">&#123;0,1&#125; &#123;1,0&#125; &#123;1,1&#125; &#123;2,0&#125; &#123;3,0&#125;</span><br><span class="line">&#123;0,2&#125; &#123;1,0&#125; &#123;2,2&#125; &#123;3,1&#125; &#123;4,1&#125;</span><br><span class="line">&#123;0,3&#125; &#123;0,1&#125; &#123;1,3&#125; &#123;2,2&#125; &#123;3,2&#125;</span><br></pre></td></tr></table></figure><p>此时<code>(2+1,3+1)</code>下标处的值为1，继续判断前缀和<code>&#123;3,2&#125;</code>，这时候已经是一个3x3的正方形了，这个对角线的值应为<code>&#123;2,2&#125;</code>才符合条件。所以需要计算当前前缀和与<strong>行的前2个</strong>和<strong>列的前2个</strong>的差值：</p><ul><li>行需要和下标<code>(3,2)</code>处的前缀和<code>&#123;1,3&#125;</code>第一位相减；</li><li>列需要和下标<code>(1,4)</code>处的前缀和<code>&#123;3,0&#125;</code>第二位相减；</li><li>即<code>&#123;3-1,2-0&#125;</code>，最终能得到<code>&#123;2,2&#125;</code>，符合正方形条件；</li><li>边长加一为3，最大正方形面积为9。</li></ul><p>以此类推，直到遍历的下标越界为止，即完成了对矩阵中一个位置的正方形查找。</p><p>这里涉及到两次叠加循环和一个扩张循环，时间复杂度可以认为是<code>O(N^3)</code>或<code>O(M^3)</code>；</p><h3 id="思路1代码"><a href="#思路1代码" class="headerlink" title="思路1代码"></a>思路1代码</h3><p>代码如下，关键部分添加了注释</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maximalSquare</span><span class="params">(vector&lt;vector&lt;<span class="type">char</span>&gt;&gt;&amp; matrix)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (matrix.<span class="built_in">size</span>() == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 用于记录前缀和，下标代表这个数的行之前以及列以上的1的个数（不包括该数本身）</span></span><br><span class="line">        <span class="type">int</span> n = matrix.<span class="built_in">size</span>(), m = matrix[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        vector&lt;vector&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt;&gt; <span class="built_in">oneCount</span>(</span><br><span class="line">            n, vector&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt;(m, &#123;<span class="number">0</span>, <span class="number">0</span>&#125;));</span><br><span class="line">        oneCount[<span class="number">0</span>][<span class="number">0</span>] = &#123;<span class="number">0</span>, <span class="number">0</span>&#125;;</span><br><span class="line">        <span class="comment">// O(M*N)</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; matrix.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="type">int</span> count = <span class="number">0</span>; <span class="comment">// 每一行的1计数器</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; matrix[i].<span class="built_in">size</span>(); j++) &#123;</span><br><span class="line">                <span class="comment">// 第i行，j之前的1的个数（不包括当前值）</span></span><br><span class="line">                oneCount[i][j].first = count; <span class="comment">// 先赋值，因为不包括自己</span></span><br><span class="line">                <span class="comment">// 第i行，第j列往上1的个数（不包括当前值）</span></span><br><span class="line">                <span class="keyword">if</span> (i == <span class="number">0</span>) &#123;</span><br><span class="line">                    oneCount[i][j].second = <span class="number">0</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// 直接拿上一层的值为初值，再判断上一层是否为1</span></span><br><span class="line">                    oneCount[i][j].second = oneCount[i - <span class="number">1</span>][j].second;</span><br><span class="line">                    <span class="keyword">if</span> (matrix[i - <span class="number">1</span>][j] == <span class="string">&#x27;1&#x27;</span>) &#123;</span><br><span class="line">                        oneCount[i][j].second++;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 每一行的1的个数加一</span></span><br><span class="line">                <span class="keyword">if</span> (matrix[i][j] == <span class="string">&#x27;1&#x27;</span>) &#123;</span><br><span class="line">                    count++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 此时可以得到一个矩阵，这样判断是否为正方形只需要判断对角线的数</span></span><br><span class="line">        <span class="type">int</span> maxSquare = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; matrix.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; matrix[i].<span class="built_in">size</span>(); j++) &#123;</span><br><span class="line">                <span class="comment">// 一个位置等于1的时候就是一个1x1的正方形了</span></span><br><span class="line">                <span class="keyword">if</span> (matrix[i][j] == <span class="string">&#x27;1&#x27;</span>) &#123;</span><br><span class="line">                    <span class="comment">// 从2x2的位置开始判断</span></span><br><span class="line">                    <span class="type">int</span> a = i + <span class="number">1</span>, b = j + <span class="number">1</span>;</span><br><span class="line">                    <span class="type">int</span> length = <span class="number">1</span>;      <span class="comment">// 当前正方形边长</span></span><br><span class="line">                    <span class="type">int</span> lengthCheck = <span class="number">1</span>; <span class="comment">// 正方形条件判断计数器</span></span><br><span class="line">                    <span class="comment">// 出现越界的时候停止扩张</span></span><br><span class="line">                    <span class="keyword">while</span> (a &lt; matrix.<span class="built_in">size</span>() &amp;&amp; b &lt; matrix[i].<span class="built_in">size</span>()) &#123;</span><br><span class="line">                    <span class="comment">// 这里不能用引用，避免修改数组里面的原始值</span></span><br><span class="line">                        pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; p = oneCount[a][b];</span><br><span class="line">                        <span class="comment">// 注意这里扩张的时候需要用lengthCheck来相减计算，而不是简单的减一</span></span><br><span class="line">                        <span class="comment">// 因为边长每扩大一次需要减的位置也会扩大一次</span></span><br><span class="line">                        p.first -=</span><br><span class="line">                            oneCount[a][b - lengthCheck].first; <span class="comment">// 行的前一个</span></span><br><span class="line">                        p.second -=</span><br><span class="line">                            oneCount[a - lengthCheck][b].second; <span class="comment">// 列的上一个</span></span><br><span class="line"></span><br><span class="line">                        <span class="comment">// 符合正方形要求</span></span><br><span class="line">                        <span class="keyword">if</span> (matrix[a][b] == <span class="string">&#x27;1&#x27;</span> &amp;&amp; (p.first == lengthCheck &amp;&amp;</span><br><span class="line">                                                    p.second == lengthCheck)) &#123;</span><br><span class="line">                            lengthCheck++;</span><br><span class="line">                            length++;</span><br><span class="line">                        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                            <span class="keyword">break</span>; <span class="comment">// 不符合就跳出</span></span><br><span class="line">                        &#125;</span><br><span class="line">                        a++;</span><br><span class="line">                        b++;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// 计算面积，更新最大值</span></span><br><span class="line">                    <span class="type">int</span> square = length * length;</span><br><span class="line">                    maxSquare = square &gt; maxSquare ? square : maxSquare;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxSquare;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/03/afa2032b4f1a3b38774d638dab2109fb.png"></p><h2 id="思路2-动态递归"><a href="#思路2-动态递归" class="headerlink" title="思路2-动态递归"></a>思路2-动态递归</h2><p>因为我还没有开始学动归的算法，只学一道题其他的还是不会，不如留着到时候一起回顾。</p>]]></content>
    
    
    <summary type="html">leetcode刷题笔记-221最大正方形</summary>
    
    
    
    <category term="编程学习" scheme="https://blog.musnow.top/categories/%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="把题目都给刷干净" scheme="https://blog.musnow.top/categories/%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0/%E6%8A%8A%E9%A2%98%E7%9B%AE%E9%83%BD%E7%BB%99%E5%88%B7%E5%B9%B2%E5%87%80/"/>
    
    
    <category term="OJ刷题" scheme="https://blog.musnow.top/tags/OJ%E5%88%B7%E9%A2%98/"/>
    
    <category term="leetcode" scheme="https://blog.musnow.top/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>【leetcode】33.搜索旋转排序数组</title>
    <link href="https://blog.musnow.top/posts/2415384769/"/>
    <id>https://blog.musnow.top/posts/2415384769/</id>
    <published>2024-03-25T01:34:27.000Z</published>
    <updated>2024-03-25T02:05:18.000Z</updated>
    
    <content type="html"><![CDATA[<p>这道题是快手面经中提到的，在此记录：<a href="https://www.nowcoder.com/feed/main/detail/b17a674ca2ba4327b3105ffacd1f60b4">https://www.nowcoder.com/feed/main/detail/b17a674ca2ba4327b3105ffacd1f60b4</a></p><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><blockquote><p><a href="https://leetcode.cn/problems/search-in-rotated-sorted-array/description/">33. 搜索旋转排序数组</a></p></blockquote><p>整数数组 nums 按升序排列，数组中的值 互不相同 。</p><p>在传递给函数之前，nums 在预先未知的某个下标 k（0 &lt;&#x3D; k &lt; nums.length）上进行了 旋转，使数组变为 <code>[nums[k], nums[k+1], ..., nums[n-1], nums[0], nums[1], ..., nums[k-1]]</code>（下标 从 0 开始 计数）。例如， <code>[0,1,2,4,5,6,7]</code> 在下标 3 处经旋转后可能变为 <code>[4,5,6,7,0,1,2]</code> 。</p><p>给你 旋转后 的数组 nums 和一个整数 target ，如果 nums 中存在这个目标值 target ，则返回它的下标，否则返回 -1 。</p><p>你必须设计一个时间复杂度为 <code>O(log n)</code> 的算法解决此问题。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">示例 1：</span><br><span class="line">输入：nums = [4,5,6,7,0,1,2], target = 0</span><br><span class="line">输出：4</span><br><span class="line"></span><br><span class="line">示例 2：</span><br><span class="line">输入：nums = [4,5,6,7,0,1,2], target = 3</span><br><span class="line">输出：-1</span><br><span class="line"></span><br><span class="line">示例 3：</span><br><span class="line">输入：nums = [1], target = 0</span><br><span class="line">输出：-1</span><br></pre></td></tr></table></figure><p>提示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1 &lt;= nums.length &lt;= 5000</span><br><span class="line">-104 &lt;= nums[i] &lt;= 104</span><br><span class="line">nums 中的每个值都 独一无二</span><br><span class="line">题目数据保证 nums 在预先未知的某个下标上进行了旋转</span><br><span class="line">-104 &lt;= target &lt;= 104</span><br></pre></td></tr></table></figure><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>本题要求用<code>O(log n)</code>的算法解决这个问题，自然没有办法通过暴力遍历来解决了（不然就太简单了）。</p><p>看到log就要想到二分法，同时要想到二分法的前提是遍历的序列已经有序，但这道题并非是一个严格有序的数组，它会进行一定的旋转。</p><p>仔细观察旋转的方式，当选用下标k的时候，会将k和k以后的元素全部移动到数组开头，之前的元素移动到数组末尾。</p><p>可以拿纸笔多试试几次，就能得出来一个结论，不管数组的长度是奇数还是偶数，也不管k选择那一个地方，被旋转的部分（k和k以后）和没有被旋转的部分（k以前）的序列长度肯定<strong>相等</strong>或有一个<strong>更长</strong>！</p><p>这里假设二分法计算mid的公式是<code>left+(right-left)/2</code>，其中left初始值为0，right初始值是<code>nums.size()-1</code>，二者都是闭区间。因为上文提到的特性（被旋转的部分和没有被旋转的部分长度相等或有一个更长），使用这个公式计算出来的第一个mid值肯定是在某个有序序列之中！</p><p>这里举几个具体的例子：</p><ul><li>数组长度7（奇数），k&#x3D;3，即在下标3处旋转，此时k之前还有下标<code>0,1,2</code>三个数字，k和k以后还有<code>3,4,5,6</code>四个数字；k&#x3D;4时同理，k之前有四个数字，k以后有三个数字。<ul><li>此时计算<code>mid=0+(6-0)/2=3</code>，不管k选择什么，下标3肯定是在某个有序序列之中的，这个有序序列要么在下标3之前，要么在下标3之后。</li></ul></li><li>数组长度8（偶数），k&#x3D;4，此时k之前有<code>0,1,2,3</code>四个数字，k和k之后有下标<code>4,5,6,7</code>四个数字，被旋转和没有被旋转的部分一样长；k&#x3D;5时没有被旋转的部分更长，k&#x3D;3时被旋转的部分更长。<ul><li>此时计算<code>mid=0+(7-0)/2=3</code>，不管k选择哪一个，下标3还是肯定在某个有序序列之中！</li></ul></li></ul><p>现在我们能确认这个特性了，也就能用二分法解决这个问题了！思路就是通过判断mid左侧还是右侧有序，来确认left&#x2F;right边界，让下一轮的mid计算在有序序列中进行。</p><ul><li>如果nums[left]小于等于nums[mid]，则说明左侧有序（这里的等于判断是避免mid&#x3D;left的情况）</li><li>其他情况都可以归于右侧有序</li></ul><p>在循环体内，每一次都需要判断mid左侧还是右侧有序的，确认有序序列的位置之后，找target的操作就是在有序数组中通过二分法查找的思想了，时间复杂度是<code>O(log(N))</code>。</p><ul><li>为什么每一次都需要判断？</li></ul><p>因为target可能不在第一次找到的有序序列中，如下示例，第一次计算出来的mid&#x3D;3，虽然能确认mid的左侧是有序的，但target&#x3D;1的时候，我们需要找的目标数是在mid的右侧。此时右侧的序列是<code>[7,0,1,2]</code>，这还不是一个有序序列，我们还是需要通过计算mid判断左侧还是右侧有序，来再次确认第二个有序的子序列位置。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[3,4,5,6,7,0,1,2]</span><br></pre></td></tr></table></figure><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>思路理清楚了，代码就不难写了</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">search</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 旋转后的数组肯定是一部分有序的</span></span><br><span class="line">        <span class="comment">// 这个有序的部分肯定是在mid左侧或者右侧！</span></span><br><span class="line">        <span class="comment">// 题目中的旋转是从k开始（包括k）往后的数字移动到数组的开头</span></span><br><span class="line">        <span class="comment">// 不管k选择哪里都肯定符合上面的这个条件，永远会有一边的数字更多</span></span><br><span class="line">        <span class="comment">// [4,5,6,7,0,1,2] 以mid=3分割</span></span><br><span class="line">        <span class="comment">// [4,5,6,7]       有序</span></span><br><span class="line">        <span class="comment">//       [7,0,1,2] 无序</span></span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> left = <span class="number">0</span>, right = nums.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 如果要使用小于等于，那么left和right应该都是闭区间</span></span><br><span class="line">        <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">            <span class="type">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">            <span class="comment">// 中间能找到</span></span><br><span class="line">            <span class="keyword">if</span> (nums[mid] == target) &#123;</span><br><span class="line">                <span class="keyword">return</span> mid;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 找不到，判断左侧或者右侧是否有序</span></span><br><span class="line">            <span class="keyword">if</span> (nums[left] &lt;= nums[mid]) <span class="comment">// 左侧有序</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// 判断值是否在左侧</span></span><br><span class="line">                <span class="keyword">if</span> (nums[left] &lt;= target &amp;&amp; target &lt; nums[mid]) &#123;</span><br><span class="line">                    right = mid - <span class="number">1</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="comment">// 左侧虽然有序，但是值在右侧</span></span><br><span class="line">                &#123;</span><br><span class="line">                    left = mid + <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 左半部分不是有序，说明右半部分是有序的</span></span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 值在右侧</span></span><br><span class="line">                <span class="keyword">if</span> (nums[right] &gt;= target &amp;&amp; target &gt; nums[mid]) &#123;</span><br><span class="line">                    left = mid + <span class="number">1</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    right = mid - <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/03/aebfd954000d9b32c58a81cfa094adf3.png" alt="image.png"></p>]]></content>
    
    
    <summary type="html">leetcode的33搜索旋转排序数组</summary>
    
    
    
    <category term="编程学习" scheme="https://blog.musnow.top/categories/%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="把题目都给刷干净" scheme="https://blog.musnow.top/categories/%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0/%E6%8A%8A%E9%A2%98%E7%9B%AE%E9%83%BD%E7%BB%99%E5%88%B7%E5%B9%B2%E5%87%80/"/>
    
    
    <category term="OJ刷题" scheme="https://blog.musnow.top/tags/OJ%E5%88%B7%E9%A2%98/"/>
    
    <category term="leetcode" scheme="https://blog.musnow.top/tags/leetcode/"/>
    
    <category term="二分法" scheme="https://blog.musnow.top/tags/%E4%BA%8C%E5%88%86%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>【leetcode】895最大频率栈</title>
    <link href="https://blog.musnow.top/posts/1873646973/"/>
    <id>https://blog.musnow.top/posts/1873646973/</id>
    <published>2024-03-24T03:27:51.000Z</published>
    <updated>2024-03-25T01:33:59.000Z</updated>
    
    <content type="html"><![CDATA[<p>leetcode的895最大频率栈题解，题目来自快手面经：<a href="https://www.nowcoder.com/discuss/493925109460135936">https://www.nowcoder.com/discuss/493925109460135936</a></p><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><blockquote><p><a href="https://leetcode.cn/problems/maximum-frequency-stack/description/">895. 最大频率栈</a></p></blockquote><p>设计一个类似堆栈的数据结构，将元素推入堆栈，并从堆栈中弹出出现频率最高的元素。</p><p>实现 FreqStack 类:</p><ul><li>FreqStack() 构造一个空的堆栈。</li><li>void push(int val) 将一个整数 val 压入栈顶。</li><li>int pop() 删除并返回堆栈中出现频率最高的元素。</li></ul><p>如果出现频率最高的元素不只一个，则移除并返回最接近栈顶的元素。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">示例 1：</span><br><span class="line">输入：</span><br><span class="line">[&quot;FreqStack&quot;,&quot;push&quot;,&quot;push&quot;,&quot;push&quot;,&quot;push&quot;,&quot;push&quot;,&quot;push&quot;,&quot;pop&quot;,&quot;pop&quot;,&quot;pop&quot;,&quot;pop&quot;],</span><br><span class="line">[[],[5],[7],[5],[7],[4],[5],[],[],[],[]]</span><br><span class="line">输出：[null,null,null,null,null,null,null,5,7,5,4]</span><br><span class="line"></span><br><span class="line">解释：</span><br><span class="line">FreqStack = new FreqStack();</span><br><span class="line">freqStack.push (5);//堆栈为 [5]</span><br><span class="line">freqStack.push (7);//堆栈是 [5,7]</span><br><span class="line">freqStack.push (5);//堆栈是 [5,7,5]</span><br><span class="line">freqStack.push (7);//堆栈是 [5,7,5,7]</span><br><span class="line">freqStack.push (4);//堆栈是 [5,7,5,7,4]</span><br><span class="line">freqStack.push (5);//堆栈是 [5,7,5,7,4,5]</span><br><span class="line">freqStack.pop ();//返回 5 ，因为 5 出现频率最高。堆栈变成 [5,7,5,7,4]。</span><br><span class="line">freqStack.pop ();//返回 7 ，因为 5 和 7 出现频率最高，但7最接近顶部。堆栈变成 [5,7,5,4]。</span><br><span class="line">freqStack.pop ();//返回 5 ，因为 5 出现频率最高。堆栈变成 [5,7,4]。</span><br><span class="line">freqStack.pop ();//返回 4 ，因为 4, 5 和 7 出现频率最高，但 4 是最接近顶部的。堆栈变成 [5,7]。</span><br></pre></td></tr></table></figure><p>提示：</p><ul><li><code>0 &lt;= val &lt;= 109</code>;</li><li>push 和 pop 的操作数不大于 <code>2 * 104</code>。</li><li>输入保证在调用 pop 之前堆栈中至少有一个元素。</li></ul><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>看到hard直接害怕，题解一看发现好像没有那么难……就是让我自己想恐怕是想不出来的。</p><p>用哈希表加栈就能解决这个问题，另外还需一个int变量维护当前最高频率是多少。</p><ul><li>一个哈希表用于元素和频率的计数</li><li>一个哈希表用于频率和对应的栈</li></ul><p>当插入元素的时候</p><ul><li>元素出现频率加一</li><li>在对应频率的栈中插入元素（并不需要在之前的栈中删除元素）</li><li>更新当前最高频率</li></ul><p>当弹出元素的时候</p><ul><li>从最高频率的栈中弹出一个元素</li><li>该元素出现频率减一</li><li>如果最高频率的栈为空，则最高频率减一（因为每次都是以1的间隔增加的，所以减一的栈里面肯定会有元素）</li></ul><p>这样就能很巧妙的实现题目需要的栈。</p><ul><li>哈希表中频率从低到高能理解为是一层栈，因为后入的频率高的数在栈顶；</li><li>相同频率中又是一层栈；</li></ul><p>即可以体现每一个数字的频率，又能保证栈的先入先出的特性！</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>思路并不难，代码实现也很简单</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">FreqStack</span> &#123;</span><br><span class="line">    unordered_map&lt;<span class="type">int</span>,stack&lt;<span class="type">int</span>&gt;&gt; stMap; <span class="comment">// 每个频率都有一个栈</span></span><br><span class="line">    unordered_map&lt;<span class="type">int</span>,<span class="type">int</span>&gt; countMap; <span class="comment">// 频率计数</span></span><br><span class="line">    <span class="type">int</span> maxFreq = <span class="number">0</span>; <span class="comment">// 最高频率</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">FreqStack</span>() &#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(<span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 将某个数字的频率加一</span></span><br><span class="line">        countMap[val]++;</span><br><span class="line">        stMap[countMap[val]].<span class="built_in">push</span>(val);</span><br><span class="line">        maxFreq = <span class="built_in">max</span>(maxFreq,countMap[val]);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 从最高频率的栈中pop一个元素即可</span></span><br><span class="line">        <span class="type">int</span> val = stMap[maxFreq].<span class="built_in">top</span>();</span><br><span class="line">        stMap[maxFreq].<span class="built_in">pop</span>();</span><br><span class="line">        <span class="comment">// 频率减一</span></span><br><span class="line">        countMap[val]--;</span><br><span class="line">        <span class="comment">// 如果最大频率栈没有内容，则减一</span></span><br><span class="line">        <span class="keyword">if</span>(stMap[maxFreq].<span class="built_in">empty</span>())&#123;</span><br><span class="line">            maxFreq--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> val;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your FreqStack object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * FreqStack* obj = new FreqStack();</span></span><br><span class="line"><span class="comment"> * obj-&gt;push(val);</span></span><br><span class="line"><span class="comment"> * int param_2 = obj-&gt;pop();</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/03/4ad7ed2196fbbbced588884ca9441c12.png" alt="image.png"></p>]]></content>
    
    
    <summary type="html">leetcode的895最大频率栈题解</summary>
    
    
    
    <category term="编程学习" scheme="https://blog.musnow.top/categories/%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="把题目都给刷干净" scheme="https://blog.musnow.top/categories/%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0/%E6%8A%8A%E9%A2%98%E7%9B%AE%E9%83%BD%E7%BB%99%E5%88%B7%E5%B9%B2%E5%87%80/"/>
    
    
    <category term="哈希" scheme="https://blog.musnow.top/tags/%E5%93%88%E5%B8%8C/"/>
    
    <category term="OJ刷题" scheme="https://blog.musnow.top/tags/OJ%E5%88%B7%E9%A2%98/"/>
    
    <category term="栈" scheme="https://blog.musnow.top/tags/%E6%A0%88/"/>
    
    <category term="leetcode" scheme="https://blog.musnow.top/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>【leetcode】540.有序数组中的单一元素</title>
    <link href="https://blog.musnow.top/posts/3000154357/"/>
    <id>https://blog.musnow.top/posts/3000154357/</id>
    <published>2024-03-24T02:47:49.000Z</published>
    <updated>2024-03-25T02:05:18.000Z</updated>
    
    <content type="html"><![CDATA[<p>这道题是很久以前的快手CPP面经中出现的，在此记录一下咋写</p><blockquote><p><a href="https://www.nowcoder.com/discuss/353156663853129728?sourceSSR=users">https://www.nowcoder.com/discuss/353156663853129728?sourceSSR=users</a></p></blockquote><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><blockquote><p><a href="https://leetcode.cn/problems/single-element-in-a-sorted-array/">540. 有序数组中的单一元素</a></p></blockquote><p>给你一个仅由整数组成的有序数组，其中每个元素都会出现两次，唯有一个数只会出现一次。</p><p>请你找出并返回只出现一次的那个数。</p><p>你设计的解决方案必须满足 <code>O(log n)</code> 时间复杂度和 <code>O(1)</code> 空间复杂度。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">示例 1:</span><br><span class="line">输入: nums = [1,1,2,3,3,4,4,8,8]</span><br><span class="line">输出: 2</span><br><span class="line"></span><br><span class="line">示例 2:</span><br><span class="line">输入: nums =  [3,3,7,7,10,11,11]</span><br><span class="line">输出: 10</span><br></pre></td></tr></table></figure><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>这道题如果用暴力遍历的话，<code>O(N)</code>的时间复杂度很容易搞定，比如遍历一遍用map记录一下每个元素出现的次数，再遍历一遍map就能得到结果。</p><p>但是题目要求是用<code>O(log N)</code>的时间复杂度，这就没有办法直接遍历了。但题目中给出的数组是有序的，再加上<code>O(log N)</code>的时间复杂度，这就需要我们能想到用二分法来解决这道题。</p><p>现在确定是用二分法了，具体怎么二分呢？这又不是比大小找元素！</p><p>先观察一下给出的数组，以示例一为例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[1,1,2,3,3,4,4,8,8]</span><br></pre></td></tr></table></figure><p>将这个数组中的2补全，即所有元素都出现两次</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[1,1,2,2,3,3,4,4,8,8]</span><br><span class="line"> 0 1 2 3 4 5 6 7 8 9</span><br></pre></td></tr></table></figure><p>能发现一个规律：奇数下标上的数和前一个数相同，偶数下标上的数和后一个数相同。</p><p>那么对于不符合条件的数组，我们只需要判断mid（数组中间）的元素</p><ul><li>如果mid是奇数，判断它是否和<strong>前一个数</strong>相同，如果相同，则能确定<strong>只出现一次的数</strong>是在mid的后边，不同则在mid之前；</li><li>如果mid是偶数，判断它是否和<strong>后一个数</strong>相同，如果相同，则能确定<strong>只出现一次的数</strong>是在mid的后边，不同则在mid之前；</li></ul><p>思路确定了，就可以写代码了</p><h2 id="代码1-if-x2F-else"><a href="#代码1-if-x2F-else" class="headerlink" title="代码1-if&#x2F;else"></a>代码1-if&#x2F;else</h2><p>这里用if&#x2F;else实现上述思路比较好理解</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">singleNonDuplicate</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> left = <span class="number">0</span>, right = nums.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">            <span class="type">int</span> mid = (left + right) / <span class="number">2</span>;</span><br><span class="line">            <span class="comment">// cout &lt;&lt; left &lt;&lt; &quot; - &quot; &lt;&lt; right &lt;&lt; &quot; - &quot; &lt;&lt; mid &lt;&lt; &quot;\n&quot;;</span></span><br><span class="line">            <span class="comment">// 偶数</span></span><br><span class="line">            <span class="keyword">if</span> (mid % <span class="number">2</span> == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// 判断下一位是否和当前位相同</span></span><br><span class="line">                <span class="keyword">if</span> (nums[mid] == nums[mid + <span class="number">1</span>]) &#123;</span><br><span class="line">                    left = mid + <span class="number">1</span>; <span class="comment">// 相同，在右边</span></span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;            <span class="comment">// 不相同，在左边</span></span><br><span class="line">                    right = mid;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="comment">// 奇数</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// 判断上一位是否和当前位相同</span></span><br><span class="line">                <span class="keyword">if</span> (nums[mid] == nums[mid - <span class="number">1</span>]) &#123;</span><br><span class="line">                    left = mid + <span class="number">1</span>; <span class="comment">// 相同，在右边</span></span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;            <span class="comment">// 不相同，在左边</span></span><br><span class="line">                    right = mid;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 最终left所在位置就是题目需要的位置</span></span><br><span class="line">        <span class="keyword">return</span> nums[left];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/03/6378e71101d5d91c31187030f33a78ac.png" alt="image-20240324111139325"></p><h2 id="代码2-位运算"><a href="#代码2-位运算" class="headerlink" title="代码2-位运算"></a>代码2-位运算</h2><p>使用位运算可以统一的处理奇数和偶数，代码能更加简洁。使用异或运算（相异为一相同为零）：</p><ul><li>奇数异或1等于奇数减一（奇数末尾为1，异或1后末尾为0，相当于减一）</li><li>偶数异或1等于偶数加一（偶数末尾为0，异或1后末尾为1，相当于加一）</li></ul><p>这样能写出如下代码，直接确定mid应该和谁进行比较</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">singleNonDuplicate</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> left = <span class="number">0</span>, right = nums.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">            <span class="type">int</span> mid = (left + right) / <span class="number">2</span>;</span><br><span class="line">            <span class="comment">// 奇数异或1等于奇数减一，偶数异或1等于偶数加一</span></span><br><span class="line">            <span class="keyword">if</span> (nums[mid] == nums[mid ^ <span class="number">1</span>]) &#123;</span><br><span class="line">                left = mid + <span class="number">1</span>; <span class="comment">// 在右边</span></span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="comment">// 在左边</span></span><br><span class="line">            &#123;</span><br><span class="line">                right = mid;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nums[left];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/03/b9b05e7fefe9f03540a7d457a468192d.png" alt="image-20240324111454584"></p>]]></content>
    
    
    <summary type="html">leetcode 540.有序数组中的单一元素</summary>
    
    
    
    <category term="编程学习" scheme="https://blog.musnow.top/categories/%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="把题目都给刷干净" scheme="https://blog.musnow.top/categories/%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0/%E6%8A%8A%E9%A2%98%E7%9B%AE%E9%83%BD%E7%BB%99%E5%88%B7%E5%B9%B2%E5%87%80/"/>
    
    
    <category term="Cpp" scheme="https://blog.musnow.top/tags/Cpp/"/>
    
    <category term="OJ刷题" scheme="https://blog.musnow.top/tags/OJ%E5%88%B7%E9%A2%98/"/>
    
    <category term="leetcode" scheme="https://blog.musnow.top/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>【算法】回溯算法</title>
    <link href="https://blog.musnow.top/posts/1548282049/"/>
    <id>https://blog.musnow.top/posts/1548282049/</id>
    <published>2024-03-22T02:44:51.000Z</published>
    <updated>2024-04-06T08:38:29.000Z</updated>
    
    <content type="html"><![CDATA[<p>参考《代码随想录》。</p><h1 id="1-什么是回溯？"><a href="#1-什么是回溯？" class="headerlink" title="1.什么是回溯？"></a>1.什么是回溯？</h1><h2 id="1-1-引言"><a href="#1-1-引言" class="headerlink" title="1.1 引言"></a>1.1 引言</h2><p>回溯算法简单说来是通过递归进行遍历，他并不是一个高效的算法，因为整个遍历的过程是在穷举所有可能的结果。</p><p>在二叉树的OJ刷题博客中，就已经遇到了使用了回溯思路的题目。比如<a href="https://leetcode.cn/problems/path-sum/description/">Leetcode 112 路径总和</a>这道题，递归参数中的curSum就是利用回溯的的思路，从上层往下传的。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">traversal</span><span class="params">(TreeNode* cur, <span class="type">int</span> count)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!cur-&gt;left &amp;&amp; !cur-&gt;right &amp;&amp; count == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">true</span>; <span class="comment">// 遇到叶子节点，并且计数为0</span></span><br><span class="line">        <span class="keyword">if</span> (!cur-&gt;left &amp;&amp; !cur-&gt;right) <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">// 遇到叶子节点直接返回</span></span><br><span class="line">   <span class="comment">// 这里体现回溯的思想，先将要遍历的下一层的值添加进去，然后再撤销操作。这样能让下一层先判断自己是否为叶子节点来正确停止递归。</span></span><br><span class="line">        <span class="keyword">if</span> (cur-&gt;left) &#123; <span class="comment">// 左</span></span><br><span class="line">            count -= cur-&gt;left-&gt;val; <span class="comment">// 递归，处理节点;</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">traversal</span>(cur-&gt;left, count)) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            count += cur-&gt;left-&gt;val; <span class="comment">// 回溯，撤销处理结果</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (cur-&gt;right) &#123; <span class="comment">// 右</span></span><br><span class="line">            count -= cur-&gt;right-&gt;val; <span class="comment">// 递归，处理节点;</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">traversal</span>(cur-&gt;right, count)) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            count += cur-&gt;right-&gt;val; <span class="comment">// 回溯，撤销处理结果</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">hasPathSum</span><span class="params">(TreeNode* root, <span class="type">int</span> sum)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">traversal</span>(root, sum - root-&gt;val);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="1-2-什么问题用回溯能解决？"><a href="#1-2-什么问题用回溯能解决？" class="headerlink" title="1.2 什么问题用回溯能解决？"></a>1.2 什么问题用回溯能解决？</h2><p>回溯法，一般可以解决如下几种问题：</p><ul><li>组合问题：N个数里面按一定规则找出k个数的集合</li><li>切割问题：一个字符串按一定规则有几种切割方式</li><li>子集问题：一个N个数的集合里有多少符合条件的子集</li><li>排列问题：N个数按一定规则全排列，有几种排列方式</li><li>棋盘问题：N皇后，解数独等等</li></ul><p>这些问题一般都涉及到了切割和组合，可以把一个大的集合通过一定的选择（当前层）再往下一层切割（缩小范围）来解决。通过这个思路整体看来，回溯法就很类似树形结构，与二叉树的递归遍历类似。</p><h2 id="1-3-回溯法模板"><a href="#1-3-回溯法模板" class="headerlink" title="1.3 回溯法模板"></a>1.3 回溯法模板</h2><p>在代码随想录中Carl大佬总结了一个回溯法的模板，这里引用如下。</p><p>既然回溯法用的大多都是递归，那么就需要明确递归的三部曲</p><ul><li>递归的参数</li><li>递归的末端返回情况（终止条件）</li><li>递归的单层操作逻辑</li></ul><p>对于回溯法也是一样的</p><ul><li>回溯函数（递归函数）的参数</li><li>回溯函数的末端返回情况（终止条件）</li><li>回溯函数单层的选择（通常是遍历）</li></ul><p>所以回溯法的代码模板如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">void fallback(参数)</span><br><span class="line">&#123;</span><br><span class="line">if(终止条件)&#123;</span><br><span class="line">// 一般是存放结果到返回值数组中</span><br><span class="line">        return;</span><br><span class="line">&#125;</span><br><span class="line">// 单层逻辑</span><br><span class="line">for(循环逻辑，一般是树中节点孩子的数量就是当前层的处理数量)</span><br><span class="line">&#123;</span><br><span class="line">// 处理节点</span><br><span class="line">fallback(参数) // 递归下一层</span><br><span class="line">// 撤销操作</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="2-组合问题"><a href="#2-组合问题" class="headerlink" title="2.组合问题"></a>2.组合问题</h1><p>下面的编号都是leetcode的题目号</p><h2 id="77-组合问题"><a href="#77-组合问题" class="headerlink" title="77 组合问题"></a>77 组合问题</h2><h3 id="题目和思路"><a href="#题目和思路" class="headerlink" title="题目和思路"></a>题目和思路</h3><blockquote><p><a href="https://leetcode.cn/problems/combinations/">77. 组合</a></p></blockquote><p>给定两个整数 <code>n</code> 和 <code>k</code>，返回范围 <code>[1, n]</code> 中所有可能的 <code>k</code> 个数的组合。</p><p>你可以按 <strong>任何顺序</strong> 返回答案。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">示例 1：</span><br><span class="line">输入：n = 4, k = 2</span><br><span class="line">输出：</span><br><span class="line">[</span><br><span class="line">  [2,4],</span><br><span class="line">  [3,4],</span><br><span class="line">  [2,3],</span><br><span class="line">  [1,2],</span><br><span class="line">  [1,3],</span><br><span class="line">  [1,4],</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">示例 2：</span><br><span class="line">输入：n = 1, k = 1</span><br><span class="line">输出：[[1]]</span><br></pre></td></tr></table></figure><p>这道题用循环暴力也不是不能写，但是一层K就需要多写一层循环，很难实现一个通用的暴力算法。所以需要用到递归的回溯算法来解决这道题。</p><p>这里直接借用一下代码随想录的图，每一层遍历就选择一个数字，再往下一层从这个值往后选择，直到长度为K或循环超出边界。</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/03/e2aecbc992ef998255f12b7dc1deab95.png" alt="image-20240322105026000"></p><p>根据这个思路，递归函数的参数如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// n 和 k 是题目的参数</span></span><br><span class="line"><span class="comment">// start 是本层循环中开始循环的值（左边界）</span></span><br><span class="line"><span class="comment">// curV 保存当前递归的集合，这里不能采用引用传参，因为上一层会进行回溯撤销</span></span><br><span class="line"><span class="comment">// retV 保存最终的结果，使用引用传参；</span></span><br><span class="line"><span class="type">void</span> _combine(<span class="type">int</span> n,<span class="type">int</span> k,<span class="type">int</span> start,<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt; curV,<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;&gt;&amp; retV)</span><br></pre></td></tr></table></figure><p>递归的终止条件是curV中的元素个数等于K了（找到了一个符合条件的集合），就将curV插入到retV中。因为这里的curV传的不是引用，所以也不存在需要清空curV的操作。</p><blockquote><p>因为我们是通过递归来进行curV的插入操作的，所以同一个元素不会在一个集合中被多次插入，不需要考虑去重的问题。</p></blockquote><p>另外，还有一个隐含的终止条件是start大于n了，这在for循环的条件中就能体现出来，不需要单独处理。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = start;i&lt;=n;i++)</span><br></pre></td></tr></table></figure><p>每一层要做的事情就是从这个数字序列中选一个数出来插入当前数组curV，然后递归遍历下一层。调用完毕递归函数后，需要撤销当前选择的数，避免影响下一轮循环。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将当前值插入，然后递归进行下一次处理</span></span><br><span class="line">curV.push_back(i);</span><br><span class="line"><span class="comment">// 这里应该从当前遍历值的下一个开始继续操作</span></span><br><span class="line">_combine(n,k,i+<span class="number">1</span>,curV,retV);</span><br><span class="line">curV.pop_back(); <span class="comment">// 回溯，撤销这一次操作</span></span><br></pre></td></tr></table></figure><h3 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h3><p>代码如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// curV不需要加引用，因为是回溯算法</span></span><br><span class="line">    <span class="type">void</span> _combine(<span class="type">int</span> n,<span class="type">int</span> k,<span class="type">int</span> start,vector&lt;<span class="type">int</span>&gt; curV,vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; retV)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 数量足够，插入结果集</span></span><br><span class="line">        <span class="keyword">if</span>(curV.<span class="built_in">size</span>() == k)&#123;</span><br><span class="line">            retV.<span class="built_in">push_back</span>(curV);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 遍历进行回溯</span></span><br><span class="line">        <span class="comment">// for(int i = start;i&lt;=n;i++) // 正常遍历</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 剪枝操作，如果下一层剩下的都不足k个了，那就不需要继续了</span></span><br><span class="line">        <span class="comment">// 比如这一层是1 2 3 4，选择了3后只剩4，但k=4，此时完全不够长度，这次遍历是没有意义的</span></span><br><span class="line">        <span class="comment">// 计算n减去k还需要多少个，就能削减掉下一层不够用的情况</span></span><br><span class="line">        <span class="comment">// https://www.programmercarl.com/0077.%E7%BB%84%E5%90%88.html#%E6%80%9D%E8%B7%AF</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = start;i&lt;=n -(k-curV.<span class="built_in">size</span>()<span class="number">-1</span>);i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 将当前值插入，然后递归进行下一次处理</span></span><br><span class="line">            curV.<span class="built_in">push_back</span>(i);</span><br><span class="line">            <span class="comment">// 这里应该从当前遍历值的下一个开始继续操作</span></span><br><span class="line">            _combine(n,k,i+<span class="number">1</span>,curV,retV);</span><br><span class="line">            curV.<span class="built_in">pop_back</span>(); <span class="comment">// 回溯，撤销这一次操作</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">combine</span>(<span class="type">int</span> n, <span class="type">int</span> k) &#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; retV;</span><br><span class="line">        <span class="comment">// 注意，题目给的范围是1到n</span></span><br><span class="line">        _combine(n,k,<span class="number">1</span>,<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(),retV);</span><br><span class="line">        <span class="keyword">return</span> retV;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/03/c5811aab6d8e76c042df2c650c64a57a.png" alt="image-20240322112408032"></p><h3 id="剪枝操作"><a href="#剪枝操作" class="headerlink" title="剪枝操作"></a>剪枝操作</h3><p>这里对如下for循环的<strong>剪枝操作</strong>做说明</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = start;i &lt;= n-(k-curV.size()<span class="number">-1</span>);i++)</span><br></pre></td></tr></table></figure><p>题目要求的是k个数的组合，当前还需要的数字的个数是<code>k-curV.size()</code>，<strong>除去当前层以外</strong>（这里确定的是循环边界，进循环后就会处理当前层），还需要<code>k-curV.size()-1</code>个数字。</p><p>也就是说，我们需要保证递归处理的<strong>下一层</strong>还能有<code>k-curV.size()-1</code>个数字供处理，如果没有，那么<strong>下一层就不需要进去了</strong>，因为下一层是没有意义的递归，会浪费时间和压栈消耗。</p><p>这个思路可以参考下图，当<code>N=4, K=3</code>的时候，选择3时下一层只剩一个数字4了，肯定找不到符合条件的K&#x3D;3长度的集合，所以在第一层遍历的时候，就可以直接跳过3和3之后的数字，不进行遍历回溯。</p><p>这个计算也比较简单，下一层还需要2个，那就N-2就行了；下一层还需要3个就是N-3（留了最后三个不用）。题目给的N是一个闭区间，不需要额外处理。</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/03/75a031ea3bd57221f044a733a474815c.png" alt="image-20240322103240017"></p><p>反应到代码上，for循环的边界值就成了<code>n-(k-curV.size()-1)</code>，这样就能保证无论如何往下的递归一定能找到至少一个符合长度为K的集合。</p><p>在代码随想录网站上，描述的是用<code> n - (k - path.size()) + 1</code>这个边界进行剪枝，这个公式和上面我提供的公式是一致的，个人感觉我的那个公式的思路更好理解一些。</p><h2 id="216-组合总和3"><a href="#216-组合总和3" class="headerlink" title="216 组合总和3"></a>216 组合总和3</h2><h3 id="题目和思路-1"><a href="#题目和思路-1" class="headerlink" title="题目和思路"></a>题目和思路</h3><blockquote><p><a href="https://leetcode.cn/problems/combination-sum-iii/">216. 组合总和 III</a></p></blockquote><p>找出所有相加之和为 <code>n</code> 的 <code>k</code> 个数的组合，且满足下列条件：</p><ul><li>只使用数字1到9</li><li>每个数字 <strong>最多使用一次</strong></li></ul><p>返回 <em>所有可能的有效组合的列表</em> 。该列表不能包含相同的组合两次，组合可以以任何顺序返回。</p><hr><p>这道题和上一题基本一致，上一题给出的n是1到n的边界，这道题锁定了边界是1到9，额外多了一个要求是k个数的和要为n。</p><p>题目中还有个要求是每个数组最多使用一次，这也和我们回溯算法的思路一致，因为是从上层往下每次选用一个数进行递归的，并不会出现同一个数使用多次的情况。</p><h3 id="代码模板"><a href="#代码模板" class="headerlink" title="代码模板"></a>代码模板</h3><p>递归函数的参数和上一道题目一致，多了一个sum用于保存当前数组内元素的和</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// n 和 k 是题目的参数</span></span><br><span class="line"><span class="comment">// start 是本层循环中开始循环的值（左边界）</span></span><br><span class="line"><span class="comment">// sum  当前curV数组内元素的和</span></span><br><span class="line"><span class="comment">// curV 保存当前递归的集合，这里不能采用引用传参，因为上一层会进行回溯撤销</span></span><br><span class="line"><span class="comment">// retV 保存最终的结果，使用引用传参；</span></span><br><span class="line"><span class="type">void</span> _combinationSum3(<span class="type">int</span> k, <span class="type">int</span> n,<span class="type">int</span> start,<span class="type">int</span> sum, vector&lt;<span class="type">int</span>&gt; curV,vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; retV )</span><br></pre></td></tr></table></figure><p>递归的终止条件是curV中的元素大小等于k，然后判断成员的和是否为n，如果为n才插入返回值数组retV。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(curV.<span class="built_in">size</span>() == k)&#123;</span><br><span class="line">    <span class="keyword">if</span>(sum == n)&#123;</span><br><span class="line">        retV.<span class="built_in">push_back</span>(curV);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一行的遍历也是一样的，将当前值插入数组，然后递归道下一层，并将当前层的操作撤销</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = start;i&lt;=<span class="number">9</span>;i++)</span><br><span class="line">      &#123;</span><br><span class="line">          <span class="comment">// 单层操作</span></span><br><span class="line">          curV.<span class="built_in">push_back</span>(i);</span><br><span class="line">          sum += i; </span><br><span class="line">          <span class="comment">// 递归下一层</span></span><br><span class="line">          _combinationSum3(k,n,i+<span class="number">1</span>,sum,curV,retV);</span><br><span class="line">          <span class="comment">// 撤销</span></span><br><span class="line">          curV.<span class="built_in">pop_back</span>();</span><br><span class="line">          sum -= i;</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure><p>上述代码可以进行简化，对sum的操作改为直接在传值的时候加一下i；</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = start;i&lt;=<span class="number">9</span>;i++)</span><br><span class="line">&#123;</span><br><span class="line">    curV.<span class="built_in">push_back</span>(i);</span><br><span class="line">    _combinationSum3(k,n,i+<span class="number">1</span>,sum+i,curV,retV);</span><br><span class="line">    curV.<span class="built_in">pop_back</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="完整代码-1"><a href="#完整代码-1" class="headerlink" title="完整代码"></a>完整代码</h3><p>完整代码如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="type">void</span> _combinationSum3(<span class="type">int</span> k, <span class="type">int</span> n,<span class="type">int</span> start,<span class="type">int</span> sum, vector&lt;<span class="type">int</span>&gt; curV,vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; retV ) &#123; </span><br><span class="line">        <span class="keyword">if</span>(curV.<span class="built_in">size</span>() == k)&#123;</span><br><span class="line">            <span class="keyword">if</span>(sum == n)&#123;</span><br><span class="line">                retV.<span class="built_in">push_back</span>(curV);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 一次遍历</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = start;i&lt;=<span class="number">9</span>;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            curV.<span class="built_in">push_back</span>(i);</span><br><span class="line">            _combinationSum3(k,n,i+<span class="number">1</span>,sum+i,curV,retV);</span><br><span class="line">            curV.<span class="built_in">pop_back</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">combinationSum3</span>(<span class="type">int</span> k, <span class="type">int</span> n) &#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; retV;</span><br><span class="line">        _combinationSum3(k,n,<span class="number">1</span>,<span class="number">0</span>,<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(),retV);</span><br><span class="line">        <span class="keyword">return</span> retV;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/03/5647647f20a4d1f98bbdec6206e98f4d.png" alt="image-20240322145222332"></p><h3 id="剪枝操作-1"><a href="#剪枝操作-1" class="headerlink" title="剪枝操作"></a>剪枝操作</h3><p>和77题一样，上述的代码也能进行剪枝操作。分别针对的是k个数字和n的值</p><ul><li>下一层不够<code>k-curV.size()</code>个数字的时候就不需要递归下一层了。</li><li>当前加上i之后已经超过sum了就不需要递归下一层了。</li></ul><p>优化后的代码如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="type">void</span> _combinationSum3(<span class="type">int</span> k, <span class="type">int</span> n,<span class="type">int</span> start,<span class="type">int</span> sum, vector&lt;<span class="type">int</span>&gt; curV,vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; retV ) &#123; </span><br><span class="line">        <span class="keyword">if</span>(curV.<span class="built_in">size</span>() == k)&#123;</span><br><span class="line">            <span class="keyword">if</span>(sum == n)&#123;</span><br><span class="line">                retV.<span class="built_in">push_back</span>(curV);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 已经不符合条件，不进入循环</span></span><br><span class="line">        <span class="keyword">if</span>(sum &gt; n)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 一次遍历</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = start;i&lt;=<span class="number">9</span> -(k-curV.<span class="built_in">size</span>()<span class="number">-1</span>);i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 已经不符合条件，进入下一层</span></span><br><span class="line">            <span class="keyword">if</span>(sum + i &gt; n)&#123;</span><br><span class="line">                <span class="keyword">return</span>; <span class="comment">// 加i都已经超过n了，下一个数也没有必要遍历了</span></span><br><span class="line">            &#125;</span><br><span class="line">         </span><br><span class="line">            curV.<span class="built_in">push_back</span>(i);</span><br><span class="line">            _combinationSum3(k,n,i+<span class="number">1</span>,sum+i,curV,retV);</span><br><span class="line">            curV.<span class="built_in">pop_back</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">combinationSum3</span>(<span class="type">int</span> k, <span class="type">int</span> n) &#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; retV;</span><br><span class="line">        _combinationSum3(k,n,<span class="number">1</span>,<span class="number">0</span>,<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(),retV);</span><br><span class="line">        <span class="keyword">return</span> retV;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="17-电话号码的数字组合"><a href="#17-电话号码的数字组合" class="headerlink" title="17 电话号码的数字组合"></a>17 电话号码的数字组合</h2><h3 id="题目和思路-2"><a href="#题目和思路-2" class="headerlink" title="题目和思路"></a>题目和思路</h3><blockquote><p><a href="https://leetcode.cn/problems/letter-combinations-of-a-phone-number/">17. 电话号码的字母组合</a></p></blockquote><p>给定一个仅包含数字 <code>2-9</code> 的字符串，返回所有它能表示的字母组合。答案可以按 <strong>任意顺序</strong> 返回。</p><p>给出数字到字母的映射如下（与电话按键相同）。注意 1 不对应任何字母。</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/03/908402445c0fbd05c009b3852bcb0e18.png" alt="image-20240322145712851"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">示例 1：</span><br><span class="line">输入：digits = &quot;23&quot;</span><br><span class="line">输出：[&quot;ad&quot;,&quot;ae&quot;,&quot;af&quot;,&quot;bd&quot;,&quot;be&quot;,&quot;bf&quot;,&quot;cd&quot;,&quot;ce&quot;,&quot;cf&quot;]</span><br><span class="line"></span><br><span class="line">示例 2：</span><br><span class="line">输入：digits = &quot;&quot;</span><br><span class="line">输出：[]</span><br><span class="line"></span><br><span class="line">示例 3：</span><br><span class="line">输入：digits = &quot;2&quot;</span><br><span class="line">输出：[&quot;a&quot;,&quot;b&quot;,&quot;c&quot;]</span><br></pre></td></tr></table></figure><ul><li><code>0 &lt;= digits.length &lt;= 4</code></li><li><code>digits[i]</code> 是范围 <code>[&#39;2&#39;, &#39;9&#39;]</code> 的一个数字。</li></ul><hr><p>在早些年没有只能手机的时候，功能机一般都是九键的键盘（如上图所示），当时如果想在上面打字发短信，就需要按一个键来代表它下面的英文字母。比如你想打出字母h，就需要按4号键两次（第一次选中的是g，第二次是h）才能打出来。现在智能手机的九键键盘也是从这个设计思路衍生出来的，主要目的是增大屏幕上每个按键的大小，减少误触。</p><blockquote><p>题外话：作为00后还算是用过这种东西，在我高中之前用的都是功能机，当时父母为了不让我玩游戏没给我买智能手机。不过这不影响我在功能机上玩贪吃蛇和五子棋，哈哈。</p></blockquote><p>这道题就是让你算出来按下某个数字按键，他能打出什么字母组合的。</p><p>还是用回溯的思想，首先需要一个字符串数组来记录每一个按键对应的字母值。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;string&gt; num2str = &#123;</span><br><span class="line">        <span class="string">&quot;&quot;</span>, <span class="comment">/* 0 */</span></span><br><span class="line">        <span class="string">&quot;&quot;</span>, <span class="comment">/* 1 */</span></span><br><span class="line">        <span class="string">&quot;abc&quot;</span>,</span><br><span class="line">        <span class="string">&quot;def&quot;</span>,</span><br><span class="line">        <span class="string">&quot;ghi&quot;</span>,</span><br><span class="line">        <span class="string">&quot;jkl&quot;</span>,</span><br><span class="line">        <span class="string">&quot;mno&quot;</span>,</span><br><span class="line">        <span class="string">&quot;pqrs&quot;</span>,</span><br><span class="line">        <span class="string">&quot;tuv&quot;</span>,</span><br><span class="line">        <span class="string">&quot;wxyz&quot;</span></span><br><span class="line">    &#125;;</span><br></pre></td></tr></table></figure><p>对于这道题而言，每一次需要遍历的数组是对应数字的字符串，在这个字符串中选择一个字符后，往下一层遍历就行了。</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/03/03f0b9f54b359f787fa65db16b1aad7b.png" alt="image-20240322150726967"></p><h3 id="代码模板-1"><a href="#代码模板-1" class="headerlink" title="代码模板"></a>代码模板</h3><p>首先是递归函数的参数，包括题目传入的字符串（理解为char的数组就行），当前遍历的下标（题目给出的字符串内的下标），当前的字符串（不能用引用传参），以及最终的返回值数组</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> _letterCombinations(<span class="type">const</span> string&amp; digits,<span class="type">int</span> index,string str,vector&lt;string&gt;&amp; retV)</span><br></pre></td></tr></table></figure><p>因为leetcode的c++题解都是有一个solution类的，所以retV这类返回值完全可以用一个类的成员变量来替代，可以节省一个递归的参数（虽然没有太大区别）</p><p>递归函数的终止条件是index大于digits的长度（下标越界）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(index &gt;= digits.<span class="built_in">size</span>())&#123;</span><br><span class="line">    retV.<span class="built_in">push_back</span>(str);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一层遍历中的处理如下，这里我单独判断处理了1（但题目给出的用例中其实不包含0和1），注意每一层遍历的字符串并不是digits，而是当前数字在键盘中对应的字母字符串。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 通过ascii的计算得出当前数字，并找到curStr中映射的字符串</span></span><br><span class="line"><span class="type">int</span> num = digits[index] - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line"><span class="keyword">if</span>(num &lt; <span class="number">2</span>) <span class="comment">// 没有对应的</span></span><br><span class="line">&#123;</span><br><span class="line">    retV.<span class="built_in">push_back</span>(str);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 一层的遍历</span></span><br><span class="line">string&amp; curStr = num2str[num];</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i&lt;curStr.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">    str.<span class="built_in">push_back</span>(curStr[i]);</span><br><span class="line">    _letterCombinations(digits,index+<span class="number">1</span>,str,retV);</span><br><span class="line">    str.<span class="built_in">pop_back</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="完整代码-2"><a href="#完整代码-2" class="headerlink" title="完整代码"></a>完整代码</h3><p>完整代码如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    vector&lt;string&gt; num2str = &#123;</span><br><span class="line">        <span class="string">&quot;&quot;</span>, <span class="comment">/* 0 */</span></span><br><span class="line">        <span class="string">&quot;&quot;</span>, <span class="comment">/* 1 */</span></span><br><span class="line">        <span class="string">&quot;abc&quot;</span>,</span><br><span class="line">        <span class="string">&quot;def&quot;</span>,</span><br><span class="line">        <span class="string">&quot;ghi&quot;</span>,</span><br><span class="line">        <span class="string">&quot;jkl&quot;</span>,</span><br><span class="line">        <span class="string">&quot;mno&quot;</span>,</span><br><span class="line">        <span class="string">&quot;pqrs&quot;</span>,</span><br><span class="line">        <span class="string">&quot;tuv&quot;</span>,</span><br><span class="line">        <span class="string">&quot;wxyz&quot;</span></span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="type">void</span> _letterCombinations(<span class="type">const</span> string&amp; digits,<span class="type">int</span> index,string str,vector&lt;string&gt;&amp; retV) &#123;</span><br><span class="line">        <span class="keyword">if</span>(index &gt;= digits.<span class="built_in">size</span>())&#123;</span><br><span class="line">            retV.<span class="built_in">push_back</span>(str);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 通过ascii的计算得出当前数字，并找到curStr中映射的字符串</span></span><br><span class="line">        <span class="type">int</span> num = digits[index] - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">        <span class="keyword">if</span>(num &lt; <span class="number">2</span>) <span class="comment">// 没有对应的</span></span><br><span class="line">        &#123;</span><br><span class="line">            retV.<span class="built_in">push_back</span>(str);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 一层的遍历</span></span><br><span class="line">        string&amp; curStr = num2str[num];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i&lt;curStr.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            str.<span class="built_in">push_back</span>(curStr[i]);</span><br><span class="line">            _letterCombinations(digits,index+<span class="number">1</span>,str,retV);</span><br><span class="line">            str.<span class="built_in">pop_back</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;string&gt; <span class="title">letterCombinations</span><span class="params">(string digits)</span> </span>&#123;</span><br><span class="line">        vector&lt;string&gt; retV;</span><br><span class="line">        <span class="comment">// 单独判断一下空字符串</span></span><br><span class="line">        <span class="keyword">if</span>(digits == <span class="string">&quot;&quot;</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> retV;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        _letterCombinations(digits,<span class="number">0</span>,<span class="string">&quot;&quot;</span>,retV);</span><br><span class="line">        <span class="keyword">return</span> retV;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/03/c92703d3a59494e906d3abb632f557bf.png" alt="image-20240322151941756"></p><p>因为这道题每一次遍历的都不一定是同一个字符串，所以不存在剪枝操作，只能通过递归遍历完毕整个digits字符串。</p><h2 id="39-组合总和"><a href="#39-组合总和" class="headerlink" title="39 组合总和"></a>39 组合总和</h2><h3 id="题目和思路-3"><a href="#题目和思路-3" class="headerlink" title="题目和思路"></a>题目和思路</h3><blockquote><p><a href="https://leetcode.cn/problems/combination-sum/">39. 组合总和</a></p></blockquote><p>给你一个 <strong>无重复元素</strong> 的整数数组 <code>candidates</code> 和一个目标整数 <code>target</code> ，找出 <code>candidates</code> 中可以使数字和为目标数 <code>target</code> 的 所有 <strong>不同组合</strong> ，并以列表形式返回。你可以按 <strong>任意顺序</strong> 返回这些组合。</p><p><code>candidates</code> 中的 <strong>同一个</strong> 数字可以 <strong>无限制重复被选取</strong> 。如果至少一个数字的被选数量不同，则两种组合是不同的。 </p><p>对于给定的输入，保证和为 <code>target</code> 的不同组合数少于 <code>150</code> 个。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">示例 1：</span><br><span class="line">输入：candidates = [2,3,6,7], target = 7</span><br><span class="line">输出：[[2,2,3],[7]]</span><br><span class="line">解释：</span><br><span class="line">2 和 3 可以形成一组候选，2 + 2 + 3 = 7 。注意 2 可以使用多次。</span><br><span class="line">7 也是一个候选， 7 = 7 。</span><br><span class="line">仅有这两种组合。</span><br><span class="line"></span><br><span class="line">示例 2：</span><br><span class="line">输入: candidates = [2,3,5], target = 8</span><br><span class="line">输出: [[2,2,2,2],[2,3,3],[3,5]]</span><br><span class="line"></span><br><span class="line">示例 3：</span><br><span class="line">输入: candidates = [2], target = 1</span><br><span class="line">输出: []</span><br></pre></td></tr></table></figure><h3 id="错误代码"><a href="#错误代码" class="headerlink" title="错误代码"></a>错误代码</h3><p>这道题还是用回溯，和上面的组合问题的代码基本一致。</p><ul><li>和等于target的时候终止递归</li><li>每一层都遍历数组，而且可以选择上一层已经选过的数。</li><li>注意本题需要加的是<strong>数组元素</strong>的值，不是for循环里面的<code>i</code>；</li></ul><p>刚开始我写出来了一个错误的代码，主要是看循环部分，我这里选用了每一层都直接重新遍历整个数组，这是不对的！</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="type">void</span> _combinationSum(vector&lt;<span class="type">int</span>&gt;&amp; candidates, <span class="type">int</span> target, <span class="type">int</span> sum,</span><br><span class="line">                         vector&lt;<span class="type">int</span>&gt; curV, vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; retV) &#123;</span><br><span class="line">        <span class="comment">// 值相等，插入</span></span><br><span class="line">        <span class="keyword">if</span> (sum == target) &#123;</span><br><span class="line">            retV.<span class="built_in">push_back</span>(curV);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 值已经大于了，不进入</span></span><br><span class="line">        <span class="keyword">if</span> (sum &gt; target) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 每一层都是直接重新遍历整个数组</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; candidates.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="comment">// 值已经大于了，不进入</span></span><br><span class="line">            <span class="keyword">if</span> (sum + candidates[i] &gt; target) &#123;</span><br><span class="line">                <span class="keyword">continue</span>; <span class="comment">// 数组不一定是升序排列的，所以还需要往后走</span></span><br><span class="line">            &#125;</span><br><span class="line">            curV.<span class="built_in">push_back</span>(candidates[i]);</span><br><span class="line">            _combinationSum(candidates, target, sum + candidates[i], curV, retV);</span><br><span class="line">            curV.<span class="built_in">pop_back</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">combinationSum</span>(vector&lt;<span class="type">int</span>&gt;&amp; candidates, <span class="type">int</span> target) &#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; retV;</span><br><span class="line">        <span class="keyword">if</span> (candidates.<span class="built_in">size</span>() == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> retV;</span><br><span class="line">        &#125;</span><br><span class="line">        _combinationSum(candidates, target, <span class="number">0</span>, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(), retV);</span><br><span class="line">        <span class="keyword">return</span> retV;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>哪怕是最简单的用例都错误了，肯定是有问题。</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/03/95abe26e517ae6b3f08db67377046257.png" alt="image-20240322153818632"></p><p>问题出在哪儿呢？先不说会有很多无效的递归。以上图用例举例，如果这一层选择了3，下一层还是从最开始选取，那么就会出现<code>3,2,...</code>这种选取方式，但这个选取如果有结果的话，那么这个结果在当时选择从2开始时<strong>就已经得到过一次</strong>了。</p><p>注意题目要求如果一个结果集中数字出现的次数相同则视为一个，即<code>[3,2,3]</code>和<code>[3,3,2]</code>是同一个结果，这两个结果在返回值数组中只能出现一次。上图的输出中就出现了这种重复的结果集，<strong>不符合题目的条件</strong>。</p><h3 id="正确代码"><a href="#正确代码" class="headerlink" title="正确代码"></a>正确代码</h3><p>这就要求我们修改思路了，上面的代码最大的问题是没有进行切分，每一层都还是一个完整的数组。只需要按之前的思路对每一层进行切分，就能解决。</p><p>首先是递归函数的参数中需要多一个starti，用来记录上一层是从哪一个数开始的</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> _combinationSum(vector&lt;<span class="type">int</span>&gt;&amp; candidates, <span class="type">int</span> target, <span class="type">int</span> sum,</span><br><span class="line">                     <span class="type">int</span> starti,vector&lt;<span class="type">int</span>&gt; curV, </span><br><span class="line">                     vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; retV)</span><br></pre></td></tr></table></figure><p>for循环中也需要修改，因为题目允许同一个数被选用多次，这里我们直接从starti开始选则，并且传参给下一层的时候，也不需要对i进行加一操作（这样下一层可以选择和上层相同的数字，也不会往前选择），就是正确的思路了！</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 每一层都是直接重新遍历整个数组</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = starti; i &lt; candidates.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">    <span class="comment">// 值已经大于了，不进入</span></span><br><span class="line">    <span class="keyword">if</span> (sum + candidates[i] &gt; target) &#123;</span><br><span class="line">        <span class="keyword">continue</span>; <span class="comment">// 数组不一定是升序排列的，所以还需要往后走</span></span><br><span class="line">    &#125;</span><br><span class="line">    curV.<span class="built_in">push_back</span>(candidates[i]);</span><br><span class="line">    _combinationSum(candidates, target, sum + candidates[i], i, curV,</span><br><span class="line">                    retV);</span><br><span class="line">    curV.<span class="built_in">pop_back</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最终完整的代码如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="type">void</span> _combinationSum(vector&lt;<span class="type">int</span>&gt;&amp; candidates, <span class="type">int</span> target, <span class="type">int</span> sum,</span><br><span class="line">                         <span class="type">int</span> starti, vector&lt;<span class="type">int</span>&gt; curV,</span><br><span class="line">                         vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; retV) &#123;</span><br><span class="line">        <span class="comment">// 值相等，插入</span></span><br><span class="line">        <span class="keyword">if</span> (sum == target) &#123;</span><br><span class="line">            retV.<span class="built_in">push_back</span>(curV);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 值已经大于了，不进入</span></span><br><span class="line">        <span class="keyword">if</span> (sum &gt; target) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 每一层都是直接重新遍历整个数组</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = starti; i &lt; candidates.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="comment">// 值已经大于了，不进入</span></span><br><span class="line">            <span class="keyword">if</span> (sum + candidates[i] &gt; target) &#123;</span><br><span class="line">                <span class="keyword">continue</span>; <span class="comment">// 数组不一定是升序排列的，所以还需要往后走</span></span><br><span class="line">            &#125;</span><br><span class="line">            curV.<span class="built_in">push_back</span>(candidates[i]);</span><br><span class="line">            _combinationSum(candidates, target, sum + candidates[i], i, curV,</span><br><span class="line">                            retV);</span><br><span class="line">            curV.<span class="built_in">pop_back</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">combinationSum</span>(vector&lt;<span class="type">int</span>&gt;&amp; candidates, <span class="type">int</span> target) &#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; retV;</span><br><span class="line">        <span class="keyword">if</span> (candidates.<span class="built_in">size</span>() == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> retV;</span><br><span class="line">        &#125;</span><br><span class="line">        _combinationSum(candidates, target, <span class="number">0</span>, <span class="number">0</span>, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(), retV);</span><br><span class="line">        <span class="keyword">return</span> retV;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/03/e3c8e0fd8756bbe9b90963fb7c27ba8e.png" alt="image-20240322154233646"></p><p>这道题的剪枝思路在上述代码中已经体现了，即当前值已经大于target了，就不需要进入下一次递归了。注意这里要用continue而不是直接return，因为题目给定的数组不一定是升序排列的，如果直接return可能会错过结果集。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 值已经大于了，不进入</span></span><br><span class="line"><span class="keyword">if</span> (sum + candidates[i] &gt; target) &#123;</span><br><span class="line"><span class="keyword">continue</span>; <span class="comment">// 数组不一定是升序排列的，所以还需要往后走</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="40-组合总和2"><a href="#40-组合总和2" class="headerlink" title="40 组合总和2"></a>40 组合总和2</h2><h3 id="题目和思路-4"><a href="#题目和思路-4" class="headerlink" title="题目和思路"></a>题目和思路</h3><blockquote><p><a href="https://leetcode.cn/problems/combination-sum-ii/">40. 组合总和 II</a></p></blockquote><p>给定一个候选人编号的集合 <code>candidates</code> 和一个目标数 <code>target</code> ，找出 <code>candidates</code> 中所有可以使数字和为 <code>target</code> 的组合。</p><p><code>candidates</code> 中的每个数字在每个组合中只能使用 <strong>一次</strong> 。</p><p><strong>注意：</strong>解集不能包含重复的组合。 </p><hr><p>这道题并不能简单的从上道39题目修改而来，因为题目给出的candidates数组有不同，在39题中，candidates数组是没有重复元素的，但这道题中有重复元素，组合内也允许出现重复元素，但最终返回值内的<strong>组合不能重复</strong>，这就在<strong>去重</strong>方面给了我们更多的要求。</p><ul><li>candidates数组中可能会有重复的元素；</li><li>下一层不能再选取相同的元素（对应代码中的i需要加一后传入下一层）；</li><li>返回值中的每个组合中可以出现重复元素；</li><li>返回值中<strong>相同的组合</strong>不能出现多次；</li></ul><p>一个比较简单的思路是用map或者set对最终的组合进行一次去重。在用例简单的时候，这样做不会超时，但用例多一点，再多来一次单独的去重操作就很容易超时了，所以最好是在遍历的时候就解决这个问题。</p><p>下图是代码随想录中的图（我自己画了老半天感觉画的很烂，还是借用一下老哥的图吧），主要的去重思路是，<strong>每一层选用的数需要进行去重</strong>，但下一层和上一层之间不需要去重。</p><p>比如第一层选用了第一个1后，第二层需要在<code>[1,2]</code>中选用，此时第二层依旧可以选用1；但是第一层往后的遍历中，数组的第二个1就不能选用了，应跳过。</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/03/47894f830f881ab3283894df07ba1ad0.png" alt="image-20240324100837881"></p><p>代码随想录中讲述到的思路是使用一个bool类型的used数组来实现这个功能，我觉得实在是麻烦且不是很好理解。</p><p>当然代码随想录后面还有一个比较简单的思路，也是我能想到的，即在for循环中直接判断<strong>当前数和上一个数是否相等</strong>来去重（跳过相等的情况）。对于回溯算法而言，每一次的for循环就是每一层了，符合题目需要的去重条件。</p><p>注意，使用这个办法需要将题目给出的数组进行<strong>排序</strong>（题目并没有保证给出的数组是有序的）。</p><h3 id="完整代码-3"><a href="#完整代码-3" class="headerlink" title="完整代码"></a>完整代码</h3><p>回溯递归的代码如下，在for循环中判断一下当前选用的元素和上一个是否相等就可以了。注意这里需要判断的是<code>i&gt;starti</code>而不是<code>i&gt;0</code>，因为<code>i&gt;starti</code>才能保证去重是在同一层上，<code>i&gt;0</code>虽然能保证不越界，但是下一层就无法选择和上一层的前一个相同的元素，不符合题目条件。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="type">void</span> _combinationSum2(vector&lt;<span class="type">int</span>&gt;&amp; candidates, <span class="type">int</span> target, <span class="type">int</span> sum,</span><br><span class="line">                          <span class="type">int</span> starti, vector&lt;<span class="type">int</span>&gt; curV,</span><br><span class="line">                          vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; retV) &#123;</span><br><span class="line">        <span class="comment">// 值相等，插入</span></span><br><span class="line">        <span class="keyword">if</span> (sum == target) &#123;</span><br><span class="line">            retV.<span class="built_in">push_back</span>(curV);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 值已经大于了，不进入</span></span><br><span class="line">        <span class="keyword">if</span> (sum &gt; target) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 每一层都是直接重新遍历整个数组</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = starti; i &lt; candidates.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="comment">// 当前值和上一次相同，跳过</span></span><br><span class="line">            <span class="comment">// i &gt; starti 保证是同一层的去重</span></span><br><span class="line">            <span class="keyword">if</span>(i &gt; starti &amp;&amp; candidates[i] == candidates[i<span class="number">-1</span>])&#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 值已经大于了，不进入</span></span><br><span class="line">            <span class="keyword">if</span> (sum + candidates[i] &gt; target) &#123;</span><br><span class="line">                <span class="keyword">return</span>; <span class="comment">// 已经对数组进行排序了，可以直接返回</span></span><br><span class="line">            &#125;</span><br><span class="line">            curV.<span class="built_in">push_back</span>(candidates[i]);</span><br><span class="line">            <span class="comment">// 这道题就需要对i加一了，因为下一层不能选择下标相同的数字；</span></span><br><span class="line">            _combinationSum2(candidates, target, sum + candidates[i], i + <span class="number">1</span>,</span><br><span class="line">                             curV, retV);</span><br><span class="line">            curV.<span class="built_in">pop_back</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">combinationSum2</span>(vector&lt;<span class="type">int</span>&gt;&amp; candidates, <span class="type">int</span> target) &#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; retV;</span><br><span class="line">        <span class="keyword">if</span> (candidates.<span class="built_in">size</span>() == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> retV;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">sort</span>(candidates.<span class="built_in">begin</span>(),candidates.<span class="built_in">end</span>());</span><br><span class="line">        _combinationSum2(candidates, target, <span class="number">0</span>, <span class="number">0</span>, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(), retV);</span><br><span class="line">        <span class="keyword">return</span> retV;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/03/2be650c1805cb352d63a7abf5c2bad89.png" alt="image-20240324101552367"></p><h1 id="3-切割问题"><a href="#3-切割问题" class="headerlink" title="3.切割问题"></a>3.切割问题</h1><p>切割问题的基本思路</p><ul><li>编写切割区间是否符合条件的判断函数</li><li>确定切割区间终止条件（递归终止条件）</li><li>确定单层循环如何指定切割区间。</li></ul><h2 id="131-分割回文串"><a href="#131-分割回文串" class="headerlink" title="131 分割回文串"></a>131 分割回文串</h2><h3 id="题目和思路-5"><a href="#题目和思路-5" class="headerlink" title="题目和思路"></a>题目和思路</h3><p>给你一个字符串 s，请你将 s 分割成一些子串，使每个子串都是 <strong>回文串</strong>。返回 s 所有可能的分割方案。</p><p>回文串是从从左往右读和从右往左读都完全一致的字符串。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">示例 1：</span><br><span class="line">输入：s = &quot;aab&quot;</span><br><span class="line">输出：[[&quot;a&quot;,&quot;a&quot;,&quot;b&quot;],[&quot;aa&quot;,&quot;b&quot;]]</span><br><span class="line"></span><br><span class="line">示例 2：</span><br><span class="line">输入：s = &quot;a&quot;</span><br><span class="line">输出：[[&quot;a&quot;]]</span><br></pre></td></tr></table></figure><p>提示</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1 &lt;= s.length &lt;= 16</span><br><span class="line">s 仅由小写英文字母组成</span><br></pre></td></tr></table></figure><p>思路依旧是用回溯，这是第一次遇到切割问题，我们主要是想办法通过下标区间“模拟”出来一个切割线。根据代码随想录提供的回溯模板，我们知道每一层都是一个for循环，此时就需要通过for循环的变量i来模拟一个切割线。</p><ul><li>当遍历到i时，认为<code>s[i]</code>和<code>s[i+1]</code>之间有一个切割线。</li></ul><p>和前文的组合问题一样，我们也需要一个startIndex来标识每一层for的起点。本题需要跳过之前已经选过的子串。</p><ul><li>可以认为<code>s[startIndex]</code>和上一位字符之间有另外一个切割线</li><li>这是上一层选中的切割线；</li><li>刚开始的时候，startIndex为0，<strong>切割线在字符串开头</strong>；</li></ul><p>for循环中什么时候需要递归到下一层呢？</p><ul><li>只有本层<code>[startIndex,i]</code>区域的字符串是一个回文串的时候，才需要递归下一层；</li><li>否则本层已经不满足条件，递归到下一层也是没有意义的！</li><li>本层区间已经是回文串，递归传入<code>startIndex+1</code>，从下一位开始选择新的回文子串；</li></ul><p>递归的终止条件是什么？</p><ul><li>前文提到，“当遍历到i时，认为<code>s[i]</code>和<code>s[i+1]</code>之间有一个切割线。”</li></ul><p>所以，当传入的startIndex为字符串size的时候，认为上一层的i已经走到了字符串末尾了，已经在字符串末尾处添加了一个切割线了，这时候就可以将结果插入数组了。</p><p>这里不需要做任何额外的判断，因为之前做的递归的判断条件已经决定了，能走到这里就说明所有子串已经满足回文条件。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (startIndex &gt;= s.<span class="built_in">size</span>()) &#123;</span><br><span class="line">    retV.<span class="built_in">push_back</span>(curV);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面是一个切割的示意图，方便理解。</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/04/306d6e19ed779dbd689f8e6c772c85ad.png" alt="image.png"></p><h3 id="完整代码-4"><a href="#完整代码-4" class="headerlink" title="完整代码"></a>完整代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    vector&lt;vector&lt;string&gt;&gt; retV; <span class="comment">// 返回值数组</span></span><br><span class="line">    vector&lt;string&gt; curV;         <span class="comment">// 当前的回文子串</span></span><br><span class="line"></span><br><span class="line">    <span class="type">void</span> _partition(string s, <span class="type">int</span> startIndex) &#123;</span><br><span class="line">        <span class="comment">// 越界，说明上一层i已经是s.size()-1，此时分割线是在字符串末尾；</span></span><br><span class="line">        <span class="comment">// 已经是最后一个分割线了，说明找到了符合条件的切割（没找到是走不到这里来的）</span></span><br><span class="line">        <span class="keyword">if</span> (startIndex &gt;= s.<span class="built_in">size</span>()) &#123;</span><br><span class="line">            retV.<span class="built_in">push_back</span>(curV);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 遍历，将下标当作子串</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = startIndex; i &lt; s.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="comment">// 如果是，将这里作为一个子串切割，递归到下一层找其他子串</span></span><br><span class="line">            <span class="comment">// 子串区间一直都是闭区间 [startIndex,i]</span></span><br><span class="line">            <span class="comment">// 此时i和i+1之间可以想象成有一个分割线</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">isReverseString</span>(s, startIndex, i)) &#123;</span><br><span class="line">            <span class="comment">// 插入当前选择的子串</span></span><br><span class="line">                string temp = s.<span class="built_in">substr</span>(startIndex, i - startIndex + <span class="number">1</span>);</span><br><span class="line">                curV.<span class="built_in">push_back</span>(temp);</span><br><span class="line">                <span class="comment">// 递归下一层</span></span><br><span class="line">                <span class="comment">// _partition(s, startIndex + 1); // 错误，i才是分割线位置</span></span><br><span class="line">                _partition(s, i + <span class="number">1</span>);</span><br><span class="line">                </span><br><span class="line">                <span class="comment">// 弹出当前选择的子串</span></span><br><span class="line">                curV.<span class="built_in">pop_back</span>(); <span class="comment">// 回溯</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 如果不是，这一次的切割已经无效了，直接跳过</span></span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 注意不能break，因为后序可能还会有回文的情况</span></span><br><span class="line">                <span class="comment">// 比如ab和aba</span></span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 判断是否为回文子串，双指针法</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isReverseString</span><span class="params">(<span class="type">const</span> string&amp; str, <span class="type">int</span> begin, <span class="type">int</span> end)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = begin, j = end; i &lt; j; i++, j--) &#123;</span><br><span class="line">            <span class="keyword">if</span> (str[i] != str[j]) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;string&gt;&gt; <span class="built_in">partition</span>(string s) &#123;</span><br><span class="line">        _partition(s, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> retV;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/04/8ecd5435bbc64b90bf69a31229a408b1.png" alt="image.png"></p><h2 id="93-复原IP地址"><a href="#93-复原IP地址" class="headerlink" title="93 复原IP地址"></a>93 复原IP地址</h2><blockquote><p><a href="https://leetcode.cn/problems/restore-ip-addresses/">https://leetcode.cn/problems/restore-ip-addresses/</a></p></blockquote><h3 id="题目和思路-6"><a href="#题目和思路-6" class="headerlink" title="题目和思路"></a>题目和思路</h3><p>有效 IP 地址 正好由四个整数（每个整数位于 0 到 255 之间组成，且不能含有前导 0），整数之间用 <code>&#39;.&#39;</code> 分隔。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">例如：&quot;0.1.2.201&quot; 和 &quot;192.168.1.1&quot; 是 有效 IP 地址，但是 &quot;0.011.255.245&quot;、&quot;192.168.1.312&quot; 和 &quot;192.168@1.1&quot; 是 无效 IP 地址。</span><br></pre></td></tr></table></figure><p>给定一个只包含数字的字符串 s ，用以表示一个 IP 地址，返回所有可能的有效 IP 地址，这些地址可以通过在 s 中插入 <code>&#39;.&#39;</code> 来形成。你 <strong>不能</strong> 重新排序或删除 s 中的任何数字。你可以按 任何 顺序返回答案。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">示例 1：</span><br><span class="line">输入：s = &quot;25525511135&quot;</span><br><span class="line">输出：[&quot;255.255.11.135&quot;,&quot;255.255.111.35&quot;]</span><br><span class="line"></span><br><span class="line">示例 2：</span><br><span class="line">输入：s = &quot;0000&quot;</span><br><span class="line">输出：[&quot;0.0.0.0&quot;]</span><br><span class="line"></span><br><span class="line">示例 3：</span><br><span class="line">输入：s = &quot;101023&quot;</span><br><span class="line">输出：[&quot;1.0.10.23&quot;,&quot;1.0.102.3&quot;,&quot;10.1.0.23&quot;,&quot;10.10.2.3&quot;,&quot;101.0.2.3&quot;</span><br></pre></td></tr></table></figure><p>提示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1 &lt;= s.length &lt;= 20</span><br><span class="line">s 仅由数字组成</span><br></pre></td></tr></table></figure><p>这道题和上一题131的切割基本一致，只不过我们需要在虚拟的切割线的基础上做额外的处理，即把<code>&#39;.&#39;</code>字符当作切割线，插入到字符串中。因为题目最终返回的的字符串需要是带IP地址的<code>&#39;.&#39;</code>的，我们这样做就相当于提前处理了最终IP地址的字符串。</p><p>先来确定最终的递归终止条件吧，这里不再用startIndex大于size的判断方式，因为IP地址大概率是走不到这里就已经找到符合条件的子串了。我们应该利用IP地址中有3个<code>&#39;.&#39;</code>的特性来做递归的终止条件，即加了点的数量为3的时候，就已经不能继续执行本层了，需要退出了。</p><p>插入返回值之前，还需要判断最后一个点到字符串末尾的区间是否符合IP地址的条件。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (pointNum == <span class="number">3</span>) &#123;</span><br><span class="line">    <span class="comment">// 判断最后一部分是否符合ip的条件</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">checkIpStr</span>(s, startIndex, s.<span class="built_in">size</span>() - <span class="number">1</span>)) &#123;</span><br><span class="line">        retV.<span class="built_in">push_back</span>(s);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>IP地址的判断函数如下，保证区间的字符串对应的数字是0到255，且不能有前导0；</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 判断这个区间是否是合法的ip地址</span></span><br><span class="line">   <span class="function"><span class="type">bool</span> <span class="title">checkIpStr</span><span class="params">(<span class="type">const</span> string&amp; s, <span class="type">int</span> start, <span class="type">int</span> end)</span> </span>&#123;</span><br><span class="line">       <span class="comment">// 区间合法（不能等于，start==end时是一个数字的情况）</span></span><br><span class="line">       <span class="keyword">if</span> (start &gt; end) &#123;</span><br><span class="line">           <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">// 以0开始的不合法（除非只有一个0）</span></span><br><span class="line">       <span class="keyword">if</span> (s[start] == <span class="string">&#x27;0&#x27;</span> &amp;&amp; start != end) &#123;</span><br><span class="line">           <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">       <span class="keyword">for</span> (<span class="type">int</span> i = start; i &lt;= end; i++) &#123;</span><br><span class="line">           <span class="comment">// 不是数字，不符合</span></span><br><span class="line">           <span class="keyword">if</span> (s[i] &lt; <span class="string">&#x27;0&#x27;</span> || s[i] &gt; <span class="string">&#x27;9&#x27;</span>) &#123;</span><br><span class="line">               <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="comment">// 加到sum里面</span></span><br><span class="line">           sum = sum * <span class="number">10</span> + (s[i] - <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">           <span class="comment">// 如果超过255，不符合</span></span><br><span class="line">           <span class="keyword">if</span> (sum &gt; <span class="number">255</span>) &#123;</span><br><span class="line">               <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>最终回溯函数的步骤如下：</p><ul><li>当遍历到i的时候，假设<code>s[i]</code>和<code>s[i+1]</code>之间有一个点；</li><li>判断<code>[startIndex,i]</code>区间是否符合IP地址的规定（0到255）；</li><li>符合条件，在i和i+1之间插入一个点；</li><li>点的数量加一；</li><li>递归下一层，其中startIndex应该传入<code>i+2</code>（跳过刚刚插入的点）；</li><li>回溯，点的数量减一，删除刚刚添加的点；</li></ul><h3 id="完整代码-5"><a href="#完整代码-5" class="headerlink" title="完整代码"></a>完整代码</h3><p>完整代码如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    vector&lt;string&gt; retV;</span><br><span class="line"></span><br><span class="line">    <span class="type">void</span> _restoreIpAddresses(string s, <span class="type">int</span> startIndex, <span class="type">int</span> pointNum) &#123;</span><br><span class="line">        <span class="comment">// IP地址需要打三个点，有三个点了之后就不需要继续for了</span></span><br><span class="line">        <span class="keyword">if</span> (pointNum == <span class="number">3</span>) &#123;</span><br><span class="line">            <span class="comment">// 判断最后一部分是否符合ip的条件</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">checkIpStr</span>(s, startIndex, s.<span class="built_in">size</span>() - <span class="number">1</span>)) &#123;</span><br><span class="line">                retV.<span class="built_in">push_back</span>(s);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = startIndex; i &lt; s.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="comment">// 判断[start,i]区间是否是合法的ip地址组成</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">checkIpStr</span>(s, startIndex, i)) &#123;</span><br><span class="line">                <span class="comment">// 是，加点（注意insert是在选中位置之前插入）</span></span><br><span class="line">                <span class="comment">// 加点是为了方便最后直接插入返回值</span></span><br><span class="line">                s.<span class="built_in">insert</span>(s.<span class="built_in">begin</span>() + i + <span class="number">1</span>, <span class="string">&#x27;.&#x27;</span>);</span><br><span class="line">                pointNum++;</span><br><span class="line">                <span class="comment">// 这里加2是为了跳过插入的点，走到下一位</span></span><br><span class="line">                _restoreIpAddresses(s, i + <span class="number">2</span>, pointNum);</span><br><span class="line">                <span class="comment">// 回溯本层操作</span></span><br><span class="line">                pointNum--;</span><br><span class="line">                s.<span class="built_in">erase</span>(s.<span class="built_in">begin</span>() + i + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 如果已经不符合条件了，说明这一层都不符合条件了</span></span><br><span class="line">            <span class="comment">// 比如515已经不符合条件了，再往后走更不符合（这一层符合条件的组合已经在之前走过了）</span></span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">break</span>; <span class="comment">// 跳出本层</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断这个区间是否是合法的ip地址</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">checkIpStr</span><span class="params">(<span class="type">const</span> string&amp; s, <span class="type">int</span> start, <span class="type">int</span> end)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 区间合法（不能等于，start==end时是一个数字的情况）</span></span><br><span class="line">        <span class="keyword">if</span> (start &gt; end) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 以0开始的不合法（除非只有一个0）</span></span><br><span class="line">        <span class="keyword">if</span> (s[start] == <span class="string">&#x27;0&#x27;</span> &amp;&amp; start != end) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = start; i &lt;= end; i++) &#123;</span><br><span class="line">            <span class="comment">// 不是数字，不符合</span></span><br><span class="line">            <span class="keyword">if</span> (s[i] &lt; <span class="string">&#x27;0&#x27;</span> || s[i] &gt; <span class="string">&#x27;9&#x27;</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 加到sum里面</span></span><br><span class="line">            sum = sum * <span class="number">10</span> + (s[i] - <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">            <span class="comment">// 如果超过255，不符合</span></span><br><span class="line">            <span class="keyword">if</span> (sum &gt; <span class="number">255</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;string&gt; <span class="title">restoreIpAddresses</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        _restoreIpAddresses(s, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> retV;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/04/05ea0b8be513ac4fdb8848948a5d301c.png" alt="image.png"></p><h1 id="4-子集问题"><a href="#4-子集问题" class="headerlink" title="4.子集问题"></a>4.子集问题</h1><h2 id="78-子集"><a href="#78-子集" class="headerlink" title="78 子集"></a>78 子集</h2><blockquote><p><a href="https://leetcode.cn/problems/subsets/description/">https://leetcode.cn/problems/subsets/description/</a></p></blockquote><h3 id="题目和思路-7"><a href="#题目和思路-7" class="headerlink" title="题目和思路"></a>题目和思路</h3><p>给你一个整数数组 nums ，数组中的元素 <strong>互不相同</strong> 。返回该数组所有可能的子集（幂集）。</p><p>解集 不能 包含重复的子集。你可以按 任意顺序 返回解集。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">示例 1：</span><br><span class="line">输入：nums = [1,2,3]</span><br><span class="line">输出：[[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]]</span><br><span class="line"></span><br><span class="line">示例 2：</span><br><span class="line">输入：nums = [0]</span><br><span class="line">输出：[[],[0]]</span><br></pre></td></tr></table></figure><p>这道题的思路就不是很难了，属于是回溯算法的一个最基础的思路。</p><p>首先要根据题目需要的子集来确定什么时候插入返回值数组和递归的终止条件，最开始我的想法是单独处理每个元素构成的数组（比如<code>[1],[2],[3]</code>）和空数组<code>[]</code>；在递归终止条件中插入其他数组到返回值。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(startIndex&gt;=nums.<span class="built_in">size</span>())&#123;</span><br><span class="line"> retV.<span class="built_in">push_back</span>(curV);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是这样会多出额外的一次遍历，虽然整体的时间复杂度没有变化，但多了一个遍历总归会浪费一些时间。</p><p>实际上也不需要这么麻烦，根据回溯算法的思路，其实第二层递归的时候，curV就是<code>[1],[2],[3]</code>这些由单个元素构成的数组了，也就是说，我们只要每一次递归调用函数的时候就把curV插入返回值，就能满足条件了！同时，第一次调用递归函数时，也正好会把空的curV给插入，空集也不需要额外处理了！</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 因为子集包括每一个数单独组成的数组和空数组，所以可以先直接把数组插入</span></span><br><span class="line"><span class="comment">// 第一次进入函数是插入空数组，第二层递归是插入每个数单独组成的数组</span></span><br><span class="line">retV.<span class="built_in">push_back</span>(curV);</span><br><span class="line"><span class="keyword">if</span>(startIndex&gt;=nums.<span class="built_in">size</span>())&#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>剩余的部分其实就是单层回溯了，题目要求不能有重复的子集（数组每个元素都不相同），所以下一层递归的时候，传给startIndex的是<code>i+1</code>，从下一位开始选择数插入数组就OK了。</p><h3 id="完整代码-6"><a href="#完整代码-6" class="headerlink" title="完整代码"></a>完整代码</h3><p>学过了前几题的回溯思路，这道题相对来说没有那么困难了。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; retV;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; curV;</span><br><span class="line">    <span class="comment">// 求子集的回溯函数</span></span><br><span class="line">    <span class="type">void</span> _subsets(vector&lt;<span class="type">int</span>&gt;&amp; nums,<span class="type">int</span> startIndex)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 因为子集包括每一个数单独组成的数组和空数组，所以可以先直接把数组插入</span></span><br><span class="line">        <span class="comment">// 第一次进入函数是插入空数组，第二层递归是插入每个数单独组成的数组</span></span><br><span class="line">        retV.<span class="built_in">push_back</span>(curV);</span><br><span class="line">        <span class="keyword">if</span>(startIndex&gt;=nums.<span class="built_in">size</span>())&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 回溯的循环</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = startIndex;i&lt;nums.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            <span class="comment">// 插入当前数</span></span><br><span class="line">            curV.<span class="built_in">push_back</span>(nums[i]);</span><br><span class="line">            <span class="comment">// 递归下一层，不能选择相同下标的数</span></span><br><span class="line">            _subsets(nums,i+<span class="number">1</span>);</span><br><span class="line">            <span class="comment">// 回溯当前操作</span></span><br><span class="line">            curV.<span class="built_in">pop_back</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">subsets</span>(vector&lt;<span class="type">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        _subsets(nums,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> retV;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/04/489dc2b8a3021e05a4564c670c11bd0a.png" alt="image.png"></p><h2 id="90-子集2"><a href="#90-子集2" class="headerlink" title="90 子集2"></a>90 子集2</h2><blockquote><p><a href="https://leetcode.cn/problems/subsets-ii/description/">https://leetcode.cn/problems/subsets-ii/description/</a></p></blockquote><h3 id="题目和思路-8"><a href="#题目和思路-8" class="headerlink" title="题目和思路"></a>题目和思路</h3><p>给你一个整数数组 nums ，<strong>其中可能包含重复元素</strong>，请你返回该数组所有可能的 子集（幂集）。</p><p>解集 不能 包含重复的子集。返回的解集中，子集可以按 任意顺序 排列。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">示例 1：</span><br><span class="line">输入：nums = [1,2,2]</span><br><span class="line">输出：[[],[1],[1,2],[1,2,2],[2],[2,2]]</span><br><span class="line"></span><br><span class="line">示例 2：</span><br><span class="line">输入：nums = [0]</span><br><span class="line">输出：[[],[0]]</span><br></pre></td></tr></table></figure><p>这道题和78题的关系好比39和40题的关系一样，由78题的数组中不包括重复元素，变成了数组中有重复元素，且结果集不能有重复的子集。</p><p>如果还按照78题的思路来写，此时就会出现两个<code>[1,2]</code>子集的情况（一个是1和第一个2匹配的子集，另外一个是1和第二个2匹配的子集）。</p><p>实际上，每一层的处理都不能处理相同的数，包括进入下一层的递归也是。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[1,2,2,3]</span><br><span class="line">当前 i = 1，选中第一个2</span><br><span class="line">往下递归，可得到集合[2,2]、[2,3]、[2,2,3]</span><br><span class="line"></span><br><span class="line">如果for循环不做去重，i = 2选中第二个2</span><br><span class="line">往下递归，会重复得到集合[2,3]</span><br></pre></td></tr></table></figure><p>这里的去重思路并不难实现，和40题的去重基本一致：在<strong>单层</strong>for中，如果上一位和当前位相等，则跳过当前位（重复了）。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (i &gt; startIndex &amp;&amp; nums[i] == nums[i - <span class="number">1</span>]) &#123;</span><br><span class="line"><span class="keyword">continue</span>; <span class="comment">// 跳过相同数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样不仅解决了多个数的子集的重复问题，还解决了单个数的子集的重复问题，<code>[1,2,2]</code>在第一层for中，只会有1和第一个2进入下一层，<strong>最后一个2会被去重跳过</strong>，也就不会重复插入子集<code>[2]</code>。</p><h3 id="完整代码-7"><a href="#完整代码-7" class="headerlink" title="完整代码"></a>完整代码</h3><p>注意，这个判断上一位的去重思路是基于数组有序的，但题目并没有保证输入数组有序，所以调用递归函数之前，需要对数组排序。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; retV;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; curV;</span><br><span class="line">    <span class="comment">// 求子集的回溯函数</span></span><br><span class="line">    <span class="type">void</span> _subsetsWithDup(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> startIndex) &#123;</span><br><span class="line">        <span class="comment">// 因为子集包括每一个数单独组成的数组和空数组，所以可以先直接把数组插入</span></span><br><span class="line">        <span class="comment">// 第一次进入函数是插入空数组，第二层递归是插入每个数单独组成的数组</span></span><br><span class="line">        retV.<span class="built_in">push_back</span>(curV);</span><br><span class="line">        <span class="keyword">if</span> (startIndex &gt;= nums.<span class="built_in">size</span>()) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 回溯的循环</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = startIndex; i &lt; nums.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="comment">// 单层的去重</span></span><br><span class="line">            <span class="keyword">if</span> (i &gt; startIndex &amp;&amp; nums[i] == nums[i - <span class="number">1</span>]) &#123;</span><br><span class="line">                <span class="keyword">continue</span>; <span class="comment">// 跳过相同数</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 插入当前数</span></span><br><span class="line">            curV.<span class="built_in">push_back</span>(nums[i]);</span><br><span class="line">            <span class="comment">// 递归下一层</span></span><br><span class="line">            _subsetsWithDup(nums, i + <span class="number">1</span>);</span><br><span class="line">            <span class="comment">// 回溯当前操作</span></span><br><span class="line">            curV.<span class="built_in">pop_back</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">subsetsWithDup</span>(vector&lt;<span class="type">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        <span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>()); <span class="comment">// 排序</span></span><br><span class="line">        _subsetsWithDup(nums, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> retV;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/04/abc05725c7808521ecda379be843cea7.png" alt="image.png"></p><h2 id="491-非递减子序列"><a href="#491-非递减子序列" class="headerlink" title="491 非递减子序列"></a>491 非递减子序列</h2><blockquote><p><a href="https://leetcode.cn/problems/non-decreasing-subsequences/description/">https://leetcode.cn/problems/non-decreasing-subsequences/description/</a></p></blockquote><h3 id="题目和思路-9"><a href="#题目和思路-9" class="headerlink" title="题目和思路"></a>题目和思路</h3><p>给你一个整数数组 nums ，找出并返回所有该数组中不同的递增子序列，递增子序列中 至少有两个元素 。你可以按 任意顺序 返回答案。</p><p>数组中可能含有重复元素，<strong>如出现两个整数相等，也可以视作递增序列的一种特殊情况</strong>。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">示例 1：</span><br><span class="line">输入：nums = [4,6,7,7]</span><br><span class="line">输出：[[4,6],[4,6,7],[4,6,7,7],[4,7],[4,7,7],[6,7],[6,7,7],[7,7]]</span><br><span class="line"></span><br><span class="line">示例 2：</span><br><span class="line">输入：nums = [4,4,3,2,1]</span><br><span class="line">输出：[[4,4]]</span><br></pre></td></tr></table></figure><p>提示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1 &lt;= nums.length &lt;= 15</span><br><span class="line">-100 &lt;= nums[i] &lt;= 100</span><br></pre></td></tr></table></figure><p>首先注意这道题的要求，需要我们找到所有的递增子序列。这里包含了一个隐含的要求，即我们<strong>不可以对原数组进行重排序</strong>（否则找到的递增子序列不一定符合条件）。</p><ul><li>怎么判断当前找到的子序列是递增的？</li></ul><p>通过startIndex来判断，我们需要保证当前层添加的数比上一层的数更大或相等，就是一个递增的子序列。第一层curV为空，不需要判断。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 因为在for中每次都只会往curV插入一个数，所以可以直接判断</span></span><br><span class="line"><span class="comment">// 如果当前位小于startIndex-1，跳过</span></span><br><span class="line"><span class="keyword">if</span> (startIndex - <span class="number">1</span> &gt;= <span class="number">0</span> &amp;&amp; i &gt; startIndex - <span class="number">1</span> &amp;&amp;</span><br><span class="line">nums[i] &lt; nums[startIndex - <span class="number">1</span>]) &#123;</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>什么时候插入返回值？</li></ul><p>题目需要的是<strong>所有递增的子序列</strong>。</p><p>此时既不能在越界终止条件中插入返回值，也不能直接在函数开始插入返回值。前者会导致结果集<strong>只包含叶子节点的子集</strong>（中途节点符合条件的子集未被加入），后者会导致<strong>只包含单个元素的子集被错误插入</strong>（题目要求子集必须至少有2个元素）。</p><p>正确的插入情况是curV的长度大于1的时候插入，这时候每一次递归都会把符合条件的子集插入其中。配合for循环内的去重逻辑避免重复子集被插入。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (curV.<span class="built_in">size</span>() &gt; <span class="number">1</span>) &#123;</span><br><span class="line">          retV.<span class="built_in">push_back</span>(curV);</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure><p>递归的终止条件依旧是startIndex大于数组长度</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 越界终止</span></span><br><span class="line"><span class="keyword">if</span> (startIndex &gt;= nums.<span class="built_in">size</span>()) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>需要去重吗？</li></ul><p>注意，本题也是需要去重的</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[4,6,7,7]</span><br><span class="line">第一层选择4，进入第二层，在[6,7,7]中选</span><br><span class="line">如果不去重，就会出现两个[4,7]子集</span><br><span class="line"></span><br><span class="line">第二层选择6，进入第三层，在[7,7]中选</span><br><span class="line">如果不去重，就会出现两个[4,6,7]子集</span><br></pre></td></tr></table></figure><ul><li>单层怎么去重？</li></ul><p>之前的函数中，我们直接判断i不等于i-1来去重，但那是基于数组已经有序的情况下使用的了。</p><p>现在因为<strong>不能对原始数组做重排序</strong>，我们应该使用一个哈希表来对数组中元素去重。单层被选用过的元素不能再被使用。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// for循环之前定义去重集合</span></span><br><span class="line">unordered_set&lt;<span class="type">int</span>&gt; used; </span><br><span class="line"></span><br><span class="line"><span class="comment">// for循环中，判断某个数是否已被使用过</span></span><br><span class="line"><span class="keyword">if</span> (used.<span class="built_in">count</span>(nums[i]) != <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line">used.<span class="built_in">insert</span>(nums[i]);<span class="comment">// 没有使用过则插入</span></span><br></pre></td></tr></table></figure><p>此时的代码已经可以通过了。但针对本题，去重还有可优化之处：注意题目给的提示，数组中元素的大小区间是<code>[-100,100]</code>，这并不是一个很大的区间，我们完全可以使用一个201个元素的数组来替代<code>unordered_set</code>做去重的操作。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// for循环之前定义</span></span><br><span class="line"><span class="function">vector&lt;<span class="type">bool</span>&gt; <span class="title">usedArray</span><span class="params">(<span class="number">201</span>, <span class="literal">false</span>)</span></span>; <span class="comment">// num[i] + 100 作为下标</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// for循环内直接判断对应下标位置即可</span></span><br><span class="line"><span class="keyword">if</span> (usedArray[nums[i] + <span class="number">100</span>] != <span class="literal">false</span>) &#123;</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line">usedArray[nums[i] + <span class="number">100</span>] = <span class="literal">true</span>; <span class="comment">// 标记已经使用过了</span></span><br></pre></td></tr></table></figure><p>虽然<code>unordered_set</code>能提供<code>O(1)</code>级别的查找，但它并非严格的<code>O(1)</code>，同时插入的操作也会有更多的耗时。使用数组能保证不管是查询还是插入都只需要做1个操作。</p><p>针对这种哈希的情形，如果能确定数值的范围不大（比如本题或映射仅小写英文字母的情况），那么使用一个定长数组会优于使用哈希表。</p><h3 id="完整代码-8"><a href="#完整代码-8" class="headerlink" title="完整代码"></a>完整代码</h3><p>代码如下，本题主要是去重思路和其他题目不一样。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; retV;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; curV;</span><br><span class="line">    <span class="type">void</span> _findSubsequences(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> startIndex) &#123;</span><br><span class="line">        <span class="comment">// 题目要求子序列必须有两个元素</span></span><br><span class="line">        <span class="keyword">if</span> (curV.<span class="built_in">size</span>() &gt; <span class="number">1</span>) &#123;</span><br><span class="line">            retV.<span class="built_in">push_back</span>(curV);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 越界终止</span></span><br><span class="line">        <span class="keyword">if</span> (startIndex &gt;= nums.<span class="built_in">size</span>()) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 单层for中不能选择已经选过的数</span></span><br><span class="line">        <span class="comment">// unordered_set&lt;int&gt; used; // 去重集合</span></span><br><span class="line">        <span class="comment">// 因为题目给出了数字的区间是-100到100，可以直接用一个201长度的数组做哈希，提高效率</span></span><br><span class="line">        <span class="function">vector&lt;<span class="type">bool</span>&gt; <span class="title">usedArray</span><span class="params">(<span class="number">201</span>, <span class="literal">false</span>)</span></span>; <span class="comment">// num[i] + 100 作为下标</span></span><br><span class="line">        <span class="comment">// 单层for</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = startIndex; i &lt; nums.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="comment">// 因为在for中每次都只会往curV插入一个数，所以可以直接判断</span></span><br><span class="line">            <span class="comment">// 如果当前位小于startIndex-1，跳过</span></span><br><span class="line">            <span class="keyword">if</span> (startIndex - <span class="number">1</span> &gt;= <span class="number">0</span> &amp;&amp; i &gt; startIndex - <span class="number">1</span> &amp;&amp;</span><br><span class="line">                nums[i] &lt; nums[startIndex - <span class="number">1</span>]) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 单层for中不能选择已经选过的数</span></span><br><span class="line">            <span class="comment">// if (used.count(nums[i]) != 0)</span></span><br><span class="line">            <span class="keyword">if</span> (usedArray[nums[i] + <span class="number">100</span>] != <span class="literal">false</span>) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 插入本层</span></span><br><span class="line">            <span class="comment">// used.insert(nums[i]);</span></span><br><span class="line">            usedArray[nums[i] + <span class="number">100</span>] = <span class="literal">true</span>; <span class="comment">// 标记已经使用过了</span></span><br><span class="line">            curV.<span class="built_in">push_back</span>(nums[i]);</span><br><span class="line">            <span class="comment">// 递归下一层</span></span><br><span class="line">            _findSubsequences(nums, i + <span class="number">1</span>);</span><br><span class="line">            <span class="comment">// 回溯</span></span><br><span class="line">            curV.<span class="built_in">pop_back</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">findSubsequences</span>(vector&lt;<span class="type">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        _findSubsequences(nums, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> retV;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/04/787201c7664cacc5753ef66e8fbfbf57.png" alt="image.png"></p><h1 id="5-排列问题"><a href="#5-排列问题" class="headerlink" title="5.排列问题"></a>5.排列问题</h1><h2 id="46-全排列"><a href="#46-全排列" class="headerlink" title="46 全排列"></a>46 全排列</h2><blockquote><p><a href="https://leetcode.cn/problems/permutations/">https://leetcode.cn/problems/permutations/</a></p></blockquote><h3 id="题目和思路-10"><a href="#题目和思路-10" class="headerlink" title="题目和思路"></a>题目和思路</h3><p>给定一个<strong>不含重复数字</strong>的数组 nums ，返回其 所有可能的全排列 。你可以 按任意顺序 返回答案。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">示例 1：</span><br><span class="line">输入：nums = [1,2,3]</span><br><span class="line">输出：[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]</span><br><span class="line"></span><br><span class="line">示例 2：</span><br><span class="line">输入：nums = [0,1]</span><br><span class="line">输出：[[0,1],[1,0]]</span><br><span class="line"></span><br><span class="line">示例 3：</span><br><span class="line">输入：nums = [1]</span><br><span class="line">输出：[[1]]</span><br></pre></td></tr></table></figure><p>这道题和前文的子集问题都不同，这道题是希望我们将数组随便重新排列，并把所有可能重新排列的情况返回。</p><p>此时for循环就不需要使用startIndex了，因为每一次都需要从0开始遍历。比如当前选中了<code>[1,2,3]</code>中的2，还是需要从0开始遍历，加上1，再加上3；为此需要一个used数组来标记数组中哪一个元素已经被使用过了，跳过已经被使用的元素。</p><p>递归的终止条件也很简单，只要当前的curV和nums长度一致，就说明我们找到了一个全排列。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 长度相等代表找到了一个全排列</span></span><br><span class="line"><span class="keyword">if</span> (curV.<span class="built_in">size</span>() == nums.<span class="built_in">size</span>()) &#123;</span><br><span class="line">    retV.<span class="built_in">push_back</span>(curV);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>本质上这道题就是一个暴力破解的过程，用回溯的思路模拟了一层循环。</p><h3 id="完整代码-9"><a href="#完整代码-9" class="headerlink" title="完整代码"></a>完整代码</h3><p>注意，我在主函数中使用resize初始化了used数组，因为需要保证刚开始的时候，所有下标都是false（未被使用）。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; retV;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; curV;</span><br><span class="line">    vector&lt;<span class="type">bool</span>&gt; used;</span><br><span class="line">    <span class="comment">// 因为全排列每次都需要从0开始，所以不需要startIndex</span></span><br><span class="line">    <span class="type">void</span> _permute(vector&lt;<span class="type">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        <span class="comment">// 长度相等代表找到了一个全排列</span></span><br><span class="line">        <span class="keyword">if</span> (curV.<span class="built_in">size</span>() == nums.<span class="built_in">size</span>()) &#123;</span><br><span class="line">            retV.<span class="built_in">push_back</span>(curV);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (used[i] == <span class="literal">true</span>) &#123;</span><br><span class="line">                <span class="keyword">continue</span>; <span class="comment">// 跳过已经被选择了的</span></span><br><span class="line">            &#125;</span><br><span class="line">            curV.<span class="built_in">push_back</span>(nums[i]);</span><br><span class="line">            used[i] = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">            _permute(nums);</span><br><span class="line"></span><br><span class="line">            used[i] = <span class="literal">false</span>;</span><br><span class="line">            curV.<span class="built_in">pop_back</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">permute</span>(vector&lt;<span class="type">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        used.<span class="built_in">resize</span>(nums.<span class="built_in">size</span>(), <span class="literal">false</span>); <span class="comment">// 注意初始化</span></span><br><span class="line">        _permute(nums);</span><br><span class="line">        <span class="keyword">return</span> retV;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/04/7999ae3a336b9c34f97ce1f6dd684b5e.png" alt="image.png"></p><h2 id="47-全排列2"><a href="#47-全排列2" class="headerlink" title="47 全排列2"></a>47 全排列2</h2><blockquote><p><a href="https://leetcode.cn/problems/permutations-ii/">https://leetcode.cn/problems/permutations-ii/</a></p></blockquote><h3 id="题目和思路-11"><a href="#题目和思路-11" class="headerlink" title="题目和思路"></a>题目和思路</h3><p>给定一个<strong>可包含重复数字</strong>的序列 nums ，按任意顺序 返回所有不重复的全排列。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">示例 1：</span><br><span class="line">输入：nums = [1,1,2]</span><br><span class="line">输出：</span><br><span class="line">[[1,1,2],</span><br><span class="line"> [1,2,1],</span><br><span class="line"> [2,1,1]]</span><br><span class="line"> </span><br><span class="line">示例 2：</span><br><span class="line">输入：nums = [1,2,3]</span><br><span class="line">输出：[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]</span><br></pre></td></tr></table></figure><p>这道题和46题的区别在于给定数组内部元素可能重复，不过也不是第一次遇到这样的情况了。</p><blockquote><p>以<code>[1,1,2]</code>为例，从第一个1开始回溯的时候，就可以得到<code>[1,1,2]</code>和<code>[1,2,1]</code>这两个排列。如果不去重，直接走到第二个1时，它还是会得到<code>[1,1,2]</code>和<code>[1,2,1]</code>这两个排列，此时<strong>排列重复</strong>！</p></blockquote><p>因为本题并不在乎子集的顺序，所以我们直接通过<strong>排序</strong>，再加上if判断相邻节点的方式来去重，就可以了。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (i &gt; <span class="number">0</span> &amp;&amp; nums[i] == nums[i - <span class="number">1</span>]) &#123;</span><br><span class="line">    <span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>加了这个代码发现，完全通过不了，输出结果为空，这是为什么呢？</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/04/c16565842d52f6e880e24e67680ceccc.png" alt="image.png"></p><p>以图中的用例<code>[1,1,2]</code>为例，<strong>这里无论什么情况都跳过了第二个1</strong>，第二层的时候也不会使用第二个1（这并不是我们预期的结果），这会导致curV永远无法达到nums的长度，也就没有结果被插入retV数组中。</p><p>正确的去重逻辑应该是：如果上一位被选用过且上一位的值和当前相同，那么就跳过当前位。在if判断中新增一个条件就可以了。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 跳过相同的（前提是上一位已经被选择过了）</span></span><br><span class="line"><span class="keyword">if</span> (i &gt; <span class="number">0</span> &amp;&amp; nums[i] == nums[i - <span class="number">1</span>] &amp;&amp; used[i - <span class="number">1</span>] == <span class="literal">false</span>) &#123;</span><br><span class="line">    <span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意，这里需要判断的是<code>used[i - 1] == false</code>而不是为true的情况，因为在回溯过程中，我们会先把<code>used[i]</code>设置为true，然后又重置为false。在同一层里面，其实不会出现<code>used[i-1]==true</code>的情况（已经被回溯undo了）</p><p>既然不会出现<code>used[i-1]==true</code>的情况，为什么还需添加这个判断条件呢？原因前文已经提到过，如果删除这个判断，那么就会导致去重变成了<strong>多层之间都不会选择相同的数</strong>，这是不符合题目逻辑的！</p><blockquote><p>在代码随想录上有关于这个去重逻辑更详细的解释：<a href="https://www.programmercarl.com/0047.%E5%85%A8%E6%8E%92%E5%88%97II.html#%E6%8B%93%E5%B1%95">点我查看</a></p></blockquote><p>当然，因为去重是基于同一层的，那么完全可以使用<code>unordered_set</code>来去重，效果也是一样的。不过使用set也不能去掉used数组，那还不如直接通过used数组来去重，效率更高。</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/04/0d2a0de90ba7a27ed5797404fac82a53.png" alt="image.png"></p><p>注意，每一层递归都额外定义一个<code>unordered_set</code>会让整体空间复杂度由<code>O(N)</code>变成<code>O(N^2)</code>，所以除非必须的时候，不额外定义set才是更好的做法。</p><h3 id="完整代码-10"><a href="#完整代码-10" class="headerlink" title="完整代码"></a>完整代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; retV;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; curV;</span><br><span class="line">    vector&lt;<span class="type">bool</span>&gt; used;</span><br><span class="line">    <span class="comment">// 同样每一次都是从0开始，但是需要跳过单层已经被选择过的元素</span></span><br><span class="line">    <span class="type">void</span> _permuteUnique(vector&lt;<span class="type">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        <span class="comment">// 长度相等代表找到了一个全排列</span></span><br><span class="line">        <span class="keyword">if</span> (curV.<span class="built_in">size</span>() == nums.<span class="built_in">size</span>()) &#123;</span><br><span class="line">            retV.<span class="built_in">push_back</span>(curV);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="comment">// 跳过相同的（前提是同层上一位已经被选择过了）</span></span><br><span class="line">            <span class="keyword">if</span> (i &gt; <span class="number">0</span> &amp;&amp; nums[i] == nums[i - <span class="number">1</span>] &amp;&amp; used[i - <span class="number">1</span>] == <span class="literal">false</span>) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 正常情况下也需要跳过被选用了的</span></span><br><span class="line">            <span class="keyword">if</span> (used[i] == <span class="literal">true</span>) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            curV.<span class="built_in">push_back</span>(nums[i]);</span><br><span class="line">            used[i] = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">            _permuteUnique(nums);</span><br><span class="line"></span><br><span class="line">            used[i] = <span class="literal">false</span>;</span><br><span class="line">            curV.<span class="built_in">pop_back</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">permuteUnique</span>(vector&lt;<span class="type">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        used.<span class="built_in">resize</span>(nums.<span class="built_in">size</span>(), <span class="literal">false</span>);</span><br><span class="line">        <span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>());</span><br><span class="line"></span><br><span class="line">        _permuteUnique(nums);</span><br><span class="line">        <span class="keyword">return</span> retV;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/04/159a19cdeb90bc479b14da8d8d0d4142.png" alt="image.png"></p><h1 id="6-其他问题"><a href="#6-其他问题" class="headerlink" title="6.其他问题"></a>6.其他问题</h1><h2 id="332-重新安排行程"><a href="#332-重新安排行程" class="headerlink" title="332 重新安排行程"></a>332 重新安排行程</h2><blockquote><p><a href="https://leetcode.cn/problems/reconstruct-itinerary/description/">https://leetcode.cn/problems/reconstruct-itinerary/description/</a></p></blockquote><h3 id="题目和思路-12"><a href="#题目和思路-12" class="headerlink" title="题目和思路"></a>题目和思路</h3><p>给你一份航线列表 tickets ，其中 <code>tickets[i] = [fromi, toi]</code> 表示飞机出发和降落的机场地点。请你对该行程进行重新规划排序。</p><ul><li>所有这些机票都属于一个从 JFK（肯尼迪国际机场）出发的先生，所以该行程必须从 JFK 开始。如果存在多种有效的行程，请你按<strong>字典排序</strong>返回最小的行程组合。</li></ul><p>例如，行程 <code>[&quot;JFK&quot;, &quot;LGA&quot;]</code> 与 <code>[&quot;JFK&quot;, &quot;LGB&quot;]</code> 相比就更小，排序更靠前。</p><p>假定所有机票至少存在一种合理的行程。且所有的机票 必须都用一次 且 只能用一次。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">示例1：</span><br><span class="line">输入：tickets = [[&quot;MUC&quot;,&quot;LHR&quot;],[&quot;JFK&quot;,&quot;MUC&quot;],[&quot;SFO&quot;,&quot;SJC&quot;],[&quot;LHR&quot;,&quot;SFO&quot;]]</span><br><span class="line">输出：[&quot;JFK&quot;,&quot;MUC&quot;,&quot;LHR&quot;,&quot;SFO&quot;,&quot;SJC&quot;]</span><br><span class="line"></span><br><span class="line">示例2：</span><br><span class="line">输入：tickets = [[&quot;JFK&quot;,&quot;SFO&quot;],[&quot;JFK&quot;,&quot;ATL&quot;],[&quot;SFO&quot;,&quot;ATL&quot;],[&quot;ATL&quot;,&quot;JFK&quot;],[&quot;ATL&quot;,&quot;SFO&quot;]]</span><br><span class="line">输出：[&quot;JFK&quot;,&quot;ATL&quot;,&quot;JFK&quot;,&quot;SFO&quot;,&quot;ATL&quot;,&quot;SFO&quot;]</span><br><span class="line">解释：另一种有效的行程是 [&quot;JFK&quot;,&quot;SFO&quot;,&quot;ATL&quot;,&quot;JFK&quot;,&quot;ATL&quot;,&quot;SFO&quot;] ，但是它字典排序更大更靠后。</span><br></pre></td></tr></table></figure><p>提示</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1 &lt;= tickets.length &lt;= 300</span><br><span class="line">tickets[i].length == 2</span><br><span class="line">fromi.length == 3</span><br><span class="line">toi.length == 3</span><br><span class="line">fromi 和 toi 由大写英文字母组成</span><br><span class="line">fromi != toi</span><br></pre></td></tr></table></figure><p>这道题其实更偏向于图论的深搜（还没学），但是它也可以通过回溯的思想来解决。</p><p>首先需要确定如何记录机票，最好的办法自然是用一个unordered_map来记录起始机场和目的机场的关系，且目的机场使用multiset而不是unordered_set，可以自然实现字典排序（set&#x2F;map基于红黑树，是有序的）。使用multiset是为了避免<strong>有多张从A到B</strong>的机票的情况，此时目的地会重复出现。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 起始机场,目的机场集合</span></span><br><span class="line">unordered_map&lt;string,multiset&lt;string&gt;&gt; ticketsMap;</span><br></pre></td></tr></table></figure><p>记录了之后，就可以实现回溯的单层遍历了。这里还需要一个计数器来整体记录当前选了多少个机票，机票数量够了就可以return了。</p><ul><li>参数startAp记录起始机场；</li><li>遍历起始机场的目的地集合<code>ticketsMap[startAp]</code>，每次选择一个，继续往下递归；<ul><li>递归之前需要将选择的目的机场从set中删除，并插入retV返回值数组；</li><li>递归结束之后将选择的目的机场重新插入set，并从retV返回值数组中删除；</li></ul></li><li>当遍历到某个机场的目的地集合为空的时候，说明走到了叶子节点，返回；</li><li>当当前已经选择机票达到上限（注意每个机票必须且只能使用一次），返回；</li></ul><p>这里就出现了一个问题：因为我们需要从set中删除数据，但删除的同时我们又需要继续遍历set，这便是一个经典的<code>迭代器失效</code>问题。因为set是基于红黑树的，当前节点被删除后，它就和其他节点没有链接关系了，迭代器无法继续往下走。不过我们可以先获取下一个迭代器的值，再删除，但那样对于for循环而言就有些麻烦了。</p><p>所以，我们可以将multiset改成另外一个map，用计数器来替代删除。当计数器为0的时候，可以认为这个机票已经不可用了（等价于被删除）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// &lt;起始机场,&lt;目的机场,票数&gt;&gt;</span></span><br><span class="line">unordered_map&lt;string,map&lt;string,<span class="type">int</span>&gt;&gt; ticketsMap;</span><br></pre></td></tr></table></figure><p>用下面的循环对这个map进行初始化</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span>&amp; v : tickets) &#123;</span><br><span class="line">ticketsMap[v[<span class="number">0</span>]][v[<span class="number">1</span>]]++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样，每一层for的时候，直接将对应票数减一即可。循环的时候跳过票数为0的机场即可。当一个机场的所有目的地机票都为0，则说明这个机场不能继续往下飞了。</p><h3 id="错误代码-1"><a href="#错误代码-1" class="headerlink" title="错误代码"></a>错误代码</h3><p>根据上面的思路，可以写出这样的第一版代码。注意代码中<strong>范围循环</strong>中auto一定要写引用<code>auto&amp;</code>，因为我们需要通过<code>p.second</code>直接修改ticket的计数器。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    vector&lt;string&gt; retV;</span><br><span class="line">    <span class="comment">// 判断是否所有机票都用完了</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">checkTicketsEmpty</span><span class="params">(map&lt;string, <span class="type">int</span>&gt;&amp; tickets)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; p : tickets) &#123;</span><br><span class="line">            <span class="keyword">if</span> (p.second != <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 回溯法，每一次都找一个机场走，注意起点机场是JFK</span></span><br><span class="line">    <span class="comment">// ticketSum是总共的机票数量，ticketNum是当前已经被使用过的机票数量</span></span><br><span class="line">    <span class="type">void</span> _findItinerary(unordered_map&lt;string, map&lt;string, <span class="type">int</span>&gt;&gt;&amp; ticketsMap,</span><br><span class="line">                        <span class="type">const</span> <span class="type">int</span> ticketsSum, <span class="type">int</span> ticketsNum,</span><br><span class="line">                        <span class="type">const</span> string&amp; startAp) &#123;</span><br><span class="line">        <span class="comment">// 如果ticket被用完了，也可以返回</span></span><br><span class="line">        <span class="keyword">if</span> (ticketsNum == ticketsSum) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果map里面对应的目的机场机票都用完了，这一层没有办法往下走了</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">checkTicketsEmpty</span>(ticketsMap[startAp])) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果不是，随机选择一个机场往下走</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; p : ticketsMap[startAp]) &#123;</span><br><span class="line">            <span class="comment">// 跳过已经选择了的机场</span></span><br><span class="line">            <span class="keyword">if</span> (p.second == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 没有选择过，可以走</span></span><br><span class="line">            retV.<span class="built_in">push_back</span>(p.first);</span><br><span class="line">            p.second--;   <span class="comment">// 机票数量减一</span></span><br><span class="line">            ticketsNum++; <span class="comment">// 已选机票数量加一</span></span><br><span class="line">            cout &lt;&lt; startAp &lt;&lt; <span class="string">&quot;-&gt;&quot;</span> &lt;&lt; p.first &lt;&lt; <span class="string">&quot;:&quot;</span> &lt;&lt; p.second</span><br><span class="line">                 &lt;&lt; <span class="string">&quot; num:&quot;</span> &lt;&lt; ticketsNum &lt;&lt; endl;</span><br><span class="line">            _findItinerary(ticketsMap, ticketsSum, ticketsNum, p.first);</span><br><span class="line">            <span class="comment">// 回溯操作</span></span><br><span class="line">            p.second++;</span><br><span class="line">            ticketsNum--;</span><br><span class="line">            retV.<span class="built_in">pop_back</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;string&gt; <span class="title">findItinerary</span><span class="params">(vector&lt;vector&lt;string&gt;&gt;&amp; tickets)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 存放&lt;起点机场,&lt;目的机场,票数&gt;&gt;</span></span><br><span class="line">        <span class="comment">// 两个机场之间单向只会有一个票，所以不需要用multimap</span></span><br><span class="line">        unordered_map&lt;string, map&lt;string, <span class="type">int</span>&gt;&gt; ticketsMap;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; v : tickets) &#123;</span><br><span class="line">            ticketsMap[v[<span class="number">0</span>]][v[<span class="number">1</span>]]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 因为是从JFK开始的，所以需要先把第一个值插入</span></span><br><span class="line">        retV.<span class="built_in">push_back</span>(<span class="string">&quot;JFK&quot;</span>);</span><br><span class="line">        _findItinerary(ticketsMap, tickets.<span class="built_in">size</span>(), <span class="number">0</span>, <span class="string">&quot;JFK&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> retV;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>但是这一版代码有问题，会发现结果集里面只有JFK被插入了</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/04/da1d1929064a8726263cbe4a56fad97e.png" alt="image.png"></p><p>这是因为当前用例中，for循环内并没有进行条件判断，这就导致retV一直在被<code>插入-&gt;递归-&gt;删除</code>，最终retV里面的值还是空的。</p><p>添加一个cout打印，可以看到如下输出，其中ticketsNum已经打印到4了，说明我们期待的结果起始已经出现了，但因为回溯的<code>pop_back</code>又被删除了。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">JFK-&gt;MUC:0 num:1</span><br><span class="line">MUC-&gt;LHR:0 num:2</span><br><span class="line">LHR-&gt;SFO:0 num:3</span><br><span class="line">SFO-&gt;SJC:0 num:4</span><br></pre></td></tr></table></figure><p>所以，我们需要在for循环中添加一个判断，当当前递归的返回值retV已经符合条件的时候，直接跳过pop_back回溯步骤，提前返回。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">_findItinerary(ticketsMap, ticketsSum, ticketsNum, p.first);</span><br><span class="line">         <span class="comment">// 符合条件了，直接跳出</span></span><br><span class="line">         <span class="keyword">if</span> (retV.<span class="built_in">size</span>() == ticketsSum) &#123;</span><br><span class="line">             <span class="keyword">return</span>;</span><br><span class="line">         &#125;</span><br></pre></td></tr></table></figure><p>这里的判断是错误的，因为传入的ticketsSum是机票的总数量，而retV中的结果集是存放路途中经过地点的，经过的地点应该比机票数量多一张！</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 符合条件了，直接跳出，地点比机票数量多一个</span></span><br><span class="line"><span class="keyword">if</span> (retV.<span class="built_in">size</span>() == ticketsSum+<span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="完整代码-11"><a href="#完整代码-11" class="headerlink" title="完整代码"></a>完整代码</h3><p>下面是正确的代码</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    vector&lt;string&gt; retV;</span><br><span class="line">    <span class="comment">// 判断是否所有机票都用完了</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">checkTicketsEmpty</span><span class="params">(map&lt;string, <span class="type">int</span>&gt;&amp; tickets)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; p : tickets) &#123;</span><br><span class="line">            <span class="keyword">if</span> (p.second != <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 回溯法，每一次都找一个机场走，注意起点机场是JFK</span></span><br><span class="line">    <span class="comment">// ticketSum是总共的机票数量，ticketNum是当前已经被使用过的机票数量</span></span><br><span class="line">    <span class="type">void</span> _findItinerary(unordered_map&lt;string, map&lt;string, <span class="type">int</span>&gt;&gt;&amp; ticketsMap,</span><br><span class="line">                        <span class="type">const</span> <span class="type">int</span> ticketsSum, <span class="type">int</span> ticketsNum,</span><br><span class="line">                        <span class="type">const</span> string&amp; startAp) &#123;</span><br><span class="line">        <span class="comment">// 如果ticket被用完了，也可以返回</span></span><br><span class="line">        <span class="keyword">if</span> (ticketsNum == ticketsSum) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果map里面对应的目的机场机票都用完了，这一层没有办法往下走了</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">checkTicketsEmpty</span>(ticketsMap[startAp])) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果不是，随机选择一个机场往下走</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; p : ticketsMap[startAp]) &#123;</span><br><span class="line">            <span class="comment">// 跳过已经选择了的机场</span></span><br><span class="line">            <span class="keyword">if</span> (p.second == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 没有选择过，可以走</span></span><br><span class="line">            retV.<span class="built_in">push_back</span>(p.first);</span><br><span class="line">            p.second--;   <span class="comment">// 机票数量减一</span></span><br><span class="line">            ticketsNum++; <span class="comment">// 已选机票数量加一</span></span><br><span class="line">            <span class="comment">// cout &lt;&lt; startAp &lt;&lt; &quot;-&gt;&quot; &lt;&lt; p.first &lt;&lt; &quot;:&quot; &lt;&lt; p.second</span></span><br><span class="line">            <span class="comment">//      &lt;&lt; &quot; num:&quot; &lt;&lt; ticketsNum &lt;&lt; endl;</span></span><br><span class="line">            _findItinerary(ticketsMap, ticketsSum, ticketsNum, p.first);</span><br><span class="line">            <span class="comment">// 符合条件了，直接跳出，地点比机票数量多一个</span></span><br><span class="line">            <span class="keyword">if</span> (retV.<span class="built_in">size</span>() == ticketsSum + <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 回溯操作</span></span><br><span class="line">            p.second++;</span><br><span class="line">            ticketsNum--;</span><br><span class="line">            retV.<span class="built_in">pop_back</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;string&gt; <span class="title">findItinerary</span><span class="params">(vector&lt;vector&lt;string&gt;&gt;&amp; tickets)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 存放&lt;起点机场,&lt;目的机场,票数&gt;&gt;</span></span><br><span class="line">        <span class="comment">// 两个机场之间单向只会有一个票，所以不需要用multimap</span></span><br><span class="line">        unordered_map&lt;string, map&lt;string, <span class="type">int</span>&gt;&gt; ticketsMap;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; v : tickets) &#123;</span><br><span class="line">            ticketsMap[v[<span class="number">0</span>]][v[<span class="number">1</span>]]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 因为是从JFK开始的，所以需要先把第一个值插入</span></span><br><span class="line">        retV.<span class="built_in">push_back</span>(<span class="string">&quot;JFK&quot;</span>);</span><br><span class="line">        _findItinerary(ticketsMap, tickets.<span class="built_in">size</span>(), <span class="number">0</span>, <span class="string">&quot;JFK&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> retV;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/04/ddda44cea08f7d0f079120b8fa5efe7f.png" alt="image.png"></p><p>这个代码还有可优化之处，比如<code>checkTicketsEmpty</code>函数中做的判断就没有意义了，因为for循环中本来也会判断票数是否为0。加上这个函数会让每一层递归的时间复杂度多一个<code>O(N)</code>。把它删除，代码也能通过。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    vector&lt;string&gt; retV;</span><br><span class="line">    <span class="comment">// 回溯法，每一次都找一个机场走，注意起点机场是JFK</span></span><br><span class="line">    <span class="comment">// ticketSum是总共的机票数量，ticketNum是当前已经被使用过的机票数量</span></span><br><span class="line">    <span class="type">void</span> _findItinerary(unordered_map&lt;string, map&lt;string, <span class="type">int</span>&gt;&gt;&amp; ticketsMap,</span><br><span class="line">                        <span class="type">const</span> <span class="type">int</span> ticketsSum, <span class="type">int</span> ticketsNum,</span><br><span class="line">                        <span class="type">const</span> string&amp; startAp) &#123;</span><br><span class="line">        <span class="comment">// 如果ticket被用完了，也可以返回</span></span><br><span class="line">        <span class="keyword">if</span> (ticketsNum == ticketsSum) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果不是，随机选择一个机场往下走</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; p : ticketsMap[startAp]) &#123;</span><br><span class="line">            <span class="comment">// 跳过已经选择了的机场</span></span><br><span class="line">            <span class="keyword">if</span> (p.second == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 没有选择过，可以走</span></span><br><span class="line">            retV.<span class="built_in">push_back</span>(p.first);</span><br><span class="line">            p.second--;   <span class="comment">// 机票数量减一</span></span><br><span class="line">            ticketsNum++; <span class="comment">// 已选机票数量加一</span></span><br><span class="line"><span class="comment">// 递归下一层</span></span><br><span class="line">            _findItinerary(ticketsMap, ticketsSum, ticketsNum, p.first);</span><br><span class="line">            <span class="comment">// 符合条件了，直接跳出，地点数量比机票数量多一个</span></span><br><span class="line">            <span class="keyword">if</span> (retV.<span class="built_in">size</span>() == ticketsSum + <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 回溯操作</span></span><br><span class="line">            p.second++;</span><br><span class="line">            ticketsNum--;</span><br><span class="line">            retV.<span class="built_in">pop_back</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;string&gt; <span class="title">findItinerary</span><span class="params">(vector&lt;vector&lt;string&gt;&gt;&amp; tickets)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 存放&lt;起点机场,&lt;目的机场,票数&gt;&gt;</span></span><br><span class="line">        <span class="comment">// 两个机场之间单向只会有一个票，所以不需要用multimap</span></span><br><span class="line">        unordered_map&lt;string, map&lt;string, <span class="type">int</span>&gt;&gt; ticketsMap;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; v : tickets) &#123;</span><br><span class="line">            ticketsMap[v[<span class="number">0</span>]][v[<span class="number">1</span>]]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 因为是从JFK开始的，所以需要先把第一个值插入</span></span><br><span class="line">        retV.<span class="built_in">push_back</span>(<span class="string">&quot;JFK&quot;</span>);</span><br><span class="line">        _findItinerary(ticketsMap, tickets.<span class="built_in">size</span>(), <span class="number">0</span>, <span class="string">&quot;JFK&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> retV;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>耗时也变短了（虽然这个耗时没有参考价值）。</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/04/9532e24a5566b8086b9d11f7d70c9b70.png" alt="image.png"></p><h3 id="代码随想录版本"><a href="#代码随想录版本" class="headerlink" title="代码随想录版本"></a>代码随想录版本</h3><p>下面的代码是《代码随想录》上的版本，大佬将递归函数的返回值改成了bool，以此来标识是否符合条件，true代表可以提前退出。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="comment">// unordered_map&lt;出发机场, map&lt;到达机场, 航班次数&gt;&gt; targets</span></span><br><span class="line">unordered_map&lt;string, map&lt;string, <span class="type">int</span>&gt;&gt; targets;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">backtracking</span><span class="params">(<span class="type">int</span> ticketNum, vector&lt;string&gt;&amp; result)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (result.<span class="built_in">size</span>() == ticketNum + <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (pair&lt;<span class="type">const</span> string, <span class="type">int</span>&gt;&amp; target : targets[result[result.<span class="built_in">size</span>() - <span class="number">1</span>]]) &#123;</span><br><span class="line">        <span class="keyword">if</span> (target.second &gt; <span class="number">0</span> ) &#123; <span class="comment">// 记录到达机场是否飞过了</span></span><br><span class="line">            result.<span class="built_in">push_back</span>(target.first);</span><br><span class="line">            target.second--;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">backtracking</span>(ticketNum, result)) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            result.<span class="built_in">pop_back</span>();</span><br><span class="line">            target.second++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;string&gt; <span class="title">findItinerary</span><span class="params">(vector&lt;vector&lt;string&gt;&gt;&amp; tickets)</span> </span>&#123;</span><br><span class="line">        targets.<span class="built_in">clear</span>();</span><br><span class="line">        vector&lt;string&gt; result;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">const</span> vector&lt;string&gt;&amp; vec : tickets) &#123;</span><br><span class="line">            targets[vec[<span class="number">0</span>]][vec[<span class="number">1</span>]]++; <span class="comment">// 记录映射关系</span></span><br><span class="line">        &#125;</span><br><span class="line">        result.<span class="built_in">push_back</span>(<span class="string">&quot;JFK&quot;</span>); <span class="comment">// 起始机场</span></span><br><span class="line">        <span class="built_in">backtracking</span>(tickets.<span class="built_in">size</span>(), result);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="51-N皇后"><a href="#51-N皇后" class="headerlink" title="51 N皇后"></a>51 N皇后</h2><blockquote><p><a href="https://leetcode.cn/problems/n-queens/description/">https://leetcode.cn/problems/n-queens/description/</a></p></blockquote><h3 id="题目和思路-13"><a href="#题目和思路-13" class="headerlink" title="题目和思路"></a>题目和思路</h3><p>按照国际象棋的规则，皇后可以攻击与之处在同一行或同一列或同一斜线上的棋子。</p><p>n 皇后问题 研究的是如何将 n 个皇后放置在 n×n 的棋盘上，并且使皇后彼此之间不能相互攻击。</p><p>给你一个整数 n ，返回所有不同的 n 皇后问题 的解决方案。</p><p>每一种解法包含一个不同的 n 皇后问题 的棋子放置方案，该方案中 ‘Q’ 和 ‘.’ 分别代表了皇后和空位。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">示例 1：</span><br><span class="line">输入：n = 4</span><br><span class="line">输出：[[&quot;.Q..&quot;,&quot;...Q&quot;,&quot;Q...&quot;,&quot;..Q.&quot;],[&quot;..Q.&quot;,&quot;Q...&quot;,&quot;...Q&quot;,&quot;.Q..&quot;]]</span><br><span class="line">解释：如上图所示，4 皇后问题存在两个不同的解法。</span><br><span class="line"></span><br><span class="line">示例 2：</span><br><span class="line">输入：n = 1</span><br><span class="line">输出：[[&quot;Q&quot;]]</span><br></pre></td></tr></table></figure><p>这道题是回溯的经典题目：</p><ul><li>回溯每一层模拟每一列的遍历（横向）</li><li>多层递归模拟每一行行的遍历（纵向）</li></ul><p>整体的思路如下：</p><ul><li>每一层的for在当前行选择一个位置设置为Q</li><li>判断该位置是否符合N皇后的条件</li><li>符合，递归下一层，行号加一</li><li>当行号等于N时，代表越界，插入结果集并终止递归。</li></ul><p>主要是写出判断每一层是否符合皇后占位的代码，回溯的思路不难。</p><ul><li>皇后所在的行和列，斜线上都不能有其他皇后。</li></ul><p>对于我们的回溯而言，因为每一层都是for在当前行选择一个作为皇后，所以同行不会有多个皇后，不需要判断当前行。</p><p>而回溯的每一层是模拟从上往下的纵向遍历，所以纵向上也只需要判断<strong>当前列</strong>在当前行之前是否有其他皇后（当前行之后都还没有被操作）。</p><p>其次就是斜线上的判断了，这里主要涉及到行和列下标如何操作，注意我们是从当前位置沿着斜线往上遍历</p><ul><li>135°斜线（右上到左下）：行号和列号每次都减一；</li><li>45°斜线（左下到右上）：行号减一，列号加一；</li></ul><p>如下就是判断当前位置是否可以放皇后的代码。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">checkQueen</span><span class="params">(<span class="type">const</span> vector&lt;string&gt;&amp; curV, <span class="type">int</span> n, <span class="type">int</span> row, <span class="type">int</span> col)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 因为在回溯每一层的时候都只会选择一行进行处理，一行只会有一个Q，不需要遍历</span></span><br><span class="line">    <span class="comment">// 遍历列（这里小于row就行了，因为回溯才走到这里，更大的行是没有数据的）</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; row; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (curV[i][col] == <span class="string">&#x27;Q&#x27;</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 遍历右边斜线（从右上到左下的斜线,135°）</span></span><br><span class="line">    <span class="comment">// 减一开始往回遍历</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = row - <span class="number">1</span>, j = col - <span class="number">1</span>; i &gt;= <span class="number">0</span> &amp;&amp; j &gt;= <span class="number">0</span>; i--, j--) &#123;</span><br><span class="line">        <span class="keyword">if</span> (curV[i][j] == <span class="string">&#x27;Q&#x27;</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 遍历左边斜线，45°</span></span><br><span class="line">    <span class="comment">// 这里应该是列加一行减一，然后每一次都是行减一列加一</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = row - <span class="number">1</span>, j = col + <span class="number">1</span>; i &gt;= <span class="number">0</span> &amp;&amp; j &lt; n; i--, j++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (curV[i][j] == <span class="string">&#x27;Q&#x27;</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="错误代码-2"><a href="#错误代码-2" class="headerlink" title="错误代码"></a>错误代码</h3><p>刚开始我写出了这样的代码</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> col = <span class="number">0</span>; col &lt; n; col++) &#123;</span><br><span class="line">          <span class="comment">// 判断是否符合条件，不符合直接返回</span></span><br><span class="line">          <span class="keyword">if</span> (<span class="built_in">checkQueen</span>(curV, n, row, col) == <span class="literal">false</span>) &#123;</span><br><span class="line">              <span class="keyword">continue</span>; <span class="comment">// 后面可能有符合条件的，不能return</span></span><br><span class="line">          &#125;</span><br><span class="line">          curV[row][col] = <span class="string">&#x27;Q&#x27;</span>; <span class="comment">// 假设为皇后</span></span><br><span class="line">          row++;                <span class="comment">// 下一行</span></span><br><span class="line">          <span class="comment">// 递归</span></span><br><span class="line">          _solveNQueens(n, row, curV);</span><br><span class="line">          <span class="comment">// 回溯</span></span><br><span class="line">          curV[row][col] = <span class="string">&#x27;.&#x27;</span>; <span class="comment">// 重置</span></span><br><span class="line">          row--; </span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure><p>但是提交发现retV始终为空，想不明白为什么。最终加了一堆打印之后，发现了问题所在。如下所示，这是正确的一个结果集内的回溯过程，选中了<code>(0,1)</code>和<code>(1,3)</code>后，理论上<code>(2,0)</code>应该要被选中，但是<code>(2,0)</code>在判断中却因为<code>(0,0)</code>处是Q而退出了。打印出第0行的字符串，发现这里就有两个Q，很明显是第一波的操作没有被成功回溯。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">good: 0 1</span><br><span class="line">1 0</span><br><span class="line">1 1</span><br><span class="line">1 2</span><br><span class="line">1 3</span><br><span class="line">good: 1 3</span><br><span class="line">2 0</span><br><span class="line">2,0 exit here1： 0 0</span><br><span class="line">string: QQ..</span><br></pre></td></tr></table></figure><p>检查回溯部分的代码，会发现这两行有问题</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 回溯</span></span><br><span class="line">curV[row][col] = <span class="string">&#x27;.&#x27;</span>; <span class="comment">// 重置</span></span><br><span class="line">row--; </span><br></pre></td></tr></table></figure><p>在调用递归函数之前，将row++了，此时回溯却先重置点再row–，问题就出现了：被重置的是下一行的col位置，和当前应该回溯的不是同一个位置！<strong>正确代码是先修复row再重置数组中的值</strong>！</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 回溯</span></span><br><span class="line">row--; </span><br><span class="line">curV[row][col] = <span class="string">&#x27;.&#x27;</span>; <span class="comment">// 重置</span></span><br><span class="line"><span class="comment">// row--; // error，应该先减减再重置数组中的值</span></span><br></pre></td></tr></table></figure><h3 id="完整代码-12"><a href="#完整代码-12" class="headerlink" title="完整代码"></a>完整代码</h3><p>正确的代码如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    vector&lt;vector&lt;string&gt;&gt; retV;</span><br><span class="line">    <span class="comment">// n是皇后数量（同时也是棋盘的边长），row是行号</span></span><br><span class="line">    <span class="type">void</span> _solveNQueens(<span class="type">int</span> n, <span class="type">int</span> row, vector&lt;string&gt;&amp; curV) &#123;</span><br><span class="line">        <span class="comment">// 行号是下标，当下标row等于n的时候代表越界，找到了一个解</span></span><br><span class="line">        <span class="keyword">if</span> (n == row) &#123;</span><br><span class="line">            retV.<span class="built_in">push_back</span>(curV);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 列号，每一位都尝试使用</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> col = <span class="number">0</span>; col &lt; n; col++) &#123;</span><br><span class="line">            <span class="comment">// 判断是否符合条件，不符合直接返回</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">checkQueen</span>(curV, n, row, col) == <span class="literal">false</span>) &#123;</span><br><span class="line">                <span class="keyword">continue</span>; <span class="comment">// 后面可能有符合条件的，不能return</span></span><br><span class="line">            &#125;</span><br><span class="line">            curV[row][col] = <span class="string">&#x27;Q&#x27;</span>; <span class="comment">// 假设为皇后</span></span><br><span class="line">            row++;                <span class="comment">// 下一行</span></span><br><span class="line">            <span class="comment">// 递归</span></span><br><span class="line">            _solveNQueens(n, row, curV);</span><br><span class="line">            <span class="comment">// 回溯</span></span><br><span class="line">            row--;</span><br><span class="line">            curV[row][col] = <span class="string">&#x27;.&#x27;</span>; <span class="comment">// 重置</span></span><br><span class="line">            <span class="comment">// row--; // error，应该先减减再重置数组中的值</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 注意，每一次选择都需要做检查，判断同一行，同一列，斜线上是否有其他皇后</span></span><br><span class="line">    <span class="comment">// 入参是当前插入皇后的位置</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">checkQueen</span><span class="params">(<span class="type">const</span> vector&lt;string&gt;&amp; curV, <span class="type">int</span> n, <span class="type">int</span> row, <span class="type">int</span> col)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 因为在回溯每一层的时候都只会选择一行进行处理，一行只会有一个Q，不需要遍历</span></span><br><span class="line">        <span class="comment">// 遍历列（这里小于row就行了，因为回溯才走到这里，更大的行是没有数据的）</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; row; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (curV[i][col] == <span class="string">&#x27;Q&#x27;</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 遍历右边斜线（从右上到左下的斜线,135°）</span></span><br><span class="line">        <span class="comment">// 减一开始往回遍历</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = row - <span class="number">1</span>, j = col - <span class="number">1</span>; i &gt;= <span class="number">0</span> &amp;&amp; j &gt;= <span class="number">0</span>; i--, j--) &#123;</span><br><span class="line">            <span class="keyword">if</span> (curV[i][j] == <span class="string">&#x27;Q&#x27;</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 遍历左边斜线，45°</span></span><br><span class="line">        <span class="comment">// 这里应该是列加一行减一，然后每一次都是行减一列加一</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = row - <span class="number">1</span>, j = col + <span class="number">1</span>; i &gt;= <span class="number">0</span> &amp;&amp; j &lt; n; i--, j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (curV[i][j] == <span class="string">&#x27;Q&#x27;</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;string&gt;&gt; <span class="built_in">solveNQueens</span>(<span class="type">int</span> n) &#123;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">1</span>) &#123;</span><br><span class="line">            retV.<span class="built_in">push_back</span>(vector&lt;string&gt;&#123;<span class="string">&quot;Q&quot;</span>&#125;);</span><br><span class="line">            <span class="keyword">return</span> retV;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 注意vector需要初始化，不然没有办法直接下标操作</span></span><br><span class="line">        <span class="function">vector&lt;string&gt; <span class="title">curV</span><span class="params">(n, string(n, <span class="string">&#x27;.&#x27;</span>))</span></span>;</span><br><span class="line">        _solveNQueens(n, <span class="number">0</span>, curV);</span><br><span class="line">        <span class="keyword">return</span> retV;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/04/8ce3959a7b61554f8450dfbe341bb492.png" alt="image.png"></p>]]></content>
    
    
    <summary type="html">学习回溯算法并练习</summary>
    
    
    
    <category term="编程学习" scheme="https://blog.musnow.top/categories/%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="把题目都给刷干净" scheme="https://blog.musnow.top/categories/%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0/%E6%8A%8A%E9%A2%98%E7%9B%AE%E9%83%BD%E7%BB%99%E5%88%B7%E5%B9%B2%E5%87%80/"/>
    
    
    <category term="算法" scheme="https://blog.musnow.top/tags/%E7%AE%97%E6%B3%95/"/>
    
    <category term="Cpp" scheme="https://blog.musnow.top/tags/Cpp/"/>
    
    <category term="回溯" scheme="https://blog.musnow.top/tags/%E5%9B%9E%E6%BA%AF/"/>
    
  </entry>
  
</feed>
