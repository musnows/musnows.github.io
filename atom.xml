<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>慕雪的寒舍</title>
  
  <subtitle>雪下了一夜</subtitle>
  <link href="https://blog.musnow.top/atom.xml" rel="self"/>
  
  <link href="https://blog.musnow.top/"/>
  <updated>2023-12-18T08:52:00.000Z</updated>
  <id>https://blog.musnow.top/</id>
  
  <author>
    <name>慕雪年华</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>【Python】Python实现文件分片加密和上传（未实现）</title>
    <link href="https://blog.musnow.top/posts/621478472/"/>
    <id>https://blog.musnow.top/posts/621478472/</id>
    <published>2023-12-18T08:52:00.000Z</published>
    <updated>2023-12-18T08:52:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h1><blockquote><p>项目地址：<a href="https://github.com/musnows/encrypt2bdy">musnows&#x2F;encrypt2bdy</a></p></blockquote><p>之前写的一篇博客提到了我的encrypt2bdy项目中，文件直接整个被读取到内存里面再计算md5，导致内存占用巨大的问题。后续解决方法是用分片的方式挨个读取文件块并计算md5。</p><p>但光是修改md5计算方式还不够，因为项目中还涉及到<strong>上传加密后文件</strong>的问题，且听我细细道来👇</p><h1 id="关于文件加密库"><a href="#关于文件加密库" class="headerlink" title="关于文件加密库"></a>关于文件加密库</h1><h2 id="cryptography-fernet"><a href="#cryptography-fernet" class="headerlink" title="cryptography.fernet"></a>cryptography.fernet</h2><p>我的加密解密操作使用的是Fernet这个库，它会创建一个密钥文件，并借密钥文件对字节流进行加密和解密操作。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">from cryptography.fernet import Fernet</span><br></pre></td></tr></table></figure><p>但是，Fernet框架不适合<strong>进行分片加密和解密</strong>。在我的尝试中，分片加密文件是可以的，但是<strong>解密</strong>的时候会因为密钥对不上而出现异常。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cryptography.fernet.InvalidToken – If the token is in any way invalid, this exception is raised. A token may be invalid for a number of reasons: it is older than the ttl, it is malformed, or it does not have a valid signature.</span><br></pre></td></tr></table></figure><p><a href="https://cryptography.io/en/latest/fernet/">官方文档</a>里面提到了，Fernet只适合用于能<strong>完全加载到内存</strong>里面的数据，不适合用于处理大文件。</p><blockquote><p>Limitations:<br>Fernet is ideal for encrypting data that easily fits in memory. As a design feature it does not expose unauthenticated bytes. This means that the complete message contents must be available in memory, making Fernet generally unsuitable for very large files at this time.</p></blockquote><p>在当前备份文件的这个场景下，将文件全部加载到内存里面是不合理的。所以需要换一个加密&#x2F;解密库</p><h2 id="pyAesCrypt"><a href="#pyAesCrypt" class="headerlink" title="pyAesCrypt"></a>pyAesCrypt</h2><p>改用pyAesCrypt了，加密和解密的处理非常简单，也可以分片加载。如下代码示例中，input_file是待加密文件，output_file是加密后文件，password是用户提供的加密密钥。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pyAesCrypt</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">encrypt_file</span>(<span class="params">input_file, output_file, password, buffer_size=<span class="number">64</span> * <span class="number">1024</span></span>):</span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(input_file, <span class="string">&#x27;rb&#x27;</span>) <span class="keyword">as</span> file_in, <span class="built_in">open</span>(output_file, <span class="string">&#x27;wb&#x27;</span>) <span class="keyword">as</span> file_out:</span><br><span class="line">        pyAesCrypt.encryptStream(file_in, file_out, password, buffer_size)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">decrypt_file</span>(<span class="params">input_file, output_file, password, buffer_size=<span class="number">64</span> * <span class="number">1024</span></span>):</span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(input_file, <span class="string">&#x27;rb&#x27;</span>) <span class="keyword">as</span> file_in, <span class="built_in">open</span>(output_file, <span class="string">&#x27;wb&#x27;</span>) <span class="keyword">as</span> file_out:</span><br><span class="line">        pyAesCrypt.decryptStream(file_in, file_out, password, buffer_size)</span><br></pre></td></tr></table></figure><p>只要用户还记得住自己的加密密钥，那么他就可以用解密函数将文件解密出来。</p><p>AES加密是当前广泛使用的对称加密方式，至于它是怎么实现的，能否被破解都是密码学的范畴了。我了解到的信息是，破解AES加密算法本身的消耗巨大，真要去破解，一般都会采用猜测密钥的方式（即猜测你是用什么密钥加密的这个文件）</p><p>所以当你需要使用AES密钥来加密文件的时候，一定要选用一个强密钥，保证数据不被轻易窃取。</p><p>当然，我的项目中，加密的目的很单纯，就是为了避<strong>免百度云盘扫我的相片和个人文件</strong>。防止文件被窃取只是个附带的功能。</p><p>实测，encrypt2bdy项目中采用pyAesCrypt库后，处理500MB文件的过程中内存占用都不会超过90MB，非常完美。</p><h3 id="密钥泄露问题？"><a href="#密钥泄露问题？" class="headerlink" title="密钥泄露问题？"></a>密钥泄露问题？</h3><p>更新后的项目还是采用环境变量的方式来加载用户密钥，至于环境变量方式是否会导致密钥泄露：别人都能看到你的docker配置了，他还取你的密钥干嘛，直接把本地源文件偷走了好吧……</p><p>就算不用环境变量，在配置文件&#x2F;前端里面填密钥，最终都还是需要一个位置来存放这个密钥 </p><p>除非直接把密钥存内存里面，不写入任何文件，且每次重启docker都<strong>要求用户重新填密钥</strong>。但是这样会导致容器可用性很差，毕竟每次操作docker容器都得重新弄一下配置。不过后续给某些对隐私要求高的老哥提供这个功能也不是不行。（这个功能必须要等前端写出来了之后才有可能实现）</p><h1 id="分片加密上传"><a href="#分片加密上传" class="headerlink" title="分片加密上传"></a>分片加密上传</h1><p>修改了加密库还是不够。来和我一起看看当前项目上传文件的逻辑吧，假设用户选择了加密上传</p><ul><li>分片读取文件，计算文件md5用于本地入库</li><li>分片读取和加密文件，并将<strong>加密后文件</strong>添加<code>.e2bdy</code>后缀写入源目录</li><li><strong>分片读取和上传</strong>加密后文件</li><li>上传完毕，删除加密后文件（只保留源文件）</li><li>循环处理，直到选定目录中所有文件都被处理完毕。</li></ul><p>整个程序逻辑都采用了分片读取文件，内存占用问题是解决了，但还有另外一个问题没有解决：加密后文件需要写入磁盘，上传后又被删除。</p><p>也就是说，假设我需要备份100GB的文件，那么磁盘就会多出100GB的数据擦写……程序也需要累积等待100GB的磁盘写入，如果是机械硬盘……</p><p>而且，磁盘还需要<strong>保留有足量空间</strong>来存放这个临时的加密文件，假设我想备份一个10GB的单个文件，磁盘剩余可用空间只剩5GB了，此时程序<strong>就无法将加密后的文件写入磁盘</strong>（一般加密后的文件会比原始文件略大一些），导致无法处理这个文件了。</p><p>这样肯定不行！所以我换了一个思路，百度云盘要求数据按4MB的分片调用API上传，<strong>那么我们可否每次读取4MB的文件内容，加密它并保存在内存中，随后直接上传这个分片呢</strong>？这样整个的处理流程中，都是分片后在内存中处理，也不会多出来一个临时的加密文件导致的数据擦写，项目可用性提高！</p><p>问了GPT，写了个这样的示例代码</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> io</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> pyAesCrypt</span><br><span class="line"></span><br><span class="line"><span class="comment"># 加密函数</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">encrypt_chunk</span>(<span class="params">chunk_data, password</span>):</span><br><span class="line">    <span class="comment"># 加密数据块</span></span><br><span class="line">    <span class="keyword">with</span> io.BytesIO() <span class="keyword">as</span> block_encrypted:</span><br><span class="line">        pyAesCrypt.encryptStream(</span><br><span class="line">            io.BytesIO(chunk_data),</span><br><span class="line">            block_encrypted,</span><br><span class="line">            password</span><br><span class="line">        )</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 返回加密后的数据</span></span><br><span class="line">        <span class="keyword">return</span> block_encrypted.getvalue()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 上传函数</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">upload_chunk_to_cloud</span>(<span class="params">chunk_data</span>):</span><br><span class="line">    <span class="comment"># 将加密后的数据块上传到云端</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 主程序</span></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    src_path = <span class="string">&#x27;path/to/source/file&#x27;</span></span><br><span class="line">    password = <span class="string">&#x27;your-password&#x27;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(src_path, <span class="string">&#x27;rb&#x27;</span>) <span class="keyword">as</span> src_file:</span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">            <span class="comment"># 读取一个数据块</span></span><br><span class="line">            chunk = src_file.read(<span class="number">4</span> * <span class="number">1024</span> * <span class="number">1024</span>)</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> chunk:</span><br><span class="line">                <span class="comment"># 数据块读取完毕，退出循环</span></span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">            <span class="comment"># 加密数据块</span></span><br><span class="line">            encrypted_chunk = encrypt_chunk(chunk, password)</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 上传加密后的数据块到云端</span></span><br><span class="line">            upload_chunk_to_cloud(encrypted_chunk)</span><br></pre></td></tr></table></figure><p>现在我要做的，就是验证一下这样操作是否能上传成功、是否能解密上传后的文件，然后再看看内存占用多少。</p><h2 id="分片加密和直接加密区别"><a href="#分片加密和直接加密区别" class="headerlink" title="分片加密和直接加密区别"></a>分片加密和直接加密区别</h2><p>然而第一部我就卡住了：百度云盘的API要求上传前先传入文件的完整md5，也就是说，<strong>我得想个办法拿到加密后文件的完整md5</strong>！</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> io</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> hashlib</span><br><span class="line"><span class="keyword">import</span> pyAesCrypt</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 加密函数</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">encrypt_chunk</span>(<span class="params">chunk_data, password</span>):</span><br><span class="line">    <span class="comment"># 加密数据块</span></span><br><span class="line">    <span class="keyword">with</span> io.BytesIO() <span class="keyword">as</span> block_encrypted:</span><br><span class="line">        pyAesCrypt.encryptStream(io.BytesIO(chunk_data), block_encrypted,</span><br><span class="line">                                 password)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 返回加密后的数据</span></span><br><span class="line">        <span class="keyword">return</span> block_encrypted.getvalue()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">encrypt_file</span>(<span class="params">input_file_path: <span class="built_in">str</span>, passwd</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    加密文件，采用分片读取</span></span><br><span class="line"><span class="string">    :param input_file_path： 需要加密的源文件</span></span><br><span class="line"><span class="string">    :return 加密后的文件路径</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    encrypt_file_path = input_file_path + <span class="string">&quot;.ept&quot;</span></span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(input_file_path, <span class="string">&#x27;rb&#x27;</span>) <span class="keyword">as</span> file_in, <span class="built_in">open</span>(encrypt_file_path,</span><br><span class="line">                                                      <span class="string">&#x27;wb&#x27;</span>) <span class="keyword">as</span> file_out:</span><br><span class="line">        pyAesCrypt.encryptStream(file_in, file_out, passwd, <span class="number">4</span> * <span class="number">1024</span> * <span class="number">1024</span>)</span><br><span class="line">    <span class="keyword">return</span> encrypt_file_path</span><br><span class="line"></span><br><span class="line"><span class="comment"># 主程序</span></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    src_path = <span class="string">&#x27;/home/mu/code-wsl/py-wsl/encrypt2bdy/test/CloudDrive2Setup-X64-0.5.14.exe&#x27;</span></span><br><span class="line">    password = <span class="string">&#x27;test&#x27;</span></span><br><span class="line">    ept_file_path = encrypt_file(src_path,password)</span><br><span class="line">    <span class="comment"># 读取加密后文件计算md5</span></span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(ept_file_path, <span class="string">&#x27;rb&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">        file_md5_str = hashlib.md5(f.read()).hexdigest()</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;full encrypt&quot;</span>,file_md5_str)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 分片加密并计算md5</span></span><br><span class="line">    file_md5_str = hashlib.md5()</span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(src_path, <span class="string">&#x27;rb&#x27;</span>) <span class="keyword">as</span> src_file:</span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">            <span class="comment"># 读取一个数据块</span></span><br><span class="line">            chunk = src_file.read(<span class="number">4</span> * <span class="number">1024</span> * <span class="number">1024</span>)</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> chunk:</span><br><span class="line">                <span class="comment"># 数据块读取完毕，退出循环</span></span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">            <span class="comment"># 加密数据块</span></span><br><span class="line">            encrypted_chunk = encrypt_chunk(chunk, password)</span><br><span class="line">            file_md5_str.update(encrypted_chunk)</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;chunk encrypt&quot;</span>,file_md5_str.hexdigest())</span><br></pre></td></tr></table></figure><p>分片加密后的整个文件，和直接加密的文件肯定是不一样的，即便这两个操作都用了相同大小的分片块。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">╰─ python3.10 test.py</span><br><span class="line">full encrypt e994f5c7244fa7d6e9577e2089a029bc</span><br><span class="line">chunk encrypt bdd05213bcafe4f87470c90633d7c2bc</span><br></pre></td></tr></table></figure><p>但如果把分片后的文件写入本地，再计算md5，会发现二者相同</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 分片加密并计算md5</span></span><br><span class="line">file_md5_str = hashlib.md5()</span><br><span class="line">chunk_encrpy_file = src_path + <span class="string">&#x27;.test&#x27;</span></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(chunk_encrpy_file,<span class="string">&#x27;wb&#x27;</span>) <span class="keyword">as</span> ef:</span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(src_path, <span class="string">&#x27;rb&#x27;</span>) <span class="keyword">as</span> src_file:</span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">            <span class="comment"># 读取一个数据块</span></span><br><span class="line">            chunk = src_file.read(<span class="number">4</span> * <span class="number">1024</span> * <span class="number">1024</span>)</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> chunk:</span><br><span class="line">                <span class="comment"># 数据块读取完毕，退出循环</span></span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">            <span class="comment"># 加密数据块</span></span><br><span class="line">            encrypted_chunk = encrypt_chunk(chunk, password)</span><br><span class="line">            file_md5_str.update(encrypted_chunk)</span><br><span class="line">            ef.write(encrypted_chunk)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;chunk encrypt&quot;</span>,file_md5_str.hexdigest())</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;chunk encrypt file:&quot;</span>,file_md5(chunk_encrpy_file))</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">chunk encrypt 843ef6583227592da36e563c1700d0da</span><br><span class="line">chunk encrypt file: 843ef6583227592da36e563c1700d0da</span><br></pre></td></tr></table></figure><p>也就是说，虽然这种方式和直接加密整个文件，<strong>得到的最终文件是不一样的</strong>，但我们依旧可以通过用相同办法进行加密和解密操作，来进行分片加密上传和分片解密文件（吗？）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">raise ValueError(&quot;Bad HMAC (file is corrupted).&quot;)</span><br></pre></td></tr></table></figure><p>无法解密……G！</p><p>要期末了，等放假了再继续研究这个问题</p>]]></content>
    
    
    <summary type="html">Python实现文件分片加密和上传（未实现）</summary>
    
    
    
    <category term="速通Python" scheme="https://blog.musnow.top/categories/%E9%80%9F%E9%80%9APython/"/>
    
    
    <category term="Python" scheme="https://blog.musnow.top/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>【Python】Python分片计算文件md5</title>
    <link href="https://blog.musnow.top/posts/1918073551/"/>
    <id>https://blog.musnow.top/posts/1918073551/</id>
    <published>2023-12-17T11:52:00.000Z</published>
    <updated>2023-12-17T11:52:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="问题说明"><a href="#问题说明" class="headerlink" title="问题说明"></a>问题说明</h1><blockquote><p>项目地址：<a href="https://github.com/musnows/encrypt2bdy">musnows&#x2F;encrypt2bdy</a></p></blockquote><p>之前自己瞎写了一个上传文件到百度云的python程序，提供了docker并部署在了我自己的nas上，但是我限制容器可用内存大小为1GB后，总是会遇到docker因为<strong>内存爆满</strong>直接被系统kill了的情况。</p><p>现在总算有时间看看到底是啥问题了，其实我已经能想到了，上传文件的部分已经是按分片上传的，理论上不是那个地方的问题，另外一个打开文件的地方只有一处，就是计算文件整体md5的操作。</p><p>因为当时没想明白问题在哪里，我还在项目的README里面写了一个不建议用于备份大文件，因为内存会撑爆的提示（</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">## 已知错误</span><br><span class="line"></span><br><span class="line">### 1.docker退出码137</span><br><span class="line"></span><br><span class="line">内存不足时，系统将对应docker容器终止。出现此问题，请确认您要备份的文件中不会出现大于您系统内存或docker容器内存限制的文件。</span><br><span class="line"></span><br><span class="line">正如开头所说，本项目适合于备份照片、图片、文档等小文件，并不建议用于备份录像、电影等资源。</span><br></pre></td></tr></table></figure><h2 id="原有代码读取md5的方式"><a href="#原有代码读取md5的方式" class="headerlink" title="原有代码读取md5的方式"></a>原有代码读取md5的方式</h2><p>在程序中，我计算文件整体md5的操作是这样写的</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 打开文件</span></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(file_path, <span class="string">&#x27;rb&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">file_bytes = f.read()</span><br><span class="line"><span class="comment"># 1.计算文件md5，判断文件是否存在于数据中</span></span><br><span class="line">file_name = os.path.basename(file_path)  <span class="comment"># 文件名</span></span><br><span class="line">file_md5_str = hashlib.md5(file_bytes).hexdigest()</span><br><span class="line">_log.debug(<span class="string">f&quot;<span class="subst">&#123;file_path&#125;</span> | <span class="subst">&#123;file_md5_str&#125;</span>&quot;</span>)</span><br></pre></td></tr></table></figure><p>问题其实很明朗，就是这里的<code>f.read()</code>操作直接将<strong>整个文件加载到内存里面</strong>了！备份的文件稍微大一点，指定要把内存整爆的！</p><h2 id="分片读取md5"><a href="#分片读取md5" class="headerlink" title="分片读取md5"></a>分片读取md5</h2><p>这部分代码应该替换为如下形式，分片读取文件，并将读取的md5给update到<code>hashlib.md5()</code>对象中</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">file_md5</span>(<span class="params">file_path: <span class="built_in">str</span></span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;给定一个文件路径，分片加载文件，计算文件的md5&quot;&quot;&quot;</span></span><br><span class="line">    chunk_size = <span class="number">4096</span>  <span class="comment"># 根据需要调整单块的大小</span></span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(file_path, <span class="string">&#x27;rb&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">        file_md5 = hashlib.md5()</span><br><span class="line">        <span class="keyword">while</span> chunk := f.read(chunk_size):</span><br><span class="line">            file_md5.update(chunk)</span><br><span class="line">    <span class="keyword">return</span> file_md5.hexdigest()</span><br></pre></td></tr></table></figure><p>经过测试，这种办法计算出来的md5和直接<code>f.read()</code>全部计算出的md5完全一致</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">╰─ python3.10 test.py                 </span><br><span class="line">ca60e24bf4dde156a381c8b9d268faf5</span><br><span class="line">ca60e24bf4dde156a381c8b9d268faf5</span><br></pre></td></tr></table></figure><h1 id="内存占用监控线程"><a href="#内存占用监控线程" class="headerlink" title="内存占用监控线程"></a>内存占用监控线程</h1><p>用下面的代码弄个内存占用的监控线程，通过psutil库实时打印内存占用</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> psutil</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">monitor_memory_usage</span>():</span><br><span class="line">    process = psutil.Process(os.getpid())</span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        memory_info = process.memory_info()</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;Memory used: <span class="subst">&#123;memory_info.rss / (<span class="number">1024</span> * <span class="number">1024</span>):<span class="number">.2</span>f&#125;</span> MB&quot;</span>)</span><br><span class="line">        time.sleep(<span class="number">1</span>)  <span class="comment"># 每秒更新一次内存信息</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 启动一个线程来监视内存使用情况</span></span><br><span class="line">memory_monitor_thread = threading.Thread(target=monitor_memory_usage)</span><br><span class="line">memory_monitor_thread.start()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 主线程继续执行其他任务</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 等待监视线程结束（如果需要）</span></span><br><span class="line">memory_monitor_thread.join()</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="内存占用测试"><a href="#内存占用测试" class="headerlink" title="内存占用测试"></a>内存占用测试</h2><p>将项目中上传到百度云的部分注释掉，休眠10秒替代上传操作，模拟原有代码整体打开一个文件，又分片打开文件上传到百度云的流程。</p><p>用两个450MB左右的视频做测试。程序原有思路是遍历需要备份目录中的所有文件，分片上传到百度云。计算整个文件的MD5的操作其实是用来<strong>本地入库</strong>标定文件是否有修改、是否已经上传的。</p><p>不过后续<strong>加密文件</strong>的操作也是无脑<code>f.read()</code>，这部分也需要修改。</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2023/12/f053a510be9127854a6a2102cac8589f.png" alt="image.png"></p><p>日志输出如下，可以看到，开始处理test目录之后，程序直接把视频完整加载到了内存里面，占用内存的大小和视频文件大小基本一致。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">╰─ python3.10 main.py</span><br><span class="line">[23-12-17 20:01:22] INFO:confLoad.py:&lt;module&gt;:68 | [config] loaded config from &#x27;./config/config.yml&#x27;</span><br><span class="line">[23-12-17 20:01:22] INFO:confLoad.py:&lt;module&gt;:89 | [config] loaded config success</span><br><span class="line">[23-12-17 20:01:22] INFO:querySql.py:&lt;module&gt;:72 | [sqlite3] create all tables</span><br><span class="line">[23-12-17 20:01:23] INFO:main.py:&lt;module&gt;:294 | [start] start at 23-12-17 20:01:23</span><br><span class="line">[23-12-17 20:01:23] INFO:encrypt.py:__init__:24 | load key file from &#x27;./config/encrypt.key&#x27;</span><br><span class="line">Memory used: 39.18 MB</span><br><span class="line">[23-12-17 20:01:23] INFO:main.py:upload_task:132 | 上传任务开始：23-12-17 20:01:23</span><br><span class="line">[23-12-17 20:01:23] INFO:main.py:upload_task:139 | 开始处理路径 &#x27;/home/mu/code-wsl/py-wsl/encrypt2bdy/test&#x27; | 文件数量 2</span><br><span class="line">[23-12-17 20:01:23] INFO:main.py:upload_task:144 | [0] 开始处理 &#x27;/home/mu/code-wsl/py-wsl/encrypt2bdy/test/【超丝滑60帧】4K精装字幕版《ILLSHOWYOU》KDA阿狸.mp4&#x27;</span><br><span class="line">Memory used: 483.52 MB</span><br><span class="line">Memory used: 483.52 MB</span><br><span class="line">Memory used: 483.52 MB</span><br><span class="line">Memory used: 483.52 MB</span><br><span class="line">Memory used: 483.52 MB</span><br><span class="line">Memory used: 483.52 MB</span><br><span class="line">Memory used: 483.52 MB</span><br><span class="line">Memory used: 483.52 MB</span><br><span class="line">Memory used: 483.52 MB</span><br><span class="line">Memory used: 483.52 MB</span><br><span class="line">[23-12-17 20:01:33] INFO:main.py:upload_task:237 | [1] 成功上传 &#x27;/home/mu/code-wsl/py-wsl/encrypt2bdy/test/【超丝滑60帧】4K精装字幕版《ILLSHOWYOU》KDA阿狸.mp4&#x27; 文件哈希：7d5735eba55a638a1290ab36e00530ca</span><br><span class="line">[23-12-17 20:01:33] INFO:main.py:upload_task:144 | [1] 开始处理 &#x27;/home/mu/code-wsl/py-wsl/encrypt2bdy/test/【超丝滑60帧】4K精装字幕版《MORE》KDA.mp4&#x27;</span><br><span class="line">Memory used: 517.39 MB</span><br><span class="line">Memory used: 517.39 MB</span><br><span class="line">Memory used: 517.39 MB</span><br><span class="line">Memory used: 517.39 MB</span><br><span class="line">Memory used: 517.39 MB</span><br><span class="line">Memory used: 517.39 MB</span><br><span class="line">Memory used: 517.39 MB</span><br><span class="line">Memory used: 517.39 MB</span><br><span class="line">Memory used: 517.39 MB</span><br><span class="line">Memory used: 517.39 MB</span><br><span class="line">Memory used: 517.39 MB</span><br><span class="line">[23-12-17 20:01:44] INFO:main.py:upload_task:237 | [2] 成功上传 &#x27;/home/mu/code-wsl/py-wsl/encrypt2bdy/test/【超丝滑60帧】4K精装字幕版《MORE》KDA.mp4&#x27; 文件哈希：b7b0cd46e3ac7681a3644d9761ad3e71</span><br><span class="line">[23-12-17 20:01:44] INFO:main.py:upload_task:282 | 本次上传完毕，上传：2，跳过：0，错误：0 | 总计：2</span><br><span class="line">[23-12-17 20:01:44] INFO:main.py:upload_task:283 | 本次上传完毕，平均上传速度：43.143mb/s | 总耗时：21.16s</span><br><span class="line">[23-12-17 20:01:44] INFO:main.py:upload_task:286 | 本次上传完毕，下次处理：2023-12-17 21:00:00</span><br></pre></td></tr></table></figure><p>带上加密之后更加离谱，只是第一个文件就直接把内存占用干到了3.2GB，处理第二个文件的时候，也是直接干到了2.4GB，这种程度的内存消耗谁顶得住？更何况百度云API最大支持10GB的文件上传，如果要加载一个10GB的文件还得了啊？</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">╰─ python3.10 main.py</span><br><span class="line">[23-12-17 19:43:56] INFO:confLoad.py:&lt;module&gt;:68 | [config] loaded config from &#x27;./config/config.yml&#x27;</span><br><span class="line">[23-12-17 19:43:56] INFO:confLoad.py:&lt;module&gt;:89 | [config] loaded config success</span><br><span class="line">[23-12-17 19:43:56] INFO:querySql.py:&lt;module&gt;:72 | [sqlite3] create all tables</span><br><span class="line">[23-12-17 19:43:56] INFO:main.py:&lt;module&gt;:291 | [start] start at 23-12-17 19:43:56</span><br><span class="line">Memory used: 39.31 MB</span><br><span class="line">[23-12-17 19:43:56] INFO:encrypt.py:__init__:24 | load key file from &#x27;./config/encrypt.key&#x27;</span><br><span class="line">[23-12-17 19:43:56] INFO:main.py:upload_task:132 | 上传任务开始：23-12-17 19:43:56</span><br><span class="line">[23-12-17 19:43:56] INFO:main.py:upload_task:139 | 开始处理路径 &#x27;/home/mu/code-wsl/py-wsl/encrypt2bdy/test&#x27; | 文件数量 2</span><br><span class="line">Memory used: 923.04 MB</span><br><span class="line">Memory used: 3267.48 MB</span><br><span class="line">Memory used: 483.71 MB</span><br><span class="line">Memory used: 483.71 MB</span><br><span class="line">Memory used: 483.71 MB</span><br><span class="line">Memory used: 483.71 MB</span><br><span class="line">Memory used: 483.71 MB</span><br><span class="line">Memory used: 483.71 MB</span><br><span class="line">Memory used: 483.71 MB</span><br><span class="line">Memory used: 483.71 MB</span><br><span class="line">Memory used: 483.71 MB</span><br><span class="line">Memory used: 483.71 MB</span><br><span class="line">[23-12-17 19:44:08] INFO:main.py:upload_task:234 | [1] 成功上传 &#x27;/home/mu/code-wsl/py-wsl/encrypt2bdy/test/【超丝滑60帧】4K精装字幕版《ILLSHOWYOU》KDA阿狸.mp4&#x27; 文件哈希：7d5735eba55a638a1290ab36e00530ca</span><br><span class="line">Memory used: 990.96 MB</span><br><span class="line">Memory used: 2410.97 MB</span><br><span class="line">Memory used: 1622.17 MB</span><br><span class="line">Memory used: 517.57 MB</span><br><span class="line">Memory used: 517.57 MB</span><br><span class="line">Memory used: 517.57 MB</span><br><span class="line">Memory used: 517.57 MB</span><br><span class="line">Memory used: 517.57 MB</span><br><span class="line">Memory used: 517.57 MB</span><br><span class="line">Memory used: 517.57 MB</span><br><span class="line">Memory used: 517.57 MB</span><br><span class="line">Memory used: 517.57 MB</span><br><span class="line">Memory used: 517.57 MB</span><br><span class="line">[23-12-17 19:44:22] INFO:main.py:upload_task:234 | [2] 成功上传 &#x27;/home/mu/code-wsl/py-wsl/encrypt2bdy/test/【超丝滑60帧】4K精装字幕版《MORE》KDA.mp4&#x27; 文件哈希：b7b0cd46e3ac7681a3644d9761ad3e71</span><br><span class="line">[23-12-17 19:44:22] INFO:main.py:upload_task:279 | 本次上传完毕，上传：2，跳过：0，错误：0 | 总计：2</span><br><span class="line">[23-12-17 19:44:22] INFO:main.py:upload_task:280 | 本次上传完毕，平均上传速度：35.371mb/s | 总耗时：25.81s</span><br><span class="line">[23-12-17 19:44:22] INFO:main.py:upload_task:283 | 本次上传完毕，下次处理：2023-12-17 21:00:00</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>先将md5计算的函数给修改了，改成分片计算。可以看到，效果显著！内存占用和程序刚开始运行的时候差距只有5MB，这才是正常的内存占用！</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">╰─ python3.10 main.py</span><br><span class="line">[23-12-17 20:03:20] INFO:confLoad.py:&lt;module&gt;:68 | [config] loaded config from &#x27;./config/config.yml&#x27;</span><br><span class="line">[23-12-17 20:03:20] INFO:confLoad.py:&lt;module&gt;:89 | [config] loaded config success</span><br><span class="line">[23-12-17 20:03:20] INFO:querySql.py:&lt;module&gt;:72 | [sqlite3] create all tables</span><br><span class="line">[23-12-17 20:03:20] INFO:main.py:&lt;module&gt;:294 | [start] start at 23-12-17 20:03:20</span><br><span class="line">Memory used: 39.26 MB</span><br><span class="line">[23-12-17 20:03:20] INFO:encrypt.py:__init__:24 | load key file from &#x27;./config/encrypt.key&#x27;</span><br><span class="line">[23-12-17 20:03:20] INFO:main.py:upload_task:132 | 上传任务开始：23-12-17 20:03:20</span><br><span class="line">[23-12-17 20:03:20] INFO:main.py:upload_task:139 | 开始处理路径 &#x27;/home/mu/code-wsl/py-wsl/encrypt2bdy/test&#x27; | 文件数量 2</span><br><span class="line">[23-12-17 20:03:20] INFO:main.py:upload_task:144 | [0] 开始处理 &#x27;/home/mu/code-wsl/py-wsl/encrypt2bdy/test/【超丝滑60帧】4K精装字幕版《ILLSHOWYOU》KDA阿狸.mp4&#x27;</span><br><span class="line">Memory used: 44.08 MB</span><br><span class="line">Memory used: 44.08 MB</span><br><span class="line">Memory used: 44.08 MB</span><br><span class="line">Memory used: 44.08 MB</span><br><span class="line">Memory used: 44.08 MB</span><br><span class="line">Memory used: 44.08 MB</span><br><span class="line">Memory used: 44.08 MB</span><br><span class="line">Memory used: 44.08 MB</span><br><span class="line">Memory used: 44.08 MB</span><br><span class="line">Memory used: 44.08 MB</span><br><span class="line">Memory used: 44.08 MB</span><br><span class="line">[23-12-17 20:03:32] INFO:main.py:upload_task:237 | [1] 成功上传 &#x27;/home/mu/code-wsl/py-wsl/encrypt2bdy/test/【超丝滑60帧】4K精装字幕版《ILLSHOWYOU》KDA阿狸.mp4&#x27; 文件哈希：7d5735eba55a638a1290ab36e00530ca</span><br><span class="line">[23-12-17 20:03:32] INFO:main.py:upload_task:144 | [1] 开始处理 &#x27;/home/mu/code-wsl/py-wsl/encrypt2bdy/test/【超丝滑60帧】4K精装字幕版《MORE》KDA.mp4&#x27;</span><br><span class="line">Memory used: 44.08 MB</span><br><span class="line">Memory used: 44.08 MB</span><br><span class="line">Memory used: 44.08 MB</span><br><span class="line">Memory used: 44.08 MB</span><br><span class="line">Memory used: 44.08 MB</span><br><span class="line">Memory used: 44.08 MB</span><br><span class="line">Memory used: 44.08 MB</span><br><span class="line">Memory used: 44.08 MB</span><br><span class="line">Memory used: 44.08 MB</span><br><span class="line">Memory used: 44.08 MB</span><br><span class="line">Memory used: 44.08 MB</span><br><span class="line">Memory used: 44.08 MB</span><br><span class="line">[23-12-17 20:03:44] INFO:main.py:upload_task:237 | [2] 成功上传 &#x27;/home/mu/code-wsl/py-wsl/encrypt2bdy/test/【超丝滑60帧】4K精装字幕版《MORE》KDA.mp4&#x27; 文件哈希：b7b0cd46e3ac7681a3644d9761ad3e71</span><br><span class="line">[23-12-17 20:03:44] INFO:main.py:upload_task:282 | 本次上传完毕，上传：2，跳过：0，错误：0 | 总计：2</span><br><span class="line">[23-12-17 20:03:44] INFO:main.py:upload_task:283 | 本次上传完毕，平均上传速度：38.689mb/s | 总耗时：23.60s</span><br><span class="line">[23-12-17 20:03:44] INFO:main.py:upload_task:286 | 本次上传完毕，下次处理：2023-12-17 21:00:00</span><br></pre></td></tr></table></figure><h1 id="The-end"><a href="#The-end" class="headerlink" title="The end"></a>The end</h1><p>关于分片计算md5的介绍就这么多，我这个程序里面文件加密的部分也需要修改，不过那就不是本文的范畴了~</p>]]></content>
    
    
    <summary type="html">Python分片计算文件md5</summary>
    
    
    
    <category term="速通Python" scheme="https://blog.musnow.top/categories/%E9%80%9F%E9%80%9APython/"/>
    
    
    <category term="Python" scheme="https://blog.musnow.top/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>【图床】通过Cloudflare的自定义主机名服务代理图床域名</title>
    <link href="https://blog.musnow.top/posts/923376033/"/>
    <id>https://blog.musnow.top/posts/923376033/</id>
    <published>2023-12-16T09:55:00.000Z</published>
    <updated>2023-12-16T11:55:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h1><p>我的目的是，图床的域名，国内依旧使用七牛云CDN，境外的请求使用Cloudflare代理。Cloudflare能帮我们拦截一些高危的IP地址，能避免海外肉鸡刷你的图床服务。</p><p>如果你用过Cloudflare，其在SSL&#x2F;TLS模块提供了一个<code>自定义主机名</code>的服务，可以让用户在<strong>不将域名改成Cloudflare的DNS的情况下</strong>，使用Cloudflare的代理功能。</p><p>这个功能是Cloudflare for SAAS的一部分，你应该能在网上找到很多教程。</p><ul><li><a href="https://vircloud.net/exp/cf-cname-new.html">最新 CloudFlare CNAME 接入玩法详细图文教程 - SaaS·永久免费·官方稳定 - VirCloud’s Blog - Learning&amp;Sharing</a></li><li><a href="https://cloud.tencent.com/developer/article/1970429">Cloudflare Saas 接入CNAME流程-腾讯云开发者社区-腾讯云</a></li><li><a href="https://blog.csdn.net/alex_yangchuansheng/article/details/125986096">Cloudflare CNAME 接入满血复活，一分钱不用花！-CSDN博客</a></li></ul><p>简单说来，想使用这个功能，需要如下几个条件</p><ul><li>实际使用的域名：对于我而言是musnow.top</li><li>用于指定回退源的域名：这是第二个域名，名字无所谓，可以直接去<a href="https://nic.eu.org/arf/en/">EU.org</a>申请一个免费的。该域名需要接入Cloudflare的DNS，这里用example.com举例子</li><li>一个云服务器，IP用1.1.1.1举例子</li></ul><p>当你配置好了之后，请求网站的路径变成了如下模样</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">配置前：域名musnow.top-&gt;A记录-&gt;云服务器1.1.1.1</span><br><span class="line">配置后：域名musnow.top-&gt;CNAME记录-&gt;回退源域名example.com-&gt;Cloudflare-&gt;云服务器1.1.1.1</span><br></pre></td></tr></table></figure><p>使用<code>自定义主机名</code>功能，可以让Cloudflare在请求你源站的时候，使用原有域名（实际使用的域名），而不是回退源域名。假设你需要回源的云服务器是国内的服务器。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">回退源域名example.com没有备案 -&gt; 请求国内服务器会被服务商拦截</span><br><span class="line">配置自定义主机名musnow.top后；</span><br><span class="line">Cloudflare在回源到服务器的时候，采用自定义主机名的域名，即musnow.top；</span><br><span class="line">实际使用的域名musnow.top已备案 -&gt; 请求国内服务器不再被拦截</span><br></pre></td></tr></table></figure><p>整个过程中，回退源域名example.com对于用户是无感知的！我们实现了在原有域名musnow.top的DNS没有接入Cloudflare的情况下，使用了Cloudflare的防护服务。</p><p>目前免费版本的自定义主机名有如下要求</p><ul><li>Cloudflare必须要验证你的支付方式，<strong>不会扣你钱的</strong>（paypal或者银联信用卡，当时为此我还专门去办了个没有额度的学生信用卡，后来发现压根不需要，直接用paypal绑定个银联储蓄卡&#x2F;借记卡就可以了）</li><li>免费版本的回退源只能指定一个，即只能回源到一个IP地址的服务。</li></ul><h1 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h1><h2 id="回退源"><a href="#回退源" class="headerlink" title="回退源"></a>回退源</h2><p>首先是设置回退源域名的DNS，将其接入Cloudflare。随后是在DNS记录中添加一个A记录，指向你的源站服务器IP。</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2023/12/141a4967805f6d4a177f84c9557cc47f.png" alt="image.png"></p><p>这里我使用的名称是<code>back.回退源域名</code>，在SSL&#x2F;TLS模块的自定义主机名中开通Cloudflare SAAS服务，并添加回退源域名</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2023/12/44ad244bf4ee3f94cddb51153ca3d68f.png" alt="image.png"></p><p>添加回退源域名并验证成功后，就可以点击蓝色<code>添加自定义主机名</code>按钮，添加你需要代理的原始域名了。</p><p>这里我添加了我的图床域名<code>img.musnow.top</code>，首先是在腾讯云的DNS中设置CNAME解析，将境外线路设置为回退源的域名，默认线路还是七牛云CDN的CNAME</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2023/12/0257caf29cbdb23c5f99d91474f061f1.png" alt="image.png"></p><p>添加了域名解析之后，你还需要在musnow.top的DNS解析里面添加两个TXT记录来验证回退源，参考Cloudflare给出的txt记录提示就可以。界面类似下图</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2023/12/29ec2ba14997ccf0e5c5d64b8ec34d99.png" alt="image.png"></p><p>添加了之后点击刷新，直到自定义主机名的状态显示为<code>有效</code>，即配置成功。</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2023/12/06877d872e6521102ec83d0805e0bfc9.png" alt="image.png"></p><p>使用海外服务器测试，配置前，解析到七牛云CDN；配置后，解析到回退源域名，即Cloudflare</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2023/12/d900e5b35ddd67f51413e66ab54c822d.png" alt="image.png"></p><h2 id="反向代理"><a href="#反向代理" class="headerlink" title="反向代理"></a>反向代理</h2><p>但这里只是配置好了域名解析而已，还需要用反代才能让境外访问图床域名能访问出图片来。</p><h3 id="反代原有七牛云CDN的CNAME不起作用"><a href="#反代原有七牛云CDN的CNAME不起作用" class="headerlink" title="反代原有七牛云CDN的CNAME不起作用"></a>反代原有七牛云CDN的CNAME不起作用</h3><p>但是这个反代要怎么配置呢？因为只是解析线路不同，直接把img.musnow.top反向代理到img.musnow.top肯定不行，<strong>试试反代到七牛云的CNMAE</strong>？</p><p>测试发现，直接通过七牛云CDN里面的CNAME访问这个图片会403（不管是浏览器访问还是使用curl访问）</p><p>而反代过后，curl和wget的结果都变成了526，<strong>无法访问图片</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">╰─ curl https://img.musnow.top/i/2023/05/647563ddab0fb.gif</span><br><span class="line">error code: 526%    </span><br><span class="line"></span><br><span class="line">╰─ wget https://img.musnow.top/i/2023/05/647563ddab0fb.gif</span><br><span class="line">--2023-12-16 18:48:21--  https://img.musnow.top/i/2023/05/647563ddab0fb.gif</span><br><span class="line">Resolving img.musnow.top (img.musnow.top)... 172.67.157.61, 104.21.56.251, 2606:4700:3035::ac43:9d3d, ...</span><br><span class="line">Connecting to img.musnow.top (img.musnow.top)|172.67.157.61|:443... connected.</span><br><span class="line">HTTP request sent, awaiting response... 526 </span><br><span class="line">2023-12-16 18:48:21 ERROR 526: (no description).</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2023/12/b84073fd201689557c89a39ddf058e05.png" alt="image.png"></p><p>即便在反代里面设置了后端请求的域名为<code>img.musnow.top</code>，访问依旧会是526</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2023/12/6e0441d8096870ebab9dc0f560005aa4.png" alt="image.png"></p><h3 id="未设置Cloudflare时能成功解析"><a href="#未设置Cloudflare时能成功解析" class="headerlink" title="未设置Cloudflare时能成功解析"></a>未设置Cloudflare时能成功解析</h3><p>作为对比，在<strong>没有配置</strong>解析到Cloudflare的时候，使用wget是能访问出图片来的</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2023/12/21bbf4746ffcc740728e4b1df8be6427.png" alt="image.png"></p><p>将wget的这个图片通过sftp下载下来，能看到它是正常的gif，图片访问没有问题。</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2023/12/b29c2c5cbf14669c34f4037322aeeff6.png" alt="image.png"></p><h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><p>我能想到的解决办法，是白嫖一下七牛云免费的10GB HTTP流量，新建一个HTTP回源的CDN，绑定到图床的bucket上即可。</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2023/12/3e6bcea445ba19b11f6c77026ac658de.png" alt="image.png"></p><p>注意，只要你的回源地址是<strong>国内的bucket</strong>，那么域名就必须要备案才能配置CDN。</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2023/12/657d8838998a7.png"></p><p>因为现在是通过云服务器反代来访问这个CDN，此时反代的proxy设置为http，在添加<code>img.musnow.top</code>的cert证书到反代设置里面，就能实现https。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">img.musnow.top 反代 img-cloudflare.musnow.top</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2023/12/0d22fc941aa251767a6d002cf9c587a0.png" alt="image.png"></p><p>注意，反代中的后端域名也需要设置为新的CDN域名，否则访问会因为域名不匹配而403拒绝访问。</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2023/12/342efa096d28d3bdbeb9a33454b14aa4.png" alt="image.png"></p><p>随后就是添加img.musnow.top的SSL证书</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2023/12/d98f69744def3672429c19ae7879a690.png" alt="image.png"></p><p>测试一下，新建的这个cdn域名可以通过http访问到bucket里面的图片</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2023/12/41d0ef29dc9f3da44647b7150b4625f0.png" alt="image.png"></p><p>再测试一下<strong>反代后的域名</strong>，也可以访问到图片了，这里访问的IP地址<code>104.21.56.251</code>也已经是Cloudflare的IP了。配置成功！</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2023/12/ba1eb6f04811dc5e15e62055fdcb0d4a.png" alt="image.png"></p><p>此时海外访问我的图床，解析变成了如下过程</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">img.musnow.top -&gt; CNAME回退源域名 -&gt; cloudflare(https) -&gt; 云服务器反代(https) -&gt; img-cloudflare.musnow.top(http) -&gt; 七牛云bucket</span><br></pre></td></tr></table></figure><p>因为最终访问的CDN是通过HTTP回源bucket的，能白嫖七牛云10G的免费流量！</p><p>当然，如果真有人在海外打你，刷完10G流量也不是不可能……所以在cloudflare里面最好再配置一下单IP访问的频次限制！</p><p>比如下图，我设置访问URL为图床开头<code>/i</code>时进行速率监看，如果单IP访问速率超过60次&#x2F;10秒，那么就会触发cloudflare的速率限制响应，持续10秒。</p><p>因为我的博客已经设置了<strong>懒加载</strong>，所以一次性加载60个图片的场景是不存在的！这种规模的请求肯定是攻击了！再加上我的博客理论上不会有几个海外用户阅读，所以这个配置不会对国内用户产生影响。</p><blockquote><p>如果你使用了代理，请把musnow.top所有子域名加入代理白名单。</p></blockquote><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2023/12/18bbfdad10fe93f2c9b33576946d009c.png" alt="image.png"></p><h3 id="进一步优化"><a href="#进一步优化" class="headerlink" title="进一步优化"></a>进一步优化</h3><p>进一步优化，就是把新创建的这个HTTP CDN里面设置IP白名单，只允许我们设置反代的服务器的那个IP地址访问，这样就保证了其他人不能直接刷我新建的这个HTTP的CDN域名。</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2023/12/0143324cb410b006374f3ae0e2e5da60.png" alt="image.png"></p><p>在七牛云的CDN配置界面可以看到IP黑白名单，添加服务器IP地址为白名单即可</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2023/12/68f0761d01ef17bd69ae3ae390276d43.png" alt="image.png"></p><p>配置后需要过一段时间才会生效，会有个进度条。完成后，再次本地测试一下，发现已经403不允许访问了。</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2023/12/84a0913ebda28e60c4a6dd292e810ce9.png" alt="image.png"></p><p>此时在海外服务器尝试反代域名访问，依旧是OK的，访问的IP地址<code>172.67.157.61</code>也依旧是Cloudflare的IP。</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2023/12/4440fa31b56a35e7c25acc33e37974a1.png" alt="image.png"></p><h1 id="The-end"><a href="#The-end" class="headerlink" title="The end"></a>The end</h1><p>至此，配置完成！</p>]]></content>
    
    
    <summary type="html">通过Cloudflare的SAAS自定义主机名服务代理图床域名</summary>
    
    
    
    <category term="差生文具多" scheme="https://blog.musnow.top/categories/%E5%B7%AE%E7%94%9F%E6%96%87%E5%85%B7%E5%A4%9A/"/>
    
    
    <category term="图床" scheme="https://blog.musnow.top/tags/%E5%9B%BE%E5%BA%8A/"/>
    
  </entry>
  
  <entry>
    <title>【WSL】解决&#39;wsl：检测到localhost代理配置，但未镜像到WSL&#39;问题</title>
    <link href="https://blog.musnow.top/posts/3693584344/"/>
    <id>https://blog.musnow.top/posts/3693584344/</id>
    <published>2023-12-16T09:52:00.000Z</published>
    <updated>2023-12-16T09:52:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>今天使用wsl2的centos的时候遇到了这个问题</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">wsl: 检测到 localhost 代理配置，但未镜像到 WSL。</span><br><span class="line">NAT 模式下的 WSL 不支持 localhost 代理。</span><br></pre></td></tr></table></figure><p>参考 <a href="https://www.cnblogs.com/hg479/p/17869109.html">解决”wsl: 检测到 localhost 代理配置，但未镜像到 WSL。NAT 模式下的 WSL 不支持 localhost 代理” - JustInCase - 博客园</a></p><p>在windows的<code>C:\User\&lt;你的用户名&gt;\</code> 下创建一个<code>.wslconfig</code>，内部写入如下内容</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[experimental]</span><br><span class="line">autoMemoryReclaim=gradual  </span><br><span class="line">networkingMode=mirrored</span><br><span class="line">dnsTunneling=true</span><br><span class="line">firewall=true</span><br><span class="line">autoProxy=true</span><br></pre></td></tr></table></figure><p>写完后保存，重启wsl即可</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wsl --shutdown</span><br></pre></td></tr></table></figure><p>再次启动wsl，不再弹出上述提示</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2023/12/cf8be920995459ca75ed48adc48b4908.png" alt="image.png"></p>]]></content>
    
    
    <summary type="html">解决&#39;wsl：检测到localhost代理配置，但未镜像到WSL&#39;问题</summary>
    
    
    
    <category term="玩上Linux" scheme="https://blog.musnow.top/categories/%E7%8E%A9%E4%B8%8ALinux/"/>
    
    
    <category term="Linux" scheme="https://blog.musnow.top/tags/Linux/"/>
    
    <category term="虚拟机" scheme="https://blog.musnow.top/tags/%E8%99%9A%E6%8B%9F%E6%9C%BA/"/>
    
    <category term="wsl" scheme="https://blog.musnow.top/tags/wsl/"/>
    
  </entry>
  
  <entry>
    <title>【nginx】nginx通过配置文件允许uptimerobot的请求</title>
    <link href="https://blog.musnow.top/posts/1547739098/"/>
    <id>https://blog.musnow.top/posts/1547739098/</id>
    <published>2023-12-15T11:49:00.000Z</published>
    <updated>2023-12-15T11:49:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="问题说明"><a href="#问题说明" class="headerlink" title="问题说明"></a>问题说明</h1><p>前几天，我给我的artalk上了IP屏蔽，只放行国内IP，不允许任何国外的IP地址评论。</p><p><a href="https://blog.musnow.top/posts/2029711168/">【Nginx】nginx通过配置文件阻止海外ip访问 | 慕雪的寒舍</a></p><p>然后就发现了一个问题，我使用的uptimerobot这个在线状态监控程序是国外的，它的请求自然也是通过海外IP发起的，此时就会被我服务器的nginx拦截，导致403，uptimerobot认为403也是无法访问，service down了。</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2023/12/9b7cc2eba613b4a9d0fbd06a003e63b8.png" alt="image.png"></p><h1 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h1><p>之前通过折腾，已经知道了如何使用nginx的配置文件来allow或者deny一系列ip地址，那么uptimerobot的这个问题也很好解决：只要我们知道uptimerobbot的请求来源ip，那么将其写入一个如下类似的nginx配置文件，再在具体的location中include，放行对应ip地址即可。</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">allow</span> uptime-robot-ip1;</span><br><span class="line"><span class="attribute">allow</span> uptime-robot-ip2;</span><br></pre></td></tr></table></figure><p>我在uptimerobot的官网找到了它们的ip地址列表：<a href="https://uptimerobot.com/help/locations/">Locations and IPs | UptimeRobot</a></p><p>txt文件也有的：</p><ul><li>ipv4：<a href="https://uptimerobot.com/inc/files/ips/IPv4.txt">uptimerobot.com&#x2F;inc&#x2F;files&#x2F;ips&#x2F;IPv4.txt</a></li><li>ipv4+ipv6：<a href="https://uptimerobot.com/inc/files/ips/IPv4andIPv6.txt">uptimerobot.com&#x2F;inc&#x2F;files&#x2F;ips&#x2F;IPv4andIPv6.txt</a></li></ul><p>用如下脚本来实现</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line">rm -f IPv4.txt black_uptime_`date +%F`.conf</span><br><span class="line">wget https://uptimerobot.com/inc/files/ips/IPv4.txt</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">删除原有文件每一行的回车符号</span></span><br><span class="line">sed -i &#x27;s/\r//g&#x27; IPv4.txt </span><br><span class="line"></span><br><span class="line">while IFS= read -r line</span><br><span class="line">do</span><br><span class="line">  echo &quot;allow $line;&quot; &gt;&gt; black_uptime_`date +%F`.conf</span><br><span class="line">done &lt; IPv4.txt</span><br><span class="line"></span><br><span class="line">rm -f /etc/nginx/black_uptime.conf &amp;&amp; \</span><br><span class="line">ln -s $PWD/black_uptime_`date +%F`.conf /etc/nginx/black_uptime.conf</span><br></pre></td></tr></table></figure><p>将其写入一个<code>uptimerobot.sh</code>文件，使用如下命令执行它</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sh uptimerobot.sh</span><br></pre></td></tr></table></figure><p>这个脚本会在当前目录里面下载uptimerobot的这个IPv4.txt，并以nginx的形式写为allow，最后在<code>/etc/nginx</code>里面创建一个软连接 <code>/etc/nginx/black_uptime.conf</code> 文件，文件内容如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">allow 18.116.158.121;</span><br><span class="line">allow 18.223.50.16;</span><br><span class="line">allow 54.241.175.147;</span><br></pre></td></tr></table></figure><p>随后我们进入nginx的配置文件，在对应站点配置文件的location里面，include这个配置文件就可以了</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">location</span> / &#123;</span><br><span class="line"><span class="comment"># 允许uptimerobot的请求</span></span><br><span class="line"><span class="attribute">include</span> /etc/nginx/black_uptime.conf;</span><br><span class="line"><span class="attribute">deny</span> all; <span class="comment"># 拒绝其他所有请求</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>添加之后，重启nginx，配置就生效啦</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl restart nginx</span><br></pre></td></tr></table></figure><p>如下图，uptimerobot已经可以正常请求和监看我的artalk评论页面了</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2023/12/80d723cf79673db1f53efb9452baa448.png" alt="image.png"></p>]]></content>
    
    
    <summary type="html">nginx通过配置文件允许uptimerobot的请求，放行uptimerobot的ip</summary>
    
    
    
    <category term="差生文具多" scheme="https://blog.musnow.top/categories/%E5%B7%AE%E7%94%9F%E6%96%87%E5%85%B7%E5%A4%9A/"/>
    
    
    <category term="Linux" scheme="https://blog.musnow.top/tags/Linux/"/>
    
    <category term="nginx" scheme="https://blog.musnow.top/tags/nginx/"/>
    
  </entry>
  
  <entry>
    <title>【docker】部署minio对象存储并用rclone同步</title>
    <link href="https://blog.musnow.top/posts/1950951389/"/>
    <id>https://blog.musnow.top/posts/1950951389/</id>
    <published>2023-12-13T13:29:02.000Z</published>
    <updated>2023-12-13T13:29:02.000Z</updated>
    
    <content type="html"><![CDATA[<p>docker部署minio对象存储并用rclone同步</p><h1 id="1-什么是minio？"><a href="#1-什么是minio？" class="headerlink" title="1.什么是minio？"></a>1.什么是minio？</h1><p>minio是一个开源的对象存储服务器，兼容S3协议。</p><p>官网：<a href="https://min.io/">https://min.io/</a></p><p>官方在开源的基础上也提供云端S3服务，分为个人和企业，有不同的收费标准。</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2023/12/3dbb54877957d5ede7354a3401dd4cf0.png" alt="5ae0c978272b7ca6732817920adae0f5.png"></p><h2 id="1-1-自建对象存储的好处？"><a href="#1-1-自建对象存储的好处？" class="headerlink" title="1.1 自建对象存储的好处？"></a>1.1 自建对象存储的好处？</h2><p>当然，本文写下来肯定不是让你去买它的对象存储服务的，而是在我们自己的服务器&#x2F;Nas上部署一个minio的docker，来拥有一个我们自己的对象存储服务器！</p><p>对象存储服务器可以用来做图床、静态资源缓存，亦或者是直接当作一个网盘来使用。</p><p>自建的对象存储的好处是所有源文件我们都能亲手管理，且无需为付费的对象存储的奇怪的计价文档感到手足无措，也不需要担心有人恶意刷流把你一套房子给套走。</p><p>缺点就是，自建的稳定性肯定不如已有厂家提供的服务，且自购的服务器&#x2F;Nas上传带宽一般都很低，文件一多，访问速度就很慢了。</p><p>对于我个人而言，自建minio的唯一作用，就是备份七牛云&#x2F;阿里云对象存储中的文件。考虑到2023下半年，各大厂接连boom云服务，国外的谷歌还出现了云盘里面用户的数据回滚到几月前的恶性问题，这可是可能导致用户数据丢失的大问题啊！</p><ul><li><a href="https://www.ithome.com/0/737/538.htm">谷歌公布方案，修复 Drive 云盘文件丢失问题</a></li><li><a href="https://news.zol.com.cn/845/8455073.html">谷歌承认云端硬盘Google Drive存在BUG，3月内用户文件可能丢失</a></li></ul><p>所以，将数据在自己本地留一份总是安心一些。数据安全靠的是备份，不是云服务厂家给你提供的<code>99.99999%</code>可用性的一面之词。</p><p>如果你对数据备份这个话题感兴趣，可以看看我的另外一篇博客：<a href="https://blog.musnow.top/posts/3543423459/?f=minio">谈谈如何进行有效数据备份，3+2+1</a></p><blockquote><p>温馨提醒：如果你想在<strong>云服务器</strong>上安装minio来备份已有S3中的文件的话，最好是使用一个和已有S3<strong>不在同一个地域、非同一个服务商</strong>的云服务器，避免某些服务商云服务器和对象存储一起boom的情况……</p></blockquote><h1 id="2-docker安装minio"><a href="#2-docker安装minio" class="headerlink" title="2.docker安装minio"></a>2.docker安装minio</h1><h2 id="2-1-安装docker"><a href="#2-1-安装docker" class="headerlink" title="2.1 安装docker"></a>2.1 安装docker</h2><p>docker安装的教程详见我的另外一篇博客</p><p><a href="https://blog.musnow.top/posts/2069190154/?f=minio">【Docker】deepin&#x2F;centos安装docker | 慕雪的寒舍</a></p><h2 id="2-2-安装minio"><a href="#2-2-安装minio" class="headerlink" title="2.2 安装minio"></a>2.2 安装minio</h2><p>这里推荐使用由VMware维护的minio docker版本<code>bitnami/minio</code>，更新很频繁。</p><p><a href="https://hub.docker.com/r/bitnami/minio">hub.docker.com&#x2F;r&#x2F;bitnami&#x2F;minio</a></p><p>创建容器的命令如下，非常简单</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">docker run -it -d --name minio \</span><br><span class="line">-p 9000:9000 \</span><br><span class="line">-p 9001:9001 \</span><br><span class="line">--restart=always \</span><br><span class="line">-v /minio/data:/bitnami/minio/data \</span><br><span class="line">-e MINIO_ROOT_USER=<span class="string">&quot;minio_root&quot;</span> \</span><br><span class="line">-e MINIO_ROOT_PASSWORD=<span class="string">&quot;minio_123456&quot;</span> \</span><br><span class="line">-e TZ=<span class="string">&#x27;Asia/Shanghai&#x27;</span> \</span><br><span class="line">bitnami/minio:latest</span><br></pre></td></tr></table></figure><p>该创建容器操作基于如下hash的docker镜像（更新于2023-12-12），创建容器的命令后续可能会有变动，请参考docker-hub中的官方文档</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bitnami/minio  latest    552af9bd3d6d   2 days ago     212MB</span><br></pre></td></tr></table></figure><p>对这个docker命令进行解释</p><ul><li><code>-it -d</code>，it提供交互能力，d代表后台运行</li><li><code>--restart=always</code>，始终重启docker（docker服务重启后，镜像会自动启动）</li><li><code>-p 9000:9000</code>，将docker内的9000端口（右侧）映射给宿主机（左侧）的9000端口，端口9001的映射同理。<ul><li>容器内9000端口是minio的api端口（用于S3协议操作）</li><li>容器内9001端口是minio的web管理界面端口</li><li>根据你的需要，修改<strong>冒号左侧</strong>的宿主机端口即可。</li></ul></li><li><code>-v /minio/data:/bitnami/minio/data</code>，将docker内<code>/bitnami/minio/data</code>路径映射给主机<code>/minio/data</code>路径，主机上的路径（左侧）请自行修改；这个路径是bucket和minio配置文件的存储路径。</li><li>两个<code>-e</code>设置的是环境变量，分别设置的是minio管理员的账户和管理员的密码。请注意，在这里配置了管理员用户名和密码后，<strong>进入minio管理系统的密码无法被修改</strong>。如果你的minio服务需要暴露在公网上，请一定要设置一个<strong>高强度</strong>的密码！</li><li><code>-e TZ=&#39;Asia/Shanghai&#39;</code> 设置时区为东八区（后续定时备份需要有正确时区）</li><li>最后的<code>bitnami/minio:latest</code>代表我们需要创建<code>bitnami/minio</code>这个docker镜像的latest版本，如果本地没有这个镜像，则会自动去docker-hub拉取。</li><li>如果你卡在了pull镜像的步骤，请自行百度如何<a href="https://blog.musnow.top/posts/2069190154/?f=minio">替换docker的镜像源</a>。</li></ul><p>如下是我在一个没有安装过minio的云服务上测试的结果，成功安装并启动minio</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">[root:~/docker]# docker run -it -d --name minio \</span><br><span class="line">&gt; -p 19000:9000 \</span><br><span class="line">&gt; -p 19001:9001 \</span><br><span class="line">&gt; --restart=always \</span><br><span class="line">&gt; -v /root/docker/minio:/bitnami/minio/data \</span><br><span class="line">&gt; -e MINIO_ROOT_USER=&quot;minio_root&quot; \</span><br><span class="line">&gt; -e MINIO_ROOT_PASSWORD=&quot;minio_123456&quot; \</span><br><span class="line">&gt; bitnami/minio:latest</span><br><span class="line">Unable to find image &#x27;bitnami/minio:latest&#x27; locally</span><br><span class="line">latest: Pulling from bitnami/minio</span><br><span class="line">ef5975039511: Pull complete </span><br><span class="line">Digest: sha256:3bb81d101dea57a5382a2d01eda6991e75ce69669d2d49c4646d82721b7c258e</span><br><span class="line">Status: Downloaded newer image for bitnami/minio:latest</span><br><span class="line">afefbb9514de0f4a1c02b7f4212b1e05eee5ef342ed4ce27e03de10071914060</span><br></pre></td></tr></table></figure><p>容器正常启动，处于Running状态，STATUS正常！</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">CONTAINER ID   IMAGE                                  COMMAND                  CREATED         STATUS         PORTS                                                                                      NAMES</span><br><span class="line">afefbb9514de   bitnami/minio:latest                   &quot;/opt/bitnami/script…&quot;   3 minutes ago   Up 3 minutes   0.0.0.0:19000-&gt;9000/tcp, :::19000-&gt;9000/tcp, 0.0.0.0:19001-&gt;9001/tcp, :::19001-&gt;9001/tcp   minio</span><br></pre></td></tr></table></figure><p>这样还不够，请在后续创建了bucket并上传测试文件后，查看本地映射的路径中是否有对应文件夹和文件，<strong>避免路径映射失败</strong>！（如果路径没有成功映射到本地，那么你当前创建的minio被删除之后，文件就很难找回来了）</p><blockquote><p>顺带一提，在我这边测试发现，如果你错误使用浏览器访问了9000这个api端口，会被自动重定向到9001 web管理页面端口（前提是映射的宿主机端口和docker内端口一致）</p></blockquote><h2 id="2-3-web管理"><a href="#2-3-web管理" class="headerlink" title="2.3 web管理"></a>2.3 web管理</h2><p>使用 <code>http://IP:端口</code> 打开minio的9001端口对应的宿主机端口，访问minio的web管理页面。输入刚刚创建容器时，在环境变量里面配置的用户名和密码进行登录，即可进入控制台。</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2023/12/8ab832241e5ea9a14713e75fb56c2df0.png" alt="image.png"></p><p>minio的界面比较简单，基本要做的操作只有两个，创建bucket存储桶，和accesskey用于api调用。</p><blockquote><p>更高阶的配置项和操作我没有尝试过，请自行参考minio的文档或者其他教程。</p></blockquote><h3 id="2-3-1-创建bucket"><a href="#2-3-1-创建bucket" class="headerlink" title="2.3.1 创建bucket"></a>2.3.1 创建bucket</h3><p>第一个界面就是大大的Object Browser，在这里我们可以创建存储桶</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2023/12/df27f17b80655b3107ef12018f180712.png" alt="image.png"></p><p>点击创建bucket，会进入如下配置项，除了bucket的名字，还有三个选项</p><ul><li>Versioning：版本控制，开启后，该bucket将处于多版本模式下，文件会保留修改的历史记录。</li><li>Object Locking：避免文件被删除，需要支持保留和合法保留（这两个啥意思我不明白），该选项只能在bucket创建时打开。</li><li>Quota：限制容器中文件大小（总容量）</li></ul><p>对于我的备份需求来说，这三个额外选项都不需要，直接创建就行了</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2023/12/c7b5efc573e9e3691f0237a6e9d7357a.png" alt="image.png"></p><p>创建之后，在bucket页面可以看到刚刚创建的test存储桶，这里会统计存储容量和文件数量</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2023/12/01016c16a27570ded8d93a7aa4781a1f.png" alt="image-20231213232421462"></p><h3 id="2-3-2-创建accessKey"><a href="#2-3-2-创建accessKey" class="headerlink" title="2.3.2 创建accessKey"></a>2.3.2 创建accessKey</h3><p>accessKey是用于操作api的token凭证。创建完毕后，他只会显示一次，后续将不会显示出来。</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2023/12/7413b4978a8916f3ba34043afa034e7f.png" alt="image.png"></p><p>如果你不想创建太多个密钥，那就把这个密钥的文件下载下来，免得到时候不知道是什么了。点击右下角的import文件就可以下载，会下载一个<code>json</code>文件，内部包含密钥和其他一些相关信息</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2023/12/c06b9cd5866f9b3d9a2f37e0ded15404.png" alt="image.png"></p><p>因为我这只是做个测试，一会就会把这个minio的docker删除，所以展示密钥无所谓。如果你是在生产环境下使用，请一定不要暴露你的密钥给任何人。</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;url&quot;</span><span class="punctuation">:</span> <span class="string">&quot;http://公网IP:19001/api/v1/service-account-credentials&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;accessKey&quot;</span><span class="punctuation">:</span> <span class="string">&quot;aXpBxrUceV30Id6gOouG&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;secretKey&quot;</span><span class="punctuation">:</span> <span class="string">&quot;dIWl9IFL05UtaI08PZfPXE66zPGu2zWrGFfSTaUm&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;api&quot;</span><span class="punctuation">:</span> <span class="string">&quot;s3v4&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;path&quot;</span><span class="punctuation">:</span> <span class="string">&quot;auto&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>密钥创建完毕，就能在列表看到它。</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2023/12/d70adb75c6ec74a362a065e9afc88092.png" alt="image.png"></p><h1 id="3-rclone备份"><a href="#3-rclone备份" class="headerlink" title="3.rclone备份"></a>3.rclone备份</h1><p>rclone是一个全平台的命令行工具，其可以用于多种云端&#x2F;本地存储之间的数据拷贝、同步、加密同步等功能。详见rclone官网：<a href="https://rclone.org/">rclone.org</a></p><p>因为我的目标就是我的七牛云bucket里面的图床文件备份到本地，rclone绝对是不二之选。</p><h2 id="3-1-进入docker容器内终端"><a href="#3-1-进入docker容器内终端" class="headerlink" title="3.1 进入docker容器内终端"></a>3.1 进入docker容器内终端</h2><p>你可以选择在<strong>宿主机</strong>上安装rclone，也可以选择直接在minio的容器内安装rclone。</p><p>前排提醒：部分nas品牌的系统（比如群晖）已经提供了<strong>执行定时脚本</strong>的功能，这种情况下直接使用系统提供的定时任务来执行<code>rclone sync</code>即可，<strong>即直接在nas里面安装rclone和使用定时任务</strong>，不要在minio的docker里面安装rclone。</p><p>如你选择了在宿主机上安装rclone，则可以直接<strong>跳过本3.1步骤</strong>，阅读3.2及后续步骤</p><h3 id="docker特权模式"><a href="#docker特权模式" class="headerlink" title="docker特权模式"></a>docker特权模式</h3><p>注意，如果在minio的容器内安装rclone，那么minio容器被删除后，<strong>rclone和它的配置文件自然也不在了</strong>。</p><p><strong>且如果需要用minio的容器进行crontab定时任务</strong>，则必须用<strong>特权模式</strong>安装minio的docker，在minio的docker创建命令里面加如下这条，设置特权模式（不需要定时任务可以不设置）。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">--privileged</span><br></pre></td></tr></table></figure><p>在绿联nas的docker管理界面，创建docker的时候给定所有权限，也是一样的效果。（因为我不太了解这里具体每个权限的作用，干脆全给了）</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2023/12/accf78ec16b7e73aec583e3672291e37.png" alt="image.png"></p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2023/12/e96098feea2769aa014db319b74bff58.png" alt="image.png"></p><h3 id="ssh连接宿主设备"><a href="#ssh连接宿主设备" class="headerlink" title="ssh连接宿主设备"></a>ssh连接宿主设备</h3><p>不同nas机型进入ssh的方式不太一样，请参考你的nas或设备品牌搜索对应类型教程。</p><p><strong>连接到宿主设备的ssh后</strong>，参考：<a href="https://www.cnblogs.com/langgeligelang/p/13628821.html">以指定用户启动和进入docker容器 - langyong - 博客园</a> 一文，使用如下docker命令进入minio的容器终端中。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker <span class="built_in">exec</span> -it -u 用户名 容器名 /bin/bash</span><br><span class="line"><span class="comment"># 示例如下</span></span><br><span class="line">docker <span class="built_in">exec</span> -it -u root minio /bin/bash</span><br></pre></td></tr></table></figure><p>如果你使用的是绿联、极空间这类不太方便进入ssh的nas，可以在nas的docker管理页里面操作，如下图所示，选择<code>/bin/bash</code>后点击链接即可进入容器内终端。</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/20231214091932.png" alt="image.png"></p><h2 id="3-2-下载安装rclone"><a href="#3-2-下载安装rclone" class="headerlink" title="3.2 下载安装rclone"></a>3.2 下载安装rclone</h2><p>进入终端后，默认所在路径是docker容器的工作路径<code>/opt/bitnami/minio-client</code>。</p><p>为了避免影响容器运行，我们不要在工作路径里面做操作，请使用如下命令，创建一个新的rclone文件夹，进入root用户的家目录进行操作。</p><p>如果你是在宿主机上操作，也是一样的道理，为rclone单独创建一个文件夹，来存放它的软件包、配置文件、执行日志。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mkdir /root/rclone</span><br><span class="line">cd /root/rclone</span><br></pre></td></tr></table></figure><blockquote><p>如果是docker内操作，你可以在创建minio容器的时候，就把<code>/root/rclone</code>路径给映射到宿主机上，方便后续查看rclone备份的日志。</p></blockquote><p>下载安装rclone的命令如下</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">curl -O https://downloads.rclone.org/rclone-current-linux-amd64.zip</span><br><span class="line">unzip rclone-current-linux-amd64.zip</span><br><span class="line"><span class="built_in">cd</span> rclone-*-linux-amd64</span><br><span class="line"> </span><br><span class="line">sudo <span class="built_in">cp</span> rclone /usr/bin/</span><br><span class="line">sudo <span class="built_in">chown</span> root:root /usr/bin/rclone</span><br><span class="line">sudo <span class="built_in">chmod</span> 755 /usr/bin/rclone</span><br></pre></td></tr></table></figure><p>minio的docker内没有unzip命令，需要安装一下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apt-get update &amp;&amp; apt-get install -y unzip</span><br></pre></td></tr></table></figure><p>minio的docker内也没有sudo，将上述安装命令中的sudo去掉就可以了。</p><p>完成安装命令后，执行一下<code>rclone</code>，出现rclone命令的使用提示，那就是安装成功了！</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">root@878a0dd03ec4:/root/rclone/rclone-v1.65.0-linux-amd64# rclone</span><br><span class="line">Usage:</span><br><span class="line">  rclone [flags]</span><br><span class="line">  rclone [command]</span><br><span class="line">  ...</span><br></pre></td></tr></table></figure><h2 id="3-3-rclone对象存储配置"><a href="#3-3-rclone对象存储配置" class="headerlink" title="3.3 rclone对象存储配置"></a>3.3 rclone对象存储配置</h2><p>rclone的官网上有不同云端存储协议和不同S3服务商的配置教程，跟着官方的来就可以了。</p><p>执行<code>rclone config</code>命令，工具会自动在<code>/.config/rclone/rclone.conf</code>下创建一个config文件，你可以根据<a href="https://rclone.org/">官方的向导</a>，在此处添加新的remote;</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">root@878a0dd03ec4:/root/rclone/rclone-v1.65.0-linux-amd64# rclone config</span><br><span class="line">2023/12/14 04:38:44 NOTICE: Config file &quot;/.config/rclone/rclone.conf&quot; not found - using defaults</span><br><span class="line">No remotes found, make a new one?</span><br><span class="line">n) New remote</span><br><span class="line">s) Set configuration password</span><br><span class="line">q) Quit config</span><br><span class="line">n/s/q&gt; q</span><br></pre></td></tr></table></figure><p>下面给出minio和七牛云的配置文件，你可以直接修改这个配置文件中的内容为你的配置，然后写入<code>/.config/rclone/rclone.conf</code>即可。</p><ul><li><a href="https://rclone.org/s3/#minio">rclone.org&#x2F;s3&#x2F;#minio</a></li><li><a href="https://rclone.org/s3/#qiniu">rclone.org&#x2F;s3&#x2F;#qiniu</a></li></ul><p>其中minio的region在minio的控制台里面可以修改，如果你没有修改过，默认使用的是<code>us-east-1</code>。因为rclone是直接在minio的docker里面执行的，所以endpoint只需要写成<code>127.0.0.1</code>和minio的api端口9000就可以了。</p><p>如果你的minio在公网或者其他设备上，请修改对应的IP地址和端口。</p><p>七牛云的region和endpoint在<strong>七牛云bucket页面</strong>找到<strong>S3域名</strong>就可以看到。</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2023/12/64d88c8052b653bb69edbed3d75fdca5.png" alt="image.png"></p><blockquote><p>请注意，七牛云&#x2F;阿里云这类存储服务商，如果你有多个bucket，且他们的地域不一样，则需要新增对应地域的配置项。通过修改<code>[]</code>里面的<strong>配置名</strong>进行区分。</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">[minio]</span><br><span class="line">type = s3</span><br><span class="line">provider = Minio</span><br><span class="line">env_auth = false</span><br><span class="line">access_key_id = 控制台获取的key_id</span><br><span class="line">secret_access_key = 控制台获取的secret_key</span><br><span class="line">region = us-east-1</span><br><span class="line">endpoint = http://127.0.0.1:9000</span><br><span class="line">location_constraint =</span><br><span class="line">server_side_encryption =</span><br><span class="line"></span><br><span class="line">[qiniu]</span><br><span class="line">type = s3</span><br><span class="line">provider = Qiniu</span><br><span class="line">access_key_id = 七牛云控制台获取key_id</span><br><span class="line">secret_access_key = 七牛云控制台获取secret_key</span><br><span class="line">region = cn-east-1</span><br><span class="line">endpoint = s3-cn-east-1.qiniucs.com</span><br><span class="line">location_constraint = cn-east-1</span><br><span class="line">acl = private</span><br><span class="line">storage_class = STANDARD</span><br></pre></td></tr></table></figure><p>执行如下命令，安装nano编辑器，然后使用nano编辑器打开rclone配置文件进行编辑。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">apt-get update &amp;&amp; apt-get install -y nano</span><br><span class="line">nano /.config/rclone/rclone.conf</span><br></pre></td></tr></table></figure><p>linux下的粘贴命令是<code>CTRL+SHIFT+V</code>或<code>CTRL+INSERT</code>，你可以在本地修改了配置文件后，通过nano编辑器，直接粘贴到docker容器内。编辑完毕后，使用<code>CTRL+X</code>退出nano的编辑模式，并按Y确认保存，随后直接回车，即完成编辑。</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2023/12/f82a30d9349cb55e60bc621dc2264be3.png" alt="image.png"></p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2023/12/283ab6851395ecf722d287aa06a8de0b.png" alt="image.png"></p><p>这个配置文件建议备份一个，免得每次都得重新弄</p><h2 id="3-4-rclone基本命令"><a href="#3-4-rclone基本命令" class="headerlink" title="3.4 rclone基本命令"></a>3.4 rclone基本命令</h2><h3 id="copy"><a href="#copy" class="headerlink" title="copy"></a>copy</h3><p>拷贝命令如下，配置名称是在config文件中<code>[]</code>里面的文字，桶名就是你的S3服务里面的对象存储桶，还可以在桶名后面用<code>/</code>来追加指定上传的路径。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">rclone copy 本地文件路径 配置名称:桶名</span><br><span class="line">rclone copy 本地文件路径 配置名称:桶名/桶内目录</span><br></pre></td></tr></table></figure><p>这里我在docker内创建了一个<code>test.txt</code>文件，尝试将其拷贝到minio里面。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">touch test.txt</span><br><span class="line">rclone copy ./test.txt minio:1panel-bak</span><br></pre></td></tr></table></figure><p>命令没有错误输出，即拷贝成功！</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">root@878a0dd03ec4:/root/rclone# touch test.txt</span><br><span class="line">root@878a0dd03ec4:/root/rclone# rclone copy ./test.txt minio:1panel-bak</span><br><span class="line">root@878a0dd03ec4:/root/rclone# </span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2023/12/bcd922882c21dbe6aa3e8aeb67fe08fa.png" alt="image.png"></p><p>尝试在拷贝的时候指定远端仓库内的路径</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rclone copy ./test.txt minio:qiniu-muxue-sy/test</span><br></pre></td></tr></table></figure><p>成功指定，文件被上传到了test文件夹里面。</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/20231214133906.png" alt="image.png"></p><h3 id="sync"><a href="#sync" class="headerlink" title="sync"></a>sync</h3><p>备份命令如下，可以在任意目的地（本地-远端，远端-本地，远端-远端）里面执行这个命令，左侧是源路径，右侧是目标。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">rclone sync 本地源文件路径  目的地配置名称:桶名 </span><br><span class="line">rclone sync 源配置名称:桶名 目的地配置名称:桶名</span><br><span class="line">rclone sync 源配置名称:桶名 目的地的本地文件路径</span><br></pre></td></tr></table></figure><p>rclone sync有两个常用的选项，刚开始使用的时候，建议带上 <code>--dry-run</code> 命令来确认自己的配置没有问题</p><ul><li><code>-P</code> 显示详细同步进度条</li><li><code>--dry-run</code> 用作命令测试，不会真正的执行同步</li></ul><p>指定<code>-P</code>命令后的进度输出如下，可以看到实时网速和文件数量&#x2F;大小。</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/20231214133932.png" alt="image.png"></p><p>目前发现的问题是minio显示的文件总量和数据存储量会<strong>有一定滞后</strong>，刚开始我还以为是rclone没有跑完呢，sync完毕过了几分钟minio里面才刷出正确的文件数量来。</p><h2 id="3-5-cron定时同步"><a href="#3-5-cron定时同步" class="headerlink" title="3.5 cron定时同步"></a>3.5 cron定时同步</h2><p>前排提醒：部分nas品牌的系统（比如群晖）已经提供了<strong>执行定时脚本</strong>的功能，这种情况下直接使用系统提供的定时任务来执行<code>rclone sync</code>即可，无序安装其他服务。<strong>即直接在nas里面安装rclone和使用定时任务</strong>，不要在minio的docker里面安装rclone和cron。</p><ul><li>群晖官网关于定时任务的说明： <a href="https://kb.synology.cn/zh-cn/DSM/help/DSM/AdminCenter/system_taskscheduler?version=6">https://kb.synology.cn/zh-cn/DSM/help/DSM/AdminCenter/system_taskscheduler?version=6</a></li><li>绿联nas的环境中已有crontab，但我没有试过使用它。考虑到绿联这个nas的系统还是一点都不稳定，还是别动它的系统里面的东西了，不知道绿联官方有没有可能把定时任务加到控制页里面去吧（我估计是没戏，这个系统的限制太多了）。</li></ul><p>如果你使用的是群晖、威联通等提供了执行定时任务的功能的nas，请在nas内配置好rclone后，自行百度执行定时任务相关教程。</p><h3 id="minio-docker内安装cron服务"><a href="#minio-docker内安装cron服务" class="headerlink" title="minio docker内安装cron服务"></a>minio docker内安装cron服务</h3><p>下面介绍在minio的docker内cron服务的安装和使用。</p><p>在minio的docker里面直接安装crontab服务和nano文本编辑器</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">apt-get update</span><br><span class="line">apt-get install -y cron nano</span><br></pre></td></tr></table></figure><p>但这还不够，cron服务的运行还依赖于其他组件，需要一并安装。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">apt-get install -y rsyslog  postfix</span><br><span class="line">service rsyslog start</span><br></pre></td></tr></table></figure><p>安装postfix的时候会提示让你选择配置文件，键入1选择无配置就够了。</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2023/12/934acd2b8c197729473f9d2a917740ca.png" alt="image.png"></p><p>postfix还需要额外配置，否则可能会遇到如下错误</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Dec 16 01:07:01 878a0dd03ec4 postfix/sendmail[1859]: fatal: open /etc/postfix/main.cf: No such file or directory</span><br><span class="line">Dec 16 01:12:02 878a0dd03ec4 postfix/postdrop[1912]: warning: unable to look up public/pickup: No such file or directory</span><br></pre></td></tr></table></figure><p>配置命令如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">touch /etc/postfix/main.cf</span><br><span class="line">mkfifo /var/spool/postfix/public/pickup</span><br></pre></td></tr></table></figure><h3 id="crontab配置定时任务测试"><a href="#crontab配置定时任务测试" class="headerlink" title="crontab配置定时任务测试"></a>crontab配置定时任务测试</h3><p>安装完毕后，使用<code>crontab -e</code>看看是否能打开crontab的配置编辑页面，如果可以打开如下配置界面，则代表cron安装成功。</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/20231214111457.png" alt="image.png"></p><p>这个配置文件需要写入的格式如下，一行对应一个配置。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">五位cron表达式 需要执行的命令</span><br></pre></td></tr></table></figure><p>cron表达式可以用在线工具<a href="https://tool.lu/crontab/">crontab执行时间计算 - 在线工具</a></p><p>先用如下的配置来检测cron服务是否能正常运行，以及是否能成功输出日志</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">*/1 * * * * echo &quot;$(date) This is a test command&quot; &gt;&gt; /root/rclone/log.txt</span><br></pre></td></tr></table></figure><p>该配置的含义是每分钟执行一次echo命令，打印当前时间和对应内容到<code>/root/rclone/log.txt</code>文件中。</p><p>修改了配置文件后，启动cron服务，测试我们的配置是否有效，cron服务是否能正常运行。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">service cron start </span><br></pre></td></tr></table></figure><p>该命令执行效果如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">root@878a0dd03ec4:/root/rclone# service cron start</span><br><span class="line">Starting periodic command scheduler: cron.</span><br></pre></td></tr></table></figure><p>等待数分钟，看看cron命令是否成功输出内容到指定文件里面了，有内容则代表配置和运行成功！默认情况下，<strong>使用cron执行的echo命令内的date</strong>采用了<strong>UTC时间</strong>的输出，但这并不影响我们的使用，给小时加8就能得到东八区的时间了。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">root@878a0dd03ec4:/root/rclone# cat /root/rclone/log.txt</span><br><span class="line">Sat Dec 16 01:18:01 UTC 2023 This is a test command</span><br><span class="line">Sat Dec 16 01:18:01 UTC 2023 This is a test command</span><br><span class="line">Sat Dec 16 01:19:01 UTC 2023 This is a test command</span><br><span class="line">Sat Dec 16 01:19:01 UTC 2023 This is a test command</span><br></pre></td></tr></table></figure><p>在syslog里面也能看到cron的服务日志，该服务日志组件依赖于先前安装的rsyslog</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat /var/log/syslog</span><br></pre></td></tr></table></figure><p>文件<code>/var/log/syslog</code>内部cron执行日志如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Dec 16 01:25:01 878a0dd03ec4 CRON[2059]: (root) CMD (echo &quot;$(date) This is a test command&quot; &gt;&gt; /root/rclone/log.txt)</span><br><span class="line">Dec 16 01:25:01 878a0dd03ec4 CRON[2058]: (root) CMD (echo &quot;$(date) This is a test command&quot; &gt;&gt; /root/rclone/log.txt)</span><br></pre></td></tr></table></figure><blockquote><p>请注意，默认情况下，minio的docker是<strong>没有时区配置</strong>的，请一定要在创建docker容器的时候，使用<strong>TZ环境变量</strong>来设置时区，否则crontab不会执行！<br>原因也很简单，cron表达式有一个指定时间，比如每周一执行、几点执行，如果没有配置时区，cron没有办法明确你的cron表达式到底应该什么时候跑，干脆就不跑了！</p></blockquote><p>如果你的docker已经创建，不想重新创建，可以通过修改配置文件来设置时区，修改后重启docker容器即可。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">nano /etc/environment</span><br><span class="line"># 在文件末尾写入如下内容</span><br><span class="line">TZ=&#x27;Asia/Shanghai&#x27;</span><br></pre></td></tr></table></figure><h3 id="crontab配置定时rclone-sync"><a href="#crontab配置定时rclone-sync" class="headerlink" title="crontab配置定时rclone sync"></a>crontab配置定时rclone sync</h3><p>确认cron服务可用，就可以来配置rclone sync的自动执行命令了。</p><p>对于rclone的sync备份而言，写入如下内容即可；</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">0 3 * * 1,5 rclone sync qiniu-e1:muxue-sy  minio:qiniu-muxue-sy &gt;&gt; /root/rclone/rclone.log 2&gt;&amp;1</span><br><span class="line">0 2 * * 1,5 rclone sync qiniu-e2:muxue-img  minio:qiniu-muxue-img &gt;&gt; /root/rclone/rclone.log 2&gt;&amp;1</span><br></pre></td></tr></table></figure><p>解析如下</p><ul><li><code>0 3 * * 1,5</code> 代表每周一和周五的凌晨3点执行一次</li><li><code>0 2 * * 1,5</code> 代表每周一和周五的凌晨2点执行一次</li><li><code>&gt;&gt; /root/rclone/rclone.log 2&gt;&amp;1</code> 代表将rclone命令的输出结果写入到 <code>/root/rclone/rclone.log</code> 文件中。</li></ul><p>因为我对备份的频次要求不高，一周备份两次就够了。</p><p>写入完毕后，<code>CTRL+X</code>关闭nano编辑模式，按Y和回车即完成nano编辑。编辑完成后会有如下输出。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">root@878a0dd03ec4:/root/rclone# crontab -e</span><br><span class="line">no crontab for root - using an empty one</span><br><span class="line">crontab: installing new crontab</span><br></pre></td></tr></table></figure><p>后续crontab执行的命令结果都会输入到<code>/root/rclone/rclone.log</code>日志文件中。rclone命令只有在出现ERROR的时候才会输出。如果这个文件里面什么都么有，就代表运行没有出错！</p><p>配置好了之后，使用如下命令重新启动cron服务</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">service cron restart</span><br></pre></td></tr></table></figure><p>用如下命令查看cron服务状态</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">root@878a0dd03ec4:/root/rclone# service cron status</span><br><span class="line">cron is running.</span><br></pre></td></tr></table></figure><h3 id="优化cron日志"><a href="#优化cron日志" class="headerlink" title="优化cron日志"></a>优化cron日志</h3><p>为了让日志更加合理，可以在执行rclone命令之前，打印当前时间，这样可以知道crontab到底有没有正常执行定时任务。</p><p>打印时间的基本命令如下，echo命令会将当前时间和相关的说明信息写入<code>test.txt</code>文件中</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo &quot;$(date) This is a test command&quot; &gt;&gt; test.txt</span><br></pre></td></tr></table></figure><p>执行效果如下，打印了时间和对应的日志信息</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">root@878a0dd03ec4:/root/rclone# echo &quot;$(date) This is a test command&quot; &gt;&gt; test.txt</span><br><span class="line">root@878a0dd03ec4:/root/rclone# cat test.txt</span><br><span class="line">Sat Dec 16 09:36:06 CST 2023 This is a test command</span><br></pre></td></tr></table></figure><blockquote><p>再次提醒，minio的docker内<strong>必须指定TZ环境变量</strong>，否则crontab不会执行！且date命令时区和东八区不符。</p></blockquote><p>echo打印的时候，可以临时指定TZ环境变量来打印不同时区的date</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo &quot;$(TZ=&#x27;Asia/Shanghai&#x27; date) 这是东八区&quot; &gt;&gt; test.txt</span><br></pre></td></tr></table></figure><p>执行效果如下，因为我的docker内已经设置了TZ环境变量为东八区，所以不加这个TZ也是打印的东八区的时间。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">root@878a0dd03ec4:/root/rclone# echo &quot;$(TZ=&#x27;Asia/Shanghai&#x27; date) 这是东八区&quot; &gt;&gt; test.txt</span><br><span class="line">root@878a0dd03ec4:/root/rclone# cat test.txt</span><br><span class="line">Sat Dec 16 09:36:06 CST 2023 This is a test command</span><br><span class="line">Sat Dec 16 09:37:39 CST 2023 这是东八区</span><br></pre></td></tr></table></figure><p>但是需要注意的是，使用cron命令执行的时候，它依旧会打印UTC时间，前文已经提到过了。</p><p>将原本的crontab命令改成如下形式（<code>crontab -e</code>编辑配置文件），使用<code>&amp;&amp;</code>来链接echo和rclone命令，这样在每次执行rclone之前都会有一个当前时间和sync的是什么内容的的输出，能让我们知道crontab是否正常执行。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">0 3 * * 1,5 echo &quot;$(TZ=&#x27;Asia/Shanghai&#x27; date) sync muxue-sy&quot; &gt;&gt; /root/rclone/rclone.log &amp;&amp; rclone sync qiniu-e1:muxue-sy  minio:qiniu-muxue-sy &gt;&gt; /root/rclone/rclone.log 2&gt;&amp;1</span><br><span class="line"></span><br><span class="line">0 2 * * 1,5 echo &quot;$(TZ=&#x27;Asia/Shanghai&#x27; date) sync muxue-img&quot; &gt;&gt; /root/rclone/rclone.log &amp;&amp; rclone sync qiniu-e2:muxue-img  minio:qiniu-muxue-img &gt;&gt; /root/rclone/rclone.log 2&gt;&amp;1</span><br></pre></td></tr></table></figure><p>你可以修改cron表达式为<code>*/1 * * * *</code>，让crontab表达式立即执行一次，确认一下输出是否正确，以及rclone命令是否正常执行。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">*/1 * * * * echo &quot;$(date) sync muxue-img&quot; &gt;&gt; /root/rclone/rclone.log &amp;&amp; rclone sync qiniu-e2:muxue-img  minio:qiniu-muxue-img &gt;&gt; /root/rclone/rclone.log 2&gt;&amp;1</span><br></pre></td></tr></table></figure><p>我的测试结果如下，rclone sync成功被cron执行（这个ERROR是因为我的bucket里面有个无效的文件，正常情况下应该不会有ERROR）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Sat Dec 16 01:45:01 UTC 2023 sync muxue-img</span><br><span class="line">2023/12/16 01:45:02 ERROR : : Entry doesn&#x27;t belong in directory &quot;&quot; (same as directory) - ignoring</span><br></pre></td></tr></table></figure><p>测试结束后，<strong>记得还原配置项</strong>。</p><p>每次修改配置文件后，都需要重启cron服务！</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">root@878a0dd03ec4:/root/rclone# service cron restart</span><br><span class="line">Restarting periodic command scheduler: cronStopping periodic command scheduler: cron.</span><br><span class="line">Starting periodic command scheduler: cron.</span><br></pre></td></tr></table></figure><h3 id="centos安装cron"><a href="#centos安装cron" class="headerlink" title="centos安装cron"></a>centos安装cron</h3><p>在centos中安装cron的命令不同</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">yum install -y vixie-cron </span><br><span class="line">yum install -y crontabs</span><br></pre></td></tr></table></figure><p>启动crontab</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">systemctl start crond <span class="comment"># 启动cron服务</span></span><br><span class="line">systemctl <span class="built_in">enable</span> crond <span class="comment"># 设置开机自启</span></span><br><span class="line">systemctl status crond <span class="comment"># cron服务状态</span></span><br><span class="line">systemctl restart crond <span class="comment"># 重启cron</span></span><br></pre></td></tr></table></figure><p>cron配置的其余操作和上文相同，都是用<code>crontab -e</code>编辑配置文件。</p><p>因为我这个是一个云服务器的完整centos系统，所以也不需要安装<code>rsyslog postfix</code> 这两个包。</p><h1 id="The-end"><a href="#The-end" class="headerlink" title="The end"></a>The end</h1><p>本文的教程结束，有问题欢迎在评论区提出。</p><p>数据无价，多一份备份，多一份安心</p>]]></content>
    
    
    <summary type="html">docker部署minio对象存储并用rclone同步</summary>
    
    
    
    <category term="docker真好玩" scheme="https://blog.musnow.top/categories/docker%E7%9C%9F%E5%A5%BD%E7%8E%A9/"/>
    
    
    <category term="docker" scheme="https://blog.musnow.top/tags/docker/"/>
    
  </entry>
  
  <entry>
    <title>【MySQL】wsl的ubuntu中无法systemctl启动mariadb（已解决）</title>
    <link href="https://blog.musnow.top/posts/1382619221/"/>
    <id>https://blog.musnow.top/posts/1382619221/</id>
    <published>2023-12-13T09:52:14.000Z</published>
    <updated>2023-12-13T09:52:14.000Z</updated>
    
    <content type="html"><![CDATA[<p>这是GPT的答案，实测有效。</p><p>如果您在启动 MariaDB 时遇到 <code>&quot;Failed to start mariadb.service: Interactive authentication required&quot; </code>错误，这是因为在 Ubuntu 22.04 上默认启用了 systemd 的用户会话限制，需要进行一些额外的步骤来解决该问题。以下是解决方法：</p><p>打开终端，并使用以下命令编辑 MariaDB 的服务文件：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo nano /lib/systemd/system/mariadb.service</span><br></pre></td></tr></table></figure><p>在文件的 <code>[Service]</code> 部分中添加一个新的行，内容如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[Service]</span><br><span class="line">...</span><br><span class="line">...</span><br><span class="line">ExecStartPre=/bin/sh -c <span class="string">&#x27;touch /etc/mysql/mariadb.conf.d/.interactive&#x27;</span></span><br></pre></td></tr></table></figure><p>确保在 <code>[Service]</code> 部分内的其他行之后添加此行。</p><p>保存并关闭文件（在 Nano 编辑器中按 Ctrl+X，然后按 Y 确认保存）。</p><p>运行以下命令重新加载 systemd 配置：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo systemctl daemon-reload</span><br></pre></td></tr></table></figure><p>现在，您可以启动 MariaDB 服务：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo systemctl start mariadb</span><br></pre></td></tr></table></figure><p>这次启动应该没有出现 “Interactive authentication required” 错误。</p><p>最后，您可以设置 MariaDB 在系统启动时自动启动：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo systemctl enable mariadb</span><br></pre></td></tr></table></figure><p>现在，您应该能够成功启动和运行 MariaDB 服务了。如果您仍然遇到问题，请确保按照上述步骤操作，并仔细检查所做的更改是否正确。</p>]]></content>
    
    
    <summary type="html">wsl的ubuntu中无法systemctl启动mariadb问题解决</summary>
    
    
    
    <category term="学习sql" scheme="https://blog.musnow.top/categories/%E5%AD%A6%E4%B9%A0sql/"/>
    
    
    <category term="Linux" scheme="https://blog.musnow.top/tags/Linux/"/>
    
    <category term="mysql" scheme="https://blog.musnow.top/tags/mysql/"/>
    
  </entry>
  
  <entry>
    <title>【Linux】wsl虚拟机时间和实际时间不符合</title>
    <link href="https://blog.musnow.top/posts/1339169411/"/>
    <id>https://blog.musnow.top/posts/1339169411/</id>
    <published>2023-12-12T01:30:55.000Z</published>
    <updated>2023-12-12T01:31:55.000Z</updated>
    
    <content type="html"><![CDATA[<p>偶然遇到了这个问题，触发原因是电脑在开启wsl的情况下进入了<code>休眠</code>模式，且在无网络情况下几天不使用。</p><p>然后开启wsl，发现<code>git log</code>显示最新commit的提交时间是明天，给我吓一跳，然后才发现原来是wsl里面的时间不对。</p><p>Linux下看时间的命令是<code>date</code>，本文写于12月12日，但wsl中的时间是12月10日，肯定是不对。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; date</span><br><span class="line">Tue Dec 10 09:51:29 AM CST 2023</span><br></pre></td></tr></table></figure><p>在wsl内部使用如下命令进行时间同步</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo hwclock -s</span><br></pre></td></tr></table></figure><p>执行后，在windows的命令行里面执行如下命令，重启wsl子系统。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wsl --shutdown</span><br></pre></td></tr></table></figure><p>再在wsl里面执行<code>date</code>命令，时间正确。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; date</span><br><span class="line">Tue Dec 12 09:53:21 AM CST 2023</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">wsl虚拟机时间和实际时间不符合</summary>
    
    
    
    <category term="玩上Linux" scheme="https://blog.musnow.top/categories/%E7%8E%A9%E4%B8%8ALinux/"/>
    
    
    <category term="Linux" scheme="https://blog.musnow.top/tags/Linux/"/>
    
    <category term="虚拟机" scheme="https://blog.musnow.top/tags/%E8%99%9A%E6%8B%9F%E6%9C%BA/"/>
    
    <category term="wsl" scheme="https://blog.musnow.top/tags/wsl/"/>
    
  </entry>
  
  <entry>
    <title>【Hexo】在中英文之间添加空格</title>
    <link href="https://blog.musnow.top/posts/3894841472/"/>
    <id>https://blog.musnow.top/posts/3894841472/</id>
    <published>2023-12-10T07:32:14.000Z</published>
    <updated>2023-12-10T07:32:14.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="说明和插件安装"><a href="#说明和插件安装" class="headerlink" title="说明和插件安装"></a>说明和插件安装</h1><p>如题，中英文添加空格是比较规范的写法， 但是我个人实在是懒，每次都要这么弄太累了。想找找hexo有没有对应的插件，还是有的</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-filter-auto-spacing --save</span><br></pre></td></tr></table></figure><p>安装了之后，在hexo的<code>_config.yml</code>里面添加配置项</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># hexo 中英文之间自动加空格</span><br><span class="line"># npm install hexo-filter-auto-spacing --save</span><br><span class="line">auto_spacing:</span><br><span class="line">  enable: true</span><br></pre></td></tr></table></figure><p>随后<code>hexo s</code>就能看到插件启用后的结果了</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2023/12/bc23322af55db5caac57603bdc3df125.png" alt="image-20231210153203131"></p><p>请注意，该插件仓库 <a href="https://github.com/hexojs/hexo-filter-auto-spacing">https://github.com/hexojs/hexo-filter-auto-spacing</a> 已经被设置为公共归档，且最后一次代码提交是<strong>2022年6月</strong>。</p><p>2023年12月10日实测该插件依旧有用，但不保证hexo更新后依旧有效。慕雪使用的hexo和主题版本如下。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hexo 6.2.0</span><br><span class="line">hexo-butterfly 4.9.0</span><br></pre></td></tr></table></figure><p>暂时没有搜到其他仍在更新的插件。</p><h1 id="buffterfly主题自带配置"><a href="#buffterfly主题自带配置" class="headerlink" title="buffterfly主题自带配置"></a>buffterfly主题自带配置</h1><p>感谢评论区老哥的提醒，buffterfly主题其实<strong>自带</strong>了这个配置项 <a href="https://butterfly.js.org/posts/ceeb73f/#Pangu">https://butterfly.js.org/posts/ceeb73f/#Pangu</a></p><p>使用如下命令<strong>卸载</strong>上方提到的插件。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm uninstall hexo-filter-auto-spacing --save</span><br></pre></td></tr></table></figure><p>在hexo-butterfly主题中<code>pangu</code>配置项就是中英文之间添加空格的配置。</p><p>其中site是对全站生效，post是只对文章生效（对其他页面不生效）</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># https://github.com/vinta/pangu.js</span></span><br><span class="line"><span class="comment"># Insert a space between Chinese character and English character (中英文之間添加空格)</span></span><br><span class="line"><span class="attr">pangu:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">false</span></span><br><span class="line">  <span class="attr">field:</span> <span class="string">site</span> <span class="comment"># site/post</span></span><br></pre></td></tr></table></figure><p>将enable改成true即可启用，效果也很好，不仅中英文之间会添加空格，数字和中文之间也添加了空格。完美啦！</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2023/12/1ffcfb9e601a003fd9e246a31d833e15.png" alt="image-20231210213203331"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;说明和插件安装&quot;&gt;&lt;a href=&quot;#说明和插件安装&quot; class=&quot;headerlink&quot; title=&quot;说明和插件安装&quot;&gt;&lt;/a&gt;说明和插件安装&lt;/h1&gt;&lt;p&gt;如题，中英文添加空格是比较规范的写法， 但是我个人实在是懒，每次都要这么弄太累了。想找找hexo有没</summary>
      
    
    
    
    <category term="差生文具多" scheme="https://blog.musnow.top/categories/%E5%B7%AE%E7%94%9F%E6%96%87%E5%85%B7%E5%A4%9A/"/>
    
    
    <category term="Hexo" scheme="https://blog.musnow.top/tags/Hexo/"/>
    
  </entry>
  
  <entry>
    <title>【nginx】nginx 配置避免 IP 访问时证书暴露域名</title>
    <link href="https://blog.musnow.top/posts/3528013149/"/>
    <id>https://blog.musnow.top/posts/3528013149/</id>
    <published>2023-12-09T09:12:55.000Z</published>
    <updated>2023-12-09T10:12:55.000Z</updated>
    
    <content type="html"><![CDATA[<p>本文转载自：<a href="https://zinglix.xyz/2021/10/04/nginx-ssl-reject-handshake/">https://zinglix.xyz/2021/10/04/nginx-ssl-reject-handshake/</a></p><h1 id="原文"><a href="#原文" class="headerlink" title="原文"></a>原文</h1><h2 id="TL-DR"><a href="#TL-DR" class="headerlink" title="TL;DR"></a>TL;DR</h2><p>nginx 配置避免 IP 访问时证书暴露域名</p><p>利用 <code>nginx 1.19.4</code> 后的新特性 <code>ssl_reject_handshake on;</code>，将其置于默认访问时配置中，IP 访问时会终止 TLS 握手，也就不会暴露域名了。</p><p>使用如下命令查看你的nginx版本</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># nginx -v</span><br><span class="line">nginx version: nginx/1.20.1</span><br></pre></td></tr></table></figure><h2 id="细说"><a href="#细说" class="headerlink" title="细说"></a>细说</h2><p>CDN 是建站时常用的工具，在自己的主机外面套一层 CDN 是常见操作，一般这样认为自己的主机就安全了，有人来攻击也会先到 CDN 服务器，攻击者根本无法获取到自己主机的 IP，但事实真的是这样吗？</p><p>我们先来看看一般配置后会出现什么问题。</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">    <span class="attribute">listen</span> <span class="number">80</span> default_server;</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Redirect all HTTP requests to HTTPS.</span></span><br><span class="line">    <span class="attribute">return</span> <span class="number">301</span> https://<span class="variable">$host</span><span class="variable">$request_uri</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">    <span class="attribute">listen</span> <span class="number">443</span> default_server;</span><br><span class="line">    <span class="attribute">server_name</span> _;</span><br><span class="line">    <span class="attribute">include</span> conf.d/ssl.config;</span><br><span class="line">    <span class="attribute">return</span> <span class="number">444</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面是一个很常用的 nginx 配置，HTTP 访问全部重定向到 HTTPS 的 443 端口上，没有配置过的域名返回 444 终止连接。</p><p>好了，现在尝试用 IP 和 HTTPS 访问你的网站，你应该能够看到预想中访问失败、证书无效等连接失败的提示。</p><p><strong>但是！</strong>注意下浏览器左上角提示的不安全，点开查看证书信息，你就会发现你的域名其实随着证书发送了过来。此时如果你是攻击者，那么其实就可以知道该域名背后的源主机 IP 就是这个。</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2023/12/035ad572d3638bb917c07e53e24c9575.png"></p><p>上图即为用 IP 访问后，依旧能看到证书内容。这是因为返回 444 是 HTTP 层面的事情，意味着到达这一步下层的 TLS 握手已经完成。证书不被信任是一回事，但说明已经拿到了服务器的证书。</p><p>CDN 确实避免了直接 DNS 查询暴露 IP 的问题，但攻击者通过扫描全网 IP，用上述方式依旧可以知道每个 IP 对应的域名是什么，这也是为什么很多站长用了 CDN 后并且反复更换 IP 却依旧被攻击者迅速找到 IP 的原因。</p><blockquote><p><a href="https://search.censys.io/">Censys</a> 就一直在干这件事，全网扫描 IP 并找到其对应的域名</p></blockquote><h2 id="那该怎么办呢？"><a href="#那该怎么办呢？" class="headerlink" title="那该怎么办呢？"></a>那该怎么办呢？</h2><p>问题根源出在 client 在 TLS 握手时发送了 ClientHello 后，nginx 在 ServerHello 中带着含有域名的默认证书返回了，因为 nginx 期望可以完成握手，这可能可以算是 nginx 的一个缺陷。</p><blockquote><p>如果你不熟悉 TLS 握手流程，那么可以看看 <a href="https://zinglix.xyz/2019/05/07/tls-handshake/">这篇文章</a></p></blockquote><h3 id="笨办法"><a href="#笨办法" class="headerlink" title="笨办法"></a>笨办法</h3><p>既然 nginx 默认提供了带有域名的证书，那么想不暴露也很简单，提供一个不含有正确域名的证书即可。</p><p>nginx 设置中 HTTPS 访问如果没有设置证书，那么就会报错。但反正 IP 访问也不需要提供服务，那么直接自签一个 IP 证书，或者随便一个域名的证书都可。当然，如果能搞定合法的 IP 证书也不是不行。</p><p>搞定证书后，添加一个配置，让 IP 访问返回错误证书就完事了。</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">    <span class="attribute">listen</span> <span class="number">443</span> ssl default_server;</span><br><span class="line">    <span class="attribute">server_name</span> your_ip;</span><br><span class="line"></span><br><span class="line">    <span class="attribute">ssl_certificate</span>    xxxx.pem;</span><br><span class="line">    // <span class="attribute">and</span> more ssl config ...</span><br><span class="line"></span><br><span class="line">    return <span class="number">444</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="好方法"><a href="#好方法" class="headerlink" title="好方法"></a>好方法</h3><p>这种方法还得自己搞个证书，如果服务器多每个都得这么搞也挺麻烦的，好在这个问题 nginx 这已经有了很完美的解决方案。</p><p>ClientHello 中是带着 SNI 的，所以其实握手阶段是可以知道访问的域名是否合法的，nginx 1.19.4 中添加了一个新的配置项 <code>ssl_reject_handshake</code> 用于拒绝握手，也就不会提供证书。</p><p>使用方法也很简单，将原本默认配置中的 <code>return 444</code> 替换成 <code>ssl_reject_handshake on</code> 即可。</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">    <span class="attribute">listen</span> <span class="number">443</span> default_server;</span><br><span class="line">    <span class="attribute">server_name</span> _;</span><br><span class="line">    <span class="attribute">include</span> conf.d/ssl.config;</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 不用返回 444 了，直接拒绝握手</span></span><br><span class="line">    <span class="attribute">ssl_reject_handshake</span> <span class="literal">on</span>;</span><br><span class="line">    <span class="comment"># return 444;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>配置后，再尝试 IP 访问，会发现浏览器报了 <code>ERR_SSL_UNRECOGNIZED_NAME_ALERT</code> 的错误，也看不到证书信息，目标达成！</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2023/12/18ba4a8ac5a7c8d5400ecf4a2a6bb392.png"></p><h2 id="其实还没完"><a href="#其实还没完" class="headerlink" title="其实还没完"></a>其实还没完</h2><p>上述方法是通过 ClientHello 中的 SNI 确定访问是否合法的，那如果 SNI 就是正确的域名呢？</p><p>这种场景发生于攻击者已经确定要攻击某个域名，那么他就可以将带着该域名的握手信息遍历所有 IP，握手成功就找到，这样访问其实与正常访问并无区别，<strong>唯一解决方法</strong>就是白名单只允许 CDN 服务器访问。</p><blockquote><p>例如攻击者用 hosts 直接硬写 IP，<strong>将域名强行指向某个 IP</strong></p><p>或者用这种方式 <code>curl https://example.com --resolve &#39;example.com:443:172.17.54.18&#39;</code></p></blockquote><p>如下，在 nginx 里面的 location 配置添加上 allow 的 IP 段，只允许 CDN 运营商的 IP 访问你的服务，就能避免绕过 CDN 造成的攻击</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">location</span> / &#123;</span><br><span class="line">    <span class="attribute">allow</span>   <span class="number">172.1.2.0</span>/<span class="number">24</span>; <span class="comment"># 允许CDN运营商的IP</span></span><br><span class="line">    <span class="attribute">allow</span>   <span class="number">1.2.3.4</span>/<span class="number">32</span>;</span><br><span class="line">    <span class="attribute">deny</span>    all; <span class="comment"># 阻止其他任何IP</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述 IP 段只能向 CDN 服务提供商询问，一般文档中都是有相关信息的。</p><h1 id="慕雪的测试"><a href="#慕雪的测试" class="headerlink" title="慕雪的测试"></a>慕雪的测试</h1><p>上面这篇文章我第一次看的时候还没有理解他说的是什么内容。后来测试了一下，明白了。</p><h2 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h2><p>以我的服务器举例，我是<code>centos 7.2</code>的服务器，直接用yum安装的nginx，版本<code>nginx/1.20.1</code>，配置路径是<code>/etc/nginx</code>；</p><p>在默认情况下，你会有个<code>nginx.conf</code>，和<code>/etc/nginx/conf.d</code>里面的用户配置文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">/etc/nginx</span><br><span class="line">- nginx.conf</span><br><span class="line">- conf.d</span><br><span class="line">- server1.conf</span><br><span class="line">- server2.conf</span><br></pre></td></tr></table></figure><p>在<code>nginx.conf</code>里面除了加载用户配置文件，还会有一个默认的server，指向一个<strong>静态文件路径</strong>。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"># 用户配置文件</span><br><span class="line">   include /etc/nginx/conf.d/*.conf;</span><br><span class="line"></span><br><span class="line">   server &#123;</span><br><span class="line">       listen       80;</span><br><span class="line">       listen       [::]:80;</span><br><span class="line">       server_name  _;</span><br><span class="line">       root         /usr/share/nginx/html; # 默认的静态文件路径</span><br><span class="line"></span><br><span class="line">       # Load configuration files for the default server block.</span><br><span class="line">       include /etc/nginx/default.d/*.conf;</span><br><span class="line"></span><br><span class="line">       error_page 404 /404.html;</span><br><span class="line">       location = /404.html &#123;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       error_page 500 502 503 504 /50x.html;</span><br><span class="line">       location = /50x.html &#123;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>在我的服务器上，这个路径里面是如下内容</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@bt-7274:/etc/nginx]# ls /usr/share/nginx/html</span><br><span class="line">404.html  50x.html  en-US  icons  img  index.html  nginx-logo.png  poweredby.png</span><br></pre></td></tr></table></figure><p>此时直接在浏览器访问你的ip，会展示这个默认路径里面的<code>index.html</code>，是centos的一个介绍页面。</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2023/12/03207321f1c2ee5a4f77f22d55746121.png" alt="image-20231209173337849"></p><p>但是，这并不代表你当前没有解析到任何<strong>用户自定义文件</strong>！nginx默认情况下会使用第一个用户自定义conf来作为ip访问的结果（这是因为对用户自定义conf的include是在defualt server之前的，你可以理解为用户自定义文件会像C语言的头文件一样在<code>nginx.conf</code>中被展开）</p><p>当前实际上是访问了<code>/etc/nginx/conf.d</code>里面按字典排序的<strong>第一个用户conf配置</strong>！</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">/etc/nginx</span><br><span class="line">- nginx.conf</span><br><span class="line">- conf.d</span><br><span class="line">- server1.conf # 直接访问ip，使用了这个配置文件</span><br><span class="line">- server2.conf</span><br></pre></td></tr></table></figure><p>为什么在我这里依旧展示了<strong>默认的静态文件路径呢</strong>？是因为我的第一个配置文件<code>a.conf</code>中没有配置<code>location /</code>，全都是其他路径（比如<code>/a/</code>）的反代！所以nginx就往后采用了最末尾的default server里面提供的默认静态文件。</p><p>而浏览器链接左侧的红色<code>不安全</code>就告诉我们，当前其实收到了一个ssl证书，这便是上面原文中提到的<code>ip访问会因为ssl证书泄漏域名</code>的问题。</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2023/12/0aff6af71c686835cb262961360442ab.png" alt="image-20231209174001901"></p><p>我们可以点击<code>不安全</code>提示，再点击右上角那个<strong>带徽章的小按钮</strong>，查看当前收到的证书</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2023/12/96fafa7dca660e58ec838fb95350aa05.png" alt="image-20231209174025184"></p><p>如下图，当前收到的这证书，正是我的<code>/etc/nginx/conf.d</code>中第一个用户配置里面的ssl证书；内部包含了该证书对应的域名，我们的域名因此泄漏！</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2023/12/c59ed5779697e2dda320ae46d6b8f7e5.png" alt="image-20231209174102666"></p><h2 id="思路回顾"><a href="#思路回顾" class="headerlink" title="思路回顾"></a>思路回顾</h2><p>再来缕一缕思路</p><ul><li>nginx会先加载用户配置文件，末尾才是默认指向<code>/usr/share/nginx/html</code>静态路径的配置</li><li>当你使用ip访问当前服务器，nginx会给浏览器发送<code>/etc/nginx/conf.d</code>中按<strong>字典序</strong>排在第一位的<strong>用户配置文件</strong>中的ssl证书（即上图所示证书）</li><li>恶意访问人员可以通过遍历访问所有IP地址，当访问你的服务器IP地址时，他拿到一个ssl证书，其中包括了一个域名A；</li><li>假设你的域名A是按<code>域名A-&gt;CDN-&gt;服务器IP</code>来进行解析的，此时恶意访问人员就通过这个ssl证书直接得到了<code>域名A-&gt;服务器IP</code>的对应关系，完全绕过了CDN</li><li>此时他就可以通过修改hosts强制让<code>域名A</code>指向<code>服务器IP</code>，绕过CDN直接攻击你的源站</li></ul><p>套了CDN还暴露源站IP肯定不是我们想要的结果，所以我们需要解决这个问题！</p><h2 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h2><p>在<code>/etc/nginx/conf.d</code>中直接添加一个<code>a.conf</code>，让其排序在<strong>字典序的第一位</strong>，里面写入如下内容，其中<code>server_name _</code>的含义是除了我们配置过的域名外的其他访问</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">    <span class="attribute">listen</span> <span class="number">80</span> default_server;</span><br><span class="line">    <span class="attribute">server_name</span> _;</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Redirect all HTTP requests to HTTPS.</span></span><br><span class="line">    <span class="attribute">return</span> <span class="number">301</span> https://<span class="variable">$host</span><span class="variable">$request_uri</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">    <span class="attribute">listen</span> <span class="number">443</span> default_server;</span><br><span class="line">    <span class="attribute">server_name</span> _;</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 不用返回 444 了，直接拒绝握手</span></span><br><span class="line">    <span class="attribute">ssl_reject_handshake</span> <span class="literal">on</span>;</span><br><span class="line">    <span class="comment"># return 444;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>配置后直接重启nginx，没有报错就是ok了</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@bt-7274:/etc/nginx/conf.d]# systemctl restart nginx</span><br><span class="line">[root@bt-7274:/etc/nginx/conf.d]# ll</span><br><span class="line">total 28</span><br><span class="line">-rw-r--r-- 1 root root  193 Dec  9 17:52 a.conf</span><br></pre></td></tr></table></figure><p>此时直接访问就会报错ssl的alert了，但是edge中估计是因为<strong>缓存的问题</strong>，依旧能看到证书</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2023/12/9c095bed2d740e56c781c10e33212c9d.png" alt="image-20231209175534238"></p><p>换火狐看一下，无法连接，没有证书，目标达成！</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2023/12/20311f168b98f1ebe38157edf25b0c1a.png" alt="image-20231209175736923"></p><p>这里顺带贴一下火狐中一个正常ssl网站会显示成什么样子。如下是京东官网，在锁的按钮里面能看到证书的颁发者，而<strong>上图修改完毕配置文件后的测试中</strong>没有看到证书颁发者，即我们的证书并没有泄漏，目的达成。</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2023/12/6b4716321086d0e5ef6978695a52b630.png" alt="image-20231209175834078"></p><p>另外，我试了试我另外一个服务器使用的1panel安装的OpenResty，这个比较好，在默认情况下直接访问IP地址返回的是404，且没有暴露证书。不需要自己额外做配置了。</p>]]></content>
    
    
    <summary type="html">nginx配置避免IP访问时证书暴露域名</summary>
    
    
    
    <category term="玩上Linux" scheme="https://blog.musnow.top/categories/%E7%8E%A9%E4%B8%8ALinux/"/>
    
    
    <category term="Linux" scheme="https://blog.musnow.top/tags/Linux/"/>
    
    <category term="nginx" scheme="https://blog.musnow.top/tags/nginx/"/>
    
  </entry>
  
  <entry>
    <title>【nginx】nginx通过配置文件阻止海外ip访问</title>
    <link href="https://blog.musnow.top/posts/2029711168/"/>
    <id>https://blog.musnow.top/posts/2029711168/</id>
    <published>2023-12-09T08:12:55.000Z</published>
    <updated>2023-12-09T12:12:55.000Z</updated>
    
    <content type="html"><![CDATA[<p>nginx通过配置文件阻止海外ip访问</p><h1 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h1><p>因为最近发现有不少刷评论的脚本，在nginx请求日志里面看了眼，都是海外的ip，反正我的博客也是全中文。所以干脆把海外ip禁止artalk评论。</p><p>在<code>/etc/nginx/nginx.conf</code>中可以看到默认的日志路径，在里面能找到每一个转发的请求和其源IP。其中artak新增评论的请求是<code>/api/add</code>路径</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">access_log  /var/log/nginx/access.log  main;</span><br></pre></td></tr></table></figure><p>考虑到添加海外ip屏蔽可能会阻止一些真的在国外的朋友，如果你在阅读本站博客时，遇到相关问题无法直接评论与我交流，可以移步github随便找个我的仓库开个issue提问！</p><h1 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h1><h2 id="APNIC介绍"><a href="#APNIC介绍" class="headerlink" title="APNIC介绍"></a>APNIC介绍</h2><p>后文出现的网站是来自<strong>APNIC</strong> (Asia Pacific Network Information Center)，其是IP地址管理机构之一，负责亚洲、太平洋地区。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">APNIC提供了每日更新的亚太地区IPv4，IPv6，AS号分配的信息表：</span><br><span class="line">http://ftp.apnic.net/apnic/stats/apnic/delegated-apnic-latest</span><br><span class="line">该文件的格式与具体内容参见：</span><br><span class="line">http://ftp.apnic.net/pub/apnic/stats/apnic/README.TXT</span><br></pre></td></tr></table></figure><h2 id="脚本获取ip"><a href="#脚本获取ip" class="headerlink" title="脚本获取ip"></a>脚本获取ip</h2><p>初步解决方法参考：<a href="https://www.cnblogs.com/guoyabin/p/14263732.html">https://www.cnblogs.com/guoyabin/p/14263732.html</a></p><p>原博主提供的脚本如下，可以下载所有海外ip列表并生成一个nginx配置，写入<code>/etc/nginx/blackip.conf</code>中</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="built_in">rm</span> -f legacy-apnic-latest black_`<span class="built_in">date</span> +%F`.conf &amp;&amp; wget http://ftp.apnic.net/apnic/stats/apnic/legacy-apnic-latest</span><br><span class="line"></span><br><span class="line">awk -F <span class="string">&#x27;|&#x27;</span> <span class="string">&#x27;&#123;if(NR&gt;2)printf(&quot;%s %s/%d%s\n&quot;,&quot;deny&quot;,$4,24,&quot;;&quot;)&#125;&#x27;</span> legacy-apnic-latest &gt; black_`<span class="built_in">date</span> +%F`.conf &amp;&amp; \</span><br><span class="line"><span class="built_in">rm</span> -f /etc/nginx/blackip.conf &amp;&amp; \</span><br><span class="line"><span class="built_in">ln</span> -s <span class="variable">$PWD</span>/black_`<span class="built_in">date</span> +%F`.conf /etc/nginx/blackip.conf</span><br></pre></td></tr></table></figure><p>脚本执行后的效果如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@bt-7274:/etc/nginx]# ll</span><br><span class="line">total 88</span><br><span class="line">lrwxrwxrwx 1 root root   34 Dec  9 16:03 blackip.conf -&gt; /root/docker/black_2023-12-09.conf</span><br></pre></td></tr></table></figure><p>文件内容如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[root@bt-7274:/etc/nginx/conf.d]# cat ../blackip.conf</span><br><span class="line">deny 128.134.0.0/24;</span><br><span class="line">deny 128.184.0.0/24;</span><br><span class="line">deny 128.250.0.0/24;</span><br><span class="line">deny 129.60.0.0/24;</span><br><span class="line">deny 129.78.0.0/24;</span><br><span class="line">...后面的省略了</span><br></pre></td></tr></table></figure><h2 id="nginx屏蔽海外ip"><a href="#nginx屏蔽海外ip" class="headerlink" title="nginx屏蔽海外ip"></a>nginx屏蔽海外ip</h2><p>参考原博主的做法，你可以将这个<code>blackip.conf</code>在<code>/etc/nginx/nginx.conf</code>中的<strong>http模块</strong>里面include，这样会阻止当前服务器所有反代的海外的请求。</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">include</span> /etc/nginx/blackip.conf;</span><br></pre></td></tr></table></figure><p>还可以在单个配置文件的<a href="https://zinglix.xyz/2021/10/04/nginx-ssl-reject-handshake/">location里面引用</a></p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">  <span class="section">location</span> / &#123;</span><br><span class="line">      <span class="attribute">proxy_redirect</span> <span class="literal">off</span>; <span class="comment"># artalk的nginx配置中必须有这个</span></span><br><span class="line">      <span class="attribute">proxy_set_header</span> X-Real-IP <span class="variable">$remote_addr</span>;</span><br><span class="line">      <span class="attribute">proxy_set_header</span> X-Forwarded-For <span class="variable">$proxy_add_x_forwarded_for</span>;</span><br><span class="line">      <span class="attribute">proxy_set_header</span> Host <span class="variable">$host</span>;</span><br><span class="line">      <span class="attribute">proxy_set_header</span> Upgrade-Insecure-Requests <span class="number">1</span>;</span><br><span class="line">      <span class="attribute">proxy_set_header</span> X-Forwarded-Proto https;</span><br><span class="line"></span><br><span class="line">      <span class="attribute">include</span> /etc/nginx/blackip.conf; <span class="comment"># 引用配置</span></span><br><span class="line"></span><br><span class="line">      <span class="attribute">proxy_pass</span> http://127.0.0.1:14722;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>修改后重启nginx，没有报错就是ok了</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl restart nginx</span><br></pre></td></tr></table></figure><p>用海外的服务器试试能不能请求artalk，用<a href="https://artk.musnow.top/sidebar/#/login">artk.musnow.top&#x2F;sidebar&#x2F;…</a>这个管理员登录页面来进行测试。</p><p>国内服务器请求结果如下，和浏览器打开的结果基本是一样（管理员登录界面）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">[root@bt-7274:/etc/nginx/conf.d]# curl https://artk.musnow.top/sidebar/#/login</span><br><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">  &lt;head&gt;</span><br><span class="line">    &lt;meta charset=&quot;UTF-8&quot; /&gt;</span><br><span class="line">    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot; /&gt;</span><br><span class="line">    &lt;title&gt;Artalk Sidebar&lt;/title&gt;</span><br><span class="line">    &lt;script type=&quot;module&quot; crossorigin src=&quot;./assets/index-5a0b3a93.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">    &lt;link rel=&quot;stylesheet&quot; href=&quot;./assets/index-84fdcf98.css&quot;&gt;</span><br><span class="line">  &lt;/head&gt;</span><br><span class="line">  &lt;body&gt;</span><br><span class="line">    &lt;div id=&quot;app&quot;&gt;&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">  &lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><p>海外服务器请求结果也是上面这样……然后发现是因为我的海外服务器ip压根不在那个black的deny列表里面</p><p>尝试把ip的网段给加进去，重启nginx再试试。<strong>完美处理</strong>！添加前能正常请求到，添加后就变成403了</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">[root@RainYun-8aNbbsmA:~]# curl https://artk.musnow.top/sidebar/#/login</span><br><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">  &lt;head&gt;</span><br><span class="line">    &lt;meta charset=&quot;UTF-8&quot; /&gt;</span><br><span class="line">    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot; /&gt;</span><br><span class="line">    &lt;title&gt;Artalk Sidebar&lt;/title&gt;</span><br><span class="line">    &lt;script type=&quot;module&quot; crossorigin src=&quot;./assets/index-5a0b3a93.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">    &lt;link rel=&quot;stylesheet&quot; href=&quot;./assets/index-84fdcf98.css&quot;&gt;</span><br><span class="line">  &lt;/head&gt;</span><br><span class="line">  &lt;body&gt;</span><br><span class="line">    &lt;div id=&quot;app&quot;&gt;&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">  &lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br><span class="line">[root@RainYun-8aNbbsmA:~]#</span><br><span class="line">[root@RainYun-8aNbbsmA:~]# curl https://artk.musnow.top/sidebar/#/login</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;&lt;title&gt;403 Forbidden&lt;/title&gt;&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;center&gt;&lt;h1&gt;403 Forbidden&lt;/h1&gt;&lt;/center&gt;</span><br><span class="line">&lt;hr&gt;&lt;center&gt;nginx/1.20.1&lt;/center&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br><span class="line">[root@RainYun-8aNbbsmA:~]#</span><br></pre></td></tr></table></figure><h2 id="nginx屏蔽非国内ip"><a href="#nginx屏蔽非国内ip" class="headerlink" title="nginx屏蔽非国内ip"></a>nginx屏蔽非国内ip</h2><p>我前文提到了我的海外服务器的ip不在这个deny的ip列表里面，没有被屏蔽。</p><p>考虑到网上搜不到<code>legacy-apnic-latest</code>文件存放的是什么ip的信息，我决定换一个思路：allow国内的ip，拒绝所有非国内的ip</p><blockquote><p>获取国内ip列表 <a href="https://www.cnblogs.com/sentangle/p/13201770.html">https://www.cnblogs.com/sentangle/p/13201770.html</a></p></blockquote><p>下面这个url里面的ip地址标明了地区，我们只需要将其提取出来即可</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://ftp.apnic.net/apnic/stats/apnic/delegated-apnic-latest</span><br></pre></td></tr></table></figure><p>这个文件里面的内容结构如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">等级机构|获得该IP段的国家/组织|资源类型|起始IP|IP段长度|分配日期|分配状态</span><br></pre></td></tr></table></figure><p>我们只需要提取CN的所有IP，然后允许他们，再<code>deny all</code>阻止其他ip就可以了</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="built_in">rm</span> -f delegated-apnic-latest blackcn_`<span class="built_in">date</span> +%F`.conf &amp;&amp; wget http://ftp.apnic.net/apnic/stats/apnic/delegated-apnic-latest</span><br><span class="line"></span><br><span class="line">awk -F\| <span class="string">&#x27;/CN\|ipv4/ &#123; printf(&quot;%s %s/%d%s\n&quot;,&quot;allow&quot;,$4, 32-log($5)/log(2), &quot;;&quot;) &#125;&#x27;</span> delegated-apnic-latest &gt; blackcn_`<span class="built_in">date</span> +%F`.conf &amp;&amp; \</span><br><span class="line"><span class="built_in">rm</span> -f /etc/nginx/blackcn.conf &amp;&amp; \</span><br><span class="line"><span class="built_in">ln</span> -s <span class="variable">$PWD</span>/blackcn_`<span class="built_in">date</span> +%F`.conf /etc/nginx/blackcn.conf</span><br></pre></td></tr></table></figure><p>执行这个脚本后，会生成<code>/etc/nginx/blackcn.conf</code>文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@bt-7274:/etc/nginx]# ll</span><br><span class="line">total 88</span><br><span class="line">lrwxrwxrwx 1 root root   42 Dec  9 16:54 blackcn.conf -&gt; /root/docker/nginx/blackcn_2023-12-09.conf</span><br><span class="line">lrwxrwxrwx 1 root root   40 Dec  9 16:56 blackip.conf -&gt; /root/docker/nginx/black_2023-12-09.conf</span><br></pre></td></tr></table></figure><p>内容如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">allow 223.248.0.0/14;</span><br><span class="line">allow 223.252.128.0/17;</span><br><span class="line">allow 223.254.0.0/16;</span><br><span class="line">allow 223.255.0.0/17;</span><br><span class="line">allow 223.255.236.0/22;</span><br><span class="line">allow 223.255.252.0/23;</span><br><span class="line">....</span><br></pre></td></tr></table></figure><p>还是修改nginx单个站点配置文件的location中的内容</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">  <span class="section">location</span> / &#123;</span><br><span class="line">      <span class="attribute">proxy_redirect</span> <span class="literal">off</span>;</span><br><span class="line">  <span class="attribute">proxy_set_header</span> X-Real-IP <span class="variable">$remote_addr</span>;</span><br><span class="line">      <span class="attribute">proxy_set_header</span> X-Forwarded-For <span class="variable">$proxy_add_x_forwarded_for</span>;</span><br><span class="line">      <span class="attribute">proxy_set_header</span> Host <span class="variable">$host</span>;</span><br><span class="line">      <span class="attribute">proxy_set_header</span> Upgrade-Insecure-Requests <span class="number">1</span>;</span><br><span class="line">      <span class="attribute">proxy_set_header</span> X-Forwarded-Proto https;</span><br><span class="line"><span class="comment"># 允许所有国内ip</span></span><br><span class="line">  <span class="attribute">include</span> /etc/nginx/blackcn.conf;</span><br><span class="line">  <span class="attribute">deny</span> all; <span class="comment"># 阻止其他ip</span></span><br><span class="line"></span><br><span class="line">  <span class="attribute">proxy_pass</span> http://127.0.0.1:14722;</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure><p>先来试试不修改配置文件（不做任何deny和allow操作的情况下）海外ip请求结果</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">[root@RainYun-8aNbbsmA:~]# curl https://artk.musnow.top/sidebar/#/login</span><br><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">  &lt;head&gt;</span><br><span class="line">    &lt;meta charset=&quot;UTF-8&quot; /&gt;</span><br><span class="line">    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot; /&gt;</span><br><span class="line">    &lt;title&gt;Artalk Sidebar&lt;/title&gt;</span><br><span class="line">    &lt;script type=&quot;module&quot; crossorigin src=&quot;./assets/index-5a0b3a93.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">    &lt;link rel=&quot;stylesheet&quot; href=&quot;./assets/index-84fdcf98.css&quot;&gt;</span><br><span class="line">  &lt;/head&gt;</span><br><span class="line">  &lt;body&gt;</span><br><span class="line">    &lt;div id=&quot;app&quot;&gt;&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">  &lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><p>符合预期，正常请求出了登录页面的html文件。</p><p>添加如上修改后，重启nginx，再次进行测试。这一次已经403阻止了，完美！</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[root@RainYun-8aNbbsmA:~]# curl https://artk.musnow.top/sidebar/#/login</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;&lt;title&gt;403 Forbidden&lt;/title&gt;&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;center&gt;&lt;h1&gt;403 Forbidden&lt;/h1&gt;&lt;/center&gt;</span><br><span class="line">&lt;hr&gt;&lt;center&gt;nginx/1.20.1&lt;/center&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><h1 id="The-end"><a href="#The-end" class="headerlink" title="The end"></a>The end</h1><p>你可以写个crontab让其定时执行脚本并重启nginx，我个人还是选择人工处理了（什么时候想起来就去更新一下ip列表）</p><p>感谢本文中出现的博客的博主。没有他们的帮助，我无法编写出shell脚本。</p>]]></content>
    
    
    <summary type="html">nginx通过配置文件阻止海外ip访问</summary>
    
    
    
    <category term="玩上Linux" scheme="https://blog.musnow.top/categories/%E7%8E%A9%E4%B8%8ALinux/"/>
    
    
    <category term="Linux" scheme="https://blog.musnow.top/tags/Linux/"/>
    
    <category term="nginx" scheme="https://blog.musnow.top/tags/nginx/"/>
    
  </entry>
  
  <entry>
    <title>【图床】删除对象存储桶前一定要检查！</title>
    <link href="https://blog.musnow.top/posts/3595872827/"/>
    <id>https://blog.musnow.top/posts/3595872827/</id>
    <published>2023-12-09T02:32:14.000Z</published>
    <updated>2023-12-09T02:32:14.000Z</updated>
    
    <content type="html"><![CDATA[<p>我又干蠢事了！虽然没有很大影响，但是这种问题还是不要发生的好。</p><h2 id="什么情况？"><a href="#什么情况？" class="headerlink" title="什么情况？"></a>什么情况？</h2><p>我在博客尚有引用某个对象存储bucket中图片的情况下，删除了那个bucket（因为这个bucket很久没有用，算是弃用的）</p><p>还好今天看旧笔记的时候，突然发现了这个问题，立马去重新搜索了一下这个旧bucket的图片链接，还好还好，受影响的只有两篇文章</p><ul><li>一篇之前导出过PDF，图片还能找到</li><li>另外一篇文章以文字为主，内部丢失的图片可有可无</li></ul><p>我恢复了第一篇里面的图片，然后修改了第二篇中和图片相关的文字说明，算是解决了这个问题。</p><p>又重写检查了一下笔记目录，算是彻底没有这个被我删除的bucket里面的图片了。</p><p>这一次还好，算是没有丢东西，不然数据不备份就删除的笑料又要多一个了……🤣</p><h2 id="以此为戒"><a href="#以此为戒" class="headerlink" title="以此为戒"></a>以此为戒</h2><p>删除bucket之前一定要检查自己到底还有没有使用这个bucket中的文件或者图片！</p><p>删除图床本地目录前，一定要检查自己还有没有这个本地目录里面的图片！</p><p>最佳方案：不要管那个bucket，将其访问权限改成<strong>私有</strong>后，使用备注功能将其标记为弃用。以后不再使用该bucket即可。</p><p>因为对于我个人使用来说，一个bucket里面不会有太多文件，目前最大的图床bucket也不过2GB而已，把它留在那里花不了几个钱！不然把bucket删了，哪天发现需要去里面找旧文件的时候无从下手就麻烦了！</p><blockquote><p>至于我为什么要删……其实是因为我有点强迫症，不用还留在那里看着有点不爽……</p></blockquote><p>当然还有另外一个解决方案：使用<code>rclone</code>等工具，将s3中的所有文件下载到本地，打包多地备份后，删除云端bucket</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;我又干蠢事了！虽然没有很大影响，但是这种问题还是不要发生的好。&lt;/p&gt;
&lt;h2 id=&quot;什么情况？&quot;&gt;&lt;a href=&quot;#什么情况？&quot; class=&quot;headerlink&quot; title=&quot;什么情况？&quot;&gt;&lt;/a&gt;什么情况？&lt;/h2&gt;&lt;p&gt;我在博客尚有引用某个对象存储bucke</summary>
      
    
    
    
    <category term="差生文具多" scheme="https://blog.musnow.top/categories/%E5%B7%AE%E7%94%9F%E6%96%87%E5%85%B7%E5%A4%9A/"/>
    
    
    <category term="图床" scheme="https://blog.musnow.top/tags/%E5%9B%BE%E5%BA%8A/"/>
    
  </entry>
  
  <entry>
    <title>【博客】hexo配置sitemap和百度|必应|谷歌收录</title>
    <link href="https://blog.musnow.top/posts/3595872826/"/>
    <id>https://blog.musnow.top/posts/3595872826/</id>
    <published>2023-12-08T12:32:14.000Z</published>
    <updated>2023-12-08T12:32:14.000Z</updated>
    
    <content type="html"><![CDATA[<p>最近没事找事，又看了会关于博客主题的东西，之前的sitemap一直没有弄上去，现在有时间就弄一下。</p><h1 id="1-hexo安装sitemap插件"><a href="#1-hexo安装sitemap插件" class="headerlink" title="1.hexo安装sitemap插件"></a>1.hexo安装sitemap插件</h1><p>在你的hexo路径下执行如下命令，安装sitemap生成插件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-generator-baidu-sitemap --save</span><br><span class="line">npm install hexo-generator-sitemap --save</span><br></pre></td></tr></table></figure><p>实测在windows11的<code>node v16.20.2</code>和<code>npm  9.8.1</code>下可以正常安装，但是安装baidu-sitemap插件的时候可能会有警告（不影响使用）</p><p>安装完毕插件后，在你的hexo配置文件<code>_config.yml</code>中添加如下内容，指定站点地图的文件名字即可。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 百度和谷歌的sitemap</span></span><br><span class="line"><span class="comment"># npm install hexo-generator-baidu-sitemap --save</span></span><br><span class="line"><span class="comment"># npm install hexo-generator-sitemap --save</span></span><br><span class="line"><span class="attr">baidusitemap:</span></span><br><span class="line">    <span class="attr">path:</span> <span class="string">baidusitemap.xml</span></span><br><span class="line"><span class="attr">sitemap:</span></span><br><span class="line">    <span class="attr">path:</span> <span class="string">sitemap.xml</span></span><br></pre></td></tr></table></figure><p>请注意，需要修改的是hexo的配置文件，并非主题配置文件！</p><h1 id="2-如何修改hexo主题生成的index-html文件？"><a href="#2-如何修改hexo主题生成的index-html文件？" class="headerlink" title="2.如何修改hexo主题生成的index.html文件？"></a>2.如何修改hexo主题生成的index.html文件？</h1><p>一般情况下，站点平台都会让你在<code>index.html</code>的<code>&lt;head&gt;</code>里面加一个html语句，来验证站点的所有权。比图百度的验证html语句如下</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;baidu-site-verification&quot;</span> <span class="attr">content</span>=<span class="string">&quot;验证码&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure><p>部分hexo主题可能提供了自定义<code>&lt;head&gt;</code>的选项（比如butterfly主题就有）</p><p>如果你使用的主题没有提供自定义<code>&lt;head&gt;</code>，可以尝试在主题文件夹下搜索index或者head关键字，来找到当前主题使用的<code>index.html</code>生成源文件</p><blockquote><p>该方法<strong>仅</strong>适用于将主题文件直接下载到<code>themes</code>文件夹下的情况，因为如果你用的是npm安装的主题，那么修改的主题文件是不会对其他地方的部署生效的，下一次更新主题还会覆盖掉。</p></blockquote><p>比如下图是keep主题<code>v3.6.1</code>版本中的<code>head.ejs</code>，你只需要把提供的meta标签加到这里面，下一次部署的时候的<code>index.html</code>中就会带上这个标头了。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">themes\keep\layout\_partial\head.ejs</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2023/12/c5c020be0607437acbd2d4364edd839b.png" alt="image-20231208205004240"></p><h1 id="3-站长平台添加sitemap"><a href="#3-站长平台添加sitemap" class="headerlink" title="3.站长平台添加sitemap"></a>3.站长平台添加sitemap</h1><h2 id="百度"><a href="#百度" class="headerlink" title="百度"></a>百度</h2><p>百度资源搜索平台 <a href="https://ziyuan.baidu.com/site/index#/">https://ziyuan.baidu.com/site/index#/</a></p><p>百度实在是无语，之前安装了<code>hexo-baidu-url-submit</code>插件，主动调用百度api给他推送url，结果弄了已经快一年了，还没有收录我的站点。</p><blockquote><p>实话说，百度不收录站点，网站看的人就很少。百度我自己博客的关键词，结果是一堆被百度收录的爬虫站点用我的文章赚流量。唉……</p></blockquote><p>在资源搜索平台的站点管理中添加你的站点，用第二点提到的方式进行验证</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2023/12/f5049ad4122b226e6621e3f77bbca406.png" alt="image-20231208205611557"></p><p>添加完毕后，在普通收录中可以找到sitemap提交的区域。但是不知道为什么我这里的提交配额是0，搜索了一下也没有找到原因。</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2023/12/f1271309829d10b946af8dc1834d6530.png" alt="image-20231208205652153"></p><p><a href="https://zmingcx.com/baidu-linksubmit-sitemap.html">百度资源平台提交sitemap是取消了还是我被限制了？</a></p><p>有人说是站点质量太低被百度屏蔽了，但是这个情况也是很多人都遇到过的。估计是百度策略更新什么的，不允许你添加了吧！</p><p>如果你已经添加了sitemap，请不要将其删除，免得到时候又没有办法添加了。</p><h2 id="bing"><a href="#bing" class="headerlink" title="bing"></a>bing</h2><p>bing的站长平台直接搜就行：<a href="https://www.bing.com/webmasters/about?setlang=zh-cn">https://www.bing.com/webmasters/about?setlang=zh-cn</a></p><blockquote><p>国内裸连可能不稳定，需要用点方法。</p><p>不过bing即便不提交sitemap也咔咔收录了我的博客，主打一个主动+来者不拒。</p></blockquote><p>进去之后，用微软账户登录，然后点击新增站点，<strong>输入你博客的域名</strong></p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2023/12/46eaebbcbe275e5719c48c0fa212d482.png" alt="image-20231208203803163"></p><p>bing会让你验证站点所有权，根据下面三种方式的指引，选择一种就行了。如果你不知道如何修改hexo的源文件，使用<strong>CNAME验证</strong>方式是最简单的（只要你有域名有权就行了）。</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2023/12/6decdf248d463e8dcf22c1408d1521a8.png" alt="image-20231208204120311"></p><p>不过估计有很多老哥都是白嫖的github pages或者netlify&#x2F;vercel的<strong>二级域名</strong>，在没有域名所有权的情况下，你可以用前两种方式来验证。</p><ul><li>XML文件方式：将bing提供的XML文件下载，然后放到你hexo源目录的<strong>source</strong>文件夹下，就可以了。</li><li>HTML MATE标记验证：部分hexo主题可能提供了自定义header的选项（比如butterfly主题就有）其他主题可以参考上文第二点操作</li></ul><p>域名验证完毕后，在左侧可以提交网站地图（即sidemap）</p><p>直接点击按钮提交你的站点地图的url就可以了。bing会自动进行处理，如下图我的第一个sitemap已经成功处理出来了383个链接，非常完美。</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2023/12/24f236053b3ebece4028124e987e6c65.png" alt="image-20231208204707769"></p><h2 id="谷歌"><a href="#谷歌" class="headerlink" title="谷歌"></a>谷歌</h2><p>实话说，一个纯中文且面向国内读者的站点，在谷歌上面收录了估计也没多大用处，但是可以没用，但不能没有。也给他弄一下吧。</p><p><a href="https://search.google.com/search-console/welcome">https://search.google.com/search-console/welcome</a></p><p>首先是输入站点网址，因为我不需要验证所有站点，只把博客收录了就行，所以这里我选的是网址前缀。输入站点的时候需要把http也带上</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2023/12/940d735d204146063e8cb6de8db30326.png" alt="image-20231208210159103"></p><p>谷歌的验证方式也有很多种，这里的操作和bing是一样的，把它发给你的文件直接放到hexo的source路径下就可以了，或者采用html标签的方式验证。</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2023/12/6b7aef8d762ec3127bf418fba2257ff7.png" alt="image-20231208210317624"></p><p>验证成功后，选择前往资源界面，即前往当前站点的控制台。</p><p>如果你不小心点了完成，站点资源界面在站长工具的<strong>左侧边栏</strong>里面，在里面可以找到你已经添加了的站点。</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2023/12/2b62fc8c0f4a83a969894d7a97f13007.png" alt="image-20231208210604314"></p><p>在左侧选择站点地图，点击添加即可</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2023/12/f8159f7211dc0f12fc854ae74476f2f8.png" alt="image-20231208210802621"></p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2023/12/d57012975919635230b6bd8f57e9871b.png" alt="image-20231208210849226"></p><h1 id="搞定！"><a href="#搞定！" class="headerlink" title="搞定！"></a>搞定！</h1><p>有什么问题，欢迎评论区提出！</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;最近没事找事，又看了会关于博客主题的东西，之前的sitemap一直没有弄上去，现在有时间就弄一下。&lt;/p&gt;
&lt;h1 id=&quot;1-hexo安装sitemap插件&quot;&gt;&lt;a href=&quot;#1-hexo安装sitemap插件&quot; class=&quot;headerlink&quot; title=&quot;1</summary>
      
    
    
    
    <category term="差生文具多" scheme="https://blog.musnow.top/categories/%E5%B7%AE%E7%94%9F%E6%96%87%E5%85%B7%E5%A4%9A/"/>
    
    
    <category term="Hexo" scheme="https://blog.musnow.top/tags/Hexo/"/>
    
  </entry>
  
  <entry>
    <title>【Linux】lcov2.0安装和perl修改镜像源</title>
    <link href="https://blog.musnow.top/posts/1274282021/"/>
    <id>https://blog.musnow.top/posts/1274282021/</id>
    <published>2023-11-26T12:12:55.000Z</published>
    <updated>2023-11-26T12:12:55.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="安装lcov-2-0"><a href="#安装lcov-2-0" class="headerlink" title="安装lcov 2.0"></a>安装lcov 2.0</h1><p>你可能不知道lcov是什么，简而言之，它是一个代码单元测试覆盖率的显示工具，基于gcov。</p><ul><li>什么是单元测试覆盖率？</li></ul><p>我们需要对项目中的每个函数编写单元测试，其实就是测试函数的功能。通过gcc&#x2F;g++的相关编译选项，可以得到一个gcda文件，内部包含某个cpp文件中相关函数被执行了多少次，以及某些if&#x2F;switch中的多分支是否覆盖上了；</p><p>lcov就可以解析这些gcda文件，得到如下图所示的函数<strong>测试覆盖率</strong>的报告</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2023/11/6115958c076400afbfaf6ace5c1e89b9.png" alt="image-20231126201406666"></p><p>包括单元测试在内，这部分对代码函数测试的操作一般被称之为<code>功能安全</code>，这里就不多说了。</p><p>lcov 2.0的安装命令相对来说很简单，就是下面这些</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">wget https://github.com/linux-test-project/lcov/releases/download/v2.0/lcov-2.0.tar.gz</span><br><span class="line">tar -zxvf lcov-2.0.tar.gz</span><br><span class="line"><span class="built_in">cd</span> lcov-2.0</span><br><span class="line">sudo make install</span><br></pre></td></tr></table></figure><h1 id="perl"><a href="#perl" class="headerlink" title="perl"></a>perl</h1><p>使用lcov的时候需要perl，此时就需要修改镜像源。默认的perl module的源是在国外的，国内基本上是完全用不了。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># centos8 安装perl</span></span><br><span class="line">sudo yum install perl</span><br></pre></td></tr></table></figure><p>如果你的lcov运行的时候遇到下面类似的错误，那么就是因为perl缺少对应module导致的，比如如下报错是因为缺少<code>Capture::Tiny</code>这个module；</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Can&#x27;t locate Capture/Tiny.pm in @INC (you may need to install the Capture::Tiny module) (@INC contains: /usr/local/lib/lcov /usr/local/lib64/perl5 /usr/local/share/perl5 /usr/lib64/perl5/vendor_perl /usr/share/perl5/vendor_perl /usr/lib64/perl5 /usr/share/perl5) at /usr/local/lib/lcov/lcovutil.pm line 14.</span><br><span class="line">BEGIN failed--compilation aborted at /usr/local/lib/lcov/lcovutil.pm line 14.</span><br><span class="line">Compilation failed in require at /usr/local/bin/lcov line 102.</span><br><span class="line">BEGIN failed--compilation aborted at /usr/local/bin/lcov line 102.</span><br><span class="line">make: *** [makefile:6: lcov] Error 2</span><br></pre></td></tr></table></figure><h2 id="perl使用清华源"><a href="#perl使用清华源" class="headerlink" title="perl使用清华源"></a>perl使用清华源</h2><p>使用清华源就行了 <a href="https://mirrors.tuna.tsinghua.edu.cn/help/CPAN/">https://mirrors.tuna.tsinghua.edu.cn/help/CPAN/</a></p><p>因为我用的centos的系统，安装的perl版本很老，<code>v5.26.3</code>，所以这里记录一个手动修改镜像源的办法</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">perl --version</span><br></pre></td></tr></table></figure><p>在root用户下执行如下命令，会进入一个perl的命令行</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">perl -MCPAN -e shell</span><br></pre></td></tr></table></figure><p>在perl的命令行中执行如下命令</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">o conf init</span><br></pre></td></tr></table></figure><p>最终展现的结果应该如下，会自动往当前用户的家目录下创建一个配置文件</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2023/11/fdfb49a8a83aa12789080503070a9a7a.png" alt="image-20231126200126012"></p><p>这里创建的配置文件是在root用户下，输入<code>quit</code>退出perl的命令行后，我们直接vim打开这个配置文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim /root/.cpan/CPAN/MyConfig.pm</span><br></pre></td></tr></table></figure><p>在里面找到urllist选项，根据已有格式添加一个新的镜像路径就可以了</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2023/11/0f2b4af79a73a2f95bb6f6de6b17560b.png" alt="image-20231126200230352"></p><p>我这里添加后的urllist配置项如下，第一项是镜像源就OK</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#x27;urllist&#x27; =&gt; [q[https://mirrors.tuna.tsinghua.edu.cn/CPAN/], q[http://www.cpan.org/]],</span><br></pre></td></tr></table></figure><p>但是要注意一下，在我这边的网络环境中，清华源在perl安装包的时候也容易抽风，我试出来比较稳定的ip如下，将其写入<code>/etc/hosts</code>文件中，这样安装perl包的时候就不会timeout了</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">101.6.15.130 mirrors.tuna.tsinghua.edu.cn</span><br></pre></td></tr></table></figure><p>这个ip后续可能会有变化啊，请以你的实际情况为准！</p><h2 id="perl安装module"><a href="#perl安装module" class="headerlink" title="perl安装module"></a>perl安装module</h2><p>后续安装包的时候，就可以用上镜像源了，安装包的语句如下，请注意这个安装语句最后还有个英文的单引号，一定不要把他删了！</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo perl -MCPAN -e <span class="string">&#x27;install &quot;包名&quot;&#x27;</span></span><br></pre></td></tr></table></figure><p>我需要用perl是因为要用到lcov，在lcov仓库的readme里面提到了lcov需要的perl包，一个一个安装就行了（以下节选自<code>lcov2.0</code>的仓库README）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">These perl packages include:</span><br><span class="line"></span><br><span class="line">  - Capture::Tiny</span><br><span class="line">  - DateTime</span><br><span class="line">  - Devel::Cover</span><br><span class="line">  - Digest::MD5</span><br><span class="line">  - File::Spec</span><br><span class="line">  - at least one flavor of JSON module.</span><br><span class="line">    In order of performance/preference:</span><br><span class="line">       - JSON::XS</span><br><span class="line">       - Cpanel::JSON::XS</span><br><span class="line">       - JSON::PP</span><br><span class="line">       - JSON</span><br><span class="line"> - Memory::Process</span><br><span class="line"> - Module::Load::Conditional</span><br><span class="line"> - Scalar::Util</span><br><span class="line"> - Time::HiRes</span><br><span class="line"></span><br><span class="line">If your system is missing any of these, then you may be able to install them</span><br><span class="line">via:</span><br><span class="line"></span><br><span class="line">   $ perl -MCPAN -e &#x27;install &quot;packageName&quot;&#x27;</span><br></pre></td></tr></table></figure><p>比如我需要安装<code>Capture::Tiny</code>包，就用如下命令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo perl -MCPAN -e <span class="string">&#x27;install &quot;Capture::Tiny&quot;&#x27;</span></span><br></pre></td></tr></table></figure><p>正常安装的命令输出结果如下图所示</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2023/11/566a4438035e393943d353c48b016149.png" alt="image-20231126201023622"></p><h2 id="ubuntu安装perl-module"><a href="#ubuntu安装perl-module" class="headerlink" title="ubuntu安装perl module"></a>ubuntu安装perl module</h2><p>如果是ubuntu，安装perl的包会方便一点，因为apt源里面是有perl的module</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># ubuntu 22.04 可以直接安装下面的依赖项，就可以使用lcov 2.0了</span></span><br><span class="line">sudo apt install -y perl libcapture-tiny-perl libdatetime-perl</span><br></pre></td></tr></table></figure><p>你可以根据perl的包名中的<strong>关键字</strong>，尝试在<code>apt list</code>里面找找有没有对应的包</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt list | grep 包名</span><br></pre></td></tr></table></figure><h1 id="使用lcov"><a href="#使用lcov" class="headerlink" title="使用lcov"></a>使用lcov</h1><p>对于lcov2.0的命令使用，可以参考我的linux仓库中的测试</p><p><a href="https://gitee.com/musnows/raspberry-practice/tree/master/lcov_test">https://gitee.com/musnows/raspberry-practice/tree/master/lcov_test</a></p>]]></content>
    
    
    <summary type="html">lcov2.0安装和perl修改镜像源</summary>
    
    
    
    <category term="玩上Linux" scheme="https://blog.musnow.top/categories/%E7%8E%A9%E4%B8%8ALinux/"/>
    
    
    <category term="Linux" scheme="https://blog.musnow.top/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>【C++】空对象指针也能访问成员函数？</title>
    <link href="https://blog.musnow.top/posts/3858168549/"/>
    <id>https://blog.musnow.top/posts/3858168549/</id>
    <published>2023-11-16T08:40:46.000Z</published>
    <updated>2023-11-16T08:40:46.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-起因"><a href="#1-起因" class="headerlink" title="1.起因"></a>1.起因</h1><p>今天写代码的时候遇到一个bug，一个类中的set函数在设置一个POD类型的时候出现了异常，直接段错误退出了。</p><blockquote><p>小tips，POD类型指的是内置类型。</p></blockquote><p>想了好久，都没发现这里的问题到底是因为什么。后来才知道，原来空的对象指针，也能被解引用访问到函数！</p><h1 id="2-示例"><a href="#2-示例" class="headerlink" title="2.示例"></a>2.示例</h1><p>下面是关于这个情况的示例代码</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">mytest</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">mytest</span>() = <span class="keyword">default</span>;</span><br><span class="line">    <span class="built_in">mytest</span>(<span class="type">int</span> a):_a(<span class="number">0</span>)&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">set_int</span><span class="params">(<span class="type">int</span> a)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;set int to &quot;</span> &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">        _a = a;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(<span class="type">int</span> a)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;just a print&quot;</span> &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> _a = <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    mytest* ptr = <span class="literal">nullptr</span>;</span><br><span class="line">    ptr-&gt;<span class="built_in">print</span>(<span class="number">20</span>);</span><br><span class="line">    ptr-&gt;<span class="built_in">set_int</span>(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行这个程序，会出现段错误。但你会发现这个段错误并不是因为我们的<code>ptr-&gt;</code> 里面出现的，而是成功进入了set_int函数，执行了打印，最终对成员变量<code>_a</code>赋值的时候出现的！</p><p>对象指针为空，代表压根不存在一个实际的对象，也没办法对不存在的成员变量操作。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt; ./test</span><br><span class="line">just a print20</span><br><span class="line">set int to 10</span><br><span class="line">[1]    280362 segmentation fault  ./test</span><br></pre></td></tr></table></figure><p>当代码很多的时候，就会因为忽略这个特性（其实我当时是压根不知道）而误以为错误出现在set_int函数中。</p><p>没有想到是外层的对象指针为空导致的。</p><h1 id="3-为什么？"><a href="#3-为什么？" class="headerlink" title="3.为什么？"></a>3.为什么？</h1><p>在编译过程中，对象就已经绑定了函数地址。一个类的所有对象，使用的函数地址都是一样的。当编译<code>ptr-&gt;set_int(10)</code> 的时候，函数的地址就已经和这个指针绑定了，调用它等价于直接调用 set_int 函数。</p><p>如果这个函数中没有需要用到成员变量的地方，也就不需要解引用this指针，是不会出错的。比如上方代码中的print函数，就没有出现异常。</p><p>但如果函数内访问了内置成员，那么就会出现解引用空指针导致的段错误！</p>]]></content>
    
    
    <summary type="html">真没想到，空对象指针也能访问成员函数啊？</summary>
    
    
    
    <category term="遇见C++" scheme="https://blog.musnow.top/categories/%E9%81%87%E8%A7%81C/"/>
    
    
    <category term="数据结构" scheme="https://blog.musnow.top/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    <category term="C++" scheme="https://blog.musnow.top/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>【面经】C++面筋记录 (一) 231021</title>
    <link href="https://blog.musnow.top/posts/721187015/"/>
    <id>https://blog.musnow.top/posts/721187015/</id>
    <published>2023-10-21T10:50:14.000Z</published>
    <updated>2023-10-21T10:50:14.000Z</updated>
    
    <content type="html"><![CDATA[<p>记录部分从牛客网上看到的面筋</p><span id="more"></span><h1 id="1-声明一个vector，当vector过大时会栈溢出吗？"><a href="#1-声明一个vector，当vector过大时会栈溢出吗？" class="headerlink" title="1.声明一个vector，当vector过大时会栈溢出吗？"></a>1.声明一个vector，当vector过大时会栈溢出吗？</h1><p>答案是会。</p><p>默认申请的vector是放在栈区的，栈区的大小&lt;&lt;堆区的大小。所以如果我们在栈区中开辟的vector中插入巨量的数据，是会导致栈溢出的。</p><p>解决办法是将数据存放到堆区上（使用new来创建vector，而不是直接创建）</p><h1 id="2-如何实现多次运行程序但只有一个后台进程？"><a href="#2-如何实现多次运行程序但只有一个后台进程？" class="headerlink" title="2.如何实现多次运行程序但只有一个后台进程？"></a>2.如何实现多次运行程序但只有一个后台进程？</h1><p>使用命名互斥锁，程序启动前申请锁。</p><ul><li>如果锁没有被申请，代表是第一个进程，可以正常运行</li><li>如果锁已经被占用，代表已经有进程了，直接退出当前进程（这里要使用try_lock避免阻塞等待）</li></ul><p>在Linux下可以用命名信号量来实现类似进程共享锁的操作。这部分可以去学习进程通信中信号量的部分。</p><p>咨询了发这篇面筋的大佬，说是用文件保存之前进程的PID，读取出来将之前的进程kill掉。</p><h1 id="3-二分法的前提是什么？"><a href="#3-二分法的前提是什么？" class="headerlink" title="3.二分法的前提是什么？"></a>3.二分法的前提是什么？</h1><ul><li>数据有序</li><li>数据结构支持随机访问</li></ul><h1 id="4-互斥锁和自旋锁有什么区别"><a href="#4-互斥锁和自旋锁有什么区别" class="headerlink" title="4.互斥锁和自旋锁有什么区别"></a>4.互斥锁和自旋锁有什么区别</h1><ul><li>互斥锁是在内核态进行阻塞等待</li><li>自旋锁是在用户态不断循环沦陷检测锁的状态</li></ul><p>如果使用场景是较长运行的共享资源，那么就使用互斥锁。避免自旋锁不断沦陷检测消耗大量CPU资源。</p><p>如果使用场景的共享资源访问速度快，那么可以使用自旋锁。避免互斥锁频繁进行用户、内核态的转换而造成消耗（这里指其他需要获取锁的进程得进入内核态阻塞等待）</p><h1 id="5-TCP三次握手除了序列号还发了什么其他东西？"><a href="#5-TCP三次握手除了序列号还发了什么其他东西？" class="headerlink" title="5.TCP三次握手除了序列号还发了什么其他东西？"></a>5.TCP三次握手除了序列号还发了什么其他东西？</h1><ul><li>SYN和ACK这些表记位（具体复习三次握手每个阶段的发送）</li><li>双方服务进程的端口号</li><li>起始序列号和对对方发送的SYN报文的应答序列号</li><li>TCP校验和</li><li>TCP窗口大小</li></ul><p>后续建立连接后，就会根据双方的窗口大小和数据的序列号开始相互通信。</p><h1 id="6-子类重写父类函数，子类中该函数声明为private，能否重写成功？"><a href="#6-子类重写父类函数，子类中该函数声明为private，能否重写成功？" class="headerlink" title="6.子类重写父类函数，子类中该函数声明为private，能否重写成功？"></a>6.子类重写父类函数，子类中该函数声明为private，能否重写成功？</h1><p>用下面这个毛坯房来进行测试，在默认情况下，我们子类的重写函数都和父类有相同的作用域声明符。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">test</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">foo1</span>();</span><br><span class="line"><span class="built_in">foo2</span>();</span><br><span class="line"><span class="built_in">foo3</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">foo1</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;A::foo1&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">foo2</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;A::foo2&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">foo3</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;A::foo3&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> : <span class="keyword">public</span> A</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">foo1</span>();</span><br><span class="line"><span class="built_in">foo2</span>();</span><br><span class="line"><span class="built_in">foo3</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">foo1</span><span class="params">()</span> <span class="keyword">override</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;B::foo1&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">foo2</span><span class="params">()</span> <span class="keyword">override</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;B::foo2&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">foo3</span><span class="params">()</span> <span class="keyword">override</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;B::foo3&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">B b;</span><br><span class="line">b.<span class="built_in">test</span>();</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;----&quot;</span> &lt;&lt; endl;</span><br><span class="line">A *bb = &amp;b;</span><br><span class="line">bb-&gt;<span class="built_in">test</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>直接运行，结果也符合预期，目前调用的是子类重写后的虚函数，所有函数都重写成功。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">B::foo1</span><br><span class="line">B::foo2</span><br><span class="line">B::foo3</span><br><span class="line">----</span><br><span class="line">B::foo1</span><br><span class="line">B::foo2</span><br><span class="line">B::foo3</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> : <span class="keyword">public</span> A</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">foo1</span>();</span><br><span class="line"><span class="built_in">foo2</span>();</span><br><span class="line"><span class="built_in">foo3</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">foo2</span><span class="params">()</span> <span class="keyword">override</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;B::foo2&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">foo3</span><span class="params">()</span> <span class="keyword">override</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;B::foo3&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">foo1</span><span class="params">()</span> <span class="keyword">override</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;B::foo1&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 编译能通过，运行输出和上方没区别</span></span><br></pre></td></tr></table></figure><p>我尝试了各种修改作用域的方式，包括将子类中foo3函数改成公有，foo1函数改成私有，都能正常完成重写。这里的作用域声明符只是会改变<strong>子类外是否能调用这个函数</strong>，和能否完成虚函数重写无关！</p><p>请注意，如果你将<strong>继承方式由public改成private</strong>，那么就无法在类外使用父类指针指向子类对象了</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">╰─ g++ test2.cpp -o test</span><br><span class="line">test2.cpp: In function ‘int main()’:</span><br><span class="line">test2.cpp:316:11: error: ‘A’ is an inaccessible base of ‘B’</span><br><span class="line">  A *bb = &amp;b;</span><br></pre></td></tr></table></figure><p>但这依旧不影响子类函数重写父类函数（我的依据是override关键字没有报错）</p><h1 id="7-pthread-create能传入类成员函数的指针吗"><a href="#7-pthread-create能传入类成员函数的指针吗" class="headerlink" title="7.pthread_create能传入类成员函数的指针吗"></a>7.pthread_create能传入类成员函数的指针吗</h1><p>可以，但是必须是静态成员函数。</p><p>如果是普通成员函数，那就需要用中间函数来处理，比如下面的示例代码。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span>* <span class="title">threadFunc</span><span class="params">(<span class="type">void</span>* arg)</span> </span>&#123;</span><br><span class="line">    std::function&lt;<span class="type">void</span>()&gt; func = *<span class="keyword">reinterpret_cast</span>&lt;std::function&lt;<span class="built_in">void</span>()&gt;*&gt;(arg);</span><br><span class="line">    <span class="built_in">func</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::function&lt;<span class="type">void</span>()&gt; myFunc = []() &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Hello from thread!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="type">pthread_t</span> thread;</span><br><span class="line">    <span class="built_in">pthread_create</span>(&amp;thread, <span class="literal">nullptr</span>, &amp;threadFunc, <span class="built_in">reinterpret_cast</span>&lt;<span class="type">void</span>*&gt;(&amp;myFunc));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 等待线程结束</span></span><br><span class="line">    <span class="built_in">pthread_join</span>(thread, <span class="literal">nullptr</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们可以用<code>std::function</code>包装一个类的成员函数，并用<code>std::bind</code>将对象的this指针绑定到第一个参数上。外层再套上一个用于执行该函数的void函数，就能传给<code>pthread_create</code>。</p><p><code>std::function</code>的对象不能直接传给C语言的函数指针，即便参数对应。会报错。</p><h1 id="8-函数内static变量的作用"><a href="#8-函数内static变量的作用" class="headerlink" title="8.函数内static变量的作用"></a>8.函数内static变量的作用</h1><p>在函数内定义一个static变量，该变量只会在进入这个函数的时候初始化一次。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 计算某一月的1号是一年的第几天(不考虑闰年)</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">DayOfYear</span><span class="params">(<span class="type">int</span> month)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> day_array = &#123;<span class="number">0</span>,<span class="number">31</span>,<span class="number">59</span>,<span class="number">90</span>,<span class="number">120</span>,<span class="number">151</span>,<span class="number">181</span>,<span class="number">212</span>,<span class="number">243</span>,<span class="number">273</span>,<span class="number">304</span>,<span class="number">334</span>&#125;;</span><br><span class="line">    <span class="keyword">return</span> day_array[month];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>比如上面的函数，我们定义的day数组就只会在第一次进入这个函数的时候初始化。之后进入这个函数将不在初始化，就节省了初始化一个数组的消耗。出了这个函数后，该数组变量依旧存在。</p><p>请注意，这个static语句并不只是变量只初始化一次，实际上这一行语句在该函数中都只会进行一次</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="title function_">checkFlag</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">static</span> <span class="type">bool</span> flag = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span>(!flag)&#123;</span><br><span class="line">        <span class="comment">// ..进行对应修改</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>比如上面的代码中，如果用正常思维来理解，你会觉得这个if语句每次都会判断为真而进入其中。但实际上flag的定义只会被定义一次，<strong>只要我们在if中将其改成了true</strong>，那么下一次进入该函数的时候，<strong>flag依旧会是true</strong>，<code>static bool flag = false;</code>语句会被直接跳过，并不会再次执行赋值！</p><p>我之前理解的就是flag变量只会被创建一次，但static后的赋值依旧会执行。这个理解是<strong>错误</strong>的！</p><h1 id="9-私有static成员函数的意义？"><a href="#9-私有static成员函数的意义？" class="headerlink" title="9.私有static成员函数的意义？"></a>9.私有static成员函数的意义？</h1><p>这个问题比较有意思，我们知道static函数属于整个类，可以直接通过类名作用域调用。且static函数中无法访问任何非static的成员变量。</p><p>但是，如果给你个static的私有成员函数，它又有什么意义呢？</p><ul><li>私有static成员是无法通过类名调用的</li><li>他也没有办法访问类中非static成员变量</li></ul><p>可以这么理解：我有一个方法只在这个类里面需要，这个方法不需要使用成员变量，可以通过传参实现（比如计算什么的）</p><p>但是，我又不想它的命名污染父作用域。</p><p>那么，我就可以把它写为类的私有成员函数，并加上static告诉其他人，这个函数是一个单纯的方法类，不需要使用类的成员变量。</p><p>当然，加上static只是一个编程习惯罢了，实际上这种情况不写static也无所谓。</p>]]></content>
    
    
    <summary type="html">C++面筋记录 (一) 231021</summary>
    
    
    
    <category term="求职路上一去不复返" scheme="https://blog.musnow.top/categories/%E6%B1%82%E8%81%8C%E8%B7%AF%E4%B8%8A%E4%B8%80%E5%8E%BB%E4%B8%8D%E5%A4%8D%E8%BF%94/"/>
    
    
    <category term="面经" scheme="https://blog.musnow.top/tags/%E9%9D%A2%E7%BB%8F/"/>
    
  </entry>
  
  <entry>
    <title>【Linux】wsl安装的ubuntu不支持POSIX消息队列 | 已解决</title>
    <link href="https://blog.musnow.top/posts/4006913293/"/>
    <id>https://blog.musnow.top/posts/4006913293/</id>
    <published>2023-10-17T04:30:55.000Z</published>
    <updated>2023-10-17T04:30:55.000Z</updated>
    
    <content type="html"><![CDATA[<p>wsl安装的ubuntu不支持POSIX消息队列的解决办法</p><span id="more"></span><h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2023/10/f317c38d511b44a48ff5dc5df48b1c80.png"></p><p>如题，我的win10上安装了wsl的ubuntu后（微软商店下载的wsl的Ubuntu）这个系统内部不支持POSIX的消息队列，虽然有<code>&lt;mqueue.h&gt;</code>头文件，但是没有实现，会报错。</p><p>如果想找个简单的办法呢，那就是用systemV的消息队列，可这是个<strong>虚拟机本地环境问题</strong>，我用virtualbox安装的虚拟机就能正常使用。所以肯定得解决这个问题，换成systemV的消息队列就有点「掩耳盗铃」的意味了。</p><h1 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h1><p>下面是一个POSIX消息队列的demo</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mqueue.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">mqd_t</span> mqID;</span><br><span class="line">    mqID = <span class="built_in">mq_open</span>(<span class="string">&quot;/testmQueue&quot;</span>, O_RDWR | O_CREAT, <span class="number">0666</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (mqID &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;open message queue error...&quot;</span>&lt;&lt;<span class="built_in">strerror</span>(errno)&lt;&lt;endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mq_attr mqAttr;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">mq_getattr</span>(mqID, &amp;mqAttr) &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;get the message queue attribute error&quot;</span>&lt;&lt;endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;mq_flags:&quot;</span>&lt;&lt;mqAttr.mq_flags&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;mq_maxmsg:&quot;</span>&lt;&lt;mqAttr.mq_maxmsg&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;mq_msgsize:&quot;</span>&lt;&lt;mqAttr.mq_msgsize&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;mq_curmsgs:&quot;</span>&lt;&lt;mqAttr.mq_curmsgs&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果编译后运行出现了下面的报错，代表当前系统不支持POSIX消息队列。当前系统下有mqueue头文件，但并没有函数的实现体</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">root@DESKTOP-5SQO6N0:~# ./test</span><br><span class="line">open message queue error...No such file or directory</span><br><span class="line">open message queue error...Function not implemented</span><br></pre></td></tr></table></figure><h1 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h1><p>需要将wsl版本1改成版本2，否则无完整Linux内核支持，无法使用POSIX消息队列。<strong>这也是WSL版本1和2的重大区别之一</strong>。</p><p>用如下命令将当前虚拟机改成wsl2版本，就可以使用了。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">wsl -l -v # 用这个命令查看当前虚拟机的version是不是1</span><br><span class="line">wsl --update # 更新wsl</span><br><span class="line">wsl --set-version 虚拟机名 2  # 把指定虚拟机改成wsl版本2</span><br></pre></td></tr></table></figure><h2 id="再次测试"><a href="#再次测试" class="headerlink" title="再次测试"></a>再次测试</h2><p>正常情况下，上面的消息队列代码应该输出如下内容</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">root@DESKTOP-5SQO6N0:~# ./test</span><br><span class="line">mq_flags:0</span><br><span class="line">mq_maxmsg:10</span><br><span class="line">mq_msgsize:8192</span><br><span class="line">mq_curmsgs:0</span><br></pre></td></tr></table></figure><h2 id="绑定目录"><a href="#绑定目录" class="headerlink" title="绑定目录"></a>绑定目录</h2><p>除了上面这个问题，在使用消息队列之前还可以monut一下路径，参考man手册中的教程（似乎不是必须要做的，mount了这个路径之后能更好地看到现有的消息队列）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mkdir /dev/mqueue</span><br><span class="line">mount -t mqueue none /dev/mqueue</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">wsl安装的ubuntu不支持POSIX消息队列的解决办法</summary>
    
    
    
    <category term="玩上Linux" scheme="https://blog.musnow.top/categories/%E7%8E%A9%E4%B8%8ALinux/"/>
    
    
    <category term="Linux" scheme="https://blog.musnow.top/tags/Linux/"/>
    
    <category term="虚拟机" scheme="https://blog.musnow.top/tags/%E8%99%9A%E6%8B%9F%E6%9C%BA/"/>
    
    <category term="wsl" scheme="https://blog.musnow.top/tags/wsl/"/>
    
  </entry>
  
  <entry>
    <title>【微机】DOSBox在windows上的安装和masm的配置</title>
    <link href="https://blog.musnow.top/posts/2839269095/"/>
    <id>https://blog.musnow.top/posts/2839269095/</id>
    <published>2023-10-16T17:49:13.000Z</published>
    <updated>2023-10-16T17:49:13.000Z</updated>
    
    <content type="html"><![CDATA[<p>最近学校学习微型计算机原理与接口技术，需要用到DOSBox来模拟DOS环境进行汇编编程的学习。</p><p>本文记录了如何在windows11&#x2F;10上安装<code>DOSBox0.74</code>并配置<code>masm5</code></p><h1 id="1-安装"><a href="#1-安装" class="headerlink" title="1.安装"></a>1.安装</h1><p>这两个软件我打包上传到了百度云盘。放心，加起来也就2mb，下载应该不会很久</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">链接: https://pan.baidu.com/s/1vjbSL7iwP8WpMVA9K505ZA</span><br><span class="line">提取码: kr4x</span><br></pre></td></tr></table></figure><h2 id="1-1-DOSBox"><a href="#1-1-DOSBox" class="headerlink" title="1.1 DOSBox"></a>1.1 DOSBox</h2><p>点击<code>DOSBox0.74</code>的安装包，无脑下一步安装即可</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2023/10/4ef1475a8016a019d58a90bd6845e70d.png" alt="image-20231017015458406"></p><p>安装出来的图标如下</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2023/10/cc5f29112bed916bb978c49a9a23636d.png" alt="image-20231017015529621"></p><h2 id="1-2-masm5"><a href="#1-2-masm5" class="headerlink" title="1.2 masm5"></a>1.2 masm5</h2><p>找一个空的文件夹，文件路径中不能包含空格、特殊字符和中文，将<code>masm5.zip</code>中的文件全部解压到这个文件夹中，如下图</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2023/10/21d3adc3a7e767d3aa3d0eba69df75e9.png" alt="image-20231017015700958"></p><p>随后修改DOSBox软件的配置文件，右键桌面上Dosbox软件的快捷图标，选择<code>打开文件所在位置</code>找到DOSBox软件的安装路径，点击<code>DOSBox 0.74 Options.bat</code>文件，稍等片刻，会以记事本的方式打开配置文件。</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2023/10/06f84cbaea8c2c0380807a61e01f1a7d.png" alt="image-20231017015801923"></p><p>拉到配置文件最底下，新增如下配置。你只需要修改<code>D:\GAME\masm</code>为你的masm5文件的解压目录就行了。这个文件路径中不能有空格，也不能有特殊字符和中文！</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">MOUNT C D:\GAME\masm</span><br><span class="line">path=%path%; \masm</span><br><span class="line">C: </span><br><span class="line">cd \asm</span><br></pre></td></tr></table></figure><p>配置完成后，启动DOSbox，查看masm命令是否能正常使用。如图所示，没有报错masm命令不存在，那么就是配置好了。</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2023/10/62cba64fa60c2fd957b5968d4387109b.png" alt="image-20231017020002774"></p><h1 id="2-修改DOSBox窗口大小"><a href="#2-修改DOSBox窗口大小" class="headerlink" title="2.修改DOSBox窗口大小"></a>2.修改DOSBox窗口大小</h1><p>默认情况下DOSBox的命令行窗口是非常非常非常小的，我们需要将其改大。同样是修改DOSBox的配置文件，如何打开配置文件参考上文。</p><p>按下图所示修改</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2023/10/2b5bab3f2fc1dbb0a766659d1eb51130.png" alt="image-20231017020347782"></p><p>请注意，这里的1280和1080中间的是大写的X，并不是乘号</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">windowresolution=1280X1080</span><br><span class="line">output=opengl</span><br></pre></td></tr></table></figure><p>修改了之后保存，再重新打开DOSBox，界面就应该会变大了。如果你觉得还是小了，可以修改这里的分辨率，继续让他变大一点。</p><h1 id="3-编译一个汇编程序"><a href="#3-编译一个汇编程序" class="headerlink" title="3.编译一个汇编程序"></a>3.编译一个汇编程序</h1><p>用下面最简单的汇编程序做测试，将如下内容写入到<code>test.asm</code>中，并放入和masm的同一目录下（必须要是同一目录）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">CODE SEGMENT ;USE16</span><br><span class="line">     ASSUME CS:CODE</span><br><span class="line">BEG: MOV DL,&#x27;H&#x27;</span><br><span class="line">     MOV AH, 2 ; 调用2号DOS系统调用输出字符到屏幕上</span><br><span class="line">     INT 21H</span><br><span class="line">     MOV AH, 4CH</span><br><span class="line">     INT 21H</span><br><span class="line">CODE  ENDS</span><br><span class="line">        END BEG</span><br></pre></td></tr></table></figure><p>打开DOSBox，输入如下命令</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">masm test.asm</span><br><span class="line">link test.obj</span><br></pre></td></tr></table></figure><p>输出如下图所示，第一个命令的作用是编译源文件（注意看有没有编译报错）；第二个命令的作用是链接obj文件，最终会弹出来一个警告，不用管他。</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2023/10/60d8190bb6bda5b544018ce777909c0f.png" alt="image-20231017020903839"></p><p>最终执行test，成功输出字符H到终端上。</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2023/10/8cace87b33fc71a4387afa5d7765e8a4.png" alt="image-20231017020946832"></p><p>能走到这一步，就代表你的masm基本环境已经配置好了。可以用来编译运行汇编代码了</p>]]></content>
    
    
    <summary type="html">DOSBox在windows上的安装和masm的配置</summary>
    
    
    
    <category term="差生文具多" scheme="https://blog.musnow.top/categories/%E5%B7%AE%E7%94%9F%E6%96%87%E5%85%B7%E5%A4%9A/"/>
    
    
    <category term="编译" scheme="https://blog.musnow.top/tags/%E7%BC%96%E8%AF%91/"/>
    
    <category term="windows" scheme="https://blog.musnow.top/tags/windows/"/>
    
  </entry>
  
  <entry>
    <title>【Linux】ubuntu/centos8安装zsh终端</title>
    <link href="https://blog.musnow.top/posts/2565866661/"/>
    <id>https://blog.musnow.top/posts/2565866661/</id>
    <published>2023-10-15T09:12:55.000Z</published>
    <updated>2023-10-15T09:12:55.000Z</updated>
    
    <content type="html"><![CDATA[<p>根据这篇知乎文章进行 <a href="https://zhuanlan.zhihu.com/p/514636147">https://zhuanlan.zhihu.com/p/514636147</a></p><h1 id="1-安装zsh"><a href="#1-安装zsh" class="headerlink" title="1.安装zsh"></a>1.安装zsh</h1><p>先安装zsh并设置为默认的终端</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># ubuntu</span></span><br><span class="line">sudo apt install zsh</span><br><span class="line"><span class="comment"># centos </span></span><br><span class="line">sudo yum install zsh util-linux-user</span><br><span class="line"><span class="comment"># 通用</span></span><br><span class="line">chsh -s /bin/zsh</span><br></pre></td></tr></table></figure><blockquote><p>如果centos下找不到chsh命令，参考此博客：<a href="https://blog.csdn.net/FungLeo/article/details/99448425">https://blog.csdn.net/FungLeo/article/details/99448425</a></p></blockquote><p>然后安装oh-my-zsh，这是一个大佬在github上开源的一个zsh配置项，相对方便点</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget --no-check-certificate https://github.com/robbyrussell/oh-my-zsh/raw/master/tools/install.sh -O - | sh </span><br></pre></td></tr></table></figure><p>如果github连不上就用gitee，如果你用的是子用户，那么<strong>这个命令不要用sudo权限执行</strong>！否则后续子用户会因为权限问题没办法使用。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sh -c <span class="string">&quot;<span class="subst">$(curl -fsSL https://gitee.com/shmhlsy/oh-my-zsh-install.sh/raw/master/install.sh)</span>&quot;</span></span><br></pre></td></tr></table></figure><p>最终出现如图所示的界面就是安装成功了。</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2023/10/5ebc935468a46d95ac77e65dc879c66d.png" alt="image-20231015205326739"></p><h1 id="2-安装zsh插件"><a href="#2-安装zsh插件" class="headerlink" title="2.安装zsh插件"></a>2.安装zsh插件</h1><p>安装这两个最常用的插件就可以了</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># zsh-autosuggestions 命令行命令键入时的历史命令建议</span></span><br><span class="line">git <span class="built_in">clone</span> https://github.com/zsh-users/zsh-autosuggestions <span class="variable">$&#123;ZSH_CUSTOM:-~/.oh-my-zsh/custom&#125;</span>/plugins/zsh-autosuggestions</span><br><span class="line"><span class="comment"># zsh-syntax-highlighting 命令行语法高亮插件</span></span><br><span class="line">git <span class="built_in">clone</span> https://gitee.com/Annihilater/zsh-syntax-highlighting.git <span class="variable">$&#123;ZSH_CUSTOM:-~/.oh-my-zsh/custom&#125;</span>/plugins/zsh-syntax-highlighting</span><br></pre></td></tr></table></figure><p>这个历史命令建议的插件是用方向键👉来进行补全的，不要和我一样傻乎乎按tab。</p><h1 id="3-配置文件和主题"><a href="#3-配置文件和主题" class="headerlink" title="3.配置文件和主题"></a>3.配置文件和主题</h1><p>原文中的配置文件有很多地方都不对劲，需要我们修改；</p><p>首先是<code>oh-my-zsh</code>的安装路径，需要改成你的用户家目录下，然后需要先安装一下<code>powerlevel10k</code>主题，这个主题很好用！</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> --depth=1 https://gitee.com/romkatv/powerlevel10k.git <span class="variable">$&#123;ZSH_CUSTOM:-<span class="variable">$HOME</span>/.oh-my-zsh/custom&#125;</span>/themes/powerlevel10k</span><br></pre></td></tr></table></figure><p>配置文件<code>~/.zshrc</code>改成如下内容（建议将原本的配置文件cp备份一下）其中的zsh安装路径一定要修改，否则无法正常配置！</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 防止中文乱码</span></span><br><span class="line"><span class="built_in">export</span> LC_ALL=en_US.UTF-8</span><br><span class="line"><span class="built_in">export</span> LANG=en_US.UTF-8</span><br><span class="line"><span class="comment"># oh-my-zsh的安装路径（zsh的配置路径）</span></span><br><span class="line">ZSH=<span class="string">&quot;/home/你的用户名/.oh-my-zsh&quot;</span></span><br><span class="line"><span class="comment"># ZSH_THEME=&quot;robbyrussell&quot;</span></span><br><span class="line"><span class="comment"># 设置字体模式以及配置命令行的主题</span></span><br><span class="line">POWERLEVEL9K_MODE=<span class="string">&#x27;nerdfont-complete&#x27;</span></span><br><span class="line"><span class="comment"># ZSH_THEME=&quot;agnoster&quot;</span></span><br><span class="line">ZSH_THEME=<span class="string">&quot;powerlevel10k/powerlevel10k&quot;</span> <span class="comment"># 主题推荐这个，需要进行安装</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 启动错误命令自动更正</span></span><br><span class="line">ENABLE_CORRECTION=<span class="string">&quot;true&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 在命令执行的过程中，使用小红点进行提示</span></span><br><span class="line">COMPLETION_WAITING_DOTS=<span class="string">&quot;true&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 配置要使用的插件</span></span><br><span class="line">plugins=(</span><br><span class="line">        git</span><br><span class="line">        extract</span><br><span class="line">        zsh-autosuggestions</span><br><span class="line">        zsh-syntax-highlighting</span><br><span class="line">)</span><br><span class="line"><span class="built_in">source</span> <span class="variable">$ZSH</span>/oh-my-zsh.sh</span><br><span class="line"><span class="built_in">source</span> <span class="variable">$ZSH_CUSTOM</span>/plugins/zsh-autosuggestions/zsh-autosuggestions.zsh</span><br><span class="line"><span class="comment"># python虚拟环境相关设置</span></span><br><span class="line"><span class="keyword">if</span> [ -f /usr/local/bin/virtualenvwrapper.sh ];</span><br><span class="line"><span class="keyword">then</span></span><br><span class="line">    <span class="built_in">export</span> WORKON_HOME=<span class="variable">$HOME</span>/.virtualenvs</span><br><span class="line">    <span class="built_in">export</span> VIRTUALENVWRAPPER_PYTHON=/usr/bin/python3</span><br><span class="line">    <span class="built_in">source</span> /usr/local/bin/virtualenvwrapper.sh</span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure><p>改好了之后，启用他，然后就可以了；执行下方命令后，就会自动弹出<code>powerlevel10k</code>主题的配置引导过程。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">source ~/.zshrc</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2023/10/684bc428ce3e1369d8d60997845180a8.png" alt="image-20231015205703586"></p><p>如果设置完毕后，你对<code>powerlevel10k/powerlevel10k</code>的配置又不满意了，可以执行如下命令重新配置</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">p10k configure</span><br></pre></td></tr></table></figure><p>你可能也会遇到如下报错，原因未知，但似乎不影响使用</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">❯ ls</span><br><span class="line">_p9k_worker_stop:zle:4: No handler installed for fd 12</span><br><span class="line">_p9k_worker_stop:5: failed to close file descriptor 12: bad file descriptor</span><br></pre></td></tr></table></figure><p>如上报错解决办法参考github的issue内的说明</p><p><a href="https://github.com/romkatv/powerlevel10k/issues/1554">https://github.com/romkatv/powerlevel10k/issues/1554</a></p><p>在配置文件<code>.zshrc</code>的末尾加上下面这一行，然后source让其生效就可以了</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">unset ZSH_AUTOSUGGEST_USE_ASYNC</span><br></pre></td></tr></table></figure><h1 id="4-使用小技巧"><a href="#4-使用小技巧" class="headerlink" title="4.使用小技巧"></a>4.使用小技巧</h1><p>输入命令的时候键入tab，会弹出一些命令的提示</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2023/10/486730657def543552dc7a82163410e9.png" alt="image-20231015210623737"></p><p>输入之前写过的命令的时候，会出现历史命令提示，使用方向键右👉就可以补全这个命令</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2023/10/eb1e448943c27dd0bdeb29267b26d252.png" alt="image-20231015210708230"></p><p>zsh主要就是这一点非常的方便，至于会不会和默认的<code>/bin/bash</code>有性能差异，那就不知道了。</p><p>另外，在zsh终端中直接重定向会卡住，如下命令就会阻塞掉。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt; 文本文件</span><br></pre></td></tr></table></figure><p>所以要用echo（一般我是用来清空某个文本文件）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo &gt; 文本文件</span><br></pre></td></tr></table></figure><h1 id="5-zsh安装后git中文乱码"><a href="#5-zsh安装后git中文乱码" class="headerlink" title="5.zsh安装后git中文乱码"></a>5.zsh安装后git中文乱码</h1><p>安装zsh后用<code>git log</code>查看提交信息的时候发现中文乱码。</p><h2 id="5-1-修改zsh配置文件"><a href="#5-1-修改zsh配置文件" class="headerlink" title="5.1 修改zsh配置文件"></a>5.1 修改zsh配置文件</h2><p>其实上文中提到的配置文件里面已经有这两个配置项了，说明问题不在这里</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># 防止中文乱码</span><br><span class="line">export LC_ALL=en_US.UTF-8</span><br><span class="line">export LANG=en_US.UTF-8</span><br></pre></td></tr></table></figure><h2 id="5-2-执行git配置"><a href="#5-2-执行git配置" class="headerlink" title="5.2 执行git配置"></a>5.2 执行git配置</h2><p>一篇博客说要执行下面的git命令，也没有用</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">git config --global core.quotepath false </span><br><span class="line">git config --global gui.encoding utf-8 </span><br><span class="line">git config --global i18n.commit.encoding utf-8 </span><br><span class="line">git config --global i18n.logoutputencoding utf-8 </span><br><span class="line">set LESSCHARSET=utf-8</span><br></pre></td></tr></table></figure><h2 id="5-3-修改系统字符配置"><a href="#5-3-修改系统字符配置" class="headerlink" title="5.3 修改系统字符配置"></a>5.3 修改系统字符配置</h2><p>另外一篇博客说要修改系统的字符集配置，如下环境变量</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">export LESSCHARSET=utf-8</span><br></pre></td></tr></table></figure><p>执行后确实ok了，可以编辑<code>/etc/profile</code>文件，在该文件末尾追加如下内容让其始终生效</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">export LESSCHARSET=utf-8</span><br></pre></td></tr></table></figure><p>随后用source命令刷新这个配置文件即可。</p><h1 id="6-粘贴文本很慢的问题"><a href="#6-粘贴文本很慢的问题" class="headerlink" title="6.粘贴文本很慢的问题"></a>6.粘贴文本很慢的问题</h1><p>参考 <a href="https://github.com/zsh-users/zsh-autosuggestions/issues/238">zsh-users&#x2F;zsh-autosuggestions&#x2F;issues&#x2F;238</a> 解决这个问题</p><p>在<code>.zshrc</code>之后添加如下配置项</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"># This speeds up pasting w/ autosuggest</span><br><span class="line"># https://github.com/zsh-users/zsh-autosuggestions/issues/238</span><br><span class="line">pasteinit() &#123;</span><br><span class="line">  OLD_SELF_INSERT=$&#123;$&#123;(s.:.)widgets[self-insert]&#125;[2,3]&#125;</span><br><span class="line">  zle -N self-insert url-quote-magic # I wonder if you&#x27;d need `.url-quote-magic`?</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">pastefinish() &#123;</span><br><span class="line">  zle -N self-insert $OLD_SELF_INSERT</span><br><span class="line">&#125;</span><br><span class="line">zstyle :bracketed-paste-magic paste-init pasteinit</span><br><span class="line">zstyle :bracketed-paste-magic paste-finish pastefinish</span><br></pre></td></tr></table></figure><p>配置了之后，source使其生效。</p><p>这时候在终端里面粘贴内容的时候，就不会一个一个字符地打印出来了。那样实在是太慢了。</p>]]></content>
    
    
    <summary type="html">ubuntu/centos8虚拟机安装zsh终端</summary>
    
    
    
    <category term="玩上Linux" scheme="https://blog.musnow.top/categories/%E7%8E%A9%E4%B8%8ALinux/"/>
    
    
    <category term="Linux" scheme="https://blog.musnow.top/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>【虚拟机】WIN11的WSL安装CentOS8Stream虚拟机</title>
    <link href="https://blog.musnow.top/posts/4065446782/"/>
    <id>https://blog.musnow.top/posts/4065446782/</id>
    <published>2023-10-15T03:30:55.000Z</published>
    <updated>2023-10-15T03:30:55.000Z</updated>
    
    <content type="html"><![CDATA[<p>本人所使用的系统是 <code>win11 22H2 家庭版</code>，如果你不是非CentOS不可，强烈建议直接去微软应用商店里面下载Ubuntu，全自动安装到WSL，啥都不用管。(就是好像没办法选择安装路径)</p><h1 id="1-启用WSL"><a href="#1-启用WSL" class="headerlink" title="1.启用WSL"></a>1.启用WSL</h1><p>刚开始安装WSL的时候，参考的是<a href="https://blog.csdn.net/qq_38442140/article/details/120724215">这个博客</a>。说实话，我个人并不喜欢这篇博客。因为里面遗漏了很多东西，并且在不恰当的位置贴出了命令，导致读者会误以为是需要执行这些命令。</p><p>比如我就理解错误，先执行了设置wsl默认版本为2的命令，<strong>这个命令先不要执行</strong>！后文会告诉你为什么。</p><p>这篇博客中对开启wsl的设置的位置描述也不完全，看上去像从网上哪里抄过来的win10的设置逻辑（win11的位置完全不一样）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">该博客原文：在windows设置中打开【启用或关闭Windwos功能】，勾选【适用于Linux的Windwos子系统】，点击确定后会系统会提示重启，选择确认即可</span><br></pre></td></tr></table></figure><p>实际上在win11中，需要多点好几个地方才能找到这个设置的位置</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">右键桌面 - 个性化 - 进入win11设置界面 - 应用 - 可选功能 - (往下滑)更多windows功能</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2023/10/542d2e77f4272f4598629626e44ee2a7.png" alt="image-20231015104701566"></p><blockquote><p>这都是我对一个<strong>不完善博客</strong>的吐槽，但并没有贬低这个教程的意思啊！至少他告诉我基本步骤应该做哪些。</p><p>为什么我要吐槽呢？因为这种写的不全的博客经常会让读者得去重新搜索某些设置的位置，而作者明明是已经走过这个流程的。博客里面作者的截图明显是windows11，但他提供的设置却是win10中的旧位置。多花30秒写清楚位置并带上截图，不知道能节省读者多少时间……如果你体会过查资料的时候阅读这些「断头短尾」的博客，应该也能体会到我的心情。</p></blockquote><p>回到正题。在更多 windows 功能选项框中（win10&#x2F;11的这个选项框基本相同），勾选上下面的几个选项，三个都要勾选上！</p><ul><li>适用于 Linux 的 Windows 子系统</li><li>虚拟机平台</li><li>windows 虚拟机监控程序平台</li></ul><p>点击确定，就成功启用了 WSL。系统会弹出一个进度条，下载一些东西。</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2023/10/61b796407e655ae94c7ff535edaeae69.png" alt="image-20231015104951463"></p><p>处理完毕后，WIN+R输入cmd，打开命令行工具，在命令行工具中输入<code>wsl -l -v</code>命令，有相关输出就是启用成功了！</p><p>初始化情况下，执行这个命令，应该会提示你当前什么虚拟机都没有安装。</p><h1 id="2-安装Centos8"><a href="#2-安装Centos8" class="headerlink" title="2.安装Centos8"></a>2.安装Centos8</h1><h2 id="2-1-下载系统zip"><a href="#2-1-下载系统zip" class="headerlink" title="2.1 下载系统zip"></a>2.1 下载系统zip</h2><p>去 <a href="https://github.com/wsldl-pg/CentWSL/releases/tag/8.1.1911.1">github&#x2F;wsldl-pg&#x2F;CentWSL</a> 上下载适用于wsl的<code>CentOS8</code>系统的zip</p><blockquote><p>这个也可以：<a href="https://github.com/mishamosher/CentOS-WSL">https://github.com/mishamosher/CentOS-WSL</a></p></blockquote><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2023/10/c42449d2875a2e60a296953f2bfcfae8.png" alt="image-20231015104110576"></p><p>把zip解压到你想安装虚拟机的位置（一定要是一个空文件夹），然后右键<code>CentOS8.exe</code>，以管理员身份运行。</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2023/10/a13a0b3e0db1dab54e499c9c7bf5ddc6.png" alt="image-20231015104455537"></p><h2 id="2-2-报错HRESULT-0x80370102解决"><a href="#2-2-报错HRESULT-0x80370102解决" class="headerlink" title="2.2 报错HRESULT:0x80370102解决"></a>2.2 报错HRESULT:0x80370102解决</h2><p>安装CentOS8的时候，就遇到了这个<strong>issue</strong>中的问题👇</p><p><a href="https://github.com/wsldl-pg/CentWSL/issues/36">github.com&#x2F;wsldl-pg&#x2F;CentWSL&#x2F;issues&#x2F;36</a></p><p>用管理员身份运行<code>CentOS8.exe</code>之后，弹出的终端会输出如下内容</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ERROR:Installation Failed!</span><br><span class="line">HRESULT:0x80370102</span><br></pre></td></tr></table></figure><p>根据<a href="https://github.com/wsldl-pg/CentWSL/issues/36">该issue</a> 中最后一个回复的解决办法，我先将wsl版本设置回了1（这就是为什么前文说不要先设置为默认wsl2）</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2023/10/d19e82cbafe8e5eba20d8c6eef64687a.png" alt="image-20231015112649042"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wsl --set-default-version 1</span><br></pre></td></tr></table></figure><p>重复如上安装步骤（以管理员身份运行<code>CentOS8.exe</code>），就成功安装了虚拟机。在win11的文件管理器左侧会多出来一个Linux图标，里面有CentOS8的系统里面的文件。</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2023/10/721c72e099c746ab5f618282dc205e27.png" alt="image-20231015105247440"></p><p>在windows的powershell或者cmd中，输入<code>wsl</code>，就可以进入CentOS8的bash；见下图，我们已经成功安装好了一个CentOS8的虚拟机。内部的文件就是CentOS8系统的默认文件。</p><p>在内部执行<code>exit</code>命令，就可以退出wsl虚拟机，回到windows的终端下。</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2023/10/fa9eb9786e59758af270ae93f120ed51.png" alt="image-20231015105338512"></p><p>而且WSL有个最大的好处，就是它能自动挂载windows下的文件到<code>/mnt</code>目录下，这个目录里面可以看到我的win11宿主机的3个硬盘分区；windows的文件资源管理器里面也可以看到Linux中的文件，<strong>方便我们在windows和linux下互传文件</strong>（就不需要用sftp工具了）</p><p>特别是如果你需要写带Doxygen文档的项目，在生成Doxygen的html后，就能直接从这里在windows的浏览器中打开网页，而不需要用sftp或者其他工具传到windows下再打开了！</p><blockquote><p>当然，你也可以用带GUI的Linux系统来解决这个问题。</p></blockquote><h2 id="2-3-更新为WSL2"><a href="#2-3-更新为WSL2" class="headerlink" title="2.3 更新为WSL2"></a>2.3 更新为WSL2</h2><p>使用<code>wsl -l -v</code>命令，可以看到当前运行的wsl虚拟机，版本是1</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">PS C:\Users\S2522\Desktop&gt; wsl -l -v</span><br><span class="line">  NAME       STATE           VERSION</span><br><span class="line">* CentOS8    Running         1</span><br></pre></td></tr></table></figure><p>我们可以将其升级为WSL2版本，但是这里会告诉你需要更新内核组件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">PS C:\Users\S2522\Desktop&gt; wsl --set-version CentOS8 2</span><br><span class="line">正在进行转换，这可能需要几分钟时间...</span><br><span class="line">有关与 WSL 2 的主要区别的信息，请访问 https://aka.ms/wsl2</span><br><span class="line">WSL 2 需要更新其内核组件。有关信息，请访问 https://aka.ms/wsl2kernel</span><br></pre></td></tr></table></figure><p>那就更新呗！<a href="https://aka.ms/wsl2kernel">微软官方文档</a> 中会告诉你需要 <code>wsl.exe --install</code> 或 <code>wsl.exe --update</code>命令。</p><p>这里我执行了<code>wsl --update</code>命令，执行后会弹窗要你提供管理权限，并出现一个进度条，等他跑完就行。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">PS C:\Users\S2522\Desktop&gt; wsl --update</span><br><span class="line">正在安装: 适用于 Linux 的 Windows 子系统</span><br><span class="line">已安装 适用于 Linux 的 Windows 子系统。</span><br></pre></td></tr></table></figure><p>更新好了，再重新执行<code>wsl --set-version CentOS8 2</code>升级命令，会提示你正在执行转换，需要等待一会。</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2023/10/a870772fe8f185d55935bb2eb1d720d3.png" alt="image-20231015105730332"></p><p>最终成功转换了，使用命令<code>wsl -l -v</code>里面显示的版本也是2了。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">PS C:\Users\S2522\Desktop&gt; wsl --set-version CentOS8 2</span><br><span class="line">有关与 WSL 2 关键区别的信息，请访问 https://aka.ms/wsl2</span><br><span class="line"></span><br><span class="line">正在进行转换，这可能需要几分钟时间。</span><br><span class="line">操作成功完成。</span><br><span class="line">PS C:\Users\S2522\Desktop&gt; wsl -l -v</span><br><span class="line">  NAME       STATE           VERSION</span><br><span class="line">* CentOS8    Stopped         2</span><br></pre></td></tr></table></figure><p>搞定！现在我们就有一个方便的CentOS8的WSL环境啦！</p><p>可以用如下命令，将当前的CentOS8设置为默认的wsl虚拟机。这样在windows命令行中执行wsl或者bash命令，就能直接进入CentOS8中。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wslconfig /setdefault CentOS8</span><br></pre></td></tr></table></figure><p>重启电脑后，在powershell的下拉栏中会自动出现CentOS8的选项，点击它也能进入wsl虚拟机环境中。</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2023/10/e40e68ef976f8ef57c9f73d03a8dc892.png" alt="image-20231015134927313"></p><h1 id="3-解决yum报错问题"><a href="#3-解决yum报错问题" class="headerlink" title="3.解决yum报错问题"></a>3.解决yum报错问题</h1><p>因为这个CentOS的镜像是最小安装版本（类似于Docker安装的CentOS），所以内部的yum源都是坏掉的。执行<code>yum update</code>会出现如下报错。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@7945R9P ~]# yum -y update</span><br><span class="line">Failed to set locale, defaulting to C.UTF-8</span><br><span class="line">CentOS-8 - AppStream                                                                     68  B/s |  38  B     00:00</span><br><span class="line">Failed to download metadata for repo &#x27;AppStream&#x27;</span><br><span class="line">Error: Failed to download metadata for repo &#x27;AppStream&#x27;</span><br></pre></td></tr></table></figure><p>这时候需要进行yum源的重新设置，参考本站博客解决这个问题就行</p><p> <a href="https://blog.musnow.top/posts/1296728696/">【Docker】配置CentOS容器时出现 Error Failed to download metadata for repo ‘appstream’ Cannot prepare internal mirrorlist | 转载</a></p><p>搞定yum之后，就可以正常安装你想要的开发软件了。这个系统很轻量，sudo和passwd等很多完整系统会自带的命令都没有，需要自行安装一些。</p><p>另外，我写过一个CentOS8的初始化脚本，可以自动化安装一些软件，这里安装的软件并不一定是你想要的，请酌情参考：<a href="https://gitee.com/musnows/centos8-init">https://gitee.com/musnows/centos8-init</a></p><hr><p>而且，默认情况下的ls命令也没有颜色输出，需要修改bash配置来设置命令别名</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">alias</span> <span class="built_in">ls</span>=<span class="string">&#x27;ls --color=auto&#x27;</span></span><br></pre></td></tr></table></figure><p>你也可以根据自己的喜好，改成zsh或者其他终端。</p><h1 id="4-vscode连接"><a href="#4-vscode连接" class="headerlink" title="4.vscode连接"></a>4.vscode连接</h1><p>普通的虚拟机我们需要用vscode的remote ssh插件来连接，但是WSL主机我们直接用vsc的<strong>WSL插件</strong>来连接就行了，使用的效果和remote ssh插件是相同的</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2023/10/4211aec9f60b6984a3a680c1a900b5c8.png" alt="image-20231015111412100"></p><p>在左侧这个远程连接控制器中（和Remote ssh是同一个位置），找到上方的下拉条，改成WSL目标，就能看到我们的CentOS8虚拟机。点击连接它就可以了。</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2023/10/344e4ab417ab6246fa14351b211f016c.png" alt="image-20231015111429863"></p><p>但是vscode默认链接的是root用户，一般情况下肯定不会在root下写代码的。所以需要配置一下子用户</p><p>修改虚拟机中的<code>/etc/wsl.conf</code>文件，添加下面两行</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[user]</span><br><span class="line">default=用户名</span><br></pre></td></tr></table></figure><p>然后回到windows的命令行，重启wsl</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wsl --shutdown CentOS8</span><br></pre></td></tr></table></figure><p>再次启动wsl，这样vsc就能默认链接你的子用户了。</p><h1 id="5-修改wsl资源限制"><a href="#5-修改wsl资源限制" class="headerlink" title="5.修改wsl资源限制"></a>5.修改wsl资源限制</h1><p>默认情况下，<strong>wsl2的虚拟机能访问到完整的系统资源</strong>，包括所有CPU核心和内存。</p><p>这就会导致如果Linux下对一些东西进行了缓存而没有及时清理，Windows是没办法回收这部分内存的。<strong>最终就导致我们Windows宿主机没有足够的内存可用了</strong>，这怎么行？</p><blockquote><p>这种情况下，一般windows系统会把wsl直接给干掉，那我们虚拟机里面跑的活也没办法完成了。要知道，Linux可是很喜欢cache内存的，很容易会把宿主机的内存给干没。</p></blockquote><p>为了解决这个问题，我们需要设置wsl的虚拟机内存&#x2F;CPU限制。</p><p>在<strong>Linux下</strong>可以用这两个命令来查看cpu和内存的配置信息，刚开始的时候应该是和你的宿主机的CPU和内存一样。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cat</span> /proc/cpuinfo | grep processor <span class="comment"># 查看cpu核心数量</span></span><br><span class="line"><span class="built_in">cat</span> /proc/meminfo | grep Total     <span class="comment"># 查看内存信息</span></span><br></pre></td></tr></table></figure><p>在windows的<strong>C盘</strong>的<strong>用户文件夹</strong>下，创建一个<code>.wslconfig</code>文件，并在内部写入限制</p><ul><li>processors是cpu核数限制</li><li>memory和swap都是内存限制</li></ul><p>顶多设置为宿主机内存的一半，避免宿主机卡顿。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[wsl2]</span><br><span class="line">processors=8</span><br><span class="line">memory=8GB</span><br><span class="line">swap=8GB</span><br></pre></td></tr></table></figure><p>这个配置文件的路径是（windows下）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">C:\Users\你的用户名\.wslconfig</span><br></pre></td></tr></table></figure><p>随后在windows的终端中使用如下命令，终止这个wsl虚拟机</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">PS C:\Users\S2522\Desktop&gt; wsl --shutdown CentOS8</span><br><span class="line">PS C:\Users\S2522\Desktop&gt; wsl -l -v</span><br><span class="line">  NAME       STATE           VERSION</span><br><span class="line">* CentOS8    Stopped         2</span><br></pre></td></tr></table></figure><p>wsl命令中并没有<code>--start</code>选项，我们直接用wsl命令，就会自动重启并进入这个虚拟机。</p><p>这时候再在虚拟机内部看看CPU和内存信息，就可以看到你刚刚配置的性能限制结果了。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">[root@7945R9P ~]# cat /proc/cpuinfo | grep processor</span><br><span class="line">processor       : 0</span><br><span class="line">processor       : 1</span><br><span class="line">processor       : 2</span><br><span class="line">processor       : 3</span><br><span class="line">processor       : 4</span><br><span class="line">processor       : 5</span><br><span class="line">processor       : 6</span><br><span class="line">processor       : 7</span><br><span class="line">[root@7945R9P ~]# cat /proc/meminfo | grep Total</span><br><span class="line">MemTotal:        8136640 kB</span><br><span class="line">SwapTotal:       8388608 kB</span><br><span class="line">VmallocTotal:   34359738367 kB</span><br><span class="line">HugePages_Total:       0</span><br></pre></td></tr></table></figure><h2 id="删除wsl主机"><a href="#删除wsl主机" class="headerlink" title="删除wsl主机"></a>删除wsl主机</h2><p>删除虚拟机的命令如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wsl --unregister &lt;DistributionName&gt;</span><br></pre></td></tr></table></figure><p>更多命令参考微软官网 <a href="https://learn.microsoft.com/zh-cn/windows/wsl/basic-commands">https://learn.microsoft.com/zh-cn/windows/wsl/basic-commands</a></p><h1 id="6-启用systemctl"><a href="#6-启用systemctl" class="headerlink" title="6.启用systemctl"></a>6.启用systemctl</h1><p>我们的系统里面有systemctl命令，但是没有办法使用。网上有些教程说用service命令来替代，但CentOS中是没有service命令的。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@7945R9P bison-3.8]# systemctl</span><br><span class="line">System has not been booted with systemd as init system (PID 1). Can&#x27;t operate.</span><br><span class="line">Failed to connect to bus: Host is down</span><br></pre></td></tr></table></figure><h2 id="6-1-distrod-第三方工具"><a href="#6-1-distrod-第三方工具" class="headerlink" title="6.1 distrod 第三方工具"></a>6.1 distrod 第三方工具</h2><p>我们需要用distrod来安装systemctl的组件，才能成功启用它。具体教程参考github仓库的README中的介绍。不是很难</p><blockquote><p><a href="https://github.com/nullpo-head/wsl-distrod">https://github.com/nullpo-head/wsl-distrod</a></p></blockquote><p>先下载一个自动安装的脚本（连不上github会报ssl或者timeout错误，请使用其他办法下载这个脚本再丢到虚拟机里面去就行）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">curl -L -O &quot;https://raw.githubusercontent.com/nullpo-head/wsl-distrod/main/install.sh&quot;</span><br><span class="line">chmod +x install.sh</span><br><span class="line">sudo ./install.sh install</span><br></pre></td></tr></table></figure><p>然后用下面两个命令之一来启动（第一个命令是会在windows开机自动启动的）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">/opt/distrod/bin/distrod enable --start-on-windows-boot</span><br><span class="line">/opt/distrod/bin/distrod enable</span><br></pre></td></tr></table></figure><p>更多内容相见<a href="https://github.com/nullpo-head/wsl-distrod">该仓库README</a>；</p><p>请注意，执行第一个自启动命令的时候需要windows的管理员权限，此时需要输入的是系统登录的微软账户的密码（不是你的PIN），看下面，我第一次输入密码输入的就是PIN，显示错误，第二次输入了微软账户的密码才成功。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">[root@7945R9P pkg]# /opt/distrod/bin/distrod enable --start-on-windows-boot</span><br><span class="line">[Distrod] Distrod has been enabled. Now your shell will start under systemd.</span><br><span class="line">[Distrod] Enabling atuomatic startup of Distrod. UAC dialog will appear because scheduling</span><br><span class="line">a task requires the admin privilege. Please hit enter to proceed.</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Error</span><br><span class="line">It seems the task has not been scheduled successfully. You may have typed a wrong password, or you may not have the</span><br><span class="line">necessary administrative privileges. Do you want to retry?</span><br><span class="line">[Y] Yes  [N] No  [?] 帮助 (默认值为“Y”): y</span><br><span class="line">Enabling autostart has succeeded.</span><br><span class="line">[Distrod] Distrod will now start automatically on Windows startup.</span><br></pre></td></tr></table></figure><p>操作完成后，需要重启虚拟机。用如下命令将对应的wsl虚拟机关闭就行了，再次执行wsl就会重启这个虚拟机。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wsl --terminate CentOS8</span><br></pre></td></tr></table></figure><p>如图，我的systemctl命令已经生效。</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2023/10/9340e7964572037fbd3b58f1b379b177.png" alt="image-20231015150251531"></p><p>也能正常通过systemctl命令启动mariadb数据库</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2023/10/6edf311cf4a5dd1749328456a0008255.png" alt="image-20231015150404823"></p><h2 id="6-2-微软官方（推荐）"><a href="#6-2-微软官方（推荐）" class="headerlink" title="6.2 微软官方（推荐）"></a>6.2 微软官方（推荐）</h2><blockquote><p>参考 <a href="https://zhuanlan.zhihu.com/p/569883693">https://zhuanlan.zhihu.com/p/569883693</a></p></blockquote><p>查看wsl版本号命令为： <code>wsl --version</code>，如果此命令未正常回显版本号，或版本号低于<code>0.67.6</code>，那么你安装的wsl还不支持systemd。如下，我的wsl版本已经是支持的了。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">PS C:\Users\S2522\Desktop&gt; wsl --version</span><br><span class="line">WSL 版本： 1.2.5.0</span><br><span class="line">内核版本： 5.15.90.1</span><br><span class="line">WSLg 版本： 1.0.51</span><br><span class="line">MSRDC 版本： 1.2.3770</span><br><span class="line">Direct3D 版本： 1.608.2-61064218</span><br><span class="line">DXCore 版本： 10.0.25131.1002-220531-1700.rs-onecore-base2-hyp</span><br><span class="line">Windows 版本： 10.0.22621.2134</span><br></pre></td></tr></table></figure><p>进入wsl的CentOS虚拟机，执行如下命令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> -e <span class="string">&quot;[boot]\nsystemd=true&quot;</span> | sudo <span class="built_in">tee</span> -a /etc/wsl.conf</span><br></pre></td></tr></table></figure><p>随后exit退出虚拟机，<strong>回到windows终端命令行</strong>，重启wsl</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wsl <span class="literal">--shutdown</span></span><br></pre></td></tr></table></figure><p>随后再次在windows命令行下执行wsl命令，重启这个虚拟机；</p><p>重启wsl虚拟机后，在<strong>虚拟机内部</strong>执行如下命令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ps --no-headers -o <span class="built_in">comm</span> 1</span><br></pre></td></tr></table></figure><ul><li>如果这个命令返回结果是<strong>systemd</strong>，则代表我们的<code>systemctl</code>命令已经可以使用。</li><li>如果返回的是<code>init</code>，则设置失败</li></ul><p>如下图，我已经设置成功了！</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2023/10/a072fdd5b53abc04cf444c1ab0ac9ad2.png" alt="image-20231015204810685"></p><p>微软官方支持的systemd还是有一点是优于distrod的，那就是启用了官方 systemd 的 wsl2 实例，在用户停止操作后，<strong>会自动关闭</strong>，和未启用 systemd 时的特性一样，这有利于节约电脑的计算资源。</p>]]></content>
    
    
    <summary type="html">win11安装wsl和CentOS8Stream虚拟机</summary>
    
    
    
    <category term="玩上Linux" scheme="https://blog.musnow.top/categories/%E7%8E%A9%E4%B8%8ALinux/"/>
    
    
    <category term="Linux" scheme="https://blog.musnow.top/tags/Linux/"/>
    
    <category term="虚拟机" scheme="https://blog.musnow.top/tags/%E8%99%9A%E6%8B%9F%E6%9C%BA/"/>
    
    <category term="wsl" scheme="https://blog.musnow.top/tags/wsl/"/>
    
  </entry>
  
</feed>
