<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>慕雪的寒舍</title>
  
  <subtitle>雪下了一夜</subtitle>
  <link href="https://blog.musnow.top/atom.xml" rel="self"/>
  
  <link href="https://blog.musnow.top/"/>
  <updated>2023-09-10T00:52:30.000Z</updated>
  <id>https://blog.musnow.top/</id>
  
  <author>
    <name>慕雪年华</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>【MySQL】事务</title>
    <link href="https://blog.musnow.top/posts/2200233148/"/>
    <id>https://blog.musnow.top/posts/2200233148/</id>
    <published>2023-09-10T00:52:14.000Z</published>
    <updated>2023-09-10T00:52:30.000Z</updated>
    
    <content type="html"><![CDATA[<p>学习了之后，你会对MySQL如何进行数据的访问控制有更深刻的了解；</p><span id="more"></span><p>本文中有大量截图，如果出现404的图片，请评论告知，谢谢；</p><h1 id="1-什么是事务？"><a href="#1-什么是事务？" class="headerlink" title="1.什么是事务？"></a>1.什么是事务？</h1><h2 id="1-1-场景举例"><a href="#1-1-场景举例" class="headerlink" title="1.1 场景举例"></a>1.1 场景举例</h2><h3 id="1-1-1-转账"><a href="#1-1-1-转账" class="headerlink" title="1.1.1 转账"></a>1.1.1 转账</h3><p>当A需要给B转账50元的时候，后台应该进行如何处理？</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 先判断用户还有多少余额（这里的user_id=A只是一个示例，知道什么意思就行）</span></span><br><span class="line"><span class="keyword">select</span> money <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">where</span> user_id<span class="operator">=</span>A;</span><br><span class="line"><span class="comment">-- 如果余额充足，那就给A扣50</span></span><br><span class="line"><span class="keyword">update</span> <span class="keyword">user</span> <span class="keyword">set</span> money <span class="operator">=</span> money <span class="operator">-</span> <span class="number">50</span> <span class="keyword">where</span> user_id<span class="operator">=</span>A;</span><br><span class="line"><span class="comment">-- 然后给B加50</span></span><br><span class="line"><span class="keyword">update</span> <span class="keyword">user</span> <span class="keyword">set</span> money <span class="operator">=</span> money <span class="operator">+</span> <span class="number">50</span> <span class="keyword">where</span> user_id<span class="operator">=</span>B;</span><br></pre></td></tr></table></figure><p>这一个操作，需要3个SQL语句才能完成，但很明显，我们即便在当前的服务器端对这3条语句的操作进行加锁，也没有办法避免如下的情况</p><ul><li>服务器负载过高，进程被kill了</li><li>服务器断电了</li><li>MySQL服务器抽风挂掉了</li><li>等等不可抗力</li></ul><p>这时候，如果在执行第一条查询语句后就挂掉了，那还不会有啥问题；但如果是在执行完毕第二条扣钱的语句之后挂掉了，那问题就大了！</p><ul><li>A给B转钱，A的钱扣了，B的钱没有加，这怎么可以？</li></ul><p>最终还需要程序员通过MySQL的日志一个个核对到底是谁出现了这样的情况，给人家把钱加回去，那太过麻烦；在数据量大的时候，这种工作更是不应该由人工手动完成的！</p><p>所以，MySQL就需要提供一种方法，让我们能够实现类似原子性的操作。在执行这3条语句的时候，<strong>只能出现两种情况</strong>：</p><ul><li>成功执行，A扣了钱，B也加了钱，转账成功；</li><li>执行失败，但是A和B的钱都没有变化，并告知用户转账失败；</li></ul><p>这样才是靠谱的结果！</p><h3 id="1-1-2-卖票"><a href="#1-1-2-卖票" class="headerlink" title="1.1.2 卖票"></a>1.1.2 卖票</h3><p>另外<span id="jump1">一个场景</span>就是卖票，其也包含了多条SQL</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> ticket <span class="keyword">where</span> tid<span class="operator">=</span>?; <span class="comment">-- 查询某某车次高铁的票还有没有余量</span></span><br><span class="line"><span class="comment">-- 有余量，进行售卖流程；这里可能要操作另外一张表来添加买票者的用户信息</span></span><br><span class="line"><span class="keyword">update</span> ticket <span class="keyword">set</span> num<span class="operator">=</span>num<span class="number">-1</span> <span class="keyword">where</span> tid<span class="operator">=</span>?; <span class="comment">-- 售卖流程结束，扣去这张票</span></span><br></pre></td></tr></table></figure><p>如果有两个客户端都同时来执行这两条SQL语句，那么就会出现问题；</p><ul><li>只剩一张票</li><li>客户端A进行查询，发现有票，开始执行卖票流程</li><li>客户端B进行查询，也发现有票，开始执行卖票流程</li><li>此时A执行完毕，将票的数量-1，卖完票了；</li><li>随后B执行完毕，也将票的数量-1，此时就会出现票数是负数的情况！</li><li>更难受的是，同一张票被错误地卖给了两个用户！</li></ul><p>这时候在客户端里面加锁是不顶用的，两个客户端都不是同一个进程，锁无法共享；需要MySQL解决这个问题，就还得提供更加严格的访问控制，在A没有完成整个卖票逻辑，票数没有扣掉的情况下，<strong>B不可以来查询票数</strong>；</p><h2 id="1-2-事务的介绍"><a href="#1-2-事务的介绍" class="headerlink" title="1.2 事务的介绍"></a>1.2 事务的介绍</h2><p>事务（transaction）就是一组DML语句的集合，这些语句在逻辑上是一个整体；执行这组语句，必须全部成功，亦或者是全部失败。</p><p>在执行这组SQL的时候，MySQL需要将其视作一个原子性的操作；这个操作不能被其他事务打断，出现问题的时候还需要回滚到开始执行之前的初始状态；事务还能使不同客户端看到的数据是不同的，不同事务之间的操作不会相互影响；只有事务结束后，双方才能看到对方的操作（根据隔离级别不同，这点也会有区别）；</p><p>正如上面的两个场景所提到的操作，同一个时刻对于MySQL的一个数据库来说，其可能有多个客户端进行不同业务的操作，如果都在访问同一个表，在不加访问控制的情况下，一定会出现访问临界资源的数据二义性问题。</p><blockquote><p>事务的出现，是客户端在实际应用场景下的需要，</p></blockquote><p>所以，一个完整的事务，除了是多条DML语句的集合，还需要满足下面4个特性</p><ul><li>原子性：一个事务中的所有操作，要么全部完成，要么全部失败；如果事务在执行过程中发现错误，那就需要回滚（Rollback）到事务开始之前的状态，就好比这个事务并没有执行过一般</li><li>一致性：事务开始之前和结束后，数据库的完整性没有被破坏。进行的操作复合我们预设的要求；这包含数据的准确度、串联性以及后续数据库可以自发完成预定的工作；</li><li>隔离性：数据库允许多个并发事务同时对数据库中的数据进行CURD操作，隔离性保证这些事务之间的操作并不会由于并发的交叉运行而出现不一致的情况。事务隔离性分为不同级别，具体的区别会在后文详解<ul><li>读未提交（Read Uncommitted）</li><li>读已提交（Read Committed）</li><li>可重复读（Repeatble Read）</li><li>串行化（Serializable）</li></ul></li><li>持久性：事务处理完毕后，对事务的修改是永久的，即便系统宕机了也不会丢失（除非硬盘坏了）</li></ul><p>上面的四个属性，简称为ACID；</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">原子性（Atomicity，或称不可分割性）</span><br><span class="line">一致性（Consistency）</span><br><span class="line">隔离性（Isolation，又称独立性）</span><br><span class="line">持久性（Durability）</span><br></pre></td></tr></table></figure><p>其中，一致性是由原子性、隔离性、持久性来保证的，只要满足了这三个性质，自然能实现一致性。简单记忆，AID来保证C；</p><h2 id="1-3-事务的存储引擎支持"><a href="#1-3-事务的存储引擎支持" class="headerlink" title="1.3 事务的存储引擎支持"></a>1.3 事务的存储引擎支持</h2><p>在MySQL中，只有<code>Innodb</code>支持事务，<code>MyISAM</code>是不支持事务的；</p><p>我们可以用如下语句来查询MySQL的引擎和支持的特性</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line">MariaDB [hello_mysql]<span class="operator">&gt;</span> <span class="keyword">show</span> engines \G</span><br><span class="line"><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span> <span class="number">1.</span> <span class="type">row</span> <span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span></span><br><span class="line">      Engine: MEMORY</span><br><span class="line">     Support: YES</span><br><span class="line">     Comment: Hash based, stored <span class="keyword">in</span> memory, useful <span class="keyword">for</span> temporary tables</span><br><span class="line">Transactions: <span class="keyword">NO</span></span><br><span class="line">          XA: <span class="keyword">NO</span></span><br><span class="line">  Savepoints: <span class="keyword">NO</span></span><br><span class="line"><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span> <span class="number">2.</span> <span class="type">row</span> <span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span></span><br><span class="line">      Engine: MRG_MyISAM</span><br><span class="line">     Support: YES</span><br><span class="line">     Comment: Collection <span class="keyword">of</span> identical MyISAM tables</span><br><span class="line">Transactions: <span class="keyword">NO</span></span><br><span class="line">          XA: <span class="keyword">NO</span></span><br><span class="line">  Savepoints: <span class="keyword">NO</span></span><br><span class="line"><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span> <span class="number">3.</span> <span class="type">row</span> <span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span></span><br><span class="line">      Engine: CSV</span><br><span class="line">     Support: YES</span><br><span class="line">     Comment: Stores tables <span class="keyword">as</span> CSV files</span><br><span class="line">Transactions: <span class="keyword">NO</span></span><br><span class="line">          XA: <span class="keyword">NO</span></span><br><span class="line">  Savepoints: <span class="keyword">NO</span></span><br><span class="line"><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span> <span class="number">4.</span> <span class="type">row</span> <span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span></span><br><span class="line">      Engine: BLACKHOLE</span><br><span class="line">     Support: YES</span><br><span class="line">     Comment: <span class="operator">/</span>dev<span class="operator">/</span><span class="keyword">null</span> storage engine (anything you write <span class="keyword">to</span> it disappears)</span><br><span class="line">Transactions: <span class="keyword">NO</span></span><br><span class="line">          XA: <span class="keyword">NO</span></span><br><span class="line">  Savepoints: <span class="keyword">NO</span></span><br><span class="line"><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span> <span class="number">5.</span> <span class="type">row</span> <span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span></span><br><span class="line">      Engine: MyISAM</span><br><span class="line">     Support: YES</span><br><span class="line">     Comment: Non<span class="operator">-</span>transactional engine <span class="keyword">with</span> good performance <span class="keyword">and</span> small data footprint</span><br><span class="line">Transactions: <span class="keyword">NO</span></span><br><span class="line">          XA: <span class="keyword">NO</span></span><br><span class="line">  Savepoints: <span class="keyword">NO</span></span><br><span class="line"><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span> <span class="number">6.</span> <span class="type">row</span> <span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span></span><br><span class="line">      Engine: ARCHIVE</span><br><span class="line">     Support: YES</span><br><span class="line">     Comment: gzip<span class="operator">-</span>compresses tables <span class="keyword">for</span> a low storage footprint</span><br><span class="line">Transactions: <span class="keyword">NO</span></span><br><span class="line">          XA: <span class="keyword">NO</span></span><br><span class="line">  Savepoints: <span class="keyword">NO</span></span><br><span class="line"><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span> <span class="number">7.</span> <span class="type">row</span> <span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span></span><br><span class="line">      Engine: FEDERATED</span><br><span class="line">     Support: YES</span><br><span class="line">     Comment: Allows <span class="keyword">to</span> access tables <span class="keyword">on</span> other MariaDB servers, supports transactions <span class="keyword">and</span> more</span><br><span class="line">Transactions: YES</span><br><span class="line">          XA: <span class="keyword">NO</span></span><br><span class="line">  Savepoints: YES</span><br><span class="line"><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span> <span class="number">8.</span> <span class="type">row</span> <span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span></span><br><span class="line">      Engine: PERFORMANCE_SCHEMA</span><br><span class="line">     Support: YES</span><br><span class="line">     Comment: Performance Schema</span><br><span class="line">Transactions: <span class="keyword">NO</span></span><br><span class="line">          XA: <span class="keyword">NO</span></span><br><span class="line">  Savepoints: <span class="keyword">NO</span></span><br><span class="line"><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span> <span class="number">9.</span> <span class="type">row</span> <span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span></span><br><span class="line">      Engine: SEQUENCE</span><br><span class="line">     Support: YES</span><br><span class="line">     Comment: Generated tables filled <span class="keyword">with</span> sequential <span class="keyword">values</span></span><br><span class="line">Transactions: YES</span><br><span class="line">          XA: <span class="keyword">NO</span></span><br><span class="line">  Savepoints: YES</span><br><span class="line"><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span> <span class="number">10.</span> <span class="type">row</span> <span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span></span><br><span class="line">      Engine: InnoDB</span><br><span class="line">     Support: <span class="keyword">DEFAULT</span> <span class="comment">-- 默认引擎</span></span><br><span class="line">     Comment: Supports transactions, <span class="type">row</span><span class="operator">-</span>level locking, <span class="keyword">foreign</span> keys <span class="keyword">and</span> encryption <span class="keyword">for</span> tables <span class="comment">-- 描述</span></span><br><span class="line">Transactions: YES  <span class="comment">-- 支持事务</span></span><br><span class="line">          XA: YES  </span><br><span class="line">  Savepoints: YES  <span class="comment">-- 支持事务中的保存点</span></span><br><span class="line"><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span> <span class="number">11.</span> <span class="type">row</span> <span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span></span><br><span class="line">      Engine: Aria</span><br><span class="line">     Support: YES</span><br><span class="line">     Comment: Crash<span class="operator">-</span>safe tables <span class="keyword">with</span> MyISAM heritage</span><br><span class="line">Transactions: <span class="keyword">NO</span></span><br><span class="line">          XA: <span class="keyword">NO</span></span><br><span class="line">  Savepoints: <span class="keyword">NO</span></span><br><span class="line"><span class="number">11</span> <span class="keyword">rows</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.000</span> sec)</span><br></pre></td></tr></table></figure><h2 id="1-4-保存点"><a href="#1-4-保存点" class="headerlink" title="1.4 保存点"></a>1.4 保存点</h2><p>所谓保存点，就是在事务执行过程中，给当前的数据设置一个savepoint，这样在出现问题的时候，可以回退到当前的数据中；就好比之后的操作没有进行一样；</p><p>游戏中的保存点其实也是这样的功能，让玩家回退到打某个BOSS之前，包括当时你收集的材料，都会回退到打这个BOSS之前的状态；</p><p>你可以理解为，是给当前的数据拍了张照片，出现问题的时候，用这个照片里面的东西复写掉新的东西。这便是保存点的作用；</p><h2 id="1-5-基础命令操作"><a href="#1-5-基础命令操作" class="headerlink" title="1.5 基础命令操作"></a>1.5 基础命令操作</h2><p>先提一下事务的开启和结束方式，以及如何设置保存点和回滚吧</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 开启，这两种方式是一样的</span></span><br><span class="line"><span class="keyword">begin</span>;</span><br><span class="line"><span class="keyword">start</span> transaction;</span><br><span class="line"><span class="comment">-- 设置保存点（名字可以自由更改，但不能有重复）</span></span><br><span class="line"><span class="keyword">savepoint</span> save1; <span class="comment">-- 创建一个保存点save1</span></span><br><span class="line"><span class="keyword">rollback</span> <span class="keyword">to</span> save1; <span class="comment">-- 回滚到保存点save1</span></span><br><span class="line"><span class="keyword">rollback</span>; <span class="comment">-- 回滚到事务开始</span></span><br><span class="line"><span class="comment">-- 结束</span></span><br><span class="line"><span class="keyword">commit</span>; <span class="comment">-- 提交事务</span></span><br></pre></td></tr></table></figure><h1 id="2-使用"><a href="#2-使用" class="headerlink" title="2.使用"></a>2.使用</h1><p>了解了事务为什么存在，下面就是来使用一下事务了；</p><h2 id="2-1-提交方式"><a href="#2-1-提交方式" class="headerlink" title="2.1 提交方式"></a>2.1 提交方式</h2><p>事务的提交方式有两种方式</p><ul><li>自动提交</li><li>手动提交</li></ul><p>默认情况下，MySQL的自动提交是处于开启状态的</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">MariaDB [hello_mysql]&gt; show variables like &#x27;autocommit&#x27;;</span><br><span class="line">+---------------+-------+</span><br><span class="line">| Variable_name | Value |</span><br><span class="line">+---------------+-------+</span><br><span class="line">| autocommit    | ON    |</span><br><span class="line">+---------------+-------+</span><br><span class="line">1 row in set (0.001 sec)</span><br></pre></td></tr></table></figure><p>我们可以用下面的语句来设置是否开启自动提交（只对当前会话生效）</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">set</span> autocommit <span class="operator">=</span> <span class="number">0</span>; <span class="comment">-- 关闭自动提交</span></span><br><span class="line"><span class="keyword">set</span> autocommit <span class="operator">=</span> <span class="number">1</span>; <span class="comment">-- 开启</span></span><br></pre></td></tr></table></figure><p>这两个提交方式有啥区别呢？是不是开了自动提交就什么都不用管了？后文我们再通过实测来说明；</p><h2 id="2-2-场景演示"><a href="#2-2-场景演示" class="headerlink" title="2.2 场景演示"></a>2.2 场景演示</h2><p>最开始测试的时候，先将事务隔离级别设置为读未提交；请注意，不要在有生产环境的MySQL中进行此项操作；</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 设置全局隔离级别为读未提交</span></span><br><span class="line"><span class="keyword">set</span> <span class="keyword">global</span> transaction isolation level READ UNCOMMITTED; </span><br><span class="line"><span class="comment">-- 重启mysql终端后查看隔离级别</span></span><br><span class="line"><span class="keyword">select</span> @<span class="variable">@tx</span>_isolation; </span><br><span class="line"><span class="operator">+</span><span class="comment">------------------+</span></span><br><span class="line"><span class="operator">|</span> @<span class="variable">@tx</span>_isolation   <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">------------------+</span></span><br><span class="line"><span class="operator">|</span> READ<span class="operator">-</span>UNCOMMITTED <span class="operator">|</span>   <span class="comment">-- 成功设置读未提交的隔离级级别</span></span><br><span class="line"><span class="operator">+</span><span class="comment">------------------+</span></span><br><span class="line"><span class="number">1</span> <span class="type">row</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.000</span> sec)</span><br></pre></td></tr></table></figure><h3 id="2-2-1-数据回滚演示"><a href="#2-2-1-数据回滚演示" class="headerlink" title="2.2.1 数据回滚演示"></a>2.2.1 数据回滚演示</h3><p>设置完毕后，进入测试数据库，创建如下测试表</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> test_ruc(</span><br><span class="line">id <span class="type">int</span> unsigned <span class="keyword">primary</span> key,</span><br><span class="line">user_id <span class="type">int</span> unsigned <span class="keyword">not</span> <span class="keyword">null</span>,</span><br><span class="line">    name <span class="type">varchar</span>(<span class="number">30</span>) <span class="keyword">not</span> <span class="keyword">null</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>先给表里面插入几个基本的数据：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> test_ruc <span class="keyword">values</span> (<span class="number">1</span>,<span class="number">10</span>,<span class="string">&#x27;李华&#x27;</span>),(<span class="number">2</span>,<span class="number">20</span>,<span class="string">&#x27;王五&#x27;</span>);</span><br></pre></td></tr></table></figure><p>插入后，我们在两侧的终端中都可以看到已有的数据</p><p><img src="https://img.musnow.top/i/2023/09/319fbe3f23373d34fb0eff4a249ef16b.png" alt="image-20230910163833837"></p><p>随后在两个终端中都开启一个事务，左侧终端插入一个数据，右侧终端查看</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> test_ruc <span class="keyword">values</span> (<span class="number">3</span>,<span class="number">30</span>,<span class="string">&#x27;左侧终端插入&#x27;</span>);</span><br></pre></td></tr></table></figure><p>可以看到，两侧的终端都可以看到这份数据</p><p><img src="https://img.musnow.top/i/2023/09/8021cf95d4fa8a29c24771161f17cf52.png" alt="image-20230910164315360"></p><p>此时将左侧终端强制退出（使用<code>CTRL+\</code>），右侧再次查询，会发现新插入的数据没有了；这里便是事务的<strong>原子性</strong>的体现，左侧的终端所执行的事务没有<code>commit</code>就因为异常退出了，MySQL自动将数据回滚到了这个事务执行之前，即没有插入这份新数据；</p><p><img src="https://img.musnow.top/i/2023/09/db2ea78350e2fe7927f8367f7aecf2db.png" alt="image-20230910164414488"></p><p>左侧重新链接MySQL，开启一个事务；在右侧插入一个数据，随后创建保存点<code>save1</code>；插入第二个数据，创建保存点<code>save2</code>；</p><p>在左侧查询，我们可以看到右侧插入的两条新数据；</p><p><img src="https://img.musnow.top/i/2023/09/cf012a62e99049bc5b41b66583e7b49a.png" alt="image-20230910165426916"></p><p>在右侧回滚到保存点save1，会发现插入的数据2没有了；这与保存点的预期操作相符合；</p><p><img src="https://img.musnow.top/i/2023/09/99e569e2c4fde9770594fc1176aa52ec.png" alt="image-20230910165719357"></p><p>将右侧终端强制退出，再次查询数据，可以看到第一次插入的数据也没有了，数据又回到了右侧终端事务开始之前的样子。</p><p><img src="https://img.musnow.top/i/2023/09/60cb747da1ac4756bce1c6e6ff12ace0.png" alt="image-20230910171826318"></p><p>这里能得出一个结论：如果终端异常退出，MySQL会将数据回滚到事务开始时；你可以理解为，我们使用<code>begin;</code>的时候就已经创建了一个隐藏的保存点，MySQL在异常的时候只会将数据回退到这个<strong>事务开始之时</strong>的隐藏保存点，无论中途用户有没有设置其他保存点！</p><p>即：在异常退出的时候，MySQL会自动帮我们执行<code>rollback</code>命令回退到事务开头！</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">rollback</span>; <span class="comment">-- 回退到事务开头</span></span><br></pre></td></tr></table></figure><p>这样就能避免最开始提到的，转账系统中给A扣了钱但是没有给B加钱的问题！</p><h3 id="2-2-2-数据持久化演示"><a href="#2-2-2-数据持久化演示" class="headerlink" title="2.2.2 数据持久化演示"></a>2.2.2 数据持久化演示</h3><p>接着我们再来看看，如果执行了commit之后又会是什么情况</p><p><img src="https://img.musnow.top/i/2023/09/e04e7e3b782a176b62e140c1143b1695.png" alt="image-20230910213252764"></p><h3 id="2-2-3-自动提交"><a href="#2-2-3-自动提交" class="headerlink" title="2.2.3 自动提交"></a>2.2.3 自动提交</h3><p>前面提到了，MySQL的自动提交默认是开启的；那么这个自动提交有什么作用呢？是不是开启了自动提交，就不需要手动创建事务了？</p><p><strong>并不是</strong>！在之前的测试中，<code>autocommit</code>是开启的；我们已经证明了，手动<code>begin</code>创建的事务，在没有手动<code>commit</code>的时候不会被写入磁盘（不进行持久化）；这代表我们手动创建的事务，不会受到<code>autocommit</code>是否开关的影响；（开着的时候都没有自动提交，关闭的时候肯定更不会自动提交了）</p><ul><li>那么这个<code>autocommit</code>会影响谁呢？</li></ul><p>开启两个终端，左侧将自动提交关闭，随后插入一个数据；插入后会发现右侧看不到左侧新插入的数据！</p><blockquote><p>备注：<code>set autocommit = 0;</code>语句只会影响当前终端，不会影响另外的终端。</p></blockquote><p><img src="https://img.musnow.top/i/2023/09/05a473c988222c4e9f669040110ce010.png" alt="image-20230911081342217"></p><p>此时手动进行<code>commit</code>，右侧就看得到数据了！</p><p><img src="https://img.musnow.top/i/2023/09/b0c20ecfa43ae1ba23143c78abea5a3d.png" alt="image-20230911081509985"></p><p>而如果我们不手动执行<code>commit</code>就把左侧终端<code>CTRL+\</code>退出，那么新插入的这一条数据会丢失！</p><h3 id="2-2-4-单条SQL和事务的关系"><a href="#2-2-4-单条SQL和事务的关系" class="headerlink" title="2.2.4 单条SQL和事务的关系"></a>2.2.4 单条SQL和事务的关系</h3><p>欸？我们明明没有<code>begin</code>开启事务，为什么可以执行<code>commit</code>呢？</p><p>这是因为，在MySQL中，每一个不主动使用事务的单条SQL语句，都会视作一个事务进行操作！既我们之前没学习事务时，执行的所有单条SQL也是一个个各自独立的事务！</p><p>知道了这一点，你就能理解<strong>自动提交的作用</strong>了：在执行单条SQL的时候，是否自动提交该SQL语句的事务。</p><p>将<code>autocommit</code>重新开启，再进行测试；会发现左侧插入的数据右侧可以立马看到，无需手动<code>commit</code>。这便是自动提交的作用的体现！</p><p><img src="https://img.musnow.top/i/2023/09/2fa8f41ee1644efb200d2fdbe65677ac.png" alt="image-20230911082134863"></p><h2 id="2-3-结论"><a href="#2-3-结论" class="headerlink" title="2.3 结论"></a>2.3 结论</h2><p>经过上面的这些简单测试，我们可以看到事务的原子性和持久性，做一个总结</p><ul><li>输入了<code>begin/start transaction</code>手动创建的事务，必须通过<code>commit</code>手动挡提交，才会持久化；这一点和<code>autocommit</code>无关！</li><li>事务可以设置保存点和手动回滚，出现异常的时候，MySQL会自动回退到事务开头；</li><li>对于<code>InnoDB</code>存储引擎而言，所有的单条SQL语句都会被视作一个事务，自动提交；</li><li><code>select</code>语句会有一些差别，因为MySQL有MVCC访问控制（后文讲解）</li></ul><p>操作事务的一些注意事项</p><ul><li>只有<code>InnoDB</code>才支持事务，<code>MyISAM</code>不支持;</li><li>一个事务被提交了之后，不可以执行<code>rollback</code>;</li><li>创建了保存点后，可以选择回退到哪一个保存点，亦或者是回退到事务开头；</li></ul><h1 id="3-事务隔离级别"><a href="#3-事务隔离级别" class="headerlink" title="3.事务隔离级别"></a>3.事务隔离级别</h1><h2 id="3-1-基本说明"><a href="#3-1-基本说明" class="headerlink" title="3.1 基本说明"></a>3.1 基本说明</h2><p>事务的隔离级别和事务的隔离性息息相关</p><ul><li>MySQL的单个数据库可能被多个进程&#x2F;线程同时进行访问和事务操作；</li><li>一个事务是由多个SQL语句组成的，任何一个事务，都会存在执行前&#x2F;中&#x2F;后的阶段。所谓原子性，就是MySQL要保证各个客户端要么只能看到事务执行前或者执行后的数据；执行中的事务，对于其他用户来看是原子的，出现异常会被自动回滚；</li><li>但事务毕竟还是存在执行中的概念，其他客户端是有可能看到某个事物执行中的状态的，这就需要隔离性来介入了；</li><li>隔离性：保证事务在执行过程中尽量不受干扰；</li><li>隔离级别：允许事务受不同程度的干扰；</li></ul><p>开头就提到了，MySQL的事务有4种隔离级别</p><ul><li>读未提交（Read Uncommitted）：在这个隔离级别中，所有事务都可以看到其他事物还没有提交的内容（你可以理解为压根没有隔离性，之前的测试使用的就是这个隔离级别）这种情况下就容易引起并发和读取数据的不一致问题，还有<strong>脏读</strong>问题（对方没有commit的数据就叫做脏数据），生产环境中是打死不能用这个隔离级别的！</li><li>读已提交（Read Committed）：在这个隔离级别中，事务只可以看到其他事务已经提交了的内容。这已经满足了隔离的基本定义：只能看到其他事务开始前或者开始后的内容；但是这种隔离模式会产生<strong>不可重复读</strong>的问题（相同<code>select</code>会出现不同结果）；</li><li>可重复读（Repeatable Read）：为了解决不可重复读的问题，这个隔离级别保证了事务在运行过程中多次读取相同数据时会得到相同结果；但是这个隔离级别在某些数据库中可能会出现<strong>幻读</strong>问题；MySQL默认采用此隔离级别；</li><li>串行化（Serializable）：所谓串行化，就是MySQL给数据库的所有操作都上锁，必须要排队运行。一个事务在运行时，另外一个事务得等它运行完毕了才能进来运行，这样能最大程度保证隔离性；但是会降低效率；</li></ul><p>隔离级别是由MySQL进行各种类型的加锁来实现的，比如表锁、行锁、读写锁、间隙锁（GAP）、NEXT-KEY锁（GAP+行锁）等等；</p><blockquote><p>这里还需要验证另外一件事，MySQL如果开启了串行化，客户端c&#x2F;cpp操作还需要加锁吗？<code>mysqlquery</code>的操作是会阻塞还是直接错误退出？</p></blockquote><p>在MySQL中，事务的隔离级别可以分别设置全局的隔离级别和当前客户端的隔离级别；如果没有主动设置客户端的隔离级别，则会继承全局的隔离级别。顾名思义，会话隔离级别只会影响当前的会话，不会影响另外的客户端；</p><p>另外，全局的隔离级别会在数据库服务重启后，被重置为配置文件中默认的隔离级别（一般是RR）</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 设置 会话/全局 隔离级别</span></span><br><span class="line"><span class="keyword">set</span> [session <span class="operator">|</span> <span class="keyword">global</span>] transaction isolation level [read uncommitted <span class="operator">|</span> read committed <span class="operator">|</span> repeatable read <span class="operator">|</span> serializable ]</span><br><span class="line"><span class="comment">-- 查看当前会话的隔离级别</span></span><br><span class="line"><span class="keyword">select</span> @<span class="variable">@session</span>.tx_isolation;</span><br><span class="line"><span class="comment">-- 查看全局的隔离级别</span></span><br><span class="line"><span class="keyword">select</span> @<span class="variable">@tx</span>_isolation;</span><br></pre></td></tr></table></figure><h2 id="3-2-读未提交"><a href="#3-2-读未提交" class="headerlink" title="3.2 读未提交"></a>3.2 读未提交</h2><p>这个隔离级别在第二大点里面就已经测试过了，左侧终端插入的数据，即便没有commit，在右侧终端中也能看得到，这里就不二次演示了</p><p><img src="https://img.musnow.top/i/2023/09/8021cf95d4fa8a29c24771161f17cf52.png" alt="image-20230910164315360"></p><p>清楚已有的数据，来测试一下会话隔离级别的作用；默认情况下，全局和会话的隔离级别都是RR；</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">MariaDB [hello_mysql]&gt; select @@tx_isolation;</span><br><span class="line">+-----------------+</span><br><span class="line">| @@tx_isolation  |</span><br><span class="line">+-----------------+</span><br><span class="line">| REPEATABLE-READ |</span><br><span class="line">+-----------------+</span><br><span class="line">1 row in set (0.000 sec)</span><br><span class="line"></span><br><span class="line">MariaDB [hello_mysql]&gt; select @@session.tx_isolation;</span><br><span class="line">+------------------------+</span><br><span class="line">| @@session.tx_isolation |</span><br><span class="line">+------------------------+</span><br><span class="line">| REPEATABLE-READ        |</span><br><span class="line">+------------------------+</span><br><span class="line">1 row in set (0.000 sec)</span><br></pre></td></tr></table></figure><p>将左侧的终端中的会话隔离级别设置为读未提交</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">set</span> session transaction isolation level read uncommitted;</span><br></pre></td></tr></table></figure><p><strong>插入数据之前</strong>，执行一次<code>select</code>全列查询，两侧都是空；</p><p>在左侧插入数据后，右侧查看会发现依旧是<code>empty set</code>没有结果；只有左侧<code>commit</code>之后，右侧才能看到数据；这是因为在之前测试的时候，<strong>我们将自动提交关闭了</strong>；右侧看不到我们还没有提交的事务；</p><p><img src="https://img.musnow.top/i/2023/09/9c76acac8deca528d4226b226146de13.png" alt="image-20230911100829407"></p><p>右侧手动开启事务后，即便没有进行<code>commit</code>，但是左侧因为设置了读未提交，所以可以直接看到右侧还没有提交的事务中的修改。这便是这个隔离级别的特性；</p><p><img src="https://img.musnow.top/i/2023/09/6ba51b47e8c05b4171645e423f1ad6a2.png" alt="image-20230911101100927"></p><h2 id="3-3-读已提交"><a href="#3-3-读已提交" class="headerlink" title="3.3 读已提交"></a>3.3 读已提交</h2><p>接下来再将全局隔离级别设置为读已提交，重新开启两个终端进行测试；</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set global transaction isolation level read committed;</span><br></pre></td></tr></table></figure><p>设置完毕，重启终端后，可以看到两侧的隔离级别都是读已提交，自动提交都是开启的；</p><p><img src="https://img.musnow.top/i/2023/09/bc6c1464a3c9331191aee2a24f9273e4.png" alt="image-20230911102633596"></p><p>两侧都开启一个事务，左侧插入数据，右侧查看，发现没有内容；</p><p><img src="https://img.musnow.top/i/2023/09/8e60ab3a2b5b4bff70b80ed22bce706b.png" alt="image-20230911103402950"></p><p>左侧commit之后，右侧才可以看到这个数据；</p><p><img src="https://img.musnow.top/i/2023/09/9ec9807c381ccebd42a77a741151c422.png" alt="image-20230911103432740"></p><p>这符合我们对<strong>读已提交</strong>这个隔离级别的字面理解，但是这并不代表这个隔离级别没有问题！</p><h3 id="3-3-1-出问题的场景"><a href="#3-3-1-出问题的场景" class="headerlink" title="3.3.1 出问题的场景"></a>3.3.1 出问题的场景</h3><p>来看看下面这个场景：</p><ul><li>公司需要根据员工工资，分发不同级别的奖金：<ul><li>2000-4000 级别一</li><li>4001-8000 级别二</li><li>8001-15000 级别三</li></ul></li><li>甲开启了一个客户端，开始用MySQL筛选不同工资区间的员工，记录下来；</li><li>乙开启了一个客户端，想要给员工丁加工资<ul><li>丁原本的工资是3000</li><li>乙给丁加了2000工资，丁的工资变成了5000，跳到了工资级别二；</li><li>乙提交修改（commit）</li></ul></li><li>假设甲已经完成了对2000-4000级别工资的员工筛选，此时乙过来给丁加了工资，丁跳到了工资级别二；</li><li>因为隔离级别是读已提交，甲在筛选工资级别二的人员时，会把刚刚被修改过的丁也给纳入进去；</li><li>这时候，对于甲而言，<strong>丁就同时出现在了工资级别一和二的人员中，这明显是不合理的</strong>！</li></ul><p>这个场景被称为<code>不可重复读</code>，即在一个事务中，同一个查询语句，可能会因为其他事务的提交而产生不同的结果；换做SQL语句来描述，在读已提交的隔离级别中，同一个select语句只能执行一次，第二次执行的时候，可能会获取到和第一次不同的结果，所以这个问题才被称作<code>不可重复读</code>（不可以重复执行select）问题；</p><hr><p>来实际演示一下，两侧都开启一个新的事务，左侧终端更新表中的用户id，只要它不提交，右侧就看不到修改。</p><p><img src="https://img.musnow.top/i/2023/09/8789693271635e5d27c7ad0873937af8.png" alt="image-20230911105147039"></p><p>但是提交了之后，右侧就能看到这个用户id的改变，在进行数据筛选的时候，这种情形就会出现问题！</p><p><img src="https://img.musnow.top/i/2023/09/c9f4f3c119361dfcfab135c9e4342921.png" alt="image-20230911105214340"></p><h2 id="3-4-可重复读"><a href="#3-4-可重复读" class="headerlink" title="3.4 可重复读"></a>3.4 可重复读</h2><p>所以，为了避免上面提到的这个问题，MySQL还提供了一个可重复读的隔离级别，且默认采用的就是这个隔离级别；</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">set</span> <span class="keyword">global</span> transaction isolation level  repeatable read;</span><br></pre></td></tr></table></figure><p>可重复读就解决了上面提到的问题，即便其他事务提交了修改，当前事务也看不到这份修改，只有当前事务结束后，才能看到最新的数据；</p><p>看下图，两侧都开启一个事务，不管左侧是否有提交事务，右侧都看不到左侧新插入的数据；</p><p><img src="https://img.musnow.top/i/2023/09/c702bd94bb9b4f1b39da177aba23faf0.png" alt="image-20230911150201158"></p><p>只有右侧也提交了自己的事务，才能看到左侧插入的新数据；</p><p><img src="https://img.musnow.top/i/2023/09/8e5ce5e2e310cf65a10b003bb0036e3e.png" alt="image-20230911150323005"></p><p>这就保证了，右侧这个事务在运行的始终，它执行的相同<code>select</code>语句的结果永远都是一样的，不会出现不可重复读的问题！</p><p>而如果在RR级别中，同时访问相同数据，会出现<strong>加锁</strong>的情况，下图中，右侧插入了主键为6的数据，此时左侧如果也尝试插入一个主键为6的数据，会进入阻塞状态；</p><p><img src="https://img.musnow.top/i/2023/09/fa7dbb9ad31fd27e00307f37aac40a4e.png" alt="image-20230911151027879"></p><p>如果很久都不继续操作，就会因为等待超时，跳出等待</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">MariaDB [hello_mysql]&gt; insert into test_ruc values (6,60,&#x27;天数&#x27;);</span><br><span class="line">ERROR 1205 (HY000): Lock wait timeout exceeded; try restarting transaction</span><br></pre></td></tr></table></figure><p>但当前事务中插入的数据依旧是存在的，当前事务也没有结束</p><p><img src="https://img.musnow.top/i/2023/09/d8de538b5a89adf04842efd2097239c6.png" alt="image-20230911151335335"></p><p>再次尝试插入这个主键为6的数据，依旧会陷入阻塞态，只有右侧的事务被提交了之后，左侧才会出现主键冲突的提示，禁止插入；</p><p><img src="https://img.musnow.top/i/2023/09/be7f7f5c5a63329fbe574ba4ff22d085.png" alt="image-20230911151444595"></p><p>左侧commit了之后，右侧才能看到左侧新插入的主键为5的数据；</p><p><img src="https://img.musnow.top/i/2023/09/0827a5499036b9e5b024b60f174ec44a.png" alt="image-20230911151710391"></p><h2 id="3-5-串行化"><a href="#3-5-串行化" class="headerlink" title="3.5 串行化"></a>3.5 串行化</h2><p>这个就比较简单了，一个事务没结束，另外一个就阻塞等待；</p><p>串行化是最高的隔离级别，但其并发性能很低，实际上用的也不多；</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set global transaction isolation level  serializable;</span><br></pre></td></tr></table></figure><p>两侧终端都开始事务，查询的时候是不会加锁的，但是左侧执行<code>update</code>的时候，阻塞了（可以通过左侧update的执行时间观察到阻塞现象，截图看的不是很明显）；右侧也执行一次<code>update</code>，左侧的update就立马成功了，右侧显示报错检测到死锁，建议尝试重启事务；</p><p><img src="https://img.musnow.top/i/2023/09/d75f063fa7959ec6c7926eba70d25e35.png" alt="image-20230911110259760"></p><p>再来试试，两侧都开启事务，左侧尝试插入一个数据，<strong>会阻塞</strong>；右侧<code>commit</code>之后，左侧的插入就立马成功了！</p><p><img src="https://img.musnow.top/i/2023/09/8f8ed448629e2b9a842eb819c91f6cea.png" alt="image-20230911110525989"></p><p>这便是串行化的表现：两个事务如果都是在执行select的读取操作，则不会被阻塞，但如果有一个事务要执行<strong>增删改</strong>，那么就必须等待其他事务都结束了，这个操作才能被执行；</p><h3 id="3-5-1-串行化的适用场景"><a href="#3-5-1-串行化的适用场景" class="headerlink" title="3.5.1 串行化的适用场景"></a>3.5.1 串行化的适用场景</h3><p>回到 <a href="#jump1">1.1.2 卖票</a> 的场景，在这个场景下，如果你需要保证客户端A的卖票逻辑完全执行完毕了，客户端B才能过来查询票数，那就需要使用串行化；</p><p>但是，串行化中，我们是可以执行查询操作的！那么在A没有结束的情况下，B不还是会查询到有剩余票数？</p><blockquote><p>实际上，我们的卖票操作并不是直连数据库实现的，而是有一个服务端进程来提供API，供客户端来查询剩余票数，剩下的卖票操作其实都是服务端来实现的（让客户端直连MySQL来执行SQL是非常不可靠的，很有可能出现SQL注入攻击）</p></blockquote><p>所以，这个问题得在服务端进程中加锁解决！MySQL本身即便使用串行化也是没有办法解决这个问题的；</p><p>但是，别忘了，MySQL还有另外一个东西——<strong>约束</strong>；你可以设置一个触发器，更新剩余票数的时候，拒绝将票数设置为负数；这样客户端B即便进入了卖票业务，最终将剩余票数的数据设置为负数的时候，<strong>也会被MySQL阻止插入</strong>，这个卖票的事务B就相当于错误退出了，所有操作都会被回滚！而隔离级别就是避免A和B同时修改一个数据而导致的错误；</p><p>二者相辅相成，就能解决这个问题；当然，在服务端API处理逻辑中加锁是更好的解决办法，既可以保证数据一致性，又能隔离客户端和MySQL服务；</p><h2 id="3-6-总结"><a href="#3-6-总结" class="headerlink" title="3.6 总结"></a>3.6 总结</h2><ul><li>隔离级别越高，安全性越高，数据库的并发性能就越低；我们需要根据业务逻辑，选用合适的隔离级别；</li><li>不可重复读的问题在于其他客户端的修改和删除，同样的select语句会查出不同的结果，是不合理的；</li><li>幻读的重点在于新增，其他客户端新增的记录可能被我们当前的客户端查询到；但是在MySQL中，这个问题是不存在的，因为<code>InnoDB</code>通过NEXT-KEY锁解决了幻读问题；</li><li>事务也分为长短事务的概念，事务之间互相影响，主要指的是事务在并行阶段（都没有<code>commit</code>的时候）产生的影响；</li><li>一般情况下，我们使用MySQL默认的RR的事务级别就可以了；</li></ul><p>下面给出一个不同事务级别之间的区别的表格，Y代表会出现这个问题，N代表不会出现这个问题</p><table><thead><tr><th>隔离级别</th><th>脏读</th><th>不可重复读</th><th>幻读</th><th>加锁读</th></tr></thead><tbody><tr><td>读未提交</td><td>Y</td><td>Y</td><td>Y</td><td>不加锁</td></tr><tr><td>读已提交</td><td>N</td><td>Y</td><td>Y</td><td>不加锁</td></tr><tr><td>可重复读</td><td>N</td><td>N</td><td>N</td><td>不加锁</td></tr><tr><td>串行化</td><td>N</td><td>N</td><td>N</td><td>加锁</td></tr></tbody></table><h2 id="3-7-一致性"><a href="#3-7-一致性" class="headerlink" title="3.7 一致性"></a>3.7 一致性</h2><ul><li>事务执行的结果，必须使数据库从一个一致性状态，变到另一个一致性状态。当数据库只包含事务 成功提交的结果时，数据库处于一致性状态。</li><li>如果系统运行发生中断，某个事务尚未完成而被迫中 断，而改未完成的事务对数据库所做的修改已被写入数据库，此时数据库就处于一种不正确（不一致）的状态。因此一致性是通过<strong>原子性</strong>来保证的。</li><li>其实一致性和用户的业务逻辑强相关，一般MySQL提供技术支持，但是一致性还是要用户业务逻辑做支撑（比如客户端如果不使用事务，那MySQL也没有办法帮助维护），所以说，一致性是由用户决定是否维护的。 </li><li>技术上，通过AID保证C</li></ul><h1 id="4-隔离性的理解"><a href="#4-隔离性的理解" class="headerlink" title="4.隔离性的理解"></a>4.隔离性的理解</h1><p>说完了隔离级别，接下来再深入理解一下隔离性</p><h2 id="4-1-MVCC"><a href="#4-1-MVCC" class="headerlink" title="4.1 MVCC"></a>4.1 MVCC</h2><p>数据库并发的场景一共有下面三种</p><ul><li><code>读-读</code>：不存在任何问题，不需要访问控制</li><li><code>读-写</code>：有线程安全问题，可能会遇到隔离性中的脏读、幻读、不可重复读问题；</li><li><code>写-写</code>：有线程安全问题，还有可能出现更新丢失问题；</li></ul><p>我们主要关注的是读写并发的情况，这也是数据库最常遇到的处理场景；</p><p>再MySQL中，采用了MVCC（多版本并发控制）来解决读写冲突，这是一种无锁的并发控制机制；</p><p>在了解MVCC之前，我们需要了解几个前置知识：</p><ul><li>三个隐藏列字段</li><li>UNDO日志</li><li>READ VIEW</li></ul><h3 id="4-1-1-隐藏列字段"><a href="#4-1-1-隐藏列字段" class="headerlink" title="4.1.1 隐藏列字段"></a>4.1.1 隐藏列字段</h3><p>在MySQL中，每一个表都存在三个隐藏的列字段</p><ul><li>DB_TRX_ID：6 byte，最近修改(修改&#x2F;插入)事务ID，记录创建这条记录&#x2F;最后一次修改该记录的事务ID；</li><li>DB_ROLL_PTR: 7 byte，回滚指针，指向这条记录的上一个版本（简单理解成，指向历史版本就 行，这些数据一般在 <code>undo log</code> 中） </li><li>DB_ROW_ID: 6 byte，隐含的自增ID（隐藏主键），如果数据表没有主键， InnoDB 会自动以 DB_ROW_ID 产生一个<strong>聚簇索引</strong>；</li><li>补充：实际还有一个删除flag隐藏字段，既记录被更新或删除并不代表真的删除，而是删除flag变了；</li></ul><p>假设有如下表结构</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> if <span class="keyword">not</span> <span class="keyword">exists</span> student(</span><br><span class="line">    name <span class="type">varchar</span>(<span class="number">11</span>) <span class="keyword">not</span> <span class="keyword">null</span>,</span><br><span class="line">    age <span class="type">int</span> <span class="keyword">not</span> <span class="keyword">null</span></span><br><span class="line">);</span><br><span class="line"><span class="comment">-- 插入一条记录</span></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> student (name, age) <span class="keyword">values</span> (<span class="string">&#x27;张三&#x27;</span>, <span class="number">19</span>);</span><br></pre></td></tr></table></figure><p>那么这个表中的实际数据是这样的</p><table><thead><tr><th>name</th><th>age</th><th>DB_TRX_ID(创建这个记录的事务ID)</th><th>DB_ROW_ID（隐藏主键）</th><th>DB_ROLL_PTR（回滚指针）</th></tr></thead><tbody><tr><td>张三</td><td>19</td><td>NULL</td><td>1</td><td>NULL</td></tr></tbody></table><p>我们并不知道创建这个记录的事务ID，所以设置为NULL；因为是第一条记录，所以隐藏主键是1；因为是第一条记录，所以没有回滚的地方，回滚指针也是NULL（换句话说，如果回滚指针为NULL，代表这个就是这个表中的第一条记录了）</p><h3 id="4-1-2-undo日志"><a href="#4-1-2-undo日志" class="headerlink" title="4.1.2 undo日志"></a>4.1.2 undo日志</h3><p>MySQL是以服务进程的方式在内存中运行的，我们对数据的CURD操作，都需要通过MySQL将其刷入到硬盘上进行持久化，MySQL为这些操作会提供一个专门的<code>buffer pool</code>内存缓冲区；而<code>undo log/redo log</code>也是内存中的一块区域，对于MySQL而言</p><ul><li>日志需要立刻刷盘（有一个专门的线程来管理日志）</li><li>数据根据运行策略，选择合适的时间刷盘（因为数据量一般比较大，如果实时刷盘会造成较大IO负载，影响进程运行）</li></ul><p>先来说说<code>redo log</code>，这里包含了MySQL中的所有尚未落盘的CURD操作；如果MySQL还没有写入数据的时候就挂了，那么下次启动的时候就会从<code>redo log</code>里面恢复数据，来确保数据的一致性和完整性；</p><p>在MySQL存储路径<code>/var/lib/mysql</code>中的<code>ib_logfile0/ib_logfile1</code>就是<code>redo log</code>；</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-rw-rw----. 1 mysql mysql  50331648 Sep 11 03:16 ib_logfile0</span><br><span class="line">-rw-rw----. 1 mysql mysql  50331648 Sep  9 21:03 ib_logfile1</span><br></pre></td></tr></table></figure><p>而<code>undo log</code>主要用于以下功能</p><ol><li>回滚事务</li><li>MVCC（多版本控制&#x2F;隔离性和隔离级别）</li></ol><p>假设我们来了一个update操作，将刚刚插入的张三的年龄改成30岁，对于MySQL而言就会在<code>undo log</code>里面做如下处理；</p><ul><li>该update操作对应的事务<code>DB_TRX_ID</code>是10；</li><li>将旧数据放入<code>undo log</code>中，并将当前数据的<code>DB_ROLL_PTR</code>指向旧数据的地址；</li><li>如果需要回滚，那么就通过<code>DB_ROLL_PTR</code>找到旧数据，复写回去；</li></ul><p><img src="https://img.musnow.top/i/2023/09/6f386ba45e0c26e72de76bff973c4a4f.png" alt="image-20230911172501941"></p><p>如果再来一次修改，将张三的名字改成李四，也是依照这个逻辑在<code>undo log</code>中新增旧数据，并链接<code>DB_ROLL_PTR</code>指针；</p><ul><li>事务11修改这条数据，先申请锁；</li><li>将现有数据复制到<code>undo log</code>中（头插），并将<code>DB_ROLL_PTR</code>指针指向旧数据的地址；</li><li>修改记录中的name，并且将<code>DB_TRX_ID</code>改成当前事务的ID 11；</li><li>事务11提交，释放锁；</li></ul><p><img src="https://img.musnow.top/i/2023/09/d4a9aca8bdd9c3e38daa5b07896e7684.png" alt="image-20230911173024425"></p><p>这样，我们就有了一个类似于链表的历史版本链；每次回退的时候，都可以找到历史数据，覆盖当前的数据。这些版本我们称之为<code>快照</code>；</p><p>而插入和删除都可以写入<code>undo log</code>，但是只有更新和删除能形成历史版本链；</p><ul><li>删除是将删除flag置为真，旧数据依旧可以写入到<code>undo log</code>中，如果需要回滚，将这行记录恢复；</li><li>插入并没有历史版本，但也需要将其放入<code>undo log</code>中，事务回滚的时候需要将新插入的数据删除；</li><li>事务提交了之后，已有的历史记录可以被删除；</li></ul><p>增删改都说了，那么<code>select</code>呢？</p><p>一般而言，查询不会产生数据写入操作，也不需要设置历史版本链；</p><p>但是在之前关于RR级别隔离性的验证中，我们看到了<code>select</code>无法看到另外一个事务已经提交了的数据，这说明<code>select</code>有时候读取的是<strong>历史版本</strong>的数据，而并非当前最新的数据！</p><p>读取历史数据我们称之为<code>快照读</code>，在RR级别中默认采用的就是快照读；读取最新数据叫做当前读（增删改都是当前读）；还有一种读取是为了更新而查询；</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> ... <span class="comment">-- 在RR级别下，默认是快照读</span></span><br><span class="line"><span class="keyword">select</span> ... <span class="keyword">for</span> <span class="keyword">update</span>; <span class="comment">-- 为了更新而查询，MySQL会将当前行上锁</span></span><br><span class="line"><span class="keyword">select</span> ... lock <span class="keyword">in</span> share mode; <span class="comment">-- 查询最新数据（当前读），是串行化的</span></span><br></pre></td></tr></table></figure><p>除了手动指定<code>select</code>的查询方式以外，隔离级别会影响<code>select</code>的默认行为，比如在串行化隔离级别的场景下，默认执行的就是<strong>当前读</strong>；</p><p>在RR模式下进行测试，会发现当前读会阻塞当前的客户端（右侧客户端阻塞）；</p><p><img src="https://img.musnow.top/i/2023/09/4025f787fda333689872e3295712df1b.png" alt="image-20230911200703608"></p><p>只有左侧的事务在提交了之后，右侧的查询才会返回最新的结果；</p><p><img src="https://img.musnow.top/i/2023/09/1675840504edd0a5689e3a6ec052a4dd.png" alt="image-20230911201033979"></p><p>这是因为<strong>当前读</strong>，包括增删改操作，是需要加锁的；如果要在RR模式下实现当前读，那么整个系统就需要<strong>串行化</strong>执行；</p><p>而快照读不需要加锁，因为它可以读取历史版本，而历史版本是不会被其他线程修改的，也就不需要维护访问控制，提高了并发效率；</p><p>那么，MySQL是如何实现快照读的呢？</p><h3 id="4-1-3-Read-View"><a href="#4-1-3-Read-View" class="headerlink" title="4.1.3 Read View"></a>4.1.3 Read View</h3><p><code>Read View</code>就是MySQL为快照读生成的一个<strong>读视图</strong>；在事务执行快照读的时候（即执行<code>select</code>的时候）将当前数据拍一张照，这样在这个事务中，后续的所有<code>select</code>都只会看到这个照片里面的结果，看不到其他事务最新的修改（不管其他事务是否commit）。</p><blockquote><p>快照读的现象我们已经在本文 <code>3.4 可重复读</code> 中演示过了，这里就不再二次演示了；</p></blockquote><p><code>Read View</code>在MySQL的源码中其实就是一个类，该类中包含一些可读性判断的信息，内部有条件，来标明当前事务能够看到那个版本的数据，即有可能是当前最新的数据，也有可能是<code>undo log</code>中的某个历史版本；</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ReadView</span> &#123;</span><br><span class="line"><span class="comment">// 省略...</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">/** 高水位，大于等于这个ID的事务均不可见*/</span></span><br><span class="line">    <span class="type">trx_id_t</span> m_low_limit_id</span><br><span class="line">    <span class="comment">/** 低水位：小于这个ID的事务均可见 */</span></span><br><span class="line">    <span class="type">trx_id_t</span> m_up_limit_id;</span><br><span class="line">    <span class="comment">/** 创建该 Read View 的事务ID*/</span></span><br><span class="line">    <span class="type">trx_id_t</span> m_creator_trx_id;</span><br><span class="line">    <span class="comment">/** 创建视图时的活跃事务id列表，是一个位图 */</span></span><br><span class="line">    <span class="type">ids_t</span> m_ids;</span><br><span class="line">    <span class="comment">/** 配合purge，标识该视图不需要小于m_low_limit_no的UNDO LOG，</span></span><br><span class="line"><span class="comment">    * 如果其他视图也不需要，则可以删除小于m_low_limit_no的UNDO LOG*/</span></span><br><span class="line">    <span class="type">trx_id_t</span> m_low_limit_no;</span><br><span class="line">    <span class="comment">/** 标记视图是否被关闭*/</span></span><br><span class="line">    <span class="type">bool</span> m_closed;</span><br><span class="line">    <span class="comment">// 省略...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>单独说明一下这里的4个重要的变量；其中需要注意，在这里面<strong>up是低水位，low是高水位</strong>，这是由他们保存的数据的性质决定的，请不要和这两个单词的本意混淆！</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">m_ids; <span class="comment">// 一张位图，用来保存Read View生成时，系统正活跃（没有结束的）的事务ID</span></span><br><span class="line">up_limit_id; <span class="comment">// 记录m_ids列表中事务ID最小的ID </span></span><br><span class="line">low_limit_id; <span class="comment">// ReadView生成时刻系统尚未分配的下一个事务ID，也就是目前已出现过的事务ID的最大值+1</span></span><br><span class="line">creator_trx_id <span class="comment">// 创建该ReadView的事务ID</span></span><br></pre></td></tr></table></figure><p>要知道，当前事务是知道自己的事务ID的（<code>DB_TRX_ID</code>），那么我们手中就有快照读中最大最小的事务ID，以及当前活跃中的事务ID；那么在读取版本链的时候，就进行如下匹配，设当前开启的这个<strong>事务为A</strong>:</p><ul><li>版本链中的事务ID不存在于<code>m_ids</code>中，代表<strong>事务A开启</strong>的时候，这个事务已经提交了，所以我们可以读取这个事务操作的结果；</li><li>版本链中的事务ID存在于<code>m_ids</code>中，代表事务A开启的时候，这个事务是<strong>活跃状态</strong>，那么我就不应该读到这个事务的操作结果；</li><li>版本链的中的事务ID大于<code>low_limit_id</code>，代表事务A开启的时候，这个事务还不存在，所以也不应该看到这个在A之后来的事务的操作结果；（A还没操作完毕，这个新事务就来了）</li><li>版本链中的事物ID小于<code>up_limit_id</code>，代表事物A开启的时候，这个事物都不知道是是它的父亲辈还是爷爷辈了，<strong>长辈给你留下的东西肯定得好好收着</strong>；说人话：这个是A来之前的之前就已经结束了的事物，肯定是可以读取其结果的；</li></ul><p>在MySQL中我们可以看到如下源码，链接也贴出来了，github上可以查看源码；这个函数就是用来判断当前事务应该能看到那些版本链的，具体的判断逻辑参考中文注释（英文注释是官方留的）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这个函数是ReadView类的成员函数 ReadView::changes_visible </span></span><br><span class="line"><span class="comment">// 源码链接 https://github.com/mysql/mysql-server/blob/ea1efa9822d81044b726aab20c857d5e1b7e046a/storage/innobase/include/read0types.h#L162  </span></span><br><span class="line"></span><br><span class="line"><span class="comment">/** Check whether the changes by id are visible.</span></span><br><span class="line"><span class="comment">  @param[in]    id      transaction id to check against the view</span></span><br><span class="line"><span class="comment">  @param[in]    name    table name</span></span><br><span class="line"><span class="comment">  @return whether the view sees the modifications of id. */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// [[nodiscard]] 代表这个函数的返回值不能被忽略，一定需要使用该返回值；否则编译器会爆警告；即告知程序员必须关注这个函数的返回值！</span></span><br><span class="line"><span class="comment">// 函数的返回值是当前事务能否看到某一个事务id值的版本链，入参是目标事务id</span></span><br><span class="line">  [[nodiscard]] <span class="function"><span class="type">bool</span> <span class="title">changes_visible</span><span class="params">(<span class="type">trx_id_t</span> id,</span></span></span><br><span class="line"><span class="params"><span class="function">                                     <span class="type">const</span> <span class="type">table_name_t</span> &amp;name)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">    <span class="built_in">ut_ad</span>(id &gt; <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 小于最小的事务id或者等于当前事务id，则代表这个事务我们可以看到 </span></span><br><span class="line">    <span class="keyword">if</span> (id &lt; m_up_limit_id || id == m_creator_trx_id) &#123;</span><br><span class="line">      <span class="keyword">return</span> (<span class="literal">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">check_trx_id_sanity</span>(id, name);</span><br><span class="line"><span class="comment">// 如果这个id比当前事务中的高水位还大，说明这个id是后来者，不应该看到</span></span><br><span class="line">    <span class="keyword">if</span> (id &gt;= m_low_limit_id) &#123;</span><br><span class="line">      <span class="keyword">return</span> (<span class="literal">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// 如果当前事务创建时，没有活跃事务</span></span><br><span class="line">    <span class="comment">// 且 m_up_limit_id &lt;= id &lt; m_low_limit_id </span></span><br><span class="line">    <span class="comment">// 那么这个事务ID就可以被看到，返回真</span></span><br><span class="line">     <span class="keyword">else</span> <span class="keyword">if</span> (m_ids.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">      <span class="built_in">return</span> (<span class="literal">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">const</span> <span class="type">ids_t</span>::value_type *p = m_ids.<span class="built_in">data</span>();</span><br><span class="line"><span class="comment">// 如果上面都没有匹配到，那就检查这个id是否在活跃列表m_ids中</span></span><br><span class="line">    <span class="comment">// std::binary_search的返回值：是否在位图中，true代表在，false代表不在</span></span><br><span class="line">    <span class="comment">// 如果在，那么这个事务是活跃状态，不能被看到</span></span><br><span class="line">    <span class="comment">// 如果不在，那么这个事务是已经提交了，可以被看到</span></span><br><span class="line">    <span class="keyword">return</span> (!std::<span class="built_in">binary_search</span>(p, p + m_ids.<span class="built_in">size</span>(), id));</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>如果查到不应该看到当前版本，接下来就是遍历下一个版本，直到符合条件，即可以看到。这便是我们select当前读的时候，会自动产生的<code>ReadView</code>结构体的作用；</p><h2 id="4-2-快照读实操"><a href="#4-2-快照读实操" class="headerlink" title="4.2 快照读实操"></a>4.2 快照读实操</h2><h2 id="4-3-当前读实操"><a href="#4-3-当前读实操" class="headerlink" title="4.3 当前读实操"></a>4.3 当前读实操</h2><h2 id="4-4-RR和RC的区别"><a href="#4-4-RR和RC的区别" class="headerlink" title="4.4 RR和RC的区别"></a>4.4 RR和RC的区别</h2><ul><li>正是Read View生成时机的不同，从而造成RC,RR级别下快照读的结果的不同</li><li>在RR级别下的某个事务的对某条记录的第一次快照读会创建一个快照及Read View, 将当前系统活 跃的其他事务记录起来</li><li>此后在调用快照读的时候，还是使用的是同一个Read View，所以只要当前事务在其他事务提交更新之前使用过快照读，那么之后的快照读使用的都是同一个Read View，所以对之后的修改不可见；</li><li>即RR级别下，快照读生成Read View时，Read View会记录此时所有其他活动事务的快照，这些事务的修改对于当前事务都是不可见的。而早于Read View创建的事务所做的修改均是可见；</li><li>而在RC级别下的，事务中，每次快照读都会<strong>新生成一个快照</strong>和Read View, 这就是我们在RC级别下的事务中可以看到别的事务提交的更新的原因；</li><li>总之在RC隔离级别下，是每个快照读都会生成并获取最新的Read View；而在RR隔离级别下，则是同一个事务中的第一个快照读才会创建Read View，之后的快照读获取的都是同一个Read View。 </li><li>正是RC每次快照读，都会形成Read View，所以，RC才会有不可重复读问题。</li></ul>]]></content>
    
    
    <summary type="html">事务的学习</summary>
    
    
    
    <category term="学习sql" scheme="https://blog.musnow.top/categories/%E5%AD%A6%E4%B9%A0sql/"/>
    
    
    <category term="Linux" scheme="https://blog.musnow.top/tags/Linux/"/>
    
    <category term="mysql" scheme="https://blog.musnow.top/tags/mysql/"/>
    
  </entry>
  
  <entry>
    <title>【MySQL】索引</title>
    <link href="https://blog.musnow.top/posts/3474107655/"/>
    <id>https://blog.musnow.top/posts/3474107655/</id>
    <published>2023-09-07T09:52:14.000Z</published>
    <updated>2023-09-07T09:52:30.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-索引"><a href="#1-索引" class="headerlink" title="1.索引"></a>1.索引</h1><h2 id="1-1-为啥需要索引？"><a href="#1-1-为啥需要索引？" class="headerlink" title="1.1 为啥需要索引？"></a>1.1 为啥需要索引？</h2><p>对于数据库而言，查询始终是一个高频的操作；假设在数据量到百万级的时候，查询一个用户信息就要花5秒中，那用户肯定不愿意等待你的系统响应，这就造成了用户流失。</p><p>所以，MySQL必须使用某种方式来保证查询的高速可靠，索引就诞生了；</p><p>对于使用者而言，索引是很香的，因为你只需要执行<code>create index</code>给指定的列，那么MySQL就会自动帮你维护一系列索引创建的操作，查询嘎嘎快！</p><p>但，查询速度的提高是以插入、更新、删除等操作的速度为代价的，这些写操作会增加大量的IO；索引的价值在于提高海量数据的查询速度；</p><p>常见的索引</p><ul><li>主键索引</li><li>唯一键索引</li><li>普通索引</li><li>复合索引</li><li>全文索引</li></ul><h2 id="1-2-索引的效果"><a href="#1-2-索引的效果" class="headerlink" title="1.2 索引的效果"></a>1.2 索引的效果</h2><p>通过如下的大数据用例，我们能看到索引的效果几何</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">drop</span> database if <span class="keyword">exists</span> `bit_index`;</span><br><span class="line"><span class="keyword">create</span> database if <span class="keyword">not</span> <span class="keyword">exists</span> `bit_index` <span class="keyword">default</span> <span class="type">character</span> <span class="keyword">set</span> utf8;</span><br><span class="line">use `bit_index`;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 构建一个8000000条记录的数据</span></span><br><span class="line"><span class="comment">-- 构建的海量表数据需要有差异性，所以使用存储过程来创建， 拷贝下面代码就可以了，暂时不用理解</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 产生随机字符串</span></span><br><span class="line">delimiter $$</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">function</span> rand_string(n <span class="type">INT</span>)</span><br><span class="line"><span class="keyword">returns</span> <span class="type">varchar</span>(<span class="number">255</span>)</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line"><span class="keyword">declare</span> chars_str <span class="type">varchar</span>(<span class="number">100</span>) <span class="keyword">default</span></span><br><span class="line"><span class="string">&#x27;abcdefghijklmnopqrstuvwxyzABCDEFJHIJKLMNOPQRSTUVWXYZ&#x27;</span>;</span><br><span class="line"><span class="keyword">declare</span> return_str <span class="type">varchar</span>(<span class="number">255</span>) <span class="keyword">default</span> <span class="string">&#x27;&#x27;</span>;</span><br><span class="line"><span class="keyword">declare</span> i <span class="type">int</span> <span class="keyword">default</span> <span class="number">0</span>;</span><br><span class="line">while i <span class="operator">&lt;</span> n do</span><br><span class="line"><span class="keyword">set</span> return_str <span class="operator">=</span>concat(return_str,<span class="built_in">substring</span>(chars_str,<span class="built_in">floor</span>(<span class="number">1</span><span class="operator">+</span>rand()<span class="operator">*</span><span class="number">52</span>),<span class="number">1</span>));</span><br><span class="line"><span class="keyword">set</span> i <span class="operator">=</span> i <span class="operator">+</span> <span class="number">1</span>;</span><br><span class="line"><span class="keyword">end</span> while;</span><br><span class="line"><span class="keyword">return</span> return_str;</span><br><span class="line"><span class="keyword">end</span> $$</span><br><span class="line">delimiter ;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 产生随机数字</span></span><br><span class="line">delimiter $$</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">function</span> rand_num( )</span><br><span class="line"><span class="keyword">returns</span> <span class="type">int</span>(<span class="number">5</span>)</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line"><span class="keyword">declare</span> i <span class="type">int</span> <span class="keyword">default</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">set</span> i <span class="operator">=</span> <span class="built_in">floor</span>(<span class="number">10</span><span class="operator">+</span>rand()<span class="operator">*</span><span class="number">500</span>);</span><br><span class="line"><span class="keyword">return</span> i;</span><br><span class="line"><span class="keyword">end</span> $$</span><br><span class="line">delimiter ;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 创建存储过程，向雇员表添加海量数据</span></span><br><span class="line">delimiter $$</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">procedure</span> insert_emp(<span class="keyword">in</span> <span class="keyword">start</span> <span class="type">int</span>(<span class="number">10</span>),<span class="keyword">in</span> max_num <span class="type">int</span>(<span class="number">10</span>))</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line"><span class="keyword">declare</span> i <span class="type">int</span> <span class="keyword">default</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">set</span> autocommit <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">repeat</span><br><span class="line"><span class="keyword">set</span> i <span class="operator">=</span> i <span class="operator">+</span> <span class="number">1</span>;</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> EMP <span class="keyword">values</span> ((<span class="keyword">start</span><span class="operator">+</span>i)</span><br><span class="line">,rand_string(<span class="number">6</span>),<span class="string">&#x27;SALESMAN&#x27;</span>,<span class="number">0001</span>,curdate(),<span class="number">2000</span>,<span class="number">400</span>,rand_num());</span><br><span class="line">until i <span class="operator">=</span> max_num</span><br><span class="line"><span class="keyword">end</span> repeat;</span><br><span class="line"><span class="keyword">commit</span>;</span><br><span class="line"><span class="keyword">end</span> $$</span><br><span class="line">delimiter ;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 雇员表</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `EMP` (</span><br><span class="line">  `empno` <span class="type">int</span>(<span class="number">6</span>) unsigned zerofill <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;雇员编号&#x27;</span>,</span><br><span class="line">  `ename` <span class="type">varchar</span>(<span class="number">10</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;雇员姓名&#x27;</span>,</span><br><span class="line">  `job` <span class="type">varchar</span>(<span class="number">9</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;雇员职位&#x27;</span>,</span><br><span class="line">  `mgr` <span class="type">int</span>(<span class="number">4</span>) unsigned zerofill <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;雇员领导编号&#x27;</span>,</span><br><span class="line">  `hiredate` datetime <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;雇佣时间&#x27;</span>,</span><br><span class="line">  `sal` <span class="type">decimal</span>(<span class="number">7</span>,<span class="number">2</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;工资月薪&#x27;</span>,</span><br><span class="line">  `comm` <span class="type">decimal</span>(<span class="number">7</span>,<span class="number">2</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;奖金&#x27;</span>,</span><br><span class="line">  `deptno` <span class="type">int</span>(<span class="number">2</span>) unsigned zerofill <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;部门编号&#x27;</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 执行存储过程，添加8000000条记录</span></span><br><span class="line"><span class="keyword">call</span> insert_emp(<span class="number">100001</span>, <span class="number">8000000</span>);</span><br></pre></td></tr></table></figure><p>在这个表里面，有大量的数据，其默认状态下，并没有配置索引</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">MariaDB [bit_index]&gt; desc EMP;</span><br><span class="line">+----------+--------------------------+------+-----+---------+-------+</span><br><span class="line">| Field    | Type                     | Null | Key | Default | Extra |</span><br><span class="line">+----------+--------------------------+------+-----+---------+-------+</span><br><span class="line">| empno    | int(6) unsigned zerofill | NO   |     | NULL    |       |</span><br><span class="line">| ename    | varchar(10)              | YES  |     | NULL    |       |</span><br><span class="line">| job      | varchar(9)               | YES  |     | NULL    |       |</span><br><span class="line">| mgr      | int(4) unsigned zerofill | YES  |     | NULL    |       |</span><br><span class="line">| hiredate | datetime                 | YES  |     | NULL    |       |</span><br><span class="line">| sal      | decimal(7,2)             | YES  |     | NULL    |       |</span><br><span class="line">| comm     | decimal(7,2)             | YES  |     | NULL    |       |</span><br><span class="line">| deptno   | int(2) unsigned zerofill | YES  |     | NULL    |       |</span><br><span class="line">+----------+--------------------------+------+-----+---------+-------+</span><br><span class="line">8 rows in set (0.001 sec)</span><br></pre></td></tr></table></figure><p>此时如果你直接全列查询，进程就会阻塞在这里</p><p><img src="https://img.musnow.top/i/2023/09/bd7ed9436789f27dec4d4ba2ab40ea5b.png" alt="image-20230907172052198"></p><p>进MySQL的文件路径看看，会发现这张表的大小已经到了惊人的564mb，虽然我们的内存也许能存的下这么大的数据，但实际IO读写这么大量的数据是非常耗时的</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@vm-cnt8:/var/lib/mysql/bit_index]# ll -h</span><br><span class="line">total 565M</span><br><span class="line">-rw-rw----. 1 mysql mysql   61 Sep  6 05:36 db.opt</span><br><span class="line">-rw-rw----. 1 mysql mysql  770 Sep  6 05:36 EMP.frm</span><br><span class="line">-rw-rw----. 1 mysql mysql 564M Sep  6 05:39 EMP.ibd</span><br></pre></td></tr></table></figure><p>在之前的查询操作中提到过，对于这种大数据表的时候，我们应该避免使用全列查询，而应该设置<code>limit</code>只查询出少量用例数据，来判断这个表的数据结构和作用</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">MariaDB [bit_index]&gt; select * from EMP limit 3;</span><br><span class="line">+--------+--------+----------+------+---------------------+---------+--------+--------+</span><br><span class="line">| empno  | ename  | job      | mgr  | hiredate            | sal     | comm   | deptno |</span><br><span class="line">+--------+--------+----------+------+---------------------+---------+--------+--------+</span><br><span class="line">| 100002 | FNXAKX | SALESMAN | 0001 | 2023-09-06 00:00:00 | 2000.00 | 400.00 |    327 |</span><br><span class="line">| 100003 | rQbLBy | SALESMAN | 0001 | 2023-09-06 00:00:00 | 2000.00 | 400.00 |    394 |</span><br><span class="line">| 100004 | wRVdDF | SALESMAN | 0001 | 2023-09-06 00:00:00 | 2000.00 | 400.00 |    195 |</span><br><span class="line">+--------+--------+----------+------+---------------------+---------+--------+--------+</span><br><span class="line">3 rows in set (0.001 sec)</span><br></pre></td></tr></table></figure><p>在没有索引的情况下进行一个查询，用时大约在1.6秒左右</p><p><img src="https://img.musnow.top/i/2023/09/cec2caa51179f05f7309b5c968a539df.png" alt="image-20230907172357990"></p><p>这时候我们来对empno列创建一个主键索引</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> EMP <span class="keyword">add</span> <span class="keyword">primary</span> key(empno);</span><br></pre></td></tr></table></figure><p>因为表中的数据很多，所以设置主键索引也需要耗费一定时间，这个时间内，其实就是MySQL在后台帮我们创建索引所需要的数据结构的过程</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">MariaDB [bit_index]&gt; alter table EMP add primary key(empno);</span><br><span class="line">Query OK, 0 rows affected (17.184 sec)              </span><br><span class="line">Records: 0  Duplicates: 0  Warnings: 0</span><br></pre></td></tr></table></figure><p>再来查询一下刚刚查询的数据，可以看到，用时只有<code>0.000 sec</code>，直接秒回！</p><p><img src="https://img.musnow.top/i/2023/09/0a7e44f14cf052534721da8beca3a073.png" alt="image-20230907172541115"></p><p>这便是索引在提升性能方面的重大作用！</p><h2 id="1-3-MySQL和文件系统"><a href="#1-3-MySQL和文件系统" class="headerlink" title="1.3 MySQL和文件系统"></a>1.3 MySQL和文件系统</h2><h3 id="1-3-1-Linux文件系统"><a href="#1-3-1-Linux文件系统" class="headerlink" title="1.3.1 Linux文件系统"></a>1.3.1 Linux文件系统</h3><p>在之前对<a href="https://blog.musnow.top/posts/2864480005/">Linux文件系统</a>的学习中，我们知道在磁盘中，一个区块是512KB，在Linux系统中，为了提高效率，会采用4KB的分块对数据进行读取。哪怕你只是修改1KB，也是需要将4KB完整读取，再写入回去的。</p><p><img src="https://img.musnow.top/i/2023/09/cda9058519a11abeed3a167eb6690d0c.png" alt="image-20230907174710578"></p><p>因为机械硬盘物理结构的限制，<strong>随机读取的性能不佳</strong>，一次性读取100KB数据，远远优于100次读取1KB。因为一次性读取的时候，只需要一次寻道就能将磁头摆到正确的位置，往里面写数据就完事了。但多次读取小数据的时候，尽管相邻的两次IO操作在同一时刻发出，但如果它们的请求的扇区地址相差很大的话也只能称为随机访问，而非连续访问。</p><p>随机访问就要多次寻道，每次写入的量又很少，大大增加了IO的负担。</p><h3 id="1-3-2-MySQL和磁盘交互基本单位-16KB"><a href="#1-3-2-MySQL和磁盘交互基本单位-16KB" class="headerlink" title="1.3.2 MySQL和磁盘交互基本单位 16KB"></a>1.3.2 MySQL和磁盘交互基本单位 16KB</h3><p>而MySQL中，为了更好的实现对数据IO量的缩减和控制，其内部将16KB作为一次IO的基本单位，这个大小我们叫做MySQL的文件Page；</p><ul><li>MySQL中的数据文件，都是以Page为基本单位保存至磁盘里面的；</li><li>MySQL中的CURD操作，都需要通过计算来定位到需要修改和访问的数据的位置；</li><li>涉及到计算的操作都需要CPU参与，CPU只能处理内存中的数据，这就要求MySQL需要提前将一部分数据加载到内存中；</li><li>所以在MySQL运行的这段时间内，其操作的数据会同时存在于内存和磁盘中，需要以特定的策略将内存中的数据刷新到磁盘中；这个操作就是IO，基本单位是Page；</li><li>为了更好的管理这些操作，MySQL会自己维护一个<code>buffer pool</code>的内存空间，来进行缓存。</li><li>MySQL是一个应用程序，它的所有文件IO操作都需要通过操作系统提供的接口来实现！但内部的刷盘逻辑是可以由MySQL来调用系统接口来自主控制的，而不需要呆板地遵守操作系统的自动策略；（MySQL创建<code>buffer pool</code>也是基于更高的自主性来考虑的）</li><li>最终目标是尽可能地减少IO操作，提高运行效率；</li></ul><p>运行如下命令可以看到MySQL中关于Page设置的全局变量，即16KB</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">MariaDB [bit_index]&gt; SHOW GLOBAL STATUS LIKE &#x27;innodb_page_size&#x27;;</span><br><span class="line">+------------------+-------+</span><br><span class="line">| Variable_name    | Value |</span><br><span class="line">+------------------+-------+</span><br><span class="line">| Innodb_page_size | 16384 |</span><br><span class="line">+------------------+-------+</span><br><span class="line">1 row in set (0.001 sec)</span><br></pre></td></tr></table></figure><h3 id="1-3-3-为什么要用Page为单位进行交互？"><a href="#1-3-3-为什么要用Page为单位进行交互？" class="headerlink" title="1.3.3 为什么要用Page为单位进行交互？"></a>1.3.3 为什么要用Page为单位进行交互？</h3><p>为何MySQL和磁盘进行IO交互的时候，要采用Page的方案进行交互呢？用多少，加载多少不香吗？</p><p>先来个测试用例看看吧，这是一个非常简单的用户表</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 主键默认生成主键索引</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> if <span class="keyword">not</span> <span class="keyword">exists</span> <span class="keyword">user</span> (</span><br><span class="line">    id <span class="type">int</span> <span class="keyword">primary</span> key, </span><br><span class="line">    age <span class="type">int</span> <span class="keyword">not</span> <span class="keyword">null</span>,</span><br><span class="line">    name <span class="type">varchar</span>(<span class="number">16</span>) <span class="keyword">not</span> <span class="keyword">null</span></span><br><span class="line">);</span><br><span class="line"><span class="comment">-- 插入多条记录，主键没有按顺序插入</span></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">insert</span> <span class="keyword">into</span> <span class="keyword">user</span> (id, age, name) <span class="keyword">values</span>(<span class="number">3</span>, <span class="number">18</span>, <span class="string">&#x27;杨过&#x27;</span>);</span><br><span class="line">Query OK, <span class="number">1</span> <span class="type">row</span> affected (<span class="number">0.01</span> sec)</span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">insert</span> <span class="keyword">into</span> <span class="keyword">user</span> (id, age, name) <span class="keyword">values</span>(<span class="number">4</span>, <span class="number">16</span>, <span class="string">&#x27;小龙女&#x27;</span>);</span><br><span class="line">Query OK, <span class="number">1</span> <span class="type">row</span> affected (<span class="number">0.00</span> sec)</span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">insert</span> <span class="keyword">into</span> <span class="keyword">user</span> (id, age, name) <span class="keyword">values</span>(<span class="number">2</span>, <span class="number">26</span>, <span class="string">&#x27;黄蓉&#x27;</span>);</span><br><span class="line">Query OK, <span class="number">1</span> <span class="type">row</span> affected (<span class="number">0.01</span> sec)</span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">insert</span> <span class="keyword">into</span> <span class="keyword">user</span> (id, age, name) <span class="keyword">values</span>(<span class="number">5</span>, <span class="number">36</span>, <span class="string">&#x27;郭靖&#x27;</span>);</span><br><span class="line">Query OK, <span class="number">1</span> <span class="type">row</span> affected (<span class="number">0.00</span> sec)</span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">insert</span> <span class="keyword">into</span> <span class="keyword">user</span> (id, age, name) <span class="keyword">values</span>(<span class="number">1</span>, <span class="number">56</span>, <span class="string">&#x27;欧阳锋&#x27;</span>);</span><br><span class="line">Query OK, <span class="number">1</span> <span class="type">row</span> affected (<span class="number">0.00</span> sec)</span><br><span class="line"><span class="comment">-- 最终发现数据是有序的</span></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> <span class="keyword">user</span>; </span><br><span class="line"><span class="operator">+</span><span class="comment">----+-----+-----------+</span></span><br><span class="line"><span class="operator">|</span> id <span class="operator">|</span> age <span class="operator">|</span> name      <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-----+-----------+</span></span><br><span class="line"><span class="operator">|</span> <span class="number">1</span>  <span class="operator">|</span> <span class="number">56</span>  <span class="operator">|</span> 欧阳锋     <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> <span class="number">2</span>  <span class="operator">|</span> <span class="number">26</span>  <span class="operator">|</span> 黄蓉       <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> <span class="number">3</span>  <span class="operator">|</span> <span class="number">18</span>  <span class="operator">|</span> 杨过       <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> <span class="number">4</span>  <span class="operator">|</span> <span class="number">16</span>  <span class="operator">|</span> 小龙女     <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> <span class="number">5</span>  <span class="operator">|</span> <span class="number">36</span>  <span class="operator">|</span> 郭靖       <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-----+-----------+</span></span><br><span class="line"><span class="number">5</span> <span class="keyword">rows</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure><p>在上面的5条记录中，如果MySQL要查找id&#x3D;2的记录，第一次加载id&#x3D;1，第二次加载id&#x3D;2，一次一条记录，<strong>那么就需要2次IO</strong>。如果要找id&#x3D;5，那么就需要5次IO。</p><p>但，如果这5条(或者更多)都被保存在一个Page中(16KB，能保存很多记录)，那么第一次IO查找id&#x3D;2的时候，整个Page会被加载到MySQL的<code>Buffer Pool</code>中，这里完成了一次IO。但是往后如果在查找id&#x3D;1,3,4,5等，完全不需要进行IO了，而是直接在内存中进行了。所以，就在单Page里面，大大减少了IO的次数！</p><p>虽然我们不能保证后续的几次IO一定在这次加载的Page中，但根据<code>局部性原理</code>，其访问相近的几条数据的概率是很大的！所以这样最终是能提升IO效率的！</p><p>往往IO效率低下的最主要矛盾不是IO单次数据量的大小，<strong>而是IO的次数</strong>。</p><h2 id="1-4-B-树和Page"><a href="#1-4-B-树和Page" class="headerlink" title="1.4 B+树和Page"></a>1.4 B+树和Page</h2><p>有了对Page的认识，接下来就需要用一个数据结构来维护这些加载到<code>Buffer Pool</code>当中的Page了。这时候，我们的B+树就登场了。</p><h3 id="1-4-1-单个Page"><a href="#1-4-1-单个Page" class="headerlink" title="1.4.1 单个Page"></a>1.4.1 单个Page</h3><p>单个Page里面存放的肯定是一部分的数据，我们可以加上前后指针，以双链表的形式将所有Page连起来，这样就能实现数据的遍历；在MySQL中，就是这么操作的。</p><p><img src="https://img.musnow.top/i/2023/09/fafa9750da8082ecdf3927663eb49941.png" alt="image-20230907182425023"></p><p>因为存在主键，MySQL还会给单个Page中的数据依照主键进行排序，从上图就能看出阿里，单个Page中数据是依照主键按序排列的；且每一个数据都会链接到下一个数据上；</p><p>这样排序后，数据库在进行数据筛选的时候，就能更好的定位到数据的位置，减少查询耗时。插入时排序也能让后续在进行数据降序&#x2F;升序输出的时候，无需二次对数据进行排序了；</p><h3 id="1-4-2-多个Page"><a href="#1-4-2-多个Page" class="headerlink" title="1.4.2 多个Page"></a>1.4.2 多个Page</h3><p>既然一个Page是如此，那多个Page呢？</p><ul><li>前面提到了，当MySQL需要加载数据的时候，会将和这个数据相邻近的其他数据，以16KB为单位一起加载到一个Page里面，并连接到这个双向链表上；</li><li>这样，我们就可以通过多个Page的遍历来进行数据的定位</li><li>可链表是一个线性结构，MySQL肯定不可能用线性结构来维护数据吧？那样查询的效率也太低了，每次都需要O(N)的遍历，数据一多就慢慢慢！</li></ul><p><img src="https://img.musnow.top/i/2023/09/12d3385dee351703d07d0104f014b80a.png" alt="image-20230907183025895"></p><p>所以，我们肯定要在双向链表的基础上添加其他的结构来进行查找的优化！这时候就可以引入<strong>目录</strong>了</p><h4 id="页目录"><a href="#页目录" class="headerlink" title="页目录"></a>页目录</h4><p>在我们看书的时候，就会有目录来帮助我们快速查找到某一个章节。比如我们想看第九章的内容，那就可以先看目录，找到第九章的页码，再进行阅读。</p><p>对于MySQL中的数据，这个情景也是适用的，我们给数据上一个目录，查询的时候先根据目录定位到具体的page，我们可以知道1-10号数据都在这个page里面，那就直接去里面找就行了；这时候查找的效率就比单纯的从链表开头进行遍历快多了！</p><p>当然，和书籍的目录需要消耗纸张一样，在MySQL中对数据设置目录也是需要消耗空间的，这就是一种用空间换时间的做法，而在生产环境中，时间显然更加宝贵！</p><h4 id="单页目录"><a href="#单页目录" class="headerlink" title="单页目录"></a>单页目录</h4><p>在单个Page里面，我们可以安如下的方式设定一个目录，嗝一定间隔就设置一个新的节点作为目录。在数据量小的时候，这个目录的作用不算大，但数据量一大，目录对搜索效率的提升是非常可观的！</p><blockquote><p>比如，我们要查找id&#x3D;4记录，之前必须线性遍历4次，才能拿到结果。现在直接通过目录2[3]，直接进行定位新的起始位置，只需要遍历3次就能找到结果，提高了效率。</p></blockquote><p>即便在单个Page中添加目录会导致这个Page实际存放的数据变少，但这是必要的牺牲！</p><p><img src="https://img.musnow.top/i/2023/09/052c18b6ad7065a68f008d8234f08dfc.png" alt="image-20230907191523912"></p><h4 id="多页目录"><a href="#多页目录" class="headerlink" title="多页目录"></a>多页目录</h4><p>前面提到，MySQL会自动把新的数据加载到一个Page中，并链接到已有链表上；但是线性遍历需要大量的IO，每次遇到新的Page的时候，就需要将其加载到内存里面，进行遍历，这就使得单个Page中的目录不那么实用了；</p><ul><li>单个Page的目录是小节目录</li><li>多个Page的目录是章节目录</li></ul><p>所以我们必须给多个Page也加上一个顶层的章节目录，进一步优化效率！</p><ul><li>使用一个Page来指向多个Page，存放每个Page的起始key值（假设每个Page中的key都有序且为升序）；这个Page中不存放实际的数据，只有目录值；</li><li>遍历的时候，先通过多Page的目录找到我们要去的Page，再去访问该实际存储数据的Page中的单Page目录，最终查找到目标数据；</li><li>所以，每个多Page的目录项中就是一个键值+对应普通Page的指针</li></ul><p><img src="https://img.musnow.top/i/2023/09/f14ce259e947e2cc699ae2341e3e83cd.png" alt="image-20230907192840730"></p><p>一层目录Page不够，我们还可以再加一层。这样就实现了一个类似于二叉树的结构，只不过每一个节点Page中都包含多个Page的key+指针，最终只有叶子节点是实际存储数据的！</p><p><img src="https://img.musnow.top/i/2023/09/485204263a90e86428707dd92244878b.png" alt="image-20230907193042036"></p><p>这个数据结构就叫做B+树（注意，不是B树！）而整个上图中的数据接就是MySQL中对user表做的索引！</p><p>此时的查询，需要经过的节点肯定变少了，比如我们需要查询<code>id=12</code>的用户：</p><ul><li>顶层判断，12&gt;11&gt;1，向右走【2次比较】</li><li>第二层判断，12&gt;11且12&lt;16，向左走，来到具体的Page【2次比较】</li><li>查找单页目录，12&gt;11且12&lt;13；【2次比较】</li><li>从11开始遍历，走一步就能找到【1次比较】</li></ul><p>最终，我们查找12的操作只用了7次就成功了。而从投开始遍历需要12次才能找到它；</p><p>遍历次数的减少，就等同于IO次数的减少，最终查询的效率就变高了！</p><blockquote><p>这里的分析可能有误，不过结论是没有问题的，分页肯定能增加查找的效率！</p></blockquote><p>另外，MySQL还可以根据访问的频率，定期的释放一些Page；比如在B+树中，可能树的右半部分很少被访问，那就可以暂时释放这部分Page的空间，给其他表使用，真到遇到访问的时候，再去读盘去除这部分数据。<strong>这是由MySQL的缓存策略来自主决定的</strong>；</p><p>毕竟当一个表非常大的时候，将其全部加载到内存里面是不可行的！必须要用缓存策略和局部性原理来加载频繁使用的数据到内存中，才能在效率和负载上达到平衡；</p><p>不然你的MySQL无脑缓存Page导致占用过多内存，操作系统看不下去直接给你KILL了，那业务就完蛋了！🤣</p><h3 id="1-4-3-小结"><a href="#1-4-3-小结" class="headerlink" title="1.4.3 小结"></a>1.4.3 小结</h3><ul><li>Page分为目录页和数据页。目录页只放各个下级Page的最小键值和该Page的指针。</li><li>查找的时候，自顶向下找，只需要加载部分目录页到内存，即可完成算法的整个查找过程，大大减少了IO次数</li><li>范围查询的时候，可以找到区间边界的两个节点的位置，然后直接通过叶子节点的链表进行遍历，取出数据即可！</li><li>MySQL可以根据访问频率，适当地预先加载或者释放一些Page的空间，并不是说一张表的所有数据都必须全部加载到内存里面；</li></ul><p>后续我还会学习B树和B+树数据结构在CPP中的实现，敬请关注我的博客！</p><h2 id="1-5-为什么其他数据结构不适合索引？"><a href="#1-5-为什么其他数据结构不适合索引？" class="headerlink" title="1.5 为什么其他数据结构不适合索引？"></a>1.5 为什么其他数据结构不适合索引？</h2><p>在认识这个问题之前，我们首先要记住上文提到的一个结论：真正影响索引性能的，是和硬盘IO的次数，IO次数越少，性能越高；</p><ul><li>链表、线性表：都是线性遍历，压根没有索引的功能</li><li>二叉搜索树：在极端场景下会退化成普通二叉树，还是线性遍历</li><li><code>AVLTree/RBTree</code>：虽然相对平衡，但二叉结构会导致树的整体过高，自顶向下查询的时候，需要经过多层的多次IO，才能找到目标数据（B+树的层数更少，在这种情况下B+树更优秀）</li><li>HASH：虽然查找的时候很快，基本能做到O(1)，但范围查询的效果不佳；在MySQL中也是支持HASH索引的，比如<code>MEMOY/HEAP/NDB</code>存储引擎；</li></ul><p><img src="https://img.musnow.top/i/2023/09/ab7bb4e2660ff869b45d61974beb6ed7.png" alt="image-20230907193621724"></p><p>那B树为什么不适合呢？作为一个多叉树结构，B树的同层能比红黑树存储更多信息，看上去也是可以做索引的呀？</p><p>牵扯到B树和B+树的区别了，来看看二者的结构图</p><p><img src="https://img.musnow.top/i/2023/09/d485930385b11585cdb3c15e87e2b2df.png" alt="image-20230907145442565"></p><p>文字说明如下：</p><ul><li>B树的每一个节点都会存放一定的数据和page指针；</li><li>B+树只有叶子节点会存放数据，非叶子节点只有page的目录；</li><li>B+树的叶子节点全部相连；</li></ul><p>这就引出了B+树的两个优点：</p><ul><li>因为B+树的非叶子节点只需要存储page目录，所以在一个非叶子节点中就能存放较多的目录索引，使得树整体更矮；</li><li>B+树的叶子节点全部相连，方便进行范围遍历，比如<code>where sal&gt;100 and sal &lt; 300</code>的这种范围条件，就可以直接通过叶子节点的链表向后遍历来解决；</li></ul><p>最终的效率问题依旧落到了如何让树更矮来<strong>减少IO次数</strong>，因为在整体上B+树都能做到较矮，查询效率优秀，方便范围查询；所以MySQL主要选用了B+树作为索引结构。</p><h2 id="1-6-聚簇-x2F-非聚簇索引"><a href="#1-6-聚簇-x2F-非聚簇索引" class="headerlink" title="1.6 聚簇&#x2F;非聚簇索引"></a>1.6 聚簇&#x2F;非聚簇索引</h2><h3 id="1-6-1-说明"><a href="#1-6-1-说明" class="headerlink" title="1.6.1 说明"></a>1.6.1 说明</h3><p>InnoDB的数据是和B+树一起存放的，叶子节点里面有数据；这种数据和索引在一起的形式，叫做<strong>聚簇索引</strong>。</p><p><img src="https://img.musnow.top/i/2023/09/c569f1a484e8f61b916751b6d6305a2b.png" alt="image-20230907145652553"></p><p>MyISAM的叶子中没有数据，而是存放的指向数据表对应位置的指针，有额外的一张表来存放所有数据；这种数据和索引分离的形式，叫做<strong>非聚簇索引</strong>；</p><p><img src="https://img.musnow.top/i/2023/09/6be83a012b547b33adf2f8e9cab5252d.png" alt="image-20230907145704130"></p><p>对于MyISAM存储引擎来说，<strong>其很适合进行查询</strong>，特别是大文本查找和全文索引（后文会提到）；</p><h3 id="1-6-2-实机演示"><a href="#1-6-2-实机演示" class="headerlink" title="1.6.2 实机演示"></a>1.6.2 实机演示</h3><blockquote><p>在MySQL中，我们可以通过实际文件的数量看出InnoDB和MyISAM存储引擎的区别；其也反映了聚簇&#x2F;非聚簇索引的性质。</p></blockquote><p>这里我们新建一个数据库，创建user1表，默认采用的是InnoDB作为存储引擎</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">MariaDB [hello_mysql]&gt; create table user1( id int unsigned primary key, name varchar(200) NOT NULL );</span><br><span class="line">Query OK, 0 rows affected (0.008 sec)</span><br></pre></td></tr></table></figure><p>在MySQL的文件存储路径中，可以查看到user1表对应了两个文件，其中<code>.ibd</code>后缀指的就是InnoDB，其内部同时包含了该表中的数据和索引值；</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@vm-cnt8:/var/lib/mysql/hello_mysql]# ll</span><br><span class="line">total 104</span><br><span class="line">-rw-rw----. 1 mysql mysql    61 Sep  7 02:59 db.opt</span><br><span class="line">-rw-rw----. 1 mysql mysql  1545 Sep  7 03:00 user1.frm</span><br><span class="line">-rw-rw----. 1 mysql mysql 98304 Sep  7 03:00 user1.ibd</span><br></pre></td></tr></table></figure><p>再来创建一个属性完全相同的user2表，但采用MyISAM存储引擎</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">MariaDB [hello_mysql]&gt; create table user2( id int unsigned primary key, name varchar(200) NOT NULL ) engine=MyISAM;</span><br><span class="line">Query OK, 0 rows affected (0.002 sec)</span><br></pre></td></tr></table></figure><p>此时能看到，MyISAM对应的存储文件有3个，<code>.MYI</code>包含的是索引，<code>.MYD</code>包含的是实际数据；</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[root@vm-cnt8:/var/lib/mysql/hello_mysql]# ll</span><br><span class="line">total 112</span><br><span class="line">-rw-rw----. 1 mysql mysql    61 Sep  7 02:59 db.opt</span><br><span class="line">-rw-rw----. 1 mysql mysql  1545 Sep  7 03:00 user1.frm</span><br><span class="line">-rw-rw----. 1 mysql mysql 98304 Sep  7 03:00 user1.ibd</span><br><span class="line">-rw-rw----. 1 mysql mysql  1545 Sep  7 03:03 user2.frm</span><br><span class="line">-rw-rw----. 1 mysql mysql     0 Sep  7 03:03 user2.MYD</span><br><span class="line">-rw-rw----. 1 mysql mysql  1024 Sep  7 03:03 user2.MYI</span><br></pre></td></tr></table></figure><p>两表都有一个占用空间完全相同的<code>.frm</code>文件，这个文件中存储的就是该表的结构属性信息，因为两个表的结构完全相同，所以这个文件的大小也相同；</p><h2 id="1-7-回表查找"><a href="#1-7-回表查找" class="headerlink" title="1.7 回表查找"></a>1.7 回表查找</h2><p>创建<strong>辅助索引</strong>的时候，MyISAM依旧创建一个B+树，叶子节点也是指向对应位置的指针；所以在MyISAM中，主键&#x2F;非主键索引区别不大，无非是是否允许冗余数据的问题。</p><p><img src="https://img.musnow.top/i/2023/09/2540a3c70fb29ad3e861374ef8a0cbe1.png" alt="image-20230907145845574"></p><p>InnoDB的辅助索引中，不再直接存放节点数据，而是存放<strong>主键key值</strong>，查询的时候根据key值回到<strong>主键索引表</strong>中进行查询，需要<strong>查询两次</strong>才能获取到结果。</p><blockquote><p>如果辅助索引中还保存数据，就会造成极大的空间浪费，一份数据被保存两次甚至更多次，显然是不合理的。</p></blockquote><p>InnoDB这个先查辅助索引表，再回到主键表中查询的动作，叫做<code>回表查询</code>；</p><p>话虽是这么说，但也并不是每次查询我们都需要回表的。比如下图是一个复合键的索引表，假设数字是用户ID（主键），文字是用户姓名，在这种情况下，我们通过用户姓名查询用户ID的时候，就不需要回到主键表也能获取到结果。</p><p><img src="https://img.musnow.top/i/2023/09/6004dda4aa0dd67277e214f2fa4497db.png" alt="image-20230907144213435"></p><p>另外，在一般的数据库中，B+树并不会很深，所以即便需要进行回表的两次查询，效率也不会受到较大影响；（但肯定会有一定损失）</p><h1 id="2-索引操作"><a href="#2-索引操作" class="headerlink" title="2.索引操作"></a>2.索引操作</h1><h2 id="2-1-创建索引的原则"><a href="#2-1-创建索引的原则" class="headerlink" title="2.1 创建索引的原则"></a>2.1 创建索引的原则</h2><ul><li>比较频繁作为查询条件的字段应该创建索引</li><li>唯一性太差的字段不适合单独创建索引，即使频繁作为查询条件</li><li>更新非常频繁的字段不适合作创建索引（因为每次更新都得重置索引，增加IO压力）</li><li>不会出现在where子句中的字段不该创建索引（不作为查询条件的字段）</li></ul><p>另外，如果在创建表的时候么有指定主键，那么MySQL会自动帮我们创建一个隐藏的自增主键ID（不然就没办法支持其他索引和其本身的快速查找了）</p><h2 id="2-2-创建主键索引"><a href="#2-2-创建主键索引" class="headerlink" title="2.2 创建主键索引"></a>2.2 创建主键索引</h2><p>创建表的时候指定<code>primary key</code>，默认就会创建主键索引</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> user1( id <span class="type">int</span> unsigned <span class="keyword">primary</span> key, name <span class="type">varchar</span>(<span class="number">200</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> );</span><br></pre></td></tr></table></figure><p>创建表的最后，指定某列为主键索引，这个和第一种方式本质上没区别</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> user1( id <span class="type">int</span> unsigned , name <span class="type">varchar</span>(<span class="number">200</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>, <span class="keyword">primary</span> key(id) );</span><br></pre></td></tr></table></figure><p>创建表了之后再添加主键</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 创建表</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> user1( id <span class="type">int</span> unsigned , name <span class="type">varchar</span>(<span class="number">200</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>);</span><br><span class="line"><span class="comment">-- 添加主键</span></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> user1 <span class="keyword">add</span> <span class="keyword">primary</span> key(id);</span><br></pre></td></tr></table></figure><p>主键索引的特点：</p><ul><li>一个表里面本来就只能有一个主键，所以主键索引也只有一个（复合主键也只算一个主键）</li><li>主键索引的效率高（主键列不可重复）</li><li>主键列不能为NULL，所以也不存在无法被索引的值</li><li>一般都会用数字来作为主键，在索引中方便数据比较</li></ul><h2 id="2-3-唯一键索引"><a href="#2-3-唯一键索引" class="headerlink" title="2.3 唯一键索引"></a>2.3 唯一键索引</h2><p>当你给某一列设置为唯一键的时候，MySQL就会自动创建唯一键索引；唯一键索引其实就是普通的辅助索引，只不过其和主键一样都包含唯一的键值约束；</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 直接指定唯一键</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> user2(id <span class="type">int</span> <span class="keyword">primary</span> key, name <span class="type">varchar</span>(<span class="number">200</span>) <span class="keyword">unique</span>);</span><br><span class="line"><span class="comment">-- 创建语句末尾指定唯一键</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> user2(id <span class="type">int</span> <span class="keyword">primary</span> key, name <span class="type">varchar</span>(<span class="number">200</span>),<span class="keyword">unique</span>(name));</span><br><span class="line"><span class="comment">-- 创建后再添加唯一键</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> user2(id <span class="type">int</span> <span class="keyword">primary</span> key, name <span class="type">varchar</span>(<span class="number">200</span>));</span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> user2 <span class="keyword">add</span> <span class="keyword">unique</span>(name);</span><br></pre></td></tr></table></figure><p>唯一索引的特点：</p><ul><li>一个表中，可以有多个唯一索引，包括复合唯一键的索引；</li><li>查询效率高；</li><li>如果在某一列建立唯一索引，必须保证这列不能有重复数据；</li><li>如果一个唯一索引上指定<code>not null</code>，等价于主键索引；</li><li>如果删除唯一键索引，也会同时删除唯一的约束属性；</li></ul><h2 id="2-4-普通键索引"><a href="#2-4-普通键索引" class="headerlink" title="2.4 普通键索引"></a>2.4 普通键索引</h2><p>创建普通索引依旧有3种方式</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 在表的定义最后，指定某列为索引</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> user3(id <span class="type">int</span> <span class="keyword">primary</span> key,</span><br><span class="line">    name <span class="type">varchar</span>(<span class="number">20</span>),</span><br><span class="line">    email <span class="type">varchar</span>(<span class="number">30</span>),</span><br><span class="line">    index(name)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 创建完表以后指定某列为普通索引</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> user3(id <span class="type">int</span> <span class="keyword">primary</span> key, name <span class="type">varchar</span>(<span class="number">20</span>), email</span><br><span class="line"><span class="type">varchar</span>(<span class="number">30</span>));</span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> user3 <span class="keyword">add</span> index(name);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 创建索引的时候指定名字</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> user3(id <span class="type">int</span> <span class="keyword">primary</span> key, name <span class="type">varchar</span>(<span class="number">20</span>), email</span><br><span class="line"><span class="type">varchar</span>(<span class="number">30</span>));</span><br><span class="line"><span class="keyword">create</span> index idx_name <span class="keyword">on</span> user3(name); <span class="comment">-- 创建一个索引名为 idx_name 的索引</span></span><br></pre></td></tr></table></figure><p>普通索引的特点：</p><ul><li>一个表中可以有多个普通索引</li><li>普通索引中的键值可以重复，但不要在大量重复的键值上建立索引（比如性别）</li></ul><h2 id="2-5-复合-x2F-联合索引"><a href="#2-5-复合-x2F-联合索引" class="headerlink" title="2.5 复合&#x2F;联合索引"></a>2.5 复合&#x2F;联合索引</h2><p>给多个键值创建索引，操作如下</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> index 索引名字 <span class="keyword">on</span> 表名(字段<span class="number">1</span>,字段<span class="number">2</span>);</span><br></pre></td></tr></table></figure><p>此时我们创建的索引，在字段1和字段2上会共用一个索引的<code>Key_name</code>，索引名字是相同的。</p><p>复合索引有一个好处，如果使用InnoDB时，<strong>需要查询的结果包含在索引字段中</strong>，那就可以节省一次返还到主键索引中查询的回表步骤，可以在一定程度上提高效率（在上文中已经提及此事）</p><ul><li>上面这种操作叫做<strong>索引覆盖</strong>（覆盖索引），直接从普通索引表中查询到结果；</li><li>建立复合索引相比于建立多个单列索引，还能在一定程度上减少空间消耗，提高效率；</li></ul><p>另外，在进行复合索引的查询的时候，<strong>我们只能使用用户名来查询用户ID</strong>，返过来是不行的（不会使用索引）。因为在MySQL对索引进行匹配的时候，只会匹配最左侧的索引值；</p><p>比如下图中，充当判断条件的是用户名字，通过用户名字查用户ID是OK的，反过来就不行；这种情况下MySQL不会使用索引，依旧是全表遍历；</p><p><img src="https://img.musnow.top/i/2023/09/6004dda4aa0dd67277e214f2fa4497db.png" alt="image-20230907144213435"></p><p>这种叫做MySQL索引的<strong>最左匹配原则</strong></p><blockquote><p>详解：<a href="https://blog.csdn.net/weixin_47162914/article/details/123793589">联合索引-最左匹配原则</a></p></blockquote><p>MySQL在创建复合索引的时候，首先会<strong>对最左边字段排序</strong>，也就是第一个字段，然后再在保证第一个字段有序的情况下，再排序第二个字段，以此类推。所以联合索引最左列是绝对有序的，其他字段无序。</p><p>举个例子：可以把联合索引看成“电话簿”，姓名作为联合索引，姓是第一列，名是第二列，当查找人名时，是先确定这个人姓再根据名确定人。只有名没有姓就查不到。</p><h2 id="2-6-全文索引"><a href="#2-6-全文索引" class="headerlink" title="2.6 全文索引"></a>2.6 全文索引</h2><p>如果对文章或者大量文字的字段进行检索的时候，就会使用到全文索引。MySQL提供全文索引机制，但是要求表的存储引擎必须是<code>MyISAM</code>；而且默认的全文索引只支持英文，不支持中文。如果对中文进行全文检索，可以使用sphinx的中文版(coreseek)。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 创建表，FULLTEXT设置全文索引</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> articles (</span><br><span class="line">    id <span class="type">INT</span> UNSIGNED AUTO_INCREMENT <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">PRIMARY</span> KEY,</span><br><span class="line">    title <span class="type">VARCHAR</span>(<span class="number">200</span>),</span><br><span class="line">    body TEXT,</span><br><span class="line">    FULLTEXT (title,body) </span><br><span class="line">)engine<span class="operator">=</span>MyISAM;</span><br><span class="line"><span class="comment">-- 插入测试数据</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> articles (title,body) <span class="keyword">VALUES</span></span><br><span class="line">    (<span class="string">&#x27;MySQL Tutorial&#x27;</span>,<span class="string">&#x27;DBMS stands for DataBase ...&#x27;</span>),</span><br><span class="line">    (<span class="string">&#x27;How To Use MySQL Well&#x27;</span>,<span class="string">&#x27;After you went through a ...&#x27;</span>),</span><br><span class="line">    (<span class="string">&#x27;Optimizing MySQL&#x27;</span>,<span class="string">&#x27;In this tutorial we will show ...&#x27;</span>),</span><br><span class="line">    (<span class="string">&#x27;1001 MySQL Tricks&#x27;</span>,<span class="string">&#x27;1. Never run mysqld as root. 2. ...&#x27;</span>),</span><br><span class="line">    (<span class="string">&#x27;MySQL vs. YourSQL&#x27;</span>,<span class="string">&#x27;In the following database comparison ...&#x27;</span>),</span><br><span class="line">    (<span class="string">&#x27;MySQL Security&#x27;</span>,<span class="string">&#x27;When configured properly, MySQL ...&#x27;</span>);</span><br></pre></td></tr></table></figure><p>创建好表之后，查询表中索引信息，可以看到title和body字段都用上了索引名字为<code>title</code>的全文索引</p><p><img src="https://img.musnow.top/i/2023/09/f0c396d35a81e6ab863f7bec84174f48.png" alt="image-20230907155913783"></p><p>假设我们查询这个表中有没有包含database的文字数据，虽然成功查询了结果，但是并没有使用到全文索引</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> articles <span class="keyword">where</span> body <span class="keyword">like</span> <span class="string">&#x27;%database%&#x27;</span>;</span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------------+------------------------------------------+</span></span><br><span class="line"><span class="operator">|</span> id <span class="operator">|</span> title             <span class="operator">|</span> body                                     <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------------+------------------------------------------+</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">1</span> <span class="operator">|</span> MySQL Tutorial    <span class="operator">|</span> DBMS stands <span class="keyword">for</span> DataBase ...             <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">5</span> <span class="operator">|</span> MySQL vs. YourSQL <span class="operator">|</span> <span class="keyword">In</span> the following database comparison ... <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------------+------------------------------------------+</span></span><br><span class="line"><span class="number">2</span> <span class="keyword">rows</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.000</span> sec)</span><br></pre></td></tr></table></figure><p>使用explain语句可以看出是否有使用全文索引，这里的key为NULL就代表么有使用上索引；这个工具的作用是<strong>预执行</strong>，并不会实际上运行这个语句，但是会告诉你我想<strong>怎么运行它</strong>；</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">explain select * from articles where body like &#x27;%database%&#x27;\G</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">           id: 1</span><br><span class="line">  select_type: SIMPLE</span><br><span class="line">        table: articles</span><br><span class="line">         type: ALL</span><br><span class="line">possible_keys: NULL</span><br><span class="line">          key: NULL</span><br><span class="line">      key_len: NULL</span><br><span class="line">          ref: NULL</span><br><span class="line">         rows: 6</span><br><span class="line">        Extra: Using where</span><br><span class="line">1 row in set (0.000 sec)</span><br></pre></td></tr></table></figure><p>要想使用全文索引，得这么写</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> articles <span class="keyword">WHERE</span> <span class="keyword">MATCH</span> (title,body) AGAINST (<span class="string">&#x27;database&#x27;</span>);</span><br></pre></td></tr></table></figure><p>再用explain工具看看，此时就可以看到key里面显示的是title，成功使用上了全文索引</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">explain SELECT * FROM articles WHERE MATCH (title,body) AGAINST</span><br><span class="line">    -&gt; (&#x27;database&#x27;)\G</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">           id: 1</span><br><span class="line">  select_type: SIMPLE</span><br><span class="line">        table: articles</span><br><span class="line">         type: fulltext</span><br><span class="line">possible_keys: title</span><br><span class="line">          key: title</span><br><span class="line">      key_len: 0</span><br><span class="line">          ref: </span><br><span class="line">         rows: 1</span><br><span class="line">        Extra: Using where</span><br><span class="line">1 row in set (0.000 sec)</span><br></pre></td></tr></table></figure><h3 id="explain工具"><a href="#explain工具" class="headerlink" title="explain工具"></a>explain工具</h3><p>这里对explain工具显示的列作一个说明</p><ul><li>id — 选择标识符，id 越大优先级越高，越先被执行；</li><li>select_type — 表示查询的类型；</li><li>table — 输出结果集的表；</li><li>partitions — 匹配的分区；</li><li>type — 表示表的连接类型；</li><li>possible_keys — 表示查询时，可能使用的索引；</li><li><strong>key — 表示实际使用的索引；</strong></li><li>key_len — 索引字段的长度；</li><li>ref—  列与索引的比较；</li><li>rows — 大概估算的行数；</li><li>filtered — 按表条件过滤的行百分比；</li><li>Extra — 执行情况的描述和说明。</li></ul><h2 id="2-7-查询-x2F-删除索引"><a href="#2-7-查询-x2F-删除索引" class="headerlink" title="2.7 查询&#x2F;删除索引"></a>2.7 查询&#x2F;删除索引</h2><p>如果需要删除主键索引，直接把主键删了就行了</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> 表名 <span class="keyword">drop</span> <span class="keyword">primary</span> key;</span><br></pre></td></tr></table></figure><p>删除普通索引语句如下</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> 表名 <span class="keyword">drop</span> index 索引名字;</span><br></pre></td></tr></table></figure><p>注意，索引的名字不一定和字段名相同（在创建索引的时候可以指定索引名字），需要使用如下语句查看</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> keys <span class="keyword">from</span> 表名;</span><br></pre></td></tr></table></figure><p>比如user2表中包含id主键索引和name的主键索引，其结果查询如下；其中的<code>Key_name</code>才是索引的名字，不一定和字段名相同！删除索引的时候需要使用索引名字！</p><p><img src="https://img.musnow.top/i/2023/09/e01d3842d22be7c1f41568ef3802d1e0.png" alt="image-20230907153259042"></p><p>还可以用如下语句来更加清楚的看到每个索引的相关属性</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> index <span class="keyword">from</span> 表名\G;</span><br></pre></td></tr></table></figure><p>我给user2表添加一个键值，并设置普通索引</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> user2 <span class="keyword">add</span> qq <span class="type">varchar</span>(<span class="number">40</span>); <span class="comment">-- 添加一个键值</span></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> user2 <span class="keyword">add</span> index(qq); <span class="comment">-- 添加普通索引</span></span><br></pre></td></tr></table></figure><p>使用<code>show index from 表名\G;</code>语句查看user2表的索引属性；在这里可以看到，唯一键索引的属性和普通索引是完全相同的，<strong>所以才说唯一键的索引本质上还是普通索引</strong>。</p><p>这里还写明了索引的类型是BTREE，其就是B+树；</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">MariaDB [hello_mysql]&gt; desc user2;</span><br><span class="line">+-------+------------------+------+-----+---------+-------+</span><br><span class="line">| Field | Type             | Null | Key | Default | Extra |</span><br><span class="line">+-------+------------------+------+-----+---------+-------+</span><br><span class="line">| id    | int(10) unsigned | NO   | PRI | NULL    |       |</span><br><span class="line">| name  | varchar(200)     | NO   | UNI | NULL    |       |</span><br><span class="line">| qq    | varchar(40)      | YES  | MUL | NULL    |       |</span><br><span class="line">+-------+------------------+------+-----+---------+-------+</span><br><span class="line">3 rows in set (0.001 sec)</span><br><span class="line"></span><br><span class="line">MariaDB [hello_mysql]&gt; show index from user2\G;</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">        Table: user2</span><br><span class="line">   Non_unique: 0</span><br><span class="line">     Key_name: PRIMARY</span><br><span class="line"> Seq_in_index: 1</span><br><span class="line">  Column_name: id</span><br><span class="line">    Collation: A</span><br><span class="line">  Cardinality: 0</span><br><span class="line">     Sub_part: NULL</span><br><span class="line">       Packed: NULL</span><br><span class="line">         Null: </span><br><span class="line">   Index_type: BTREE</span><br><span class="line">      Comment: </span><br><span class="line">Index_comment: </span><br><span class="line">*************************** 2. row ***************************</span><br><span class="line">        Table: user2</span><br><span class="line">   Non_unique: 0</span><br><span class="line">     Key_name: name</span><br><span class="line"> Seq_in_index: 1</span><br><span class="line">  Column_name: name</span><br><span class="line">    Collation: A</span><br><span class="line">  Cardinality: 0</span><br><span class="line">     Sub_part: NULL</span><br><span class="line">       Packed: NULL</span><br><span class="line">         Null: </span><br><span class="line">   Index_type: BTREE</span><br><span class="line">      Comment: </span><br><span class="line">Index_comment: </span><br><span class="line">*************************** 3. row ***************************</span><br><span class="line">        Table: user2</span><br><span class="line">   Non_unique: 1</span><br><span class="line">     Key_name: qq</span><br><span class="line"> Seq_in_index: 1</span><br><span class="line">  Column_name: qq</span><br><span class="line">    Collation: A</span><br><span class="line">  Cardinality: NULL</span><br><span class="line">     Sub_part: NULL</span><br><span class="line">       Packed: NULL</span><br><span class="line">         Null: YES</span><br><span class="line">   Index_type: BTREE</span><br><span class="line">      Comment: </span><br><span class="line">Index_comment: </span><br><span class="line">3 rows in set (0.000 sec)</span><br><span class="line"></span><br><span class="line">ERROR: No query specified</span><br></pre></td></tr></table></figure><h2 id="2-8-什么时候索引会失效？"><a href="#2-8-什么时候索引会失效？" class="headerlink" title="2.8 什么时候索引会失效？"></a>2.8 什么时候索引会失效？</h2><blockquote><p><a href="https://cloud.tencent.com/developer/article/2035778">https://cloud.tencent.com/developer/article/2035778</a></p><p><a href="https://zhuanlan.zhihu.com/p/361172794">https://zhuanlan.zhihu.com/p/361172794</a></p></blockquote><h3 id="2-8-1-如果条件中有or-x2F-and"><a href="#2-8-1-如果条件中有or-x2F-and" class="headerlink" title="2.8.1 如果条件中有or&#x2F;and"></a>2.8.1 如果条件中有or&#x2F;and</h3><p>如果条件中有or&#x2F;and，即使其中<strong>有部分条件带索引</strong>也不会使用；</p><p>先说结论：如果在使用and和or进行查询的时候，只有两列都包含了索引才会使用；</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 创建示例表，其中id是主键，user_id没有创建索引</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> user3(</span><br><span class="line">id <span class="type">int</span> unsigned <span class="keyword">primary</span> key,</span><br><span class="line">user_id <span class="type">int</span> unsigned <span class="keyword">not</span> <span class="keyword">null</span>,</span><br><span class="line">    name <span class="type">varchar</span>(<span class="number">30</span>) <span class="keyword">not</span> <span class="keyword">null</span></span><br><span class="line">);</span><br><span class="line"><span class="comment">-- 插入示例数据</span></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> user3 <span class="keyword">values</span> </span><br><span class="line">(<span class="number">1</span>,<span class="number">10</span>,<span class="string">&#x27;甲&#x27;</span>),(<span class="number">2</span>,<span class="number">20</span>,<span class="string">&#x27;丙&#x27;</span>),(<span class="number">3</span>,<span class="number">30</span>,<span class="string">&#x27;乙&#x27;</span>),(<span class="number">4</span>,<span class="number">40</span>,<span class="string">&#x27;丁&#x27;</span>),</span><br><span class="line">(<span class="number">5</span>,<span class="number">50</span>,<span class="string">&#x27;尼斯&#x27;</span>),(<span class="number">6</span>,<span class="number">23</span>,<span class="string">&#x27;企鹅&#x27;</span>),(<span class="number">7</span>,<span class="number">14</span>,<span class="string">&#x27;倪浩&#x27;</span>),(<span class="number">9</span>,<span class="number">21</span>,<span class="string">&#x27;test&#x27;</span>);</span><br></pre></td></tr></table></figure><p>这时候如果用如下语句进行查询，那就不会使用索引</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> user3 <span class="keyword">where</span> id<span class="operator">=</span><span class="number">3</span> <span class="keyword">or</span> user_id<span class="operator">=</span><span class="number">40</span>;</span><br></pre></td></tr></table></figure><p>使用<code>explain</code>命令来查看运行过程，可以看到key一列为空，代表没有使用索引</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">MariaDB [hello_mysql]&gt; explain select * from user3 where id=3 or user_id=40\G;</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">           id: 1</span><br><span class="line">  select_type: SIMPLE</span><br><span class="line">        table: user3</span><br><span class="line">         type: ALL</span><br><span class="line">possible_keys: PRIMARY</span><br><span class="line">          key: NULL</span><br><span class="line">      key_len: NULL</span><br><span class="line">          ref: NULL</span><br><span class="line">         rows: 4</span><br><span class="line">        Extra: Using where</span><br><span class="line">1 row in set (0.000 sec)</span><br><span class="line"></span><br><span class="line">ERROR: No query specified</span><br><span class="line"></span><br><span class="line">MariaDB [hello_mysql]&gt; explain select * from user3 where id=2 and user_id=30\G;</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">           id: 1</span><br><span class="line">  select_type: SIMPLE</span><br><span class="line">        table: NULL</span><br><span class="line">         type: NULL</span><br><span class="line">possible_keys: NULL</span><br><span class="line">          key: NULL</span><br><span class="line">      key_len: NULL</span><br><span class="line">          ref: NULL</span><br><span class="line">         rows: NULL</span><br><span class="line">        Extra: Impossible WHERE noticed after reading const tables</span><br><span class="line">1 row in set (0.001 sec)</span><br><span class="line"></span><br><span class="line">ERROR: No query specified</span><br></pre></td></tr></table></figure><p>直接查询id，有使用索引</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">MariaDB [hello_mysql]&gt; explain select * from user3 where id=2\G;</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">           id: 1</span><br><span class="line">  select_type: SIMPLE</span><br><span class="line">        table: user3</span><br><span class="line">         type: const</span><br><span class="line">possible_keys: PRIMARY</span><br><span class="line">          key: PRIMARY</span><br><span class="line">      key_len: 4</span><br><span class="line">          ref: const</span><br><span class="line">         rows: 1</span><br><span class="line">        Extra: </span><br><span class="line">1 row in set (0.000 sec)</span><br><span class="line"></span><br><span class="line">ERROR: No query specified</span><br></pre></td></tr></table></figure><p>此时如果给<code>user_id</code>列加上索引后重新操作，那结果就不一样了</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> user3 <span class="keyword">add</span> <span class="keyword">unique</span>(user_id); <span class="comment">-- 唯一键索引</span></span><br></pre></td></tr></table></figure><p>可以看到，有使用索引（在我的测试中，并不是每次都会使用索引，这大概是因为我的内容列太少了，不如直接遍历？）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">MariaDB [hello_mysql]&gt; explain select * from user3 where id=2 and user_id=20\G;</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">           id: 1</span><br><span class="line">  select_type: SIMPLE</span><br><span class="line">        table: user3</span><br><span class="line">         type: const</span><br><span class="line">possible_keys: PRIMARY,user_id</span><br><span class="line">          key: PRIMARY</span><br><span class="line">      key_len: 4</span><br><span class="line">          ref: const</span><br><span class="line">         rows: 1</span><br><span class="line">        Extra: </span><br><span class="line">1 row in set (0.000 sec)</span><br><span class="line"></span><br><span class="line">ERROR: No query specified</span><br></pre></td></tr></table></figure><h3 id="2-8-2-复合索引没有使用最左列"><a href="#2-8-2-复合索引没有使用最左列" class="headerlink" title="2.8.2 复合索引没有使用最左列"></a>2.8.2 复合索引没有使用最左列</h3><p>使用sn + name + age创建复合索引，我们假设它们的顺序是 A + B + C，以下联合索引的使用情况如下：</p><p><img src="https://img.musnow.top/i/2023/09/d5285b42e3341a5dda532dfdaf6fc7dc.png" alt="image"></p><p>从结果可以看出，只有A+B+C或者A+B&#x2F;A+C才能触发索引，而使用B+C无法触发索引，因为没有使用最左列；</p><h3 id="2-8-3-错误模糊查询"><a href="#2-8-3-错误模糊查询" class="headerlink" title="2.8.3  错误模糊查询"></a>2.8.3  错误模糊查询</h3><p>模糊查询的时候，只有<code>关键字%</code>才能用到索引，使用<code>%关键字</code>或者<code>%关键字%</code>都是无法使用索引的；</p><p>测试表结构如下，其中ename是用户名，我给他添加了一个普通索引</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">MariaDB [bit_index]&gt; desc EMP;</span><br><span class="line">+----------+--------------------------+------+-----+---------+-------+</span><br><span class="line">| Field    | Type                     | Null | Key | Default | Extra |</span><br><span class="line">+----------+--------------------------+------+-----+---------+-------+</span><br><span class="line">| empno    | int(6) unsigned zerofill | NO   | PRI | NULL    |       |</span><br><span class="line">| ename    | varchar(10)              | YES  |     | NULL    |       |</span><br><span class="line">| job      | varchar(9)               | YES  |     | NULL    |       |</span><br><span class="line">| mgr      | int(4) unsigned zerofill | YES  |     | NULL    |       |</span><br><span class="line">| hiredate | datetime                 | YES  |     | NULL    |       |</span><br><span class="line">| sal      | decimal(7,2)             | YES  |     | NULL    |       |</span><br><span class="line">| comm     | decimal(7,2)             | YES  |     | NULL    |       |</span><br><span class="line">| deptno   | int(2) unsigned zerofill | YES  |     | NULL    |       |</span><br><span class="line">+----------+--------------------------+------+-----+---------+-------+</span><br><span class="line">8 rows in set (0.001 sec)</span><br><span class="line"></span><br><span class="line">MariaDB [bit_index]&gt; alter table EMP add index(ename);</span><br><span class="line">Query OK, 0 rows affected (11.911 sec)              </span><br><span class="line">Records: 0  Duplicates: 0  Warnings: 0</span><br></pre></td></tr></table></figure><p>然后进行测试。注意看下方3次查询的like条件区别，以及是否使用了索引；可以看到，只有第一次使用<code>FN%</code>作为查询条件的时候，才使用了索引</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">MariaDB [bit_index]&gt; explain select * from EMP where ename like &#x27;FN%&#x27;\G;</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">           id: 1</span><br><span class="line">  select_type: SIMPLE</span><br><span class="line">        table: EMP</span><br><span class="line">         type: range</span><br><span class="line">possible_keys: ename</span><br><span class="line">          key: ename</span><br><span class="line">      key_len: 33</span><br><span class="line">          ref: NULL</span><br><span class="line">         rows: 22000</span><br><span class="line">        Extra: Using index condition</span><br><span class="line">1 row in set (0.000 sec)</span><br><span class="line"></span><br><span class="line">ERROR: No query specified</span><br><span class="line"></span><br><span class="line">MariaDB [bit_index]&gt; explain select * from EMP where ename like &#x27;%FN%&#x27;\G;</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">           id: 1</span><br><span class="line">  select_type: SIMPLE</span><br><span class="line">        table: EMP</span><br><span class="line">         type: ALL</span><br><span class="line">possible_keys: NULL</span><br><span class="line">          key: NULL</span><br><span class="line">      key_len: NULL</span><br><span class="line">          ref: NULL</span><br><span class="line">         rows: 7968250</span><br><span class="line">        Extra: Using where</span><br><span class="line">1 row in set (0.000 sec)</span><br><span class="line"></span><br><span class="line">ERROR: No query specified</span><br><span class="line"></span><br><span class="line">MariaDB [bit_index]&gt; explain select * from EMP where ename like &#x27;%FN&#x27;\G;</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">           id: 1</span><br><span class="line">  select_type: SIMPLE</span><br><span class="line">        table: EMP</span><br><span class="line">         type: ALL</span><br><span class="line">possible_keys: NULL</span><br><span class="line">          key: NULL</span><br><span class="line">      key_len: NULL</span><br><span class="line">          ref: NULL</span><br><span class="line">         rows: 7968250</span><br><span class="line">        Extra: Using where</span><br><span class="line">1 row in set (0.000 sec)</span><br><span class="line"></span><br><span class="line">ERROR: No query specified</span><br></pre></td></tr></table></figure><h3 id="2-8-4-列运算"><a href="#2-8-4-列运算" class="headerlink" title="2.8.4 列运算"></a>2.8.4 列运算</h3><p>如果包含索引的列进行了运算，也不会使用索引；</p><p>比如下方，直接进行<code>id=5</code>查询的时候，可以使用索引，但用<code>id+2=5</code>进行查询的时候无法使用索引；</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">MariaDB [hello_mysql]&gt; explain select * from user3 where id=5\G;</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">           id: 1</span><br><span class="line">  select_type: SIMPLE</span><br><span class="line">        table: user3</span><br><span class="line">         type: const</span><br><span class="line">possible_keys: PRIMARY</span><br><span class="line">          key: PRIMARY</span><br><span class="line">      key_len: 4</span><br><span class="line">          ref: const</span><br><span class="line">         rows: 1</span><br><span class="line">        Extra: </span><br><span class="line">1 row in set (0.000 sec)</span><br><span class="line"></span><br><span class="line">ERROR: No query specified</span><br><span class="line"></span><br><span class="line">MariaDB [hello_mysql]&gt; explain select * from user3 where id+2=5\G;</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">           id: 1</span><br><span class="line">  select_type: SIMPLE</span><br><span class="line">        table: user3</span><br><span class="line">         type: ALL</span><br><span class="line">possible_keys: NULL</span><br><span class="line">          key: NULL</span><br><span class="line">      key_len: NULL</span><br><span class="line">          ref: NULL</span><br><span class="line">         rows: 8</span><br><span class="line">        Extra: Using where</span><br><span class="line">1 row in set (0.000 sec)</span><br><span class="line"></span><br><span class="line">ERROR: No query specified</span><br></pre></td></tr></table></figure><h3 id="2-8-5-使用函数"><a href="#2-8-5-使用函数" class="headerlink" title="2.8.5 使用函数"></a>2.8.5 使用函数</h3><p>查询列如果使用任意 MySQL 提供的函数就会导致索引失效，这一点的情况和上一点进行运算其实是类似的，毕竟函数也是一种内置的运算；</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">MariaDB [hello_mysql]&gt; explain select * from user3 where ifnull(id,0)=5\G;</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">           id: 1</span><br><span class="line">  select_type: SIMPLE</span><br><span class="line">        table: user3</span><br><span class="line">         type: ALL</span><br><span class="line">possible_keys: NULL</span><br><span class="line">          key: NULL</span><br><span class="line">      key_len: NULL</span><br><span class="line">          ref: NULL</span><br><span class="line">         rows: 8</span><br><span class="line">        Extra: Using where</span><br><span class="line">1 row in set (0.001 sec)</span><br><span class="line"></span><br><span class="line">ERROR: No query specified</span><br></pre></td></tr></table></figure><h3 id="2-8-6-类型转换"><a href="#2-8-6-类型转换" class="headerlink" title="2.8.6 类型转换"></a>2.8.6 类型转换</h3><p>当查询的条件和其本身的数据类型不同时，不会触发索引；</p><p>比如 address 为字符串类型，而查询的时候设置了 int 类型的值就会导致索引失效，如下图所示：</p><p><img src="https://img.musnow.top/i/2023/09/fb421f166c9d97c932ad6c579ea55f10.png" alt="image"></p><h3 id="2-8-7-使用is-not-null"><a href="#2-8-7-使用is-not-null" class="headerlink" title="2.8.7 使用is not null"></a>2.8.7 使用is not null</h3><p>当在查询中使用了 is not null 也会导致索引失效，而 is null 则会正常触发索引的，如下图所示：</p><p><img src="https://img.musnow.top/i/2023/09/87c89678b12c5b3a0fbb33686e46c6ec.png" alt="image.png"></p><h1 id="3-索引优化"><a href="#3-索引优化" class="headerlink" title="3.索引优化"></a>3.索引优化</h1><h2 id="3-1-关联查询优化"><a href="#3-1-关联查询优化" class="headerlink" title="3.1 关联查询优化"></a>3.1 关联查询优化</h2><p>保证被驱动表的JOIN字段已经创建了索引，需要 JOIN 的字段，数据类型保持绝对一致。</p><ul><li>LEFT JOIN 时，<strong>选择小表作为驱动表， 大表作为被驱动表</strong> 。减少外层循环的次数。</li><li>INNER JOIN 时，MySQL会自动将小结果集的表选为驱动表 。</li></ul><p><strong>选择相信MySQL优化策略</strong>。能够直接多表关联的尽量直接关联，不用子查询。(减少查询的趟数）</p><blockquote><p>不建议使用子查询，建议将子查询SQL拆开结合程序多次查询，或使用 JOIN 来代替子查询，参考第二点；</p></blockquote><p>另外，衍生表建不了索引。这点也需要注意</p><h2 id="3-2-子查询优化"><a href="#3-2-子查询优化" class="headerlink" title="3.2 子查询优化"></a>3.2 子查询优化</h2><p>MySQL从4.1版本开始支持子查询，使用子查询可以进行SELECT语句的嵌套查询，即一个SELECT查询的结果作为另一个SELECT语句的条件。 </p><p>子查询可以一次性完成很多逻辑上需要多个步骤才能完成的SQL操作，子查询是 MySQL 的一项重要的功能，可以帮助我们通过一个 SQL 语句实现比较复杂的查询。</p><p>但是，<strong>子查询的执行效率不高</strong>。原因： </p><ul><li>执行子查询时，MySQL需要为内层查询语句的查询结果 建立一个临时表 ，然后外层查询语句从临时表中查询记录。查询完毕后，再撤销这些临时表。这样会消耗过多的CPU和IO资源，产生大量的慢查询。 </li><li>子查询的结果集存储的<strong>临时表</strong>，不论是内存临时表还是磁盘临时表都<strong>不会存在索引</strong> ，所以查询性能会受到一定的影响。</li><li>对于返回结果集比较大的子查询，其对查询性能的影响也就越大。 在MySQL中，可以使用连接（JOIN）查询来替代子查询。连接查询不需要建立临时表 ，其速度比子查询要快 ，如果查询中使用索引的话，性能就会更好。</li></ul><p>结论：尽量不要使用 NOT IN 或者 NOT EXISTS，用<code>LEFT JOIN xxx ON xx WHERE xx IS NULL</code>替代；</p><h2 id="3-3-排序优化"><a href="#3-3-排序优化" class="headerlink" title="3.3 排序优化"></a>3.3 排序优化</h2><ul><li>SQL 中，可以在 WHERE 子句和 ORDER BY 子句中使用索引，目的是在 WHERE 子句中 避免全表扫 描 ，在 ORDER BY 子句 避免使用 FileSort 排序 。当然，某些情况下全表扫描，或者 FileSort 排 序不一定比索引慢。但总的来说，我们还是要避免，以提高查询效率。</li><li>尽量使用 Index 完成 ORDER BY 排序。如果 WHERE 和 ORDER BY 后面是相同的列就使用单索引列； 如果不同就使用联合索引。</li><li>无法使用 Index 时，需要对 FileSort 方式进行调优。</li></ul><h2 id="3-4-GROUP-BY优化"><a href="#3-4-GROUP-BY优化" class="headerlink" title="3.4 GROUP BY优化"></a>3.4 GROUP BY优化</h2><p>group by使用索引的原则几乎跟<code>order by</code>一致 ，group by即使没有过滤条件用到索引，也可以直接使用索引。</p><ul><li>group by 先排序再分组，遵照索引建的<strong>最佳左前缀法则</strong>；</li><li>当无法使用索引列事，增大 <code>max_length_for_sort_data</code> 和 <code>sort_buffer_size</code> 参数的设置；</li><li>where效率高于having，能写在where限定的条件就不要写在having中了！</li><li>减少使用order by，和业务沟通能不排序就不排序，或将排序放到程序端去做。Order by、group by、distinct这些语句较为耗费CPU，数据库的CPU资源是极其宝贵的。</li><li>包含了order by、group by、distinct这些查询的语句，where条件过滤出来的结果集请保持在1000行 以内，否则SQL会很慢。</li></ul><h2 id="3-5-索引覆盖"><a href="#3-5-索引覆盖" class="headerlink" title="3.5 索引覆盖"></a>3.5 索引覆盖</h2><p>这一点在上文的回表查找中已经提及了，即使用复合索引，并将你需要查询的目标字段以最左匹配原则设置到复合索引中，减少回表操作。</p><p>当然，这依旧需要遵循索引创建的原则，即如果某列数据重复量过多，则不应该作为索引列（如果真的需要，可以放在复合索引的最后面，这样能减少以之为查询判据的场景）</p>]]></content>
    
    
    <summary type="html">索引的学习</summary>
    
    
    
    <category term="学习sql" scheme="https://blog.musnow.top/categories/%E5%AD%A6%E4%B9%A0sql/"/>
    
    
    <category term="Linux" scheme="https://blog.musnow.top/tags/Linux/"/>
    
    <category term="mysql" scheme="https://blog.musnow.top/tags/mysql/"/>
    
  </entry>
  
  <entry>
    <title>【MySQL】复合查询 | 内外链接</title>
    <link href="https://blog.musnow.top/posts/2529084145/"/>
    <id>https://blog.musnow.top/posts/2529084145/</id>
    <published>2023-09-06T23:52:14.000Z</published>
    <updated>2023-09-06T23:52:30.000Z</updated>
    
    <content type="html"><![CDATA[<p>各类复合查询和笛卡尔积、内外链接的操作</p><span id="more"></span><h1 id="1-基础查询"><a href="#1-基础查询" class="headerlink" title="1.基础查询"></a>1.基础查询</h1><p>在之前的MySQL的CURD基本操作博客中，讲述了一部分查询的语法，但是在实际的生产活动中，那种最基础的查询方式不足以满足复杂查询条件时的要求，所以在普通查询的基础上，MySQL还提供了功能更强大的复合查询，本文就让我们一起来学学复合查询的操作吧！</p><blockquote><p>依旧是使用scott提供的这张表，来进行复合查询的操作。</p></blockquote><p>在那之前，先复习一下普通查询的基本操作吧！</p><ul><li>查询工资高于500或者岗位为MANAGER的成员，同时他们的姓名首字母为大写J</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> emp <span class="keyword">where</span> (sal <span class="operator">&gt;</span> <span class="number">500</span> <span class="keyword">or</span> job <span class="operator">=</span> <span class="string">&#x27;MANAGER&#x27;</span>) <span class="keyword">and</span> ename <span class="keyword">like</span> <span class="string">&#x27;J%&#x27;</span>;</span><br></pre></td></tr></table></figure><ul><li>按照部门号升序、雇员的工资降序排序</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> emp <span class="keyword">order</span> <span class="keyword">by</span> deptno, sal <span class="keyword">desc</span>;</span><br></pre></td></tr></table></figure><ul><li>显示工资高于平均工资的员工信息</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> emp <span class="keyword">where</span> sal <span class="operator">&gt;</span> (<span class="keyword">select</span> <span class="built_in">avg</span>(sal) <span class="keyword">from</span> emp);</span><br></pre></td></tr></table></figure><ul><li>显示每个部门的平均工资和最高工资</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> deptno, <span class="built_in">avg</span>(sal), <span class="built_in">max</span>(sal) <span class="keyword">from</span> emp <span class="keyword">group</span> <span class="keyword">by</span> deptno;</span><br></pre></td></tr></table></figure><ul><li>显示每种岗位的雇员数量和平均工资</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> job,<span class="built_in">count</span>(<span class="operator">*</span>),<span class="built_in">avg</span>(sal) <span class="keyword">from</span> emp <span class="keyword">group</span> <span class="keyword">by</span> job;</span><br><span class="line"><span class="comment">-- 默认情况下会保留6位小数，可以用format函数保留到2位</span></span><br><span class="line"><span class="keyword">select</span> job,<span class="built_in">count</span>(<span class="operator">*</span>),format(<span class="built_in">avg</span>(sal),<span class="number">2</span>) <span class="keyword">from</span> emp <span class="keyword">group</span> <span class="keyword">by</span> job;</span><br><span class="line"><span class="comment">-- 格式化后的输出结果如下</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-----------+----------+--------------------+</span></span><br><span class="line"><span class="operator">|</span> job       <span class="operator">|</span> <span class="built_in">count</span>(<span class="operator">*</span>) <span class="operator">|</span> format(<span class="built_in">avg</span>(sal),<span class="number">2</span>) <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-----------+----------+--------------------+</span></span><br><span class="line"><span class="operator">|</span> ANALYST   <span class="operator">|</span>        <span class="number">2</span> <span class="operator">|</span> <span class="number">3</span>,<span class="number">000.00</span>           <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> CLERK     <span class="operator">|</span>        <span class="number">4</span> <span class="operator">|</span> <span class="number">1</span>,<span class="number">037.50</span>           <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> MANAGER   <span class="operator">|</span>        <span class="number">3</span> <span class="operator">|</span> <span class="number">2</span>,<span class="number">758.33</span>           <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> PRESIDENT <span class="operator">|</span>        <span class="number">1</span> <span class="operator">|</span> <span class="number">5</span>,<span class="number">000.00</span>           <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> SALESMAN  <span class="operator">|</span>        <span class="number">4</span> <span class="operator">|</span> <span class="number">1</span>,<span class="number">400.00</span>           <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-----------+----------+--------------------+</span></span><br><span class="line"><span class="number">5</span> <span class="keyword">rows</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.000</span> sec)</span><br></pre></td></tr></table></figure><h1 id="2-多表查询"><a href="#2-多表查询" class="headerlink" title="2.多表查询"></a>2.多表查询</h1><p>基础查询的操作就复习上面几个就差不多了，接下来我们先看复合查询的第一个大点，多表查询。</p><p>所谓多表查询，就是将一个表和另外一个表合并，再在这个合并了之后的表里面进行查询；</p><ul><li>比如：显示雇员名、雇员工资以及所在部门的名字</li></ul><p>因为雇员名是在emp表里面，部门名字是在dept表里面，所以我们就需要进行多表的联合查询才能一次取到结果（一次查询的效率优于两次独立查询）</p><p>其基本语句就是在from后面添加多个表，并使用<code>表名.表中字段名</code>来指定某一个表中的字段；如果这个字段只有一个表中有，那就可以不用指定表名（但依旧建议指定表名避免出错）</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> 表<span class="number">1</span>,表<span class="number">2</span>,...;</span><br></pre></td></tr></table></figure><h2 id="2-1-笛卡尔积"><a href="#2-1-笛卡尔积" class="headerlink" title="2.1 笛卡尔积"></a>2.1 笛卡尔积</h2><p>先来一个全列查询，看看效果</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> emp,dept;</span><br></pre></td></tr></table></figure><p>可以看到，dept表直接拼接在了emp表之后，而且emp表中的每一个值都被根据dept中不同的部门ID重复了4次。这是因为在MySQL中，他并不知道你需要什么数据，所以进行数据拼接的时候，是采用穷举的方式来拼接的！</p><p>这个不加任何过滤条件，穷举拼接得到的结果被称为<code>笛卡尔积</code>！</p><p><img src="https://img.musnow.top/i/2023/09/3ab44ca912fdd37336acec9da9271b4e.png" alt="image-20230908082727650"></p><h2 id="2-2-指定条件"><a href="#2-2-指定条件" class="headerlink" title="2.2 指定条件"></a>2.2 指定条件</h2><p>接下来再回到上面提到的问题：显示雇员名、雇员工资以及所在部门的名字；</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> emp.ename,emp.sal,dept.dname <span class="keyword">from</span> emp,dept;</span><br></pre></td></tr></table></figure><p>虽然我们选中了我们需要的列来显示，但依旧没有解决笛卡尔积中穷举出来的无效数据；</p><p><img src="https://img.musnow.top/i/2023/09/962f9b4daf49a81d8a0c1a5cedcff9ba.png" alt="image-20230908083214029"></p><p>这时候就需要添加上筛选条件，来剔除掉无效的数据。</p><p>和当前员工的部门编号不同的部门数据就是无效的，我们添加上员工部门编号和部门表中的部门编号相同的条件，就可以剔除掉无效的数据。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> emp.ename,emp.sal,dept.dname <span class="keyword">from</span> emp,dept <span class="keyword">where</span> emp.deptno <span class="operator">=</span> dept.deptno;</span><br></pre></td></tr></table></figure><p>这时候筛选出来的数据，才是正确的每个员工和其对应的部门名字的数据；每个员工也不在会重复4次了。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">MariaDB [scott]&gt; select emp.ename,emp.sal,dept.dname from emp,dept where emp.deptno = dept.deptno;</span><br><span class="line">+--------+---------+------------+</span><br><span class="line">| ename  | sal     | dname      |</span><br><span class="line">+--------+---------+------------+</span><br><span class="line">| SMITH  |  800.00 | RESEARCH   |</span><br><span class="line">| ALLEN  | 1600.00 | SALES      |</span><br><span class="line">| WARD   | 1250.00 | SALES      |</span><br><span class="line">| JONES  | 2975.00 | RESEARCH   |</span><br><span class="line">| MARTIN | 1250.00 | SALES      |</span><br><span class="line">| BLAKE  | 2850.00 | SALES      |</span><br><span class="line">| CLARK  | 2450.00 | ACCOUNTING |</span><br><span class="line">| SCOTT  | 3000.00 | RESEARCH   |</span><br><span class="line">| KING   | 5000.00 | ACCOUNTING |</span><br><span class="line">| TURNER | 1500.00 | SALES      |</span><br><span class="line">| ADAMS  | 1100.00 | RESEARCH   |</span><br><span class="line">| JAMES  |  950.00 | SALES      |</span><br><span class="line">| FORD   | 3000.00 | RESEARCH   |</span><br><span class="line">| MILLER | 1300.00 | ACCOUNTING |</span><br><span class="line">+--------+---------+------------+</span><br><span class="line">14 rows in set (0.004 sec)</span><br></pre></td></tr></table></figure><p>再来做两个小练习</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 显示部门号为10的部门名字，员工名字和员工工资；</span></span><br><span class="line">MariaDB [scott]<span class="operator">&gt;</span> <span class="keyword">select</span> emp.ename,emp.sal,dept.dname <span class="keyword">from</span> emp,dept <span class="keyword">where</span> emp.deptno <span class="operator">=</span> dept.deptno <span class="keyword">and</span> dept.deptno <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line"><span class="operator">+</span><span class="comment">--------+---------+------------+</span></span><br><span class="line"><span class="operator">|</span> ename  <span class="operator">|</span> sal     <span class="operator">|</span> dname      <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">--------+---------+------------+</span></span><br><span class="line"><span class="operator">|</span> CLARK  <span class="operator">|</span> <span class="number">2450.00</span> <span class="operator">|</span> ACCOUNTING <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> KING   <span class="operator">|</span> <span class="number">5000.00</span> <span class="operator">|</span> ACCOUNTING <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> MILLER <span class="operator">|</span> <span class="number">1300.00</span> <span class="operator">|</span> ACCOUNTING <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">--------+---------+------------+</span></span><br><span class="line"><span class="number">3</span> <span class="keyword">rows</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.001</span> sec)</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 显示各个部门员工的姓名，工资，工资级别</span></span><br><span class="line">MariaDB [scott]<span class="operator">&gt;</span> <span class="keyword">select</span> emp.ename,emp.sal,salgrade.grade <span class="keyword">from</span> emp,salgrade <span class="keyword">where</span> emp.sal <span class="keyword">between</span> losal <span class="keyword">and</span> hisal;</span><br><span class="line"><span class="operator">+</span><span class="comment">--------+---------+-------+</span></span><br><span class="line"><span class="operator">|</span> ename  <span class="operator">|</span> sal     <span class="operator">|</span> grade <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">--------+---------+-------+</span></span><br><span class="line"><span class="operator">|</span> SMITH  <span class="operator">|</span>  <span class="number">800.00</span> <span class="operator">|</span>     <span class="number">1</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> ALLEN  <span class="operator">|</span> <span class="number">1600.00</span> <span class="operator">|</span>     <span class="number">3</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> WARD   <span class="operator">|</span> <span class="number">1250.00</span> <span class="operator">|</span>     <span class="number">2</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> JONES  <span class="operator">|</span> <span class="number">2975.00</span> <span class="operator">|</span>     <span class="number">4</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> MARTIN <span class="operator">|</span> <span class="number">1250.00</span> <span class="operator">|</span>     <span class="number">2</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> BLAKE  <span class="operator">|</span> <span class="number">2850.00</span> <span class="operator">|</span>     <span class="number">4</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> CLARK  <span class="operator">|</span> <span class="number">2450.00</span> <span class="operator">|</span>     <span class="number">4</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> SCOTT  <span class="operator">|</span> <span class="number">3000.00</span> <span class="operator">|</span>     <span class="number">4</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> KING   <span class="operator">|</span> <span class="number">5000.00</span> <span class="operator">|</span>     <span class="number">5</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> TURNER <span class="operator">|</span> <span class="number">1500.00</span> <span class="operator">|</span>     <span class="number">3</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> ADAMS  <span class="operator">|</span> <span class="number">1100.00</span> <span class="operator">|</span>     <span class="number">1</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> JAMES  <span class="operator">|</span>  <span class="number">950.00</span> <span class="operator">|</span>     <span class="number">1</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> FORD   <span class="operator">|</span> <span class="number">3000.00</span> <span class="operator">|</span>     <span class="number">4</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> MILLER <span class="operator">|</span> <span class="number">1300.00</span> <span class="operator">|</span>     <span class="number">2</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">--------+---------+-------+</span></span><br><span class="line"><span class="number">14</span> <span class="keyword">rows</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.001</span> sec)</span><br></pre></td></tr></table></figure><h1 id="3-自链接"><a href="#3-自链接" class="headerlink" title="3.自链接"></a>3.自链接</h1><p>所谓自连接，是在同一张表中进行链接和查询</p><p>比如显示员工FORD上级领导的员工编号和姓名</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 使用子查询</span></span><br><span class="line"><span class="keyword">select</span> empno,ename <span class="keyword">from</span> emp <span class="keyword">where</span> emp.empno<span class="operator">=</span>(<span class="keyword">select</span> mgr <span class="keyword">from</span> emp <span class="keyword">where</span></span><br><span class="line">ename<span class="operator">=</span><span class="string">&#x27;FORD&#x27;</span>);</span><br><span class="line"><span class="comment">-- 使用多表查询（其实是给emp表起两个不同的别名）</span></span><br><span class="line"><span class="keyword">select</span> leader.empno,leader.ename <span class="keyword">from</span> emp leader, emp worker <span class="keyword">where</span></span><br><span class="line">leader.empno <span class="operator">=</span> worker.mgr <span class="keyword">and</span> worker.ename<span class="operator">=</span><span class="string">&#x27;FORD&#x27;</span>;</span><br></pre></td></tr></table></figure><p>这种在一张表里面进行笛卡儿积的查询操作，就叫做自链接。最终都可以获取到正确结果</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">+--------+-------+</span><br><span class="line">| empno  | ename |</span><br><span class="line">+--------+-------+</span><br><span class="line">| 007566 | JONES |</span><br><span class="line">+--------+-------+</span><br><span class="line">1 row in set (0.001 sec)</span><br></pre></td></tr></table></figure><h1 id="4-子查询"><a href="#4-子查询" class="headerlink" title="4.子查询"></a>4.子查询</h1><p>子查询值得是，将一个查询语句作为子操作，嵌入到一个sql语句中；</p><p>我们可以把子查询的结果也当作是一张表来进行处理，这样一想就能理解子查询是怎么玩的了。</p><h2 id="4-1-单行子查询"><a href="#4-1-单行子查询" class="headerlink" title="4.1 单行子查询"></a>4.1 单行子查询</h2><p>显示和SMITH同一个部门的员工</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> emp <span class="keyword">where</span> deptno <span class="operator">=</span> (<span class="keyword">select</span> deptno <span class="keyword">from</span> emp <span class="keyword">where</span> ename<span class="operator">=</span><span class="string">&#x27;smith&#x27;</span>);</span><br></pre></td></tr></table></figure><p>在这个查询中，子查询语句是<code>(select deptno from emp where ename=&#39;smith&#39;)</code>，这个语句返回的结果只有一行，所以被称为单行子查询；</p><h2 id="4-2-多行子查询"><a href="#4-2-多行子查询" class="headerlink" title="4.2 多行子查询"></a>4.2 多行子查询</h2><p>有单行查询，自然也有多行查询。但是如果一个语句返回了多条结果，将其直接作为判据肯定是不行的，这会导致判据不唯一，MySQL不知道你到底想要比较的是那一部分的数据。这时候就需要用下面几个关键字来帮忙了</p><ul><li>in：查询存在于某某结果里面的数据</li><li>all：查询比这个结果中所有值都大&#x2F;小的数据</li><li>any：查询比这个结果中某一个值大&#x2F;小的数据</li></ul><p>以下是几个示例</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 查询和10号部门工作岗位相同的员工名字、岗位、工资、部门号，但是不包含10号部门自己的员工</span></span><br><span class="line"><span class="keyword">select</span> ename,job,sal,deptno <span class="keyword">from</span> emp <span class="keyword">where</span> job <span class="keyword">in</span> (<span class="keyword">select</span> job <span class="keyword">from</span> emp <span class="keyword">where</span> deptno<span class="operator">=</span><span class="number">10</span>) <span class="keyword">and</span> deptno <span class="operator">&lt;&gt;</span> <span class="number">10</span>;</span><br><span class="line"><span class="operator">+</span><span class="comment">-------+---------+---------+--------+</span></span><br><span class="line"><span class="operator">|</span> ename <span class="operator">|</span> job     <span class="operator">|</span> sal     <span class="operator">|</span> deptno <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-------+---------+---------+--------+</span></span><br><span class="line"><span class="operator">|</span> SMITH <span class="operator">|</span> CLERK   <span class="operator">|</span>  <span class="number">800.00</span> <span class="operator">|</span>     <span class="number">20</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> JONES <span class="operator">|</span> MANAGER <span class="operator">|</span> <span class="number">2975.00</span> <span class="operator">|</span>     <span class="number">20</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> BLAKE <span class="operator">|</span> MANAGER <span class="operator">|</span> <span class="number">2850.00</span> <span class="operator">|</span>     <span class="number">30</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> ADAMS <span class="operator">|</span> CLERK   <span class="operator">|</span> <span class="number">1100.00</span> <span class="operator">|</span>     <span class="number">20</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> JAMES <span class="operator">|</span> CLERK   <span class="operator">|</span>  <span class="number">950.00</span> <span class="operator">|</span>     <span class="number">30</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-------+---------+---------+--------+</span></span><br><span class="line"><span class="number">5</span> <span class="keyword">rows</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.001</span> sec)</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 显示部门工资比30号部门所有员工工资都高的员工姓名、工资、部门号</span></span><br><span class="line"><span class="keyword">select</span> ename,sal,deptno <span class="keyword">from</span> emp <span class="keyword">where</span> sal <span class="operator">&gt;</span> <span class="keyword">all</span>(<span class="keyword">select</span> sal <span class="keyword">from</span> emp <span class="keyword">where</span> deptno <span class="operator">=</span> <span class="number">30</span>);</span><br><span class="line"><span class="operator">+</span><span class="comment">-------+---------+--------+</span></span><br><span class="line"><span class="operator">|</span> ename <span class="operator">|</span> sal     <span class="operator">|</span> deptno <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-------+---------+--------+</span></span><br><span class="line"><span class="operator">|</span> JONES <span class="operator">|</span> <span class="number">2975.00</span> <span class="operator">|</span>     <span class="number">20</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> SCOTT <span class="operator">|</span> <span class="number">3000.00</span> <span class="operator">|</span>     <span class="number">20</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> KING  <span class="operator">|</span> <span class="number">5000.00</span> <span class="operator">|</span>     <span class="number">10</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> FORD  <span class="operator">|</span> <span class="number">3000.00</span> <span class="operator">|</span>     <span class="number">20</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-------+---------+--------+</span></span><br><span class="line"><span class="number">4</span> <span class="keyword">rows</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.001</span> sec)</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">各类复合查询和笛卡尔积、内外链接的操作</summary>
    
    
    
    <category term="学习sql" scheme="https://blog.musnow.top/categories/%E5%AD%A6%E4%B9%A0sql/"/>
    
    
    <category term="Linux" scheme="https://blog.musnow.top/tags/Linux/"/>
    
    <category term="mysql" scheme="https://blog.musnow.top/tags/mysql/"/>
    
  </entry>
  
  <entry>
    <title>【Linux】root和子用户都能执行的命令，sudo无法执行（已解决）</title>
    <link href="https://blog.musnow.top/posts/2473452644/"/>
    <id>https://blog.musnow.top/posts/2473452644/</id>
    <published>2023-09-01T10:12:55.000Z</published>
    <updated>2023-09-01T10:12:55.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>全流程帖子 <a href="https://ask.oceanbase.com/t/topic/35604437/7">https://ask.oceanbase.com/t/topic/35604437/7</a></p></blockquote><h1 id="1-问题"><a href="#1-问题" class="headerlink" title="1.问题"></a>1.问题</h1><p>如题，在编译miniob的时候遇到如下错误</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[mu@vm-cnt8:~/code/miniob]$ sudo bash build.sh init</span><br><span class="line">build.sh init</span><br><span class="line">HEAD is now at 5df3037d Merge branch <span class="string">&#x27;release-2.1.12-stable-pull&#x27;</span> into patches-2.1</span><br><span class="line">build.sh: line 83: cmake: <span class="built_in">command</span> not found</span><br><span class="line">build.sh: line 91: cmake: <span class="built_in">command</span> not found</span><br><span class="line">build.sh: line 99: cmake: <span class="built_in">command</span> not found</span><br><span class="line">build.sh: line 107: cmake: <span class="built_in">command</span> not found</span><br></pre></td></tr></table></figure><p>根据字面意思，是cmake命令找不到，但是我的系统里面已经有了符合条件的环境；以下是gihub&#x2F;miniob仓库中docs里面<code>how_to_build.md</code>的内容</p><blockquote><p>MiniOB 需要使用：</p><ul><li>cmake 版本 &gt;&#x3D; 3.13</li><li>gcc&#x2F;clang gcc建议8.3以上，编译器需要支持c++20新标准</li><li>flex (2.5+), bison (3.7+) 用于生成词法语法分析代码</li></ul></blockquote><p>我使用的系统是centos8-steam的vmware虚拟机；当前使用的miniob的commit为</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">76221e46e66ef408771ce886aa0c586a09374b0d</span><br></pre></td></tr></table></figure><p>以下是我的系统中各个依赖项的版本号，可以看到在子用户中，依赖项的所有命令都可以正常执行</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">[mu@vm-cnt8:~/code/miniob]$ gcc --version</span><br><span class="line">gcc (GCC) 8.5.0 20210514 (Red Hat 8.5.0-20)</span><br><span class="line">Copyright (C) 2018 Free Software Foundation, Inc.</span><br><span class="line">This is free software; see the <span class="built_in">source</span> <span class="keyword">for</span> copying conditions.  There is NO</span><br><span class="line">warranty; not even <span class="keyword">for</span> MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.</span><br><span class="line"></span><br><span class="line">[mu@vm-cnt8:~/code/miniob]$ cmake --version</span><br><span class="line">cmake version 3.27.4</span><br><span class="line"></span><br><span class="line">CMake suite maintained and supported by Kitware (kitware.com/cmake).</span><br><span class="line">[mu@vm-cnt8:~/code/miniob]$ flex --version</span><br><span class="line">flex 2.6.1</span><br><span class="line">[mu@vm-cnt8:~/code/miniob]$ bison --version</span><br><span class="line">bison (GNU Bison) 3.8</span><br><span class="line">Written by Robert Corbett and Richard Stallman.</span><br><span class="line"></span><br><span class="line">Copyright (C) 2021 Free Software Foundation, Inc.</span><br><span class="line">This is free software; see the <span class="built_in">source</span> <span class="keyword">for</span> copying conditions.  There is NO</span><br><span class="line">warranty; not even <span class="keyword">for</span> MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.</span><br></pre></td></tr></table></figure><p>在root中，也可以正常执行这些命令</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">[root@vm-cnt8:~]# cmake --version</span><br><span class="line">cmake version 3.27.4</span><br><span class="line"></span><br><span class="line">CMake suite maintained and supported by Kitware (kitware.com/cmake).</span><br><span class="line">[root@vm-cnt8:~]# flex --version</span><br><span class="line">flex 2.6.1</span><br><span class="line">[root@vm-cnt8:~]# bison --version</span><br><span class="line">bison (GNU Bison) 3.8</span><br><span class="line">Written by Robert Corbett and Richard Stallman.</span><br><span class="line"></span><br><span class="line">Copyright (C) 2021 Free Software Foundation, Inc.</span><br><span class="line">This is free software; see the source for copying conditions.  There is NO</span><br><span class="line">warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.</span><br></pre></td></tr></table></figure><p>但是sudo执行miniob的安装脚本的时候，却找不到cmake命令</p><h1 id="2-debug过程"><a href="#2-debug过程" class="headerlink" title="2.debug过程"></a>2.debug过程</h1><p>经过大佬的教学，知道了一个新的sudo用法：<code>sudo -E</code></p><blockquote><p><code>sudo -E</code> 是继承当前用户的环境变量运行sudo后面的命令，否则环境变量会被清理掉；</p></blockquote><p>但是在初次使用的时候，依旧无法成功编译miniob，也找不到cmake命令</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">[mu@vm-cnt8:~/code/miniob]$ sudo -E bash build.sh init</span><br><span class="line">[sudo] password for mu: </span><br><span class="line">build.sh init</span><br><span class="line">HEAD is now at 5df3037d Merge branch &#x27;release-2.1.12-stable-pull&#x27; into patches-2.1</span><br><span class="line">build.sh: line 83: cmake: command not found</span><br><span class="line">build.sh: line 91: cmake: command not found</span><br><span class="line">build.sh: line 99: cmake: command not found</span><br><span class="line">build.sh: line 107: cmake: command not found</span><br><span class="line"></span><br><span class="line">[mu@vm-cnt8:~]$ sudo -E cmake --version</span><br><span class="line">[sudo] password for mu: </span><br><span class="line">sudo: cmake: command not found</span><br></pre></td></tr></table></figure><h1 id="3-最终解决：PATH环境变量"><a href="#3-最终解决：PATH环境变量" class="headerlink" title="3.最终解决：PATH环境变量"></a>3.最终解决：PATH环境变量</h1><p>最终的解决办法是我自己想出来的（大佬也回复了我这个解决方案）</p><p>当前在子用户使用 <code>sudo -E</code>是找不到cmake命令的。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[mu@vm-cnt8:~]$ sudo -E cmake --version</span><br><span class="line">[sudo] password for mu: </span><br><span class="line">sudo: cmake: command not found</span><br></pre></td></tr></table></figure><p>我的系统里面的PATH环境变量如下。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[mu@vm-cnt8:~]$ sudo <span class="built_in">env</span> | grep PATH</span><br><span class="line">PATH=/sbin:/bin:/usr/sbin:/usr/bin</span><br></pre></td></tr></table></figure><p>而cmake的路径如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[mu@vm-cnt8:~]$ type cmake</span><br><span class="line">cmake is /usr/local/bin/cmake</span><br><span class="line">[mu@vm-cnt8:~]$ whereis cmake</span><br><span class="line">cmake: /usr/local/bin/cmake /usr/share/cmake</span><br></pre></td></tr></table></figure><p>有没有可能，是因为cmake不在PATH环境变量里面，导致sudo的时候找不到命令呢？虽然在root和mu用户下都可以直接执行cmake。</p><p>于是我就去root里面执行了一下软连接</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@vm-cnt8:~]# ls /usr/bin | grep cmake</span><br><span class="line">[root@vm-cnt8:~]# ln -s /usr/local/bin/cmake /usr/bin/cmake</span><br><span class="line">[root@vm-cnt8:~]# ll /usr/bin | grep cmake</span><br><span class="line">lrwxrwxrwx. 1 root root          20 Sep  1 05:57 cmake -&gt; /usr/local/bin/cmake</span><br></pre></td></tr></table></figure><p>再来试试</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ sudo -E cmake --version</span><br><span class="line">cmake version 3.27.4</span><br><span class="line"></span><br><span class="line">CMake suite maintained and supported by Kitware (kitware.com/cmake).</span><br></pre></td></tr></table></figure><p>最后再来试试编译，应该是OK了，init成功执行，编译也通过了，没有报错</p><p><img src="https://img.musnow.top/i/2023/09/7e206210ba3f9ffa5df6a492ae7b457a.png" alt="image-20230901181050840"></p><p>感谢miniob社区大佬们的帮助！</p><h1 id="4-结论"><a href="#4-结论" class="headerlink" title="4.结论"></a>4.结论</h1><p>如果出现一个命令，root和子用户都可以执行，但是子用户中sudo却找不到此命令，可以尝试检查一下该命令所在路径是否与当前系统的PATH环境变量不符合！</p>]]></content>
    
    
    <summary type="html">root和子用户都能执行的命令，sudo却无法执行，如何解决？</summary>
    
    
    
    <category term="玩上Linux" scheme="https://blog.musnow.top/categories/%E7%8E%A9%E4%B8%8ALinux/"/>
    
    
    <category term="Linux" scheme="https://blog.musnow.top/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>【win】Windows下MSI Afterburner如何让其不在某个软件中显示帧数</title>
    <link href="https://blog.musnow.top/posts/4160666395/"/>
    <id>https://blog.musnow.top/posts/4160666395/</id>
    <published>2023-08-31T13:44:31.000Z</published>
    <updated>2023-08-31T13:44:31.000Z</updated>
    
    <content type="html"><![CDATA[<p>Windows下MSI Afterburner如何让其不在某个软件中显示帧数</p><span id="more"></span><h1 id="1-问题说明"><a href="#1-问题说明" class="headerlink" title="1.问题说明"></a>1.问题说明</h1><p>总所周知，<code>MSI Afterburner</code>这个软件可以在游戏里面展示你当前电脑的各项生命体征，包括GPU&#x2F;CPU功耗频率温度，内存占用，当前帧数等等数据，不管是用来监看电脑运行是否正常，还是用来小超一下显卡，都是很好用的东西，再加上毫无广告+免费，几乎是人手必备的PC良药</p><p><img src="https://img.musnow.top/i/2023/08/22a440a97052d98344faa1679af7e4a1.png" alt="image-20230831211541651"></p><p>但总有时候这个软件会抽风，比如我的电脑里面，最新版本的这个软件，就会把照片莫名其妙的也识别成了一个游戏，在里面显示帧数，最离谱的是，最下方的预览其他图片的小框框里面，也给你显示了帧数</p><p><img src="https://img.musnow.top/i/2023/08/33033ee6b815fd496aefff2db7b41983.png" alt="image-20230831211739693"></p><p>这肯定很恼火，我们要怎么样才能让他不在这里面显示呢？</p><h1 id="2-配置"><a href="#2-配置" class="headerlink" title="2.配置"></a>2.配置</h1><p>和<code>MSI Afterburner</code>捆绑下载的有这么一个软件，其实它才是负责将数据投屏到你的屏幕上的软件，在这里面，我们就可以设置在某个软件中不显示帧数</p><p><img src="https://img.musnow.top/i/2023/08/38ddd77df81cad02c8ac53f0834550f8.png" alt="image-20230831212031500"></p><p>对于正常安装的软件，我们都可以找到软件的安装路径，选中它的exe可执行文件，再设置一下把帧数器关闭，就可以避免错误地显示帧数影响软件自身的使用</p><p><img src="https://img.musnow.top/i/2023/08/952d106d45b52990e2bd63ae4ddc5534.png" alt="image-20230831212050181"></p><p>但是windows自带的相册就有点恼火了，<strong>我们压根不知道它的可执行文件在哪里</strong>！</p><h1 id="3-windows系统应用的可执行文件"><a href="#3-windows系统应用的可执行文件" class="headerlink" title="3.windows系统应用的可执行文件"></a>3.windows系统应用的可执行文件</h1><p>windows绝大部分的系统自带软件都在这里面，你需要打开显示隐藏文件夹才能看到此文件夹</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">C:\Program Files\WindowsApps\</span><br></pre></td></tr></table></figure><p>而<a href="https://zhidao.baidu.com/question/1550787637804576787.html">照片软件路径</a>如下（我的win11版本是<code>22H2 22621.963</code>）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">C:\Program Files\WindowsApps\Microsoft.Windows.Photos_2023.11080.4003.0_x64__8wekyb3d8bbwe</span><br></pre></td></tr></table></figure><p>这里面有一个<code>PhotosApp.exe</code>，就是windows自带照片的可执行文件了；</p><p>但是！你会发现你压根没有 <code>C:\Program Files\WindowsApps\</code>这个文件夹的进入权限，更别提找到这个照片软件的exe了！</p><p>百度了一下，找到了一个教程 <a href="https://www.bkqs.com.cn/content/kn928o443.html">Win10下WindowsApps权限怎么获取</a>；顺带一提，为了避免原文失效，这篇文章也转载到了本站。</p><blockquote><p>注意！毕竟这算是系统底层文件夹了，我不确定这样修改文件夹权限是否会出现问题！如果你担心出现问题，<strong>请不要操作</strong>，在不打游戏的时候不要启动MSI Afterbuner是更好的选择！</p><p>如果出现问题，参考 【<a href="https://blog.csdn.net/oh_futrue/article/details/91042020">WindowsApps 权限问题导致Microsoft Store及其下载的应用不能启动（闪退）的解决办法</a>】 复原权限！实在不行就恐怕要重装系统了 🤣</p><p><img src="https://img.musnow.top/i/2023/08/91c5e537eee80c51f1e2788b15a7d997.png" alt="image-20230831214242664"></p><p>目前我这边还么有出现异常情况，毕竟我修改为了<code>everyone</code>理论上来说是并不会出现权限不够而导致某个程序无法执行的问题的</p></blockquote><p>根据教程里面的步骤一步一步来，就可以获取到这个文件夹的进入权限</p><p><img src="https://img.musnow.top/i/2023/08/f35c62ab02b889383a3f88a3b9700629.png" alt="image-20230831212801573"></p><h1 id="4-禁用照片中的帧数显示"><a href="#4-禁用照片中的帧数显示" class="headerlink" title="4.禁用照片中的帧数显示"></a>4.禁用照片中的帧数显示</h1><p>找到这个<code>PhotosApp.exe</code>之后，在<code>RivaTuner</code>这个软件里面选中这个可执行文件，将其的display关闭</p><p><img src="https://img.musnow.top/i/2023/08/b98f245a377bbfe1369b7cb9809fc9a5.png" alt="image-20230831212557862"></p><p>好了，这下没有胡乱显示帧数了！</p><p><img src="https://img.musnow.top/i/2023/08/d0f3baad38aec23619141b8cf92b6292.png" alt="image-20230831212631268"></p>]]></content>
    
    
    <summary type="html">Windows下MSI Afterburner如何让其不在某个软件中显示帧数</summary>
    
    
    
    <category term="电脑使用小贴士" scheme="https://blog.musnow.top/categories/%E7%94%B5%E8%84%91%E4%BD%BF%E7%94%A8%E5%B0%8F%E8%B4%B4%E5%A3%AB/"/>
    
    
    <category term="windows" scheme="https://blog.musnow.top/tags/windows/"/>
    
  </entry>
  
  <entry>
    <title>【win】Windows下C盘里面的WindowsApps文件夹权限怎么获取</title>
    <link href="https://blog.musnow.top/posts/3712817486/"/>
    <id>https://blog.musnow.top/posts/3712817486/</id>
    <published>2023-08-31T13:34:31.000Z</published>
    <updated>2023-08-31T13:34:31.000Z</updated>
    
    <content type="html"><![CDATA[<p>避免原文失效，转载此文</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">原文 https://www.bkqs.com.cn/content/kn928o443.html</span><br></pre></td></tr></table></figure><h1 id="Win下WindowsApps权限怎么获取"><a href="#Win下WindowsApps权限怎么获取" class="headerlink" title="Win下WindowsApps权限怎么获取"></a>Win下WindowsApps权限怎么获取</h1><p><code>2023-01-31 14:32:17</code></p><p>Win10下WindowsApps权限怎么获取？WindowsApps安装的是Windows应用商店的应用程序，访问此文件夹需要获取权限才能进入。具体怎么设置呢？一起来了解下吧！</p><p><img src="https://img.musnow.top/i/2023/08/df83e62f3e53e132acb209f09a797b6f.png"></p><h2 id="操作方法"><a href="#操作方法" class="headerlink" title="操作方法"></a>操作方法</h2><ul><li><p>01</p><p>1、在计算机中，打开此电脑。点击查看选项，并勾选选项框中的“隐藏的项目”。如图所示；</p><p><img src="https://img.musnow.top/i/2023/08/ac1473123b0f35d32f01b7539023fb51.png"></p></li><li><p>02</p><p>2、在此电脑窗口中，找到系统盘下的“WindowsApps”（隐藏的文件夹），具体路径为“C:\Program Files\WindowsApps”。如图所示；</p><p><img src="https://img.musnow.top/i/2023/08/9a1d5608930d12c04e4303e3b923a747.png"></p></li><li><p>03</p><p>3、选中WindowsApps文件夹，并点击鼠标右键，在弹出的选项框中点击“属性”选项。如图所示；</p><p><img src="https://img.musnow.top/i/2023/08/32e95c80075f35fb9004e63797b1f1d7.png"></p></li><li><p>04</p><p>4、点击属性选项后，这个时候会打开“WindowsApps属性”对话框。如图所示；</p><p><img src="https://img.musnow.top/i/2023/08/5ede94735ea0e66cb1115012e795b0df.png"></p></li><li><p>05</p><p>5、在WindowsApps属性对话框中，切换到“安全”选项卡。如图所示；</p><p><img src="https://img.musnow.top/i/2023/08/b92921c8b6547e8a81e68752e96c830f.png"></p></li><li><p>06</p><p>6、在安全选项卡下，看到提示“必须具有读取权限才能查看对象属性”，并点击“高级”选项按钮。如图所示；</p><p><img src="https://img.musnow.top/i/2023/08/a13b0247ca7b99c1793189336e492c85.png"></p></li><li><p>07</p><p>7、点击高级选项后，这个时候会打开“WindowsApps的高级安全设置”对话窗口。如图所示；</p><p><img src="https://img.musnow.top/i/2023/08/434d13327223687c0ae808b9e5bd0226.png"></p></li><li><p>08</p><p>8、在WindowsApps的高级安全设置对话窗口中，点击所有者后的“更改”按钮。如图所示；</p><p><img src="https://img.musnow.top/i/2023/08/c7060a1aacb894d0ea904202291e9267.png"></p></li><li><p>09</p><p>9、点击更改后，这个时候会打开“选择用户或组”对话框。如图所示；</p><p><img src="https://img.musnow.top/i/2023/08/9b02a003b59c4ce73a72690fc414c038.png"></p></li><li><p>10</p><p>10、在输入要选择的对象名称输入框中，输入“Everyone”，并点击“确定”按钮。如图所示；</p><p><img src="https://img.musnow.top/i/2023/08/fa792f7c20c081c4079f02f6734e2e8d.png"></p></li><li><p>11</p><p>11、点击确定后，这个时候会跳转到WindowsApps的高级安全设置对话窗口。如图所示；</p><p><img src="https://img.musnow.top/i/2023/08/f132cedbea9f1c6677375c0661e68994.png"></p></li><li><p>12</p><p>12、接着勾选所有者下的“替换子容器和对象的所有者”，并点击“确定”按钮。如图所示；</p><p><img src="https://img.musnow.top/i/2023/08/bf8f5bb96b5daa6290850574d2258bb7.png"></p></li><li><p>13</p><p>13、点击确定后，这个时候会弹出Windows安全对话框，进行更改所有权。如图所示；</p><p><img src="https://img.musnow.top/i/2023/08/74051d49c0138f62d250c588acb0eaa4.png"></p></li><li><p>14</p><p>14、更改所有权完成后，这个时候就能正常访问“WindowsApps”文件夹了。如图所示；</p><p><img src="https://img.musnow.top/i/2023/08/c523ded7262708fbef624c1c742997f8.png"></p></li></ul>]]></content>
    
    
    <summary type="html">Win下C盘里面的WindowsApps权限怎么获取</summary>
    
    
    
    <category term="电脑使用小贴士" scheme="https://blog.musnow.top/categories/%E7%94%B5%E8%84%91%E4%BD%BF%E7%94%A8%E5%B0%8F%E8%B4%B4%E5%A3%AB/"/>
    
    
    <category term="windows" scheme="https://blog.musnow.top/tags/windows/"/>
    
  </entry>
  
  <entry>
    <title>【Linux】centos8安装bison3.8</title>
    <link href="https://blog.musnow.top/posts/1067381808/"/>
    <id>https://blog.musnow.top/posts/1067381808/</id>
    <published>2023-08-30T10:31:55.000Z</published>
    <updated>2023-08-30T10:31:55.000Z</updated>
    
    <content type="html"><![CDATA[<p>centos8安装<code>bison3.8</code>的教程，感觉这个软件包很<code>小众</code>啊，百度找不到安装教程，最终还是在起脚旮旯里面翻出来了很久之前的文档，好在没有过时；</p><span id="more"></span><blockquote><p><a href="https://linux.cn/lfs/LFS-BOOK-7.7-systemd/chapter06/bison.html">https://linux.cn/lfs/LFS-BOOK-7.7-systemd/chapter06/bison.html</a></p></blockquote><p><img src="https://img.musnow.top/i/2023/09/db6be01dbd28cd3371fdf8e5d657b968.png" alt="image-20230901215525821"></p><p>虽然centos8中你可以使用yum直接安装，但是哪个安装的版本太低了，达不到如今的需求</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install -y bison</span><br></pre></td></tr></table></figure><p>我这边直接用yum安装的是<code>3.0.4</code>的版本，已经是2015年的东西了，最新的版本已经到3.8了，而且我正在使用的新项目miniob就要求更高的版本，所以老版本肯定是不行的；</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">bison (GNU Bison) 3.0.4</span><br><span class="line">Written by Robert Corbett and Richard Stallman.</span><br><span class="line"></span><br><span class="line">Copyright (C) 2015 Free Software Foundation, Inc.</span><br><span class="line">This is free software; see the source for copying conditions.  There is NO</span><br><span class="line">warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.</span><br></pre></td></tr></table></figure><p>先用yum把安装好了的删掉</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum remove bison</span><br></pre></td></tr></table></figure><blockquote><p>我看有的文章说需要先安装前置依赖项<code>flex</code>，这里带上吧。因为我的系统里面不知道什么时候就已经安装好了这个东西了</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install flex</span><br></pre></td></tr></table></figure></blockquote><p>去官网 <a href="http://ftp.gnu.org/gnu/bison/">http://ftp.gnu.org/gnu/bison/</a> 下载最新的压缩包</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget http://ftp.gnu.org/gnu/bison/bison-3.8.tar.gz</span><br></pre></td></tr></table></figure><p>解压并进入文件夹</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">tar -zxvf bison-3.8.tar.gz</span><br><span class="line">cd bison-3.8</span><br></pre></td></tr></table></figure><p>配置安装路径，这里我使用了<code>/usr/local</code>这个目录，如果你查看过安装后的bison，你会发现它的安装包的逻辑是和<code>/usr/local</code>目录一致的，当然你也可以修改成你自己想要的目录</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># ls /usr/local/</span><br><span class="line">bin  doc  etc  games  include  lib  lib64  libexec  openssl-1.1.1  sbin  share  src</span><br></pre></td></tr></table></figure><p>使用如下命令配置安装路径为<code>/usr/local</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./configure -prefix=/usr/local/</span><br></pre></td></tr></table></figure><p>目录配置好了之后，make安装</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make install</span><br></pre></td></tr></table></figure><blockquote><p>如果要卸载，用<code>make uninstall</code></p></blockquote><p>安装好了之后执行<code>bison --version</code>，你会得到如下输出</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-bash: /usr/bin/bison: No such file or directory</span><br></pre></td></tr></table></figure><p>这是因为我们在<code>/usr/local</code>里面安装的东西没有在path中，没有办法直接执行，需要我们将其软链接到<code>/usr/bin</code>里面；</p><p>如果你的安装正确了，应该可以在<code>/usr/local/bin</code>里面找到<code>bison</code>; 如果你安装的路径不同，那就去你安装路径下找<code>bison</code>的可执行文件；</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># ls /usr/local/bin</span></span><br><span class="line">2to3-3.10  bison  cmake  cpack  ctest  docker-compose  idle3.10  pip3.10  pydoc3.10  python3.10  python3.10-config  yacc</span><br></pre></td></tr></table></figure><p>将其软连接一下就ok了</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># ln -s /usr/local/bin/bison /usr/bin/bison</span></span><br><span class="line"><span class="comment"># ls /usr/bin/bison</span></span><br><span class="line">/usr/bin/bison</span><br></pre></td></tr></table></figure><p>再次检查版本，安装<code>3.8</code>成功！</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># bison --version</span><br><span class="line">bison (GNU Bison) 3.8</span><br><span class="line">Written by Robert Corbett and Richard Stallman.</span><br><span class="line"></span><br><span class="line">Copyright (C) 2021 Free Software Foundation, Inc.</span><br><span class="line">This is free software; see the source for copying conditions.  There is NO</span><br><span class="line">warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;centos8安装&lt;code&gt;bison3.8&lt;/code&gt;的教程，感觉这个软件包很&lt;code&gt;小众&lt;/code&gt;啊，百度找不到安装教程，最终还是在起脚旮旯里面翻出来了很久之前的文档，好在没有过时；&lt;/p&gt;</summary>
    
    
    
    <category term="玩上Linux" scheme="https://blog.musnow.top/categories/%E7%8E%A9%E4%B8%8ALinux/"/>
    
    
    <category term="Linux" scheme="https://blog.musnow.top/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>【Linux】centos8安装cmake3.27.4</title>
    <link href="https://blog.musnow.top/posts/343476194/"/>
    <id>https://blog.musnow.top/posts/343476194/</id>
    <published>2023-08-30T10:30:55.000Z</published>
    <updated>2023-08-30T10:30:55.000Z</updated>
    
    <content type="html"><![CDATA[<p>第一步，去<a href="https://cmake.org/download/">官网</a>下安装包，一定不要下错了</p><p><img src="https://img.musnow.top/i/2023/08/a7b64c50664a8d69fb805fcbb17edcbe.png" alt="image-20230830175242958"></p><p>下好了之后，用ftp软件传到云服务器或者虚拟机上，也可以用wget直接下载</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget https://github.com/Kitware/CMake/releases/download/v3.27.4/cmake-3.27.4.tar.gz</span><br></pre></td></tr></table></figure><p>我用的是centos8系统，安装之前先准备好这些依赖项</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">yum install -y gcc gcc-c++ make automake</span><br><span class="line">yum install -y openssl  openssl-devel</span><br></pre></td></tr></table></figure><p>把下载好的安装包传上去后，解压（在root用户下操作）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar -zxvf cmake-3.27.4.tar.gz </span><br></pre></td></tr></table></figure><p>解压完毕后进入文件夹</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cd cmake-3.27.4</span><br></pre></td></tr></table></figure><p>执行命令</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./bootstrap</span><br></pre></td></tr></table></figure><p>耐心等候完成后，依次运行下面两个命令</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">gmake</span><br><span class="line">gmake install</span><br></pre></td></tr></table></figure><p>最终判断是否安装成功</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cmake --version</span><br></pre></td></tr></table></figure><p>出现如下信息就是搞定了</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># cmake --version</span><br><span class="line">cmake version 3.27.4</span><br><span class="line"></span><br><span class="line">CMake suite maintained and supported by Kitware (kitware.com/cmake).</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;第一步，去&lt;a href=&quot;https://cmake.org/download/&quot;&gt;官网&lt;/a&gt;下安装包，一定不要下错了&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img.musnow.top/i/2023/08/a7b64c50664a8d69fb805fcbb</summary>
      
    
    
    
    <category term="玩上Linux" scheme="https://blog.musnow.top/categories/%E7%8E%A9%E4%B8%8ALinux/"/>
    
    
    <category term="Linux" scheme="https://blog.musnow.top/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>【C++】C++14的那些新特性</title>
    <link href="https://blog.musnow.top/posts/1184922698/"/>
    <id>https://blog.musnow.top/posts/1184922698/</id>
    <published>2023-08-28T14:40:46.000Z</published>
    <updated>2023-08-28T14:40:46.000Z</updated>
    
    <content type="html"><![CDATA[<p>学习C++14的那些新特性</p><span id="more"></span><p><img src="https://img.musnow.top/i/2023/08/0061de987afa3c3003cbfa4762397ac5.png" alt="v2-642fda8762a7dcda4556e14c8ff5c1ef_1440w"></p><p>为了方便指定使用C++14来编译代码，本文的测试都是在linux下进行的，g++版本如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ g++ --version</span><br><span class="line">g++ (GCC) 8.5.0 20210514 (Red Hat 8.5.0-4)</span><br></pre></td></tr></table></figure><p>如果你和我一样，也是使用VSC来链接linux进行代码编写，那一定要记得修改C++插件里面的CPP版本，否则默认以C++11来进行语法高亮的话，会把C++11不支持的语法标红，影响我们学习</p><p><img src="https://img.musnow.top/i/2023/08/8363f819fd562b1bd452551e970ff4a3.png" alt="image-20230828230838973"></p><blockquote><p>本文参考 <a href="https://zhuanlan.zhihu.com/p/588826142">https://zhuanlan.zhihu.com/p/588826142</a> 进行学习;</p><p>官方文档 <a href="https://zh.cppreference.com/w/cpp/14">https://zh.cppreference.com/w/cpp/14</a></p></blockquote><h1 id="1-lambda新特性"><a href="#1-lambda新特性" class="headerlink" title="1.lambda新特性"></a>1.lambda新特性</h1><p>C++14给lambda表达式添加了两个新功能</p><ul><li>参数推断（auto）</li><li>参数初始化后捕获（可以在<code>[]</code>对某个新参数进行赋值）</li></ul><p>先来复习一下C++11中学习的lambda捕获的基本方式</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[val]：表示值传递方式捕捉变量val</span><br><span class="line">[=]：表示值传递方式捕获所有父作用域中的变量(包括this)</span><br><span class="line">[&amp;val]：表示引用传递捕捉变量val</span><br><span class="line">[&amp;]：表示引用传递捕捉所有父作用域中的变量(包括this)</span><br><span class="line">[this]：表示值传递方式捕捉当前的this指针</span><br></pre></td></tr></table></figure><p>在C++14中，新增的是下面的这种情况</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">30</span>;</span><br><span class="line"><span class="comment">// [] 中赋值了一个参数</span></span><br><span class="line"><span class="comment">// () 中可以使用auto关键字来推断参数类型</span></span><br><span class="line"><span class="keyword">auto</span> func = [x = <span class="number">3</span>](<span class="keyword">auto</span> y) &#123;<span class="keyword">return</span> x + y; &#125;;</span><br><span class="line">cout &lt;&lt; <span class="built_in">func</span>(a) &lt;&lt; endl;</span><br></pre></td></tr></table></figure><p>运行测试，可以看到成功输出了结果</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ make</span><br><span class="line">g++ test.cpp -o test -std=c++14</span><br><span class="line">$ ./test</span><br><span class="line">33</span><br></pre></td></tr></table></figure><p>修改一下类型，也能正常调用</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">double</span> a = <span class="number">30.2</span>;</span><br><span class="line"><span class="keyword">auto</span> func = [x = <span class="number">3</span>](<span class="keyword">auto</span> y)</span><br><span class="line">&#123; <span class="keyword">return</span> x + y; &#125;;</span><br><span class="line">cout &lt;&lt; <span class="built_in">func</span>(a) &lt;&lt; endl;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ ./test</span><br><span class="line">33.2</span><br></pre></td></tr></table></figure><p>如果想将赋值参数和原本的捕获方式一起使用，则需要将<strong>赋值参数</strong>放在<code>[]</code>的最<strong>后面</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">test_lambda2</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">10</span>, b = <span class="number">20</span>;</span><br><span class="line">    <span class="type">int</span> c = <span class="number">1</span>, d = <span class="number">3</span>, e = <span class="number">5</span>;</span><br><span class="line">    <span class="comment">// 赋值的参数要放在[]的最后面，捕获方式放在前面</span></span><br><span class="line">    <span class="keyword">auto</span> func6 = [=, f = <span class="number">30</span>, g = <span class="number">40</span>]</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">return</span> (a + b + c + d + e + f + g);</span><br><span class="line">    &#125;;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">func6</span>() &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ ./test</span><br><span class="line">109</span><br></pre></td></tr></table></figure><p>初始化捕获的好处是可以支持<strong>移动捕获</strong>了；不然在C++11中，lambda就只能使用赋值捕获和引用捕获</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::unique_ptr&lt;Item&gt; <span class="title">item</span><span class="params">(<span class="keyword">new</span> Item())</span></span>;</span><br><span class="line"><span class="comment">// std::move改为右值进行赋值后捕获</span></span><br><span class="line"><span class="keyword">auto</span> func = [m = std::<span class="built_in">move</span>(item)] &#123; <span class="comment">/* do something */</span> &#125;;</span><br></pre></td></tr></table></figure><p>这个新特性的提出，也让lambda成功有了和bind比拼的能力。在C++11中，bind的优势就是在于<strong>移动捕获</strong>的支持；如今lambda也有了这份能力了，我们可以更灵活地根据场景选用lambda或者bind，而不是只能使用bind了。</p><h1 id="2-变量模板"><a href="#2-变量模板" class="headerlink" title="2.变量模板"></a>2.变量模板</h1><h2 id="2-1-示例"><a href="#2-1-示例" class="headerlink" title="2.1 示例"></a>2.1 示例</h2><p>看清楚这个名字啊！是<strong>变量模板</strong>，可不是什么函数模板哈！</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line">T pi = <span class="built_in">T</span>(<span class="number">3.1415926535897932385L</span>); <span class="comment">// variable template</span></span><br><span class="line"><span class="comment">// 数字最后的L代表这是一个长浮点型</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test_value_template</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; pi&lt;<span class="type">double</span>&gt; &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; pi&lt;<span class="type">float</span>&gt; &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; pi&lt;<span class="type">int</span>&gt; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如上就是一个最最最简单的变量模板，我们在传入对应的类型后，他就会转成我们需要的类型</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ make</span><br><span class="line">g++ test.cpp -o test -std=c++14</span><br><span class="line">$ ./test</span><br><span class="line">3.14159</span><br><span class="line">3.14159</span><br><span class="line">3</span><br></pre></td></tr></table></figure><h2 id="2-2-类中使用"><a href="#2-2-类中使用" class="headerlink" title="2.2 类中使用"></a>2.2 类中使用</h2><p>当你需要在类中使用模板变量的时候，这个变量必须定义为<code>static</code>；</p><p>因为它是模板，我们还可以接用模板本身就有的特性，将这个模板针对某一个类型进行<strong>特化</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Limits</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">    <span class="type">static</span> <span class="type">const</span> T min; <span class="comment">// 声明静态成员模板</span></span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">const</span> T Limits::min = &#123; &#125;; <span class="comment">// 定义静态成员模板，全部使用默认值</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 下面三个是模板变量的特化</span></span><br><span class="line"><span class="keyword">template</span>&lt;&gt;</span><br><span class="line"><span class="type">const</span> <span class="type">float</span> Limits::min&lt;<span class="type">float</span>&gt; = <span class="number">4.5</span>;</span><br><span class="line"><span class="keyword">template</span>&lt;&gt;</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> Limits::min&lt;<span class="type">double</span>&gt; = <span class="number">5.5</span>;</span><br><span class="line"><span class="keyword">template</span>&lt;&gt;</span><br><span class="line"><span class="type">const</span> std::string Limits::min&lt;std::string&gt; = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::cout &lt;&lt; Limits::min&lt;<span class="type">int</span>&gt; &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; Limits::min&lt;<span class="type">float</span>&gt; &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; Limits::min&lt;<span class="type">double</span>&gt; &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; Limits::min&lt;std::string&gt; &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ ./test</span><br><span class="line">0</span><br><span class="line">4.5</span><br><span class="line">5.5</span><br><span class="line">hello</span><br></pre></td></tr></table></figure><h2 id="2-3-和类型转换的区别"><a href="#2-3-和类型转换的区别" class="headerlink" title="2.3 和类型转换的区别"></a>2.3 和类型转换的区别</h2><p>这里我又直接定义了一个变量，使用<code>static_cast</code>直接转换变量，看看结果会不会有什么区别</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 数字最后的L代表这是一个长浮点型</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line">T pi = <span class="built_in">T</span>(<span class="number">3.1415926535897932385L</span>); <span class="comment">// 变量模板</span></span><br><span class="line"></span><br><span class="line"><span class="type">long</span> <span class="type">double</span> lpi = <span class="number">3.1415926535897932385L</span>; <span class="comment">// 直接定义长浮点型</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test_value_template</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; pi&lt;<span class="type">double</span>&gt; &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; pi&lt;<span class="type">float</span>&gt; &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; pi&lt;<span class="type">int</span>&gt; &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot; ----- \n&quot;</span>;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="built_in">static_cast</span>&lt;<span class="type">double</span>&gt;(lpi) &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">static_cast</span>&lt;<span class="type">float</span>&gt;(lpi) &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">static_cast</span>&lt;<span class="type">int</span>&gt;(lpi) &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看上去二者的结果完全相同，那么既然可以直接使用变量类型转换，为什么还要新增一个模板变量呢？</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ ./test</span><br><span class="line">3.14159</span><br><span class="line">3.14159</span><br><span class="line">3</span><br><span class="line"> ----- </span><br><span class="line">3.14159</span><br><span class="line">3.14159</span><br><span class="line">3</span><br></pre></td></tr></table></figure><blockquote><p>以下内容来自GPT，我觉得它说的很对</p></blockquote><p>定义一个变量并使用数据转换（类型转换）是一种常见的编程方式，但与变量模板有一些区别：</p><ol><li><strong>通用性：</strong> 变量模板允许你通过模板参数来生成多个不同类型的变量，从而在不同的上下文中使用。这使得代码更具通用性和可扩展性，因为你可以为多个类型生成相应的变量。相比之下，直接定义变量并使用数据转换通常只适用于特定的一种数据类型。</li><li><strong>模板化：</strong> 变量模板是一种模板化的方式来生成变量，它遵循 C++ 的模板机制，这意味着你可以使用模板<strong>特化</strong>、部分特化等技术来定制化生成的变量，以满足不同的需求。而使用数据转换时，你必须显式地执行类型转换，这可能会在代码中引入不必要的重复。</li><li><strong>编译时计算：</strong> 变量模板通常用于在编译时生成值，因此可以在编译阶段进行类型检查和计算。这有助于提高代码的性能和安全性。而数据转换可能在运行时进行，可能会引入一些运行时开销和类型错误的风险。</li><li><strong>抽象性：</strong> 变量模板可以在更高的抽象层次上操作数据，使代码更具表达力和可读性。它允许你以更自然的方式描述某个值与特定类型之间的关系，而不必显式进行类型转换。</li></ol><p>总之，变量模板提供了一种更灵活、通用和模板化的方式来生成变量，适用于需要在不同类型上工作的情况。当你需要为多个类型生成特定的变量或值时，变量模板是一种更优雅和强大的选择。</p><h1 id="3-constexpr限制放宽"><a href="#3-constexpr限制放宽" class="headerlink" title="3.constexpr限制放宽"></a>3.constexpr限制放宽</h1><p>在C++11中被引入的constexpr，可以让编译器在编译程序的期间，就将一部分工作完成，不必等到运行期间再做；在C++11中，constexpr的限制很严格，这导致它并不好用：</p><ul><li>constexpr修饰变量，要求变量必须可以在编译器推导出来</li><li>constexpr修饰函数（返回值），函数内除了可以包含using和typedef指令以及<code>static_asssert</code>断言外，只能包含一条<code>return</code>语句</li><li>constexpr同时可以修饰构造函数，但也会要求使用这个构造函数的时候，可以在编译器就把相关的内容全推导出来</li></ul><p>以下是一个比较基础的C++11中的用例，给该函数设置了<code>constexpr</code>关键字后，该函数就可以在编译期间被计算出结果，再用<code>static_assert</code>在编译期间断言结果是否正确；</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">constexpr</span> <span class="type">int</span> <span class="title">factorial</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (n &lt;= <span class="number">1</span>) ? <span class="number">1</span> : n * <span class="built_in">factorial</span>(n - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">test_constexpr1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constexpr</span> <span class="type">int</span> result = <span class="built_in">factorial</span>(<span class="number">5</span>); <span class="comment">// 编译时计算阶乘</span></span><br><span class="line">    <span class="built_in">static_assert</span>(result == <span class="number">120</span>, <span class="string">&quot;Factorial of 5 should be 120&quot;</span>); <span class="comment">// 编译时断言</span></span><br><span class="line">    cout &lt;&lt; result &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果在C++11中的constexpr函数内包含其他语句，编译的时候会报错，翻译过来是该函数内部不是一个return返回语句</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ g++ test.cpp -o test -std=c++11</span><br><span class="line">test.cpp: In function ‘constexpr int FuncNew(int)’:</span><br><span class="line">test.cpp:96:1: error: body of ‘constexpr’ function ‘constexpr int FuncNew(int)’ not a return-statement</span><br><span class="line"> &#125;</span><br><span class="line"> ^</span><br></pre></td></tr></table></figure><p>c++14中，对constexpr的限制放宽了，允许使用<strong>循环、if、switch</strong>等等语句，但是主旨还是一样的，需要在编译期间就可以计算出全部内容；限制放宽之后，这个关键字便可以更灵活的使用了。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 计算前n项和，C++11</span></span><br><span class="line"><span class="function"><span class="keyword">constexpr</span> <span class="type">int</span> <span class="title">Func</span><span class="params">(<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> n &gt; <span class="number">0</span> ? <span class="built_in">Func</span>(n - <span class="number">1</span>) + n : <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 计算前N项和，C++14</span></span><br><span class="line"><span class="function"><span class="keyword">constexpr</span> <span class="type">int</span> <span class="title">FuncNew</span><span class="params">(<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n &lt;= <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        sum += i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="4-二进制变量"><a href="#4-二进制变量" class="headerlink" title="4.二进制变量"></a>4.二进制变量</h1><p>可以使用<code>0b</code>或者<code>0B</code>开头直接定义二进制变量。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;    </span><br><span class="line">    <span class="type">int</span> bit1 = <span class="number">0b1001</span>;</span><br><span class="line">    <span class="type">int</span> bit2 = <span class="number">0B</span>1011;</span><br><span class="line">    std::cout &lt;&lt; bit1 &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; bit2 &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ g++ test.cpp -o test -std=c++14</span><br><span class="line">$ ./test</span><br><span class="line">9 11</span><br></pre></td></tr></table></figure><p>我在测试中发现，当我用C++11编译此代码的时候，似乎也没有引发编译错误，难道说0b是在C++11里面就支持了吗？</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ g++ test.cpp -o test -std=c++11</span><br><span class="line">$ ./test</span><br><span class="line">9 11</span><br></pre></td></tr></table></figure><p>GPT给出了0B这种二进制变量是在C++14中引入的确认，并提到了为什么会出现上述情况；虽然C++11看上去编译和运行都没有问题，但我们还是得遵循版本，选用正确的版本进行编译，才能根本上避免错误</p><blockquote><p>C++标准通常是向后兼容的，这意味着较新版本的编译器通常会继续支持较旧版本的标准。例如，如果你在使用支持C++11标准的编译器（如g++）时，使用了C++14或更高版本的特性，通常不会引发编译错误，因为这些编译器会尽量向后兼容，以保持现有代码的可编译性。</p><p>在你提到的情况下，即使你使用g++编译器以C++11标准编译，它仍然可以理解和接受C++14引入的二进制字面量特性。这是编译器开发者的一种设计选择，以便使代码的迁移更加平滑。但是，为了遵循最佳实践和保持代码的可读性，当你在使用特定C++标准的功能时，最好将编译器选项设置为该标准的版本，以确保代码的可移植性。</p></blockquote><h1 id="5-数字分隔符"><a href="#5-数字分隔符" class="headerlink" title="5.数字分隔符"></a>5.数字分隔符</h1><p>在日常生活中使用数字的时候，为了更好的可读性，我们会以3个数组或者4个数组为分割，打一个点</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1,0000,0000 一亿</span><br><span class="line">100,000,000</span><br></pre></td></tr></table></figure><p>C++14中，也支持了这样的打点，以方便我们更好的看出大数字的位数</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">test_num_div</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> big_num1 = <span class="number">100000000</span>;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> big_num2 = <span class="number">100&#x27;000&#x27;000</span>;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> big_num3 = <span class="number">1&#x27;0000&#x27;0000</span>;</span><br><span class="line">    cout &lt;&lt; big_num1 &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; big_num2 &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; big_num3 &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>需要注意，这样的操作不会对数字本身有任何影响</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ ./test</span><br><span class="line">100000000</span><br><span class="line">100000000</span><br><span class="line">100000000</span><br></pre></td></tr></table></figure><p>在C++11中这种语法是不支持的</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">$ g++ test.cpp -o test -std=c++11</span><br><span class="line">test.cpp:116:29: warning: multi-character character constant [-Wmultichar]</span><br><span class="line">     long long big_num2 = 100&#x27;000&#x27;000;</span><br><span class="line">                             ^~~~~</span><br><span class="line">test.cpp:117:27: warning: multi-character character constant [-Wmultichar]</span><br><span class="line">     long long big_num3 = 1&#x27;0000&#x27;0000;</span><br><span class="line">                           ^~~~~~</span><br><span class="line">test.cpp: In function ‘void test_num_div()’:</span><br><span class="line">test.cpp:116:29: error: expected ‘,’ or ‘;’ before &#x27;\x303030&#x27;</span><br><span class="line">     long long big_num2 = 100&#x27;000&#x27;000;</span><br><span class="line">                             ^~~~~</span><br><span class="line">test.cpp:117:27: error: expected ‘,’ or ‘;’ before &#x27;\x30303030&#x27;</span><br><span class="line">     long long big_num3 = 1&#x27;0000&#x27;0000;</span><br><span class="line">                           ^~~~~~</span><br></pre></td></tr></table></figure><h1 id="6-返回值auto推导"><a href="#6-返回值auto推导" class="headerlink" title="6.返回值auto推导"></a>6.返回值auto推导</h1><p>c++14新增了函数返回值的推导，当返回值声明为auto时，编译器会根据你的return语句推导出你的返回值类型。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">Func</span><span class="params">(T x, T y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="built_in">Func</span>(<span class="number">3</span>, <span class="number">4</span>) &lt;&lt; std::endl; <span class="comment">// 返回值推导为int</span></span><br><span class="line">    std::cout &lt;&lt; <span class="built_in">Func</span>(<span class="number">3.1</span>, <span class="number">4.2</span>) &lt;&lt; std::endl; <span class="comment">// 返回值推导为double</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ make</span><br><span class="line">g++ test.cpp -o test -std=c++14</span><br><span class="line">$ ./test</span><br><span class="line">7</span><br><span class="line">7.3</span><br></pre></td></tr></table></figure><p>这个推导是有限制条件的</p><p>1、如果有多个推导语句，那么多个推导的结果必须一致</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 编译报错，第一个return推导为int，第二个return推导为double，两次推导结果不一致</span></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">Func</span><span class="params">(<span class="type">int</span> flag)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (flag &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">3.14</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2、如果没有return或者return为void类型，那么auto会被推导为void。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">f</span><span class="params">()</span> </span>&#123;&#125;              <span class="comment">// returns void</span></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">g</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="built_in">f</span>(); &#125; <span class="comment">// returns void</span></span><br><span class="line"><span class="function"><span class="keyword">auto</span>* <span class="title">x</span><span class="params">()</span> </span>&#123;&#125;             <span class="comment">// error: cannot deduce auto* from void</span></span><br></pre></td></tr></table></figure><p>3、一旦在函数中看到return语句，从该语句推导出的返回类型就可以在函数的其余部分中使用，包括在其他return语句中。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">Sum</span><span class="params">(<span class="type">int</span> i)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (i &lt;= <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> i; <span class="comment">// 返回值被推导为int</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Sum</span>(i - <span class="number">1</span>) + i; <span class="comment">// sum的返回值已经被推导出来了，所以这里是没有问题的</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是如果还没被推导出来，那就不能使用。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">Sum</span><span class="params">(<span class="type">int</span> i)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (i &gt; <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Sum</span>(i - <span class="number">1</span>) + i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 编译报错，因为Sum的返回值还没有被推导出来，所以还不能使用</span></span><br><span class="line">error: use of ‘<span class="function"><span class="keyword">auto</span> <span class="title">Sum</span><span class="params">(<span class="type">int</span>)</span>’ before deduction of ‘<span class="keyword">auto</span>’</span></span><br></pre></td></tr></table></figure><p>4、不能推导初始化列表。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">func</span> <span class="params">()</span> </span>&#123; <span class="keyword">return</span> &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;; &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 编译报错</span></span><br><span class="line">error: returning initializer list</span><br></pre></td></tr></table></figure><p>5、虚函数不能使用返回值推导</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Item</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">auto</span> <span class="title">Func</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 编译报错</span></span><br><span class="line">error: <span class="keyword">virtual</span> function cannot have deduced <span class="keyword">return</span> type</span><br></pre></td></tr></table></figure><h1 id="7-deprecated-标记"><a href="#7-deprecated-标记" class="headerlink" title="7.[[deprecated]]标记"></a>7.<code>[[deprecated]]</code>标记</h1><p>这个标记的作用是告知其他人，某个函数被弃用了，不允许继续调用该函数；该字段的好处在于，如果一个方法已经在后续不需要使用了，你可以先给他加上这个关键字，然后再进行其他的代码检查，确认无误后，再将这个函数整体清除；</p><p>别人也不需要去检查函数的实现，因为在编译过程中编译器就会告诉你这个函数被弃用；<strong>但是编译依旧是成功的</strong>！</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">[[deprecated]]</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">test_return_auto</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="built_in">Func</span>(<span class="number">3</span>, <span class="number">4</span>) &lt;&lt; std::endl; <span class="comment">// 返回值推导为int</span></span><br><span class="line">    std::cout &lt;&lt; <span class="built_in">Func</span>(<span class="number">3.1</span>, <span class="number">4.2</span>) &lt;&lt; std::endl; <span class="comment">// 返回值推导为double</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">test_return_auto</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在编译的时候，编译器会警告你，这个函数已经被弃用了；但这里只是警告，编译依旧成功了，所以最终还是需要程序猿去瞅一眼各个警告到底是什么意思。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">$ make</span><br><span class="line">g++ test.cpp -o test -std=c++14</span><br><span class="line">test.cpp: In function ‘int main()’:</span><br><span class="line">test.cpp:145:22: warning: ‘int test_return_auto()’ is deprecated [-Wdeprecated-declarations]</span><br><span class="line">     test_return_auto();</span><br><span class="line">                      ^</span><br><span class="line">test.cpp:132:5: note: declared here</span><br><span class="line"> int test_return_auto()</span><br><span class="line">     ^~~~~~~~~~~~~~~~</span><br><span class="line">test.cpp:145:22: warning: ‘int test_return_auto()’ is deprecated [-Wdeprecated-declarations]</span><br><span class="line">     test_return_auto();</span><br><span class="line">                      ^</span><br><span class="line">test.cpp:132:5: note: declared here</span><br><span class="line"> int test_return_auto()</span><br><span class="line">     ^~~~~~~~~~~~~~~~</span><br></pre></td></tr></table></figure><hr><h1 id="std库的新特性"><a href="#std库的新特性" class="headerlink" title="std库的新特性"></a>std库的新特性</h1><p>以下是STD库的新增内容！</p><h2 id="8-std-make-unique"><a href="#8-std-make-unique" class="headerlink" title="8.std::make_unique"></a>8.std::make_unique</h2><p>这个东西在cplusplus网站上找不到释义，所以就去<a href="https://zh.cppreference.com/">cpp的官网</a>上找了</p><blockquote><p><a href="https://zh.cppreference.com/w/cpp/memory/unique_ptr/make_unique">https://zh.cppreference.com/w/cpp/memory/unique_ptr/make_unique</a></p></blockquote><p>该函数定义在<code>&lt;memory&gt;</code>头文件中</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt; <span class="keyword">class</span> T, <span class="keyword">class</span>... Args &gt;</span></span><br><span class="line"><span class="function">unique_ptr&lt;T&gt; <span class="title">make_unique</span><span class="params">( Args&amp;&amp;... args )</span></span>;</span><br><span class="line"><span class="comment">//(1)(C++14 起) (仅对非数组类型)</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt; <span class="keyword">class</span> T &gt;</span></span><br><span class="line"><span class="function">unique_ptr&lt;T&gt; <span class="title">make_unique</span><span class="params">( std::<span class="type">size_t</span> size )</span></span>;</span><br><span class="line"><span class="comment">//(2)(C++14 起) (仅对未知边界数组)</span></span><br><span class="line"><span class="keyword">template</span>&lt; <span class="keyword">class</span> <span class="title class_">T</span>, <span class="keyword">class</span>... Args &gt;</span><br><span class="line"><span class="comment">/* unspecified */</span> <span class="built_in">make_unique</span>( Args&amp;&amp;... args ) = <span class="keyword">delete</span>;</span><br><span class="line"><span class="comment">//(3)(C++14 起) (仅对已知边界数组)</span></span><br></pre></td></tr></table></figure><p>作用是构造 <code>T</code> 类型对象并将其包装进 <a href="https://zh.cppreference.com/w/cpp/memory/unique_ptr">std::unique_ptr</a>；</p><table><thead><tr><th>参数</th><th>说明</th></tr></thead><tbody><tr><td>args</td><td>将要构造的 <code>T</code> 实例所用的参数列表。</td></tr><tr><td>size</td><td>要构造的数组大小</td></tr></tbody></table><ol><li>构造非数组类型 <code>T</code> 对象。传递参数 <code>args</code> 给 <code>T</code> 的构造函数。此重载只有在 <code>T</code> 不是数组类型时才会参与重载决议。函数等价于：</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">unique_ptr</span>&lt;T&gt;(<span class="keyword">new</span> <span class="built_in">T</span>(std::forward&lt;Args&gt;(args)...))</span><br></pre></td></tr></table></figure><ol start="2"><li>构造拥有动态大小的数组。<a href="https://zh.cppreference.com/w/cpp/language/value_initialization">值初始化</a>数组元素。此重载只有在 <code>T</code> 是未知边界数组时才会参与重载决议。函数等价于：</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">unique_ptr</span>&lt;T&gt;(<span class="keyword">new</span> std::<span class="type">remove_extent_t</span>&lt;T&gt;[size]())</span><br></pre></td></tr></table></figure><p>使用示例</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">test_class</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">test_class</span>(<span class="type">int</span> a=<span class="number">-1</span>):_a(a)&#123;&#125;</span><br><span class="line">    <span class="type">int</span> _a;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::unique_ptr&lt;test_class&gt; pt = std::<span class="built_in">make_unique</span>&lt;test_class&gt;(<span class="number">3</span>);</span><br><span class="line">    cout &lt;&lt; pt-&gt;_a &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ make</span><br><span class="line">g++ test.cpp -o test -std=c++14</span><br><span class="line">$ ./test</span><br><span class="line">3</span><br></pre></td></tr></table></figure><h2 id="9-std-shared-timed-mutex与std-shared-lock"><a href="#9-std-shared-timed-mutex与std-shared-lock" class="headerlink" title="9.std::shared_timed_mutex与std::shared_lock"></a>9.std::shared_timed_mutex与std::shared_lock</h2><p>c++11引入了多线程线程的一些库，但是是没有读写锁的，因此在c++14引入了读写锁的相关实现（头文件shared_mutex），其实c++14读写锁也还不够完善，直到c++17读写锁这块才算是完备起来。</p><p><code>std::shared_timed_mutex</code>是带超时的读写锁对象，接口还算比较简洁易懂，和之前接触过的其他锁基本一致；内部成员中<code>lock()</code>是写锁，<code>lock_shared()</code>是读锁;</p><p><a href="https://zh.cppreference.com/w/cpp/thread/shared_timed_mutex">https://zh.cppreference.com/w/cpp/thread/shared_timed_mutex</a></p><p><img src="https://img.musnow.top/i/2023/08/9c8a79016b52e8d7845bdee6a98fc151.png" alt="image-20230829082045636"></p><p><code>std::shared_lock</code>是加锁的RAII实现，即构造时加锁，析构时解锁；我们使用<code>shared_lock/unique_lock</code>来从<code>shared_timed_mutex</code>中获取锁的时候，就会自动获取读锁和写锁；</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">std::shared_timed_mutex mutex;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">readOperation</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 读锁是多人可以获取的，所以要用shared_lock (读锁)</span></span><br><span class="line">    <span class="function">std::shared_lock&lt;std::shared_timed_mutex&gt; <span class="title">lock</span><span class="params">(mutex)</span></span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Read operation: &quot;</span> &lt;&lt; sharedResource &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">writeOperation</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 写锁互斥获取，用unique_lock (写锁)</span></span><br><span class="line">    <span class="function">std::unique_lock&lt;std::shared_timed_mutex&gt; <span class="title">lock</span><span class="params">(mutex)</span></span>;</span><br><span class="line">    sharedResource++;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Write operation: &quot;</span> &lt;&lt; sharedResource &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="10-std-exchange"><a href="#10-std-exchange" class="headerlink" title="10.std::exchange"></a>10.std::exchange</h2><p>c++14新增了一个接口<code>std::exchange</code>（头文件utility），其实这个也并不算是新增的，因为这个接口其实在c++11的时候就有了，只不过在c++11中作为一个内部函数，不暴露给用户使用，在c++14中才把它暴露出来给用户使用。使用方法也很简单。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::string s1 = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">    std::string s2 = <span class="string">&quot;world&quot;</span>;</span><br><span class="line">    std::<span class="built_in">exchange</span>(s1, s2);</span><br><span class="line">    std::cout &lt;&lt; s1 &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; s2 &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出结果</span></span><br><span class="line">world world</span><br></pre></td></tr></table></figure><p>我们可以看到，exchange会把第二个值赋值给第一个值，但是不会改变第二个值。我们来看下它的实现吧。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// Assign @p __new_val to @p __obj and return its previous value.</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> _Tp, <span class="keyword">typename</span> _Up = _Tp&gt;</span><br><span class="line">  _GLIBCXX20_CONSTEXPR</span><br><span class="line">  <span class="keyword">inline</span> _Tp</span><br><span class="line">  </span><br><span class="line">  <span class="built_in">exchange</span>(_Tp&amp; __obj, _Up&amp;&amp; __new_val)</span><br><span class="line">  <span class="built_in">noexcept</span>(__and_&lt;is_nothrow_move_constructible&lt;_Tp&gt;,</span><br><span class="line">    is_nothrow_assignable&lt;_Tp&amp;, _Up&gt;&gt;::value)</span><br><span class="line">  &#123; <span class="keyword">return</span> std::__exchange(__obj, std::forward&lt;_Up&gt;(__new_val)); &#125;  </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// C++11 version of std::exchange for internal use.</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> _Tp, <span class="keyword">typename</span> _Up = _Tp&gt;</span><br><span class="line">  _GLIBCXX20_CONSTEXPR</span><br><span class="line">  <span class="keyword">inline</span> _Tp</span><br><span class="line">  __exchange(_Tp&amp; __obj, _Up&amp;&amp; __new_val)</span><br><span class="line">  &#123;</span><br><span class="line">    _Tp __old_val = std::<span class="built_in">move</span>(__obj);</span><br><span class="line">    __obj = std::forward&lt;_Up&gt;(__new_val);</span><br><span class="line">    <span class="keyword">return</span> __old_val;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>通过注释我们可以明白含义，它的作用是把第二个值赋值给第一个值，同时返回第一个值的旧值。</p><p>除此之外，我们这里说明一个关键的点。exchange的第二个参数是万能引用，所以说他是既可以接收左值，也可以接收右值的，所以我们可以这样来使用。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::string s1 = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">    <span class="comment">// 第二个值是纯右值</span></span><br><span class="line">    std::<span class="built_in">exchange</span>(s1, <span class="string">&quot;world&quot;</span>);</span><br><span class="line">    std::cout &lt;&lt; s1 &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    std::string s2 = <span class="string">&quot;hello world&quot;</span>;</span><br><span class="line">    <span class="comment">// 第二个值通过move语义转成右值</span></span><br><span class="line">    std::<span class="built_in">exchange</span>(s1, std::<span class="built_in">move</span>(s2));</span><br><span class="line">    std::cout &lt;&lt; s1 &lt;&lt; <span class="string">&quot; | &quot;</span> &lt;&lt; s2 &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出结果，注意这里s2为空字符串，因为s2的东西已经被移动拷贝给s1了</span></span><br><span class="line">world</span><br><span class="line">hello world | </span><br></pre></td></tr></table></figure><h2 id="11-std-integer-sequence"><a href="#11-std-integer-sequence" class="headerlink" title="11.std::integer_sequence"></a>11.std::integer_sequence</h2><p>类模板 <code>std::integer_sequence</code> 表示一个编译时的整数序列。在用作<a href="https://zh.cppreference.com/w/cpp/language/function_template">函数模板</a>的实参时，能推导<a href="https://zh.cppreference.com/w/cpp/language/parameter_pack">参数包</a> <code>Ints</code> 并将它用于包展开。</p><p><a href="https://zh.cppreference.com/w/cpp/utility/integer_sequence">https://zh.cppreference.com/w/cpp/utility/integer_sequence</a></p><p>这个实在是太难懂了，搞不明白是干嘛的，放弃了😥</p><h2 id="12-std-quoted"><a href="#12-std-quoted" class="headerlink" title="12.std::quoted"></a>12.std::quoted</h2><p><a href="https://zh.cppreference.com/w/cpp/io/manip/quoted">https://zh.cppreference.com/w/cpp/io/manip/quoted</a></p><p>该函数模板位于 <code>&lt;iomanip&gt;</code> 头文件中，用于在输入输出流中处理被引号包围的字符串。它通常用于处理 CSV（逗号分隔值）文件或其他格式，其中字段被引号括起来以处理包含特殊字符（如逗号、换行符等）的情况。</p><p>对于<code>cout</code>而言，quoted会将字符串包围在双引号中输出</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">test_quorted</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::string data = <span class="string">&quot;Hello, \&quot;world\&quot;\n&quot;</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 输出流中使用 std::quoted，会将字符串在&quot;内包围输出</span></span><br><span class="line">    std::cout &lt;&lt; std::<span class="built_in">quoted</span>(data) &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ ./test</span><br><span class="line">&quot;Hello, \&quot;world\&quot;</span><br><span class="line">&quot;</span><br></pre></td></tr></table></figure><p>以下是官方给的一个示例</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iomanip&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sstream&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::stringstream ss;</span><br><span class="line">    std::string in = <span class="string">&quot;String with spaces, and embedded \&quot;quotes\&quot; too&quot;</span>;</span><br><span class="line">    std::string out;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">auto</span> show = [&amp;](<span class="type">const</span> <span class="keyword">auto</span>&amp; what) &#123;</span><br><span class="line">        &amp;what == &amp;in</span><br><span class="line">            ?   std::cout &lt;&lt; <span class="string">&quot;read in     [&quot;</span> &lt;&lt; in &lt;&lt; <span class="string">&quot;]\n&quot;</span></span><br><span class="line">                          &lt;&lt; <span class="string">&quot;stored as   [&quot;</span> &lt;&lt; ss.<span class="built_in">str</span>() &lt;&lt; <span class="string">&quot;]\n&quot;</span></span><br><span class="line">            :   std::cout &lt;&lt; <span class="string">&quot;written out [&quot;</span> &lt;&lt; out &lt;&lt; <span class="string">&quot;]\n\n&quot;</span>;</span><br><span class="line">    &#125;;</span><br><span class="line"> </span><br><span class="line">    ss &lt;&lt; std::<span class="built_in">quoted</span>(in);</span><br><span class="line">    <span class="built_in">show</span>(in);</span><br><span class="line">    ss &gt;&gt; std::<span class="built_in">quoted</span>(out);</span><br><span class="line">    <span class="built_in">show</span>(out);</span><br><span class="line"> </span><br><span class="line">    ss.<span class="built_in">str</span>(<span class="string">&quot;&quot;</span>); <span class="comment">// clear the stream buffer</span></span><br><span class="line"> </span><br><span class="line">    in = <span class="string">&quot;String with spaces, and embedded $quotes$ too&quot;</span>;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> delim &#123;<span class="string">&#x27;$&#x27;</span>&#125;;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> escape &#123;<span class="string">&#x27;%&#x27;</span>&#125;;</span><br><span class="line"> </span><br><span class="line">    ss &lt;&lt; std::<span class="built_in">quoted</span>(in, delim, escape);</span><br><span class="line">    <span class="built_in">show</span>(in);</span><br><span class="line">    ss &gt;&gt; std::<span class="built_in">quoted</span>(out, delim, escape);</span><br><span class="line">    <span class="built_in">show</span>(out);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">read in     [String with spaces, and embedded &quot;quotes&quot; too]</span><br><span class="line">stored as   [&quot;String with spaces, and embedded \&quot;quotes\&quot; too&quot;]</span><br><span class="line">written out [String with spaces, and embedded &quot;quotes&quot; too]</span><br><span class="line"> </span><br><span class="line">read in     [String with spaces, and embedded $quotes$ too]</span><br><span class="line">stored as   [$String with spaces, and embedded %$quotes%$ too$]</span><br><span class="line">written out [String with spaces, and embedded $quotes$ too]</span><br></pre></td></tr></table></figure><p>在给定的代码中，<code>delim</code> 和 <code>escape</code> 是用于指定自定义的分隔符和转义字符的参数。这些参数是用于 <code>std::quoted</code> 函数的重载形式，允许你指定不同于默认引号的字符来包围字符串，并指定一个不同于默认转义字符的字符来转义引号字符。以下是关于这两个参数的详细解释：</p><ol><li><code>delim</code>: 分隔符 在第一个用法中，<code>std::quoted</code> 函数使用了三个参数的重载形式：<code>std::quoted(in, delim, escape)</code>。<code>delim</code> 参数用于指定包围字符串的分隔符。通常情况下，<code>std::quoted</code> 使用双引号作为默认分隔符，但在某些情况下，你可能想要使用其他字符来包围字符串，以避免与字符串本身的字符冲突。在你的代码示例中，分隔符 <code>delim</code> 被设置为 <code>$</code>，这意味着字符串会被包围在 <code>$</code> 字符内。</li><li><code>escape</code>: 转义字符 <code>escape</code> 参数允许你指定一个字符，用于转义分隔符字符本身。在默认情况下，<code>std::quoted</code> 使用双引号 <code>&quot;</code> 作为转义字符，以确保在字符串中嵌入的引号不会被解释为结束引号。但如果你选择了自定义的分隔符，你可能还需要指定一个不同于默认转义字符的字符来进行转义。在你的代码示例中，转义字符 <code>escape</code> 被设置为 <code>%</code>，这意味着在字符串中，如果你想要表示分隔符 <code>$</code> 本身，你需要使用 <code>%$</code>。</li></ol><p>这部分也不是很容易搞明白它是干嘛的，如果面试官问道了就说我不会吧😭</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;学习C++14的那些新特性&lt;/p&gt;</summary>
    
    
    
    <category term="遇见C++" scheme="https://blog.musnow.top/categories/%E9%81%87%E8%A7%81C/"/>
    
    
    <category term="C++" scheme="https://blog.musnow.top/tags/C/"/>
    
    <category term="数据结构" scheme="https://blog.musnow.top/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    <category term="C++14" scheme="https://blog.musnow.top/tags/C-14/"/>
    
  </entry>
  
  <entry>
    <title>【leetcode】1137. 第 N 个泰波那契数</title>
    <link href="https://blog.musnow.top/posts/563921472/"/>
    <id>https://blog.musnow.top/posts/563921472/</id>
    <published>2023-08-27T09:32:44.000Z</published>
    <updated>2023-08-27T09:32:44.000Z</updated>
    
    <content type="html"><![CDATA[<p>今天是学习动归的第一天，先来一道简单题练练手吧！</p><h1 id="1-题目"><a href="#1-题目" class="headerlink" title="1.题目"></a>1.题目</h1><blockquote><p>leetcode <a href="https://leetcode.cn/problems/n-th-tribonacci-number/">1137. 第 N 个泰波那契数</a></p></blockquote><p>泰波那契序列 Tn 定义如下： </p><p>T0 &#x3D; 0, T1 &#x3D; 1, T2 &#x3D; 1, 且在 n &gt;&#x3D; 0 的条件下 <code>Tn+3 = Tn + Tn+1 + Tn+2</code></p><p>给你整数 <code>n</code>，请返回第 n 个泰波那契数 Tn 的值。</p><p>需要注意的是，这里的不是我们常用的斐波那契数列，哪个是 <code>Tn = Tn-1 + Tn-2</code>，而这里是三个；</p><h1 id="2-动归解法"><a href="#2-动归解法" class="headerlink" title="2.动归解法"></a>2.动归解法</h1><p>动态递归的思路是需要找到一个递归方程，本题中的递归方程已经给出来了。但是需要注意的是，当n小于3的时候，这个递归方程是不可用的（因为我们没有办法计算T<sub>负数</sub>的值）</p><h2 id="2-1-解法1-递归"><a href="#2-1-解法1-递归" class="headerlink" title="2.1 解法1-递归"></a>2.1 解法1-递归</h2><p>如下是我的第一个解法，通过递归函数计算数值，并提前写入0、1、2这三个数值到数组里面。</p><p>如果数组里面有值，直接取出来，如果没有值，在计算了之后再赋值到数组里面。这样就能保证在整个递归流程中，相同下标处的数据只会被计算一次（不这么做会超时）</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> DEF -1 <span class="comment">//默认值</span></span></span><br><span class="line">    <span class="comment">// 直接用递归会超时</span></span><br><span class="line">    <span class="comment">// 想法是将数据存到vector里面，避免针对某一个数的二次递归运算</span></span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> <span class="title function_">fib</span><span class="params">(<span class="type">int</span> n,<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;&amp; _map)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(_map[n] != DEF)&#123;</span><br><span class="line">            <span class="keyword">return</span> _map[n];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> ans = fib(n<span class="number">-1</span>,_map) + fib(n<span class="number">-2</span>,_map)+fib(n<span class="number">-3</span>,_map);</span><br><span class="line">        _map[n] = ans;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="title function_">tribonacci</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt; _map(<span class="number">40</span>,DEF);</span><br><span class="line">        _map[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        _map[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">        _map[<span class="number">2</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 初始化并传引用给递归函数</span></span><br><span class="line">        <span class="keyword">return</span> fib(n,_map);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>使用该方法的通过率如图</p><p><img src="https://img.musnow.top/i/2023/08/6da34c2bc594bf2893b2b0edaee08c21.png" alt="image-20230827172927657"></p><h2 id="2-2-方法2-迭代"><a href="#2-2-方法2-迭代" class="headerlink" title="2.2 方法2-迭代"></a>2.2 方法2-迭代</h2><p>还是相同的思路，只不过这次我们不用递归，而是用迭代来计算出数组里面对应下标的值，最后再返回给用户</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">tribonacci</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(n&lt;=<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> n;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt; _map(n+<span class="number">1</span>,DEF);</span><br><span class="line">    _map[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    _map[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    _map[<span class="number">2</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">3</span>;i&lt;_map.size();i++)&#123;</span><br><span class="line">        _map[i] = _map[i<span class="number">-3</span>] +_map[i<span class="number">-2</span>]+_map[i<span class="number">-1</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> _map[n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该办法的通过率如图，时间复杂度和空间复杂度都是<code>O(N)</code></p><p><img src="https://img.musnow.top/i/2023/08/eddf5511ea8346939633d018000e406f.png" alt="image-20230827173201195"></p><h2 id="2-3-迭代-变量"><a href="#2-3-迭代-变量" class="headerlink" title="2.3 迭代+变量"></a>2.3 迭代+变量</h2><p>既然在计算的时候我们只需要用到当前数据和该数据之前的3个变量，所以我们完全可以用固定的几个变量来实现这个操作，每次计算之后，都对变量进行一次轮换就ok了，官方的题解就是这么操作的</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">tribonacci</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (n &lt;= <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> p = <span class="number">0</span>, q = <span class="number">0</span>, r = <span class="number">1</span>, s = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">3</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        p = q;</span><br><span class="line">        q = r;</span><br><span class="line">        r = s;</span><br><span class="line">        s = p + q + r;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样操作，时间复杂度还是O(N)，但是空间复杂度就降到O(1)了！</p><p><img src="https://img.musnow.top/i/2023/08/0681a6444a756d58fe395a2202b0ce18.png" alt="image-20230827173339364"></p><h1 id="3-矩阵计算"><a href="#3-矩阵计算" class="headerlink" title="3.矩阵计算"></a>3.矩阵计算</h1><p>如果不用递归，还可以用矩阵乘法运算，该方法的时间复杂度是<code>O(LogN)</code></p><p><a href="https://leetcode.cn/problems/n-th-tribonacci-number/solutions/921898/di-n-ge-tai-bo-na-qi-shu-by-leetcode-sol-kn16/">https://leetcode.cn/problems/n-th-tribonacci-number/solutions/921898/di-n-ge-tai-bo-na-qi-shu-by-leetcode-sol-kn16/</a></p><p><img src="https://img.musnow.top/i/2023/08/a0431301252e331d1d2e9ac952358063.png" alt="image-20230827173653674"></p><p>奈何本人线代知识忘记了，完全看不懂</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">public:</span><br><span class="line">    <span class="type">int</span> <span class="title function_">tribonacci</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (n &lt;= <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="type">long</span>&gt;&gt; q = &#123;&#123;<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>&#125;, &#123;<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>&#125;, &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>&#125;&#125;;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="type">long</span>&gt;&gt; res = <span class="built_in">pow</span>(q, n);</span><br><span class="line">        <span class="keyword">return</span> res[<span class="number">0</span>][<span class="number">2</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="type">long</span>&gt;&gt; <span class="built_in">pow</span>(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="type">long</span>&gt;&gt;&amp; a, <span class="type">long</span> n) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="type">long</span>&gt;&gt; ret = &#123;&#123;<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>&#125;, &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>&#125;&#125;;</span><br><span class="line">        <span class="keyword">while</span> (n &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((n &amp; <span class="number">1</span>) == <span class="number">1</span>) &#123;</span><br><span class="line">                ret = multiply(ret, a);</span><br><span class="line">            &#125;</span><br><span class="line">            n &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">            a = multiply(a, a);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="type">long</span>&gt;&gt; multiply(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="type">long</span>&gt;&gt;&amp; a, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="type">long</span>&gt;&gt;&amp; b) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="type">long</span>&gt;&gt; c(<span class="number">3</span>, <span class="built_in">vector</span>&lt;<span class="type">long</span>&gt;(<span class="number">3</span>));</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">3</span>; j++) &#123;</span><br><span class="line">                c[i][j] = a[i][<span class="number">0</span>] * b[<span class="number">0</span>][j] + a[i][<span class="number">1</span>] * b[<span class="number">1</span>][j] + a[i][<span class="number">2</span>] * b[<span class="number">2</span>][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> c;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>测了一下效果，好像效率和使用2.3的办法没啥区别，那我还是用动归吧😭</p><p><img src="https://img.musnow.top/i/2023/08/858eede4f1ef9c10b2eb69f2150eae9d.png" alt="image-20230827173941225"></p><p>以后有时间了再来纠结这个答案的思路</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;今天是学习动归的第一天，先来一道简单题练练手吧！&lt;/p&gt;
&lt;h1 id=&quot;1-题目&quot;&gt;&lt;a href=&quot;#1-题目&quot; class=&quot;headerlink&quot; title=&quot;1.题目&quot;&gt;&lt;/a&gt;1.题目&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;leetcode &lt;a href=</summary>
      
    
    
    
    <category term="把题目都给刷干净" scheme="https://blog.musnow.top/categories/%E6%8A%8A%E9%A2%98%E7%9B%AE%E9%83%BD%E7%BB%99%E5%88%B7%E5%B9%B2%E5%87%80/"/>
    
    
    <category term="C++" scheme="https://blog.musnow.top/tags/C/"/>
    
    <category term="OJ刷题" scheme="https://blog.musnow.top/tags/OJ%E5%88%B7%E9%A2%98/"/>
    
    <category term="leetcode" scheme="https://blog.musnow.top/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>【技术】CDN/PCDN/SDN详解</title>
    <link href="https://blog.musnow.top/posts/292924834/"/>
    <id>https://blog.musnow.top/posts/292924834/</id>
    <published>2023-08-27T02:49:28.000Z</published>
    <updated>2023-08-27T02:49:28.000Z</updated>
    
    <content type="html"><![CDATA[<p>朴实的学习原因：京东实习生招聘条目上写了这些技术，那就给他学了！</p><span id="more"></span><blockquote><p>参考<br><a href="https://blog.csdn.net/baidu_41651554/article/details/122218513">https://blog.csdn.net/baidu_41651554/article/details/122218513</a></p></blockquote><p>嗨嗨嗨，直接上菜！</p><h1 id="1-CDN"><a href="#1-CDN" class="headerlink" title="1.CDN"></a>1.CDN</h1><p>CDN的全程是content delivery network，内容分发网络；说人话就是把网站产生的内容分发到各个用户请求的网络里去，具有 <strong>分布式</strong> 网络的特点！</p><h2 id="1-1-前置声明"><a href="#1-1-前置声明" class="headerlink" title="1.1 前置声明"></a>1.1 前置声明</h2><p>当代网络形势错综复杂，特别是视频、音频类网络服务的兴起，给互联网的贷款造成了很大的压力啊！</p><p>以之前很火的“延禧攻略”为例，当时曾经在某视频APP实现了1千万用户同时在线观看。如果大家观看的是1080p清晰度的视频（理论上需要4Mbps带宽），那么，累计需要的流量带宽是<br>$$<br>10,000,000×4Mbps&#x3D;40,000,000Mbps&#x3D;40Tbps<br>$$<br>这个数字老恐怖了！对于优酷、爱奇艺这样的互联网视频内容提供商来说，这无疑是非常巨大的流量压力。</p><p>如果按服务器用的10Gbps的万兆网卡来算，那也需要四千块万兆网卡才能顶得住这么大的流量消耗，更别提压根没有那么多地方给你插这么多网卡的事情了；</p><p>有这么一个说法：当用户打开一个页面，等待超过4秒，他就会关闭这个页面。也就是说，这个用户就会流失。用户流失对于公司来说可就是金钱流失！</p><p>所以，没有任何一家互联网服务提供商原因因为网络的问题而流失客户，那么我们就得像个办法来解决这种流量短时间暴发的问题！</p><p>而CDN，就是一项非常有效的<strong>缩短时延</strong>的技术。</p><h2 id="1-2-技术主体"><a href="#1-2-技术主体" class="headerlink" title="1.2 技术主体"></a>1.2 技术主体</h2><p>CDN缩短用户延时的办法也非常“简单”，其实就是将云服务部署到用户身边。在访问的时候，根据DNS的多线解析能力（即为不同地区提供不同的IP解析）选择离用户最近的服务器来为用户提供服务。</p><p><img src="https://img.musnow.top/i/2023/08/1298b6b472d89a0007ac82fb213b1aeb.png" alt="image-20230827105913951"></p><p>因为这样，CDN就在内容层面上进行了一定的筛选和分发，所以他就叫内容分发网络；</p><p>具体来说，CDN就是采用更多的缓存服务器（CDN边缘节点），布放在用户访问相对集中的地区或网络中。当用户访问网站时，利用全局负载技术，将用户的访问指向距离最近的缓存服务器上，由缓存服务器响应用户请求。（有点像电商的本地仓）</p><p>大家可能觉得，这个不就是“镜像服务器”嘛？其实不一样。镜像服务器是源内容服务器的完整复制。而CDN，是部分内容的缓存，智能程度更高。</p><p>确切地说，<strong>CDN&#x3D;更智能的镜像+缓存+流量导流</strong></p><p>而且还需要注意的是，CDN并不是只能缓存视频内容，它还可以对网站的静态资源（例如各类型图片、html、css、js等）进行分发，对移动应用APP的静态内容（例如安装包apk文件、APP内的图片视频等）进行分发。</p><p>CDN的具体工作流程。举个例子，如果某个用户想要访问优酷的视频点播内容，那么：</p><p><img src="https://img.musnow.top/i/2023/08/8ad3d099d1138c6b02472adeb5a2097c.png" alt="img"></p><p>具体步骤如下</p><ol><li>当用户点击对应资源内容，应用根据域名地址到底层触发DNS请求；</li><li>先是请求的本地运营商的DNS，再转发到CDN域名服务的DNS；</li><li>CDN域名服务的DNS会将CDN的<strong>全局均衡负载服务器</strong>的IP地址返回给用户；</li><li>用户向CDN的负载均衡设备发起URL的访问请求；</li><li>CDN的负载均衡设备根据用户IP地址，以及用户请求的内容URL，选择一台用户所属区域（离用户越近越好）的<strong>缓存服务器</strong>；</li><li>负载均衡设备告诉用户这台缓存服务器的IP地址，让用户向所选择的缓存服务器发起请求；</li><li>用户向缓存服务器发起请求，缓存服务器响应，将用户请求内容发送给用户</li><li>如果这台服务器上没有用户想要的内容，那就根据CDN设置的<strong>回源服务器</strong>（又称源站）来请求该URL</li><li>缓存服务器从<strong>源站</strong>拉取内容缓存到本地，并传输给用户；并根据用户设置的缓存策略来判断是否需要保留该资源到本地，是则进行缓存。</li></ol><p>在CDN工作的整个流程中，源站的服务器IP是对用户不可见的；CDN服务在实现了一定的资源访问加速的基础上，还附带了隐藏源站IP的功能，避免源站直接遭受火力打击（指服务器被攻击）</p><h2 id="1-3-静态加速"><a href="#1-3-静态加速" class="headerlink" title="1.3 静态加速"></a>1.3 静态加速</h2><p>所谓静态加速，是只加速源站所提供服务中的静态资源，包括js、html、css、图片、音视频等不会出现变动的资源文件。将这些资源在CDN云服务器内进行缓存，用户访问静态资源的时候从CDN传输给用户，访问asp、php、jsp等动态资源的时候，从源站抓取，既保证了数据的及时性，又提高了静态资源的加载速度。</p><p>相比于动态资源文件，静态资源，特别是图片，是访问过程中消耗流量较大的部分；使用静态资源加速能大大减轻源站的网络贷款和资源负载的压力，又减少了用户的加载速度，使得网络服务能更快的展现在用户面前；</p><h2 id="1-4-动态加速"><a href="#1-4-动态加速" class="headerlink" title="1.4 动态加速"></a>1.4 动态加速</h2><p>动态加速是指CDN的DNS解析中通过动态链路探测，监控网络环境的变化，监控各地网络延迟，寻找到一条最<strong>稳定、最高效、最快速</strong>的路径，回源动态资源，从而实现动态资源（如asp、php、jsp等）加速。然后构成链路列表，绑定到DNS解析上，更新到CDN的本地域名服务器上。简单架构见下图所示。</p><p><img src="https://img.musnow.top/i/2023/08/9b51e87fe04bacbd8591b55e5d62f679.png" alt="img"></p><h2 id="1-5-数据节点的更新和同步"><a href="#1-5-数据节点的更新和同步" class="headerlink" title="1.5 数据节点的更新和同步"></a>1.5 数据节点的更新和同步</h2><p>cdn分为推拉两种方式</p><ul><li>推是服务器将内容推到cdn节点上</li><li>拉是cdn在第一次接受请求的时候从服务器拉取资源进行响应并保存</li></ul><p>当资源在cdn缓存之后，如果服务器上的资源发生变化，cdn节点是不会知道的，除非缓存时间到期重新拉取或者修改新资源的访问。</p><p>动态资源的话，一般都是无延迟的。静态对于 css 和 js 来说，建议在编译生成的阶段，为文件名加上时间戳。而且最好是在文件名里面，而不是 querystring 里面加。这是最方便的方案，因为一旦发生了更新，每次去取的一定是新文件，不涉及缓存刷新的问题。</p><h2 id="1-6-CDN的好处"><a href="#1-6-CDN的好处" class="headerlink" title="1.6 CDN的好处"></a>1.6 CDN的好处</h2><h3 id="1-6-1-对服务商"><a href="#1-6-1-对服务商" class="headerlink" title="1.6.1 对服务商"></a>1.6.1 对服务商</h3><p>采用CDN技术，最大的好处，就是加速了网站的访问——用户与内容之间的物理距离缩短，用户的等待时间也得以缩短。</p><p>而且，分发至不同线路的缓存服务器，也让<strong>跨运营商</strong>之间的访问得以加速。例如中国移动手机用户访问中国电信网络的内容源，可以通过在中国移动假设CDN服务器，进行加速。效果是非常明显的。</p><p>此外，CDN还有安全方面的好处。内容进行分发后，<strong>源服务器的IP被隐藏</strong>，受到攻击的概率会大幅下降。而且，当某个服务器故障时，系统会调用临近的健康服务器，进行服务，避免对用户造成影响。</p><p>正因为CDN的好处很多，所以，目前所有主流的互联网服务提供商，都采用了CDN技术。所有的云服务提供商，也都提供了CDN服务（价格，按流量计费）</p><h3 id="1-6-2-对通信行业"><a href="#1-6-2-对通信行业" class="headerlink" title="1.6.2 对通信行业"></a>1.6.2 对通信行业</h3><ul><li><strong>互联网服务提供商</strong>采用CDN，是以存储换时延。花钱购置CDN服务器或云计算服务，以此换取更好的用户体验。</li><li><strong>通信运营商</strong>也追捧CDN，但它们的目的，是以存储换带宽 ——通过服务“下沉”，减轻上层骨干网络的流量压力，避免硬件扩容，降低网络建设成本。</li></ul><p>以上文提到的爱奇艺看视频的高带宽问题为例，如果不采用CDN，那就是巨大的流量流入同一个机房，这会导致这个机房入网&#x2F;出网的线路被拥塞，影响其他业务的进行！</p><p>同样的，如果大量的业务流量数据在骨干网跑来跑去，<strong>骨干网肯定吃不消，要拼命扩容</strong>。如果这些业务流量数据在底层就被解决了，那么，骨干网的带宽压力自然就减轻了。</p><p>很多运营商已经将CDN下沉到地市级，以此减轻压力，同时可以提升用户体验！可谓是一举两得的美事！</p><p><img src="https://img.musnow.top/i/2023/08/9806e61f7d240e45b2701d25668935e7.png" alt="img"></p><h1 id="2-PCDN"><a href="#2-PCDN" class="headerlink" title="2.PCDN"></a>2.PCDN</h1><p>PCDN技术是P2P技术+CDN技术的集和，在认识PCDN之前，我们首先要简单了解一下P2P技术</p><h2 id="2-1-P2P"><a href="#2-1-P2P" class="headerlink" title="2.1 P2P"></a>2.1 P2P</h2><p>P2P即<code>Peer to Peer</code>，是一种对等连接方式，纯P2P架构包含如下内容</p><ul><li>没有总是在线的服务器</li><li>任意端之间直接通信</li><li>对等方之间可以间断链接，并可以动态改变IP地址</li></ul><p>实际的用例如下</p><ul><li>文件分发（BT下载）</li><li>流媒体</li><li>VolP</li><li>内网穿透式访问（建立P2P链接，直接和内网主机通信）</li></ul><p><img src="https://img.musnow.top/i/2023/08/ebc51e20db9f5b31b0067fead78826ae.png" alt="image"></p><p>关于P2P想了解更多信息可以查看此文：<a href="https://cloud.tencent.com/developer/article/2095486">详解P2P技术</a></p><h2 id="2-2-PCDN"><a href="#2-2-PCDN" class="headerlink" title="2.2 PCDN"></a>2.2 PCDN</h2><h3 id="2-2-1-流程"><a href="#2-2-1-流程" class="headerlink" title="2.2.1 流程"></a>2.2.1 流程</h3><p>前面提到了，PCDN是P2P+CDN，那么其是如何将P2P技术和CDN结合起来的呢？</p><p>在阿里云官网上可以看到对PCDN的介绍：<a href="https://developer.aliyun.com/article/130907">一篇文章解读提速、降费黑科技：PCDN定义、功能、架构、场景和优势</a>；本文是对这篇文章的个人理解。</p><blockquote><p>PCDN产品是与传统CDN互补协作的关系，以P2P技术为核心的分布式PCDN系统可与传统CDN、云CDN无缝集成，形成互补协作，相对于CDN拥有成本更低、质量更好两方面的核心优势。</p></blockquote><p>P2P 内容分发网络（英文名：P2P CDN，以下简称PCDN）是以P2P技术为基础，通过挖掘利用边缘网络海量碎片化闲置资源而构建的低成本高品质内容分发网络服务。你可以通过集成PCDN SDK（以下简称SDK）接入该服务后能获得等同（或略高于）CDN的分发质量，同时显著降低分发成本。适用于<strong>视频点播、直播、大文件下载</strong>等业务场景。</p><p>使用PCDN后的http请求处理流程如下图：</p><p><img src="https://img.musnow.top/i/2023/08/d2bba1440e3c9b80ec949459fd8617a8.png" alt="image-20230827133437729"></p><p>P2P的加入，就是将一些数据<strong>预先留存在部分终端设备</strong>（比如家用路由器，个人电脑，个人NAS）等产品上，再通过P2P技术，从这些Peer做种端获取到一部分数据，以此为周边用户提供服务。</p><p>使用PCDN的SDK后，在请求DNS之后，还会去请求<strong>PCDN的调度系统</strong>，PCDN同时会返回可用的CDN服务器，和可用的P2P做种端，用户能同时从<strong>多端</strong>获取到数据（根据文件分块，从不同地方获取同一文件不同分块的数据，提高文件下载速度）</p><p>比如一个文件有1MB，那么使用PCDN，我们可能服务商的从<strong>CDN服务器</strong>拉取了500KB，再从上图中所示的两个peerid端获取到了500KB数据；</p><p>因为p2p使用的是个人的peer终端节点，不仅数量多，<strong>且分布比CDN服务器更广</strong>，理论上来说至少能获得<strong>等同于</strong>仅使用CDN技术的速度优势，如果用户可以连接到的peer较多，则速度就会<strong>大于</strong>仅使用CDN技术！</p><p>而这些作为peer的做种端，会定期从CDN缓存一部分热门数据到本地，并为其他与自己建立P2P链接的终端提供服务。</p><blockquote><p>京东云路由器、迅雷的网心云、百度云盘PC客户端的闲时带宽上传，其实都是使用了PCDN技术的终端产品，其会在占用一小部分用户带宽的基础上，给用户提供京豆&#x2F;现金奖励；<br>但是PCDN似乎和运营商的政策冲突，具体的就不了解了，本文只是来学习技术的。</p></blockquote><h3 id="2-2-2-优点"><a href="#2-2-2-优点" class="headerlink" title="2.2.2 优点"></a>2.2.2 优点</h3><p>以下优点来自阿里云那篇文章</p><ul><li><p>价格低：通过P2P技术可为客户提供更低成本的内容分发服务，（以峰值带宽计价）为云CDN价格的1&#x2F;2，为传统CDN价格的1&#x2F;4，可显著降低客户的分发成本；</p><p>因为使用了更多P2P节点，减轻了CDN服务器、源站服务器的网络带宽压力，所以PCDN能在一定程度上起到降本增效的作用。</p></li><li><p>质量好：通过CDN+P2P多级节点调度，一个请求可由CDN和多个P2P源同时提供内容，通过资源冗余提高了服务可用性，播放流畅率高于纯CDN，在大文件下载场景中更是能极大提高下载速度；通过调用海量分布式P2P节点， 平均播放流畅率 &gt; 97%，平均首播时间小于1秒，用户体验得到有效提升。</p></li><li><p>成熟稳定：多年为优酷土豆提供优质的视频播放、下载等加速服务，接入带宽超10T，经历了海量用户规模的<strong>长时间验证</strong>。拥有内网穿透、缓存处理、种子管理、传输策略等各方面的核心技术和专利；（这是阿里云给自己打的广告）</p></li></ul><p><img src="https://img.musnow.top/i/2023/08/16fb75b6c4dae42f968da0e5510cd069.png" alt="image-20230827135320425"></p><h2 id="2-3-常见名词"><a href="#2-3-常见名词" class="headerlink" title="2.3 常见名词"></a>2.3 常见名词</h2><p>以下是PCDN中常见的名词；这里面漏了的一级节点指的应该是CDN服务器；</p><p><img src="https://img.musnow.top/i/2023/08/121f5a17dd247d2ba0cd17676bf53139.png" alt="image-20230827134515066"></p><p>由此可见，上文提到的京东云路由器、迅雷的网心云，这些客户端在用户的电脑启动后，其就是作为PCDN的<strong>三级节点</strong>接入整个PCDN的网络的，其提供的也是三级带宽；</p><h2 id="2-4-基础架构"><a href="#2-4-基础架构" class="headerlink" title="2.4 基础架构"></a>2.4 基础架构</h2><p>关键组件</p><ul><li>index服务：全局调度，把用户请求调度到最佳的机房</li><li>ZooKeeper (Global&amp;Local)：服务活动情况汇报给调度服务，动态配置更新</li><li>Nignx Proxy：支持私有协议的Nginx代理服务，针对不同文件一致性Hash到不同的Channel服务</li><li>Channel服务：记录文件和拥有文件的端点地址信息，为下载提供就近的端点地址</li><li>Realy服务：服务P2P建立连接和通讯</li><li>Hot服务：hot文件发现和推送</li></ul><p>以下是PCDN技术的架构图</p><p><img src="https://img.musnow.top/i/2023/08/459dd3bd580e337a248093066360ca91.png" alt="image-20230827135429913"></p><p>整个技术的流程在上文已经讲解过了。这里的架构图阿里云的文章并没有提供更多的说明，具体的就得在真正需要开发PCDN的时候在公司内部深入学习了。</p><h2 id="2-5-适用范围"><a href="#2-5-适用范围" class="headerlink" title="2.5 适用范围"></a>2.5 适用范围</h2><p>PCDN产品适用于视频点播、直播、大文件下载等业务领域。</p><ul><li>视频点播：长视频点播，热度集中的短视频点播。</li><li>视频直播：大型晚会赛事直播、地方网台直播、秀场互动直播。</li><li>大文件下载：超过1MB且热度集中的的文件分发，如应用市场分发、在线音频分发。</li></ul><h1 id="3-SDN"><a href="#3-SDN" class="headerlink" title="3.SDN"></a>3.SDN</h1><p>SDN全称<code>Software Defined Network</code>，概念最早由斯坦福大学的<code>Nick McKeown</code>教授于2009年提出；谷歌于2010到2012年建立的数据中心网络B4是SDN的成功案例；</p><p>该技术学习于b站<a href="https://www.bilibili.com/video/BV15L411E7eE/?share_source=copy_web&vd_source=7fc715db968d24a91828ac8fad0e1ad8">【408 计算机网络新增考点—软件定义网络SDN（字幕版）】</a></p><h2 id="3-1-看看路由器的功能"><a href="#3-1-看看路由器的功能" class="headerlink" title="3.1 看看路由器的功能"></a>3.1 看看路由器的功能</h2><p>路由器具备如下功能</p><ul><li>报文转发</li><li>路由选择</li></ul><p>在当前的路由器架构中，分为数据层面和控制层面。</p><ul><li>为了构建出自己的路由表，路由器必须要和周边的其他路由器定期通信，才能通过自己的路由算法设置出路由表，并选择正确的路由路径（这个耗时较长）</li><li>在数据层面，路由器采用硬件，查表进行转发（耗时低）</li></ul><p><img src="https://img.musnow.top/i/2023/08/f7ec770dd37e6f4a19c73cd9133cdf90.png" alt="image-20230827143545493"></p><blockquote><p><strong>分组</strong>是网络专有名词。大多数<a href="https://baike.baidu.com/item/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/18763?fromModule=lemma_inlink">计算机网络</a>都不能连续地传送任意长的数据，所以实际上网络系统把<a href="https://baike.baidu.com/item/%E6%95%B0%E6%8D%AE%E5%88%86%E5%89%B2/4395664?fromModule=lemma_inlink">数据分割</a>成小块，然后逐块地发送，这种小块就称作分组（packet）。也有些书籍把分组定义为网络层的<a href="https://baike.baidu.com/item/%E5%8D%8F%E8%AE%AE%E6%95%B0%E6%8D%AE%E5%8D%95%E5%85%83/8226389?fromModule=lemma_inlink">协议数据单元</a>。</p><p>说白了分组就是一个报文！</p></blockquote><h2 id="3-2-SDN核心思想"><a href="#3-2-SDN核心思想" class="headerlink" title="3.2 SDN核心思想"></a>3.2 SDN核心思想</h2><blockquote><p>SDN这种新型<strong>网络体系结构</strong>的核心思想，是将网络的控制层和数据层面玻璃，让控制层可以通过软件来控制数据层的较多设备</p></blockquote><p>在SDN体系中，路由器的路由软件被剥离开，路由器之间也不再需要交换路由信息。</p><ul><li>控制层面：有一个逻辑上集中的远程控制器，对多个交换机进行控制；该远程控制器可以由多台物理主机组成</li></ul><p>远程控制器会掌握各个主机和整个网络体系的状态，并为每一个路由分组计算出最佳的路由，和生成正确的转发表；这时候，底层的路由器硬件就仅仅需要进行查表转发，而不需要进行耗时的路由表生产和算法计算了，大大减轻了底层交换机和路由器硬件的压力。</p><p><img src="https://img.musnow.top/i/2023/08/feb23bbf0d7ea8acff297ff8111488fa.png" alt="image-20230827145453526"></p><h2 id="3-3-OpenFlow协议"><a href="#3-3-OpenFlow协议" class="headerlink" title="3.3 OpenFlow协议"></a>3.3 OpenFlow协议</h2><p>OpenFlow协议是一个受到高度认可的标准，其一般在SDN中进行使用，但SDN并不一定要用OpenFlow；</p><blockquote><p>OpenFlow协议由<strong>开放网络基金会ONF</strong>负责指定，该基金会致力于SDN的发展和标准化；OpenFlow协议目前较为成熟的是1.3版本</p></blockquote><p>OpenFlow协议是SDN体系结构中，控制层面和数据层面之间的通信接口，该协议可以允许控制层面的控制器对数据层面的物理设备进行直接的访问和控制。</p><p><img src="https://img.musnow.top/i/2023/08/0c9a0b49911c437a7d31a4090004fa1a.png" alt="image-20230827145816552"></p><h2 id="3-4-路由转发的区别"><a href="#3-4-路由转发的区别" class="headerlink" title="3.4 路由转发的区别"></a>3.4 路由转发的区别</h2><h3 id="3-4-1-传统路由表"><a href="#3-4-1-传统路由表" class="headerlink" title="3.4.1 传统路由表"></a>3.4.1 传统路由表</h3><p>传统的路由转发是查询路由表，根据地址掩码计算目的网络，判断是否与当前条目匹配，如果匹配，则从对应的「下一条」中发送出去。</p><p>路由转发这部分内容在我的IP协议详解博客中有所涉及：<a href="https://blog.musnow.top/posts/3482559497/">点我</a></p><p><img src="https://img.musnow.top/i/2023/08/e154eeaf46fb0ce68d4ca6c6ea946920.png" alt="image-20230827150215508"></p><h3 id="3-4-2-SDN广义转发"><a href="#3-4-2-SDN广义转发" class="headerlink" title="3.4.2 SDN广义转发"></a>3.4.2 SDN广义转发</h3><p>SDN在这基础上新增了更多的内容，称为<strong>广义转发</strong>：</p><ol><li>进行匹配：能够对网络体系结构中的各层（数据链路层，网络层，传输层）首部中的字段进行匹配</li><li>执行动作：不仅转发分组，还可以实现负载均衡、重写IP首部（类似NAT中的路由地址转换）、人为阻挡或丢弃一些分组（类似防火墙）</li></ol><p>在SDN广义转发中，完成这一操作的设备不再称为路由器，而是叫做OpenFlow交换机（或分组交换机），也可以简称为交换机。</p><h3 id="3-4-3-流表"><a href="#3-4-3-流表" class="headerlink" title="3.4.3 流表"></a>3.4.3 流表</h3><p>在SDN中替代 了传统路由表的是「流表（Flow Table）」</p><ul><li>一个流就是整个网络中的一组分组序列，在此序列中的每个分组都是<code>共享分组首部某些字段的值</code>，例如，某个流可以是共享相同的源IP和目的IP地址的一连串分组</li><li>OpenFlow交换机中的刘表是由SDN远程控制器来管理的，SDN远程控制器通过一个安全信道，通过OpenFlow协议来管理OpenFlow交换机中的流表</li></ul><p><img src="https://img.musnow.top/i/2023/08/da25636e91b2ab521809adc0d568a7d4.png" alt="image-20230827150934738"></p><ul><li>每个OpenFlow交换机必须有一个或者多个流表</li><li>每一个流表包含多个流表项目</li><li>每个流表项包含三个字段：首部字段值（匹配字段）、计数器、动作（类似下一跳）</li></ul><p>OpenFlow的首部字段值跨越了三个层次的首部，既可以处理数据链路层的MAC帧，又可以处理IP报文，或者是TCP&#x2F;UDP的端口</p><p><img src="https://img.musnow.top/i/2023/08/fa579c04d7c630a4b94a6158c1b0d384.png" alt="image-20230827151212669"></p><p>计数器字段包含一组计数器</p><ul><li>记录已经与该流表项匹配的分组数量的计数器；</li><li>记录该流表项上次更新到现在经历的时间的计数器</li></ul><p>动作字段是一族动作，当分组匹配到某个流表项时，执行下方的一个或者多个动作</p><ul><li>把分组转发到指定的端口</li><li>丢弃分组</li><li>把分组进行复制后，从多个端口转发出去</li><li>重写分组中的首部字段</li></ul><h3 id="3-4-4-VLAN"><a href="#3-4-4-VLAN" class="headerlink" title="3.4.4 VLAN"></a>3.4.4 VLAN</h3><blockquote><p>关于该报文中VLAN部分可以查看此博客：<a href="https://blog.csdn.net/LawssssCat/article/details/127204720">https://blog.csdn.net/LawssssCat/article/details/127204720</a></p></blockquote><p>VLAN是一种用于进一步虚拟化划分局域网的方式，假如一台路由器有4个网口，其可以通过将LAN1和LAN2设置成VLAN10，LAN3和LAN4设置成VLAN20来模拟出两个局域网</p><p><img src="https://img.musnow.top/i/2023/08/8cfceb7090ae21914683d034f680f485.png" alt="image-20230827153454860"></p><p>vlan（virtual lan）技术提供了一种灵活的解决方案；将交换机的接口根据业务需要添加到不同的vlan中，从而实现二层隔离。</p><ul><li>隔离广播域，即广播包只在本 vlan 中传播，从而在一定程度上可以提高整个网络的处理能力；</li><li>提高安全性，一个 vlan 内的用户和其他 vlan 内的用户不能互访，提高了网络的安全性；</li><li>增加带宽利用&#x2F;降低延迟&#x2F;管理作用</li></ul><h2 id="3-5-举例"><a href="#3-5-举例" class="headerlink" title="3.5 举例"></a>3.5 举例</h2><h3 id="3-5-1-简单转发"><a href="#3-5-1-简单转发" class="headerlink" title="3.5.1 简单转发"></a>3.5.1 简单转发</h3><p>通过不同的流表项来设置转发路径和转发动作，动作中的<code>转发(3)</code>代表从该交换机的3号端口转发出去。端口号在图中有标注；</p><p><img src="https://img.musnow.top/i/2023/08/6faaa19507feedb4784efd2c5a5ac376.png" alt="image-20230827151650945"></p><h3 id="3-5-2-负载均衡"><a href="#3-5-2-负载均衡" class="headerlink" title="3.5.2 负载均衡"></a>3.5.2 负载均衡</h3><p>第二个栗子是负载均衡的栗子，在下面的场景中，我们想要H3发送的分组通过<code>S2-S1-S3-H5/H6</code>，要H4发送的分组通过<code>S2-S3-H5/H6</code>；以达到负载均衡的目的。</p><p><img src="https://img.musnow.top/i/2023/08/5f152f13954536e40cb1b6b815f0c9ad.png" alt="image-20230827151718483"></p><p>使用传统的源IP和目的IP的转发方式，无法实现这样的负载均衡。在传统场景下，当S2在数据链路层发现目的MAC地址是S3的MAC地址的时候，无论如何都会直接发送给S3，而不是从S1处绕路。</p><p>但在SDN场景中，就可以通过两个不同的流表项来规定不同转发动作，实现这样的负载均衡（这里的<code>转发(4)</code>代表从S2的4号端口转发出去）</p><p><img src="https://img.musnow.top/i/2023/08/2d076ac5eca2dc6f7480020f2e0fd57f.png" alt="image-20230827151948106"></p><h3 id="3-5-3-防火墙"><a href="#3-5-3-防火墙" class="headerlink" title="3.5.3 防火墙"></a>3.5.3 防火墙</h3><p>如果我们想让S2主机只接收来自S1的数据而不接受S3的数据，就可以通过只设置S1的源IP地址的流表项，来丢弃S3发送的数据（匹配不上的数据就会被丢弃）</p><p><img src="https://img.musnow.top/i/2023/08/f7be65147a7d7897ae6d4402ad2d8f26.png" alt="image-20230827152217555"></p><h2 id="3-6-SDN体系结构的特征"><a href="#3-6-SDN体系结构的特征" class="headerlink" title="3.6 SDN体系结构的特征"></a>3.6 SDN体系结构的特征</h2><p>下图中包含了SDN的体系结构一览图和SDN的四个关键特征</p><ol><li>基于流的转发</li><li>数据层面与控制层面分离</li><li>位于数据层面分组交换机之外的网络控制功能</li><li>可编程的网络</li></ol><p>其中，SDN控制器是这个架构中最复杂的设备，其通过南向API控制底层的OpenFlow交换机，通过北向API接受其他网络控制器的策略配置。</p><p><img src="https://img.musnow.top/i/2023/08/a6678beda5464d34757501e8cc95580e.png" alt="image-20230827152358531"></p><h3 id="3-6-1-SDN控制器"><a href="#3-6-1-SDN控制器" class="headerlink" title="3.6.1 SDN控制器"></a>3.6.1 SDN控制器</h3><p>SDN控制器可以分成三个层次</p><ul><li>其通信层通过OpenFlow协议与交换机通信</li><li>中间间来根据各种策略管理各个交换机</li><li>北向API接收来自其他控制策略发起端的配置</li></ul><p><img src="https://img.musnow.top/i/2023/08/46dc0f081cfa38af5ea0d3d89e0ccc68.png" alt="image-20230827152554869"></p><p>这里使用的<code>RESTful API </code>是基于HTTP的API，也是我们较常见的API接口；</p><h3 id="3-6-2-开源SDN控制器"><a href="#3-6-2-开源SDN控制器" class="headerlink" title="3.6.2 开源SDN控制器"></a>3.6.2 开源SDN控制器</h3><p>常用的开源SDN控制器有OPEN DAYLIGHT和ONOS；</p><h3 id="3-6-3-SDN的优势"><a href="#3-6-3-SDN的优势" class="headerlink" title="3.6.3 SDN的优势"></a>3.6.3 SDN的优势</h3><blockquote><p>原文链接：<a href="https://blog.csdn.net/as12138/article/details/131273381">https://blog.csdn.net/as12138/article/details/131273381</a></p></blockquote><p>SDN相比于传统网络架构，有许多优点和优势。</p><ol><li><p>高度可编程性：SDN架构中的控制器负责管理交换机和路由器，使得网络更加可编程、可配置。管理员可以通过控制器实现灵活调整网络拓扑、管理流量和配置流调度策略，提升网络的可演变性、可定制化和可伸缩性。</p></li><li><p>网络智能集中化：在SDN中，网络智能被集中在控制器中，通过控制器进行集中式管理和控制。这种分离的模式避免了网络设备中任务的复杂，提升了网络的可管理性和可控制性。此外，集中化的管理方式也可以在网络中间件和应用中实现智能控制，如分布式存储、云计算等。</p></li><li><p>可扩展性：SDN中的网络设备是通用的硬件设备，不需要特定的功能区分，同时也不需要更新硬件，只需更新控制器即可实现拓扑可伸缩和灵活的网络管理。</p></li><li><p>自动化和提高效率：SDN中可以实现网络的自动化，通过控制器进行自动化的网络管理，可以避免手动管理网络的局限性和不确定性，从而提高网络的效率和稳定性，同时，自动化网络管理也可以降低网络维护的成本和时间。</p></li><li><p>安全可靠性提升：网络安全和可靠性是企业网络中最基本的需求。传统的网络安全往往需要通过一些特定设备和协议来实现。相比之下，SDN中的控制器可以根据网络实时状态自动优化管理策略，安全可靠的方式来提高网络的安全性。</p></li></ol><p>总之，SDN的优势在于其灵活的可编程性、集中式智能管理、高效的自动化网络管理和增强网络安全性。以上优势也是SDN技术应用广泛的主要原因，越来越多的企业和组织将SDN技术应用到自己的网络架构中，以满足未来网络的需求和挑战。</p><h2 id="3-6-4-SDN应用前景"><a href="#3-6-4-SDN应用前景" class="headerlink" title="3.6.4 SDN应用前景"></a>3.6.4 SDN应用前景</h2><p>SDN技术目前已经实现了基础网络配置、流控制、网络安全等功能。在未来，SDN技术还会面临更多的挑战和机遇。</p><ol><li><p>5G时代：5G技术将会改变网络的面貌，加速物联网应用的普及。SDN作为架构灵活、可编程的网络方式，将会在5G网络中发挥重要作用，实现网络的自动化和智能化管理。</p></li><li><p>IoT设备：物联网技术带来大量设备的连接，SDN技术的价值在于自动化了物联网设备的管理、安全和监控。未来，SDN技术将会成为物联网管理的重要工具。</p></li><li><p>AI：随着人工智能的发展，SDN的业界应用已经开始大规模落地。这将加速智能交通、智能城市和自动驾驶等领域的发展。</p></li><li><p>集成新技术：SDN可以很容易地与其他技术相结合，例如NFV（网络功能虚拟化）和AI（人工智能），以提高网络的效率和适应性。</p></li><li><p>云计算：SDN技术的灵活性和可编程性，也使得SDN与云计算等新技术的结合变得更加自然。在未来，SDN技术将与云技术紧密结合，实现业务流程的自动化、快速应用部署和弹性云资源管理。</p></li></ol><p>总而言之，SDN技术将为未来网络的发展和实现各种应用提供支撑。在日益增长的网络需求和复杂的网络技术背景下，SDN的灵活性和高可用性将会带来更大的发展空间和市场需求。SDN技术应当继续研究和发展，以满足更多的网络需求和挑战。</p><h2 id="3-7-总结"><a href="#3-7-总结" class="headerlink" title="3.7 总结"></a>3.7 总结</h2><p><img src="https://img.musnow.top/i/2023/08/3a0e7fd1ff2494f51ec6121d4a60e108.png" alt="image-20230827152810972"></p>]]></content>
    
    
    <summary type="html">朴实的学习原因：京东实习生招聘条目上写了这些技术，那就给他学了！</summary>
    
    
    
    <category term="差生文具多" scheme="https://blog.musnow.top/categories/%E5%B7%AE%E7%94%9F%E6%96%87%E5%85%B7%E5%A4%9A/"/>
    
    
    <category term="CDN" scheme="https://blog.musnow.top/tags/CDN/"/>
    
    <category term="SDN" scheme="https://blog.musnow.top/tags/SDN/"/>
    
  </entry>
  
  <entry>
    <title>【API】API的各种分类详解</title>
    <link href="https://blog.musnow.top/posts/73383828/"/>
    <id>https://blog.musnow.top/posts/73383828/</id>
    <published>2023-08-26T12:15:18.000Z</published>
    <updated>2023-08-26T12:15:18.000Z</updated>
    
    <content type="html"><![CDATA[<p>API，即应用程序编程接口，是为了方便应用程序之间的数据和功能交互而设计的一些标准方法。API 的分类可以从多个维度进行，我会对 API 的分类维度进行简单的介绍。</p><span id="more"></span><h2 id="根据使用方式的不同"><a href="#根据使用方式的不同" class="headerlink" title="根据使用方式的不同"></a>根据使用方式的不同</h2><p>通常情况下，API 可以分为两种使用方式：内部 API 和外部 API。</p><p>内部 API 是指供企业内部开发人员和应用所使用的 API。当企业需要一些定制化的应用程序或者集成特定的功能时，内部 API 可以提供更好的技术支持，同时也能保证数据的安全性和可靠性。</p><p>外部 API 则是供公众开发者使用的 API，通过提供数据和服务，使得外部的开发者可以构建丰富的应用程序并与当前的生态系统进行协作。越来越多的各类公司都开始向公众提供自己的 API，示例包括 Facebook、Twitter、Google 等。</p><h2 id="根据访问方式的不同"><a href="#根据访问方式的不同" class="headerlink" title="根据访问方式的不同"></a>根据访问方式的不同</h2><p>根据 API 的访问方式，API 可以分为以下几种：</p><ul><li>RESTful API REST（Representational State Transfer）是一种基于 HTTP 协议的 Web 应用程序架构标准。RESTful API 遵循 RESTful 架构的原则，通常由资源路径和请求方法组成，以达到可读性高、灵活性好的目的。</li><li>SOAP API SOAP（Simple Object Access Protocol）是一种基于 XML 编码的远程调用协议，比较复杂而且处理时间和网络资源使用率高。虽然 SOAP 技术已经逐渐淡出市场，但在某些特殊场景下仍然会有所应用。</li><li>GraphQL API GraphQL 是由 Facebook 公司开源的一种数据查询语言和 API 执行引擎，可以呈现出 XML schema 来表达整个数据的结构，并为前端工程师提供自由定义获取所需属性、代码重用等人性化的特色。</li><li>gRPC API gRPC 可以理解为 Google Remote Procedure Call，是 Google 最新开源的跨语言 RPC 框架。借助基于 HTTP&#x2F;2 的二进制传输协议，gRPC 提供了比 JSON 和 RESTful 更快速和更可靠的通讯方式。</li></ul><h2 id="根据功能的不同"><a href="#根据功能的不同" class="headerlink" title="根据功能的不同"></a>根据功能的不同</h2><p>根据 API 的功能性质，API 可以分为以下几类：</p><ul><li>Web API Web API 一般都针对 Web 应用程序，提供一些标准的接口，例如：W3C DOM 接口、HTTP 接口、WebSocket 接口、Web Worker 接口等。这些 API 帮助浏览器取得用户元素信息、发送 AJAX 请求等等。</li><li>操作系统 API 操作系统 API（如 Windows API 或 POSIX API）提供了与操作系统软件交互的方法，允许应用程序查询及控制硬件设备或操作系统内核任务等。此类 API 几乎适用于任何类型的环境。</li><li>数据库 API 数据库 API 可以使应用程序通过某些 API 实现对一些数据存储的操作，例如：SQL、NoSQL 等数据库里都有相关的 API 调用。</li></ul><p>在实际使用中，API 支持访问不同的功能模块，例如数据转换、数据分析、网络安全、门户管理、日历等等，还可以根据不同的需求进行客制化的开发。</p><p>总之，在开发过程中，根据实际需求选择合适的 API 类型是非常重要的，能够快速、高效地构建需要的应用程序。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">版权声明：本文为CSDN博主「luffy_fe」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。</span><br><span class="line">原文链接：https://blog.csdn.net/qq_42107247/article/details/130508490</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;API，即应用程序编程接口，是为了方便应用程序之间的数据和功能交互而设计的一些标准方法。API 的分类可以从多个维度进行，我会对 API 的分类维度进行简单的介绍。&lt;/p&gt;</summary>
    
    
    
    
    <category term="API" scheme="https://blog.musnow.top/tags/API/"/>
    
  </entry>
  
  <entry>
    <title>【Linux】高级IO和多路转接 | select/poll/epoll</title>
    <link href="https://blog.musnow.top/posts/3390191280/"/>
    <id>https://blog.musnow.top/posts/3390191280/</id>
    <published>2023-08-25T00:22:36.000Z</published>
    <updated>2023-08-25T04:05:36.000Z</updated>
    
    <content type="html"><![CDATA[<p>多路转接和高级IO</p><span id="more"></span><p>咳咳，写的时候出了点问题，标点符号全乱了（批量替换了几次），干脆就把全文的逗号和句号都改成英文的了（不然代码块里面的代码都是中文标点就跑不动了）</p><h1 id="1-高级IO"><a href="#1-高级IO" class="headerlink" title="1.高级IO"></a>1.高级IO</h1><h2 id="1-1-五种IO模型"><a href="#1-1-五种IO模型" class="headerlink" title="1.1 五种IO模型"></a>1.1 五种IO模型</h2><p>用钓鱼佬的栗子, 来看看五种不同的IO模型吧</p><ul><li>A, 拿着鱼竿去钓鱼, 一直盯着鱼漂, 鱼漂有动静就收钩</li><li>B, 拿着鱼竿去钓鱼, 时不时看看鱼漂, 有动静就收购</li><li>C, 拿着鱼竿去钓鱼, 在鱼漂上弄个铃铛, 然后干其他的事情, 听到铃铛的声音就收钩</li><li>D, 拿了一大堆鱼竿过来, 都摆弄好, 只要有一个鱼漂有动静, 就收钩</li><li>E是大老板, 直接叫人帮忙钓鱼, 钓到一定数量的🐟后通知自己, 自己过来取🐟（没有参与钓鱼过程）</li></ul><p>这五种钓鱼方式, 就对应了五种IO模型</p><ul><li>A, <strong>阻塞等待</strong>, 等待到数据就立即读取</li><li>B, <strong>轮询检测</strong>, 检测到数据的时候读取</li><li>C, 利用铃铛来作为通知方式, 听到了信号之后, 就去读取数据（<strong>信号驱动</strong>）</li><li>D, 一次性检测多个文件描述符（<strong>多路转接</strong>）</li><li>E, 没有自己参与钓鱼过程, 有别人帮忙监控文件描述符, 自己只关心拿走数据（<strong>异步IO</strong>）</li></ul><p>在这五种IO模式中, <strong>D的效率是最高的</strong>。因为它一次性监控了多个文件描述符, 这些文件描述符的IO在一定程度上重合了, 更容易等到数据。</p><p>要知道, D是过来钓鱼的, 他只要能钓到鱼就够了, 并不用关心到底是哪个鱼钩钓上来的鱼。同理, 我们的IO服务器也并不需要关心到底是哪个文件描述符在给自己传递信息, 我们只要每时每刻都在处理信息（都能钓到鱼）才是最高效率的体现。</p><p>换句话说, 在钓鱼（处理IO）的时候, 等的时间比例越低, 效率越高！</p><h2 id="1-2-阻塞和非阻塞"><a href="#1-2-阻塞和非阻塞" class="headerlink" title="1.2 阻塞和非阻塞"></a>1.2 阻塞和非阻塞</h2><p>这两个概念我们在先前对IO的学习中已经见过了</p><ul><li>阻塞：进程会在函数调用中卡住, 在没有成功调用之前不会继续向后运行</li><li>非阻塞：不管能否获取到数据, 函数都是直接返回结果;</li></ul><h2 id="1-3-异步与同步通信"><a href="#1-3-异步与同步通信" class="headerlink" title="1.3 异步与同步通信"></a>1.3 异步与同步通信</h2><ul><li>异步通信：在调用发出后, 这个调用直接返回, 并没有携带结果;类似<code>std::async/future</code>, 在调用发出后, 被调用着通过状态或通知来告知调用者, 亦或者是用回调函数来处理这个异步调用</li><li>同步通信：在发出调用后, 没有得到结果前, 该调用不返回;一旦返回就表明该调用成功获取到了返回值（调用者主动等待调用结果）</li></ul><p>这里的同步和线程&#x2F;进程同步并不是一个概念：</p><ul><li>线程和进程的同步指的是线程和进程之间有相互制约的关系, 需要在某些情况中协调他们的工作次序而进行等待</li></ul><hr><p>了解完IO模型和上方的知识后, 下面就让我们来认识一下第一个接口吧！</p><h1 id="2-fcntl"><a href="#2-fcntl" class="headerlink" title="2.fcntl"></a>2.fcntl</h1><p>这个是一个系统调用, 可以给文件描述符进行不同的策略设置。</p><p>当我们在linux中创建一个文件描述符的时候, 默认创建的都是阻塞的文件描述符。我们可以使用<code>fcntl</code>来将文件描述符设置成<strong>非阻塞</strong>的。</p><h2 id="2-1-接口"><a href="#2-1-接口" class="headerlink" title="2.1 接口"></a>2.1 接口</h2><p>该函数的原型如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">fcntl</span><span class="params">(<span class="type">int</span> fd, <span class="type">int</span> cmd, ... <span class="comment">/* arg */</span> )</span>;</span><br></pre></td></tr></table></figure><p>其中cmd是我们需要执行的策略, 下面是常见的几种选项</p><ul><li>复制一个现有的描述符（cmd&#x3D;F_DUPFD）</li><li>获得&#x2F;设置文件描述符标记(cmd&#x3D;F_GETFD或F_SETFD)</li><li>获得&#x2F;设置文件状态标记(cmd&#x3D;F_GETFL或F_SETFL)</li><li>获得&#x2F;设置异步I&#x2F;O所有权(cmd&#x3D;F_GETOWN或F_SETOWN)</li><li>获得&#x2F;设置记录锁(cmd&#x3D;F_GETLK, F_SETLK或F_SETLKW)</li></ul><p>这里我们使用的是第三个功能, 来获取和设置文件的状态标记, 就可以将文件描述符设置为非阻塞（这里要注意, 不是用第二种）</p><h2 id="2-2-设置非阻塞"><a href="#2-2-设置非阻塞" class="headerlink" title="2.2 设置非阻塞"></a>2.2 设置非阻塞</h2><p>我们需要先将文件描述符原本的属性给取出来, 然后再加上非阻塞的状态, 使用<code>fcntl</code>设置属性。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">SetNoBlock</span><span class="params">(<span class="type">int</span> fd)</span> </span><br><span class="line">&#123; </span><br><span class="line">    <span class="type">int</span> fl = fcntl(fd, F_GETFL);  <span class="comment">// 先获取文件已有状态</span></span><br><span class="line">    <span class="keyword">if</span> (fl &lt; <span class="number">0</span>) &#123; </span><br><span class="line">       perror(<span class="string">&quot;fcntl error&quot;</span>);</span><br><span class="line">       <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 在已有状态的基础上, 设置O_NONBLOCK非阻塞</span></span><br><span class="line">    fcntl(fd, F_SETFL, fl | O_NONBLOCK);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-3-stdin测试"><a href="#2-3-stdin测试" class="headerlink" title="2.3 stdin测试"></a>2.3 stdin测试</h2><p>然后, 我们还需要一个会出现阻塞的文件描述符来作为测试。但是, 如果是直接打开一个本地文件, 并不会出现阻塞态（因为文件流会被一次性读取出来）</p><p>不过, 在我们最常用的3个默认文件描述符中, 就有一个是能够实现进程阻塞的, 它就是<code>stdin</code>, 因为在控制台里面等待用户输入的时候, 进程就是处于阻塞状态的！</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ ./test</span><br><span class="line">请输入：</span><br></pre></td></tr></table></figure><p>所以我们就可以尝试将stdin设置为非阻塞, 来观察一下结果</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">SetNoBlock</span>(stdin-&gt;_fileno);</span><br><span class="line">    <span class="type">char</span> buf[<span class="number">1024</span>];</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">ssize_t</span> read_size = <span class="built_in">read</span>(stdin-&gt;_fileno, buf, <span class="built_in">sizeof</span>(buf) - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span>(read_size &lt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">perror</span>(<span class="string">&quot;read err&quot;</span>);</span><br><span class="line">            <span class="built_in">sleep</span>(<span class="number">2</span>);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;input:%s\n&quot;</span>, buf);</span><br><span class="line">        buf[<span class="number">0</span>] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译运行, 当没有读取到输入内容的时候, 并不会在<code>stdin</code>中阻塞, 而是会通过perror打印出资源暂时不可用的警告信息。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">$ ./test</span><br><span class="line">read err: Resource temporarily unavailable</span><br><span class="line">asdlfjklaf</span><br><span class="line">input:asdlfjklaf</span><br><span class="line"></span><br><span class="line">read err: Resource temporarily unavailable</span><br><span class="line">adslfkjaldfjklasjfa</span><br><span class="line">input:adslfkjaldfjklasjfa</span><br><span class="line">a</span><br><span class="line">read err: Resource temporarily unavailable</span><br><span class="line">ewqrqreqqrwer</span><br><span class="line">input:ewqrqreqqrwer</span><br><span class="line">asjfa</span><br><span class="line">a</span><br><span class="line">read err: Resource temporarily unavailable</span><br><span class="line">qweioruqoruioqewur</span><br><span class="line">input:qweioruqoruioqewur</span><br><span class="line"></span><br><span class="line">a</span><br><span class="line">read err: Resource temporarily unavailable</span><br><span class="line">weqioruqoieuotqitqwertq</span><br><span class="line">input:weqioruqoieuotqitqwertq</span><br><span class="line">����a</span><br><span class="line">read err: Resource temporarily unavailable</span><br><span class="line">^C</span><br></pre></td></tr></table></figure><h1 id="3-多路转接之select"><a href="#3-多路转接之select" class="headerlink" title="3.多路转接之select"></a>3.多路转接之select</h1><p>接下来就要进入我们的正题了, 关于<strong>多路转接</strong>的知识。</p><p>在之前的时候, 我们如果想在一个进程里面维护多个tcp链接, 就需要用到子线程或者子进程来单独为每一个用户提供服务。<strong>但一个进程可以开的线程是有数量限制的</strong>, 在32位系统中, 这个数字大概是2000。</p><p>对于一个高并发的服务器来说, 这点线程数是完全不够用的！如果你的网站一次性有2000个人访问, 你的服务器就会因为开不出更多的线程而无法为更多的用户提供服务！</p><p>所以, <strong>多路转接</strong>就出现了, 他能帮我们实现单个进程监控多个文件描述符, 同时为多个socket链接提供服务的操作！</p><blockquote><p>普通的本地文件描述符也是可以托管给多路转接的！</p></blockquote><h2 id="3-1-认识select"><a href="#3-1-认识select" class="headerlink" title="3.1 认识select"></a>3.1 认识select</h2><p>select的函数原型和我们之前接触过的linux系统调用接口都不大相似, 它的所有参数都是输入输出型参数, 而且还用到了一个我们平时较少接触的数据结构——位图</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* According to POSIX.1-2001, POSIX.1-2008 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/select.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">select</span><span class="params">(<span class="type">int</span> nfds, fd_set *readfds, fd_set *writefds, </span></span></span><br><span class="line"><span class="params"><span class="function">           fd_set *exceptfds, <span class="keyword">struct</span> timeval *timeout)</span></span>;</span><br></pre></td></tr></table></figure><p>先来依次说明一下每一个参数的作用吧</p><ul><li><code>nfds</code>：需要select帮我们监视的<code>最大文件描述符+1</code></li><li><code>readfds/writefds/exceptfds</code>, 需要select帮我们检测的读&#x2F;写&#x2F;异常文件描述符（通过<strong>位图</strong>来设定）</li><li><code>timeout</code>：阻塞监控的时长, 用来设置select单次阻塞等待的时间</li></ul><h3 id="3-1-1-timeval"><a href="#3-1-1-timeval" class="headerlink" title="3.1.1 timeval"></a>3.1.1 timeval</h3><p>首先来看看timeout的这个参数的<code>struct timeval</code>结构体框架, 内部包含两个成员变量, 一个表示秒数, 一个表示微秒数。最终select等待的时间是这两个参数的<strong>和</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> &#123;</span></span><br><span class="line">    <span class="type">long</span>    tv_sec;         <span class="comment">/* seconds */</span></span><br><span class="line">    <span class="type">long</span>    tv_usec;        <span class="comment">/* microseconds */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>如果设置成0, 则仅检测文件描述符的状态, 不管什么情况都会立即返回（完全非阻塞）</li><li>如果设置成指定的时间, 则会阻塞等待这端时间, 如果有文件事件则返回;如果没有等到文件时间, 那么时间到了就会返回</li><li>如果将<code>timeout</code>参数设置成<code>nullptr</code>, 则会<strong>阻塞等待</strong></li></ul><p>这个参数也是一个输入输出型参数, 返回值为剩余的秒数（如果等待成功的话）</p><h3 id="3-1-2-fd-set"><a href="#3-1-2-fd-set" class="headerlink" title="3.1.2 fd_set"></a>3.1.2 fd_set</h3><p>函数中有3个参数都是用到了这个<code>fd_set</code>结构, 它是一个位图结构, 同时也是一个输入输出参数</p><ul><li>输入：用户告诉操作系统, 需要帮我监控那几个文件描述符, 在需要监控的文件描述符上置1</li><li>输出：系统告诉用户, 那些文件描述符的相关事件就绪了</li></ul><p>虽然这是一个位图结构, 但其并不需要我们手动去设置, 操作系统顺便帮我们封装了相关的设置“函数”, 只需要传入fd和该结构体即可</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">FD_CLR</span><span class="params">(<span class="type">int</span> fd, fd_set *set)</span></span>;  <span class="comment">// 清空位图中对该文件描述符的设置</span></span><br><span class="line"><span class="function"><span class="type">int</span>  <span class="title">FD_ISSET</span><span class="params">(<span class="type">int</span> fd, fd_set *set)</span></span>;<span class="comment">// 判断是否被设置了</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">FD_SET</span><span class="params">(<span class="type">int</span> fd, fd_set *set)</span></span>;  <span class="comment">// 设置对应位置的文件描述符</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">FD_ZERO</span><span class="params">(fd_set *set)</span></span>;         <span class="comment">// 清空整个位图</span></span><br></pre></td></tr></table></figure><p>你可能回觉得奇怪, 为什么这些“函数”是大写的呢？Linux中大写的应该是宏才对吧？</p><p>答对了！这里的设置函数其实都是宏定义！</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Access macros for `fd_set&#x27;.  */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>FD_SET(fd, fdsetp)__FD_SET (fd, fdsetp)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>FD_CLR(fd, fdsetp)__FD_CLR (fd, fdsetp)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>FD_ISSET(fd, fdsetp)__FD_ISSET (fd, fdsetp)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>FD_ZERO(fdsetp)__FD_ZERO (fdsetp)</span></span><br></pre></td></tr></table></figure><p>既然是一个预定义好的位图, 那么它的长度就会收到操作系统底层的一定限制, 以下为源代码中<code>fd_set</code>结构体的定义</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 路径 usr/include/sys/select.h</span></span><br><span class="line"><span class="comment">/* The fd_set member is required to be an array of longs.  */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">int</span> __fd_mask;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Some versions of &lt;linux/posix_types.h&gt; define this macros.  */</span></span><br><span class="line"><span class="meta">#<span class="keyword">undef</span>__NFDBITS</span></span><br><span class="line"><span class="comment">/* It&#x27;s easier to assume 8-bit bytes than to get CHAR_BIT.  */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NFDBITS(8 * (int) sizeof (__fd_mask))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>__FD_ELT(d)((d) / __NFDBITS)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>__FD_MASK(d)((__fd_mask) (1UL &lt;&lt; ((d) % __NFDBITS)))</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* fd_set for select and pselect.  */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">  &#123;</span></span><br><span class="line">    <span class="comment">/* XPG4.2 requires this member name.  Otherwise avoid the name</span></span><br><span class="line"><span class="comment">       from the global namespace.  */</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> __USE_XOPEN</span></span><br><span class="line">    __fd_mask fds_bits[__FD_SETSIZE / __NFDBITS];</span><br><span class="line"><span class="meta"># <span class="keyword">define</span> __FDS_BITS(set) ((set)-&gt;fds_bits)</span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">    __fd_mask __fds_bits[__FD_SETSIZE / __NFDBITS];</span><br><span class="line"><span class="meta"># <span class="keyword">define</span> __FDS_BITS(set) ((set)-&gt;__fds_bits)</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">  &#125; fd_set;</span><br></pre></td></tr></table></figure><p>在另外一个头文件中, 可以找到<code>__FD_SETSIZE</code>这个宏的定义, 是1024;也就是说, <code>fd_set</code>这个位图最大的长度只有1024个比特位, 我们也只能监看这么多文件描述符！</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 路径 usr/include/bits/typesizes.h</span></span><br><span class="line"><span class="comment">/* Number of descriptors that can fit in an `fd_set&#x27;.  */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __FD_SETSIZE1024</span></span><br></pre></td></tr></table></figure><p>这也是<code>select</code>的缺点之一, 同时监看的文件描述符数量是<strong>有限制</strong>的！</p><h3 id="3-1-3-nfds"><a href="#3-1-3-nfds" class="headerlink" title="3.1.3 nfds"></a>3.1.3 nfds</h3><p>这个参数是select需要帮我们监看的最大文件描述符+1, 这是因为select在监看的过程中需要用循环来进行检测, 这个最大文件描述符+1相当于是一个循环的边界条件;</p><p>你只需根据当前已有的文件描述符号, 计算出最大文件描述符, 再加一传给这个函数即可。</p><h3 id="3-1-4-返回值"><a href="#3-1-4-返回值" class="headerlink" title="3.1.4 返回值"></a>3.1.4 返回值</h3><p>man手册中对返回值的描述如下</p><ul><li>成功的时候, 返回事件就绪的文件描述符数量</li><li>失败的时候返回<code>-1</code>, 并设置errno</li><li>如果已经<code>timeout</code>了还没有事件就绪, 返回0</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">RETURN VALUE</span><br><span class="line">       On success, select() and pselect() return the number of file descriptors contained in the three returned descriptor  sets  (that  is,  the total  number  of  bits that are set in readfds, writefds, exceptfds) which may be zero if the timeout expires before anything interesting happens.  On error, -1 is returned, and errno is set to indicate the error; the file descriptor sets are unmodified, and  timeout becomes undefined.</span><br></pre></td></tr></table></figure><h2 id="3-2-实例"><a href="#3-2-实例" class="headerlink" title="3.2 实例"></a>3.2 实例</h2><p>函数原型看完了, 得从实例出发来试试了</p><h3 id="3-2-1-socket"><a href="#3-2-1-socket" class="headerlink" title="3.2.1 socket"></a>3.2.1 socket</h3><p>这里先对<span id="jump-select">socket</span>做了一个简单的封装, 包括初始化, 绑定相关的接口, 只需要在另外一个文件里面调用这个头文件即可 !</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Sock.hpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cerrno&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cassert&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Sock</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">static</span> <span class="type">const</span> <span class="type">int</span> gbacklog = <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">SocketInit</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="type">int</span> listenSock = <span class="built_in">socket</span>(PF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span> (listenSock &lt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 设置端口复用, 避免timewait阻塞端口</span></span><br><span class="line">        <span class="type">int</span> opt = <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">setsockopt</span>(listenSock, SOL_SOCKET, SO_REUSEADDR | SO_REUSEPORT, &amp;opt, <span class="built_in">sizeof</span>(opt));</span><br><span class="line">        <span class="keyword">return</span> listenSock;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">Bind</span><span class="params">(<span class="type">int</span> socket, <span class="type">uint16_t</span> port)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> local; <span class="comment">// 用户栈</span></span><br><span class="line">        <span class="built_in">memset</span>(&amp;local, <span class="number">0</span>, <span class="keyword">sizeof</span> local);</span><br><span class="line">        local.sin_family = PF_INET;</span><br><span class="line">        local.sin_port = <span class="built_in">htons</span>(port);</span><br><span class="line">        local.sin_addr.s_addr = INADDR_ANY;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2.2 本地socket信息, 写入sock_对应的内核区域</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">bind</span>(socket, (<span class="type">const</span> <span class="keyword">struct</span> sockaddr *)&amp;local, <span class="built_in">sizeof</span>(local)) &lt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">2</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">Listen</span><span class="params">(<span class="type">int</span> socket)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">listen</span>(socket, gbacklog) &lt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">3</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">Accept</span><span class="params">(<span class="type">int</span> socket, std::string *clientip, <span class="type">uint16_t</span> *clientport)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> peer;</span><br><span class="line">        <span class="type">socklen_t</span> len = <span class="built_in">sizeof</span>(peer);</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> serviceSock = <span class="built_in">accept</span>(socket, (<span class="keyword">struct</span> sockaddr *)&amp;peer, &amp;len);</span><br><span class="line">        <span class="keyword">if</span> (serviceSock &lt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 获取链接失败</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(clientport) *clientport = <span class="built_in">ntohs</span>(peer.sin_port);</span><br><span class="line">        <span class="keyword">if</span>(clientip) *clientip = <span class="built_in">inet_ntoa</span>(peer.sin_addr);</span><br><span class="line">        <span class="keyword">return</span> serviceSock;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>另外重点说明一下这两行, 在之前学习tcp服务器的时候就提到过, 这里的<code>SO_REUSEADDR</code>是让端口可以被复用, 不会因为存在<code>TIME_WAIT</code>的链接而无法绑定端口。适用于服务器快速重启的情况。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 设置端口复用, 避免timewait阻塞端口</span></span><br><span class="line"><span class="type">int</span> opt = <span class="number">1</span>;</span><br><span class="line"><span class="built_in">setsockopt</span>(listenSock, SOL_SOCKET, SO_REUSEADDR | SO_REUSEPORT, &amp;opt, <span class="built_in">sizeof</span>(opt));</span><br></pre></td></tr></table></figure><h3 id="3-2-2-初始化"><a href="#3-2-2-初始化" class="headerlink" title="3.2.2 初始化"></a>3.2.2 初始化</h3><p>还是老一套, 通过命令行参数获取到端口号, 创建socket_fd并绑定端口和开始<code>listen</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (argc != <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="built_in">cmd_usage</span>(argv[<span class="number">0</span>]);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;   </span><br><span class="line">    <span class="comment">// 初始化socket, 获取socket fd并绑定端口</span></span><br><span class="line">    <span class="type">int</span> listensock = Sock::<span class="built_in">SocketInit</span>();</span><br><span class="line">    Sock::<span class="built_in">Bind</span>(listensock, <span class="built_in">atoi</span>(argv[<span class="number">1</span>]));</span><br><span class="line">    Sock::<span class="built_in">Listen</span>(listensock); <span class="comment">// 开始监听</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>需要注意的是, 在select中的文件描述符都只剩位图了, 所以我们必须要有一个单独的文件描述符数组来协助我们管理正在维护的文件描述符。</p><p>这里为了方便, 我设立了一个全局的数组变量, 长度为<code>sizeof(fd_set) * 8</code>, 是<code>fd_set</code>这个位图结构体能够支持的最大socket数量</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> fdsArray[<span class="built_in">sizeof</span>(fd_set) * <span class="number">8</span>] = &#123;<span class="number">0</span>&#125;; <span class="comment">// 保存历史上所有的合法fd</span></span><br><span class="line"><span class="type">int</span> fdsArraySz = <span class="built_in">sizeof</span>(fdsArray) / <span class="built_in">sizeof</span>(fdsArray[<span class="number">0</span>]);</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DFL_FD -1 <span class="comment">// 数组中默认值</span></span></span><br></pre></td></tr></table></figure><p>在main函数中, 我们需要通过遍历来将这个数组设置为默认的文件描述符<code>-1</code>来表明当前位置没有被使用, 并将0下标处设置为<code>listensock</code>;如果你使用的是vector, 则可以直接用构造函数来初始化;</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将数组里面的文件描述符都初始化为默认值, 并将第一个下标设置为listensocket</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; fdsArraySz; i++)&#123;</span><br><span class="line">    fdsArray[i] = DFL_FD;</span><br><span class="line">&#125;</span><br><span class="line">fdsArray[<span class="number">0</span>] = listensock;</span><br></pre></td></tr></table></figure><h3 id="3-2-3-监听"><a href="#3-2-3-监听" class="headerlink" title="3.2.3 监听"></a>3.2.3 监听</h3><p>初始化完毕数组后, 就可以开始循环调用<code>select</code>来进行监听了。</p><p>需要注意的是, 因为<code>select</code>的<code>fd_set</code>是一个位图, 而且是输入输出参数。每次的<code>select</code>调用之后, 这些位图就会被操作系统修改为已经就绪的文件描述符（即参数本身会被修改）所以我们下一次调用之前, <strong>需要重新设置位图参数</strong>！</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 开始监听</span></span><br><span class="line">fd_set readfds;</span><br><span class="line"><span class="keyword">while</span>(<span class="literal">true</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> maxFd = DFL_FD;</span><br><span class="line">    <span class="built_in">FD_ZERO</span>(&amp;readfds); <span class="comment">// 清空位图</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">timeval</span> timeout = &#123;<span class="number">5</span>, <span class="number">0</span>&#125;; <span class="comment">// 设置超时时间为5秒</span></span><br><span class="line">    <span class="comment">// 遍历全局数组, 将有效的fd都添加进去, 并更新maxfd</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; fdsArraySz; i++)</span><br><span class="line">    &#123;   </span><br><span class="line">        <span class="comment">// 1. 过滤不合法的fd</span></span><br><span class="line">        <span class="keyword">if</span> (fdsArray[i] == DFL_FD) <span class="keyword">continue</span>;   </span><br><span class="line">        <span class="comment">// 2. 添加所有的合法的fd到readfds中, 方便select统一进行就绪监听</span></span><br><span class="line">        <span class="built_in">FD_SET</span>(fdsArray[i], &amp;readfds); </span><br><span class="line">        <span class="keyword">if</span> (maxFd &lt; fdsArray[i]) &#123;</span><br><span class="line">            maxFd = fdsArray[i]; <span class="comment">// 3. 更新出fd最大值</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 调用select开始监听</span></span><br><span class="line">    <span class="type">int</span> sret = <span class="built_in">select</span>(maxFd+<span class="number">1</span>, &amp;readfds, <span class="literal">nullptr</span>, <span class="literal">nullptr</span>, &amp;timeout);</span><br><span class="line">    <span class="keyword">switch</span> (sret)</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">0</span>: <span class="comment">// 等待超时</span></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;time out ... : &quot;</span> &lt;&lt; (<span class="type">unsigned</span> <span class="type">long</span>)<span class="built_in">time</span>(<span class="literal">nullptr</span>) &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">-1</span>:<span class="comment">// 等待失败</span></span><br><span class="line">        cerr &lt;&lt; errno &lt;&lt; <span class="string">&quot; : &quot;</span> &lt;&lt; <span class="built_in">strerror</span>(errno) &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="comment">// 等待成功</span></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;wait success: &quot;</span> &lt;&lt; sret &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>基本框架搭起来了, 我们这时候就只需要实现等待成功后取出链接和IO信息的操作了;</p><p>先来测试一下当前的手脚架吧</p><h3 id="3-2-4-手脚架测试"><a href="#3-2-4-手脚架测试" class="headerlink" title="3.2.4 手脚架测试"></a>3.2.4 手脚架测试</h3><p>编译启动, 使用命令行参数来绑定端口, 在没有收到数据之前, 进程会在select中阻塞等待5秒, 随后因为超时跳出阻塞态, 返回0并打印当前时间戳</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ g++ main.cpp -o test</span><br><span class="line">$ ./test 10000</span><br><span class="line">time out ... : 1692955522</span><br><span class="line">time out ... : 1692955527</span><br><span class="line">time out ... : 1692955532</span><br><span class="line">time out ... : 1692955537</span><br><span class="line">time out ... : 1692955542</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>使用<code>telnet</code>命令来链接当前服务, <code>select</code>检测到listensock文件描述符就绪, 会立刻返回（对于listensock来说, 来了新链接就是读IO就绪）但因为我们没有写取走新socket的代码, 所以这里会一直打印事件就绪;</p><p>返回值为1, 代表有一个文件描述符的事件就绪。</p><p><img src="https://img.musnow.top/i/2023/08/bcd37076cf11a3ec0d3caac5f7f0501f.png" alt="image-20230825172642067"></p><h3 id="3-2-5-处理新连接"><a href="#3-2-5-处理新连接" class="headerlink" title="3.2.5 处理新连接"></a>3.2.5 处理新连接</h3><p>在<code>select</code>事件就绪后, 使用如下函数来处理新的链接</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">HandlerEvent</span><span class="params">(<span class="type">int</span> listensock, fd_set &amp;readfds)</span></span>;</span><br></pre></td></tr></table></figure><p>这里额外写了一个打印数组中元素的函数, 方便我们观察结果。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// @brief 打印数组中的文件描述符</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">ShowArray</span><span class="params">(<span class="type">int</span> arr[], <span class="type">int</span> num)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;当前合法sock list: &quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; num; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (arr[i] == DFL_FD )</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; arr[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先我们需要遍历整个链接数组, 并判断当前位置是否是有效的文件描述符。无效直接跳过。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; fdsArraySz; i++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (fdsArray[i] == DFL_FD)</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">    <span class="comment">// 处理新连接和已有链接</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>遍历的时候, 我们需要对listensock做单独的处理, 毕竟获取新连接和维护已有链接的流程是完全不同的。下面说说流程</p><ul><li>判断是否有在select中监听该文件描述符</li><li>有监听, 继续往后执行, 开始进行<code>accept</code>获取新的链接</li><li>获取失败, 直接跳出该函数, 结束该轮处理</li><li>获取成功, 不能直接read&#x2F;write, 而是应该通过数组交付给select帮我们监听事件</li><li>下一轮循环中, select便会帮我们监听该新链接的事件是否就绪</li></ul><p>因为走到这里的时候, 我们的<code>listensocket</code>里面是一定有新连接的, 所以对<code>accept</code>的调用是不会阻塞线程的！</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (i == <span class="number">0</span> &amp;&amp; fdsArray[i] == listensock)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 判断listensocket有没有事件监听</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">FD_ISSET</span>(listensock, &amp;readfds))&#123;</span><br><span class="line">        cerr &lt;&lt; <span class="string">&quot;listensocket not set in readfds&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 具有了一个新链接</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;get new connection&quot;</span> &lt;&lt; endl;</span><br><span class="line">    string clientip;</span><br><span class="line">    <span class="type">uint16_t</span> clientport = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> sock = Sock::<span class="built_in">Accept</span>(listensock, &amp;clientip, &amp;clientport); <span class="comment">// 不会阻塞</span></span><br><span class="line">    <span class="keyword">if</span> (sock &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span>; <span class="comment">// 出错了, 直接返回</span></span><br><span class="line">    <span class="comment">// 成功获取新连接</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;new conn:&quot;</span> &lt;&lt; clientip &lt;&lt; <span class="string">&quot;:&quot;</span> &lt;&lt; clientport &lt;&lt; <span class="string">&quot; | sock: &quot;</span> &lt;&lt; sock &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这里我们不能直接对这个socket进行独写, 因为新链接来了并不代表新数据一并过来了</span></span><br><span class="line">    <span class="comment">// 所以需要将新的文件描述符利用全局数组, 交付给select</span></span><br><span class="line">    <span class="comment">// select 帮我们监看socket上的读事件是否就绪</span></span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; fdsArraySz; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (fdsArray[i] == DFL_FD)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 达到上限了</span></span><br><span class="line">    <span class="keyword">if</span> (i == fdsArraySz)</span><br><span class="line">    &#123;</span><br><span class="line">        cerr &lt;&lt; <span class="string">&quot;reach the maximum number of connections&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="built_in">close</span>(sock);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="comment">// 没有达到</span></span><br><span class="line">    &#123;</span><br><span class="line">        fdsArray[i] = sock; <span class="comment">// 新的链接, 插入到数组中, 下次遍历就会添加到select监看中</span></span><br><span class="line">        <span class="built_in">ShowArray</span>(fdsArray, fdsArraySz);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-2-6-处理已有链接"><a href="#3-2-6-处理已有链接" class="headerlink" title="3.2.6 处理已有链接"></a>3.2.6 处理已有链接</h3><p>这里暂时只做了对读的操作, 当读事件就绪的时候, 我们通过read读取已有的数据。这里因为socket中肯定是有数据的, 所以也不会出现阻塞的情况。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// end if (i == 0 &amp;&amp; fdsArray[i] == listensock)</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 处理普通sock的IO事件</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">FD_ISSET</span>(fdsArray[i], &amp;readfds))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// read、recv读取即可</span></span><br><span class="line">        <span class="type">char</span> buffer[<span class="number">1024</span>];</span><br><span class="line">        <span class="type">ssize_t</span> s = <span class="built_in">recv</span>(fdsArray[i], buffer, <span class="built_in">sizeof</span>(buffer), <span class="number">0</span>); <span class="comment">// 不会阻塞</span></span><br><span class="line">        <span class="keyword">if</span> (s &gt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            buffer[s] = <span class="number">0</span>;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;client[&quot;</span> &lt;&lt; fdsArray[i] &lt;&lt; <span class="string">&quot;]# &quot;</span> &lt;&lt; buffer &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (s == <span class="number">0</span>) <span class="comment">// 对端关闭</span></span><br><span class="line">        &#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;client[&quot;</span> &lt;&lt; fdsArray[i] &lt;&lt; <span class="string">&quot;] quit, server close &quot;</span> &lt;&lt; fdsArray[i] &lt;&lt; endl;</span><br><span class="line">            <span class="built_in">close</span>(fdsArray[i]);</span><br><span class="line">            fdsArray[i] = DFL_FD; <span class="comment">// 去除对该文件描述符的select事件监听</span></span><br><span class="line">            <span class="built_in">ShowArray</span>(fdsArray, fdsArraySz);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="comment">// 异常了</span></span><br><span class="line">        &#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;client[&quot;</span> &lt;&lt; fdsArray[i] &lt;&lt; <span class="string">&quot;] error, server close &quot;</span> &lt;&lt; fdsArray[i] &lt;&lt; endl;</span><br><span class="line">            <span class="built_in">close</span>(fdsArray[i]);</span><br><span class="line">            fdsArray[i] = DFL_FD; <span class="comment">// 去除对该文件描述符的select事件监听</span></span><br><span class="line">            <span class="built_in">ShowArray</span>(fdsArray, fdsArraySz);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里我单次读取的时候, 最多只能读出1024字节的数据;如果想一次性读取完毕, 则需要使用循环+设置非阻塞来进行读取。后续在epoll的代码示例中会展示这种写法。</p><h3 id="3-2-7-实测"><a href="#3-2-7-实测" class="headerlink" title="3.2.7 实测"></a>3.2.7 实测</h3><p>到这里, 我们这套代码就基本完成了, 可以来测试一下能否实现单线程监听多个链接;</p><p>在本地使用telnet+多个终端进行测试, 可以看到我们成功实现了同时监听两个链接, 并接受这两个链接给自己发送的信息的功能。当telnet退出的时候, 也能成功回收文件描述符。</p><p><img src="https://img.musnow.top/i/2023/08/c14d2576fc599392522042a1bb12ddc5.png" alt="image-20230825183501900"></p><p>select的小实现暂时先看到这里, 如果想用select实现同时读+写, 其实是很复杂的。需要一套完整的逻辑。这就留着到最后epoll的时候再统一展现吧！</p><h2 id="3-3-socket就绪条件"><a href="#3-3-socket就绪条件" class="headerlink" title="3.3 socket就绪条件"></a>3.3 socket就绪条件</h2><p><span id="jump3">socket不同事件的就绪有各自的条件</span></p><h3 id="3-3-1-读就绪"><a href="#3-3-1-读就绪" class="headerlink" title="3.3.1 读就绪"></a>3.3.1 读就绪</h3><ul><li>socket内核中, 接收缓冲区中的字节数, 大于等于低水位标记<code>SO_RCVLOWAT</code>, 此时可以无阻塞的读该文件描述符, 并且返回值大于0; </li><li>socket在TCP通信中, 对端关闭连接, 此时对该socket读, 则返回0;</li><li>监听的socket上有新的连接请求;</li><li>socket上有未处理的错误;</li></ul><h3 id="3-3-2-写就绪"><a href="#3-3-2-写就绪" class="headerlink" title="3.3.2 写就绪"></a>3.3.2 写就绪</h3><ul><li>socket内核中,  发送缓冲区中的可用字节数(发送缓冲区的空闲位置大小),  大于等于低水位标记 <code>SO_SNDLOWAT</code>,  此时可以无阻塞的写,  并且返回值大于0;</li><li>socket的写操作被关闭(close或者shutdown). 对一个写操作被关闭的socket进行写操作,  会触发 <code>SIGPIPE</code> 信号;</li><li>socket使用非阻塞connect连接成功或失败之后;</li><li>socket上有未读取的错误;</li></ul><h3 id="3-3-3-异常就绪"><a href="#3-3-3-异常就绪" class="headerlink" title="3.3.3 异常就绪"></a>3.3.3 异常就绪</h3><p>socket上收到带外数据（TCP报头中的URG和紧急指针）</p><h2 id="3-4-select的特点"><a href="#3-4-select的特点" class="headerlink" title="3.4 select的特点"></a>3.4 select的特点</h2><ul><li>可监控的文件描述符有上限, 取决于<code>fd_set</code>位图结构体的配置</li><li>在监控文件描述符的时候, 需要用户额外的数组来维护文件描述符</li><li>每次循环都得遍历整个数组, 效率较低（可以优化为保证有效文件描述符都在数组的前方）</li></ul><p>一下是它在效率上的一些缺点</p><ul><li>每次调用select都得手动设置一边fd集和（因为<code>fd_set</code>也是输出型参数, 在内核中会被修改）</li><li>每次调用select, 都需要把所有fd从用户态拷贝到内核态, 小陆地</li><li>每次调用, 内核都须遍历传递进来的位图, 效率低</li><li>监控的文件描述符有上限, 数量小</li></ul><h1 id="4-多路转接之poll"><a href="#4-多路转接之poll" class="headerlink" title="4.多路转接之poll"></a>4.多路转接之poll</h1><h2 id="4-1-函数原型"><a href="#4-1-函数原型" class="headerlink" title="4.1 函数原型"></a>4.1 函数原型</h2><p>接下来我们要了解的是另外一个多路转接方案, <strong>poll</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;poll.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">poll</span><span class="params">(<span class="keyword">struct</span> pollfd *fds,  <span class="type">nfds_t</span> nfds,  <span class="type">int</span> timeout)</span></span>;</span><br></pre></td></tr></table></figure><h3 id="4-1-1-参数"><a href="#4-1-1-参数" class="headerlink" title="4.1.1 参数"></a>4.1.1 参数</h3><p>这里的参数就和select完全不同了, 出现了另外一个结构体</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pollfd</span> &#123;</span></span><br><span class="line">    <span class="type">int</span>   fd;         <span class="comment">/* file descriptor */</span></span><br><span class="line">    <span class="type">short</span> events;     <span class="comment">/* requested events */</span></span><br><span class="line">    <span class="type">short</span> revents;    <span class="comment">/* returned events */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这一个结构体分别包含了三个成员</p><ul><li>文件描述符fd;</li><li>用户告诉内核需要监看的事件events;</li><li>内核返回的就绪事件revents;</li></ul><p>但是从这个函数的参数上看来, 貌似它是一个只有一个元素的输入输出型参数, 难道说poll只能监看一个文件描述符吗？🧐</p><p>非也, 我们将函数原型改一下就能看明白了, 实际上, 第一个参数是一个<strong>结构体数组</strong>, 第二个参数是该结构体数组的<strong>长度</strong>！</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">poll</span><span class="params">(<span class="keyword">struct</span> pollfd fds[],  <span class="type">nfds_t</span> nfds,  <span class="type">int</span> timeout)</span>;</span><br></pre></td></tr></table></figure><p>第三个参数和select中的timeout的功能相同, 如果到达一定时间还没有获取到参数, 则直接返回;如果设置为<code>-1</code>则阻塞等待, 设置为0为完全非阻塞。</p><p>这里的timeout并非输入输出型号参数, 其只是一个输入参数, 单位为<strong>毫秒</strong>（记住, 不是秒, 是毫秒）</p><h3 id="4-1-2-返回值"><a href="#4-1-2-返回值" class="headerlink" title="4.1.2 返回值"></a>4.1.2 返回值</h3><ul><li>小于0, 出错</li><li>等于0, 等待超时</li><li>大于0, 文件描述符已经就绪的数量</li></ul><h3 id="4-1-3-事件"><a href="#4-1-3-事件" class="headerlink" title="4.1.3 事件"></a>4.1.3 事件</h3><p>这里需要了解一下poll包含的事件类型了, 我们需要根据不同情况来选择想要的事件, 并设置到结构体的<code>event</code>中;对于select&#x2F;poll&#x2F;epoll来说, 这些socket的就绪条件都是相同的。详见 <a href="#jump3">3.3 socket就绪条件</a>;</p><p><img src="https://img.musnow.top/i/2023/08/748d3a20ba69bb3b3671f5b344cba650.png" alt="img"></p><h2 id="4-2-poll优缺点"><a href="#4-2-poll优缺点" class="headerlink" title="4.2 poll优缺点"></a>4.2 poll优缺点</h2><h3 id="4-2-1-优点"><a href="#4-2-1-优点" class="headerlink" title="4.2.1 优点"></a>4.2.1 优点</h3><p>在poll中, 使用的是一个结构体数组来表示需要监听的文件描述符, 以及事件就绪的文件描述符</p><ul><li>因为结构体中用户需要监听的event和内核返回的就绪event并不在一个变量上, 所以只需要设置一次即可（如果需求没有变动的话）, 无需像select每次都得重新遍历来设置位图</li><li>poll没有最大文件描述符限制</li><li>poll无需用户额外维护一个单独的文件描述符数组, 直接沿用该结构体数组即可</li></ul><h3 id="4-2-2-缺点"><a href="#4-2-2-缺点" class="headerlink" title="4.2.2 缺点"></a>4.2.2 缺点</h3><ul><li>和select一样, poll也需要轮询检测就绪的fd和相关事件</li><li>每次调用poll需要把pollfd结构体从用户态拷贝到内核态</li><li>虽然poll没有最大文件描述符限制, 但是监看的多了后性能会线性下降</li></ul><h2 id="4-3-看看示例代码"><a href="#4-3-看看示例代码" class="headerlink" title="4.3 看看示例代码"></a>4.3 看看示例代码</h2><p>poll的代码部分的主机结构和select基本相同，这里我们主要来说一下不同的地方</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> NUM 1024</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DFL_FD -1</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pollfd</span> <span class="title">fdsArray</span>[<span class="title">NUM</span>];</span></span><br></pre></td></tr></table></figure><p>首先是全局的数组，这时候不需要自己维护一个int文件描述符数组了，直接使用这个结构体作为全局数组就OK了；在main函数里面还是老样子，我们得把整个数组的fd都设置成默认的fd作为标识</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; NUM; i++)</span><br><span class="line">&#123;</span><br><span class="line">    fdsArray[i].fd = DFL_FD;</span><br><span class="line">    fdsArray[i].events = <span class="number">0</span>;</span><br><span class="line">    fdsArray[i].revents = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">fdsArray[<span class="number">0</span>].fd = listensock;</span><br><span class="line">fdsArray[<span class="number">0</span>].events = POLLIN;</span><br></pre></td></tr></table></figure><p>在main函数的主循环中，也是用poll来依次监听事件，并判断poll函数的返回值</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> timeout = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> n = poll(fdsArray, NUM, timeout);</span><br><span class="line">    <span class="keyword">switch</span> (n)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;time out ... : &quot;</span> &lt;&lt; (<span class="type">unsigned</span> <span class="type">long</span>)time(nullptr) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">-1</span>:</span><br><span class="line">            <span class="built_in">cerr</span> &lt;&lt; errno &lt;&lt; <span class="string">&quot; : &quot;</span> &lt;&lt; strerror(errno) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            HandlerEvent(listensock);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在<code>HandlerEvent</code>函数中，我们通过判断结构体内部的<code>revent</code>来得知是否有事件就绪</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (fdsArray[i].revents &amp; POLLIN)&#123;&#125; <span class="comment">// 读事件是否就绪</span></span><br></pre></td></tr></table></figure><p>对于listensocket来说，就绪了就执行accept；并将新的文件描述符添加到数组中</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> j = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; NUM; j++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (fdsArray[j].fd == DFL_FD)</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 通过for循环找到当前位置是默认的结构体下标</span></span><br><span class="line"><span class="keyword">if</span> (j == NUM) <span class="comment">// 如果达到上限才break</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">cerr</span> &lt;&lt; <span class="string">&quot;我的服务器已经到了最大的上限了，无法在承载更多同时保持的连接了&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    close(sock);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">    fdsArray[j].fd = sock; <span class="comment">// 将sock添加到数组中</span></span><br><span class="line">    fdsArray[j].events = POLLIN;</span><br><span class="line">    fdsArray[j].revents = <span class="number">0</span>;</span><br><span class="line">    ShowArray(fdsArray, NUM);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于其他链接来说，就绪了就开始read。如果read异常或者对端关闭，那就将对应位置的结构体全部初始化（清空），相当于将这个链接从监听中去掉！</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">fdsArray[i].fd = DFL_FD; </span><br><span class="line">fdsArray[i].events = 0;</span><br><span class="line">fdsArray[i].revents = 0;</span><br></pre></td></tr></table></figure><p>其余的操作和select完全一致，在这里就不展示代码了！</p><h1 id="5-epoll"><a href="#5-epoll" class="headerlink" title="5.epoll"></a>5.epoll</h1><p>man手册中提到, epoll是为了处理大量socket文件描述符句柄而进行了一定改进的poll;</p><h2 id="5-1-接口"><a href="#5-1-接口" class="headerlink" title="5.1 接口"></a>5.1 接口</h2><p>epoll就不是只有一个函数接口了, 而是有3个相关的函数，使用过程就是三部曲：</p><ul><li>epoll_create 创建epoll文件句柄</li><li>epoll_ctl 将需要监控的文件描述符进行注册</li><li>epoll_wait 等待文件描述符就绪</li></ul><h3 id="5-1-1-epoll-create"><a href="#5-1-1-epoll-create" class="headerlink" title="5.1.1 epoll_create"></a>5.1.1 epoll_create</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/epoll.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">epoll_create</span><span class="params">(<span class="type">int</span> size)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">epoll_create1</span><span class="params">(<span class="type">int</span> flags)</span>;</span><br></pre></td></tr></table></figure><p>epoll在使用的时候, 我们需要用create函数创建一个epoll的句柄（本质上也是文件描述符）, 来管理当前进程需要操作系统帮我们监看的文件描述符</p><ul><li>自从<code>linux 2.6.8</code> 后, 这里的size参数是被胡咯的</li><li>epoll的句柄在使用完毕后也需要用<code>close()</code>函数关闭</li><li>错误的时候返回<code>-1</code>并设置errno, 正确的时候返回文件描述符</li></ul><h3 id="5-1-2-epoll-ctl"><a href="#5-1-2-epoll-ctl" class="headerlink" title="5.1.2 epoll_ctl"></a>5.1.2 epoll_ctl</h3><p>该函数是对epoll中需要监看的文件描述符进行设置</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/epoll.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">epoll_ctl</span><span class="params">(<span class="type">int</span> epfd,  <span class="type">int</span> op,  <span class="type">int</span> fd,  <span class="keyword">struct</span> epoll_event *event)</span>;</span><br></pre></td></tr></table></figure><ul><li>第一个参数是<code>epoll_create</code>的返回值</li><li>第二个参数是动作, 包含三个不同的选项<ul><li><code>EPOLL_CTL_ADD</code>：将新的文件描述符添加到<code>epfd</code>中</li><li><code>EPOLL_CTL_MOD</code>：修改已有文件描述符的监听事件</li><li><code>EPOLL_CTL_DEL</code>：删除已有文件描述符</li></ul></li><li>第三个参数是目标文件描述符</li><li>第四个参数是一个<code>epoll_event</code>结构体</li></ul><p>这个结构体的定义如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">union</span> <span class="title">epoll_data</span> &#123;</span></span><br><span class="line">    <span class="type">void</span>        *ptr;</span><br><span class="line">    <span class="type">int</span>          fd;</span><br><span class="line">    <span class="type">uint32_t</span>     u32;</span><br><span class="line">    <span class="type">uint64_t</span>     u64;</span><br><span class="line">&#125; <span class="type">epoll_data_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> &#123;</span></span><br><span class="line">    <span class="type">uint32_t</span>     events;      <span class="comment">/* Epoll events */</span></span><br><span class="line">    <span class="type">epoll_data_t</span> data;        <span class="comment">/* User data variable */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h4><p>事件<code>events</code>可以是下面的这些选项</p><table><thead><tr><th>事件</th><th>说明</th></tr></thead><tbody><tr><td>EPOLLIN</td><td>表示对应的文件描述符可以读 (包括对端SOCKET正常关闭);</td></tr><tr><td>EPOLLOUT</td><td>表示对应的文件描述符可以写;</td></tr><tr><td>EPOLLPRI</td><td>表示对应的文件描述符有紧急的数据可读 (这里应该表示有带外数据到来);</td></tr><tr><td>EPOLLERR</td><td>表示对应的文件描述符发生错误;</td></tr><tr><td>EPOLLHUP</td><td>表示对应的文件描述符被挂断;</td></tr><tr><td>EPOLLET</td><td>将EPOLL设为<strong>边缘触发 <strong>(Edge Triggered)模式,  这是相对于</strong>水平触发</strong>(Level Triggered) 来说的；</td></tr><tr><td>EPOLLONESHOT</td><td><strong>只监听一次事件,</strong>  当监听完这次事件之后,  如果还需要继续监听这个socket的话,  需要手动再次把这个socket加入到EPOLL队列里；</td></tr></tbody></table><h3 id="5-1-3-epoll-wait"><a href="#5-1-3-epoll-wait" class="headerlink" title="5.1.3 epoll_wait"></a>5.1.3 epoll_wait</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/epoll.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">epoll_wait</span><span class="params">(<span class="type">int</span> epfd,  <span class="keyword">struct</span> epoll_event *events, </span></span><br><span class="line"><span class="params">               <span class="type">int</span> maxevents,  <span class="type">int</span> timeout)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">epoll_pwait</span><span class="params">(<span class="type">int</span> epfd,  <span class="keyword">struct</span> epoll_event *events, </span></span><br><span class="line"><span class="params">                <span class="type">int</span> maxevents,  <span class="type">int</span> timeout, </span></span><br><span class="line"><span class="params">                <span class="type">const</span> <span class="type">sigset_t</span> *sigmask)</span>;</span><br></pre></td></tr></table></figure><p>改函数的作用是收集在epoll监控的事件中，已经就绪的事件</p><ul><li>第一个参数是epoll的文件描述符句柄</li><li>参数events是<code>epoll_events</code>结构体数组，是一个输出型参数。epoll会将就绪的事件赋值到events数组里面；</li><li>maxevents 告诉内核这个events的大小，其不可以超过<code>epoll_create</code>的size；</li><li>参数timeout是超时时间，也是毫秒（0非阻塞，-1永久阻塞）</li><li>返回值：成功返回IO事件就绪的文件描述符数目，0代表超时，负数代表失败</li></ul><h2 id="5-2-工作原理"><a href="#5-2-工作原理" class="headerlink" title="5.2 工作原理"></a>5.2 工作原理</h2><h3 id="5-2-1-从源码看流程"><a href="#5-2-1-从源码看流程" class="headerlink" title="5.2.1 从源码看流程"></a>5.2.1 从源码看流程</h3><p>我们知道，select通过位图来告诉操作系统需要管理的文件描述符，poll通过结构体数组来告诉操作系统需要管理的文件描述符。</p><p>但epoll里面，却变成了一个epfd文件句柄，我们只是给这个特定的句柄交付文件描述符。这说明底层肯定需要其他的数据结构，来管理某个进程的某个epfd交付给操作系统的文件描述符，以及需要监看的事件！</p><p>在<code>Linux 2.6.32.16</code>源码<code>fs/eventpoll.c</code>中，可以找到如下这个结构体</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// linux源码文件路径：fs/eventpoll.c</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * This structure is stored inside the &quot;private_data&quot; member of the file</span></span><br><span class="line"><span class="comment"> * structure and rapresent the main data sructure for the eventpoll</span></span><br><span class="line"><span class="comment"> * interface.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">eventpoll</span> &#123;</span></span><br><span class="line"><span class="comment">/* Protect the this structure access */</span></span><br><span class="line"><span class="type">spinlock_t</span> lock;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * This mutex is used to ensure that files are not removed</span></span><br><span class="line"><span class="comment"> * while epoll is using them. This is held during the event</span></span><br><span class="line"><span class="comment"> * collection loop, the file cleanup path, the epoll file exit</span></span><br><span class="line"><span class="comment"> * code and the ctl operations.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mutex</span> <span class="title">mtx</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Wait queue used by sys_epoll_wait() */</span></span><br><span class="line"><span class="type">wait_queue_head_t</span> wq;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Wait queue used by file-&gt;poll() */</span></span><br><span class="line"><span class="type">wait_queue_head_t</span> poll_wait;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* List of ready file descriptors */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">rdllist</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* RB tree root used to store monitored fd structs */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rb_root</span> <span class="title">rbr</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * This is a single linked list that chains all the &quot;struct epitem&quot; that</span></span><br><span class="line"><span class="comment"> * happened while transfering ready events to userspace w/out</span></span><br><span class="line"><span class="comment"> * holding -&gt;lock.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">epitem</span> *<span class="title">ovflist</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* The user that created the eventpoll descriptor */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">user_struct</span> *<span class="title">user</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在这里面，我们既可以看到熟悉的<code>mutex</code>锁，又可以看到一个<code>wait_queue</code>等待队列，一个双链表，和一个<code>rb_root</code>红黑树节点。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> &#123;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> *<span class="title">next</span>, *<span class="title">prev</span>;</span></span><br><span class="line">&#125;; <span class="comment">// 内核中的双链表</span></span><br></pre></td></tr></table></figure><p>抽象出来之后，其大概的结构图如下</p><p><img src="https://img.musnow.top/i/2023/08/6ca5fd02f9838c2ef2d41a014623262d.png" alt="image-20230826160246637"></p><p>当某一个进程调用<code>epoll_create</code>创建<code>epoll</code>的文件描述符句柄的时候，操作系统就会帮我们在底层创建一个<code>struct eventpoll</code>结构体，内部包含了就绪队列和一个红黑树（主要关注这两个成员）</p><ul><li>调用<code>epoll_ctl</code>的时候，操作系统就会将我们配置的文件描述符和对于的事件添加到红黑树节点中；</li><li>重复添加的事件也可以通过红黑树的键值唯一性检查出来（避免冗余）</li><li>所有添加到epoll中的事件都会与设备的<strong>网卡驱动程序</strong>建立回调消息，当某个文件描述符对应的链接有信息传来的时候，就会调用<strong>回调函数</strong>，告知epoll<ul><li>网卡收到消息</li><li>驱动程序处理，并调用对应的回调机制</li><li>epoll通过回调消息收到事件就绪，将其链入<code>rdllist</code>双链表中</li><li>上层只需要调回<code>epoll_wait</code>从该双链表中获取就绪事件</li></ul></li><li>该回调办法在底层为<code>ep_poll_callback</code>，它会将就绪的事件插入到<code>rdllist</code>双链表中</li><li>epoll中每一个事件都会建立一个对应的<code>epitem</code>结构体</li><li>当调用<code>epoll_wait</code>有事件发生的时候，只需要检查<code>eventpoll</code>对象的<code>rdllist</code>双链表中是否有<code>epitem</code>元素即可，有则取出；</li><li>如果<code>rdllist</code>不为空，则将发生的事件复制到用户态，并将事件数量返回给用户；对比需要遍历的<code>select/poll</code>，这个获取就绪事件的<strong>时间复杂度</strong>是<code>O(1)</code>的（直接判断并取出就可以了）</li></ul><p>这一大圈操作都是操作系统自行完成的，对于用户来说是无感知的！</p><p>关于epitem结构体，可以瞅一眼下面的注释，他也是在源码的<code>fs/eventpoll.c</code>文件中</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">epitem</span> &#123;</span><br><span class="line"><span class="comment">/* RB tree node used to link this structure to the eventpoll RB tree */</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">rb_node</span> rbn; <span class="comment">// 这个事件对应的红黑树节点</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* List header used to link this structure to the eventpoll ready list */</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">list_head</span> rdllink; <span class="comment">// 这个事件对应的双链表节点</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Works together &quot;struct eventpoll&quot;-&gt;ovflist in keeping the</span></span><br><span class="line"><span class="comment"> * single linked chain of items.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">epitem</span> *next; </span><br><span class="line"></span><br><span class="line"><span class="comment">/* The file descriptor information this item refers to */</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">epoll_filefd</span> ffd; <span class="comment">// 事件句柄信息</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Number of active wait queue attached to poll operations */</span></span><br><span class="line"><span class="type">int</span> nwait; </span><br><span class="line"></span><br><span class="line"><span class="comment">/* List containing poll wait queues */</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">list_head</span> pwqlist;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* The &quot;container&quot; of this item */</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">eventpoll</span> *ep; <span class="comment">// 指向其所属的epollevent对象</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* List header used to link this item to the &quot;struct file&quot; items list */</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">list_head</span> fllink;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* The structure that describe the interested events and the source fd */</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">epoll_event</span> event; <span class="comment">// 该fd关注的事件</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="5-2-2-PSH标记位"><a href="#5-2-2-PSH标记位" class="headerlink" title="5.2.2 PSH标记位"></a>5.2.2 PSH标记位</h3><p>在学习TCP的时候，我们了解过PSH这个标记位，它的作用是告诉对端的应用层，尽快取走缓冲区中的数据。</p><p>对于epoll而言，这个PSH的作用就是让epoll在<code>rdllist</code>里面新建一个就绪节点，这样上层就能知道这个文件描述符的事件就绪了（至于读不读取依旧是上层的问题）</p><ul><li>你可能会问，既然对方都发消息来催你取数据了，那不应该你的数据并没有被取走吗？这时候该文件描述符的就绪节点不应该已经存在了吗？为什么还需要额外创建一个就绪事件的节点来通知用户呢？</li></ul><p>这就涉及到epoll的两种工作策略LT&#x2F;ET了，后文会讲解；</p><blockquote><p>需要注意的是，epoll并没有对URG进行特殊处理，而是视之为正常的可读事件连入就绪队列，但是事件类型有所不同，可以用<code>EPOLLPRI</code>来关注紧急事件</p><p>（存疑，但是没有找到相关资料，暂且这么认为）</p></blockquote><h3 id="5-2-3-epoll优点"><a href="#5-2-3-epoll优点" class="headerlink" title="5.2.3 epoll优点"></a>5.2.3 epoll优点</h3><p>一下是epoll相比poll和select的优点</p><ul><li>接口使用方便，虽然拆分了3个函数，但是每个函数的功能非常明确；不需要每次使用都重新设置文件描述符，也实现了输入和输出参数的分离</li><li>数据拷贝轻量：在需要的时候调用epoll_ctl来处理文件描述符和事件，并不会每次调用都得大批量在用户和内核态之间拷贝数据（poll和select都需要）</li><li>事件回调机制：使用事件回调来替代遍历，回调函数将就绪的文件描述符结构加入到就绪队列中；<code>epoll_wait</code>直接使用就绪队列，就能知道那些文件描述符就绪；即便文件描述符较多的时候，也能快速知道就绪的文件描述符（省去了遍历的时间消耗）</li><li>无上限：文件描述符没有数量限制</li><li>线程安全：在<code>eventpoll</code>结构体里面，我们可以看到有一个<code>mutex</code>锁，在linux底层已经帮我维护了epoll相关操作的线程安全性！</li></ul><p>在有些博客里面说epoll使用了<strong>内存映射机制</strong>，这种说法是<strong>错误</strong>的！因为<code>epoll_event</code>结构体是在用户态创建的，我们势必还是需要进行一定的用户态到内核态的拷贝。</p><blockquote><p>内存映射机制：linux内核直接将就绪队列通过mmap的方式映射到用户态，避免拷贝消耗（你可以理解为用户态和内核态之间的共享内存）</p></blockquote><h2 id="5-3-工作模式"><a href="#5-3-工作模式" class="headerlink" title="5.3 工作模式"></a>5.3 工作模式</h2><p>在epoll的工作模式中，我们可以选择水平触发和边缘触发，这就好比物理实验中示波器的两种触发模式；</p><p>假设有这样一个tcp通信的栗子：</p><ul><li>对方给我发送了2kb数据</li><li>我通过epoll_wait成功获取到这个文件描述符的读事件就绪</li><li>我取出文件描述符，通过<code>recv</code>读取了1kb的数据</li><li>但缓冲区里面还有1kb……</li></ul><h3 id="5-3-1-水平触发-LT"><a href="#5-3-1-水平触发-LT" class="headerlink" title="5.3.1 水平触发 LT"></a>5.3.1 水平触发 LT</h3><p>所谓水平触发，就是只要fd的缓存区里面有数据，那么epoll就会一直认为这个fd的读事件是就绪的，并一直通知用户；</p><ul><li>上面的栗子中，因为用户只拿走了1kb数据，缓冲区里面还有1kb，在第二次调用<code>epoll_wait</code>的时候，epoll还是会报告该文件描述符的读事件就绪，让用户取走剩下的数据</li><li>只有所有的数据都被处理完毕，epoll才不会继续通知</li><li>LT支持阻塞和非阻塞读写</li></ul><p>因为LT模式只要缓冲区中还有剩余数据，epoll就会一直通知我们，这就允许上层不需要一次性取走所有数据，或者说不立刻处理当前缓冲区的数据。</p><p>因此，在LT模式中，只要是事件就绪，那么缓冲区里面一定会有数据。所以它是即支持阻塞，也支持非阻塞的文件读写的！</p><blockquote><p>select&#x2F;poll都是默认的LT模式，且不可以切换模式；epoll默认是LT，但可以切换到ET</p></blockquote><h3 id="5-3-2-边缘触发-ET"><a href="#5-3-2-边缘触发-ET" class="headerlink" title="5.3.2 边缘触发 ET"></a>5.3.2 边缘触发 ET</h3><p>边缘触发的含义，是只有某个文件描述符的数据变动的时候，才会通知用户；反应到读事件上，只有缓冲区数据增多了，才会通知用户；</p><ul><li>在上面的tcp通信栗子中，epoll会在数据到来的时候通知用户；但即便用户没有一次性读取完毕所有数据，epoll并不会继续通知了（除非有PSH信息到来）</li><li>在ET模式下，文件描述符的事件就绪后，只有一次处理机会。第二次你就无法得知这个文件描述符上是否还有没有读完的数据了</li><li>因为ET模式下<code>epoll_wait</code>返回的次数更少，所以ET的性能远高于LT（nginx默认采用ET模式的epoll）</li><li>因为我们只有一次机会，所以收到事件后必须立即处理</li><li>只支持非阻塞</li></ul><h3 id="5-3-3-LT和ET的区别"><a href="#5-3-3-LT和ET的区别" class="headerlink" title="5.3.3 LT和ET的区别"></a>5.3.3 LT和ET的区别</h3><p>因为ET模式下，epoll只会提示你一次事件就绪，所以就倒逼程序猿在收到这个事件之后，一次性处理完数据；</p><p>当然，LT模式下你也可以这么做（如果每次都能一次性取走数据，那么LT和ET的性能差距就不大了）。但ET模式就相当于告诉所有使用者，必须这么做，减少了容错率；</p><p>但ET的代码复杂度会增加；</p><h3 id="5-3-4-ET和非阻塞"><a href="#5-3-4-ET和非阻塞" class="headerlink" title="5.3.4 ET和非阻塞"></a>5.3.4 ET和非阻塞</h3><p>为什么ET必须要将文件描述符设置成非阻塞呢？</p><p>假设下面这个场景，客户端C给服务端S发送10kb数据，在没有收到服务端对这个数据的响应之前，不会继续发送数据；</p><p><img src="https://img.musnow.top/i/2023/08/1320c1d24627c05783f4d64dc6f43f21.png" alt="image-20230826180800176"></p><p>但服务器一次性只读取了1KB，剩下了9KB数据在缓冲区中；因为数据没有读完，所以不会给客户端发送响应。</p><p><img src="https://img.musnow.top/i/2023/08/42b5a34b96663a7b0314afd41e325896.png" alt="image-20230826180840435"></p><p>因为epoll设置了ET模式，所以并不会认为此时的文件描述符读就绪；<code>epoll_wait</code>不会针对这个文件描述符返回，剩下的9KB数据会一直留在缓冲区中；</p><ul><li>注意，服务端的代码逻辑是收到就绪事件就读取一次；并不存在再次读取的可能</li></ul><p>问题就来了！</p><ul><li>服务端必须要收到就绪事件才会把剩下的9kb数据给读取完毕</li><li>服务端想要收到就绪事件，就必须收到客户端C发来的新数据</li><li>但客户端C认为服务器没有给自己发送响应，不会继续发送数据</li></ul><p>这就相当于一个死循环了！</p><p><img src="https://img.musnow.top/i/2023/08/be296238e7cd395dabf1599602a8b193.png" alt="image-20230826181214987"></p><p>因此，服务端为了保证一次性能将数据全部取出，必须要采用循环读取+非阻塞的方式来将缓冲区读完！</p><p>如果采用阻塞式，那么在轮询读取的时候，就有可能因为缓冲区已经空了而阻塞！因为我们这个是一个单线程的模型，这样会直接导致整个服务器宕机了。</p><p>而LT则不会出现此问题，因为只要缓冲区中有数据就会通知你，所以我们可以一次读取定长，再将读到的数据拼接起来。</p><h3 id="5-3-5-epoll的使用场景"><a href="#5-3-5-epoll的使用场景" class="headerlink" title="5.3.5 epoll的使用场景"></a>5.3.5 epoll的使用场景</h3><p>epoll的高性能是有一定特殊场景的，如果场景不适合，epoll的性能可能表现不佳；</p><ul><li>对于多链接且链接中有一部分活跃的时候，适合使用epoll</li></ul><p>比如各种互联网APP的入口服务器，就很适合使用epoll来处理上万客户端的请求；</p><p>如果是系统内部处理服务器和服务器之间的通信，链接数较少的情况，这种时候使用epoll并不方便。得根据具体需要选择更加适合的IO模型。</p><h2 id="5-4-惊群效应"><a href="#5-4-惊群效应" class="headerlink" title="5.4 惊群效应"></a>5.4 惊群效应</h2><blockquote><p>参考 <a href="https://zhuanlan.zhihu.com/p/359774959">https://zhuanlan.zhihu.com/p/359774959</a></p></blockquote><h3 id="5-4-1-概念"><a href="#5-4-1-概念" class="headerlink" title="5.4.1 概念"></a>5.4.1 概念</h3><p>在多线程环境下，可能会遇到epoll的惊群效应；</p><ul><li>那么什么是惊群效应呢。其产生的原因是什么呢？</li></ul><p>惊群效应的具体情况是，当有多个线程或进程在 epoll 上等待某个事件（如套接字可读事件），当该事件发生时，所有等待的线程或进程都会被唤醒。然而，只有一个线程或进程可以成功地处理这个事件，而其他的线程或进程会进行不必要的竞争，可能会导致额外的上下文切换、锁竞争等问题，从而降低系统性能。</p><ul><li>以下是一个具体场景的说明</li></ul><p>在多线程或者多进程环境下，有些人为了提高程序的稳定性，往往会让<strong>多个线程</strong>或者<strong>多个进程</strong>同时在<code>epoll_wait</code>监听的socket描述符。当一个新的链接请求进来时，操作系统<strong>不知道</strong>选派那个线程或者进程处理此事件，则干脆将其中<strong>几个线程</strong>或者进程给唤醒，而实际上只有其中一个进程或者线程能够成功处理accept事件，其他线程都将失败，且errno错误码为<code>EAGAIN</code>。这种现象称为惊群效应。</p><p>结果是肯定的，惊群效应肯定会带来资源的消耗和性能的影响，因为你无端地多唤醒了几个线程，这些线程&#x2F;进程却没有活干。</p><h3 id="5-4-2-多线程环境下解决办法"><a href="#5-4-2-多线程环境下解决办法" class="headerlink" title="5.4.2 多线程环境下解决办法"></a>5.4.2 多线程环境下解决办法</h3><ul><li>专门的线程负责等待：在多线程场景下，不建议让多个线程进行<code>epoll_wait</code>，而用单个线程进行wait，并由该线程调用<code>accept</code>建立新链接，并将就绪的文件描述符交付给其他线程，来处理后续的读写操作。</li><li>使用线程池：不为每个链接都创立一个专门的线程，而是根据读写事件，将其交付给线程池中已有线程来处理；</li><li>使用ET模式：该模式下读写就绪的时候只会通知一次，再加上epoll本身是线程安全的，所以只会有一个线程可以拿到这个就绪事件，从而避免惊群现象；</li><li>互斥锁：同一时间只有一个线程进行等待和事件处理；</li></ul><h3 id="5-4-3-多进程下解决办法"><a href="#5-4-3-多进程下解决办法" class="headerlink" title="5.4.3 多进程下解决办法"></a>5.4.3 多进程下解决办法</h3><p>目前很多开源软件，如lighttpd和nginx等都采用<code>master/workers</code>的模式提高软件的吞吐能力及并发能力，在nginx中甚至还采用了<strong>负载均衡</strong>的技术，在某个子进程的处理能力达到一定负载之后，由其他<strong>负载较轻的子进程</strong>负责·的调用，那么nginx和Lighttpd是如何避免<code>epoll_wait</code>的惊群效用的呢？</p><ul><li>lighttpd的解决思路是<strong>无视</strong>惊群效应</li></ul><p>仍然采用<code>master/workers</code>模式，每个子进程仍然自己在监听的socket上调用<code>epoll_wait</code>，当有新的链接请求发生时，操作系统仍然只是唤醒其中部分的子进程来处理该事件，仍然只有一个子进程能够成功处理此事件，那么其他被惊醒的子进程捕获<code>EAGAIN</code>错误，并无视。</p><ul><li>nginx的解决思路是互斥锁</li></ul><p>在同一时刻，<strong>永远都只有一个</strong>子进程在监听的socket上<code>epoll_wait</code>，其做法是，创建一个全局的<code>pthread_mutex_t</code>，在子进程进行<code>epoll_wait</code>前，则先获取锁。当<code>epoll_wait</code>返回之后，nginx会调用accept把连接取出来，然后释放文件锁，让别的进程去监听。</p><p>这是一种折衷的办法，并没有很完美，首先进程间<strong>争抢锁</strong>会有性能开耗（即使是非阻塞的锁），中间可能会有小段时间没有进程去获取锁，比如A进程拿到锁，其他进程将会过一小段时间尝试再去获取锁，而这小段时间里面如果请求量很大，A仅接受一小部分请求就让出锁，则中间过程会有一些连接事件被hang住；</p><h3 id="5-4-4-内核解决了惊群效应了吗"><a href="#5-4-4-内核解决了惊群效应了吗" class="headerlink" title="5.4.4 内核解决了惊群效应了吗"></a>5.4.4 内核解决了惊群效应了吗</h3><p>惊群的根本原因在于epoll的默认行为是对于<strong>多进程监听同一文件不会设置互斥</strong>，进而将所有进程唤醒，后续的内核版本主要提供了两种解决方案</p><ol><li>既然默认不会设置互斥，那就加一个互斥功能好了，<code>linux 4.5</code>内核之后给epoll添加了一个<code>EPOLLEXCLUSIVE</code>的标志位，如果设置了这个标志位，那epoll将进程挂到等待队列时将会设置一下互斥标志位，这时实现跟内核原生accept一样的特性，只会唤醒队列中的一个进程</li><li>第二种方法：<code>linux 3.9</code>内核之后给socket提供<code>SO_REUSEPORT</code>标志，这种方式解决得更彻底，他允许不同进程的socket绑定到同一个端口，取代以往需要子进程共享socket监听的方式，这时候，每个进程的监听socket将指向<code>open_file_tables</code>下的不同节点，也就是说不同进程是在自己的设备等待队列下被挂起的，不存在共享fd的问题，也就不存在被同时唤醒的可能。而内核则在驱动中将设置了<code>SO_REUSEPORT</code>并且绑定同一端口的这些socket分到同一个group中，当有tcp连接事件到达的时候，内核将会对源<code>IP+源端口</code>取hash然后指定这个group中其中一个进程来接受连接，相当于在内核级别中实现了一个负载均衡</li></ol><p>基于以上两种方法，其实epoll生态在目前来说不存在所谓的惊群效应了。而新版本的nginx也采用了 <code>SO_REUSEPORT</code>来解决此问题。</p><p>除非你溢用epoll，比如多进程之间共享了同一个epfd（父进程创建epoll由多个子进程来调用），那就不能怪epoll了，因为这时候多个进程都被挂到这个epoll下，这种情况下，已经不是仅仅是惊群效应的问题了；比如说，A进程在epoll挂了socket1的连接事件，B进程调用了epoll_wait，由于属于同一个epfd，当socket1产生事件的时候，进程B也会被唤醒，而更严重的事情在于，在B进程的空间下并不存在socket1这个fd，从而把问题搞得很复杂。</p><p>总结：千万不要在多线程&#x2F;多进程之间共享epfd！</p><h1 id="6-Reactor模型"><a href="#6-Reactor模型" class="headerlink" title="6.Reactor模型"></a>6.Reactor模型</h1><p>接下来就让我们来用epoll编写一个基于Reactor模式的服务器吧！</p><h2 id="6-1-什么是Reactor？"><a href="#6-1-什么是Reactor？" class="headerlink" title="6.1 什么是Reactor？"></a>6.1 什么是Reactor？</h2><ul><li>Reactor模型是基于事件驱动的，通过一个或者多个输入同时传递给服务端进行处理</li><li>服务端请求程序处理传入的多个请求，并分发到相应的处理线程</li><li>基于IO多路转接（多路复用）模型：多个链接通用一个阻塞对象，引用程序只需要在一个阻塞对象等待，无需阻塞等待所有链接；当有新链接或者事件就绪的时候，由操作系统通知应用程序，开始进行业务处理</li><li>基于线程池复用线程资源：不必给每个链接单独创建线程，而是将链接完成后的业务处理交付给已有线程池中的线程进行处理，一个线程在生命周期中可以处理多个链接的业务。</li></ul><p>reactor模式有下面3种方式，<a href="https://blog.csdn.net/wlddhj/article/details/123872275">参考博客 @顽石九变</a></p><h3 id="6-1-1-主从Reactor多线程模型"><a href="#6-1-1-主从Reactor多线程模型" class="headerlink" title="6.1.1 主从Reactor多线程模型"></a>6.1.1 主从Reactor多线程模型</h3><p>第一种是多线程模式的，有不同的从属reactor来进行事件监控和处理</p><ul><li>Reactor主线程负责监听事件并进行链接的accept</li><li>accpet获取到链接后，分配给某一个从Reactor进行读写事件的监听</li><li>从Reactor进行事件监听，当有新事件发生的时候，创建Handler进行事件处理</li><li>Headler通过read读取数据，并处理数据（这里还可以将读取数据后的响应操作分发给线程池进行处理，线程池处理完毕后返回给Handler），通过send返回给客户端</li><li>Reactor主线程可以对应多个子线程</li></ul><p><img src="https://img.musnow.top/i/2023/08/9b1f1f0aec63e52ed44fca99f18d6e5a.png" alt="image-20230828085218401"></p><p><img src="https://img.musnow.top/i/2023/08/ecdd89978c73b286f89f29703c620c7e.png" alt="img"></p><h3 id="6-1-2-单Reactor多线程"><a href="#6-1-2-单Reactor多线程" class="headerlink" title="6.1.2 单Reactor多线程"></a>6.1.2 单Reactor多线程</h3><ul><li>Reactor通过多路转接监听客户端事件，收到事件后，进行分发</li><li>如果是建立链接的请求，则执行accept，建立链接后，创建一个Handler完成链接建立后的各个操作</li><li>如果不是链接请求（读写就绪）则由Reactor分发调用链接对应的读写Handler来进行处理</li><li>Handler只负责响应具体的事件，而不进行具体的业务处理</li><li>通过Handler中的read读取到数据后，分发给线程池子中的线程处理，处理完毕后返回Handler，再通过写方法发送给客户端</li></ul><p><img src="https://img.musnow.top/i/2023/08/18889218bcf8b973dd2140f84ee48c1d.png" alt="img"></p><h3 id="6-1-3-单Reactor单线程"><a href="#6-1-3-单Reactor单线程" class="headerlink" title="6.1.3 单Reactor单线程"></a>6.1.3 单Reactor单线程</h3><p>第三种是单线程模式下的（半异步半同步模型），当收到某个客户端的就绪事件，就去处理这个客户端的请求。此时Handler会完成read到业务处理到send的全流程；</p><p>本次主要写的是该模式下的操作，因为它基本是<strong>串行</strong>运行的，思路比较容易理解。但需要注意的是，这种模式支持的客户端量不应过多，否则会极大影响性能。</p><p><img src="https://img.musnow.top/i/2023/08/bd8688effc6efb18264e9785cc78b54e.png" alt="image-20230828085239238"></p><p><img src="https://img.musnow.top/i/2023/08/b057900a9b937973503f493cfa576711.png" alt="img"></p><h3 id="6-1-4-总结"><a href="#6-1-4-总结" class="headerlink" title="6.1.4 总结"></a>6.1.4 总结</h3><p><strong>三种模式用生活案例来理解</strong></p><ol><li><p>单Reactor单线程，前台接待员和服务员是同一个人，全程为顾客服务</p></li><li><p>单Reactor多线程，1个前台接待员，多个服务员，接待员只负责接待</p></li><li><p>主从Reactor多线程，多个前台接待员，多个服务员</p></li></ol><p><strong>Reactor模型具有如下优点</strong></p><ol><li><p>响应快，不必为单个同步事件所阻塞，虽然Reactor本身依然是同步的</p></li><li><p>可以最大程度的避免复杂的多线程及同步问题，并且避免了多线程&#x2F;进程的切换开销</p></li><li><p>扩展性好，可以方便的通过增加Reactor实例个数来充分利用CPU资源</p></li><li><p>复用性好，Reactor模型本身与具体事件处理逻辑无关，具有很高的复用性</p></li></ol><h2 id="6-2-代码分析"><a href="#6-2-代码分析" class="headerlink" title="6.2 代码分析"></a>6.2 代码分析</h2><p>话不多说，直接上代码吧！本次将所有处理模块都给拆分开来，一一进行说明</p><h3 id="6-2-1-Epoller-hpp"><a href="#6-2-1-Epoller-hpp" class="headerlink" title="6.2.1 Epoller.hpp"></a>6.2.1 Epoller.hpp</h3><p>首先是将对epoll的三个系统调用函数进行一定的封装，统一进行错误的判断处理。方便了其他模块的调用用；</p><p>这部分的代码非常简单，就只在注释里写一下解析吧！</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cerrno&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/epoll.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Log.hpp&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Epoller</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">static</span> <span class="type">const</span> <span class="type">int</span> gsize = <span class="number">128</span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">CreateEpoller</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="type">int</span> epfd = <span class="built_in">epoll_create</span>(gsize); <span class="comment">// 创建对应size的epfd</span></span><br><span class="line">        <span class="keyword">if</span> (epfd &lt; <span class="number">0</span>) <span class="comment">// 错误判断</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">logMessage</span>(FATAL, <span class="string">&quot;epoll_create : %d : %s&quot;</span>, errno, <span class="built_in">strerror</span>(errno));</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">3</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> epfd; <span class="comment">// 正确返回epfd</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">bool</span> <span class="title">AddEvent</span><span class="params">(<span class="type">int</span> epfd, <span class="type">int</span> sock, <span class="type">uint32_t</span> event)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">struct</span> <span class="title class_">epoll_event</span> ev;</span><br><span class="line">        ev.events = event; <span class="comment">// 设置event</span></span><br><span class="line">        ev.data.fd = sock;</span><br><span class="line">        <span class="comment">// 给对应的socket添加到epoll中</span></span><br><span class="line">        <span class="type">int</span> n = <span class="built_in">epoll_ctl</span>(epfd, EPOLL_CTL_ADD, sock, &amp;ev);</span><br><span class="line">        <span class="keyword">return</span> n == <span class="number">0</span>; <span class="comment">// 返回值是是否调用成功</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">bool</span> <span class="title">ModEvent</span><span class="params">(<span class="type">int</span> epfd, <span class="type">int</span> sock, <span class="type">uint32_t</span> event)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">struct</span> <span class="title class_">epoll_event</span> ev;</span><br><span class="line">        ev.events = event;</span><br><span class="line">        ev.data.fd = sock;</span><br><span class="line">        <span class="comment">// 修改已有scoket的event</span></span><br><span class="line">        <span class="comment">// 该socket必须先用ADD添加，否则无法修改，会返回ENOENT错误</span></span><br><span class="line">        <span class="type">int</span> n = <span class="built_in">epoll_ctl</span>(epfd, EPOLL_CTL_MOD, sock, &amp;ev);</span><br><span class="line">        <span class="keyword">return</span> n == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">bool</span> <span class="title">DelEvent</span><span class="params">(<span class="type">int</span> epfd, <span class="type">int</span> sock)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// 删除指定socket</span></span><br><span class="line">        <span class="type">int</span> n = <span class="built_in">epoll_ctl</span>(epfd, EPOLL_CTL_DEL, sock, <span class="literal">nullptr</span>);</span><br><span class="line">        <span class="keyword">return</span> n == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">LoopOnce</span><span class="params">(<span class="type">int</span> epfd, <span class="keyword">struct</span> epoll_event revs[], <span class="type">int</span> num)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// 单次wait的调用，从数组里面取回就绪的文件描述符</span></span><br><span class="line">        <span class="type">int</span> n = <span class="built_in">epoll_wait</span>(epfd, revs, num, <span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">logMessage</span>(FATAL, <span class="string">&quot;epoll_wait : %d : %s&quot;</span>, errno, <span class="built_in">strerror</span>(errno));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> n;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="6-2-2-Sock-hpp"><a href="#6-2-2-Sock-hpp" class="headerlink" title="6.2.2 Sock.hpp"></a>6.2.2 Sock.hpp</h3><p>同select，见上文 <a href="#jump-select">3.2.1 socket</a> 部分；</p><h3 id="6-2-3-Log-hpp"><a href="#6-2-3-Log-hpp" class="headerlink" title="6.2.3 Log.hpp"></a>6.2.3 Log.hpp</h3><p>一个巨简单的日志类</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ctime&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdarg&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cassert&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cassert&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cerrno&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DEBUG 0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NOTICE 1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> WARNING 2</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FATAL 3</span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">char</span> *log_level[] = &#123;<span class="string">&quot;DEBUG&quot;</span>, <span class="string">&quot;NOTICE&quot;</span>, <span class="string">&quot;WARINING&quot;</span>, <span class="string">&quot;FATAL&quot;</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LOGFILE <span class="string">&quot;serverTcp.log&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Log</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Log</span>():<span class="built_in">logFd</span>(<span class="number">-1</span>)</span><br><span class="line">    &#123;&#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">enable</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">umask</span>(<span class="number">0</span>);</span><br><span class="line">        logFd = <span class="built_in">open</span>(LOGFILE, O_WRONLY | O_CREAT | O_APPEND, <span class="number">0666</span>);</span><br><span class="line">        <span class="built_in">assert</span>(logFd != <span class="number">-1</span>);</span><br><span class="line">        <span class="built_in">dup2</span>(logFd, <span class="number">1</span>);</span><br><span class="line">        <span class="built_in">dup2</span>(logFd, <span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    ~<span class="built_in">Log</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(logFd != <span class="number">-1</span>) </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">fsync</span>(logFd);</span><br><span class="line">            <span class="built_in">close</span>(logFd);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> logFd;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// logMessage(DEBUG, &quot;%d&quot;, 10);</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">logMessage</span><span class="params">(<span class="type">int</span> level, <span class="type">const</span> <span class="type">char</span> *format, ...)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">assert</span>(level &gt;= DEBUG);</span><br><span class="line">    <span class="built_in">assert</span>(level &lt;= FATAL);</span><br><span class="line"></span><br><span class="line">    <span class="type">char</span> *name = <span class="built_in">getenv</span>(<span class="string">&quot;USER&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">char</span> logInfo[<span class="number">1024</span>];</span><br><span class="line">    va_list ap;</span><br><span class="line">    <span class="built_in">va_start</span>(ap, format);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">vsnprintf</span>(logInfo, <span class="built_in">sizeof</span>(logInfo) - <span class="number">1</span>, format, ap);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">va_end</span>(ap); <span class="comment">// ap = NULL</span></span><br><span class="line"></span><br><span class="line">    FILE *out = (level == FATAL) ? stderr : stdout;</span><br><span class="line">    <span class="built_in">fprintf</span>(out, <span class="string">&quot;%s | %u | %s | %s\n&quot;</span>,</span><br><span class="line">            log_level[level],</span><br><span class="line">            (<span class="type">unsigned</span> <span class="type">int</span>)<span class="built_in">time</span>(<span class="literal">nullptr</span>),</span><br><span class="line">            name == <span class="literal">nullptr</span> ? <span class="string">&quot;unknow&quot;</span> : name,</span><br><span class="line">            logInfo);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">fflush</span>(out); <span class="comment">// 将C语言缓冲区中的数据刷新到OS</span></span><br><span class="line">    <span class="built_in">fsync</span>(<span class="built_in">fileno</span>(out));   <span class="comment">// 将OS中的数据尽快写入硬盘</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="6-2-4-TcpServer"><a href="#6-2-4-TcpServer" class="headerlink" title="6.2.4 TcpServer"></a>6.2.4 TcpServer</h3><p>这是我们reactor模型的重点</p><h4 id="1-Connection类"><a href="#1-Connection类" class="headerlink" title="1.Connection类"></a>1.Connection类</h4><p>这里先定义了一个Connection链接类，比较重要的是类里面有3个回调方法的指针。在Reactor中，我们用回调方法来替代了主执行流直接调用函数的方式。线程只需要接收到这个<code>Connection</code>对象，就可以用回调方法来实现对链接的数据处理</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">using <span class="type">func_t</span> = <span class="built_in">std</span>::function&lt;<span class="type">int</span>(Connection *)&gt;;</span><br><span class="line">using <span class="type">callback_t</span> = <span class="built_in">std</span>::function&lt;<span class="type">int</span>(Connection *, <span class="built_in">std</span>::<span class="built_in">string</span> &amp;)&gt;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Connection</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">public:</span><br><span class="line">    <span class="comment">// 文件描述符</span></span><br><span class="line">    <span class="type">int</span> sock_;</span><br><span class="line">    TcpServer *R_;<span class="comment">// 主服务器的类指针</span></span><br><span class="line">    <span class="comment">// 自己的接受和发送缓冲区</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> inbuffer_;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> outbuffer_;</span><br><span class="line">    <span class="comment">// 读、写、异常的回调函数</span></span><br><span class="line">    <span class="type">func_t</span> recver_; </span><br><span class="line">    <span class="type">func_t</span> sender_;</span><br><span class="line">    <span class="type">func_t</span> excepter_;</span><br><span class="line"></span><br><span class="line">public:</span><br><span class="line">    Connection(<span class="type">int</span> sock, TcpServer *r) : sock_(sock), R_(r)</span><br><span class="line">    &#123;&#125;</span><br><span class="line">    <span class="type">void</span> <span class="title function_">SetRecver</span><span class="params">(<span class="type">func_t</span> recver)</span> &#123; recver_ = recver; &#125;</span><br><span class="line">    <span class="type">void</span> <span class="title function_">SetSender</span><span class="params">(<span class="type">func_t</span> sender)</span> &#123; sender_ = sender; &#125;</span><br><span class="line">    <span class="type">void</span> <span class="title function_">SetExcepter</span><span class="params">(<span class="type">func_t</span> excepter)</span> &#123; excepter_ = excepter; &#125;</span><br><span class="line">    ~Connection() &#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="2-TcpServer成员变量"><a href="#2-TcpServer成员变量" class="headerlink" title="2.TcpServer成员变量"></a>2.TcpServer成员变量</h4><p>再来看看tcpserver的成员变量有什么</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">private:</span><br><span class="line"><span class="comment">// 接收队列的长度</span></span><br><span class="line">    <span class="type">static</span> <span class="type">const</span> <span class="type">int</span> revs_num = <span class="number">64</span>;</span><br><span class="line">    <span class="comment">// 1. 网络socket</span></span><br><span class="line">    <span class="type">int</span> listensock_;</span><br><span class="line">    <span class="comment">// 2. epoll的fd</span></span><br><span class="line">    <span class="type">int</span> epfd_;</span><br><span class="line">    <span class="comment">// 3. 将epoll和上层代码进行结合，已有链接</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">unordered_map</span>&lt;<span class="type">int</span>, Connection *&gt; connections_;</span><br><span class="line">    <span class="comment">// 4. 就绪事件列表</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> *<span class="title">revs_</span>;</span></span><br><span class="line">    <span class="comment">// 5. 设置完整报文的处理回调方法</span></span><br><span class="line">    <span class="type">callback_t</span> cb_;</span><br></pre></td></tr></table></figure><h4 id="3-构造"><a href="#3-构造" class="headerlink" title="3.构造"></a>3.构造</h4><p>随后便是在构造函数中初始化这些成员变量，先是从<code>Sock.hpp</code>中获取到监听文件描述符，然后再通过Epoller类获取到epfd句柄，最后是将listensocket放入epoll的监听中；</p><p>这里的<code>std::bind</code>的作用，是将当前TcpServer的<code>this</code>指针绑定到<code>TcpServer::Accepter</code>函数的第一个参数上，否则在类外没有办法通过<code>Connection</code>类的回调指针来调用这个类的成员函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">TcpServer(<span class="type">callback_t</span> cb, <span class="type">int</span> port = <span class="number">8080</span>) : cb_(cb)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 当前监听的文件描述符及其事件</span></span><br><span class="line">    revs_ = new <span class="keyword">struct</span> epoll_event[revs_num]; </span><br><span class="line">    <span class="comment">// 网络功能</span></span><br><span class="line">    listensock_ = Sock::SocketInit();</span><br><span class="line">    Util::SetNonBlock(listensock_);</span><br><span class="line">    Sock::Bind(listensock_, port);</span><br><span class="line">    Sock::Listen(listensock_);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 多路转接</span></span><br><span class="line">    epfd_ = Epoller::CreateEpoller();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 添加listensock匹配的connection</span></span><br><span class="line">    AddConnection(listensock_, EPOLLIN | EPOLLET,</span><br><span class="line">                  <span class="built_in">std</span>::bind(&amp;TcpServer::Accepter, this, <span class="built_in">std</span>::placeholders::_1), nullptr, nullptr);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4-添加链接"><a href="#4-添加链接" class="headerlink" title="4.添加链接"></a>4.添加链接</h4><p>在<code>AddConnection</code>函数中，我们会将socket给添加到epfd中；如果这个epfd是使用了<code>EPOLLET</code>的ET模式，则还需要设置非阻塞；</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">AddConnection</span><span class="params">(<span class="type">int</span> sockfd, <span class="type">uint32_t</span> event, <span class="type">func_t</span> recver, <span class="type">func_t</span> sender, <span class="type">func_t</span> excepter)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (event &amp; EPOLLET)</span><br><span class="line">        Util::<span class="built_in">SetNonBlock</span>(sockfd);</span><br><span class="line">    <span class="comment">// 添加sockfd到epoll</span></span><br><span class="line">    Epoller::<span class="built_in">AddEvent</span>(epfd_, sockfd, event);</span><br><span class="line">    <span class="comment">// 将sockfd匹配的Connection也添加到当前的unordered_map中</span></span><br><span class="line">    Connection *conn = <span class="keyword">new</span> <span class="built_in">Connection</span>(sockfd, <span class="keyword">this</span>);</span><br><span class="line">    conn-&gt;<span class="built_in">SetRecver</span>(recver);</span><br><span class="line">    conn-&gt;<span class="built_in">SetSender</span>(sender);</span><br><span class="line">    conn-&gt;<span class="built_in">SetExcepter</span>(excepter);</span><br><span class="line"></span><br><span class="line">    connections_.<span class="built_in">insert</span>(std::<span class="built_in">make_pair</span>(sockfd, conn));</span><br><span class="line">    <span class="built_in">logMessage</span>(DEBUG, <span class="string">&quot;添加新链接到connections成功: %d&quot;</span>, sockfd);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>设置非阻塞的代码很简单，在前文已经演示过了</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Util</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">public:</span><br><span class="line">    <span class="type">static</span> <span class="type">void</span> <span class="title function_">SetNonBlock</span><span class="params">(<span class="type">int</span> fd)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> fl = fcntl(fd, F_GETFL);</span><br><span class="line">        fcntl(fd, F_SETFL, fl | O_NONBLOCK);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="5-析构"><a href="#5-析构" class="headerlink" title="5.析构"></a>5.析构</h4><p>在析构函数中，我们需要将listensocket和epfd两个文件描述符关闭，并析构掉链接数组</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">~<span class="built_in">TcpServer</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (listensock_ != <span class="number">-1</span>)</span><br><span class="line">        <span class="built_in">close</span>(listensock_);</span><br><span class="line">    <span class="keyword">if</span> (epfd_ != <span class="number">-1</span>)</span><br><span class="line">        <span class="built_in">close</span>(epfd_);</span><br><span class="line">    <span class="keyword">delete</span>[] revs_;</span><br><span class="line">    <span class="comment">// 还需要析构掉连接池中尚存在的connection对象</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span>&amp;c:connections_)&#123;</span><br><span class="line">        <span class="keyword">delete</span> c.second;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="6-获取新连接Accept"><a href="#6-获取新连接Accept" class="headerlink" title="6.获取新连接Accept"></a>6.获取新连接Accept</h4><p>在获取新连接这里，我们采用了一个死循环来获取。这是因为对于listensocket文件描述符而言，只要来了一个新链接，在ET模式下就会提示我们。但有可能会出现我们还没有来得及取走这个链接，就又来了一个新链接的情况（可以简化理解为一次性来了两个链接）</p><p>这时候因为ET的特性，我们就需要一次性取走所有链接；为了避免在Accept的时候，因为链接已经都被取走了而阻塞住，我们需要将listensocket设置为<strong>非阻塞</strong>；</p><blockquote><p>关于新链接为什么只关注读事件，在注释中有说明；</p></blockquote><p>对于listensocket来说，这个Accepter函数就是它的读事件回调，所以这个函数的参数也是一个<code>Connection *conn</code>对象，其是为了与其他事件处理函数统一（因为这个事件处理函数不在<code>Connection</code>类中，所以我们必须要获取一个对象才能访问到它的成员变量）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">Accepter</span><span class="params">(Connection *conn)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        std::string clientip;</span><br><span class="line">        <span class="type">uint16_t</span> clientport = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> sockfd = Sock::<span class="built_in">Accept</span>(conn-&gt;sock_, &amp;clientip, &amp;clientport);</span><br><span class="line">        <span class="keyword">if</span> (sockfd &lt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 接收函数被事件打断了</span></span><br><span class="line">            <span class="keyword">if</span> (errno == EINTR)</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            <span class="comment">// 本次数据没有准备好，可以理解为接收缓冲区空了</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (errno == EAGAIN || errno == EWOULDBLOCK)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">logMessage</span>(WARNING, <span class="string">&quot;accept error&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">logMessage</span>(DEBUG, <span class="string">&quot;get a new link: %d&quot;</span>, sockfd);</span><br><span class="line">        <span class="comment">// 注意：默认我们只设置了让epoll帮我们关心读事件，没有关心写事件</span></span><br><span class="line">        <span class="comment">// 为什么没有关注写事件：因为最开始的时候，写空间一定是就绪的！</span></span><br><span class="line">        <span class="comment">// 运行中可能才会存在写条件不满足 -- 写空间被写满了</span></span><br><span class="line">        <span class="built_in">AddConnection</span>(sockfd, EPOLLIN | EPOLLET,</span><br><span class="line">                      std::<span class="built_in">bind</span>(&amp;TcpServer::TcpRecver, <span class="keyword">this</span>, std::placeholders::_1),</span><br><span class="line">                      std::<span class="built_in">bind</span>(&amp;TcpServer::TcpSender, <span class="keyword">this</span>, std::placeholders::_1),</span><br><span class="line">                      std::<span class="built_in">bind</span>(&amp;TcpServer::TcpExcepter, <span class="keyword">this</span>, std::placeholders::_1));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">EAGAIN or EWOULDBLOCK</span><br><span class="line">The socket is marked nonblocking and the receive operation would block, or a receive timeout had been set and the timeout expired before data was received.  POSIX.1 allows either error to be returned for this case, and does not require these constants to have the same value, so  a  portable application should check for both possibilities.</span><br></pre></td></tr></table></figure><h4 id="7-链接的事件处理函数"><a href="#7-链接的事件处理函数" class="headerlink" title="7.链接的事件处理函数"></a>7.链接的事件处理函数</h4><p>其他链接的三个处理函数分别是<code>TcpRever/TcpSender/TcpExcepter</code>;</p><p>首先，在处理某一个链接的时候，我们必须要保证这个链接在已有的map里面，否则代表这个链接已经被关闭或者异常退出了；同理，在异常和关闭链接的处理流程中，我们也需要将链接从map中删除</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">IsExists</span><span class="params">(<span class="type">int</span> sock)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> iter = connections_.<span class="built_in">find</span>(sock);</span><br><span class="line">    <span class="keyword">if</span> (iter == connections_.<span class="built_in">end</span>())</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="读"><a href="#读" class="headerlink" title="读"></a>读</h5><p>对于读事件而言我们也是进行循环读取，该文件描述符也需要被设置为非阻塞。读取的内容拼接到该Connection对象的输入缓冲区string中；</p><p>在读取完毕后，我们需要在协议里面定义一个根据<strong>应用层协议字段</strong>来分离报文的函数（避免tcp的粘包问题），最终会得到一个string的数组，每个数组成员都是一个完整的报文；</p><p>最后，我们直接一个for循环，通过该tcpserver对象在初始化时候设置的<code>cb_</code>函数回调指针，来处理每一个报文（为每一个报文提供服务）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">TcpRecver</span><span class="params">(Connection *conn)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">char</span> buffer[<span class="number">1024</span>];</span><br><span class="line">        <span class="type">ssize_t</span> s = <span class="built_in">recv</span>(conn-&gt;sock_, buffer, <span class="built_in">sizeof</span>(buffer) - <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span> (s &gt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            buffer[s] = <span class="number">0</span>;</span><br><span class="line">            conn-&gt;inbuffer_ += buffer;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (s == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">logMessage</span>(DEBUG, <span class="string">&quot;client quit&quot;</span>);</span><br><span class="line">            conn-&gt;<span class="built_in">excepter_</span>(conn);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (errno == EINTR) <span class="comment">// 接收事件被打断</span></span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            <span class="comment">// 接收缓冲区空了</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (errno == EAGAIN || errno == EWOULDBLOCK)</span><br><span class="line">                <span class="keyword">break</span>; <span class="comment">// 跳出循环</span></span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// 出错了</span></span><br><span class="line">                <span class="built_in">logMessage</span>(DEBUG, <span class="string">&quot;recv error: %d:%s&quot;</span>, errno, <span class="built_in">strerror</span>(errno));</span><br><span class="line">                conn-&gt;<span class="built_in">excepter_</span>(conn);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 将本轮全部读取完毕</span></span><br><span class="line">    std::vector&lt;std::string&gt; result;</span><br><span class="line">    <span class="built_in">PackageSplit</span>(conn-&gt;inbuffer_, &amp;result);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;message : result)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cb_</span>(conn, message);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个框架的好处就在于，你可以单独实现不同协议的报文分离函数和数据服务函数，而不需要重写TcpServer的实现，相当于解耦；</p><h5 id="写"><a href="#写" class="headerlink" title="写"></a>写</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">TcpSender</span><span class="params">(Connection *conn)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">ssize_t</span> n = <span class="built_in">send</span>(conn-&gt;sock_, conn-&gt;outbuffer_.<span class="built_in">c_str</span>(), conn-&gt;outbuffer_.<span class="built_in">size</span>(), <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span>(n &gt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 去除已经成功发送的数据</span></span><br><span class="line">            conn-&gt;outbuffer_.<span class="built_in">erase</span>(<span class="number">0</span>, n);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 写入操作被打断</span></span><br><span class="line">            <span class="keyword">if</span>(errno == EINTR) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="comment">// 写入缓冲区满了，没办法继续写</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(errno == EAGAIN || errno == EWOULDBLOCK) <span class="keyword">break</span>; </span><br><span class="line">            <span class="keyword">else</span> <span class="comment">// 异常</span></span><br><span class="line">            &#123;</span><br><span class="line">                conn-&gt;<span class="built_in">excepter_</span>(conn);</span><br><span class="line">                <span class="built_in">logMessage</span>(DEBUG, <span class="string">&quot;send error: %d:%s&quot;</span>, errno, <span class="built_in">strerror</span>(errno));</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意，这里的写入如果遇到<code>(errno == EAGAIN || errno == EWOULDBLOCK)</code> 这两种情况，并不能确保输出缓冲区中的数据已经被全部写入了；有可能是写入缓冲区满了导致无法继续写入；</p><p>这种i情况下，我们需要判断<code>outbuffer</code>是否为空，如果不为空，则还是需要设置<code>EPOLLOUT</code>标记位，告知epoll继续帮我们关注写事件（这样epoll就会发信息告知Reactor，Reactor会重新调用写入函数，继续写入缓冲区的剩下数据）这个操作会在主执行流中进行统一判断</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 主执行流</span></span><br><span class="line">conn-&gt;<span class="built_in">sender_</span>(conn); <span class="comment">// 主执行流调用发送函数</span></span><br><span class="line"><span class="comment">// 判断本次是否发完毕了，没有发完毕还需要继续关心读写</span></span><br><span class="line"><span class="keyword">if</span>(conn-&gt;outbuffer_.<span class="built_in">empty</span>()) conn-&gt;R_-&gt;<span class="built_in">EnableReadWrite</span>(conn-&gt;sock_, <span class="literal">true</span>, <span class="literal">false</span>);</span><br><span class="line"><span class="keyword">else</span> conn-&gt;R_-&gt;<span class="built_in">EnableReadWrite</span>(conn-&gt;sock_, <span class="literal">true</span>, <span class="literal">true</span>);</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 打开或者关闭对于特定socket是否要关心读或者写</span></span><br><span class="line"><span class="comment">//- EnableReadWrite(sock, true, false); //只关心读</span></span><br><span class="line"><span class="comment">//- EnableReadWrite(sock, true, true);  //同时关心读写</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">EnableReadWrite</span><span class="params">(<span class="type">int</span> sock, <span class="type">bool</span> readable, <span class="type">bool</span> writeable)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">uint32_t</span> event = <span class="number">0</span>;</span><br><span class="line">    event |= (readable ? EPOLLIN : <span class="number">0</span>);</span><br><span class="line">    event |= (writeable ? EPOLLOUT : <span class="number">0</span>);</span><br><span class="line">    Epoller::<span class="built_in">ModEvent</span>(epfd_, sock, event);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h5><p>为了统一进行异常处理，在上文中当我们遇到读写出错的时候，都会调用这个函数；</p><p>在这个函数体内，会将链接从epoll中删除、关闭链接、释放connection对象、将文件描述符从map里面剔除；</p><p>需要注意的是，一定要先将socket从epoll里面剔除掉，再关闭socket！</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">TcpExcepter</span><span class="params">(Connection *conn)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 0. 判断有效性</span></span><br><span class="line">    <span class="keyword">if</span>(!<span class="built_in">IsExists</span>(conn-&gt;sock_)) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 所有的服务器异常，都会被归类到这里</span></span><br><span class="line">    <span class="comment">// 1. 删除epoll的监看</span></span><br><span class="line">    Epoller::<span class="built_in">DelEvent</span>(epfd_, conn-&gt;sock_);</span><br><span class="line">    <span class="built_in">logMessage</span>(DEBUG, <span class="string">&quot;remove epoll event!&quot;</span>);</span><br><span class="line">    <span class="comment">// 2. close</span></span><br><span class="line">    <span class="built_in">close</span>(conn-&gt;sock_);</span><br><span class="line">    <span class="built_in">logMessage</span>(DEBUG, <span class="string">&quot;close fd: %d&quot;</span>, conn-&gt;sock_);</span><br><span class="line">    <span class="comment">// 3. delete conn;</span></span><br><span class="line">    <span class="keyword">delete</span> connections_[conn-&gt;sock_];</span><br><span class="line">    <span class="built_in">logMessage</span>(DEBUG, <span class="string">&quot;delete connection object done&quot;</span>);</span><br><span class="line">    <span class="comment">// 4. erase conn;</span></span><br><span class="line">    connections_.<span class="built_in">erase</span>(conn-&gt;sock_);</span><br><span class="line">    <span class="built_in">logMessage</span>(DEBUG, <span class="string">&quot;erase connection from connections&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="8-运行"><a href="#8-运行" class="headerlink" title="8.运行"></a>8.运行</h4><p>对于TcpServer而言，一次的运行就是调用一次<code>epoll_wait</code>，再根据事件就绪的文件描述符，调用不同的事件处理函数</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Dispatcher</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n = Epoller::<span class="built_in">LoopOnce</span>(epfd_, revs_, revs_num);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> sock = revs_[i].data.fd;</span><br><span class="line">        <span class="type">uint32_t</span> revent = revs_[i].events;</span><br><span class="line">        <span class="comment">// 判断是否出现错误，如果出现了错误，那就把EPOLLIN和OUT都加上</span></span><br><span class="line">        <span class="comment">// 这样这个链接会进入下面的处理函数，并在处理函数中出现异常</span></span><br><span class="line">        <span class="comment">// 处理函数中出现异常回统一调用TcpExcpter函数</span></span><br><span class="line">        <span class="keyword">if</span>(revent &amp; EPOLLHUP) revent |= (EPOLLIN|EPOLLOUT);</span><br><span class="line">        <span class="keyword">if</span>(revent &amp; EPOLLERR) revent |= (EPOLLIN|EPOLLOUT);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (revent &amp; EPOLLIN)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">IsExists</span>(sock) &amp;&amp; connections_[sock]-&gt;recver_)</span><br><span class="line">                connections_[sock]-&gt;<span class="built_in">recver_</span>(connections_[sock]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 当链接的写事件被激活的时候，在这里就会触发写事件的处理</span></span><br><span class="line">        <span class="comment">// 所以并不需要在recv里面主动调用写事件处理函数</span></span><br><span class="line">        <span class="comment">// 只需要告诉epoll让它帮我们监控写事件，那么就会在这里触发写操作</span></span><br><span class="line">        <span class="keyword">if</span> (revent &amp; EPOLLOUT)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">IsExists</span>(sock) &amp;&amp; connections_[sock]-&gt;sender_)</span><br><span class="line">                connections_[sock]-&gt;<span class="built_in">sender_</span>(connections_[sock]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>整个服务器运行起来，就一直调用分发函数就OK啦~</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Run</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">Dispatcher</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="6-2-5-主执行流"><a href="#6-2-5-主执行流" class="headerlink" title="6.2.5 主执行流"></a>6.2.5 主执行流</h3><p>对于主执行流而言，要做的就是获取到命令行参数的端口，然后创建tcpserver对象并绑定事件处理函数</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;TcpServer.hpp&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Service.hpp&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">usage</span><span class="params">(std::string process)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cerr &lt;&lt; <span class="string">&quot;\nUsage: &quot;</span> &lt;&lt; process &lt;&lt; <span class="string">&quot; port\n&quot;</span></span><br><span class="line">         &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (argc != <span class="number">2</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">usage</span>(argv[<span class="number">0</span>]);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">TcpServer <span class="title">svr</span><span class="params">(HandlerRequest, atoi(argv[<span class="number">1</span>]))</span></span>;</span><br><span class="line">    svr.<span class="built_in">Run</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>事件处理函数可以做任意封装，来实现你自己想要的功能</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">HandlerRequest</span><span class="params">(Connection *conn, std::string &amp;message)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// beginhandler里面是具体的调用逻辑，calculator是本次事务处理函数</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">BeginHandler</span>(conn, message, calculator);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里就是我们单个完整报文的处理函数，在tcprecver方法里面被调用了；</p><p>根据上文描述的调用方法，我们可以确定，这里传入来的<code>message</code>肯定是一个完整的应用层报文，我们只需要创建一个属于我们自己的协议和协议中的数据处理函数就OK了！</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">BeginHandler</span><span class="params">(Connection *conn, std::string &amp;message, <span class="type">service_t</span> service)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// message一定是一个完整的报文，因为我们已经对它进行了解码</span></span><br><span class="line">    Request req;</span><br><span class="line">    <span class="comment">// 反序列化，进行处理的问题</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">Parser</span>(message, &amp;req))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 写回错误消息</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="comment">// 可以直接关闭连接</span></span><br><span class="line">        <span class="comment">// conn-&gt;excepter_(conn);</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 业务逻辑</span></span><br><span class="line">    Response resp = <span class="built_in">service</span>(req);</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; req.x &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; req.op &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; req.y &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; resp.code &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; resp.result &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 序列化</span></span><br><span class="line">    std::string sendstr;</span><br><span class="line">    <span class="built_in">Serialize</span>(resp, &amp;sendstr);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 处理完毕的结果，发送回给client</span></span><br><span class="line">    conn-&gt;outbuffer_ += sendstr;</span><br><span class="line">    conn-&gt;<span class="built_in">sender_</span>(conn);</span><br><span class="line">    <span class="keyword">if</span>(conn-&gt;outbuffer_.<span class="built_in">empty</span>()) conn-&gt;R_-&gt;<span class="built_in">EnableReadWrite</span>(conn-&gt;sock_, <span class="literal">true</span>, <span class="literal">false</span>);</span><br><span class="line">    <span class="keyword">else</span> conn-&gt;R_-&gt;<span class="built_in">EnableReadWrite</span>(conn-&gt;sock_, <span class="literal">true</span>, <span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;--- end ---&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="6-2-6-协议和数据处理"><a href="#6-2-6-协议和数据处理" class="headerlink" title="6.2.6 协议和数据处理"></a>6.2.6 协议和数据处理</h3><p>下面提供一个最基础的计算器协议，这个协议的好处是我们可以用telnet就模拟出请求，无需写一个tcp客户端。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">x 操作符 y#</span><br></pre></td></tr></table></figure><p>这个协议中，每个有效数据中都会带上一个空格，并以<code>#</code>作为单个报文的结尾；</p><p>响应和请求的结构体格式也非常简单，响应里面是状态码和计算结果；我们在协议中添加序列化和反序列化函数就可以将响应和请求结构体转成字符串</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Request</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line">    <span class="type">int</span> y;</span><br><span class="line">    <span class="type">char</span> op;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Response</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> code;</span><br><span class="line">    <span class="type">int</span> result;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>完整代码</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SEP <span class="string">&#x27;#&#x27;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SEP_LEN sizeof(SEP)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CRLF <span class="string">&quot;\r\n&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CRLF_LEN strlen(CRLF)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SPACE <span class="string">&quot; &quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SPACE_LEN strlen(SPACE)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 分离独立报文</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">PackageSplit</span><span class="params">(std::string &amp;inbuffer, std::vector&lt;std::string&gt; *result)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        std::<span class="type">size_t</span> pos = inbuffer.<span class="built_in">find</span>(SEP);</span><br><span class="line">        <span class="keyword">if</span> (pos == std::string::npos)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        result-&gt;<span class="built_in">push_back</span>(inbuffer.<span class="built_in">substr</span>(<span class="number">0</span>, pos));</span><br><span class="line">        inbuffer.<span class="built_in">erase</span>(<span class="number">0</span>, pos + SEP_LEN);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Request</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line">    <span class="type">int</span> y;</span><br><span class="line">    <span class="type">char</span> op;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Response</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> code;</span><br><span class="line">    <span class="type">int</span> result;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">Parser</span><span class="params">(std::string &amp;in, Request *req)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 1 + 1, 2 * 4, 5 * 9, 6 *1</span></span><br><span class="line">    std::<span class="type">size_t</span> spaceOne = in.<span class="built_in">find</span>(SPACE);</span><br><span class="line">    <span class="keyword">if</span> (std::string::npos == spaceOne)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    std::<span class="type">size_t</span> spaceTwo = in.<span class="built_in">rfind</span>(SPACE);</span><br><span class="line">    <span class="keyword">if</span> (std::string::npos == spaceTwo)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    std::string dataOne = in.<span class="built_in">substr</span>(<span class="number">0</span>, spaceOne);</span><br><span class="line">    std::string dataTwo = in.<span class="built_in">substr</span>(spaceTwo + SPACE_LEN);</span><br><span class="line">    std::string oper = in.<span class="built_in">substr</span>(spaceOne + SPACE_LEN, spaceTwo - (spaceOne + SPACE_LEN));</span><br><span class="line">    <span class="keyword">if</span> (oper.<span class="built_in">size</span>() != <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 转成内部成员</span></span><br><span class="line">    req-&gt;x = <span class="built_in">atoi</span>(dataOne.<span class="built_in">c_str</span>());</span><br><span class="line">    req-&gt;y = <span class="built_in">atoi</span>(dataTwo.<span class="built_in">c_str</span>());</span><br><span class="line">    req-&gt;op = oper[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Serialize</span><span class="params">(<span class="type">const</span> Response &amp;resp, std::string *out)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::string ec = std::<span class="built_in">to_string</span>(resp.code);</span><br><span class="line">    std::string res = std::<span class="built_in">to_string</span>(resp.result);</span><br><span class="line"></span><br><span class="line">    *out = ec;</span><br><span class="line">    *out += SPACE;</span><br><span class="line">    *out += res;</span><br><span class="line">    *out += CRLF;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在<code>service.hpp</code>里面则是数据处理的计算函数，通过我们传入的请求，计算出结构并构造响应返回给用户</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Protocol.hpp&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="type">service_t</span> = std::function&lt;<span class="built_in">Response</span> (<span class="type">const</span> Request &amp;req)&gt;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> Response <span class="title">calculator</span><span class="params">(<span class="type">const</span> Request &amp;req)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Response resp = &#123;<span class="number">0</span>, <span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">switch</span> (req.op)</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;+&#x27;</span>:</span><br><span class="line">        resp.result = req.x + req.y;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;-&#x27;</span>:</span><br><span class="line">        resp.result = req.x - req.y;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;*&#x27;</span>:</span><br><span class="line">        resp.result = req.x * req.y;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;/&#x27;</span>:</span><br><span class="line">    &#123; <span class="comment">// x_ / y_</span></span><br><span class="line">        <span class="keyword">if</span> (req.y == <span class="number">0</span>)</span><br><span class="line">            resp.code = <span class="number">-1</span>; <span class="comment">// -1. 除0</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            resp.result = req.x / req.y;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;%&#x27;</span>:</span><br><span class="line">    &#123; <span class="comment">// x_ / y_</span></span><br><span class="line">        <span class="keyword">if</span> (req.y == <span class="number">0</span>)</span><br><span class="line">            resp.code = <span class="number">-2</span>; <span class="comment">// -2. 模0</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            resp.result = req.x % req.y;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        resp.code = <span class="number">-3</span>; <span class="comment">// -3: 非法操作符</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> resp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="6-2-7-测试"><a href="#6-2-7-测试" class="headerlink" title="6.2.7 测试"></a>6.2.7 测试</h3><p>可以看到，我们的服务启动了之后，成功接收了一个链接，并计算出了我们发送的结果</p><p><img src="https://img.musnow.top/i/2023/08/5e164406ab4e280265a7fcd8fdc3de67.png" alt="image-20230828115411040"></p><p>多个链接也不在话下！</p><p><img src="https://img.musnow.top/i/2023/08/58a989acdf95c2dc2c89a1677f8a4d56.png" alt="image-20230828115525101"></p><h1 id="The-end"><a href="#The-end" class="headerlink" title="The end"></a>The end</h1><p>多路转接这部分是linux服务器最重要的一部分知识，因为大部分服务器都抛弃了最传统的一个线程维护一个链接这样的方式，而采用了多路转接来实现对大量进程的维护；</p><p>本文是学习阶段的产物，有错误在所难免，请大佬们指教！</p><p><img src="https://img.musnow.top/i/2023/08/56eecd58cac3b6593f83998c9f30eb4b.gif" alt="QQ图片20220413084241"></p>]]></content>
    
    
    <summary type="html">多路转接和高级IO</summary>
    
    
    
    <category term="玩上Linux" scheme="https://blog.musnow.top/categories/%E7%8E%A9%E4%B8%8ALinux/"/>
    
    
    <category term="Linux" scheme="https://blog.musnow.top/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>【C++】构造函数和初始化列表的性能差距</title>
    <link href="https://blog.musnow.top/posts/2628258650/"/>
    <id>https://blog.musnow.top/posts/2628258650/</id>
    <published>2023-08-24T13:55:38.000Z</published>
    <updated>2023-08-24T13:55:38.000Z</updated>
    
    <content type="html"><![CDATA[<p>构造函数和初始化列表的性能差距对比测试</p><span id="more"></span><h1 id="1-说明"><a href="#1-说明" class="headerlink" title="1.说明"></a>1.说明</h1><p>在C++类和对象中，你可能听到过更加推荐用初始化列表来初始化类内成员。如果类内成员是自定义类型，则只能在初始化列表中调用自定义类型的构造函数。</p><p>但初始化列表和在构造函数体内直接赋值有无性能差距呢？今天就用一份相对简单的代码来测试一下</p><h1 id="2-测试"><a href="#2-测试" class="headerlink" title="2.测试"></a>2.测试</h1><h2 id="2-1-代码说明"><a href="#2-1-代码说明" class="headerlink" title="2.1 代码说明"></a>2.1 代码说明</h2><p>首先是一个自定义类型，实现带缺省值的默认构造，拷贝构造和赋值重载这三个函数，并在内部新增打印来区分不同的函数</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">mytest</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">mytest</span>(<span class="type">int</span> a = <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        _a = a;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;mytest() &quot;</span> &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">mytest</span>(<span class="type">const</span> mytest&amp; st) &#123;</span><br><span class="line">        _a = st._a;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;mytest(copy) &quot;</span> &lt;&lt; st._a &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    mytest&amp; <span class="keyword">operator</span>=(<span class="type">const</span> mytest&amp; st)</span><br><span class="line">    &#123;</span><br><span class="line">        _a = st._a;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;mytest operator= &quot;</span> &lt;&lt; st._a &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> _a;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>再在另外一个类中使用这个自定义类型</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">myclass</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">myclass</span>(<span class="type">const</span> <span class="keyword">struct</span> mytest&amp; st, <span class="type">int</span> b)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;myclass() _b:&quot;</span> &lt;&lt; _b &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">mytest</span> _sa;</span><br><span class="line">    <span class="type">int</span> _b;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>此时构造函数就有两种写法，一种是在初始化列表中初始化这个自定义类型</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">myclass</span>(<span class="type">const</span> <span class="keyword">struct</span> mytest&amp; st, <span class="type">int</span> b)</span><br><span class="line">       :_sa(st),</span><br><span class="line">       _b(b)</span><br><span class="line">   &#123;</span><br><span class="line">       cout &lt;&lt; <span class="string">&quot;myclass() _b:&quot;</span> &lt;&lt; _b &lt;&lt; endl;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>另外一种是在构造函数体内通过赋值重载来初始化这个自定义类型</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">myclass</span>(<span class="type">const</span> <span class="keyword">struct</span> mytest&amp; st, <span class="type">int</span> b)</span><br><span class="line">&#123;</span><br><span class="line">     _sa = st;</span><br><span class="line">     _b = b;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;myclass() _b:&quot;</span> &lt;&lt; _b &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>需要注意的是，这里的自定义类型传参采用了引用传参，并不会因此产生额外的拷贝！</p><p>主函数体如下，为了区分第一个<code>mytest</code>的构造函数，我在其后新增了一行输出作为分割</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">mytest <span class="title">test_a</span><span class="params">(<span class="number">1</span>)</span></span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;------&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="function">myclass <span class="title">test</span><span class="params">(test_a, <span class="number">3</span>)</span></span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-2-测试"><a href="#2-2-测试" class="headerlink" title="2.2 测试"></a>2.2 测试</h2><p>先来看看使用赋值初始化的方式，可以看到，虽然我们在初始化列表中什么都没有写，但是这里<strong>依旧调用了默认的构造函数</strong>（因为默认构造函数的缺省值给的是<code>-1</code>，这里能通过参数判断出来这并不是我们显式调用的构造）</p><p>调用了默认构造后，又通过赋值重载来初始化了一遍<code>_sa</code>，相当于两次初始化</p><p><img src="https://img.musnow.top/i/2023/08/ce34a7ef5363f3de7ee7ee1034f75e04.png" alt="image-20230824212849577"></p><p>但如果调用初始化列表，则只会有一次拷贝构造，<strong>避免了额外的默认构造调用</strong>！</p><p><img src="https://img.musnow.top/i/2023/08/b9f31dd47442b86d7580fa6e779c1ef3.png" alt="image-20230824213021929"></p><p>在linux下也测试过了，结果和VS2019相同</p><h1 id="3-结论"><a href="#3-结论" class="headerlink" title="3.结论"></a>3.结论</h1><p>结论就出来了：初始化列表能节省一次默认构造的调用，优化性能！</p><h2 id="3-1-实际场景"><a href="#3-1-实际场景" class="headerlink" title="3.1 实际场景"></a>3.1 实际场景</h2><p>在上面的场景中，性能差距可能并不会特别大，但是在下面的场景中可能就不一样了</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">mytest</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">mytest</span>(<span class="type">int</span> sz = <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        _str = <span class="keyword">new</span> <span class="type">char</span>[sz];</span><br><span class="line">        _sz = sz;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;mytest() &quot;</span> &lt;&lt; sz &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">mytest</span>(<span class="type">const</span> mytest&amp; st) &#123;</span><br><span class="line">        <span class="keyword">delete</span> _str;<span class="comment">// 需要先销毁原视的数据</span></span><br><span class="line">        _str = <span class="keyword">new</span> <span class="type">char</span>[st._sz]; <span class="comment">// 再创建一个新的</span></span><br><span class="line">        _sz = st._sz;</span><br><span class="line">        <span class="comment">//省略拷贝数据的代码</span></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;mytest(copy) &quot;</span> &lt;&lt; st._sz &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    mytest&amp; <span class="keyword">operator</span>=(<span class="type">const</span> mytest&amp; st)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">delete</span> _str;<span class="comment">// 需要先销毁原视的数据</span></span><br><span class="line">        _str = <span class="keyword">new</span> <span class="type">char</span>[st._sz]; <span class="comment">// 再创建一个新的</span></span><br><span class="line">        <span class="comment">//省略拷贝数据的代码</span></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;mytest&amp; operator= &quot;</span> &lt;&lt; st._sz &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">char</span>* _str;</span><br><span class="line">    <span class="type">size_t</span> _sz;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">myclass</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">myclass</span>(<span class="type">const</span> <span class="keyword">struct</span> mytest&amp; st, <span class="type">int</span> b)</span><br><span class="line">        :_sa(st),</span><br><span class="line">        _b(b)</span><br><span class="line">    &#123;</span><br><span class="line">         <span class="comment">//_sa = st;</span></span><br><span class="line">         <span class="comment">//_b = b;</span></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;myclass() _b:&quot;</span> &lt;&lt; _b &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">mytest</span> _sa;</span><br><span class="line">    <span class="type">int</span> _b;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在这个场景中，因为<code>mytest</code>自定义类型的拷贝构造涉及到了深拷贝，此时就需要将已有的空间给销毁了，再new一片新的空间出来，再将数据给拷贝过去。</p><p>白白多了一层默认构造中的new空间的+拷贝构造中delete原有空间的消耗！</p><p>如果类中需要深拷贝的成员不止一个，那性能差距就更大！</p><p>所以在C++中，<strong>一律以初始化列表优先</strong>！</p><hr><p>这里顺带提一嘴初始化列表的小坑，也算是复习；</p><p>当你使用初始化列表来初始化类内成员的时候，初始化的顺序是类内成员声明的顺序，而<strong>不是初始化列表中的顺序</strong>！这点非常重要，如果顺序不对，可能会出现使用未定义（还没有初始化完成）的参数的bug！</p>]]></content>
    
    
    <summary type="html">构造函数和初始化列表的性能差距对比测试</summary>
    
    
    
    <category term="遇见C++" scheme="https://blog.musnow.top/categories/%E9%81%87%E8%A7%81C/"/>
    
    
    <category term="C++" scheme="https://blog.musnow.top/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>【牛客网】BM3链表中的节点每k个一组翻转</title>
    <link href="https://blog.musnow.top/posts/3391123821/"/>
    <id>https://blog.musnow.top/posts/3391123821/</id>
    <published>2023-08-24T06:05:28.000Z</published>
    <updated>2023-08-24T06:05:28.000Z</updated>
    
    <content type="html"><![CDATA[<p>BM3链表中的节点每k个一组翻转</p><span id="more"></span><h1 id="1-题目"><a href="#1-题目" class="headerlink" title="1.题目"></a>1.题目</h1><p><a href="https://www.nowcoder.com/practice/b49c3dc907814e9bbfa8437c251b028e?tpId=295&tqId=722&ru=/exam/company&qru=/ta/format-top101/question-ranking&sourceUrl=/exam/company"><strong>BM3 链表中的节点每k个一组翻转</strong></a></p><p>将给出的链表中的节点每 k 个一组翻转，返回翻转后的链表<br>如果链表中的节点数不是 k 的倍数，<strong>将最后剩下的节点保持原样</strong><br>你不能更改节点中的值，只能更改节点本身。</p><p><img src="https://img.musnow.top/i/2023/08/95cfbee58b6d1466bde50dd0daad2383.png" alt="image-20230824140620807"></p><h1 id="2-解析"><a href="#2-解析" class="headerlink" title="2.解析"></a>2.解析</h1><h2 id="2-1-链表逆置"><a href="#2-1-链表逆置" class="headerlink" title="2.1 链表逆置"></a>2.1 链表逆置</h2><p>其他部分其实很好解决，基于链表逆置的代码（即逆置整个链表的代码）</p><p>我们只需要将每一个需要逆置的小区间的开头给记下来，交付给链表逆置就可以了。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 无差别逆置</span></span><br><span class="line"><span class="function">ListNode* <span class="title">reverseNode</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="literal">nullptr</span> || head-&gt;next == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ListNode* ans = <span class="built_in">reverseNode</span>(head-&gt;next);</span><br><span class="line">    head-&gt;next-&gt;next = head;</span><br><span class="line">    head-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-2-记录每个需要逆置的区间"><a href="#2-2-记录每个需要逆置的区间" class="headerlink" title="2.2 记录每个需要逆置的区间"></a>2.2 记录每个需要逆置的区间</h2><p>比如如下部分代码，为了方便进行遍历和指针控制，我创建了一个头节点放置在了原本链表开头</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 头节点和遍历指针</span></span><br><span class="line"><span class="function">ListNode <span class="title">phead</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br><span class="line">phead.next = head;</span><br><span class="line">ListNode* cur = &amp;phead;</span><br><span class="line"><span class="comment">// 把每k个节点单独取出来，分别逆置后链接起来</span></span><br><span class="line">std::vector&lt;ListNode*&gt; begin_node_v,begin_node_prev_v;</span><br><span class="line"><span class="type">int</span> index = k<span class="number">-1</span>; <span class="comment">// 初始化为k-1(忽略头节点)，原有链表第一个节点始终入栈</span></span><br><span class="line"><span class="type">int</span> node_count = <span class="number">0</span>;<span class="comment">// 节点总数（包含头节点）</span></span><br><span class="line"><span class="keyword">while</span> (cur != <span class="literal">nullptr</span>) &#123; <span class="comment">// 不知道有多长，得死循环</span></span><br><span class="line">    <span class="keyword">if</span>(index+<span class="number">1</span> == k &amp;&amp; cur != &amp;phead)&#123;</span><br><span class="line">        begin_node_prev_v.<span class="built_in">push_back</span>(cur);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (index == k) &#123;</span><br><span class="line">        begin_node_v.<span class="built_in">push_back</span>(cur);</span><br><span class="line">        index = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cur = cur-&gt;next;</span><br><span class="line">    index++;</span><br><span class="line">    node_count ++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里还创建了两个vector数组</p><ul><li><code>begin_node_v</code>：待逆置区间的开头</li><li><code>begin_node_prev_v</code>：待逆置区间的开头的上一个</li></ul><p>下面是对这两个数组的说明，如果给出的示例是如下形式</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;1,2,3,4,5&#125;,2</span><br></pre></td></tr></table></figure><p>那么两个数组分别存储了如下值</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">begin_node_v:     &#123;1,3,5&#125;</span><br><span class="line">begin_node_prev_v: &#123;2,4&#125;</span><br></pre></td></tr></table></figure><p>这样一来，第一个数组实际上存放的是每个区间的<strong>开头</strong>，第二个数组存放的则是每个区间的<strong>结尾</strong>。<strong>逆置了之后</strong>:</p><ul><li>第二个数组就是新区间的开头</li><li>第一个数组就是新区间的结尾</li></ul><p>方便我们将逆置后的链表重新连起来！</p><h2 id="2-3-抛弃无需逆置的区间"><a href="#2-3-抛弃无需逆置的区间" class="headerlink" title="2.3 抛弃无需逆置的区间"></a>2.3 抛弃无需逆置的区间</h2><p>在上面的循环中，用了<code>node_count</code>来计算了整个链表的长度，减1剔除我自己添加的头节点，就是原始链表的长度。</p><p>题目有个特殊要求：如果原始链表的长度并非k的整数倍，那么最后一段区域的链表是不需要逆置的</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1 - 2 - 3 - 4 - 5</span><br><span class="line">当k=3的时候，只需要逆置 1-2-3</span><br><span class="line">            4-5不需要逆置</span><br><span class="line">3 - 2 - 1 - 4 - 5</span><br></pre></td></tr></table></figure><p>在这种情况，用例和两个数组存放的节点如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">用例 &#123;1,2,3,4,5&#125;,3</span><br><span class="line"></span><br><span class="line">begin_node_v:     &#123;1,4&#125;</span><br><span class="line">begin_node_prev_v: &#123;3&#125;</span><br></pre></td></tr></table></figure><p>如果我们直接将<code>begin_node_v</code>里面的节点交付给链表逆置函数，就会将<code>4-5</code>这一段夜给逆置，最终返回的结果是<code>3-2-1-5-4</code>，不符合题目要求！</p><p>所以在这种情况下，我们需要将4从第一个数组中删除！如果原视链表的节点数量已经小于k了，则也不需要逆置，直接返回即可。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 如果节点总数量小于k则不逆置直接返回</span></span><br><span class="line">node_count --;<span class="comment">//减-1 头节点</span></span><br><span class="line"><span class="keyword">if</span>(node_count &lt;k)&#123;</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 不是整数倍，代表最后一个是不要处理的</span></span><br><span class="line">ListNode* last_link = <span class="literal">nullptr</span>; </span><br><span class="line"><span class="keyword">if</span>((node_count %k) != <span class="number">0</span>) &#123;</span><br><span class="line">    last_link = begin_node_v[begin_node_v.<span class="built_in">size</span>()<span class="number">-1</span>];<span class="comment">// 最后一个</span></span><br><span class="line">    begin_node_v.<span class="built_in">pop_back</span>();<span class="comment">// 删除最后一个</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>另外，为了最终将这段么有逆置的链表和新链表连起来，我们还需用一个指针记录下这一段的开头；<code>last_link</code>初始化为空是方便后续的判断，如果为空代表不存在这一段链表，不需要链接。</p><h2 id="2-4-区间结束标识"><a href="#2-4-区间结束标识" class="headerlink" title="2.4 区间结束标识"></a>2.4 区间结束标识</h2><p>为了标识每次逆置的结束符，我们还需要将待逆置的每一个小区间的末尾都改成<code>nullptr</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将每个区间的末尾节点的next链接为Null作为递归标识</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span>&amp;n:begin_node_prev_v)&#123;</span><br><span class="line">    n-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-5-逆置和重新链接"><a href="#2-5-逆置和重新链接" class="headerlink" title="2.5 逆置和重新链接"></a>2.5 逆置和重新链接</h2><p>上面的步骤都敲定了之后，我们就可以将第一个数组<code>begin_node_v</code>的节点喂给链表逆置函数了，该逆置函数的返回值是新链表的开头。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将每个区间交付给递归开始逆置，并将逆置的返回值与上一个区间的开头连起来</span></span><br><span class="line">cur = &amp;phead;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span>&amp; n:begin_node_v)&#123;</span><br><span class="line">    ListNode* ptr=<span class="built_in">reverseNode</span>(n);</span><br><span class="line">    cur-&gt;next = ptr;</span><br><span class="line">    cur = n;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里说一下cur指针的作用，以用例<code>&#123;1,2,3,4,5&#125;,2</code>为栗子，此时<code>begin_node_v</code>数组中存放的是<code>&#123;1,3,5&#125;</code></p><ul><li>初始化为phead</li><li>第一次循环，n指向的是1，cur指向的是phead；逆置结束后，ptr指向的是2，刚好就是新链表的开头，将cur的next链接为它，并将cur更新为1</li><li>第二次循环，n指向的是3，cur指向的是1；逆置结束后，ptr指向的是4，此时cur的next指向它，就是将1的next链接为4，再次更新cur为3。</li><li>第三次循环，n指向的是5，cur指向的是3；逆置结束后，将3的next链接为5，cur更新为5</li><li>循环结束</li></ul><p>结束时，这个链表就已经完工了！我们只需要判断一下还没有剩下的没有逆置的节点，将其链接给<code>begin_node_v</code>数组中的最后一个节点（也是逆置部分的最后一个节点）的next就可以了</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 判断是否还有剩下的节点</span></span><br><span class="line"><span class="keyword">if</span>(last_link !=<span class="literal">nullptr</span>)&#123;</span><br><span class="line">    begin_node_v[begin_node_v.<span class="built_in">size</span>()<span class="number">-1</span>]-&gt;next = last_link;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="3-完整代码"><a href="#3-完整代码" class="headerlink" title="3.完整代码"></a>3.完整代码</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * @param head ListNode类</span></span><br><span class="line"><span class="comment">     * @param k int整型</span></span><br><span class="line"><span class="comment">     * @return ListNode类</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="comment">// 无差别逆置</span></span><br><span class="line">    <span class="function">ListNode* <span class="title">reverseNode</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="literal">nullptr</span> || head-&gt;next == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ListNode* ans = <span class="built_in">reverseNode</span>(head-&gt;next);</span><br><span class="line">        head-&gt;next-&gt;next = head;</span><br><span class="line">        head-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">cout_vector</span><span class="params">(std::vector&lt;ListNode*&gt;&amp; begin_node_v)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; e : begin_node_v) &#123;</span><br><span class="line">            cout &lt;&lt; e-&gt;val &lt;&lt; <span class="string">&quot; &quot;</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">ListNode* <span class="title">reverseKGroup</span><span class="params">(ListNode* head, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 只有一个节点，或者逆置区间为1的都不需要操作</span></span><br><span class="line">        <span class="keyword">if</span> (head == <span class="literal">nullptr</span> || head-&gt;next == <span class="literal">nullptr</span> || k &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 头节点和遍历指针</span></span><br><span class="line">        <span class="function">ListNode <span class="title">phead</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br><span class="line">        phead.next = head;</span><br><span class="line">        ListNode* cur = &amp;phead;</span><br><span class="line">        <span class="comment">// 把每k个节点单独取出来，分别逆置后链接起来</span></span><br><span class="line">        std::vector&lt;ListNode*&gt; begin_node_v,begin_node_prev_v;</span><br><span class="line">        <span class="type">int</span> index = k<span class="number">-1</span>; <span class="comment">// 初始化为k-1(忽略头节点)，原有链表第一个节点始终入栈</span></span><br><span class="line">        <span class="type">int</span> node_count = <span class="number">0</span>;<span class="comment">// 节点总数（包含头节点）</span></span><br><span class="line">        <span class="keyword">while</span> (cur != <span class="literal">nullptr</span>) &#123; <span class="comment">// 不知道有多长，得死循环</span></span><br><span class="line">            <span class="keyword">if</span>(index+<span class="number">1</span> == k &amp;&amp; cur != &amp;phead)&#123;</span><br><span class="line">                begin_node_prev_v.<span class="built_in">push_back</span>(cur);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (index == k) &#123;</span><br><span class="line">                begin_node_v.<span class="built_in">push_back</span>(cur);</span><br><span class="line">                index = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            cur = cur-&gt;next;</span><br><span class="line">            index++;</span><br><span class="line">            node_count ++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 走到这里已经把每个需要逆置的开头节点给记录下来了</span></span><br><span class="line">        <span class="comment">// 如果节点总数量小于k则不逆置直接返回</span></span><br><span class="line">        node_count --;<span class="comment">//减-1 头节点</span></span><br><span class="line">        <span class="keyword">if</span>(node_count &lt;k)&#123;</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 不是整数倍，代表最后一个是不要处理的</span></span><br><span class="line">        ListNode* last_link = <span class="literal">nullptr</span>; </span><br><span class="line">        <span class="keyword">if</span>((node_count %k) != <span class="number">0</span>) &#123;</span><br><span class="line">            last_link = begin_node_v[begin_node_v.<span class="built_in">size</span>()<span class="number">-1</span>];<span class="comment">// 最后一个</span></span><br><span class="line">            begin_node_v.<span class="built_in">pop_back</span>();<span class="comment">// 删除最后一个</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// cout_vector(begin_node_v);</span></span><br><span class="line">        <span class="comment">// cout_vector(begin_node_prev_v);</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将每个区间的末尾节点的next链接为Null作为递归标识</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span>&amp;n:begin_node_prev_v)&#123;</span><br><span class="line">            n-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 将每个区间交付给递归开始逆置，并将逆置的返回值与上一个区间的开头连起来</span></span><br><span class="line">        cur = &amp;phead;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; n:begin_node_v)&#123;</span><br><span class="line">            ListNode* ptr=<span class="built_in">reverseNode</span>(n);</span><br><span class="line">            cur-&gt;next = ptr;</span><br><span class="line">            cur = n;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 判断是否还有剩下的节点</span></span><br><span class="line">        <span class="keyword">if</span>(last_link !=<span class="literal">nullptr</span>)&#123;</span><br><span class="line">            begin_node_v[begin_node_v.<span class="built_in">size</span>()<span class="number">-1</span>]-&gt;next = last_link;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> phead.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>通过截图</p><p><img src="https://img.musnow.top/i/2023/08/591fcb7e890e13ec8638e0eb567790e9.png" alt="image-20230824142627806"></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;BM3链表中的节点每k个一组翻转&lt;/p&gt;</summary>
    
    
    
    <category term="把题目都给刷干净" scheme="https://blog.musnow.top/categories/%E6%8A%8A%E9%A2%98%E7%9B%AE%E9%83%BD%E7%BB%99%E5%88%B7%E5%B9%B2%E5%87%80/"/>
    
    
    <category term="C++" scheme="https://blog.musnow.top/tags/C/"/>
    
    <category term="OJ刷题" scheme="https://blog.musnow.top/tags/OJ%E5%88%B7%E9%A2%98/"/>
    
    <category term="牛客网" scheme="https://blog.musnow.top/tags/%E7%89%9B%E5%AE%A2%E7%BD%91/"/>
    
  </entry>
  
  <entry>
    <title>【C++】早绑定、析构与多态 | 一道关于多态的选择题记录</title>
    <link href="https://blog.musnow.top/posts/2254346194/"/>
    <id>https://blog.musnow.top/posts/2254346194/</id>
    <published>2023-08-22T13:14:28.000Z</published>
    <updated>2023-08-22T13:14:28.000Z</updated>
    
    <content type="html"><![CDATA[<p>今天在和群友聊天的时候看到了一道很坑的题目，分享给大家</p><span id="more"></span><h1 id="1-看题！"><a href="#1-看题！" class="headerlink" title="1.看题！"></a>1.看题！</h1><p>先来看看题目</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Dad</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Dad</span>()&#123; <span class="built_in">echo</span>();&#125;</span><br><span class="line">    ~<span class="built_in">Dad</span>()&#123; <span class="built_in">echo</span>();&#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">echo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;DAD &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Son</span>:Dad</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">echo</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;SON &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Son ss;</span><br></pre></td></tr></table></figure><p>请问这个的输出是什么？</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">A  &quot;DAD DAD &quot;</span><br><span class="line">B  &quot;DAD SON &quot;</span><br><span class="line">C  &quot;SON DAD &quot;</span><br><span class="line">D  &quot;SON SON &quot;</span><br><span class="line">E  编译出错</span><br><span class="line">F  运行出错</span><br></pre></td></tr></table></figure><blockquote><p>答案是E，编译出错！</p></blockquote><h1 id="2-涉及到的知识点"><a href="#2-涉及到的知识点" class="headerlink" title="2.涉及到的知识点"></a>2.涉及到的知识点</h1><h2 id="2-1-知识点"><a href="#2-1-知识点" class="headerlink" title="2.1 知识点"></a>2.1 知识点</h2><p>先来说说这道题目里面涉及到了什么知识点</p><ul><li>多态调用；</li><li>多态重写函数需要满足什么条件；</li><li>类内函数后加<code>const</code>的作用；</li><li>类内函数后加<code>override</code>的作用；</li><li>什么是早绑定和晚绑定</li></ul><p>一个一个复习吧！</p><ul><li>多态调用是父类指针&#x2F;引用指向子类时，调用虚函数会调用子类重写后的版本</li><li>多态重写函数的条件：函数名&#x2F;参数&#x2F;返回值都必须相同（注意还有协变）</li><li>类内函数后加<code>const</code>修饰的是这个对象的<code>this</code>指针，被修饰的函数中无法修改类内成员变量</li><li>类内函数后加<code>override</code>是让编译器来严格检查是否构成重载</li><li>早绑定：静态绑定；晚绑定：动态绑定（具体请看<a href="https://blog.musnow.top/posts/3933786088/">CPP多态</a>的博客）</li></ul><h2 id="2-2-分析题目"><a href="#2-2-分析题目" class="headerlink" title="2.2 分析题目"></a>2.2 分析题目</h2><p>注意看父类和子类中这两个<code>echo()</code>函数的区别</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">echo</span><span class="params">()</span></span>&#123;&#125;<span class="comment">//父类</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">echo</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">override</span> </span>&#123;&#125;<span class="comment">//子类</span></span><br></pre></td></tr></table></figure><p>首先需要说明的是，子类函数中<code>virtual</code>关键字是可以省略的，但即便省略了，这个函数依旧是个虚函数。</p><p>这里子类的函数中多了<code>const</code>修饰，而这个const修饰的就是函数中隐含的<code>this</code>指针，此时子类中<code>echo()</code>函数的参数就发生了变化！</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">echo</span><span class="params">(Son* <span class="keyword">this</span>)</span> </span>&#123; &#125; <span class="comment">// 不加const</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">echo</span><span class="params">(<span class="type">const</span> Son* <span class="keyword">this</span>)</span> </span>&#123; &#125; <span class="comment">// 加const</span></span><br></pre></td></tr></table></figure><p>正是因为这里的this指针出现了const的修饰，所以子类的echo和父类echo的参数类型不同，不构成虚函数重写！再加上<code>override</code>关键字的严格检查，会直接编译报错！</p><p>正确的写法是删除子类echo中的const或者给父类echo函数加上const</p><h1 id="3-再来看题"><a href="#3-再来看题" class="headerlink" title="3.再来看题"></a>3.再来看题</h1><p>好了，坑人的点看完了，再来看个「常规」的，就是把上面的题干改成能编译通过的。此时又应该选谁呢？</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Dad</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Dad</span>()&#123; <span class="built_in">echo</span>();&#125;</span><br><span class="line">    ~<span class="built_in">Dad</span>()&#123; <span class="built_in">echo</span>();&#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">echo</span><span class="params">()</span> <span class="type">const</span></span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;DAD &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Son</span>:Dad</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">echo</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;SON &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Son ss;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">A  &quot;DAD DAD &quot;</span><br><span class="line">B  &quot;DAD SON &quot;</span><br><span class="line">C  &quot;SON DAD &quot;</span><br><span class="line">D  &quot;SON SON &quot;</span><br></pre></td></tr></table></figure><p><img src="https://img.musnow.top/i/2023/08/e278c7b0a62e7383e4151067de284350.png" alt="image-20230822211806379"></p><p>编译运行，可以看到，结果是<code>DAD DAD</code>，应该选A</p><h2 id="3-1-分析"><a href="#3-1-分析" class="headerlink" title="3.1 分析"></a>3.1 分析</h2><p>在给 <code>Son</code> 类定义构造函数和析构函数时，没有指定调用父类的对应构造函数和析构函数。因此，在创建 <code>Son</code> 对象 <code>ss</code> 时，会默认调用 <code>Dad</code> 类的构造函数和析构函数。</p><p>由于 <code>Dad</code> 类中的构造函数和析构函数调用了虚函数 <code>echo()</code>，而这个虚函数在子类 <code>Son</code> 中被重写，所以会根据对象类型调用相应的重写函数。然而，在构造函数和析构函数中，虚函数机制不会按照预期工作。</p><p>构造函数中调用虚函数时，会忽略动态绑定机制，直接调用父类的函数版本。因此，在 <code>Dad</code> 的构造函数中调用 <code>echo()</code>，实际上调用的是 <code>Dad</code> 类中的 <code>echo()</code> 函数，而不是 <code>Son</code> 类中的重写版本。</p><p>同样地，析构函数中也会忽略动态绑定机制，直接调用父类的函数版本。所以，在 <code>Dad</code> 的析构函数中调用 <code>echo()</code>，依然调用的是 <code>Dad</code> 类中的 <code>echo()</code> 函数。</p><p>因此，当创建 <code>Son</code> 对象 <code>ss</code> 并打印输出时，会先调用 <code>Dad</code> 类的构造函数并打印 <code>&quot;DAD &quot;</code>，然后调用 <code>Dad</code> 类的析构函数并再次打印 <code>&quot;DAD &quot;</code>。</p><h2 id="3-2-结论"><a href="#3-2-结论" class="headerlink" title="3.2 结论"></a>3.2 结论</h2><p>在父类的构造和析构中，对象的版本都被确定为父类的版本，会采用<strong>早绑定</strong>来调用父类自己的函数，而不是子类的重写后的函数；</p><p>简单记忆：父类的构造和析构中如果出现虚函数，只会调用父类自己的函数！</p><hr><p>这是因为编译器需要保证正确的构造和析构顺序，<strong>如果父类析构里调用子类的虚函数</strong>，可能会出现下面的场景</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Dad</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Dad</span>()&#123; <span class="built_in">echo</span>();&#125;</span><br><span class="line">    ~<span class="built_in">Dad</span>()&#123; <span class="built_in">echo</span>();&#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">echo</span><span class="params">()</span> <span class="type">const</span></span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;DAD &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Son</span>:Dad</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Son</span>() &#123;</span><br><span class="line">        _a = <span class="keyword">new</span> <span class="built_in">int</span>(<span class="number">3</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    ~<span class="built_in">Son</span>() &#123;</span><br><span class="line">        <span class="keyword">delete</span> _a;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">echo</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;SON &quot;</span>;</span><br><span class="line">        <span class="keyword">delete</span> _a;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> _a;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Son ss;</span><br></pre></td></tr></table></figure><p>如果父类中的析构<code>echo()</code>调用子类重写的函数，此时就会出现子类已经被销毁（子类的析构函数早于父类析构调用）的<code>_a</code>被二次<code>delete</code>，两次<code>delete</code>同一片空间是会报错的！</p><p>所以为了避免这种情况，父类的析构中采用早绑定，子类重写的虚函数不会生效！</p><p>这种行为是为了确保在对象的构造和析构过程中，<strong>按照正确的顺序调用各个类的构造和析构函数</strong>，避免在对象处于未完全初始化或已部分销毁状态时调用子类的函数。</p><blockquote><p>包括父类的构造也可以这么理解，如果父类构造里面可以调用子类的虚函数，可能会出现两次对一个子类对象进行new空间，会产生内存泄露；</p><p>但构造函数还和虚函数表的初始化有关系，此时虚函数表还没有完全初始化，<strong>子类对象尚未构造完成</strong>，没有多态调用的条件，所以也不能调用到子类重写后的虚函数。</p></blockquote>]]></content>
    
    
    <summary type="html">&lt;p&gt;今天在和群友聊天的时候看到了一道很坑的题目，分享给大家&lt;/p&gt;</summary>
    
    
    
    <category term="把题目都给刷干净" scheme="https://blog.musnow.top/categories/%E6%8A%8A%E9%A2%98%E7%9B%AE%E9%83%BD%E7%BB%99%E5%88%B7%E5%B9%B2%E5%87%80/"/>
    
    
    <category term="C++" scheme="https://blog.musnow.top/tags/C/"/>
    
    <category term="OJ刷题" scheme="https://blog.musnow.top/tags/OJ%E5%88%B7%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>【网络】IP网络层和数据链路层</title>
    <link href="https://blog.musnow.top/posts/3482559497/"/>
    <id>https://blog.musnow.top/posts/3482559497/</id>
    <published>2023-08-21T12:22:36.000Z</published>
    <updated>2023-08-22T04:05:36.000Z</updated>
    
    <content type="html"><![CDATA[<p>IP协议详解</p><span id="more"></span><h1 id="1-概念"><a href="#1-概念" class="headerlink" title="1.概念"></a>1.概念</h1><h2 id="1-1-四层模型"><a href="#1-1-四层模型" class="headerlink" title="1.1 四层模型"></a>1.1 四层模型</h2><ul><li>应用层：解决如何传输数据（依照什么格式&#x2F;协议处理数据）的问题</li><li>传输层：解决可靠性问题</li><li>网络层：数据往哪里传，怎么找到目标主机</li><li>数据链路层（物理层）：数据在物理硬件层面上传输</li></ul><p>网络层的IP协议，就是让网络，拥有将数据从A主机发送到B主机的能力。</p><blockquote><p>注意：拥有此能力，并不代表每次都能成功送达！（即可靠性非100%）</p></blockquote><p>而失败的时候，就需要<strong>传输层</strong>来获取发生错误的原因，并进行错误重传或者超时重传等操作。</p><p>所以，在从网络层获取到信息成功送达到对方的反馈之前，传输层需要暂时保留已经发送的数据。如果网络层发送失败了，传输层需要进行重发操作，以保证可靠性。</p><p><img src="https://img.musnow.top/i/2023/02/2023e40723a2e8f8c6b0662d97d468537cbb.jpeg"></p><h2 id="1-2-主机、路由器、节点"><a href="#1-2-主机、路由器、节点" class="headerlink" title="1.2 主机、路由器、节点"></a>1.2 主机、路由器、节点</h2><ul><li>主机：拥有IP地址，但不进行路由控制的设备</li><li>路由器：拥有IP地址，并进行路由控制的设备</li><li>节点：主机和路由器的统称</li></ul><h1 id="2-IP报文"><a href="#2-IP报文" class="headerlink" title="2.IP报文"></a>2.IP报文</h1><h2 id="2-1-报文结构"><a href="#2-1-报文结构" class="headerlink" title="2.1 报文结构"></a>2.1 报文结构</h2><p>IP协议的报文与TCP的报文有一定程度上的相似</p><p>下图为IPV4中报文的格式（IPV6的报文和下图是不同的）</p><p><img src="https://img.musnow.top/i/2023/07/f93a3878d288a436d0a9f8320202f3c0.png" alt="image-20230724122812011"></p><ul><li>四位版本号：指定IP协议的版本，IPV4来说就是4</li><li>四位首部长度：IP报头的长度（和TCP的定义一样，标准长度需要用<code>四位首部长度 * 4字节</code>，即最大报头长度为<code>15*4=60</code>字节）</li><li>八位服务类型：包含3位优先权字段（已经弃用）、4位TOS字段和1位保留字段（必须置为0）四位TOS分别表示：<strong>最大吞吐量、最高可靠性、最小成本、最小延时</strong>。只能四选一，需要根据具体传输层的协议要求进行选择。</li><li>十六位总长度：包括报头的整个报文的长度，减去四位首部长度就能得出报文中数据字段的长度。</li><li>十六位首部校验和：使用CRC校验来判断报头是否有数据损坏</li><li>八位协议：上层协议类型（比如tcp、udp、ssh等）解决如何向上层交付的问题</li><li>八位生存时间（TTL）：用于控制IP报文能在网络层传输的时间（生命周期的限制）比如有些报文由于路由时出现了错误，陷入了路由的死循环；亦或者是路由程序出现了BUG，导致没办法被正常转发到正确的主机上；还有路由超时的问题。<strong>此时这个出错的报文就会在路由里面长时间游离而没办法抵达目的地</strong>（好比内存泄露）。规定了TTL之后，可以在IP报头中中记录报文的生命周期时间，当报文转发的耗时已经大于这个TTL之后，就将这个报文丢弃。</li><li>三十二位源地址和三十二位位目标地址：表示发送端IP和接收端IP</li><li>选项字段：不定长，最多40字节（这是因为首部默认是20字节，再加上首部长度最多只能表示60个字节，所以选项字段就是 <code>60-20=40</code>）</li><li>此处省略了几个字段，会在后文的<strong>分片</strong>中说明……</li></ul><p>IP协议的报文中没有端口号，因为端口号是<strong>传输层应该解决</strong>的事情（UDP和TCP的报头中才有端口号的字段）IP层只关注如何将报文发送给目标主机。也就是两个主机之间如何正常通信的问题。</p><h2 id="2-2-分片"><a href="#2-2-分片" class="headerlink" title="2.2 分片"></a>2.2 分片</h2><h3 id="2-2-1-认识MTU"><a href="#2-2-1-认识MTU" class="headerlink" title="2.2.1 认识MTU"></a>2.2.1 认识MTU</h3><p>MTU相<span id="jump1">当于</span>发快递时对包裹尺寸的限制，这个限制是不同的<strong>数据链路层</strong>对应的物理层产生的限制。</p><ul><li>以太网帧中的数据长度规定最小46字节，最大1500字节；</li><li>ARP数据包的长度不够46字节。要在后面补填充位；</li><li>最大值1500称为以太网的最大传输单元(MTU)，不同的网络类型有不同的MTU；</li><li>如果一个数据包从以太网路由到拨号链路上，数据包长度大于拨号链路的MTU了，则需要对数据包进行分片(fragmentation)；</li><li>不同的数据链路层标准的MTU是不同的；</li></ul><p>所以，数据链路层不支持过大的数据，这就需要在网络层对数据进行分片。</p><p>而网络层IP协议会<strong>自动</strong>帮我们分片，并在接收端组装。这个行为对传输层来说是不需要关注的，在<strong>四层模型</strong>中，每一层之间的功能需要进行解耦。</p><p>分片之后，只要有一个分片报文丢失，这个报文的整体就会认为丢失了（因为没有办法拼出完整的报文数据）</p><hr><p>但这样就引出了一个问题：<strong>分片会提高丢包的概率</strong>，影响传输速率（发一次快递和发三次快递，明显三次快递丢东西的可能性更高）</p><p>对于具有可靠性机制的TCP而言，丢包问题不大，我们可以在传输层进行重传。但UDP没有可靠性，此时出现分片后丢包了就没办法找回了。</p><p>所以，网络层进行分片并不是主流！相比之下，在传输层就进行分片才是更好的选择。</p><h3 id="2-2-2-如何分片"><a href="#2-2-2-如何分片" class="headerlink" title="2.2.2 如何分片"></a>2.2.2 如何分片</h3><p>在IP报头中，如下字段就是用于分片和组装操作的</p><p><img src="https://img.musnow.top/i/2023/07/4245674fedcf6b9d43b2845083017f26.png" alt="image-20230724185036181"></p><ul><li>十六位标识 (id): 唯一的标识主机发送的报文。如果IP报文在数据链路层被分片了，那么<strong>每一个片里面的这个id都是相同的</strong></li><li>三位标志字段: <ul><li>第一位保留 (保留的意思是现在不用， 但是还没想好说不定以后要用到)。 </li><li>第二位置为1表示“禁止分片”， 这时候如果报文长度超过MTU， IP模块就会丢弃报文。 </li><li>第三位表示”更多分片”， 如果分片了的话， <strong>最后一个分片置为0</strong>， 其他分片报文都是1；<strong>0就类似于一个分片的结束标记</strong></li></ul></li><li>十三位分片偏移 (framegament offset): 是分片相对于原始IP报文开始处的偏移。 其实就是在表示当前分片在原报文中处在哪个位置。实际偏移的字节数是这个值 <code>* 8 </code>得到的。因此， 除了最后一个报文之外， <strong>其他报文的长度必须是8的整数倍</strong> (否则报文就不连续了)</li></ul><p>此时，只要将三位标志字段中的<code>更多分片</code>置为1，就代表当前报文并不是一个完整的报文，而是已经被分片后的报文。</p><blockquote><ul><li>更多分片为0，且分片偏移为0，代表当前报文没有进行分片；</li><li>更多分片为1，且分片偏移为0，代表当前是分片后报文中的第一个；</li><li>更多分片为0，且分片偏移<strong>不为0</strong>，代表当前是分片报文中的最后一个；</li></ul></blockquote><p>此时就需要根据十六位标识来确定当前分片属于哪一个“组”，再将当前报文和后续收到的ID相同的报文集合在一起，通过十三位片偏移来进行排序，组装成完整数据！</p><p>比如，第一个报文的起始偏移量是0，第二个是1000，第三个是2000，这时候就根据片偏移排序进行拼接就可以了。（这只是个栗子）</p><ul><li>如何保证收完了？</li></ul><p>根据十六位标识，按照片偏移进行排序，排序后发现缺失了部分的报文，那就代表没有被收完。因为每一个报文的<code>偏移量+该报文长度</code>，就是下一个报文的<code>偏移量</code>！只要数据对不上，那就代表丢东西了。</p><p>而开头和结尾的报文，就能通过上面提到的根据<code>更多分片标记位+分片偏移</code>来确定有没有丢。</p><h3 id="2-2-3-如何减少分片"><a href="#2-2-3-如何减少分片" class="headerlink" title="2.2.3 如何减少分片"></a>2.2.3 如何减少分片</h3><p>虽然说IP网络层会自动帮我们分片，但是否分片是<strong>可以通过传输层</strong>来进行控制的</p><p>只要传输层一次交付的数据没有超过需要分片的阈值，那网络层在传输的时候就不会进行分片了！</p><p>减少分片的方式，那就是在传输层就进行一定的分片，这样能更好将<code>丢分片报文</code>这件事在传输层进行处理。而不是在网络层丢包后，没办法在传输层失败并处理。</p><hr><h4 id="传输层进行限制"><a href="#传输层进行限制" class="headerlink" title="传输层进行限制"></a>传输层进行限制</h4><p>如果是TCP协议，在三次握手的时候，就会协商双方单词传输数据的大小。从而避免网络层对数据进行分片，以规避数据链路层的MTU限制。同时也维护了滑动窗口，如果网络层的传输出现了丢包，由传输层来进行重传操作，以实现可靠传输。</p><ul><li>限制成多少好呢？</li></ul><p>一般建议将该大小设置为比网络中的最小MTU值小一些，以防止出现分片</p><blockquote><p>后续会补上更多信息</p></blockquote><h3 id="2-2-4-分片的限制"><a href="#2-2-4-分片的限制" class="headerlink" title="2.2.4 分片的限制"></a>2.2.4 分片的限制</h3><p>在上文中提到，MTU的限制是最大1500字节，这个数据长度是包含IP协议的报头的（数据是从IP网络层向下交付给数据链路层的）</p><p>假设我们有一个<strong>网络层的3000字节</strong>的数据，此时网络层要进行分片，并不是简单的<code>3000/1500=2</code>就能搞定了的。而是要计算上IP报头的长度（20字节）</p><p>每一个分片都是一个独立的IP报文，都会有自己独立的IP报头！否则缺少报头，在接收端没有办法进行数据组装操作。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">20+1480</span><br><span class="line">20+1480</span><br><span class="line">20+20</span><br></pre></td></tr></table></figure><p>一共需要分3片，才能将这网络层的3000字节的数据成功传输！</p><p>但是这里就有一个问题了，明明<code>1480+1480+20 = 2980</code>，并不是3000字节啊？</p><p>注意！上面提到的是网络层的3000字节数据。实际上，<strong>传输层只向下交付了2980字节</strong>，加上IP报头20字节才是<strong>网络层的3000字节</strong>数据。因为要进行分片，原本这3000字节的统一报头肯定是要丢弃的，我们需要操作的是传输层向下交付的<code>2980</code>字节数据，将其正确分片并添加上每一个分片的报头，再交给数据链路层。</p><h2 id="2-3-TTL"><a href="#2-3-TTL" class="headerlink" title="2.3 TTL"></a>2.3 TTL</h2><p>上文提到TTL是用来控制报文的生命周期的，其为了避免报文在路由中出现<strong>死循环</strong>。</p><p>比如下图中，假设有一个报文路由到了路由器D，原本他应该被正常交付给主机C，但路由器D出现了一些问题，将这个报文交付给了路由器I，路由器I给J，J给H，H给C，路由器C又给D，路由器D还是有bug，又转发给了路由器I。</p><p>这时候，就出现了一个报文路由的死循环。</p><p>如果没有TTL来控制生命周期，报文就会一直在这个死循环中跑，白白浪费路由器的性能！</p><p><img src="https://img.musnow.top/i/2023/07/cfb3fb1c0b8d2c1d8ae655d17a5e3fef.png" alt="image-20230726201220852"></p><p>规定了TTL之后，当报文的生命周期已经到了，但却还没有发送到目的地，那就需要将这个报文丢弃了。（即超了TTL的时间就认为报文无效）</p><h1 id="3-网段划分"><a href="#3-网段划分" class="headerlink" title="3.网段划分"></a>3.网段划分</h1><h2 id="3-1-IP如何找到对方主机？"><a href="#3-1-IP如何找到对方主机？" class="headerlink" title="3.1 IP如何找到对方主机？"></a>3.1 IP如何找到对方主机？</h2><p>IP如何找到对方主机呢？</p><ul><li>IP &#x3D; 目的网络 + 目的主机</li><li>由此还衍生出网段划分</li></ul><p>以IPV4的ip为例，其格式为<code>1.1.1.1</code>，可以认为是下面的划分</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1.1.1  .1</span><br><span class="line">网段   .主机</span><br></pre></td></tr></table></figure><p>这就好比你的学号，前X位里面是学院的代码，最后才是班级+班级内编号。先找到你所在学院，再找到班级，最后再找到你。</p><p>反馈到IP里面，就是先找到网段，再找到主机。</p><h3 id="3-1-1-发送数据的本质"><a href="#3-1-1-发送数据的本质" class="headerlink" title="3.1.1 发送数据的本质"></a>3.1.1 发送数据的本质</h3><p>IP就是先找到目的的<strong>网段</strong>，再找这个网段中的目的<strong>主机</strong>。（先根据目的网段进行路由，找到目的网络，再通过主机号找到目的主机）</p><p>而查找目的主机的过程，本质是一个<strong>排除</strong>的过程。</p><p>先通过网段排除一个大类，再通过主机号来排除该网段中的单个主机。这样就能避免我们<strong>一个一个遍历</strong>在全网中查找主机，<strong>提高了查找的效率</strong></p><blockquote><p>子网划分的目的：就是提高查找目标主机的效率</p></blockquote><p>这也是学校里面用学号的原因，除了为了给每个学生提供一个唯一标识，还能通过学号来提高查找到某一个学生的效率。</p><p>在全球互联网上，同样是通过IP地址的网段来划分国家，再划分到每个国家内部的不同区。这时候就会有一定IP地址资源的竞争。比如米国互联网发展早，下图中谷歌的服务器IP就老整齐了😂（不过这些服务器都在同一个地域，IP很接近是合理的）</p><p><img src="https://img.musnow.top/i/2023/07/5b872ab28b7ae44e7b57d513874d395c.png" alt="image-20230726132920408"></p><h3 id="3-1-2-网络号和主机号"><a href="#3-1-2-网络号和主机号" class="headerlink" title="3.1.2 网络号和主机号"></a>3.1.2 网络号和主机号</h3><ul><li>网络号：保证相互连接的两个网段具有不同的标识</li><li>主机号：在同一网段中，主机之间具有相同的网络号，但是主机号不同以进行区分</li></ul><p>具体框架可以查看下图，<code>192.168.128</code>就是这个局域网的网段 ，而最后的10和11是不同主机的两个主机标识。一般情况下，网段中的<code>1</code>号主机就是这个网段中的路由器。</p><blockquote><p>我们家里的路由器除了进行路由转发，还有子网划分的功能。</p></blockquote><p>如果出现了一个开头并非<code>192.168.128</code>的IP，主机就能知道这不是当前局域网的IP，于是就会将报文直接转发给<code>192.168.128.1</code>，让路由器去找这个IP的目标主机（进行跨局域网的下一层转发）</p><p><img src="https://img.musnow.top/i/2023/07/92a09c99e1a35e35157cd259802c2b75.jpeg" alt="img"></p><p>就好比我们的学号是学校的教务系统派发给每一位同学的，IP中的网段也被“某人”在一定程度上根据地区进行了划分。</p><h2 id="3-2-IP地址类别划分"><a href="#3-2-IP地址类别划分" class="headerlink" title="3.2 IP地址类别划分"></a>3.2 IP地址类别划分</h2><h3 id="3-2-1-ABCDE"><a href="#3-2-1-ABCDE" class="headerlink" title="3.2.1 ABCDE"></a>3.2.1 ABCDE</h3><p>通过A到E类不同的划分，会衍生出不同范围的IP号，然后再分配给不同的国家或地区</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">A类 0.0.0.0到127.255.255.255 </span><br><span class="line">B类 128.0.0.0到191.255.255.255 </span><br><span class="line">C类 192.0.0.0到223.255.255.255 </span><br><span class="line">D类 224.0.0.0到239.255.255.255 </span><br><span class="line">E类 240.0.0.0到247.255.255.255</span><br></pre></td></tr></table></figure><p><img src="https://img.musnow.top/i/2023/07/f3248796ffe4f8989ee68b52f3b2f7d7.png" alt="image-20230726110410094"></p><p>依照上面的划分，如果我是一个大型企业，申请了一个B类的IP地址。此时就能支持我的局域网内<code>2^16</code>台主机的ip分配。但实际上我顶多会有2w个主机，此时就出现了IP地址的浪费！</p><h3 id="3-2-2-CIDR和子网掩码"><a href="#3-2-2-CIDR和子网掩码" class="headerlink" title="3.2.2 CIDR和子网掩码"></a>3.2.2 CIDR和子网掩码</h3><p>为了避免上文中出现的IP浪费问题，CIDR（Classless Interdomain Routing）就出现了</p><ul><li>引入一个额外的子网掩码(subnet mask)来区分网络号和主机号；</li><li>子网掩码也是一个32位的正整数. 通常用一串 <code>0</code> 来结尾，一串 <code>1</code> 开头；</li><li>将IP地址和子网掩码进行 <strong>按位与</strong> 操作, 得到的结果就是网络号；</li><li>网络号和主机号的划分与这个IP地址是A类、B类还是C类<strong>无关</strong></li></ul><p>如果我们需要更多主机，就可以将子网掩码中最后一个1置0，就能适配更多局域网主机。</p><p>所以，现在已经不用<code>ABCDE</code>的类别划分方式了，都采用了<strong>子网掩码</strong>方式。</p><p><img src="https://img.musnow.top/i/2023/07/06b71c71fe5cee4bfd70781717f7f031.png" alt="image-20230726133558191"></p><p>根据上图可见，IP地址与子网掩码做与运算可以得到网络号，<strong>主机号</strong>的二进制位从全0到全1就是子网的地址范围； </p><p>IP地址和子网掩码还有一种更简洁的表示方法：例如<code>140.252.20.68/24</code>,表示IP地址为<code>140.252.20.68</code>, 子网掩码的<strong>高24位是1</strong>，也就是子网掩码<code>255.255.255.0</code></p><h2 id="3-3-基础设施"><a href="#3-3-基础设施" class="headerlink" title="3.3 基础设施"></a>3.3 基础设施</h2><p>有了网段划分，给不同国家和地区划分了IP之后，就需要有人来建设网络的<code>基础设施</code></p><p>在我们国家，搞基础设施就是三大运营商（移动 电信 联通）</p><p>比如几年前做的“光纤入户”就是基础设施建设的一部分。</p><p>基础设施搭建好了后，再通过子网掩码和已经获取到的IP的网段来划分不同省份、不同市区；最终再落到每个入网用户的头上。</p><h2 id="3-4-缓解IP地址不够用的办法"><a href="#3-4-缓解IP地址不够用的办法" class="headerlink" title="3.4 缓解IP地址不够用的办法"></a>3.4 缓解IP地址不够用的办法</h2><p>有人肯定会问了，现在公网IPV4的资源那么匮乏，大部分家宽都是没有公网ip的，那我们平时的上网是怎么实现的？</p><p>换句话说，如何缓解IP地址的匮乏？</p><ul><li>可以使用<code>动态IP分配</code>技术，只给直接接入公网的设备分配IP地址，每一个设备接入网络时，其获取到的IP地址不一定和上次相同。</li><li>NAT技术（重点）</li><li>IPV6（但是现在普及率有待提高）</li></ul><p>IPV6使用16字节（128位）来标识一个IP地址，目前看来，<code>2^128</code> 位能给“地球上每一粒沙子”都分配一个IP地址了。虽然迟早也会有不够用的那一天，但至少是一个很不错的解决方案。我们国家就在大力推广IPV6</p><p>通过前文的报文结构图可知，IPV4的IP地址只有4字节（32位）</p><hr><h1 id="4-私有IP"><a href="#4-私有IP" class="headerlink" title="4.私有IP"></a>4.私有IP</h1><h2 id="4-1-特殊的IP地址"><a href="#4-1-特殊的IP地址" class="headerlink" title="4.1 特殊的IP地址"></a>4.1 特殊的IP地址</h2><p>但是，直接采用CIDR的方式作为局域网控制的方式，就容易出现混乱。而且即便是采用了子网掩码的方式，依旧可能出现IP不够用的情况（一位网民很可能有多个设备， 再加上各类智能终端，现在需要上网的设备只会越来越多）</p><p>需要注意的是CIDR只能提高IP地址的利用率，并不能提高IP地址的上限。</p><p>所以，就衍生出了部分特殊的IP地址。这些IP地址被规定<strong>只能用于局域网</strong>，由此来减少对公网IP的地址消耗。</p><ul><li>将IP地址中的主机地址全设为0，就是该地址的网络号，代表当前局域网</li><li>将IP地址中的主机地址全设为1，就是广播地址，用于给同一个链路中相互连接的所有主机发送数据包。</li><li><code>127.*</code>的IP地址用于<strong>本机回环</strong>。我们通常使用<code>127.0.0.1</code>来进行本地服务的访问和测试，该IP地址是IPv4回环地址的标准规定，IPv6的回环地址为<code>::1</code>。</li></ul><p>我们在计算一个局域网中有多少设备的时候，需要减掉上文提到的网络号和广播地址。</p><hr><p>以下是特殊的只能用于局域网的私有IP地址，包含在这个范围中的， 都称为私有IP， 其余的则称为全局IP (或公网IP)</p><ul><li><code>10.*</code>, 前8位是网络号，共<code>16,777,216</code>个地址 </li><li><code>172.16.</code>到<code>172.31.</code>，前12位是网络号，共<code>1,048,576</code>个地址 </li><li><code>192.168.*</code>，前16位是网络号，共<code>65,536</code>个地址</li></ul><p>这里要记住2的16次方为<code>65536</code>，在网络的知识点里面经常会接触到这个数字。</p><h2 id="4-2-loopback环回"><a href="#4-2-loopback环回" class="headerlink" title="4.2 loopback环回"></a>4.2 loopback环回</h2><p>上文提到了<code>127.*</code>是用于本地环回的。下图是环回驱动程序针对IP地址的判断</p><p><img src="https://img.musnow.top/i/2023/07/94236a76f61d44ff8b9d1b6b0150aa79.jpeg" alt="img"></p><p>在云服务器上执行<code>ifconfig</code>，也能看到本地环回的配置项；这里我们能发现，本地环回的MTU是远高于网络的1500。毕竟是自己和自己通信，基本不会出现丢包，传输速度也是飞快，也就不用担心数据包太大的问题</p><p>同时也能发现，我们的云服务器被分配到的ip地址并不是云服务器的公网ip，这也就表明了我们的云服务器并没有被直接暴露在公网上，而是通过了云服务器厂家的入网服务器（或者也叫路由器）来进行公网ip的映射和数据包的转发操作。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">eth0: flags=4163&lt;UP,BROADCAST,RUNNING,MULTICAST&gt;  mtu 1500</span><br><span class="line">        inet 10.0.12.2  netmask 255.255.252.0  broadcast 10.0.15.255</span><br><span class="line">        inet6 fe80::5054:ff:fec9:274f  prefixlen 64  scopeid 0x20&lt;link&gt;</span><br><span class="line">        ether 52:54:00:c9:27:4f  txqueuelen 1000  (Ethernet)</span><br><span class="line">        RX packets 277674393  bytes 80031748700 (74.5 GiB)</span><br><span class="line">        RX errors 0  dropped 0  overruns 0  frame 0</span><br><span class="line">        TX packets 302405663  bytes 162670581730 (151.4 GiB)</span><br><span class="line">        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0</span><br><span class="line"></span><br><span class="line">lo: flags=73&lt;UP,LOOPBACK,RUNNING&gt;  mtu 65536</span><br><span class="line">        inet 127.0.0.1  netmask 255.0.0.0</span><br><span class="line">        inet6 ::1  prefixlen 128  scopeid 0x10&lt;host&gt;</span><br><span class="line">        loop  txqueuelen 1000  (Local Loopback)</span><br><span class="line">        RX packets 111135687  bytes 27644436547 (25.7 GiB)</span><br><span class="line">        RX errors 0  dropped 0  overruns 0  frame 0</span><br><span class="line">        TX packets 111135687  bytes 27644436547 (25.7 GiB)</span><br><span class="line">        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0</span><br></pre></td></tr></table></figure><h3 id="4-2-1-环回"><a href="#4-2-1-环回" class="headerlink" title="4.2.1 环回"></a>4.2.1 环回</h3><p>上图中的环回驱动程序会直接和IP协议的接收端（即IP输入函数）相连，当检测到 <code>127.0.0.1</code> 的IP访问请求的时候，会直接把这个报文转发给IP输入函数，而不将其插入到以太网中。</p><p>就相当于你知道 <code>127.0.0.1</code> 这个IP地址代表的就是你自己，你想访问自己电脑上8080端口的程序，即便么有接入互联网的状况下也是能正常访问的！</p><p>Loopback环回接口对于<strong>测试和诊断本地主机上的网络服务和应用程序</strong>非常有用，因为它可以模拟网络通信而不涉及实际的网络传输。</p><h3 id="4-2-2-ARP"><a href="#4-2-2-ARP" class="headerlink" title="4.2.2 ARP"></a>4.2.2 ARP</h3><p>ARP是一个在局域网数据链路层通过IP获取到局域网主机MAC地址的协议，具体请参考后文中的解析</p><hr><h2 id="4-3-访问广域网的步骤"><a href="#4-3-访问广域网的步骤" class="headerlink" title="4.3 访问广域网的步骤"></a>4.3 访问广域网的步骤</h2><h3 id="4-3-1-说明"><a href="#4-3-1-说明" class="headerlink" title="4.3.1 说明"></a>4.3.1 说明</h3><p>下图中能看到我们家用主机是怎么来进行广域网的访问的基本流程；</p><p>我们家里的路由器除了进行路由转发，还有子网划分的功能。可以看到左下角虽然是两个不同的家庭，但其可以分配出完全一样的局域网的子网ip <code>192.168.1.1</code>，和不同的WAN口IP（WAN口就是路由器连接互联网的口）</p><p>这是因为我们的设备是直接和<strong>当前路由器</strong>相连的，访问的时候也只能通过<strong>当前路由器</strong>来进行局域网IP的转发。不可能会出现我访问一个局域网IP，却跑到了别人家里的设备上的情况。因为这个局域网IP访问的报文并不会被转发到上层路由器上，也就不可能凭空飞到其他局域网中</p><p><img src="https://img.musnow.top/i/2023/07/1a3192c168e559aee56371f85945c32b.png" alt="image-20230726185645407"></p><p>图中的 <code>122.77.241.3</code> 就是一个公网IP的服务器，当我们需要访问这个主机的时候，局域网的家用路由器在检测到这个目的IP的时候，发现其并不是局域网的IP地址，于是就会将这个报文给转发给上层的运营商路由器。</p><p>运营商路由器是直接接入了公网IP的，其就能通过<code>网段划分+主机编号</code>来查找目标主机，将报文转发给 <code>122.77.241.3</code>  服务器，再将服务器返回的信息转发给你的家用路由器，再转发到你的主机上。</p><p>这也告诉我们，想绕过运营商直接获得公网IP是不可能的，因为从<strong>物理层面上</strong>，我们的家用路由器就不是接在公网IP上的！即便是可以申请到的家用公网IP，也和云服务器的入网服务器一样，是运营商的路由器分配给你的。</p><blockquote><p>你会发现，家用申请的公网ip，很多端口都是被屏蔽的（比如 <code>80/443/8080</code>）这些端口的屏蔽操作，以及海外网站的「墙」也是运营商的路由器进行检测和屏蔽的！</p></blockquote><h3 id="4-3-2-内网访问公网的流程"><a href="#4-3-2-内网访问公网的流程" class="headerlink" title="4.3.2 内网访问公网的流程"></a>4.3.2 内网访问公网的流程</h3><p>假设我们的模型如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">广域网</span><br><span class="line">  ↓</span><br><span class="line">运营商路由器C （公网IP是122.77.241.4）</span><br><span class="line">  ↓</span><br><span class="line">家用路由器B （运营商路由器分配私有IP 10.1.1.2）</span><br><span class="line">  ↓</span><br><span class="line">家用主机A （家用路由器分配私有IP 192.168.1.201）</span><br></pre></td></tr></table></figure><p>下面是一个家用主机A，访问公网IP的主机 <code>122.77.241.10</code> 的具体步骤；</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">本地主机A发送IP报文给家庭路由器B</span><br><span class="line">————————————————————————</span><br><span class="line">| 源IP：192.168.1.201   |</span><br><span class="line">| 目的IP：122.77.241.10 |</span><br><span class="line">————————————————————————</span><br><span class="line"></span><br><span class="line">路由器B收到报文后，检测目的IP，发现并不似局域网的IP</span><br><span class="line">于是交付给上层的运营商路由器C；</span><br><span class="line">报文的源IP被修改为家用路由器B的wan口IP</span><br><span class="line">————————————————————————</span><br><span class="line">| 源IP：10.1.1.2        |</span><br><span class="line">| 目的IP：122.77.241.10 |</span><br><span class="line">————————————————————————</span><br><span class="line"></span><br><span class="line">运营商路由器C收到报文后，发现其也不是自己所在内网 10.1.1.* 的局域网IP</span><br><span class="line">于是开始执行广域网IP寻址操作，找到目标公网IP的主机，再将报文发送给该主机；</span><br><span class="line">此时发送的报文又被改成了</span><br><span class="line">————————————————————————</span><br><span class="line">| 源IP：122.77.241.4    |</span><br><span class="line">| 目的IP：122.77.241.10 |</span><br><span class="line">————————————————————————</span><br></pre></td></tr></table></figure><h3 id="4-3-3-NAT技术"><a href="#4-3-3-NAT技术" class="headerlink" title="4.3.3 NAT技术"></a>4.3.3 NAT技术</h3><p>这种不断替换源IP来进行路由转发的过程，就是<strong>NAT技术</strong>！</p><p>也正是NAT技术的存在，让我们能通过多级局域网来让更多的设备上网，大大缓解了公网IP的不足。</p><p>也正是因为IPV4地址不足的问题被大大缓解，推广IPV6就没有我们想象中的那么顺利了。毕竟IPV6的IP格式和V4完全不同，需要每个层级的路由器都进行功能升级，这可是一个巨大的工程！</p><p><img src="https://img.musnow.top/i/2023/08/18a4c496be6f375256a5563b7ff537a2.png" alt="image-20230822092804992"></p><h3 id="4-3-4-NAT怎么回来？NAPT"><a href="#4-3-4-NAT怎么回来？NAPT" class="headerlink" title="4.3.4 NAT怎么回来？NAPT"></a>4.3.4 NAT怎么回来？NAPT</h3><p>当目标主机收到这个报文后，他的反馈报文如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">————————————————————————</span><br><span class="line">| 源IP：122.77.241.10   |</span><br><span class="line">| 目的IP：122.77.241.4  |</span><br><span class="line">————————————————————————</span><br></pre></td></tr></table></figure><p>同样是先到达运营商路由器，运营商路由器需要缓存每一个转发到公网的报文的来源信息；为此路由器会维护一个<strong>转换表</strong>，记录着局域网主机的<code>私有IP地址:端口号</code>与对应的<code>公网IP地址:NAT端口号</code>的映射关系。</p><p>比如此次TCP链接中，我将路由器公网IP的<code>122.77.241.4:30000</code>映射给了局域网<code>10.1.1.2:40000</code>；当从公网收到服务器的响应报文后，从<strong>转换表</strong>里面就能够查到这个映射（一次通信中这个NAT映射是不会变的）从而确定该报文的局域网流向。</p><blockquote><p>需要注意的是，NAT技术在端口映射的时候不一定会映射到和内网主机相同的端口，此时不仅需要修改IP报文中的来源IP，还需要进一步修改传输层（比如TCP和UDP）中的源端口号</p></blockquote><p>确定局域网IP后，就修改当前报文的目的IP，继续往局域网转发；后面的子路由器也是如此，不再赘述。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">————————————————————————</span><br><span class="line">| 源IP：122.77.241.10   |</span><br><span class="line">| 目的IP：10.1.1.2      |</span><br><span class="line">————————————————————————</span><br></pre></td></tr></table></figure><p>这种<code>IP:端口</code>的关联关系表，就是由支持NAT技术的路由器来维护的，这个转换表被称为<strong>NAPT</strong>；当这次链接结束后，这对映射关系就会从转换表中被删除。</p><p><img src="https://img.musnow.top/i/2023/08/b1d4032e4d2cfd4fad023cbd0ad0f6d8.png" alt="image-20230822093121691"></p><h3 id="4-3-5-NAT和代理服务器"><a href="#4-3-5-NAT和代理服务器" class="headerlink" title="4.3.5 NAT和代理服务器"></a>4.3.5 NAT和代理服务器</h3><p>代理服务器看上去和NAT设备有一定类似，客户端向代理服务器发送请求，代理服务器将请求转发给真正需要请求的服务器；服务器返回结果后，代理服务器把结果传回客户端。</p><h4 id="4-3-5-1-NAT和代理服务器的区别？"><a href="#4-3-5-1-NAT和代理服务器的区别？" class="headerlink" title="4.3.5.1 NAT和代理服务器的区别？"></a>4.3.5.1 NAT和代理服务器的区别？</h4><ul><li>从应用来说，NAT是属于网络基础设置，解决的是公网IP不足的问题；代理服务器更贴近具体应用，比如通过代理服务器进行“翻墙”和游戏加速；</li><li>从底层来讲，NAT在网络层工作，对IP地址进行替换；代理服务器是在应用层工作；</li><li>从使用范围来讲，NAT一般部署在局域网出口，代理服务器既可以在局域网又可以在广域网部署</li><li>从部署位置来看，NAT集成在路由器或者防火墙的硬件上；代理服务器本质上是一个应用层软件，部署在服务器上</li></ul><p>代理服务器应用相对来说也比较广</p><ul><li>翻墙：广域网代理</li><li>负载均衡：局域网代理</li></ul><h4 id="4-3-5-2-反向代理"><a href="#4-3-5-2-反向代理" class="headerlink" title="4.3.5.2 反向代理"></a>4.3.5.2 反向代理</h4><p>代理服务器分为正向代理和反向代理，这里来说说<strong>反向代理</strong>，反向代理处于目标服务器和客户端之间，客户端通过反向代理访问目标服务器，而不会直接连接到目标服务器</p><ul><li>通过反向代理服务器作为一个云服务器主机集群的入网服务器</li><li>举例，一个网站拥有10台提供服务的服务器和一台反向代理服务器</li><li>域名解析到反向代理服务器</li><li>反向代理服务器通过服务器监控程序，获取到10台服务器中负载最低的那个，并将报文转发给它</li><li>反向代理服务器还会识别10台服务器中是否有宕机的服务器，如果有，则会告警给维护人员，并不再给这个宕机的服务器转发报文</li><li>反向代理服务器还可以设置黑白名单，当遇到DDOS攻击的时候，将来源IP放入黑名单进行屏蔽，避免过多的访问让所有服务器都宕机影响业务；将本公司的其他服务器放入白名单（一般白名单都很短）</li></ul><p>反向代理的作用</p><ul><li>通过反向代理服务器实现了<strong>负载均衡</strong></li><li>便于<strong>统一管理</strong>服务器集群，提供统一入网服务器</li><li>避免了直接将提供服务的主机IP暴露在公网上而被直接攻击的问题，提高了<strong>安全性</strong>。</li><li>反向代理还能对网页内容进行一定的<strong>缓存</strong>，从而减轻后端服务器的负担（比如缓存网页前端的静态资源，当用户访问的时候，由代理服务器直接返回资源，而不需要去请求实际提供服务的服务器）</li></ul><p>总之好处多多！</p><h4 id="4-3-5-3-正向代理"><a href="#4-3-5-3-正向代理" class="headerlink" title="4.3.5.3 正向代理"></a>4.3.5.3 正向代理</h4><p>正向代理是位于客户端和目标服务器之间的中间服务器。客户端通过正向代理来访问互联网上的资源，而不是直接连接到目标服务器。正向代理的作用主要有以下几点：</p><ol><li><strong>访问控制和过滤：</strong> 正向代理可以用于限制用户访问特定网站或资源，以实施访问控制策略。它可以过滤不良内容，提供更好的安全性和隐私保护。</li><li><strong>隐藏客户端身份：</strong> 正向代理可以隐藏客户端的真实 IP 地址，从而保护用户的隐私和匿名性。目标服务器只能看到代理服务器的 IP 地址，而无法获取到真正的客户端信息。</li><li><strong>缓存和加速：</strong> 正向代理服务器可以缓存常用的内容，从而减少对目标服务器的请求，提高访问速度。</li><li><strong>突破防火墙限制：</strong> 在一些网络环境中，访问特定网站可能受到限制或封锁。使用正向代理可以绕过这些限制，访问被封锁的资源。</li></ol><h2 id="4-4-ISP检测宽带账户"><a href="#4-4-ISP检测宽带账户" class="headerlink" title="4.4 ISP检测宽带账户"></a>4.4 ISP检测宽带账户</h2><blockquote><p>下文中的部分内容来自chatgpt，我对里面的内容进行了补充和修改</p></blockquote><p>运营商的路由器还会检测我们的账户是否还有余额。我们的家用路由器一般是通过光猫登录了自己的宽带账户；也可以将光猫设置成桥接模式，<strong>将接入光猫的路由器设置为宽带帐号（PPPoE）上网方式</strong>，登录运营商提供的宽带账户和密码，来接入网络。</p><p>ISP的路由器检测你的宽带账户通常是通过以下步骤来完成的：</p><ol><li><strong>设备连接与识别：</strong> 当你的计算机或其他网络设备连接到ISP提供的路由器时，路由器会分配一个私有IP地址给你的设备。这个IP地址是由路由器动态分配的，并且通常处于特定的私有IP地址范围，比如<code>10.11.1.0/16</code>或<code>10.11.1.0/24</code>等。此时，你的设备与路由器建立了一个<em>大局域网</em>内的连接。（运营商并不会直接给你分配<code>192.168.*</code>这样的私有IP，因为这个IP一般是用于<strong>最底层局域网</strong>的，给你分配了，那家庭局域网的就没IP用了）</li><li><strong>认证过程：</strong> 在你尝试访问互联网时，ISP的路由器会引导你的设备进行认证过程。这通常涉及向ISP服务器发送你的宽带账户的登录凭据（例如，用户名和密码）。</li><li><strong>账户验证：</strong> ISP的服务器会验证你提供的登录凭据是否与其记录中的账户匹配。如果验证成功，说明你的宽带账户是有效的，路由器会为你的设备分配一个公共IP地址，这个IP地址是可供互联网访问的。</li><li><strong>IP地址分配：</strong> 一旦认证成功，ISP的路由器会为你的设备分配一个公共IP地址。这个IP地址是在互联网上唯一标识你的设备的地址，使你的设备可以与其他互联网设备进行通信。</li><li><strong>数据传输：</strong> 一旦有了公共IP地址，你的设备就可以与互联网上的其他设备进行通信，发送和接收数据。</li></ol><p>这样，通过认证和IP地址分配的过程，ISP的路由器可以检测并识别你的宽带账户，从而让你的设备能够访问互联网。</p><p>人话就是，<strong>登录了宽带账户</strong>以后，当我们路由器发送的报文交付到运营商路由器的时候，该路由器就会检测你这个宽带账户的余额。如果没有余额了，就会直接丢弃掉你的IP报文。我们看到的结果就是无法上网！</p><blockquote><p>这个操作并不是每次都会执行的，只要你的路由器能稳定的接入到运营商的路由器上，那就不会每次都进行宽带账户的验证，否则会增加网络的负担。</p><p>具体的验证流程都是运营商路由器和你的本地光猫自动完成的。</p></blockquote><p>而手机没有话费余额的时候，我们依旧能拨通诸如120、119等紧急号码，这也是运营商的服务对这些特殊的电话号码做了类似于<code>免费白名单</code>的操作（手机号码可以类比公网IP来理解）</p><h1 id="5-域名"><a href="#5-域名" class="headerlink" title="5.域名"></a>5.域名</h1><h2 id="5-1-DNS服务器"><a href="#5-1-DNS服务器" class="headerlink" title="5.1 DNS服务器"></a>5.1 DNS服务器</h2><p>上文讲述的都是关于IP协议的事情。但实际上我们日常生活中，一般都不会直接使用IP地址+端口号的方式来访问某一个服务，而是使用域名来访问。比如</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">www.baidu.com</span><br><span class="line">www.google.com</span><br></pre></td></tr></table></figure><p>所谓域名，就是这些<strong>英文字符串</strong>和IP的映射。</p><p>比如<code>baidu.com</code>就是一个域名，而<code>www.baidu.com</code>是该域名下的三级域名（几级域名可以看有几个点）</p><p>实际访问的时候，是百度在域名注册商哪里，将<code>www.baidu.com</code>指向了自己的服务器的地址(假设指向的是<code>1.1.1.1</code>) 我们访问百度，实际上访问的就是 IP地址 <code>1.1.1.1</code>；</p><ul><li>DNS是应用层协议，底层使用的是UDP</li><li>系统会缓存一部分DNS的结果</li></ul><p>在主机本地，有一个<code>hosts</code>文件，也可以用于设置主机到域名的映射，在linux里面就是<code>/etc/hosts</code>这个文件。 在访问域名的时候，操作系统会先检查自己本机器的hosts，如果本地没有，就请求DNS服务器来获取解析结果。</p><h2 id="5-2-域名访问主机流程"><a href="#5-2-域名访问主机流程" class="headerlink" title="5.2 域名访问主机流程"></a>5.2 域名访问主机流程</h2><p>当我们访问一个域名的时候，首先会去请求特殊的DNS服务器</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">8.8.8.8 谷歌公司的DNS服务器</span><br><span class="line">119.29.29.29 腾讯提供的公共DNS</span><br></pre></td></tr></table></figure><p>先请求这些DNS服务器，服务器内会针对域名查询对应的DNS解析，最后再访问该解析对应的IP地址</p><p>而使用域名的时候，默认访问的是该主机的 <code>80(HTTP)/443(HTTPS)</code> 端口 ，我们也可以像IP一样，在域名之后用<code>:端口</code> 来指定特定端口号进行访问，即<code>域名:端口</code>。</p><p>一般情况下，我们的主机都可以通过<strong>自动配置DNS</strong>从上层路由器中获取到DNS服务器的地址（比如运营商会在路由器基站中内置DNS服务器）</p><h3 id="5-2-1-DNS劫持"><a href="#5-2-1-DNS劫持" class="headerlink" title="5.2.1 DNS劫持"></a>5.2.1 DNS劫持</h3><p>所谓DNS污染和DNS劫持，就是因为我们访问的DNS服务器的时候，获取到的结果和预期不同，从而导致无法访问目标网站，或者访问了<strong>假</strong>的目标网站</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">www.baidu.com 明明应该指向 1.1.1.1</span><br><span class="line">但被坏蛋劫持了DNS解析，变成了指向 1.1.1.3</span><br></pre></td></tr></table></figure><p>坏蛋可以在 <code>1.1.1.3</code> 服务器上，搭建一个和百度「看起来」一模一样的页面，并将你的报文给转发到百度服务器上。此时他就通过中间转发，获取到了你报文中的用户信息、密码等等参数；</p><p>这时候因为这个<strong>假的服务器</strong>是直接给你提供服务了，使用的HTTPS证书也是这个假服务器的证书，对方可以直接通过自己的证书解密获取到你的信息，再转发给百度。</p><h3 id="5-2-2-DNS和负载均衡"><a href="#5-2-2-DNS和负载均衡" class="headerlink" title="5.2.2 DNS和负载均衡"></a>5.2.2 DNS和负载均衡</h3><p>对于大公司而言，DNS解析还有一个重要的作用，就是通过不同区域的设置来实现负载的均衡。</p><p>假设百度在每一个省份都设立了一个自己的机房，那么它就可以通过DNS服务器，当不同省份的用户请求服务器的时候，返回他当前所处省份的机房地址。这时候就实现了每个机房的负载均衡。</p><p>在现实中，就是将你的请求转接到离你最近的拥有机房的省份，这样既能保证所有服务器的负载均衡，又能保证你的访问能较快地获取到响应（广东访问广州的服务器，肯定比访问北京服务器的延迟低一些）</p><h2 id="5-3-DNS分层"><a href="#5-3-DNS分层" class="headerlink" title="5.3 DNS分层"></a>5.3 DNS分层</h2><p>DNS服务器不会存放所有已知域名的IP解析，因为互联网上存在大量的域名，数量庞大且不断增长，单一DNS服务器无法存储和处理所有域名的IP映射。</p><p>实际上，DNS服务器通过<strong>分层的架构</strong>来解决这个问题。在根DNS服务器层级，有一组全球性的顶级DNS服务器，它们存储顶级域名（例如<code>.com、.org、.net</code>等）的IP地址。然后，在每个顶级域名下，有其他DNS服务器，负责管理该顶级域名下的子域名（例如，<code>google.com、facebook.com</code>等）。这个过程继续向下，形成了一个层级结构。</p><p>当你的设备需要解析某个域名时，它首先会向本地DNS服务器（通常由你的ISP，即<strong>互联网服务提供商</strong>，人话就是国内的三大运营商提供）发起请求。如果本地DNS服务器知道所需域名的IP地址，它会直接返回该IP地址给你的设备。但如果本地DNS服务器不知道该域名的IP地址，它会向<strong>根DNS</strong>服务器发起请求。</p><p>根DNS服务器将指导本地DNS服务器转向相应的<strong>顶级DNS服务器</strong>。然后，顶级DNS服务器可能会进一步将请求转发给负责该<strong>特定域名的授权DNS</strong>服务器。最终，这个授权DNS服务器将返回所需域名的IP地址给本地DNS服务器，本地DNS服务器再将其返回给你的设备。</p><p>这个层级结构允许DNS系统更高效地处理大量的域名解析请求，并确保及时更新和管理域名与IP地址的映射。所以，单个DNS服务器并不会存放所有已知域名的IP解析，而是通过层级结构来分散和管理这些信息。</p><p><img src="https://img.musnow.top/i/2023/08/74893f7e207a52fc1a4c3c683ebb0976.png" alt="img"></p><h2 id="5-4-dig工具分析DNS解析过程"><a href="#5-4-dig工具分析DNS解析过程" class="headerlink" title="5.4 dig工具分析DNS解析过程"></a>5.4 dig工具分析DNS解析过程</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install bind-utils</span><br></pre></td></tr></table></figure><p>安装了之后就可以使用dig命令来查看域名解析过程了</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dig 域名</span><br></pre></td></tr></table></figure><h1 id="6-路由"><a href="#6-路由" class="headerlink" title="6.路由"></a>6.路由</h1><p>路由的过程，就是下图这样一跳一跳(Hop by Hop) “问路” 的过程</p><p>所谓 “一跳” 就是数据链路层中的一个区间。具体在以太网中，指从源MAC地址到目的MAC地址之间的帧传输区间。</p><p><img src="https://img.musnow.top/i/2023/07/f1a4a3b26f00fe29305bba853e830186.png" alt="image-20230726194559495"></p><h2 id="6-1-问路栗子（帮助理解）"><a href="#6-1-问路栗子（帮助理解）" class="headerlink" title="6.1 问路栗子（帮助理解）"></a>6.1 问路栗子（帮助理解）</h2><p>拿日常生活中问路来举例子（请屏蔽现在有导航这件事）一般问路，会得到三种结果：</p><ul><li>我不知道</li><li>我知道XXX知道</li><li>我不知道，但是给你乱指（在路由寻址的过程中，这个情况是不存在的）</li></ul><p>比如张三要去南京大学的仙林校区，他飞机落地南京后，不知道怎么走；他找了个机场的保安，问他“我是从xx省新来的大学生，应该怎么去南京大学？” 保安让他先坐xx路公交车去仙林大学城，到哪里再去问其他人。</p><p>张三到了仙林大学城后，又找到了路边的环卫工，又问“我从机场过来，应该怎么去南京大学。” 环卫工给他指了条明路，那里就是南京大学的教学楼，入口就在这附近。这时候张三获取了两个人（路由器）的帮助，成功递达了南京大学的仙林校区（目标主机）。</p><p>可以看到，问路和上面图示中IP报文的路由是很相似的，都是一个路由一个路由的“问路”，最终找到目标主机。</p><hr><h2 id="6-2-路由表"><a href="#6-2-路由表" class="headerlink" title="6.2 路由表"></a>6.2 路由表</h2><p>报文在各个路由器之间路由也是如此。当一个路由器遇到一个IP报文</p><ul><li>他首先检测这是不是自己分配的局域网中的IP，是则可以直接转发到目标主机；</li><li>不是则查看自己的<strong>路由表</strong>，看看自己是否保存了这个IP应该往哪里走；</li><li>如果它自己不知道，则可以和其他与自己相连的路由器通信（信息同步），问他们这个IP应该给谁（就好比你在公司里面问某一个工作应该交给谁去做）</li><li>如果周边的路由（旁边的路人）都不知道该往哪里去，则路由器会将其交付给自己的<code>默认路由</code>，报文继续转发，去下一个人那里问路了。</li></ul><p>这样的跳跃都会有一个前提条件：相邻的两个主机（或路由器）一定是在物理上相连，处于同一局域网之中。每次的跳跃，本质上是从一个子网跳到另外一个子网；广域网可以认为是最大的“子网”</p><p><img src="https://img.musnow.top/i/2023/07/2eb52f0f7cb80aeed61e8a17d8402688.png" alt="image-20230727085331798"></p><h2 id="6-3-route命令"><a href="#6-3-route命令" class="headerlink" title="6.3 route命令"></a>6.3 route命令</h2><blockquote><p>在windows电脑上可以使用 <code> route print</code> 命令打印路由表，本文不关注windows平台。</p></blockquote><p>在linux平台里面，可以通过<code>route</code>命令查看当前主机的路由表，在Centos8主机上，命令显示如下。</p><p>可以看到，路由表的名字叫做 <strong>内核IP路由表</strong>，这也是linux系统中的一个内核数据结构。内部维护了路由表的目的地、Gateway网关、Genmask掩码、Flags标志位、Metric、Ref、Use、Iface接口</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Kernel IP routing table</span><br><span class="line">Destination     Gateway         Genmask         Flags Metric Ref    Use Iface</span><br><span class="line">default         _gateway        0.0.0.0         UG    100    0        0 eth0</span><br><span class="line">172.16.0.0      0.0.0.0         255.255.0.0     U     100    0        0 eth0</span><br><span class="line">172.17.0.0      0.0.0.0         255.255.0.0     U     0      0        0 docker0</span><br><span class="line">172.18.0.0      0.0.0.0         255.255.0.0     U     0      0        0 br-96d69eeef1ac</span><br><span class="line">172.19.0.0      0.0.0.0         255.255.0.0     U     0      0        0 br-fa4aff4c583e</span><br></pre></td></tr></table></figure><ul><li>Flags中，U代表当前路由表的条目是有效的，G代表其是一个路由器。</li><li>Gateway中，<code>_gateway</code>以及<code>0.0.0.0</code>代表的都是默认网关</li><li>Iface中，只有<code>eth0</code>是一个真正的物理网络接口，而<code>docker0/br-*</code>都是docker容器虚拟出来的桥接网络接口</li></ul><p>假设我我们有一个目的IP是 <code>172.16.0.2</code>，获取到这个IP后，系统就会将其和路由表中的子网掩码依次进行<strong>按位与</strong>；</p><p>在linux环境下，可以使用如下代码来进行这两个IP的按位与操作。其中<code>inet_addr 和 inet_ntoa</code>是linux下的两个系统调用接口。用于IP字符串到无符号整数之间的转换，具体的介绍可以阅读我的 <a href="https://blog.musnow.top/posts/368672249/">UDP博客</a></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 将点分十进制的IP地址和子网掩码转换为无符号整数</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> ipAddress = <span class="built_in">inet_addr</span>(<span class="string">&quot;172.16.0.2&quot;</span>);</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> subnetMask = <span class="built_in">inet_addr</span>(<span class="string">&quot;255.255.0.0&quot;</span>);</span><br><span class="line">    <span class="comment">// 进行按位与操作得到网络地址</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> networkAddress = ipAddress &amp; subnetMask;</span><br><span class="line">    <span class="comment">// 将网络地址转换回点分十进制表示法并输出结果</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">in_addr</span> addr;</span><br><span class="line">    addr.s_addr = networkAddress;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;IP地址: &quot;</span> &lt;&lt; <span class="string">&quot;172.16.0.2&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;子网掩码: &quot;</span> &lt;&lt; <span class="string">&quot;255.255.0.0&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;网络地址: &quot;</span> &lt;&lt; <span class="built_in">inet_ntoa</span>(addr) &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 非linux环境可以使用下方的代码进行处理</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ip_and_gmask_test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> ipAddress = <span class="number">172</span> &lt;&lt; <span class="number">24</span> | <span class="number">16</span> &lt;&lt; <span class="number">16</span> | <span class="number">0</span> &lt;&lt; <span class="number">8</span> | <span class="number">2</span>; <span class="comment">// 将 IP 地址转换为 32 位无符号整数</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> subnetMask = <span class="number">255</span> &lt;&lt; <span class="number">24</span> | <span class="number">255</span> &lt;&lt; <span class="number">16</span> | <span class="number">0</span> &lt;&lt; <span class="number">8</span> | <span class="number">0</span>; <span class="comment">// 将子网掩码转换为 32 位无符号整数</span></span><br><span class="line"></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> networkAddress = ipAddress &amp; subnetMask; <span class="comment">// 按位与</span></span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;IP地址:  172.16.0.2&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;子网掩码: 255.255.0.0&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;网络地址: &quot;</span> &lt;&lt; (networkAddress &gt;&gt; <span class="number">24</span>) &lt;&lt; <span class="string">&quot;.&quot;</span> &lt;&lt; ((networkAddress &gt;&gt; <span class="number">16</span>) &amp; <span class="number">255</span>) &lt;&lt; <span class="string">&quot;.&quot;</span> &lt;&lt; ((networkAddress &gt;&gt; <span class="number">8</span>) &amp; <span class="number">255</span>) &lt;&lt; <span class="string">&quot;.&quot;</span> &lt;&lt; (networkAddress &amp; <span class="number">255</span>) &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>二者输出结果都是<code>172.16.0.0</code></p><p>得到输出结果后，再和路由表中该项的<code>Destination</code>进行对比，二者相等，代表当前IP就是需要通过该项进行路由，那就将这个报文通过<code>Iface</code>接口<code>eth0</code>发送出去就OK了</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Destination     Gateway         Genmask         Flags Metric Ref    Use Iface</span><br><span class="line">172.16.0.0      0.0.0.0         255.255.0.0     U     100    0        0 eth0</span><br></pre></td></tr></table></figure><p>如果按位与的结果与<code>Destination</code>匹配不上，那就继续往下一个条目的子网掩码进行按位与。如果整个表都按位与完毕了，还没找到该去的地方，那就将其通过<code>default</code>默认路由发送出去。</p><h1 id="7-数据链路层"><a href="#7-数据链路层" class="headerlink" title="7.数据链路层"></a>7.数据链路层</h1><p>前面谈了一大堆将数据从一个主机到路由器再跨越多个路由器递达目标主机的流程。</p><p>要想实现这一点，我们还需要数据链路层的帮助，即实现同一局域网内两台主机在物理层面上的相互通信。</p><ul><li>IP网络层：提供跨网络找到正确路由路径，并传输数据的能力</li><li>数据链路层：提供将数据在同一网络中传输的能力</li><li>物理层：实际上的数据在物理（网线）上传输</li></ul><p>数据链路层也有不同的传输方式，本文主要关注当前主流的<strong>以太网</strong>；</p><p>需要注意的是，以太网不是一种具体的网络，而是一种技术标准。它即包含了数据链路层的内容，也包含了一些物理层的规定，比如拓扑结构和访问控制方式，传输速率等。</p><hr><h2 id="7-1-认识局域网的基本情况"><a href="#7-1-认识局域网的基本情况" class="headerlink" title="7.1 认识局域网的基本情况"></a>7.1 认识局域网的基本情况</h2><h3 id="7-1-1-局域网认识"><a href="#7-1-1-局域网认识" class="headerlink" title="7.1.1 局域网认识"></a>7.1.1 局域网认识</h3><p>不过在认识以太网之前，我们需要先知道局域网通信的一个基本情况；假设下图中就是一个局域网，其中包含了不同的主机</p><p><img src="https://img.musnow.top/i/2023/08/ffd57666730e838d74d4c8c9af7d95cd.png" alt="image-20230821171017532"></p><p>首先，如果想要两台主机能够通信，我们就需要先将其链接到<strong>同一根网线</strong>上（在这里暂且不管WIFI，其实本质上也是连在了这根网线上）；这就好比进程间通信的时候，你需要先能看到同一份资源，才能实现对这份资源的共享访问。</p><p>虽然我们认为在局域网里面通信的时候，是两台主机直接交流，但实际上你可以把局域网当作一个教师，当张三和李四沟通的时候，其实会有很多其他的吃瓜群众都能接收到你发送的这个信息。</p><p>反馈到以太网报文上，因为每个主机都是知道自己的地址的，所以只要检测到以太网报头中的<code>目的地址</code>不是自己的时候，就可以丢弃掉这个报文。因为目标并不在和你说话。这就好比在教室里面，你隔壁有俩人在聊天，他们并没有和你交谈，所以你可以不用管他们聊了什么。</p><blockquote><p>这也反馈出了为什么某些公共WIFI会不安全，因为只要接入了这个WIFI，你就有办法检测到其他用户通过这个局域网发送了什么信息！</p></blockquote><p>因为局域网内的主机是通过目的地址判断有没有人和自己聊天的，所以即便我们的电脑开机后什么事情都没有干，在操作系统底层（数据链路层）其实一直都在从局域网中拿到新的数据链路层报文，并检测是否是发给自己的报文：</p><ul><li>是，向上交付</li><li>否，丢掉</li></ul><h3 id="7-1-2-碰撞域"><a href="#7-1-2-碰撞域" class="headerlink" title="7.1.2 碰撞域"></a>7.1.2 碰撞域</h3><p>由于数据链路层向下是直接交付给物理层的，在物理层（网线）中光电信号传输是不能同时传输多个数据的，这就要求我们同一个局域网的多台主机不能同时往局域网中发数据。为了解决这个问题，主机引入了休眠机制，通过不同时间的错开休眠，来避免两台主机同时往局域网中发数据的情况。</p><ul><li>理想情况：同一时间只有一台主机在局域网中发送数据</li><li>碰撞问题：如果出现了同时发送，数据出现冲突，就需要剔除掉这部分数据</li></ul><p>通过<code>碰撞域</code>解决数据冲突问题，尽量达到理想情况；</p><p>比如我们的交换机就有<strong>划分碰撞域</strong>的功能。接到交换机上的设备，除了通过交换机进行路由转发，如果在交换机的这部分设备中出现了数据碰撞，那么交换机就能把碰撞控制在当前这个小的碰撞域内，而不会向更大的局域网中传播。</p><blockquote><p>如果一个局域网里面只有一个交换机（路由器）那么这整个局域网共享碰撞域</p></blockquote><p>所以大公司内为了避免局域网因为碰撞问题而导致的网络卡顿，一般都会将几台电脑接入一个小的交换机中来<strong>划分碰撞域</strong>。</p><p>如上是物理层面的事情，软件层面上，一个<strong>MAC帧</strong>不要太大，否则会大大增加碰撞的概率。所以MAC帧必须要对上层交付的数据大小提一个要求，不能交付太大的数据，这就是MTU的由来（一般都是1500字节，至于为什么是1500，那就是学术层面的事情了）</p><h2 id="7-2-以太网帧格式"><a href="#7-2-以太网帧格式" class="headerlink" title="7.2 以太网帧格式"></a>7.2 以太网帧格式</h2><p><img src="https://img.musnow.top/i/2023/08/736bb377f1eb050bba42a13f153a435e.png" alt="image-20230803144819270"></p><p>这里需要知道一个小知识，虽然MAC地址在一定程度上可以认为是全球唯一的，但实际上只需要保证同一个局域网内的MAC地址是唯一的，就OK了</p><ul><li>目的地址&#x2F;源地址：48位的MAC地址，MAC是每个主机在局域网内唯一的身份标识</li><li>帧协议类型有三种值，分别对应<code>IP、ARP、RARP</code>，所以只需要2个字节</li><li>帧末尾是CRC校验码，4个字节</li></ul><p>这三个就是以太网固定添加的报头，在进行解包的时候，我们只需要取走数据最前面的14个字节（6+6+2），再丢弃末尾的4个字节，就能取到上层的原始数据。</p><h2 id="7-3-认识MAC地址"><a href="#7-3-认识MAC地址" class="headerlink" title="7.3 认识MAC地址"></a>7.3 认识MAC地址</h2><ul><li>MAC地址用来识别数据链路层中相连的节点；</li><li>MAC地址长度为48位（6个字节）一般用十六进制加上冒号的方式来表示，例如<code>08:00:27:03:fb:19</code></li><li>MAC地址在网卡出场的时候就确定了，不能被修改。虚拟机中的MAC地址并不是真实的MAC地址，可能会和已有的冲突（但虚拟机会检测冲突并及时修改，不然虚拟机就上不了网了）也有很少部分网卡支持用户配置MAC地址</li></ul><h3 id="7-3-1-MAC地址和IP协议的区别"><a href="#7-3-1-MAC地址和IP协议的区别" class="headerlink" title="7.3.1 MAC地址和IP协议的区别"></a>7.3.1 MAC地址和IP协议的区别</h3><p>MAC地址和IP地址的区别如下：</p><ul><li>IP地址描述的是路途总体的起点和终点</li><li>MAC地址描述的是路途上每一个小路由区间的起点和终点</li></ul><p>因为我们的主机不可能知道一个很远的内网主机的MAC地址，所以就需要MAC地址在小路由区间来标识起点和终点，并实现正确的数据传输。</p><h2 id="7-4-MTU对上层的影响"><a href="#7-4-MTU对上层的影响" class="headerlink" title="7.4 MTU对上层的影响"></a>7.4 MTU对上层的影响</h2><h3 id="7-4-1-MTU对IP的影响"><a href="#7-4-1-MTU对IP的影响" class="headerlink" title="7.4.1 MTU对IP的影响"></a>7.4.1 MTU对IP的影响</h3><p>在前文提到过，为了避免光电信号在物理层传输的时候出现冲突，需要限制网络层给数据链路层传输的单次的数据大小，MTU的具体说明可以参考本文 <a href="#jump1">2.2.1 认识MTU</a>；</p><p>因为MTU的存在，网络层IP协议中需要对较大的数据包进行分包（IP分片和组装问题在上文也谈过了，这里就不重复了）</p><p>但因为IP协议层分片和组装对于传输层来说是不可见的，如果IP分片后出现丢包导致数据丢失，那么传输层就必须得重传。所以传输层为了避免这种不受自己控制的事情，最终分片的操作应该是由<strong>传输层</strong>来进行处理才是最好的；</p><h3 id="7-4-2-MTU对UDP的影响"><a href="#7-4-2-MTU对UDP的影响" class="headerlink" title="7.4.2 MTU对UDP的影响"></a>7.4.2 MTU对UDP的影响</h3><p>UDP最大可以传输数据是 <code>2^16</code>字节，也就是<code>64KB</code>，而1500字节是<code>1.5KB</code>；也就是说，只要UDP携带的数据超过 <code>1472 (1500 - 20 IP首部 - 8 UDP首部)</code>，那么就会在网络层被分为多个IP数据报。</p><p>一旦这个数据报中有一个IP报文丢失了，那么整个UDP报文就会丢失。再加上UDP并没有超时重传机制（不过可以根据具体的协议来定制应答和重传机制来保证数据可靠性），UDP的报文在IP层中被分片后丢包的概率远大于TCP</p><h3 id="7-4-3-MTU对TCP的影响"><a href="#7-4-3-MTU对TCP的影响" class="headerlink" title="7.4.3 MTU对TCP的影响"></a>7.4.3 MTU对TCP的影响</h3><ul><li>TCP的一个数据报也不能无限大，还是受制于MTU</li><li>TCP的单个数据报的最大消息长度，称为<code>MSS(Max Segment Size)</code>; </li><li>TCP在建立连接的过程中，通信双方会进行MSS协商。最理想的情况， MSS的值正好是在IP不会被分片处理的最大长度(这个长度仍然是受制于数据链路层的 MTU)。</li><li>双方在发送SYN的时候会在TCP头部写入自己能支持的MSS值。然后双方得知对方的MSS值之后，选择较小的作为最终MSS，进行数据传输；</li><li>MSS的值在TCP首部的40字节变长选项中 <code>(kind=2)</code>；</li></ul><p><img src="https://img.musnow.top/i/2023/08/e1f2b9c52380a6bfb16d1e3ccb5c208d.png" alt="image-20230821185112918"></p><p><img src="https://img.musnow.top/i/2023/08/b4f7547b20f6d6207f43f2cee952dd35.png" alt="image-20230821202306869"></p><h2 id="7-5-ARP协议"><a href="#7-5-ARP协议" class="headerlink" title="7.5 ARP协议"></a>7.5 ARP协议</h2><h3 id="7-5-1-说明"><a href="#7-5-1-说明" class="headerlink" title="7.5.1 说明"></a>7.5.1 说明</h3><blockquote><p>ARP协议属于数据链路层，是MAC帧协议的上层</p></blockquote><p>因为在局域网内的传输时，我们是用mac地址来作为不同主机的标识符的，所以就必须存在一个IP地址到MAC地址的转换。</p><p>ARP协议也是包含在以太网帧格式中的，其中属于他自己的正文只有28个字节；因为MTU限制最小的数据长度是46字节，所以在发送ARP报文的时候，需要给这个28字节后面填补空位。</p><p><img src="https://img.musnow.top/i/2023/08/2e608f063bce6f728307d40d2aa275d3.png" alt="image-20230821192339835"></p><p>先来看看ARP请求&#x2F;应答中的各个字段的含义吧</p><ul><li>硬件类型：标定底层使用的是以太网还是其他帧格式，1为以太网</li><li>协议类型：指要转换的地址类型，<code>0X0800</code>为IP地址</li><li>硬件地址长度：对于以太网来说为6字节（这里填的是数字6，所以只需要占用1个字节）；</li><li>协议地址长度：对于IP地址来说为4字节（同上）；</li><li><code>op</code>字段为1表示ARP请求，2表示ARP应答</li></ul><p>当我们的主机开始发送报文之前，我们的主机是不知道某一个IP对于的目标主机的MAC地址的。所以就需要用ARP协议向局域网内发送一个请求，并得到目标主机的ARP响应，响应中就包含了该主机的MAC地址</p><h3 id="7-5-2-ARP请求-x2F-响应的流程"><a href="#7-5-2-ARP请求-x2F-响应的流程" class="headerlink" title="7.5.2 ARP请求&#x2F;响应的流程"></a>7.5.2 ARP请求&#x2F;响应的流程</h3><p>主机A需要给主机B发送数据，但是不知道主机B的MAC地址，它就需要发起一个ARP请求：</p><ul><li>以太网目的地址填为全F，代表广播；源地址填自己的MAC地址</li><li>帧类型填<code>0806</code>代表ARP协议</li><li>ARP中的OP填为1，代表是ARP请求</li><li>发送端以太网地址和IP地址填为<strong>主机A</strong>自己的MAC地址和自己的IP地址</li><li>目的以太网地址填为全F，IP地址填为目的的IP地址（注意我们是知道对方IP地址的）</li><li>向下交付给以太网的MAC帧，然后送入局域网</li></ul><p>这个ARP请求的报文就开始在局域网内进行<strong>广播</strong></p><ul><li>收到这个ARP请求的主机在MAC帧收到，并向上交付给自己的ARP层</li><li>ARP层先通过OP为1判断是ARP的请求</li><li>取出请求中的目的IP地址，判断是否为本机IP地址，不是则丢弃</li><li>是本机的IP地址，代表这个报文是发给自己的ARP请求，需要构造ARP响应</li></ul><p>于是<strong>主机B</strong>就收到了这个ARP请求，并开始构造ARP响应</p><ul><li>以太网目的地址填为ARP请求中的发送端MAC地址，源MAC地址填自己的</li><li>帧类型填<code>0806</code>代表ARP协议</li><li>ARP中的OP填2，代表ARP响应</li><li>发送端以太网地址和IP地址填为<strong>主机B</strong>自己的MAC地址和自己的IP地址</li><li>目的以太网地址填为A的MAC地址（在ARP请求中得知的）IP地址填为目的主机A的IP地址</li><li>向下交付给以太网的MAC帧，然后送入局域网</li></ul><p>此时这个ARP的响应就开始在局域网中传输，因为此时以太网的目的地址不再是全F，所以各个收到这个报文的主机，<strong>就可以直接通过MAC地址来判断是否是发给自己的MAC帧</strong>。如果不是就直接丢弃，不交付给上层；</p><p><strong>主机A</strong>判断目的MAC帧是自己的，交付给上层的ARP协议</p><ul><li>判断ARP中的OP为2，代表是ARP响应</li><li>因为前面已经判断过目的MAC地址是自己的了，所以这时候不需要判断ARP中的目的MAC和目的主机IP了</li><li>直接取出发送端主机MAC和主机IP，就能得到主机B的IP和MAC地址的映射关系</li></ul><p>这时候主机A就<strong>得到了主机B的MAC地址</strong>，可以正常进行数据的发送了！</p><h3 id="7-5-3-ARP缓存与更新"><a href="#7-5-3-ARP缓存与更新" class="headerlink" title="7.5.3 ARP缓存与更新"></a>7.5.3 ARP缓存与更新</h3><ul><li>任何一台主机发出的一定是ARP的请求；</li><li>接收到的ARP可能是对方向往发送的ARP请求，也可能是我发送的ARP请求的响应；</li></ul><p>但如果每台主机都不知道IP和MAC的映射关系，岂不是每次发送数据之前，都需要来个ARP请求和响应来获取对方MAC地址？这样整个局域网内就得被ARP请求和响应给塞满了。</p><p>所以，当我们发送了一个ARP请求后，应该需要将ARP响应给暂时<strong>缓存</strong>到本机上，避免下次发送的时候不知道对方的MAC地址。操作系统中就有一张ARP缓存表，保存了局域网内部分主机的IP和MAC地址的映射关系。</p><blockquote><p>如果一个主机想获取到局域网内所有的MAC地址，就可以写个循环，把局域网内的所有IP都发送一次ARP请求，再将收集到的ARP响应给缓存起来（因为局域网内的主机网络号都是相同的，主机号都是是从1到254，并不多，写个循环就行了）</p></blockquote><p>但这里会有一个问题：如果某台主机B离开了你这个局域网，主机C接入后，路由器给主机C分配了原本是给主机B用的IP，这时候主机A里面的ARP缓存表没有更新，还是填了主机B的MAC地址（但主机B其实已经不在局域网里面了），这时候这个报文岂不是找不到目标主机了？</p><p>所以ARP不仅仅需要缓存，还需要保有一定的<strong>更新机制</strong>：可以设置一个定时器，定时向缓存表中已有IP的主机发送一条ARP请求，并得到对方的ARP响应。这时候就可以比对返回的MAC地址是否有变动，有变动则更新。</p><p>如果一个ARP请求长时间没有得到响应，则可以认为该IP地址目前没有对应的主机，将其从缓存表中删除。</p><h3 id="7-5-4-中间人攻击"><a href="#7-5-4-中间人攻击" class="headerlink" title="7.5.4 中间人攻击"></a>7.5.4 中间人攻击</h3><p>上文讲述了ARP的请求和响应的格式，假设出现了下面的这个情况：</p><ul><li>主机A想获取主机B的MAC，发送ARP请求并获取到了响应</li><li>主机D把自己的IP伪装成主机B的IP，又给主机A发送了ARP响应</li><li>此时主机A更新了ARP缓存表，将主机B的IP B映射给了MAC D</li><li>主机D用同样的办法，将主机B的ARP缓存表中的IP A映射给了MAC D</li><li>此时主机A给B发送消息，填的是MAC D；B给A发消息，填的也是MAC D；</li><li>主机D在收到A和B双方通信的报文后，先交付给自己的上层，再转发给对方；</li><li>A和B的双方通信就出现了一个<strong>中间人D</strong>，此时如果你的信息不是加密的，那就可以被主机D所窃取！</li></ul><p>这也是为啥出现了https来避免中间人攻击！</p><h3 id="7-5-5-RARP"><a href="#7-5-5-RARP" class="headerlink" title="7.5.5  RARP"></a>7.5.5  RARP</h3><p>RARP（Reverse Address Resolution Protocol，逆地址解析协议）是一种网络协议，用于在局域网（LAN）中通过已知的物理地址查找相应的IP地址。</p><p>与前面讲述的ARP（Address Resolution Protocol，地址解析协议）不同，ARP用于通过已知的IP地址查找相应的物理地址，通常用于将网络层（IP）地址映射到链路层（MAC）地址。<strong>RARP则执行相反的操作</strong>，它允许主机在启动时使用其物理地址来请求分配给它的IP地址。</p><p>RARP协议在过去的计算机网络中用于在没有人工配置的情况下为计算机分配IP地址。当计算机启动时，它会向网络发送一个RARP请求包，其中包含它的物理地址（MAC地址），以请求分配一个IP地址。网络中的RARP服务器会接收这个请求并回复包含IP地址的RARP响应包。</p><p>然而，随着时间的推移，RARP的使用逐渐减少，主要是因为它的局限性，例如不太适用于大型网络，以及需要特定的服务器来管理地址分配。现代的网络通常使用DHCP（Dynamic Host Configuration Protocol，动态主机配置协议）来实现类似的功能，它更灵活且易于管理，可以自动分配IP地址以及其他网络配置参数给主机。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><h2 id="数据链路层"><a href="#数据链路层" class="headerlink" title="数据链路层"></a>数据链路层</h2><ul><li>数据链路层的作用：两个设备(同一种数据链路节点)之间进行传递数据；</li><li>以太网是一种技术标准；既包含了数据链路层的内容， 也包含了一些物理层的内容。 例如: 规定了网络拓扑结构, 访问控制方式, 传输速率等；</li><li>以太网帧格式</li><li>理解mac地址</li><li>理解arp协议</li><li>理解MTU</li></ul><h2 id="网络层"><a href="#网络层" class="headerlink" title="网络层"></a>网络层</h2><ul><li>网络层的作用: 在复杂的网络环境中确定一个合适的路径. </li><li>理解IP地址, 理解IP地址和MAC地址的区别</li><li>理解IP协议格式</li><li>了解网段划分方法</li><li>理解如何解决IP数目不足的问题, 掌握网段划分的两种方案</li><li>理解私有IP和公网IP</li><li>理解网络层的IP地址路由过程</li><li>理解一个数据包如何跨越网段到达最终目的地</li><li>理解IP数据包分包的原因</li><li>了解NAT设备的工作原理</li></ul><h2 id="传输层"><a href="#传输层" class="headerlink" title="传输层"></a>传输层</h2><ul><li>传输层的作用: 负责数据能够从发送端传输接收端</li><li>理解端口号的概念</li><li>认识UDP协议, 了解UDP协议的特点。</li><li>认识TCP协议，理解TCP协议的可靠性</li><li>理解TCP协议的状态转化</li><li>掌握TCP的连接管理，确认应答, 超时重传, 滑动窗口, 流量控制, 拥塞控制, 延迟应答, 捎带应答特性</li><li>理解TCP面向字节流, 理解粘包问题和解决方案</li><li>能够基于UDP实现可靠传输</li><li>理解MTU对UDP&#x2F;TCP的影响</li></ul><h2 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a>应用层</h2><ul><li>应用层的作用: 满足我们日常需求的网络程序, 都是在应用层</li><li>能够根据自己的需求，设计应用层协议</li><li>了解HTTP协议</li><li>理解DNS的原理和工作流程</li></ul>]]></content>
    
    
    <summary type="html">IP协议</summary>
    
    
    
    <category term="玩上Linux" scheme="https://blog.musnow.top/categories/%E7%8E%A9%E4%B8%8ALinux/"/>
    
    
    <category term="Linux" scheme="https://blog.musnow.top/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>【牛客网】BM001：翻转链表</title>
    <link href="https://blog.musnow.top/posts/3018206681/"/>
    <id>https://blog.musnow.top/posts/3018206681/</id>
    <published>2023-08-20T09:21:28.000Z</published>
    <updated>2023-08-20T09:21:28.000Z</updated>
    
    <content type="html"><![CDATA[<p>今天打算开启新一轮刷题了，必须得刷了，再不刷就得成废物了。</p><p>也希望看我博客的老哥能监督一下我，一起进步嘛！</p><span id="more"></span><h1 id="题目BM001"><a href="#题目BM001" class="headerlink" title="题目BM001"></a>题目BM001</h1><p>打算从<a href="https://www.nowcoder.com/exam/oj">牛客网的面试top101</a>开始刷起来，今天是<a href="https://www.nowcoder.com/practice/75e878df47f24fdc9dc3e400ec6058ca?tpId=295&tqId=23286&ru=/exam/oj&qru=/ta/format-top101/question-ranking&sourceUrl=/exam/oj">BM001反转链表</a></p><blockquote><p>给定一个单链表的头结点pHead(该头节点是有值的，比如在下图，它的val是1)，长度为n，反转该链表后，返回新链表的表头。</p><p>数据范围： <code>0≤n≤1000</code></p><p>要求：空间复杂度 <code>O(1)</code> ，时间复杂度 <code>O(n) </code>。</p></blockquote><h1 id="解法1：循环"><a href="#解法1：循环" class="headerlink" title="解法1：循环"></a>解法1：循环</h1><p>最简单的办法就是用指针来一个一个修改链接，每次都将当前节点的next链接为上一个节点，最终再将开头的节点（单独存一下原本的开头）的next链接为空，返回最后一个节点即可。</p><p>很常规的写法，参考注释</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode *<span class="title">ReverseList</span><span class="params">(ListNode *head)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// 因为需要O(1)空间复杂度，所以我们不能用很蠢的将数据遍历出来后倒序放回的办法</span></span><br><span class="line">        <span class="comment">// 时间复杂度是O(N) 也要求我们写的代码相对来说效率需要高一些</span></span><br><span class="line">        <span class="keyword">if</span> (head == <span class="literal">nullptr</span> || head-&gt;next == <span class="literal">nullptr</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> head; <span class="comment">// 只有一个或者为空的情况下，直接跳过</span></span><br><span class="line">        &#125;</span><br><span class="line">        ListNode *old_head = head; <span class="comment">// 单独存头</span></span><br><span class="line">        ListNode *A, *B, *C;       <span class="comment">// 三个指针</span></span><br><span class="line">        A = head;</span><br><span class="line">        B = head-&gt;next;</span><br><span class="line">        C = head-&gt;next-&gt;next;</span><br><span class="line">        <span class="keyword">while</span> (C != <span class="literal">nullptr</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// B修改链接为B的前一个（A在原视链表中是B的前一个）</span></span><br><span class="line">            B-&gt;next = A;</span><br><span class="line">            A = B;       <span class="comment">// A变成B（也相当于A在原视链表中，往后走一步）</span></span><br><span class="line">            B = C;       <span class="comment">// B往后走一步</span></span><br><span class="line">            C = C-&gt;next; <span class="comment">// C往后走一步</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 走到这里是B的下一个C已经为nullptr，代表B是最后一个节点</span></span><br><span class="line">        B-&gt;next = A; <span class="comment">// 依旧是链接</span></span><br><span class="line">        old_head-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">return</span> B; <span class="comment">// B是原视链表的最后一个节点，新链表的第一个节点</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="解法2：递归"><a href="#解法2：递归" class="headerlink" title="解法2：递归"></a>解法2：递归</h1><p>一般面试的时候，面试官更希望看到递归的办法，因为这样的代码更加简洁，思路也更加有挑战性（反正你就要往难的办法想）</p><p>递归的思路也是让下一个节点的next链接为当前节点。主要在于递归的末端条件应该是<code>head-&gt;next==nullptr</code>的时候就需要退出了，因为此时 <code>head-&gt;next-&gt;next</code>是无效的，没有办法进行链接。</p><p>整个过程大概就是下面这个简图了，其中方框代表的是节点，圆形代表每一步</p><p><img src="https://img.musnow.top/i/2023/08/4c5f69a4fcc4d859b3623b22ad5039fb.png" alt="image-20230820175040338"></p><p>上代码，这里将 <code>head-&gt;next = NULL;</code>是为了操作第一个节点（原视链表的首节点）的时候，将下一位改成空。而在中间节点的时候，因为当前节点的next会在<strong>上一层递归</strong>的时候被修改回去，所以设置为空不会出现问题。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ListNode *<span class="title">ReverseList</span><span class="params">(ListNode *head)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 特判：注意不要漏掉head-&gt;next==NULL的情况</span></span><br><span class="line">    <span class="keyword">if</span> (head == <span class="literal">NULL</span> || head-&gt;next == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 递归调用</span></span><br><span class="line">    ListNode *ans = <span class="built_in">ReverseList</span>(head-&gt;next);</span><br><span class="line">    <span class="comment">// 让当前结点的下一个结点的 next 指针指向当前节点</span></span><br><span class="line">    head-&gt;next-&gt;next = head;</span><br><span class="line">    <span class="comment">// 同时让当前结点的 next 指针指向NULL ，从而实现从链表尾部开始的局部反转</span></span><br><span class="line">    head-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;今天打算开启新一轮刷题了，必须得刷了，再不刷就得成废物了。&lt;/p&gt;
&lt;p&gt;也希望看我博客的老哥能监督一下我，一起进步嘛！&lt;/p&gt;</summary>
    
    
    
    <category term="把题目都给刷干净" scheme="https://blog.musnow.top/categories/%E6%8A%8A%E9%A2%98%E7%9B%AE%E9%83%BD%E7%BB%99%E5%88%B7%E5%B9%B2%E5%87%80/"/>
    
    
    <category term="C语言" scheme="https://blog.musnow.top/tags/C%E8%AF%AD%E8%A8%80/"/>
    
    <category term="OJ刷题" scheme="https://blog.musnow.top/tags/OJ%E5%88%B7%E9%A2%98/"/>
    
    <category term="牛客网" scheme="https://blog.musnow.top/tags/%E7%89%9B%E5%AE%A2%E7%BD%91/"/>
    
  </entry>
  
  <entry>
    <title>【C++11】future和async等</title>
    <link href="https://blog.musnow.top/posts/2885143113/"/>
    <id>https://blog.musnow.top/posts/2885143113/</id>
    <published>2023-08-19T02:55:38.000Z</published>
    <updated>2023-08-19T09:55:38.000Z</updated>
    
    <content type="html"><![CDATA[<p>C++11的future和async等关键字</p><span id="more"></span><h1 id="1-async和future的概念"><a href="#1-async和future的概念" class="headerlink" title="1.async和future的概念"></a>1.async和future的概念</h1><p><code>std::async</code> 和 <code>std::future</code> 是 C++11 引入的标准库功能，用于实现异步编程，使得在多线程环境中更容易处理并行任务。它们可以帮助你在不同线程中执行函数，并且能够方便地获取函数的结果。</p><p>在之前使用线程的时候，我们没有办法很好的获取到线程所执行函数的返回值。甚至更多时候，我们使用线程执行的都是不关心返回值的函数。如果真的想要获取线程函数的返回值，可以将一个指针作为输出型参数放入线程所执行的函数中。主执行流执行<code>t.join()</code>等待线程执行结束，并获取到这个返回值。</p><p>但这样并不是非常方便。于是C++11就引入了如上两个关键字来帮助我们获取到线程所执行函数的返回值。适用于异步执行某些耗时的函数，提高程序运行的效率：</p><ul><li>异步执行耗时函数</li><li>主执行流干其他事情</li><li>通过<code>std::future</code>获取到返回值</li><li>继续向后执行</li></ul><p>基本的并行概念在多线程部分都已经讲过了，这里就不多bb，直接上代码吧！</p><h1 id="2-使用"><a href="#2-使用" class="headerlink" title="2.使用"></a>2.使用</h1><h2 id="2-1-std-launch"><a href="#2-1-std-launch" class="headerlink" title="2.1 std::launch"></a>2.1 std::launch</h2><p>在使用<code>std::async</code>之前，还需要认识一个枚举类型 <a href="https://legacy.cplusplus.com/reference/future/launch/">launch</a>，在使用<code>std::async</code>的函数传参的时候会用到（这里先说一下，<code>std::async</code>是用来帮我们创建线程的）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum class</span> <span class="title class_">launch</span>; <span class="comment">// std::launch</span></span><br></pre></td></tr></table></figure><p>在 <code>cplusplus</code>网站上，有这个枚举类型的释义，这里面只有俩值</p><p><img src="https://img.musnow.top/i/2023/08/d4827a8d362281d078e27fea12c949c5.png" alt="image-20230819111941932"></p><p>说一下这俩值的区别</p><ul><li><code>launch::async</code>，立即创建一个线程来执行目标函数</li><li><code>launch::deferred</code>，不立即创建线程，而是等待调用<code>std::future</code>的<code>get()</code>函数时才调用（这个get函数是用来获取返回值的）</li></ul><p>好了知道这个就够了哈！</p><h2 id="2-2-std-result-of"><a href="#2-2-std-result-of" class="headerlink" title="2.2 std::result_of"></a>2.2 std::result_of</h2><p>这里还出现了另外一个关键字，就顺带也说说是干嘛的（其实我自己也不知道，现学现卖）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;type_traits&gt;</span> <span class="comment">// 头文件</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">Fn</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">result_of</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">Fn</span>, <span class="keyword">class</span>... ArgTypes&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">result_of</span>&lt;<span class="built_in">Fn</span>(ArgTypes...)&gt;;</span><br></pre></td></tr></table></figure><p>以下是 <code>std::result_of</code> 的基本用法和概念：</p><ol><li><strong>使用 <code>std::result_of</code> 获取函数调用的返回类型：</strong> 你可以通过将函数类型和参数类型传递给 <code>std::result_of</code> 来推导函数调用的返回类型。这使得你可以在编译时获取函数调用的结果类型，而不需要手动指定它。</li><li><strong>用法示例：</strong> 假设有一个函数 <code>int add(int a, int b)</code>，你可以使用 <code>std::result_of</code> 来获取该函数在给定参数下的返回类型。</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;type_traits&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::result_of&lt;<span class="keyword">decltype</span>(add) &amp;(<span class="type">int</span>, <span class="type">int</span>)&gt;::type result = <span class="built_in">add</span>(<span class="number">3</span>, <span class="number">5</span>);</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Result: &quot;</span> &lt;&lt; result &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ g++ test.cpp -o test -std=c++11</span><br><span class="line">$ ./test</span><br><span class="line">Result: 8</span><br></pre></td></tr></table></figure><p>需要注意的是，使用<code>decltype</code>关键字来指定函数指针的时候，函数名和函数参数之间需要加上<code>&amp;</code>，否则无法正确推导类型</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">decltype</span>(add) &amp;(<span class="type">int</span>, <span class="type">int</span>) <span class="comment">// 正确</span></span><br><span class="line"><span class="keyword">decltype</span>(add) (<span class="type">int</span>, <span class="type">int</span>) <span class="comment">// 错误    </span></span><br></pre></td></tr></table></figure><h2 id="2-3-async"><a href="#2-3-async" class="headerlink" title="2.3 async"></a>2.3 async</h2><p>先来看看async函数的样本，第一个情况是不显示传入 <code>std::launch</code>，第二个函数重载是传入了<code>std::launch</code>作为启动策略</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;future&gt;</span> <span class="comment">// 头文件</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// unspecified policy (1)</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">Fn</span>, <span class="keyword">class</span>... Args&gt;</span><br><span class="line">  future&lt;<span class="keyword">typename</span> result_of&lt;<span class="built_in">Fn</span>(Args...)&gt;::type&gt;</span><br><span class="line">    <span class="built_in">async</span> (Fn&amp;&amp; fn, Args&amp;&amp;... args);</span><br><span class="line"><span class="comment">// specific policy (2)</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">Fn</span>, <span class="keyword">class</span>... Args&gt;</span><br><span class="line">  future&lt;<span class="keyword">typename</span> result_of&lt;<span class="built_in">Fn</span>(Args...)&gt;::type&gt;</span><br><span class="line">    <span class="built_in">async</span> (launch policy, Fn&amp;&amp; fn, Args&amp;&amp;... args);</span><br></pre></td></tr></table></figure><p>在cplusplus网站上，说到了第一种情况是由编译器<strong>自主决定</strong>到底是采用 <code>std::launch::async</code> 或 <code>std::launch::deferred</code>，这就需要根据平台和编译器实现以及调用逻辑的不同来具体分析了。所以不建议使用第一个，还是直接指定<code>launch policy</code>（翻译过来是启动策略）的会好一点。</p><p>所以只看第二个👇</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">Fn</span>, <span class="keyword">class</span>... Args&gt;</span><br><span class="line">  future&lt;<span class="keyword">typename</span> result_of&lt;<span class="built_in">Fn</span>(Args...)&gt;::type&gt;</span><br><span class="line">    <span class="built_in">async</span> (launch policy, Fn&amp;&amp; fn, Args&amp;&amp;... args);</span><br></pre></td></tr></table></figure><p>这里采用了可变模板参数来接收多个函数参数，类似于可变参数列表。这里还使用了<code>typename</code>关键字来告知编译器<code>result_of&lt;Fn(Args...)&gt;::type</code>是一个参数类型，需要在模板实例化了之后再去获取确定的类型。而<code>class Fn</code>是一个函数指针的模板变量。</p><ul><li>第一个参数是<code>std::launch</code>，上文已经提到过两个不同选项的区别了</li><li>第二个参数是函数，直接丢函数名就可以了</li><li>第三个参数是这个函数的参数，也是直接丢参数就可以了</li></ul><p>如下是一个简单的调用示例（并非完整示例）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;future&gt;</span> <span class="comment">// 头文件</span></span></span><br><span class="line"><span class="comment">// 函数</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 调用</span></span><br><span class="line">std::<span class="built_in">async</span>(std::launch::async, add, <span class="number">3</span>, <span class="number">5</span>);</span><br></pre></td></tr></table></figure><p>调用了这个函数后，CPP会帮我们创建一个线程来执行函数，并根据第一个启动参数的不同，决定啥时候创建这个线程。最终我们可以通过<code>future</code>获取到线程执行函数的返回值。</p><h2 id="2-4-future"><a href="#2-4-future" class="headerlink" title="2.4 future"></a>2.4 future</h2><p>人如其名，这个类型是用来声明一个<code>未来</code>的变量的。因为<code>std::async</code>会帮我们创建一个线程来执行函数，此时该线程函数的返回值是未知的，这个未来变量就是提前的一个声明，当线程执行完毕函数并返回值的时候，这个变量的值才真正被初始化为我们真正需要的那个值。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;  future;</span><br><span class="line"><span class="comment">// specialization : T is a reference type (R&amp;)</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">R</span>&amp;&gt; future&lt;R&amp;&gt;;     </span><br><span class="line"><span class="comment">// specialization : T is void</span></span><br><span class="line"><span class="keyword">template</span> &lt;&gt;         future&lt;<span class="type">void</span>&gt;;  </span><br></pre></td></tr></table></figure><p>其有如下几个成员函数</p><ul><li>get：获取对应async所执行函数的返回值，如果函数没有执行完毕则阻塞等待</li><li>valid：bool，判断当前future类型到底有没有和一个async函数所对应</li><li>share：将<code>future</code>对象转成一个<code>std::shared_future</code>对象</li><li>wait：等待异步任务完成，但不获取结果</li><li>wait_for：等待异步任务完成，但有等待的时长（没等到就返回错误）</li><li>wait_until：等待异步任务完成，直到一个确定的时间（没等到就返回错误）</li></ul><p>后面三个wait函数和CPP线程中的wait函数如出一辙。</p><h2 id="2-5-share-future"><a href="#2-5-share-future" class="headerlink" title="2.5 share_future"></a>2.5 share_future</h2><p><code>share_future</code>就好比<code>share_ptr</code>智能指针，其让<code>future</code>对象从单一所有权变成了多人可用。本来是一个只能坐一人的餐桌，现在变成了可以坐很多人的大桌子。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;  shared_future;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">R</span>&amp;&gt; shared_future&lt;R&amp;&gt;;   <span class="comment">// specialization : T is a reference type (R&amp;)</span></span><br><span class="line"><span class="keyword">template</span> &lt;&gt;         shared_future&lt;<span class="type">void</span>&gt;; <span class="comment">// specialization : T is void</span></span><br></pre></td></tr></table></figure><p>成员函数和<code>future</code>完全一样（只不过么有<code>share()</code>函数）这里就不赘述了；</p><ul><li><code>future</code>是单人餐桌，一次只能有一个线程执行get函数；当get被执行后，这个future会<strong>失效</strong>。</li><li><code>share_future</code>是大桌子，所有人一起坐在这个桌子上等服务员上菜，互不干扰；</li></ul><h2 id="2-5-测试"><a href="#2-5-测试" class="headerlink" title="2.5 测试"></a>2.5 测试</h2><h3 id="2-5-1-正常测试"><a href="#2-5-1-正常测试" class="headerlink" title="2.5.1 正常测试"></a>2.5.1 正常测试</h3><p>如下代码是一个简单的使用示例，并且通过提供不同的<code>std::launch</code>启动策略，我们也能观察到不同的现象</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;future&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;type_traits&gt;</span> <span class="comment">// result_of</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/unistd.h&gt;</span> <span class="comment">//sleep</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Add  Thread &quot;</span> &lt;&lt; std::this_thread::<span class="built_in">get_id</span>() &lt;&lt; <span class="string">&quot; | Sleeping before add...&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="built_in">sleep</span>(<span class="number">4</span>);</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Main Thread &quot;</span> &lt;&lt; std::this_thread::<span class="built_in">get_id</span>() &lt;&lt; <span class="string">&quot; | Start&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="comment">//std::future&lt;int&gt; futureResult = std::async(std::launch::deferred, add, 3, 5); // 不会创建新线程</span></span><br><span class="line">    std::future&lt;<span class="type">int</span>&gt; futureResult = std::<span class="built_in">async</span>(std::launch::async, add, <span class="number">3</span>, <span class="number">5</span>); <span class="comment">// 创建新线程</span></span><br><span class="line">    <span class="built_in">sleep</span>(<span class="number">3</span>); </span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Main Thread &quot;</span> &lt;&lt; std::this_thread::<span class="built_in">get_id</span>() &lt;&lt; <span class="string">&quot; | Waiting for result...&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="type">int</span> result = futureResult.<span class="built_in">get</span>();  <span class="comment">// 等待异步任务完成并获取结果</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Main Thread &quot;</span> &lt;&lt; std::this_thread::<span class="built_in">get_id</span>() &lt;&lt; <span class="string">&quot; | Result: &quot;</span> &lt;&lt; result &lt;&lt; std::endl;</span><br><span class="line">    <span class="built_in">sleep</span>(<span class="number">3</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果使用<code>std::launch::async</code>作为启动策略，可以看到，执行add函数的线程id和主线程的id是不同的，通过linux下的<code>ps -aL</code>命令也能观察到出现两个线程</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> :; <span class="keyword">do</span> ps jax | <span class="built_in">head</span> -1 &amp;&amp; ps -aL |  grep -v grep;<span class="built_in">sleep</span> 1; <span class="built_in">echo</span> <span class="string">&quot;########################&quot;</span>; <span class="keyword">done</span></span><br></pre></td></tr></table></figure><p>程序执行输出结果</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Main Thread 139869475694400 | Start</span><br><span class="line">Add  Thread 139869457655552 | Sleeping before add...</span><br><span class="line">Main Thread 139869475694400 | Waiting for result...</span><br><span class="line">Main Thread 139869475694400 | Result: 8</span><br></pre></td></tr></table></figure><p>但如果使用<code>std::launch::deferred</code>作为启动策略，则会发现这两个线程的id是完全相同的，这代表实际上其执行了并行的策略</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Main Thread 139789724776256 | Start</span><br><span class="line">Main Thread 139789724776256 | Waiting for result...</span><br><span class="line">Add  Thread 139789724776256 | Sleeping before add...</span><br><span class="line">Main Thread 139789724776256 | Result: 8</span><br></pre></td></tr></table></figure><h3 id="2-5-2-多线程get一个future"><a href="#2-5-2-多线程get一个future" class="headerlink" title="2.5.2 多线程get一个future"></a>2.5.2 多线程get一个future</h3><p>在如下代码中，我写了一个<code>void future_get_func(std::future&lt;int&gt;&amp; fu)</code>的函数，尝试开一个线程来get，然后主执行流又get一次，看看会发生什么。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;future&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;type_traits&gt;</span> <span class="comment">// result_of</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/unistd.h&gt;</span> <span class="comment">// sleep</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Add  Thread &quot;</span> &lt;&lt; std::this_thread::<span class="built_in">get_id</span>() &lt;&lt; <span class="string">&quot; | Sleeping before add...&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="built_in">sleep</span>(<span class="number">4</span>);</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">future_get_func_shared</span><span class="params">(std::shared_future&lt;<span class="type">int</span>&gt;&amp; fu)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> result = fu.<span class="built_in">get</span>();  <span class="comment">// 等待异步任务完成并获取结果</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Func Thread &quot;</span> &lt;&lt; std::this_thread::<span class="built_in">get_id</span>() &lt;&lt; <span class="string">&quot; | Result: &quot;</span> &lt;&lt; result &lt;&lt; std::endl;</span><br><span class="line">    <span class="built_in">sleep</span>(<span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">future_get_func</span><span class="params">(std::future&lt;<span class="type">int</span>&gt;&amp; fu)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> result = fu.<span class="built_in">get</span>();  <span class="comment">// 等待异步任务完成并获取结果</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Func Thread &quot;</span> &lt;&lt; std::this_thread::<span class="built_in">get_id</span>() &lt;&lt; <span class="string">&quot; | Result: &quot;</span> &lt;&lt; result &lt;&lt; std::endl;</span><br><span class="line">    <span class="built_in">sleep</span>(<span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Main Thread &quot;</span> &lt;&lt; std::this_thread::<span class="built_in">get_id</span>() &lt;&lt; <span class="string">&quot; | Start&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="comment">//std::future&lt;int&gt; futureResult = std::async(std::launch::deferred, add, 3, 5); // 不会创建新线程</span></span><br><span class="line">    std::future&lt;<span class="type">int</span>&gt; futureResult = std::<span class="built_in">async</span>(std::launch::async, add, <span class="number">3</span>, <span class="number">5</span>); <span class="comment">// 创建新线程</span></span><br><span class="line">    <span class="built_in">sleep</span>(<span class="number">3</span>); </span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Main Thread &quot;</span> &lt;&lt; std::this_thread::<span class="built_in">get_id</span>() &lt;&lt; <span class="string">&quot; | Waiting for result...&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 尝试测试多线程get会发生什么</span></span><br><span class="line">    </span><br><span class="line">    <span class="function">std::thread <span class="title">t1</span><span class="params">(future_get_func, std::ref(futureResult))</span></span>; <span class="comment">// 开个线程来get</span></span><br><span class="line">    t1.<span class="built_in">detach</span>(); <span class="comment">// 直接分离线程</span></span><br><span class="line">    <span class="built_in">sleep</span>(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> result = futureResult.<span class="built_in">get</span>();  <span class="comment">// 等待异步任务完成并获取结果</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Main Thread &quot;</span> &lt;&lt; std::this_thread::<span class="built_in">get_id</span>() &lt;&lt; <span class="string">&quot; | Result: &quot;</span> &lt;&lt; result &lt;&lt; std::endl;</span><br><span class="line">    <span class="built_in">sleep</span>(<span class="number">3</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>需要注意的是，如下创建线程的传参必须要用<code>std::ref</code>包裹，来告知线程这是一个引用对象，否则编译会报错。因为 <code>std::thread</code> 要求参数可以在<strong>构造函数中被调用</strong>，而 <code>std::future</code> 并不能直接传递给 <code>std::thread</code>；</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::thread <span class="title">t1</span><span class="params">(future_get_func, std::ref(futureResult))</span></span>; <span class="comment">//正确</span></span><br><span class="line"><span class="function">std::thread <span class="title">t1</span><span class="params">(future_get_func, futureResult)</span></span>; <span class="comment">//错误</span></span><br></pre></td></tr></table></figure><p>编译通过后执行，会发现跑出来了一个<code>std::future_error</code>异常，代表我们在一个无效的<code>future</code>上调用了<code>get</code>函数。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Main Thread 139869577889600 | Start</span><br><span class="line">Add  Thread 139869559850752 | Sleeping before add...</span><br><span class="line">Main Thread 139869577889600 | Waiting for result...</span><br><span class="line">Func Thread 139869551458048 | Result: 8</span><br><span class="line">terminate called after throwing an instance of &#x27;std::future_error&#x27;</span><br><span class="line">  what():  std::future_error: No associated state</span><br><span class="line">Aborted</span><br></pre></td></tr></table></figure><p>记住了，<code>std::future</code>在调用了一次<code>get</code>之后将不再与对应的<code>std::async</code>关联，所以才会需要<code>share_future</code>的出现！</p><p>改成<code>share_future</code>再执行上面这套逻辑，就会发现成功跑起来了</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Main Thread 140369883957056 | Start</span><br><span class="line">Add  Thread 140369865918208 | Sleeping before add...</span><br><span class="line">Main Thread 140369883957056 | Waiting for result...</span><br><span class="line">Func Thread 140369857525504 | Result: 8</span><br><span class="line">Main Thread 140369883957056 | Result: 8</span><br></pre></td></tr></table></figure><h3 id="2-5-3-异常处理"><a href="#2-5-3-异常处理" class="headerlink" title="2.5.3 异常处理"></a>2.5.3 异常处理</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Add  Thread &quot;</span> &lt;&lt; std::this_thread::<span class="built_in">get_id</span>() &lt;&lt; <span class="string">&quot; | Sleeping before add...&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="built_in">sleep</span>(<span class="number">4</span>);</span><br><span class="line">    <span class="keyword">throw</span> std::<span class="built_in">runtime_error</span>(<span class="string">&quot;An error occurred&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果<code>async</code>执行的函数中抛出了异常，那么这个异常将会被传回主执行流，可以在主执行流中被处理。而如果直接使用线程来执行这个函数，其异常不会被捕捉，而是会导致整个进程退出。</p><p>下图，使用async运行，成功打印出异常（捕获成功）</p><p><img src="https://img.musnow.top/i/2023/08/b54e8cd394dd45ba670b272df2a385a3.png" alt="image-20230819141820459"></p><p>下图，使用线程运行，进程退出</p><p><img src="https://img.musnow.top/i/2023/08/4a36220784bc763e51be69552f6211d1.png" alt="image-20230819141716295"></p><h2 id="2-6-launch-deferred的真正意义"><a href="#2-6-launch-deferred的真正意义" class="headerlink" title="2.6 launch::deferred的真正意义"></a>2.6 launch::deferred的真正意义</h2><p>如果<code>std::launch::deferred</code>是同步执行，这样写不是多此一举吗？</p><p>NONONO 非也非也，和直接调用<code>Add</code>函数相比，用这样的方式调用<code>Add</code>函数还是有些区别的：</p><ul><li>推迟执行：直接调用Add函数是立马执行，但是用async可以推迟到调用get的时候才执行</li><li>延迟计算：有的时候我们并不是需要立马使用这个函数的返回值，所以就可以延迟一会再执行这个函数，先把函数的调用搞起来，后面只需要一个get就能获取到结果了</li><li>避免线程创建：并不是什么时候多线程都更好，有些时候创建一个线程的消耗还不如直接执行函数来的快（比如函数干的活很小的情况）</li></ul><p>所以，这个关键字多少还是有点作用了。</p><h2 id="2-7-future-error-x2F-errc-x2F-status"><a href="#2-7-future-error-x2F-errc-x2F-status" class="headerlink" title="2.7 future_error&#x2F;errc&#x2F;status"></a>2.7 future_error&#x2F;errc&#x2F;status</h2><p>除了<code>future</code>和<code>share_future</code>，还有如下几个类型</p><ol><li><strong><code>std::future_error</code>：</strong> <code>std::future_error</code> 是一个异常类，用于表示与 <code>std::future</code> 相关的错误。当在使用 <code>std::future</code> 时出现错误，例如获取结果时异步任务抛出了异常，就会抛出 <code>std::future_error</code> 异常。它是一个<strong>标准异常类型</strong>，通常通过捕获异常对象来处理异步任务执行过程中的问题。</li><li><strong><code>std::future_errc</code>：</strong> <code>std::future_errc</code> 是一个枚举类型，用于表示 <code>std::future_error</code> 中的不同错误情况。这样的枚举类型是为了在处理异常时更加明确和方便。它包含了一系列可能的错误，如 <code>broken_promise</code>（promise 被破坏，即 promise 对象的 set_value 或 set_exception 被多次调用）和 <code>future_already_retrieved</code>（future 对象已经被获取过一次）等。</li><li><strong><code>std::future_status</code>：</strong> <code>std::future_status</code> 是一个枚举类型，用于表示 <code>std::future</code> 的状态。它描述了一个 <code>std::future</code> 对象的当前情况，指示异步任务是否已完成、是否有效等。<code>std::future_status</code> 包含三个值：<code>ready</code>（异步任务已完成，可以获取结果）、<code>timeout</code>（等待超时，即异步任务还未完成）、<code>deferred</code>（异步任务延迟执行）。</li></ol><h1 id="3-为什么C-会出现futrue？"><a href="#3-为什么C-会出现futrue？" class="headerlink" title="3.为什么C++会出现futrue？"></a>3.为什么C++会出现futrue？</h1><p>为啥要出一个future？直接用老办法不也可以这么玩吗？</p><p>C++ 标准库引入 <code>std::future</code> 和相关的异步编程机制，是为了更好地支持并发编程和多线程环境。这些机制的出现有几个原因和动机：</p><ol><li><strong>并发性和性能提升：</strong> 在现代计算机体系结构中，多核处理器已经成为常态。为了充分利用这些多核资源，编写并发代码变得重要。<code>std::future</code> 提供了一种方式，可以在多个线程中同时执行任务，并且可以方便地获取任务的结果，从而允许程序在多核处理器上并行执行，提高性能。</li><li><strong>任务分离：</strong> 在很多情况下，我们希望将一个大的任务拆分成多个子任务，在不同的线程中并行执行，然后合并子任务的结果。<code>std::future</code> 允许你在一个线程中等待另一个线程的任务完成，从而支持这种任务分离和并行执行的模式。</li><li><strong>避免阻塞：</strong> 在传统的同步编程中，如果某个操作需要等待，会导致线程阻塞。而异步编程机制允许线程继续执行其他操作，而不必等待一个潜在的耗时操作完成。<code>std::future</code> 允许你在一个线程中发起异步操作，并在需要的时候获取操作的结果，从而避免了不必要的阻塞。</li><li><strong>异常处理：</strong> 在多线程环境中，处理异步任务的异常可能变得复杂，因为异步任务在不同的线程中执行。<code>std::future</code> 引入了异常传递机制，允许异步任务在执行过程中抛出异常，并将这些异常传递到等待结果的线程中。</li></ol><p>总之，C++ 的 <code>std::future</code> 和相关的异步编程机制提供了一种更高级别、更方便的方式来处理多线程并发编程。这些机制使得开发者能够更容易地利用多核处理器的性能，并更灵活地设计并发代码，从而在面对并发和异步任务时能够更好地管理资源、提高效率和处理异常。</p><h1 id="4-promise"><a href="#4-promise" class="headerlink" title="4.promise"></a>4.promise</h1><h2 id="4-1-概念"><a href="#4-1-概念" class="headerlink" title="4.1 概念"></a>4.1 概念</h2><p><code>std::promise</code> 是 C++ 标准库中用于在一个线程中产生结果，然后在另一个线程中获取结果的工具。它提供了一些成员函数来设置结果、处理异常以及获取关联的 <code>std::future</code> 对象等。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;  promise;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">R</span>&amp;&gt; promise&lt;R&amp;&gt;;     <span class="comment">// specialization : T is a reference type (R&amp;)</span></span><br><span class="line"><span class="keyword">template</span> &lt;&gt;         promise&lt;<span class="type">void</span>&gt;;   <span class="comment">// specialization : T is void</span></span><br></pre></td></tr></table></figure><p>下面是一些常用的 <code>std::promise</code> 成员函数及其用法：</p><ol><li><p><strong><code>set_value</code>：</strong> 用于设置结果值。如果你已经通过 <code>get_future()</code> 获取了一个 <code>std::future</code> 对象，调用 <code>set_value</code> 将会使等待结果的线程被唤醒并获取结果。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">std::promise&lt;<span class="type">int</span>&gt; promiseObj;</span><br><span class="line">std::future&lt;<span class="type">int</span>&gt; futureResult = promiseObj.<span class="built_in">get_future</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在某个线程中设置结果值</span></span><br><span class="line">promiseObj.<span class="built_in">set_value</span>(<span class="number">42</span>);</span><br></pre></td></tr></table></figure></li><li><p><strong><code>set_exception</code>：</strong> 用于设置异常，将在等待结果的线程中抛出。这允许你在产生结果的线程中处理异常情况。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 产生异常</span></span><br><span class="line">    <span class="keyword">throw</span> std::<span class="built_in">runtime_error</span>(<span class="string">&quot;An error occurred&quot;</span>);</span><br><span class="line">&#125; </span><br><span class="line"><span class="built_in">catch</span> (...) </span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 将异常设置到 promise 对象中</span></span><br><span class="line">    promiseObj.<span class="built_in">set_exception</span>(std::<span class="built_in">current_exception</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong><code>get_future</code>：</strong> 返回与 <code>std::promise</code> 关联的 <code>std::future</code> 对象。通过这个 <code>std::future</code>，你可以在另一个线程中等待并获取结果。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">std::promise&lt;<span class="type">int</span>&gt; promiseObj;</span><br><span class="line">std::future&lt;<span class="type">int</span>&gt; futureResult = promiseObj.<span class="built_in">get_future</span>();</span><br></pre></td></tr></table></figure></li><li><p><strong><code>swap</code>：</strong> 交换两个 <code>std::promise</code> 对象的状态，包括关联的 <code>std::future</code> 对象和设置的结果。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">std::promise&lt;<span class="type">int</span>&gt; promise1;</span><br><span class="line">std::promise&lt;<span class="type">int</span>&gt; promise2;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 交换两个 promise 对象的状态</span></span><br><span class="line">promise1.<span class="built_in">swap</span>(promise2);</span><br></pre></td></tr></table></figure></li><li><p><strong><code>valid</code>：</strong> 检查 <code>std::promise</code> 对象是否有效，即是否与一个 <code>std::future</code> 对象关联。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">std::promise&lt;<span class="type">int</span>&gt; promiseObj;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (promiseObj.<span class="built_in">valid</span>()) &#123;</span><br><span class="line">    <span class="comment">// promiseObj 有效</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// promiseObj 无效</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>还有下面这俩个成员函数，看名字也能猜出来它是干嘛的，就不多说了</p><ul><li><p><a href="https://legacy.cplusplus.com/reference/future/promise/set_value_at_thread_exit/"><strong>set_value_at_thread_exit</strong></a></p><p>Set value at thread exit (public member function )</p></li><li><p><a href="https://legacy.cplusplus.com/reference/future/promise/set_exception_at_thread_exit/"><strong>set_exception_at_thread_exit</strong></a></p><p>Set exception at thread exit (public member function )</p></li></ul><p>这些成员函数允许你在一个线程中产生结果或异常，<strong>并在另一个线程中等待和处理这些结果或异常</strong>。它们为多线程编程提供了一种可靠的方式来传递数据和控制流。请注意，在使用 <code>std::promise</code> 时，你需要仔细处理异常和线程同步，以确保正确的结果传递。</p><h2 id="4-2-示例"><a href="#4-2-示例" class="headerlink" title="4.2 示例"></a>4.2 示例</h2><p>然后下头是一个基本的使用示例；你可以理解为<code>promise</code>就是一个用来承担线程所执行函数的参数和异常的一个变量，我们可以通过<code>set_value</code>并在主执行流中使用<code>future.get</code>来获取到这个值，也可以设置异常，并在主执行流中处理这个异常；</p><p>不过<code>promise</code>和<code>future</code>一样，是<strong>一次性</strong>的，设置value和异常都只能设置一次，设置完毕后就不能再设置了</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;future&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">worker</span><span class="params">(std::promise&lt;<span class="type">int</span>&gt;&amp; p)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    p.<span class="built_in">set_value</span>(<span class="number">42</span>); <span class="comment">// 设置值</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::promise&lt;<span class="type">int</span>&gt; promiseObj;</span><br><span class="line">    std::future&lt;<span class="type">int</span>&gt; futureResult = promiseObj.<span class="built_in">get_future</span>();</span><br><span class="line"></span><br><span class="line">    <span class="function">std::thread <span class="title">t</span><span class="params">(worker, std::ref(promiseObj))</span></span>; <span class="comment">// 通过线程执行</span></span><br><span class="line">    t.<span class="built_in">join</span>();</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> result = futureResult.<span class="built_in">get</span>(); <span class="comment">// 主线程中获取值</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Result: &quot;</span> &lt;&lt; result &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="5-packaged-task"><a href="#5-packaged-task" class="headerlink" title="5.packaged_task"></a>5.packaged_task</h1><p><code>std::packaged_task</code> 是 C++ 标准库中的一个类模板，用于将一个可调用对象（函数、函数对象或可调用成员函数）封装成一个可以<strong>异步</strong>执行的任务，并且可以通过 <code>std::future</code> 获取任务的返回值。它在多线程编程中起到了连接异步任务和线程间通信的桥梁作用。</p><p><code>std::packaged_task</code> 的主要作用有以下几个方面：</p><ol><li><strong>封装任务：</strong> <code>std::packaged_task</code> 允许你将一个可调用对象封装成一个任务，这个任务可以在另一个线程中异步执行。你可以将函数、函数对象或可调用成员函数封装为一个 <code>std::packaged_task</code> 实例。</li><li><strong>异步执行：</strong> 通过将 <code>std::packaged_task</code> 实例传递给一个 <code>std::thread</code> 或其他支持异步执行的机制，你可以在新的线程中执行封装的任务，而不需要显式创建线程函数。</li><li><strong>获取返回值：</strong> <code>std::packaged_task</code> 可以与 <code>std::future</code> 一起使用，以获取异步任务的返回值。你可以通过 <code>packaged_task</code> 的 <code>get_future</code> 方法获取一个与任务关联的 <code>std::future</code> 对象，然后在适当的时候使用 <code>std::future</code> 的 <code>get</code> 方法来获取任务的返回值。</li><li><strong>线程池：</strong> <code>std::packaged_task</code> 结合线程池的使用，可以更灵活地控制任务的执行方式。线程池可以预先创建一组线程，然后将封装好的任务分配给这些线程执行，避免了频繁创建和销毁线程的开销。</li></ol><h2 id="5-1-示例"><a href="#5-1-示例" class="headerlink" title="5.1 示例"></a>5.1 示例</h2><p>下面是一个简单示例，演示了如何使用 <code>std::packaged_task</code> 来异步执行一个函数并获取其返回值</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;future&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">std::packaged_task&lt;<span class="title">int</span><span class="params">(<span class="type">int</span>, <span class="type">int</span>)</span>&gt; <span class="title">task</span><span class="params">(add)</span></span>;</span><br><span class="line">    std::future&lt;<span class="type">int</span>&gt; future = task.<span class="built_in">get_future</span>();</span><br><span class="line"></span><br><span class="line">    <span class="function">std::thread <span class="title">worker</span><span class="params">(std::move(task), <span class="number">3</span>, <span class="number">5</span>)</span></span>;</span><br><span class="line">    worker.<span class="built_in">join</span>(); <span class="comment">// 通过线程异步执行这个task</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> result = future.<span class="built_in">get</span>(); <span class="comment">// 等待返回值</span></span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Result: &quot;</span> &lt;&lt; result &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个例子中，<code>std::packaged_task</code> 封装了一个函数 <code>add</code>，然后通过 <code>std::thread</code> 异步执行，最后通过 <code>std::future</code> 获取异步任务的返回值。</p><h2 id="5-2-make-ready-at-thread-exit"><a href="#5-2-make-ready-at-thread-exit" class="headerlink" title="5.2 make_ready_at_thread_exit"></a>5.2 make_ready_at_thread_exit</h2><p><code>packaged_task</code>的成员函数中，主要还是这个需要单独说明；先看如下代码</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;future&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">std::packaged_task&lt;<span class="title">int</span><span class="params">()</span>&gt; <span class="title">task</span><span class="params">([]()&#123; <span class="keyword">return</span> <span class="number">42</span>; &#125;)</span></span>;</span><br><span class="line">    std::future&lt;<span class="type">int</span>&gt; future = task.<span class="built_in">get_future</span>();</span><br><span class="line"></span><br><span class="line">    <span class="function">std::thread <span class="title">worker</span><span class="params">([&amp;task]() &#123;</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="comment">// 模拟一些工作</span></span></span></span><br><span class="line"><span class="params"><span class="function">        std::this_thread::sleep_for(std::chrono::seconds(<span class="number">2</span>));</span></span></span><br><span class="line"><span class="params"><span class="function"></span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="comment">// 设置任务结果值</span></span></span></span><br><span class="line"><span class="params"><span class="function">        task.make_ready_at_thread_exit();</span></span></span><br><span class="line"><span class="params"><span class="function">    &#125;)</span></span>;</span><br><span class="line"></span><br><span class="line">    worker.<span class="built_in">detach</span>(); <span class="comment">// 分离线程，不等待其结束</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 等待任务结果</span></span><br><span class="line">    <span class="type">int</span> result = future.<span class="built_in">get</span>();</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Result: &quot;</span> &lt;&lt; result &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们让<code>packaged_task</code>执行的是一个<code>return 42</code>的函数，而线程里面还会进行其他处理。</p><p>而<code>make_ready_at_thread_exit()</code>的作用，就是确认当前的<code>worker</code>线程已经干完自己的活了，可以执行<code>packaged_task</code>封装的函数了！</p><p>相当于是一个确认<code>packaged_task</code>中封装的任务到底在什么时候执行的一个函数。调用这个函数的时候，就会开始执行其包装的异步函数，并返回结果给<code>future.get()</code>的执行流</p><h1 id="The-end"><a href="#The-end" class="headerlink" title="The end"></a>The end</h1><p>收工</p>]]></content>
    
    
    <summary type="html">C++11的future和async等</summary>
    
    
    
    <category term="遇见C++" scheme="https://blog.musnow.top/categories/%E9%81%87%E8%A7%81C/"/>
    
    
    <category term="Linux" scheme="https://blog.musnow.top/tags/Linux/"/>
    
    <category term="C++" scheme="https://blog.musnow.top/tags/C/"/>
    
    <category term="C++11" scheme="https://blog.musnow.top/tags/C-11/"/>
    
  </entry>
  
  <entry>
    <title>【面经】230816云账房一面</title>
    <link href="https://blog.musnow.top/posts/1199148787/"/>
    <id>https://blog.musnow.top/posts/1199148787/</id>
    <published>2023-08-16T10:32:14.000Z</published>
    <updated>2023-08-16T10:32:14.000Z</updated>
    
    <content type="html"><![CDATA[<p>230816云账房一面</p><span id="more"></span><h2 id="1-什么是移动构造"><a href="#1-什么是移动构造" class="headerlink" title="1.什么是移动构造"></a>1.什么是移动构造</h2><h2 id="2-循环链表如何实现"><a href="#2-循环链表如何实现" class="headerlink" title="2.循环链表如何实现"></a>2.循环链表如何实现</h2><h2 id="3-用了那些stl容器"><a href="#3-用了那些stl容器" class="headerlink" title="3.用了那些stl容器"></a>3.用了那些stl容器</h2><h2 id="4-树的类型"><a href="#4-树的类型" class="headerlink" title="4.树的类型"></a>4.树的类型</h2><p>这里问了我mysql用的是什么，我答了红黑树。但其实是B+树（没学）</p><h2 id="5-C-11新特性"><a href="#5-C-11新特性" class="headerlink" title="5.C++11新特性"></a>5.C++11新特性</h2><h2 id="6-C-11future"><a href="#6-C-11future" class="headerlink" title="6.C++11future"></a>6.C++11future</h2><p>没听说过，得学</p><h2 id="7-linux进程通信的方式"><a href="#7-linux进程通信的方式" class="headerlink" title="7.linux进程通信的方式"></a>7.linux进程通信的方式</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">管道 </span><br><span class="line">共享内存</span><br><span class="line">信号量</span><br><span class="line">socket</span><br><span class="line">本地文件</span><br></pre></td></tr></table></figure><p>全答出来了，还问了谁最快（共享内存最快）</p><p>然后又问了进程之间如何同步（不会）</p><p>tnnd现在才想起来。进程同步直接用信号量就可以啊！！！！！我怎么信号量答出来了不知到这玩意是干嘛的呢……说白了还是学艺不精</p><h2 id="8-git的基本命令"><a href="#8-git的基本命令" class="headerlink" title="8.git的基本命令"></a>8.git的基本命令</h2><p>我说了下面这些</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">git add </span><br><span class="line">git push</span><br><span class="line">git commit </span><br><span class="line">git log</span><br><span class="line">git reset </span><br><span class="line">git rebase</span><br><span class="line">git merge</span><br></pre></td></tr></table></figure><h2 id="9-版本号管理"><a href="#9-版本号管理" class="headerlink" title="9.版本号管理"></a>9.版本号管理</h2><p>我答我用了3个版本号</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">大版本.功能版本.bug修复版本</span><br></pre></td></tr></table></figure><h2 id="谢谢惠顾"><a href="#谢谢惠顾" class="headerlink" title="谢谢惠顾"></a>谢谢惠顾</h2><p>泻药，太多东西没答上来，已经发了感谢信了</p>]]></content>
    
    
    <summary type="html">230816云账房一面</summary>
    
    
    
    <category term="求职路上一去不复返" scheme="https://blog.musnow.top/categories/%E6%B1%82%E8%81%8C%E8%B7%AF%E4%B8%8A%E4%B8%80%E5%8E%BB%E4%B8%8D%E5%A4%8D%E8%BF%94/"/>
    
    
    <category term="面经" scheme="https://blog.musnow.top/tags/%E9%9D%A2%E7%BB%8F/"/>
    
  </entry>
  
</feed>
