<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>慕雪的寒舍</title>
  
  <subtitle>雪下了一夜</subtitle>
  <link href="https://blog.musnow.top/atom.xml" rel="self"/>
  
  <link href="https://blog.musnow.top/"/>
  <updated>2023-03-20T09:49:26.878Z</updated>
  <id>https://blog.musnow.top/</id>
  
  <author>
    <name>muxue</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>【win】windows初次开机和使用的注意事项</title>
    <link href="https://blog.musnow.top/2023/03/19/tools/win/19win%E5%88%9D%E6%AC%A1%E5%BC%80%E6%9C%BA%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9/"/>
    <id>https://blog.musnow.top/2023/03/19/tools/win/19win%E5%88%9D%E6%AC%A1%E5%BC%80%E6%9C%BA%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9/</id>
    <published>2023-03-19T14:50:31.000Z</published>
    <updated>2023-03-20T09:49:26.878Z</updated>
    
    <content type="html"><![CDATA[<p>首次开机和使用一台windows电脑需要注意的那些事</p><span id="more"></span><p>本文所言仅为本人个人观点，且只作为建议和图一乐的素材。电脑归根结底只是个工具，不同人使用习惯不同，按自己熟悉的来用即可。大可无需因为本文而改变你使用电脑的习惯。</p><h1 id="1-跳过联网"><a href="#1-跳过联网" class="headerlink" title="1.跳过联网"></a>1.跳过联网</h1><p>windows11的年代，这已是一个过去式了，还是记录一下吧。</p><p>给不知道的人说一下，大部分笔记本厂家的策略，都是windows激活之后，就不允许退款了。</p><p>在windows10的时代，首次开机的时候，在联网阶段，会有一个跳过联网的选项，我们只需要选择这个选项，就能跳过联网，继续我们的验机过程。这样，发现了电脑有各种各样的的问题或者不满意，还能以电脑没有激活为筹码，直接七天无理由退货。</p><p>可微软的阿三工程师不知道怎么想的，windows11一出来，直接把这个按钮干没了。</p><p>起初，还能通过快捷键or命令行的方式，强行跳过联网，但现在，似乎都不行了。</p><blockquote><p>可能还有跳过联网的方式，但相比win10的一个按钮，显然任何方法都麻烦多了，对小白也不够友好</p></blockquote><p>哎，谁知道微软是怎么想的呢？</p><h1 id="2-用户名"><a href="#2-用户名" class="headerlink" title="2.用户名"></a>2.用户名</h1><p>刚开始使用电脑的时候，电脑的用户名<strong>一定一定一定</strong>要设置成英文的！哪怕你设置成拼音或一串数字，都不要设置成非英文的其他语言！</p><h2 id="软件安装路径不要有中文"><a href="#软件安装路径不要有中文" class="headerlink" title="软件安装路径不要有中文"></a>软件安装路径不要有中文</h2><p>虽然现在，大部分软件对中文的支持都足够友好，但依旧有部分软件（以游戏据多）不支持中文路径的安装目录！</p><p>说人话就是，如果你想安装这些软件，它要求你的安装目录是全英文的</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">C:\Progarm Files\test\</span><br></pre></td></tr></table></figure><p>如果你的安装路径里面带有中文，可能安装不会报错，但是软件打不开、崩溃、报错误，一堆bug就来了</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">C:\Progarm Files\你好\</span><br></pre></td></tr></table></figure><p>为了避免这种bug，我们安装软件的时候，最好都要选择全英文的安装路径。</p><p>多一事不如少一事。你可以赌对很多个支持中文路径的软件，但只要来一个你需要的而不支持中文安装路径软件，就足够让你抓狂。如果你使用的是某些小众软件，恐怕报错贴到百度上都查不到为什么。</p><h2 id="那这又和用户名有啥关系呢？"><a href="#那这又和用户名有啥关系呢？" class="headerlink" title="那这又和用户名有啥关系呢？"></a>那这又和用户名有啥关系呢？</h2><p>windows在初始化的时候，会以你的用户名，在C盘如下路径创建一个文件夹</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">C:\Users\用户名</span><br></pre></td></tr></table></figure><p>注意啊，虽然你打开文件管理器，会发现这个文件夹叫做<code>用户</code>，但实际上他还是英文的，显示为<code>用户</code>是微软对界面做的汉化处理而已。</p><p><img                       lazyload                     alt="image"                     data-src="https://img1.musnow.top/i/2023/03/6417190ec898e.png"                      alt="image-20230319221542933"                ></p><p>右键这个路径，选择将地址复制成文本，你就会发现用户是汉化处理了</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">C:\Users\moth</span><br></pre></td></tr></table></figure><p>在用户文件夹下，除了会有一些软件的配置文件（如git、vscode、pip）还会有一个隐藏文件夹<code>AppData</code>，这里面存放了大部分软件的缓存文件，甚至有一些软件的安装路径就是在<code>AppData</code>里的！</p><p>如果你的用户名设置成了中文，那很不幸，上面提到的<code>软件安装路径不能有中文</code>的大忌，你将不可避免地遇到了！</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">C:\Users\慕雪</span><br></pre></td></tr></table></figure><p>因为软件会在你的用户目录下创建缓存文件夹，如果一个软件对中文的支持不好，那它就可能因此崩溃！</p><p>在我周边的同学里面，就出现过不少个windows用户名是中文的</p><ul><li>好消息是，目前为止，我们专业学习需要的软件都支持中文路径</li><li>坏消息是，这都大二下了，我们还没有学过一个专业课，还在学基础公共课……来大学快两年了，我还连自己的专业是干嘛的都不知道（事先为何不了解？问就是调剂来的！😒）所用的软件，也不过是编程ide罢了</li></ul><h1 id="3-保持一个良好的文件存放习惯"><a href="#3-保持一个良好的文件存放习惯" class="headerlink" title="3.保持一个良好的文件存放习惯"></a>3.保持一个良好的文件存放习惯</h1><p>可笑的是，这件事，知道的人不需要你告诉他；不在乎的人你告诉他也没用。</p><p>有太多太多的用户（包括我的父母）他们的电脑都中了一个病毒，导致整台电脑只有一个分区，叫做<code>桌面</code></p><p><img                       lazyload                     alt="image"                     data-src="https://img1.musnow.top/i/2023/03/64171ca375563.png"                      alt="image-20230319223059041"                ></p><p>并不是说文件丢桌面不可以，但是丢在桌面上有一个致命的问题：重装的时候，需要格式化C盘。</p><p>windows重装，是对付软件问题的最好方式。重装的时候，大概率是要格式C盘的，而桌面的文件就是存放在C盘上面的。</p><h1 id="未完待续"><a href="#未完待续" class="headerlink" title="未完待续"></a>未完待续</h1><p>想起来啥了就给本文加点料</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;首次开机和使用一台windows电脑需要注意的那些事&lt;/p&gt;</summary>
    
    
    
    <category term="电脑使用小贴士" scheme="https://blog.musnow.top/categories/%E7%94%B5%E8%84%91%E4%BD%BF%E7%94%A8%E5%B0%8F%E8%B4%B4%E5%A3%AB/"/>
    
    
    <category term="windows" scheme="https://blog.musnow.top/tags/windows/"/>
    
  </entry>
  
  <entry>
    <title>【win】windows磁盘管理分区,实现整数容量</title>
    <link href="https://blog.musnow.top/2023/03/19/tools/win/18win%E5%88%86%E7%9B%98%E5%B0%8Ftips/"/>
    <id>https://blog.musnow.top/2023/03/19/tools/win/18win%E5%88%86%E7%9B%98%E5%B0%8Ftips/</id>
    <published>2023-03-19T13:50:31.000Z</published>
    <updated>2023-03-19T14:06:31.000Z</updated>
    
    <content type="html"><![CDATA[<p>windows磁盘管理分盘分出整数容量</p><span id="more"></span><h1 id="1-问题"><a href="#1-问题" class="headerlink" title="1.问题"></a>1.问题</h1><p>不知道各位在使用windows电脑分区的时候，有没有遇到一个抓狂的问题：那就是windows的分区总是分不出整数！</p><p>不是<code>299.9gb</code>，就是<code>300.1gb</code></p><p>对于强迫症而言，看着那多出来的小数点，别提有多难受了！</p><p><img                       lazyload                     alt="image"                     data-src="https://img1.musnow.top/i/2023/03/64171303a3dfe.png"                      alt="image-20230319214854921"                ></p><h1 id="2-解决"><a href="#2-解决" class="headerlink" title="2.解决"></a>2.解决</h1><p>于是，我就百度了一下，到底要怎么设置分区的容量，才能让它分出一个整数gb的盘来？</p><p>最后，我查到了下面这个办法</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">想要整数GB的分区，只需要在原数字上+1就行了</span><br><span class="line">N*1024+1</span><br></pre></td></tr></table></figure><p>比如，我想要把c盘分出去70GB作为数据盘，那我应该在windows磁盘管理<strong>压缩卷</strong>里设置的数字如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">70*1024+1</span><br></pre></td></tr></table></figure><p>看，完美的70gb，强迫症有救了！</p><p><img                       lazyload                     alt="image"                     data-src="https://img1.musnow.top/i/2023/03/64171303c642e.png"                      alt="image-20230319214825662"                ></p><p><img                       lazyload                     alt="image"                     data-src="https://img1.musnow.top/i/2023/03/64171331ba1d7.png"                      alt="image-20230319215041939"                ></p><p>关注本寒舍，分享更多windows电脑使用的小tips！</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;windows磁盘管理分盘分出整数容量&lt;/p&gt;</summary>
    
    
    
    <category term="电脑使用小贴士" scheme="https://blog.musnow.top/categories/%E7%94%B5%E8%84%91%E4%BD%BF%E7%94%A8%E5%B0%8F%E8%B4%B4%E5%A3%AB/"/>
    
    
    <category term="windows" scheme="https://blog.musnow.top/tags/windows/"/>
    
  </entry>
  
  <entry>
    <title>【Linux】tcp协议 | 详解</title>
    <link href="https://blog.musnow.top/2023/03/17/Linux/37%E9%87%8D%E7%9C%8Btcp/"/>
    <id>https://blog.musnow.top/2023/03/17/Linux/37%E9%87%8D%E7%9C%8Btcp/</id>
    <published>2023-03-17T07:30:55.000Z</published>
    <updated>2023-03-19T05:51:09.891Z</updated>
    
    <content type="html"><![CDATA[<p>本文带你详细了解tcp协议的相关知识</p><span id="more"></span><blockquote><p>本文中部分截图为手写，字丑见谅</p></blockquote><h1 id="1-linux下常用网络命令"><a href="#1-linux下常用网络命令" class="headerlink" title="1.linux下常用网络命令"></a>1.linux下常用网络命令</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cat</span> /etc/servcies <span class="comment"># 系统常用服务和端口</span></span><br></pre></td></tr></table></figure><p>我们自己写网络服务器进程时，绑定的端口不能和系统端口冲突。尽量绑定1024以上的端口，推荐绑定不常用的5位数端口</p><h2 id="1-1-netstat命令"><a href="#1-1-netstat命令" class="headerlink" title="1.1 netstat命令"></a>1.1 netstat命令</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">netstat</span><br><span class="line">netstat -l <span class="comment"># 只列出listen状态服务</span></span><br><span class="line">netstat -n <span class="comment"># 将显示的信息用数字（id）代替</span></span><br><span class="line">netstat -p <span class="comment"># 显示端口和进程pid的关联</span></span><br><span class="line">netstat -t <span class="comment"># tcp</span></span><br><span class="line">netstat -u <span class="comment"># udp</span></span><br><span class="line">netstat -a <span class="comment"># 显示所有服务</span></span><br></pre></td></tr></table></figure><h2 id="1-2-pidof"><a href="#1-2-pidof" class="headerlink" title="1.2 pidof"></a>1.2 pidof</h2><p>获取某个进程名的进程pid</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pidof 进程名</span><br></pre></td></tr></table></figure><p>比如我想查看<code>sshd</code>的进程id</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ pidof sshd</span><br><span class="line">20706 20703 10775 6067 6009 3339 3338 3272 3269 1340</span><br></pre></td></tr></table></figure><h1 id="2-udp协议"><a href="#2-udp协议" class="headerlink" title="2.udp协议"></a>2.udp协议</h1><p>一下为udp报文格式的结构图</p><p><img                       lazyload                     alt="image"                     data-src="https://img1.musnow.top/i/2023/03/6414432a16b9f.png"                      alt="image-20230317183835725"                ></p><p>udp采用了定长报文，这也是udp <code>面向数据报</code> 的</p><ul><li>udp采用16位作为ip+端口的存放，源端口和目的端口用于数据的<strong>解包分用</strong>（系统需要知道当前的数据包应该丢给上层的哪一个端口）</li><li>16位udp长度，表示整个数据报 <code>udp首部+udp数据</code> 的最大长度</li><li>16位校验和用于校验报文是否出现错误。如果校验和出错，就会直接丢弃报文</li></ul><p>由于udp的长度标志位只有16位，所以一个udp报文能传输的最大数据是<code>64kb</code> ( 2<sup>2 </sup>)</p><p>如果需要用udp传输大于<code>64kb</code>的数据，则需要在<strong>应用层</strong>进行拆分，在接收方的<strong>应用层</strong>进行合并。</p><h2 id="2-1-理解报头"><a href="#2-1-理解报头" class="headerlink" title="2.1 理解报头"></a>2.1 理解报头</h2><p>所谓报头，其实就是操作系统内核中的一个C语言的结构体。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//示例，不代表真实情况</span></span><br><span class="line"><span class="comment">//udp报头采用了位段</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">udp_hdr</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> src_port:<span class="number">16</span>;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> dst_port:<span class="number">16</span>;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> udp_len:<span class="number">16</span>;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> udp_check:<span class="number">16</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>添加报头的本质，其实就是给数据的头部添加上一个<code>struct udp_hdr</code>结构体；</p><p>而解包的时候，也是将指针移动固定长度（8个字节）的空间，将指针强转为<code>struct udp_hdr</code>，即获取到了当前报文的udp报头</p><h2 id="2-2-udp的特点"><a href="#2-2-udp的特点" class="headerlink" title="2.2 udp的特点"></a>2.2 udp的特点</h2><p>udp传输的过程类似于<code>飞鸽传书</code></p><ul><li>无连接：知道对方的<code>ip:端口</code>就能直接传输数据，不需要建立连接</li><li>面向数据报：定长报文，不能灵活控制报文的读取次数和数量<ul><li>一次必须要读取完毕一个完整的udp报文</li><li>假设报文100字节，不能通过10次每次读10字节来获取报文。必须一次读完100字节</li></ul></li><li>不可靠：没有确认机制和重传机制，如果因为各种原因，鸽子在路上出事了，那传输的信息也直接丢失了。udp也不会给应用层返回错误信息。</li></ul><h2 id="2-3-udp缓冲区"><a href="#2-3-udp缓冲区" class="headerlink" title="2.3 udp缓冲区"></a>2.3 udp缓冲区</h2><p>udp支持<code>全双工</code>，udp的socket即可写也可读</p><p>udp没有发送缓冲区，应用层调用<code>sendto</code>会直接将数据交给OS内核（其实就是拷贝），内核再交由网络模组进行后续传输。</p><blockquote><p>由于udp采用了定长报头，其报头较为简单，OS只需要添加上报头即可发送。这个过程很快，所以缓冲区的作用不大。</p></blockquote><p>udp有接收缓冲区，这个接收缓冲区只是一味地接收，并不能保证报文的顺序</p><blockquote><p>因为不保证顺序，所以有可能<strong>乱序</strong>，也是<strong>udp不可靠</strong>的体现</p></blockquote><p>若缓冲区满，新到达的udp数据就会被丢弃。</p><h2 id="2-4-丢包"><a href="#2-4-丢包" class="headerlink" title="2.4 丢包"></a>2.4 丢包</h2><p>一个数据包丢包可能有多种情况</p><ul><li>数据包内容出错（比特位翻转等）</li><li>数据包延迟到达（延迟过久视为丢包）</li><li>数据包在路上被阻塞（到不了）</li><li>数据包在路上由于网络波动而丢失（网络突然抽风了，报文直接不见了）</li></ul><p>udp的报文也是如此，但udp<strong>不可靠</strong>并不是一个贬义词，应该是一个中性词。</p><ul><li>udp不可靠是他的特点，由于udp简单，其不需要进行连接，报头添加的效率快，由此性能消耗小于tcp。</li><li>带来的缺点就是udp不可靠</li></ul><p>在直播场景中，udp的使用很多。同一场直播观看的人数会很多，如果每一个用户都维持一个tcp连接，服务器的负载就太大了。用udp就能直接向该用户广播数据，负载小。</p><h2 id="2-5-基于udp的应用层协议"><a href="#2-5-基于udp的应用层协议" class="headerlink" title="2.5 基于udp的应用层协议"></a>2.5 基于udp的应用层协议</h2><ul><li>NFS: 网络文件系统</li><li>TFTP: 简单文件传输协议</li><li>DHCP: 动态主机配置协议</li><li>BOOTP: 启动协议（用于无盘设备启动）</li><li>DNS: 域名解析协议</li></ul><h1 id="3-tcp协议"><a href="#3-tcp协议" class="headerlink" title="3.tcp协议"></a>3.tcp协议</h1><p>下图为tcp协议报头的一个基本结构图，我们需要了解整个结构，以及每一个部分的作用</p><p><img                       lazyload                     alt="image"                     data-src="https://img1.musnow.top/i/2023/03/6414766c49315.png"                      alt="image-20230317221627931"                ></p><h2 id="3-1-源和目的端口号"><a href="#3-1-源和目的端口号" class="headerlink" title="3.1 源和目的端口号"></a>3.1 源和目的端口号</h2><p>这部分和udp相同，tcp也需要源端口和目的端口号，以用于找到报文要去的目的地。</p><h2 id="3-2-4位首部长度"><a href="#3-2-4位首部长度" class="headerlink" title="3.2 4位首部长度"></a>3.2 4位首部长度</h2><p>相比于udp的定长报头，tcp采用了不定长的方式。但tcp的报头有<strong>标准的20字节</strong>，所有报头都至少有20字节。</p><p>在这20字节中，有一个<code>4位首部长度</code>，用于标识tcp报文的<strong>真实长度</strong>。</p><p>我们知道，4位二进制可以表示<code>0~15</code>，这不比固定的20字节还少吗？难道说，这4位首部长度标识的是比20字节多余的内容？</p><p>并不是！这4位首部长度的标识是有单位的，每一位实际上代表的是4字节，即tcp报头的最大长度为<code>15*4=60</code>字节。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">由于标准长度也记入4位首部长度，所以4位首部长度的最小值为 0101</span><br></pre></td></tr></table></figure><p>读取tcp报文的时候，只需要先读取20字节，再从这20字节中<strong>取出</strong>4位首部长度，获得报头的实际长度；再重新读取，即获得了<strong>完整</strong>的tcp报头。剩下的部分就是报文携带的数据了（有效载荷）</p><h2 id="3-3-32位序号-x2F-确认序号"><a href="#3-3-32位序号-x2F-确认序号" class="headerlink" title="3.3 32位序号&#x2F;确认序号"></a>3.3 32位序号&#x2F;确认序号</h2><h3 id="3-3-1-如何确认信息被对方收到？"><a href="#3-3-1-如何确认信息被对方收到？" class="headerlink" title="3.3.1 如何确认信息被对方收到？"></a>3.3.1 如何确认信息被对方收到？</h3><blockquote><p>tcp具有确认应答的机制</p></blockquote><p>当我们和对方<strong>微信交流</strong>的时候，怎么样才能确认自己的信息被对方看到了？</p><ul><li>A发 吃饭了吗？</li><li>B回应 吃了</li></ul><p>在这个场景中，只有B给A发出回应，A才能确认自己的消息被B看到了。</p><p>tcp通信也是如此，只有给对方发送的报文收到了对方的<strong>应答</strong>，发送方才能确认自己的报文被对方收到了。</p><p>为此，tcp引入了<code>32位 序号/确认序号</code></p><hr><h3 id="3-3-2-确认应答"><a href="#3-3-2-确认应答" class="headerlink" title="3.3.2 确认应答"></a>3.3.2 确认应答</h3><p>用于确认自己和对方的通信，究竟收到了哪一个报文（序号）以及确认信息发出的顺序。</p><p>比如客户端会向服务器发 <code>吃了吗？吃的什么？好吃吗？晚上想去干什么？</code>，如果没有对报头带上序号，服务器接收到的可能就会是下面这样 <code>好吃吗？晚上想去干什么？吃的什么？吃了吗？</code>，看起来是不是十分怪异？</p><p>所以，为了保证tcp报文的顺序性，以及保证报文被送达到对方。tcp引入了以序号为基础的<code>确认应答</code>机制</p><ul><li>客户端向服务器发送一个报头，并将<strong>序号</strong>设置为1</li><li>服务端收到信息后，回复客户端一个报头，将<strong>确认序号</strong>设置为2（为客户端所发消息的序号<code>+1</code>） </li><li>此时客户端就能确认服务器收到了自己刚刚发出的序号为1的消息</li><li>下次发送消息，客户端会从2号开始发送</li></ul><p>以上是一次通信的过程，如果是多次通信呢？ </p><ul><li>客户端连续向服务器发送了n个消息，服务器应答：1、2、3、4……</li><li>服务器的每次应答会设置<strong>确认序号</strong>，代表n之前的报文被全部收到</li><li>比如假设客户端发送了<code>1-10</code>的报文，而第6个报文出现了丢失，那么服务端就应该设置<code>确认序号</code>为6，代表<strong>6之前</strong>的报文都被正常收到。</li><li>此时客户端发现，明明自己已经都发到10了，服务端还在回应6。这就代表发送过程中，<strong>6号报文丢失了</strong>！于是客户端从6号报文开始，<strong>重发报文</strong>：6、7、8……</li></ul><p>不管是服务端给客户端发信息，还是客户端给服务器发信息，收方都需要对信息进行回应。tcp通信中，<strong>通信双方地位是对等</strong>的！</p><h3 id="3-3-3-为什么有两组确认序号？"><a href="#3-3-3-为什么有两组确认序号？" class="headerlink" title="3.3.3 为什么有两组确认序号？"></a>3.3.3 为什么有两组确认序号？</h3><p>tcp是<strong>全双工</strong>的，通信一方在发送响应信息的同时，可能也会携带新的报文给对方。</p><ul><li>客户端给服务器发了一条消息 <code>吃了吗？</code></li><li>服务器在回复的同时，也带上了新的请求 <code>吃了，你呢？</code> </li><li>服务器的这种策略叫做：<strong>捎带应答</strong></li></ul><p>此时服务端就需要在填充<em>客户端</em>消息的<strong>确认序号</strong>的同时，填充<em>自己</em>所发消息的<strong>序号</strong>。这样才能保证tcp在双向交流中的可靠性！</p><p>所以在tcp报头中，<strong>序号和确认序号</strong>缺一不可！</p><h3 id="3-3-4-没有完美的协议！"><a href="#3-3-4-没有完美的协议！" class="headerlink" title="3.3.4 没有完美的协议！"></a>3.3.4 没有完美的协议！</h3><p>经过上面的过程，我们会发现，总有一条报文，<strong>在收到对方回应之前</strong>，是无法得知对方是否收到信息的。</p><p>这也说明：没有一定可靠的协议！</p><h3 id="3-3-5-按序到达"><a href="#3-3-5-按序到达" class="headerlink" title="3.3.5 按序到达"></a>3.3.5 按序到达</h3><p><img                       lazyload                     alt="image"                     data-src="https://img1.musnow.top/i/2023/03/641543370a163.png"                      alt="image-20230318125057097"                ></p><p>序号除了用于确认应答，还有多个功能</p><ul><li>保证数据的顺序收发问题</li></ul><p>比如一个http的报头，原本的格式应该是下面这样</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GET / HTTP/1.1</span><br></pre></td></tr></table></figure><p>结果由于传输的过程中乱序了，变成了下面这样</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HTTP/1.1 GET /</span><br></pre></td></tr></table></figure><p>这种情况，是不能被应用层所正常解析的！数据全都乱了，原本写好的代码也没用了。</p><p>所以，为了避免数据在传输中<code>乱序</code>，tcp的序号就有了新的功能——保证数据的按序到达。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1.客户端发送了1-5号报文</span><br><span class="line">2.服务端收到了1 3 4 2 5（乱序）</span><br><span class="line">3.服务端在tcp的接收缓冲区中，将报文重排序为1-5</span><br><span class="line">4.将重排序后的正确数据交付给应用层</span><br></pre></td></tr></table></figure><p>但是，如果<strong>只</strong>按顺序来接收数据，那就无法处理<code>优先级</code>问题。<span id="jump">这部分</span>将在后文<strong>6个标记位</strong>详解。</p><p>序号除了可以用于排序，还能用于<code>去重</code>，这部分也将在后文<strong>超时重传</strong>部分解析。</p><h2 id="3-4-16位窗口大小"><a href="#3-4-16位窗口大小" class="headerlink" title="3.4 16位窗口大小"></a>3.4 16位窗口大小</h2><h3 id="3-4-1-发送和接收缓冲区"><a href="#3-4-1-发送和接收缓冲区" class="headerlink" title="3.4.1 发送和接收缓冲区"></a>3.4.1 发送和接收缓冲区</h3><p>tcp同时拥有发送和接收缓冲区。</p><p><img                       lazyload                     alt="image"                     data-src="https://img1.musnow.top/i/2023/03/6415458533954.png"                      alt="image-20230318130053000"                ></p><p>我们在应用层调用的<code>read/write</code>函数，实际上只是将数据<code>从接收缓冲区中拷贝出来/发送的数据拷贝到发送缓冲区</code>。</p><blockquote><p>如果write包含将数据发送给对方的过程，那么这个函数的调用效率就太低了，影响应用层执行其他代码。</p></blockquote><p>数据并没有被立即送入网络传输，而是由tcp协议自主决定发送数据的长度和发送的时间！这一切，都是由<strong>操作系统</strong>来决定的。这就是为什么tcp又称为<code>传输控制协议</code>！</p><h3 id="3-4-2-接收缓冲区满了咋办"><a href="#3-4-2-接收缓冲区满了咋办" class="headerlink" title="3.4.2 接收缓冲区满了咋办"></a>3.4.2 接收缓冲区满了咋办</h3><p>既然有缓冲区，就肯定会存在缓冲区被写满的问题。</p><ul><li>发送缓冲区满，由操作系统告知应用层，不再往发送缓冲区中写入数据</li><li>接受缓冲区满<ul><li>直接丢弃数据？</li><li>告诉对方，不再给自己发信息？</li></ul></li></ul><p>在实际的tcp收发过程中，由于<strong>接收方缓冲区满</strong>而丢弃数据，是不可接受的。因为数据跨过了茫茫网络，都已经到你机器上了，结果因为你缓冲区满了给它丢掉了，这不是坑人吗？</p><p>虽然出现这种情况，我们可以让发送方重传报文，但这样效率太低！</p><p><img                       lazyload                     alt="image"                     data-src="https://img1.musnow.top/i/2023/02/202211031203959.jpg"                      alt="QQ图片20220424132543"                ></p><p>所以，我们应该让收发双方知晓对方的缓冲区大小，从而避免这个问题！</p><p>这就是tcp报头中<code>16位窗口大小</code>的作用了！</p><h3 id="3-4-3-告知对方收缓大小"><a href="#3-4-3-告知对方收缓大小" class="headerlink" title="3.4.3 告知对方收缓大小"></a>3.4.3 告知对方收缓大小</h3><p>如下图，在客户端和服务端<code>互通有无</code>的时候，假设服务端的<strong>接收缓冲区</strong>满了，应该告知客户端，让他别再给自己发消息了。</p><p>此时，服务端设置自己的<code>16位窗口大小</code>，以此告知客户端自己的缓冲区<strong>剩余</strong>容量。</p><p>如果对方发来的报文中，<code>16位窗口大小</code>所表示的缓冲区剩余容量已经不足了，发送方就不应该继续发送，而应该等待对方从缓冲区中取走数据。</p><p><img                       lazyload                     alt="image"                     data-src="https://img1.musnow.top/i/2023/03/64154988e2f2b.png"                      alt="image-20230318131802239"                ></p><p>这是已经开始通讯的情况，但如果是<strong>第一次</strong>通讯呢？如果客户端一来就发送了一个巨大的数据，直接塞满了服务端的缓冲区，那不是出事了？</p><p>这便是tcp在<strong>三次握手</strong>中要做的事情了，简单来说就是在通信开始前就互相告知自己缓冲区的大小。后文会讲解。</p><h3 id="3-4-4-缓冲区是否独立？"><a href="#3-4-4-缓冲区是否独立？" class="headerlink" title="3.4.4 缓冲区是否独立？"></a>3.4.4 缓冲区是否独立？</h3><ul><li>进程的tcp缓冲区是独立的吗？</li></ul><p>每个进程都有自己的内核空间，内核空间里有tcp缓冲区，所以每个进程都有自己独立的tcp缓冲区</p><ul><li>线程的tcp缓冲区是独立的吗？</li></ul><p>是的！虽然这些线程共享同一个内核TCP缓冲区，但是每个线程使用的缓冲区是独立的，互相之间不会产生冲突。每个线程对自己的缓冲区进行读写操作时，会使用内核提供的同步机制，如互斥锁、信号量等来确保线程之间的缓冲区不会互相干扰，从而实现数据的安全读写。</p><h2 id="3-5-六个标记位"><a href="#3-5-六个标记位" class="headerlink" title="3.5 六个标记位"></a>3.5 六个标记位</h2><p>在4位首部长度右侧，有一块保留长度，和6个标记位。这六个标记位是所有设备都支持的标记位。</p><p><img                       lazyload                     alt="image"                     data-src="https://img1.musnow.top/i/2023/03/64156cd9c9751.png"                      alt="image-20230318154843384"                ></p><ul><li>SYN: 连接标记位，用于建立连接（又称同步报文）</li><li>FIN: 表示请求关闭连接，又称为<code>结束报文</code></li><li>ACK：响应报文，代表本次报文中包含对之前报文的确认应答</li><li>PSH：要求对方立马从tcp缓冲区中取走数据</li><li>URG：紧急指针标记位，用于紧急数据的传输</li><li>RST：要求重置连接（双方重新建立一次新的tcp连接）</li></ul><h3 id="3-5-1-8个标记位？"><a href="#3-5-1-8个标记位？" class="headerlink" title="3.5.1 8个标记位？"></a>3.5.1 8个标记位？</h3><p>在部分书籍中，还会出现8个标记位与4位保留长度的说法（下图源自《图解tcp&#x2F;ip第五版》）</p><p><img                       lazyload                     alt="image"                     data-src="https://img1.musnow.top/i/2023/03/64156e7dd3169.png"                      alt="image-20230318155543377"                ></p><ul><li>CWR（Congestion Window Reduced）：该标志位用于通知对方自己已经将拥塞窗口缩小。在TCP SYN握手时，发送方会将CWR标志位设置为1，表示它支持ECN（Explicit Congestion Notification）拥塞控制，并且接收到的TCP包的IP头部的ECN被设置为11。如果发送方收到了一个设置了ECE（ECN Echo）标志位的TCP数据包，则它将调整自己的拥塞窗口，就像它从丢失的数据包中快速恢复一样。然后，发送方会在下一个数据包中设置CWR标志位，向接收方表明它已对拥塞做出反应。发送方在每个RTT（Round Trip Time）间隔最多做出一次这种反应。</li><li>ECE（ECN Echo）：该标志位用于通知对方从对方到这边的网络有拥塞。在收到数据包的IP首部中ECN为1时，TCP首部中的ECE会被设置为1。接收方会在所有数据包中设置ECE标志位，以便通知发送方网络发生了拥塞。</li></ul><p>而我百度到的文章提到，tcp给多出来的两个标记位新增了功能：</p><ul><li>除了以上6个标志位，还有一个实验性的标志位NS（Nonce Sum），用于防止TCP发送者的数据包标记被意外或恶意改动。NS标志位仍然是一个实验标志，用于帮助防止发送者的数据包标记被意外或恶意更改。<a class="link"   href="https://www.codetd.com/article/12421677" >[3]<i class="fas fa-external-link-alt"></i></a><a class="link"   href="https://blog.csdn.net/qq_38323666/article/details/85338477" >[4]<i class="fas fa-external-link-alt"></i></a></li><li>TCP标志位中还有两个标志位后来加的一个功能：显式拥塞通知（ECN）。ECN允许拥塞控制的端对端通知而避免丢包。但是，ECN在某些老旧的路由器和操作系统（例如：Windows XP）上不受支持。在TCP连接上使用ECN也是可选的；当ECN被使用时，它必须在连接创建时通过SYN和SYN-ACK段中包含适当选项来协商。 <a class="link"   href="https://www.likecs.com/show-203551574.html" >[2]<i class="fas fa-external-link-alt"></i></a><a class="link"   href="https://www.codetd.com/article/12421677" >[3]<i class="fas fa-external-link-alt"></i></a></li></ul><p>诸如<code>tcp的标记位到底是6个还是8个?</code>这种摸棱两可的问题，在考试中不会问道。</p><p>在学习中，我们只需要掌握所有设备都支持的<strong>6个标记位</strong>即可</p><p><img                       lazyload                     alt="image"                     data-src="https://img1.musnow.top/i/2023/02/202211031205743.png"                      alt="狗头"                ></p><h3 id="3-5-2-ACK"><a href="#3-5-2-ACK" class="headerlink" title="3.5.2 ACK"></a>3.5.2 ACK</h3><p>该标记位用于标识本条报文是对之前的报文的<code>确认应答</code></p><p>ACK标记位的设置和其他标记位并不冲突，在<code>捎带应答</code>的时候，可以同时设置多个标记位</p><h3 id="3-5-3-SYN-x2F-FIN"><a href="#3-5-3-SYN-x2F-FIN" class="headerlink" title="3.5.3 SYN&#x2F;FIN"></a>3.5.3 SYN&#x2F;FIN</h3><ul><li>SYN：表示请求建立连接，并在建立连接时用于同步序列号，所以又称为<code>同步报文</code>；</li><li>FIN：表示请求关闭连接，又称为<code>结束报文</code>。设置为1时，代表本方希望断开连接。此时双方要交换FIN（四次挥手）才能真正断开tcp连接。</li></ul><p><img                       lazyload                     alt="image"                     data-src="https://img1.musnow.top/i/2023/03/6415723928135.png"                      alt="image-20230318161138819"                ></p><h4 id="3-5-3-1-三次握手"><a href="#3-5-3-1-三次握手" class="headerlink" title="3.5.3.1 三次握手"></a>3.5.3.1 三次握手</h4><p>在三次握手的时候，经历了如下过程</p><ul><li>连接发方A向对方主机B发送SYN报文，请求建立连接（A进入<code>SYN-SENT</code>状态）</li><li>主机B在收到报文后，回应<code>ACK+SYN</code>的报文，在确认应答的同时，请求建立连接（B进入<code>SYN-RCVD</code>状态）</li><li>A收到这条报文后，发送确认应答ACK（A认为连接成功建立 <code>ESTABLISHED</code>）</li><li>B收到A发送的ACK，三次握手完成（B认为连接成功建立  <code>ESTABLISHED</code>）</li></ul><h4 id="3-5-3-2-四次挥手"><a href="#3-5-3-2-四次挥手" class="headerlink" title="3.5.3.2 四次挥手"></a>3.5.3.2 四次挥手</h4><p>在断开连接，四次挥手的时候，经历了如下过程</p><ul><li>A要断开连接，发送FIN（A进入<code>FIN WAIT 1</code>状态）</li><li>B收到了FIN，发送ACK（B进入<code>CLOSE-WAIT</code>半关闭状态）</li><li>A收到了ACK（A进入<code>FIN WAIT 2</code>状态)</li><li>此时只是A要和B单方面分手，<code>A-&gt;B</code>的路被切断了，但是<code>B-&gt;A</code>的还没有，B还能继续给A发数据</li><li>B发完数据了，也和A分手了，B发送FIN（B进入<code>LAST ACK</code>状态）</li><li>A收到FIN，发送回应ACK（A进入<code>TIME WAIT</code>状态，将在<strong>一段时间后</strong>进入<code>CLOSE</code>断连状态）</li><li>B收到了ACK（B进入<code>CLOSE</code>状态）</li><li>连接关闭</li></ul><p>我们不仅需要知道3次握手和4次挥手的过程，还需要知道每一次的状态变化！</p><blockquote><p>3次握手和4次挥手对于应用层而言，都只有1个对应的函数。这些操作都是由tcp自主完成的。</p></blockquote><h3 id="3-5-4-PSH"><a href="#3-5-4-PSH" class="headerlink" title="3.5.4 PSH"></a>3.5.4 PSH</h3><p>PSH标记位的作用是：要求对方立马取走缓冲区中数据</p><p>如下图，S在接收缓冲区满了之后过了很久，还没有取走缓冲区中的数据，C实在忍不住了，给S发一个<code>PSH</code>标记位的报文，要求S立马取走这些数据！</p><p><img                       lazyload                     alt="image"                     data-src="https://img1.musnow.top/i/2023/03/641578af00365.png"                      alt="image-20230318163912700"                ></p><p>tcp在收到此报文后，将由操作系统告知应用层，取走缓冲区中的数据。</p><p>如果应用层不听操作系统的咋办？<strong>那就代表应用层写的有bug</strong>！人家给你发了那么多东西了你还不处理，有点过分了！</p><h3 id="3-5-5-URG"><a href="#3-5-5-URG" class="headerlink" title="3.5.5 URG"></a>3.5.5 URG</h3><p>URG是<strong>紧急指针标记位</strong>。</p><p>在<a href="#jump">3.3.5 按序到达</a>部分提到过，如果只关注序号，则无法处理优先级问题。有一些数据对于应用层来说，优先级较高。如果tcp只会老老实实的按顺序把数据交付给应用层，那在高优先级的数据也搞不过操作系统对tcp的处理。</p><p>所以，为了能操作优先级，tcp提供了<code>URG</code>标记位，设置了此标记位的报文具有较高优先级。</p><p>应用层有专门的接口可以优先读取带有<code>URG</code>标记位的报文。</p><h4 id="3-5-5-1-16位紧急指针"><a href="#3-5-5-1-16位紧急指针" class="headerlink" title="3.5.5.1 16位紧急指针"></a>3.5.5.1 16位紧急指针</h4><p>为了能标识这个紧急数据在报文中的位置，tcp还提供了<code>16位紧急指针</code>；这个指针的指向便是<strong>紧急数据</strong>在tcp报文中的偏移量。<strong>紧急数据</strong>规定只有1个字节！</p><p>由于紧急指针的数据可以被提前读取，不受tcp缓冲区的约束，所以又被称为<code>带外数据</code></p><p>下图就举了一个紧急指针使用的场景：</p><p><img                       lazyload                     alt="image"                     data-src="https://img1.musnow.top/i/2023/03/64157b0e4aeba.png"                      alt="image-20230318164915979"                ></p><p>TCP 在传输数据时是有顺序的，它有<strong>字节号</strong>，URG配合紧急指针，就可以找到紧急数据的<strong>字节号</strong>。</p><p>紧急数据的字节号公式如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">紧急数据字节号(urgSeq)=TCP报文序号(seq)+紧急指针(urgpoint)−1</span><br></pre></td></tr></table></figure><p>比如图中的例子，如果 <code>seq = 10,urgpoint = 5</code>，那么字节序号 <code>urgSeq = 10 + 5 -1 = 14</code></p><p><img                       lazyload                     alt="image"                     data-src="https://img1.musnow.top/i/2023/03/641582bf3d3bc.png"                      alt="image-20230318172209050"                ></p><p>知道了字节号后，就可以计算紧急数据字位于<strong>所有传输数据中</strong>的第几个字节了。如果从第0个字节开始算起，那么紧急数据就是第<code>urgSeq - ISN - 1</code>个字节（ISN 表示初始序列号），减1表示不包括第一个SYN段，因为一个SYN段会消耗一个字节号。</p><h3 id="3-5-6-RST"><a href="#3-5-6-RST" class="headerlink" title="3.5.6 RST"></a>3.5.6 RST</h3><p>RST为复位报文，即<code>RESET</code>。</p><p>如下图，如果A给B发送的ACK在传输路途上丢失了，咋办？</p><p><img                       lazyload                     alt="image"                     data-src="https://img1.musnow.top/i/2023/03/6415911e126cc.png"                      alt="image-20230318182326946"                ></p><p>这时候，就会出现A认为连接已经建立，而B由于没收到A的ACK而处于<code>SYN-RCVD</code>状态。</p><ul><li>此时A开始给B发送数据，B一看，不是说好了要建立连接才能发送数据的吗，你这是在干嘛？</li><li>于是B告知A，发送RST标志位的报文，要求和A重新建立连接（重新进行三次握手）</li><li>重新建立连接成功后，AB再正常发送信息。</li></ul><p>以上只是RST使用的情况之一。我们使用浏览器访问一些网页时，<code>F5刷新</code>就可以理解为浏览器向服务器发送了一个带有RST标记位的报文。</p><h2 id="3-6-为什么是3次握手？"><a href="#3-6-为什么是3次握手？" class="headerlink" title="3.6 为什么是3次握手？"></a>3.6 为什么是3次握手？</h2><p>为什么握手的次数是3次，不是1次、2次、4次、5次？</p><p>在讨论这个问题之前，我们要知道：连接建立是有消耗的！需要维护其缓存区、连接描述符（linux下为文件描述符）等等数据。</p><ul><li>如果是一次握手？</li></ul><p>一次握手，即A给B发送一个SYN，双方就认为连接建立了。</p><p>那么我们直接拿个机器，写个死循环，一直给对方发送SYN，自己直接丢弃文件描述符（不做维护）</p><p>由于服务器并不知道你直接丢弃了文件描述符，其还是要为此次连接维护相关数据，这样会导致服务器的资源在短时间内被大量消耗，最后直接dead了</p><blockquote><p>这种攻击叫做<strong>SYN洪水</strong></p></blockquote><ul><li>如果是二次握手？</li></ul><p>A给B发送一个SYN，B给A发送一个ACK，即认为连接建立。</p><p>这和一次握手其实是相似的，服务器发送完毕ACK之后，就认为连接已经建立，需要维护相关资源。而我们依旧可以直接丢弃，不进行任何维护，最后还是服务器的资源被消耗完了</p><ul><li>三次握手</li></ul><p>双方都必须维护连接的相关资源，这样，哪怕你攻击我的服务器，你也得付出同等的资源消耗。最后就是比谁资源更多呗！</p><p>相比于前两种情况，三次握手能在<strong>验证全双工</strong>的同时，一定程度上避免攻击。</p><p>三次握手还将最后一次ACK丢失的成本嫁接给了客户端（连接发起方）如果最后一次ACK丢失，要由客户端重新发起和服务器的连接。</p><p>注意，三次握手只是<strong>一定程度</strong>上避免攻击。我们依旧可以用很多宿主机“堆料”来和服务器硬碰硬，这是无可避免的情况。</p><ul><li>更多次握手？</li></ul><p>由于三次握手已经满足了我们的要求，更多次握手依旧有被攻击的可能，还降低了效率，完全没必要！</p><p><img                       lazyload                     alt="image"                     data-src="https://img1.musnow.top/i/2023/03/64158f71c8c50.png"                      alt="image-20230318181619570"                ></p><h2 id="3-7-超时重传"><a href="#3-7-超时重传" class="headerlink" title="3.7 超时重传"></a>3.7 超时重传</h2><p>为了保证可靠性，如果一个报文长时间未收到对方的ACK回应，则需要进行<code>超时重传</code>。</p><p>linux下每一次尝试的时间间隔为500ms，若500ms内尚未收到对方的ACK，则重发报文，再等待1000ms……以此类推。</p><p><img                       lazyload                     alt="image"                     data-src="https://img1.musnow.top/i/2023/03/6415924e3984a.png"                      alt="image-20230318182832179"                ></p><p>超时重传还可能遇到下面的情况：</p><ul><li>服务器收到了消息，也发送了ACK，但是ACK在路上丢失了</li><li>客户端没有收到ACK，于是进行超时重传</li><li>服务器再次收到了消息，此时接收缓冲区里出现了两个一样的数据</li></ul><p>但是，我们的报文是有序号的，tcp就可以<strong>直接根据序号去重</strong>，所以，tcp交给应用层的数据是<code>去重+排序</code>之后的数据！</p><hr><p>如果同一个报文超时重传了好几次，还没有收到对方的应答，就会认为对方的服务挂掉了，此时本端会强制断连。</p><p>此时客户端就可以发送一个带有RST标记位的报文，要求和对方重新建立连接。</p><h2 id="3-8-出现了很多CLOSE-WAIT状态的连接？"><a href="#3-8-出现了很多CLOSE-WAIT状态的连接？" class="headerlink" title="3.8 出现了很多CLOSE-WAIT状态的连接？"></a>3.8 出现了很多CLOSE-WAIT状态的连接？</h2><p>在上面提到过，当客户端向服务器发送FIN之后，服务器回复ACK，会进入<code>CLOSE-WAIT</code>状态。此时服务器还能给客户端发送消息，双方都还在维护连接的相关资源。</p><p>如果一个服务出现了很多个处于<code>CLOSE-WAIT</code>状态的连接，就必须要检查一下，应用层的代码里面是不是没有调用<code>close(fd)</code>函数来关闭对应的文件描述符。</p><ul><li>一方的<code>close(fd)</code>就对应了两次挥手</li></ul><p>对方明明都要和你分手了，你还挂着对方当备胎，还要找对方要钱，也太不像话了😂</p><h1 id="4-验证状态"><a href="#4-验证状态" class="headerlink" title="4.验证状态"></a>4.验证状态</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ cat /proc/sys/net/ipv4/tcp_fin_timeout</span><br><span class="line">60</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;本文带你详细了解tcp协议的相关知识&lt;/p&gt;</summary>
    
    
    
    <category term="玩上Linux" scheme="https://blog.musnow.top/categories/%E7%8E%A9%E4%B8%8ALinux/"/>
    
    
    <category term="Linux" scheme="https://blog.musnow.top/tags/Linux/"/>
    
    <category term="tcp" scheme="https://blog.musnow.top/tags/tcp/"/>
    
  </entry>
  
  <entry>
    <title>【Git】解决git status中文乱码问题</title>
    <link href="https://blog.musnow.top/2023/03/16/tools/git/18git%20status%E4%B8%AD%E6%96%87%E4%B9%B1%E7%A0%81/"/>
    <id>https://blog.musnow.top/2023/03/16/tools/git/18git%20status%E4%B8%AD%E6%96%87%E4%B9%B1%E7%A0%81/</id>
    <published>2023-03-16T04:35:28.000Z</published>
    <updated>2023-03-17T05:41:51.000Z</updated>
    
    <content type="html"><![CDATA[<p>解决git status中文乱码问题</p><span id="more"></span><h2 id="起因"><a href="#起因" class="headerlink" title="起因"></a>起因</h2><p>在项目下输入git status之后，出现如下情况：</p><p><img                       lazyload                     alt="image"                     data-src="https://img1.musnow.top/i/2023/03/6413fd7f3709b.png"                                     ></p><p>在线搜索了一下，发现是git添加了如下特性：</p><p><img                       lazyload                     alt="image"                     data-src="https://img1.musnow.top/i/2023/03/6413fd83b9a65.png"                                     ></p><p>git参考文档：<a class="link"   href="https://git-scm.com/docs/git-config" >https://git-scm.com/docs/git-config<i class="fas fa-external-link-alt"></i></a></p><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>根据上面的文档得知，git对超过0x80的字符都会以八进制输出，由于中文以UTF-8保存，所以上面的文件路径输出了一堆的八进制<a class="link"   href="https://so.csdn.net/so/search?q=%E8%BD%AC%E4%B9%89&spm=1001.2101.3001.7020" >转义<i class="fas fa-external-link-alt"></i></a>代码，这对用户极其不友好。</p><p>文档给出的方案是-z，通过-z选项的确可以输出正确的中文，但是却缺少了详细信息：</p><p><img                       lazyload                     alt="image"                     data-src="https://img1.musnow.top/i/2023/03/6413fd87a51b8.png"                                     ></p><p>所有的输出全在一行，对用户也不好友。</p><p>查阅git status命令文档可知：</p><p><img                       lazyload                     alt="image"                     data-src="https://img1.musnow.top/i/2023/03/6413fd8b68d4a.png"                                     ></p><p>该选项会以NUL为一行的几位，但是终端不能识别NUL结尾，所以终端不会<a class="link"   href="https://so.csdn.net/so/search?q=%E8%87%AA%E5%8A%A8%E6%8D%A2%E8%A1%8C&spm=1001.2101.3001.7020" >自动换行<i class="fas fa-external-link-alt"></i></a>。</p><h2 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h2><p>那么最终的解决办法：关闭这个特性。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git config --global core.quotePath false</span><br></pre></td></tr></table></figure><p><img                       lazyload                     alt="image"                     data-src="https://img1.musnow.top/i/2023/03/6413fd8f4efc9.png"                                     ></p><p>再次执行git status：</p><p><img                       lazyload                     alt="image"                     data-src="https://img1.musnow.top/i/2023/03/6413fd92c83e6.png"                                     ></p><p>一切回归正常。</p><p>然后git add python添加所有修改过的文件：</p><p><img                       lazyload                     alt="image"                     data-src="https://img1.musnow.top/i/2023/03/6413fd96574d1.png"                                     ></p><h2 id="更多"><a href="#更多" class="headerlink" title="更多"></a>更多</h2><p>默认情况下，git会将入库的文件的行尾符替换为LF，这是因为git原生的工作环境是linux&#x2F;unix，而我目前工作环境是windows，所以这个也挺正常的。当下次在windows下检出分支的时候，会自动将LF替换为<a class="link"   href="https://so.csdn.net/so/search?q=CRLF&spm=1001.2101.3001.7020" >CRLF<i class="fas fa-external-link-alt"></i></a>。</p><p>这个警告并不会带来什么问题，完全可以忽略。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">版权声明：本文为CSDN博主「lengye7」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。</span><br><span class="line">原文链接：https://blog.csdn.net/lengye7/article/details/129208899</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;解决git status中文乱码问题&lt;/p&gt;</summary>
    
    
    
    <category term="差生文具多" scheme="https://blog.musnow.top/categories/%E5%B7%AE%E7%94%9F%E6%96%87%E5%85%B7%E5%A4%9A/"/>
    
    
    <category term="git" scheme="https://blog.musnow.top/tags/git/"/>
    
  </entry>
  
  <entry>
    <title>【C++】将浮点数每一位拆分并输出</title>
    <link href="https://blog.musnow.top/2023/03/13/oj/%E5%B0%86%E6%B5%AE%E7%82%B9%E6%95%B0%E6%AF%8F%E4%B8%80%E4%BD%8D%E6%8B%86%E5%88%86%E8%BE%93%E5%87%BA/"/>
    <id>https://blog.musnow.top/2023/03/13/oj/%E5%B0%86%E6%B5%AE%E7%82%B9%E6%95%B0%E6%AF%8F%E4%B8%80%E4%BD%8D%E6%8B%86%E5%88%86%E8%BE%93%E5%87%BA/</id>
    <published>2023-03-13T11:14:28.000Z</published>
    <updated>2023-03-13T11:55:41.606Z</updated>
    
    <content type="html"><![CDATA[<p>将浮点数每一位拆分并输出</p><span id="more"></span><h1 id="1-问题"><a href="#1-问题" class="headerlink" title="1.问题"></a>1.问题</h1><blockquote><p>来源 <a class="link"   href="https://ask.csdn.net/questions/7901417" >https://ask.csdn.net/questions/7901417<i class="fas fa-external-link-alt"></i></a></p></blockquote><p>题目要求如下，将浮点数拆分，不允许使用将浮点数整数倍扩大的办法（那样太简单了）</p><p><img                       lazyload                     alt="image"                     data-src="https://img1.musnow.top/i/2023/03/640f0dcc662f1.png"                      alt="auto-orient1"                ></p><h1 id="2-办法"><a href="#2-办法" class="headerlink" title="2.办法"></a>2.办法</h1><h2 id="2-1-库函数modf"><a href="#2-1-库函数modf" class="headerlink" title="2.1 库函数modf"></a>2.1 库函数modf</h2><p>C语言有一个库函数modf，可以将浮点数的整数部分和小数部分拆分开来、</p><blockquote><p><a class="link"   href="https://www.runoob.com/cprogramming/c-function-modf.html" >https://www.runoob.com/cprogramming/c-function-modf.html<i class="fas fa-external-link-alt"></i></a></p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">double</span> <span class="title function_">modf</span><span class="params">(<span class="type">double</span> x, <span class="type">double</span> *integer)</span></span><br></pre></td></tr></table></figure><p>其中参数x是原有浮点数，参数<code>integer</code>是输出型参数，会存放x的整数部分。</p><p>函数的返回值是x的小数部分</p><h2 id="2-2-代码"><a href="#2-2-代码" class="headerlink" title="2.2 代码"></a>2.2 代码</h2><p>第一版本代码如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">double</span> num;</span><br><span class="line">    cin &gt;&gt; num;</span><br><span class="line"></span><br><span class="line">    <span class="type">double</span> int_part;</span><br><span class="line">    <span class="type">double</span> frac_part = <span class="built_in">modf</span>(num, &amp;int_part);</span><br><span class="line"></span><br><span class="line">    string int_str = <span class="built_in">to_string</span>((<span class="type">int</span>)int_part);<span class="comment">//获取到整数部分并打印</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">char</span> c : int_str) &#123;</span><br><span class="line">        cout &lt;&lt; c &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;. &quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> n = <span class="number">2</span>;<span class="comment">//小数点后n位</span></span><br><span class="line">    <span class="keyword">while</span> (i &lt; n) &#123;</span><br><span class="line">        frac_part *= <span class="number">10</span>;</span><br><span class="line">        <span class="type">double</span> int_part;</span><br><span class="line">        frac_part = <span class="built_in">modf</span>(frac_part, &amp;int_part);</span><br><span class="line">        cout &lt;&lt; (<span class="type">int</span>)int_part &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样已经做到了将整数和小数部分给分离打印了</p><h2 id="2-3-精度缺失问题"><a href="#2-3-精度缺失问题" class="headerlink" title="2.3 精度缺失问题"></a>2.3 精度缺失问题</h2><p>但是，测试可以看到，小数的最后一位出现了可能会存在的精度缺失</p><p><img                       lazyload                     alt="image"                     data-src="https://img1.musnow.top/i/2023/03/640f0e7945693.png"                      alt="img"                ></p><h1 id="3-解决"><a href="#3-解决" class="headerlink" title="3.解决"></a>3.解决</h1><p>所以还需要用另外一个办法来处理</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">//https://ask.csdn.net/questions/7901417</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">double</span> num;</span><br><span class="line">    cin &gt;&gt; num;</span><br><span class="line"></span><br><span class="line">    <span class="type">double</span> int_part;</span><br><span class="line">    <span class="type">double</span> frac_part = <span class="built_in">modf</span>(num, &amp;int_part);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;int_part: &quot;</span>&lt;&lt; int_part &lt;&lt;<span class="string">&quot; | frac_part: &quot;</span> &lt;&lt;frac_part &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="type">char</span> str[<span class="number">10</span>];</span><br><span class="line">    <span class="built_in">sprintf</span>(str, <span class="string">&quot;%.3f&quot;</span>, frac_part); <span class="comment">//将小数部分打印到字符串中</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;str:  &quot;</span> &lt;&lt; str &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打印整数部分</span></span><br><span class="line">    string int_str = <span class="built_in">to_string</span>((<span class="type">int</span>)int_part);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">char</span> c : int_str) &#123;</span><br><span class="line">        cout &lt;&lt; c &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;. &quot;</span>;</span><br><span class="line">    <span class="comment">// 打印小数部分</span></span><br><span class="line">    <span class="type">int</span> n = <span class="number">2</span>;<span class="comment">//小数点后n位</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 因为打印到字符串中的数据包含了最开始的0.</span></span><br><span class="line">        <span class="comment">// 前两个字符就是0. 应该从第三个字符开始打印</span></span><br><span class="line">        cout &lt;&lt; str[<span class="number">2</span>+i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，问题已解决，符合题目要求！</p><p><img                       lazyload                     alt="image"                     data-src="https://img1.musnow.top/i/2023/03/640f0e4ca915c.png"                      alt="img"                ></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;将浮点数每一位拆分并输出&lt;/p&gt;</summary>
    
    
    
    <category term="把题目都给刷干净" scheme="https://blog.musnow.top/categories/%E6%8A%8A%E9%A2%98%E7%9B%AE%E9%83%BD%E7%BB%99%E5%88%B7%E5%B9%B2%E5%87%80/"/>
    
    
    <category term="C++" scheme="https://blog.musnow.top/tags/C/"/>
    
    <category term="OJ刷题" scheme="https://blog.musnow.top/tags/OJ%E5%88%B7%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>【图】拓扑排序</title>
    <link href="https://blog.musnow.top/2023/03/12/data_structure/14%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F/"/>
    <id>https://blog.musnow.top/2023/03/12/data_structure/14%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F/</id>
    <published>2023-03-12T01:00:49.000Z</published>
    <updated>2023-03-12T01:13:27.604Z</updated>
    
    <content type="html"><![CDATA[<p>本文搬运自csdn</p><span id="more"></span><h3 id="文章目录"><a href="#文章目录" class="headerlink" title="文章目录"></a>文章目录</h3><ul><li><a href="#%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F">拓扑排序</a><ul><li><a href="#%E4%BB%80%E4%B9%88%E6%98%AF%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F">什么是拓扑排序？</a></li><li><a href="#%E6%80%8E%E4%B9%88%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F">怎么拓扑排序？</a></li><li><a href="#%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F%E5%AE%9E%E7%8E%B0">拓扑排序实现</a></li></ul></li><li><a href="#%E5%85%B3%E9%94%AE%E8%B7%AF%E5%BE%84">关键路径</a><ul><li><a href="#%E4%BB%80%E4%B9%88%E6%98%AF%E5%85%B3%E9%94%AE%E8%B7%AF%E5%BE%84">什么是关键路径？</a></li><li><a href="#%E6%80%8E%E4%B9%88%E6%B1%82%E5%85%B3%E9%94%AE%E8%B7%AF%E5%BE%84">怎么求关键路径？</a></li><li><a href="#%E5%85%B3%E9%94%AE%E8%B7%AF%E5%BE%84%E5%AE%9E%E7%8E%B0">关键路径实现</a></li><li><a href="#%E6%B1%82%E5%85%B3%E9%94%AE%E8%B7%AF%E5%BE%84%E8%BF%87%E7%A8%8B%E7%A4%BA%E4%BE%8B">求关键路径过程示例</a></li></ul></li></ul><h1 id="拓扑排序"><a href="#拓扑排序" class="headerlink" title="拓扑排序"></a><a class="link"   href="https://so.csdn.net/so/search?q=%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F&spm=1001.2101.3001.7020" >拓扑排序<i class="fas fa-external-link-alt"></i></a></h1><h2 id="什么是拓扑排序？"><a href="#什么是拓扑排序？" class="headerlink" title="什么是拓扑排序？"></a>什么是拓扑排序？</h2><p>  在图论中，<strong>拓扑排序</strong>是一个<strong>有向无环图</strong>的所有顶点的线性序列(获得拓扑有序序列)。且该序列必须满足下面两个条件：</p><ol><li>每个顶点出现且只出现一次。</li><li>若存在一条从顶点 A 到顶点 B 的路径，那么在序列中顶点 A 出现在顶点 B 的前面。</li></ol><p>有向无环图（DAG）才有拓扑排序，非DAG图没有拓扑排序一说。</p><p><img                       lazyload                     alt="image"                     data-src="https://img1.musnow.top/i/2023/03/640d23c77df53.png"                                     >  </p><h2 id="怎么拓扑排序？"><a href="#怎么拓扑排序？" class="headerlink" title="怎么拓扑排序？"></a>怎么拓扑排序？</h2><p><strong>拓扑排序步骤：</strong></p><ol><li>在有向图中选一个没有前驱的顶点且输出之。</li><li>从图中删除该顶点和所有以它为尾的弧。</li></ol><p>  重复上述两步，直至全部顶点均已输出，或者当前图中不存在无前驱的顶点为止。后一种情况则说明有向图中存在环。</p><p><img                       lazyload                     alt="image"                     data-src="https://img1.musnow.top/i/2023/03/eb618be1ff4873833c8469dae9093d1e.png"                                     ><br>  图中，V1 和 V6 没有前驱，则可任选一个。假设先输出 V6，在删除 V6 及弧 &lt;V6, V4&gt;,&lt;V6, V5&gt; 之后，只有顶点 V1 没有前驱，输出 V1 且删去 V1 及弧 &lt;V1, V2&gt;,&lt;V1, V3&gt; 和 &lt;V1, V4&gt;，之后 V3 和 V4 都没有前驱。依此类推，可从中任选一个继续进行。整个拓扑排序的过程如上图。</p><h2 id="拓扑排序实现"><a href="#拓扑排序实现" class="headerlink" title="拓扑排序实现"></a>拓扑排序实现</h2><p>  我们采用<strong>邻接表</strong>作有向图的存储结构，且在头结点中增加一个存放顶点入度的数组。入度为零的顶点即为没有前驱的顶点，删除顶点以及它为尾的弧的操作，则可换以弧头顶点的入度减 1 来实现。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">Status <span class="title function_">TopologicalSort</span><span class="params">(ALGraph G)</span>&#123;</span><br><span class="line"><span class="comment">//有向图G采用邻接表存储结构 </span></span><br><span class="line"><span class="comment">//若G无回路，则输出G的顶点的一个拓扑序列并返回OK，否则ERROR </span></span><br><span class="line">FindInDegree(G, indegree);<span class="comment">//对各顶点求入度indegree[0..vernum-1] </span></span><br><span class="line">InitStack(S);</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;G.vexnum;i++)<span class="comment">//建零入度顶点栈S </span></span><br><span class="line"><span class="keyword">if</span>(!indegree[i])<span class="comment">//入度为0者进栈 </span></span><br><span class="line">Push(S, i);</span><br><span class="line">count = <span class="number">0</span>;<span class="comment">//对输出顶点计数 </span></span><br><span class="line"><span class="keyword">while</span>(!StackEmpty(S))&#123;</span><br><span class="line">Pop(S, i);printf(i, G.vertices[i].data);count++;<span class="comment">//输出i号顶点并计数 </span></span><br><span class="line"><span class="keyword">for</span>(p=G.vertices[i].firstarc; p; p=p-&gt;nextarc)&#123;</span><br><span class="line">k = p-&gt;adjvex;<span class="comment">//对i号顶点的每个邻接点的入度减1 </span></span><br><span class="line"><span class="keyword">if</span>(!(--indegree[k]))<span class="comment">//若入度减为0，则入栈 </span></span><br><span class="line">Push(S, k);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(count&lt;G.vexnum)<span class="comment">//该有向图有回路 </span></span><br><span class="line"><span class="keyword">return</span> ERROR;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  对有 n 个顶点和 e 条弧的有向图而言，建立求各顶点的入度的时间复杂度 O(e)；建零入度顶点栈的时间复杂度为 O(n)；在拓扑排序过程中，若有向图无环，则每个顶点进一次栈，出一次栈，入度减 1 的操作在 WHILE 语句中总共执行 e 次，所以，总的**时间复杂度为 O(n+e)**。<br>  当有向图中无环时，也可利用深度优先遍历进行拓扑排序，因为图中无环，则由图中某点出发进行深度优先搜索遍历时，最先退出 DFS 函数的顶点即出度为零的顶点，是拓扑有序序列中最后一个顶点。由此，按退出 DFS 函数的先后记录下来的顶点序列(如同求强连通分量时 finished 数组中的顶点序列)即为逆向的拓扑有序序列。  </p><h1 id="关键路径"><a href="#关键路径" class="headerlink" title="关键路径"></a>关键路径</h1><h2 id="什么是关键路径？"><a href="#什么是关键路径？" class="headerlink" title="什么是关键路径？"></a>什么是关键路径？</h2><p><strong>AOE网：</strong> 在一个表示工程的带权有向图中，用顶点表示事件（如V1），用有向边表示活动（如&lt;V1,V2&gt; &#x3D; a1），边上的权值表示活动的持续时间，称这样的有向图为边表示的活动的网。<br><strong>源点：</strong> 在AOE网中，没有入边的顶点称为源点；如顶点V1。<br><strong>终点：</strong> 在AOE网中，没有出边的顶点称为终点；如顶点V9。<br><strong>AOE网的性质：</strong></p><ol><li>只有在进入某顶点的活动都已经结束，该顶点所代表的事件才发生；例如，V5 事件发生需要 a4 和 a5 两个活动都结束。</li><li>只有在某顶点所代表的事件发生后，从该顶点出发的各活动才开始；例如，V5 事件结束，活动 a7 和 a8 活动才能开始。<br><img                       lazyload                     alt="image"                     data-src="https://img1.musnow.top/i/2023/03/d52c8bebe169544eea3f93136b617d61.jpeg"                                     ></li></ol><p>  在AOE网中，所有活动都完成才能到达终点，因此完成整个工程所必须花费的时间（即最短工期）应该为源点到终点的最大路径长度。具有最大路径长度的路径称为<strong>关键路径</strong>。关键路径上的活动称为<strong>关键活动</strong>。<br>  假设开始点是 V1，从 V1 到 Vi 的最长路径长度叫做事件 Vi 的<strong>最早发生事件</strong>。这个时间决定了所有以 Vi 为尾的弧所表示的活动的<strong>最早开始时间</strong>。我们用 e(i) 表示活动 ai 的最早开始时间。还可以定义一个活动的<strong>最迟开始时间</strong> l(i)，这是在不推迟整个过程完成的前提下，活动 ai 最迟必须开始进行的时间。两者之差 l(i)-e(i) 意味着完成活动 ai 的时间余量。我们把 l(i)&#x3D;e(i) 的活动叫做关键活动。</p><p><strong>向关键路径要时间，向非关键路径要资源。</strong></p><ol><li><strong>从前往后，计算工期与每项活动的最早开始时间；</strong></li><li><strong>从后往前，倒推每项活动最晚开始时间。</strong></li><li><strong>关键路径：最早开始时间&#x3D;最晚开始时间</strong></li></ol><h2 id="怎么求关键路径？"><a href="#怎么求关键路径？" class="headerlink" title="怎么求关键路径？"></a>怎么求关键路径？</h2><p>ve(j)：最早发生时间<br>vl(j)：最迟发生时间</p><ol><li>输入 e 条弧&lt;j, k&gt;，建立 AOE-网的存储结构；</li><li>从源点 v0 出发，令 <code>ve[0]=0</code>，按拓扑有序求其余各顶点的最早发现时间 <code>ve[i] (1≤i≤n-1)</code>。如果得到的拓扑有序序列中顶点个数小于网中顶点数 n，则说明网中存在环，不能求关键路径，算法终止；否则执行步骤(3)。</li><li>从汇点 vn 出发，令 <code>vl[n-1]=ve[n-1]</code>，按逆拓扑有序求其余各顶点的最迟发生时间<code> vl[i] (n-2≥i≥2)</code>；</li><li>根据各顶点的 ve 和 vl 值，求每条弧 s 的最早开始时间 e(s) 和最迟开始时间 l(s)。若某条弧满足条件 e(s)&#x3D;l(s)，则为关键活动。</li></ol><p>  根据上述算法，计算各顶点的 ve 值是在拓扑排序的过程中进行的，需对拓扑排序的算法作如下修改：</p><ol><li>在拓扑排序之前设初值，令 <code>ve[i]=0 (0≤i≤n-1)</code>；</li><li>在算法中增加一个计算 vj 的直接后继 vk 的最早发生时间的操作：若 <code>ve[j]+dut(&lt;j, k&gt;) &gt; ve[k]</code>，则 <code>ve[k]=ve[j]+dut(&lt;j, k&gt;)</code>；</li><li>为了能按逆拓扑有序序列的顺序计算各顶点的 vl 值，需记下在拓扑排序的过程中求得的拓扑有序序列，这需要在拓扑排序算法中，增设一个栈以记录拓扑有序序列，则在计算求得各顶点的 ve 值之后，从栈顶至栈底便为逆拓扑有序序列。</li></ol><h2 id="关键路径实现"><a href="#关键路径实现" class="headerlink" title="关键路径实现"></a>关键路径实现</h2><p><strong>改写的拓扑排序代码：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">Status <span class="title function_">TopologicalOrder</span><span class="params">(ALGraph G, Stack &amp;T)</span>&#123;</span><br><span class="line"><span class="comment">//有向图G采用邻接表存储结构，求各顶点事件的最早发生时间 ve(全局变量) </span></span><br><span class="line"><span class="comment">//T为拓扑序列顶点栈，S为零入度顶点栈 </span></span><br><span class="line"><span class="comment">//若G无回路，则用栈T返回G的一个拓扑序列，且函数值为OK，否则ERROR </span></span><br><span class="line">FindInDegree(G, indegree);<span class="comment">//对各顶点求入度indegree[0..vernum-1] </span></span><br><span class="line">InitStack(S);<span class="comment">//建零入度顶点栈S </span></span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;G.vexnum;i++)<span class="comment">//建零入度顶点栈S </span></span><br><span class="line"><span class="keyword">if</span>(!indegree[i])<span class="comment">//入度为0者进栈 </span></span><br><span class="line">Push(S, i);</span><br><span class="line">InitStack(T);count = <span class="number">0</span>;ve[<span class="number">0.</span>.G.vexnum-<span class="number">1</span>] = <span class="number">0</span>;<span class="comment">//初始化 </span></span><br><span class="line"><span class="keyword">while</span>(!StackEmpty(S))&#123;</span><br><span class="line">Pop(S, j);Push(T, j);count++;<span class="comment">//j号顶点入T栈并计数 </span></span><br><span class="line"><span class="keyword">for</span>(p=G.vertices[j].firstarc; p; p=p-&gt;nextarc)&#123;</span><br><span class="line">k = p-&gt;adjvex;<span class="comment">//对j号顶点的每个邻接点的入度减1 </span></span><br><span class="line"><span class="keyword">if</span>(--indegree[k] == <span class="number">0</span>)<span class="comment">//若入度减为0，则入栈 </span></span><br><span class="line">Push(S, k);</span><br><span class="line"><span class="keyword">if</span>(ve[j]+ *(p-&gt;info)&gt;ve[k])</span><br><span class="line">ve[k] = ve[j] + *(p-&gt;info);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(count &lt; G.vexnum)<span class="comment">//该有向图有回路 </span></span><br><span class="line"><span class="keyword">return</span> ERROR;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="keyword">return</span> OK;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p><strong>关键路径算法：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">Status <span class="title function_">CriticalPath</span><span class="params">(ALGraph G)</span>&#123;</span><br><span class="line"><span class="comment">//G为有向图，输出G的各项关键活动 </span></span><br><span class="line"><span class="keyword">if</span>(!TopologicalOrder(G, T))</span><br><span class="line"><span class="keyword">return</span> ERROR;</span><br><span class="line">vl[<span class="number">0.</span>.G.vexnum-<span class="number">1</span>] = ve[G.vexnum-<span class="number">1</span>];<span class="comment">//初始化顶点事件的最迟发生事件 </span></span><br><span class="line"><span class="keyword">while</span>(!StackEmpty(T))&#123;<span class="comment">//按拓扑逆序求各顶点的vl值 </span></span><br><span class="line"><span class="keyword">for</span>(Pop(T, j),p=G.vertices[j].firstarc; p; p=p-&gt;nextarc)&#123;</span><br><span class="line">k = p-&gt;adjvex;dut = *(p-&gt;info);</span><br><span class="line"><span class="keyword">if</span>(vl[k]-dut &lt; vl[j])</span><br><span class="line">vl[j] = vl[k]-dut;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;G.vexnum;j++)&#123;<span class="comment">//求ee，el和关键活动 </span></span><br><span class="line"><span class="keyword">for</span>(p=G.vertices[j].firstarc; p; p=p-&gt;nextarc)&#123;</span><br><span class="line">k = p-&gt;adjvex;dut = *(p-&gt;info);</span><br><span class="line">ee = ve[j];el = vl[k]-dut;</span><br><span class="line">tag = (ee==el)?<span class="string">&#x27;*&#x27;</span>:<span class="string">&#x27;&#x27;</span>;</span><br><span class="line">printf(j, k, dut, ee, el, tag);<span class="comment">//输出关键活动 </span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p>  上面两种算法的时间复杂度均为 O(n+e)，计算弧的活动最早开始时间和最迟开始时间的时间复杂度为 O(e)，所以总的求关键路径的**时间复杂度为 O(n+e)**。  </p><h2 id="求关键路径过程示例"><a href="#求关键路径过程示例" class="headerlink" title="求关键路径过程示例"></a>求关键路径过程示例</h2><p><img                       lazyload                     alt="image"                     data-src="https://img1.musnow.top/i/2023/03/f0dcb74c0eff3d6f56e8415a2664e1dd.png"                                     ><br><img                       lazyload                     alt="image"                     data-src="https://img1.musnow.top/i/2023/03/d52c8bebe169544eea3f93136b617d61.jpeg"                                     > </p><p>上图的关键活动为 a1，a4，a7，a8，a10 和 a11。它们构成两条关键路径：(V1，V2，V5，V7，V9) 和 (V1，V2，V5，V8，V9)。  </p><p><strong>实践证明：用 AOE-网来估算某些工程完成的时间是非常有用的。只有在不改变网的关键路径的情况下，提高关键活动的速度才有效。若网中有几条关键路径，那么，单是提高一条关键路径上的关键活动的速度，还不能导致整个工程缩短工期，而必须提高同时在几条关键路径上的活动速度。</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">版权声明：本文为CSDN博主「qw&amp;amp;jy」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。</span><br><span class="line">原文链接：https://blog.csdn.net/qq_43448856/article/details/119959241</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;本文搬运自csdn&lt;/p&gt;</summary>
    
    
    
    <category term="数据结构太复杂" scheme="https://blog.musnow.top/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%A4%AA%E5%A4%8D%E6%9D%82/"/>
    
    
    <category term="数据结构" scheme="https://blog.musnow.top/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    <category term="图" scheme="https://blog.musnow.top/tags/%E5%9B%BE/"/>
    
    <category term="Java" scheme="https://blog.musnow.top/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>【教程】Typora+PicGo+又拍云USS搭建博客图床</title>
    <link href="https://blog.musnow.top/2023/03/12/tools/img/17%E5%8F%88%E6%8B%8D%E4%BA%91uss+picgo/"/>
    <id>https://blog.musnow.top/2023/03/12/tools/img/17%E5%8F%88%E6%8B%8D%E4%BA%91uss+picgo/</id>
    <published>2023-03-12T00:35:28.000Z</published>
    <updated>2023-03-20T09:52:31.707Z</updated>
    
    <content type="html"><![CDATA[<p>Typora+PicGo+又拍云USS搭建博客图床</p><span id="more"></span><h1 id="1-又拍云uos配置"><a href="#1-又拍云uos配置" class="headerlink" title="1.又拍云uos配置"></a>1.又拍云uos配置</h1><h2 id="1-1-创建"><a href="#1-1-创建" class="headerlink" title="1.1 创建"></a>1.1 创建</h2><p>进入控制台后，点击云存储，创建云存储服务。配置你的服务名称，操作员名称，和操作员的权限。</p><p>请保存操作员的密码，后续配置picgo用得到</p><p><img                       lazyload                     alt="image"                     data-src="https://img1.musnow.top/i/2023/03/51c2ef0cca2e70e32b09857f5358c54c.png"                      alt="image-20230312084831623"                ></p><h2 id="1-2-加速域名"><a href="#1-2-加速域名" class="headerlink" title="1.2 加速域名"></a>1.2 加速域名</h2><p>点击如下图齿轮进入配置页面</p><p><img                       lazyload                     alt="image"                     data-src="https://img1.musnow.top/i/2023/03/8e0fadfea5eb848011682a22a44f83ba.png"                      alt="image-20230312083903790"                ></p><p>在下图绑定你的域名（需要已备案域名）</p><p><img                       lazyload                     alt="image"                     data-src="https://img1.musnow.top/i/2023/03/625bc16e55372917417c26d5c3e819c2.png"                      alt="image-20230312084009866"                ></p><h2 id="1-3-https"><a href="#1-3-https" class="headerlink" title="1.3 https"></a>1.3 https</h2><p>随后在下图所示处配置域名的证书。如果你没有ssl证书，可以在又拍云的控制台主页申请一个免费的<code>let’s encrpy</code>证书</p><p><img                       lazyload                     alt="image"                     data-src="https://img1.musnow.top/i/2023/03/24b7d19b0bea93e1b84a24389afaf237.png"                      alt="image-20230312084046578"                ></p><h2 id="1-4-访问控制"><a href="#1-4-访问控制" class="headerlink" title="1.4 访问控制"></a>1.4 访问控制</h2><p>在访问控制里面可以配置各种形式的控制。对于博客图床而言，referer防盗链是一定要打开的，其余根据自己的需求进行配置</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">IP黑白名单 <span class="comment"># 白名单：允许的ip,黑名单：不允许的ip</span></span><br><span class="line"><span class="comment"># 如果发现某一个ip的请求次数过多，有恶意请求嫌疑，可以暂时将这个ip设置为黑名单</span></span><br><span class="line">CORS 跨域共享 <span class="comment"># 参考http://ruanyifeng.com/blog/2016/04/cors.html</span></span><br><span class="line">地区访问限制 <span class="comment"># 禁止或允许特定地区的限制</span></span><br><span class="line">Referer 防盗链 <span class="comment"># 重点，建议开启白名单，只将自己的域名添加到白名单中（建议开启）</span></span><br><span class="line">User-Agent 防盗链 <span class="comment"># 限制只有某种类型的客户端、浏览器可以访问资源</span></span><br><span class="line">Token 防盗链 <span class="comment"># 有些麻烦，请自行了解。对于静态博客而言，并不方便</span></span><br><span class="line">回源鉴权 <span class="comment"># 如果源站服务器有鉴权操作，可以在这里配置</span></span><br><span class="line">IP 访问限制 <span class="comment"># 对单个ip的请求速率进行限制（建议开启）</span></span><br><span class="line">CC 防护 <span class="comment"># 防护cc攻击</span></span><br><span class="line">WAF 保护 <span class="comment"># Web Application Firewall</span></span><br></pre></td></tr></table></figure><h1 id="2-picgo配置"><a href="#2-picgo配置" class="headerlink" title="2.picgo配置"></a>2.picgo配置</h1><p>相比于阿里云oss，这里的picgo配置就挺明了了</p><p><img                       lazyload                     alt="image"                     data-src="https://img1.musnow.top/i/2023/03/be5e600f6ec7f568f6c9722d88291f7e.png"                      alt="image-20230312084344938"                ></p><p>在picgo的<strong>上传区</strong>测试一下是否能正常上传</p><h1 id="3-typora"><a href="#3-typora" class="headerlink" title="3.typora"></a>3.typora</h1><p>typora的偏好设置中，图像一栏选择上传图片，勾选如下几项。</p><p>上传服务设置为<code>picgo(app)</code>，路径填写为你picgo的安装路径。</p><p><img                       lazyload                     alt="image"                     data-src="https://img1.musnow.top/i/2023/03/59936c6ea7a652bd02ca47fa81b94f7e.png"                      alt="image-20230312084419417"                ></p><p>随后点击左下角验证图片上传，出现如下所示代表配置成功</p><p><img                       lazyload                     alt="image"                     data-src="https://img1.musnow.top/i/2023/03/42c1bf3d071335235ff8c6d201a5a66e.png"                      alt="image-20230312084524751"                ></p><p>此时我们的图床就已经配置好了</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;Typora+PicGo+又拍云USS搭建博客图床&lt;/p&gt;</summary>
    
    
    
    <category term="差生文具多" scheme="https://blog.musnow.top/categories/%E5%B7%AE%E7%94%9F%E6%96%87%E5%85%B7%E5%A4%9A/"/>
    
    
    <category term="图床" scheme="https://blog.musnow.top/tags/%E5%9B%BE%E5%BA%8A/"/>
    
    <category term="typora" scheme="https://blog.musnow.top/tags/typora/"/>
    
  </entry>
  
  <entry>
    <title>【建站】hexo搭建博客+建站相关教程</title>
    <link href="https://blog.musnow.top/2023/03/12/blog/%E5%BB%BA%E7%AB%99%E6%95%99%E7%A8%8B/"/>
    <id>https://blog.musnow.top/2023/03/12/blog/%E5%BB%BA%E7%AB%99%E6%95%99%E7%A8%8B/</id>
    <published>2023-03-12T00:28:14.000Z</published>
    <updated>2023-03-20T09:50:31.568Z</updated>
    
    <content type="html"><![CDATA[<p>关于HEXO建站相关博客汇总</p><span id="more"></span><h1 id="1-hexo部署和主题自定义"><a href="#1-hexo部署和主题自定义" class="headerlink" title="1.hexo部署和主题自定义"></a>1.hexo部署和主题自定义</h1><p><a href="https://blog.musnow.top/2022/04/16/blog/%E4%BD%BF%E7%94%A8hexo%E5%92%8Ckeep%E4%B8%BB%E9%A2%98%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/">【教程】hexo搭建博客+keep主题美化</a></p><h1 id="2-配置图床"><a href="#2-配置图床" class="headerlink" title="2.配置图床"></a>2.配置图床</h1><p>以下为typora+picgo配置图床的教程</p><p><a href="https://blog.musnow.top/2023/01/23/tools/11picgo%E8%AE%BE%E7%BD%AE%E5%91%BD%E5%90%8D%E6%A0%BC%E5%BC%8F/">【Picgo】正确重命名文件，避免重复上传</a></p><h2 id="2-1-阿里云oss"><a href="#2-1-阿里云oss" class="headerlink" title="2.1 阿里云oss"></a>2.1 阿里云oss</h2><p><a href="https://blog.musnow.top/2022/01/11/tools/1%E9%98%BF%E9%87%8C%E4%BA%91oss+picgo+typora/">【教程】Typora+PicGo+阿里云OSS搭建博客图床（超详细）</a></p><h2 id="2-2-又拍云uos"><a href="#2-2-又拍云uos" class="headerlink" title="2.2 又拍云uos"></a>2.2 又拍云uos</h2><p>相比于阿里云oss的bucket只有防盗链，又拍云的uos还有ip黑白名单，cc防护，单ip访问限制等等功能。对于博客图床防盗刷而言，很有用。</p><p>但又拍云uos需要<strong>域名已备案</strong>才能自定义域名，否则只能使用官方提供的测试域名。如果你的域名已备案，个人更推荐使用又拍云uos作为博客图床。</p><p><a href="https://blog.musnow.top/2023/03/12/tools/17%E5%8F%88%E6%8B%8D%E4%BA%91uss+picgo/">【教程】Typora+PicGo+又拍云USS搭建博客图床</a></p><h2 id="2-3-自建图床lsky"><a href="#2-3-自建图床lsky" class="headerlink" title="2.3 自建图床lsky"></a>2.3 自建图床lsky</h2><p>自建图床的优势在于，<strong>图片都在你服务器的本地</strong>，可以直接tar打包进行备份，或者手动从服务器下载到电脑作为备份。</p><p>个人不太喜欢oss的一点，就是大多数oss服务商都没有提供批量下载oss内部文件的选项。估计是考虑到存储服务器的负载问题，所以没有提供这个功能。毕竟批量下载大量文件，是很耗资源的。</p><p>虽然可以用python代码来实现批量下载，但服务商能直接提供批量下载的功能，还是更方面嘛！</p><p><a href="https://blog.musnow.top/2023/01/28/docker/5docker%E9%85%8D%E7%BD%AElskypro%E5%9B%BE%E5%BA%8A/#4-picgo">【Docker】配置lsky pro兰空图床</a> (支持picgo)</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;关于HEXO建站相关博客汇总&lt;/p&gt;</summary>
    
    
    
    <category term="差生文具多" scheme="https://blog.musnow.top/categories/%E5%B7%AE%E7%94%9F%E6%96%87%E5%85%B7%E5%A4%9A/"/>
    
    
    <category term="Hexo" scheme="https://blog.musnow.top/tags/Hexo/"/>
    
  </entry>
  
  <entry>
    <title>【docker】通过配置文件，修改已有容器的端口映射</title>
    <link href="https://blog.musnow.top/2023/03/11/docker/11%E4%BF%AE%E6%94%B9%E5%B7%B2%E6%9C%89%E5%AE%B9%E5%99%A8%E7%9A%84%E7%AB%AF%E5%8F%A3%E6%98%A0%E5%B0%84/"/>
    <id>https://blog.musnow.top/2023/03/11/docker/11%E4%BF%AE%E6%94%B9%E5%B7%B2%E6%9C%89%E5%AE%B9%E5%99%A8%E7%9A%84%E7%AB%AF%E5%8F%A3%E6%98%A0%E5%B0%84/</id>
    <published>2023-03-11T11:45:33.000Z</published>
    <updated>2023-03-11T12:00:52.818Z</updated>
    
    <content type="html"><![CDATA[<p>docker修改已有容器的端口映射</p><span id="more"></span><blockquote><p>参考 <a class="link"   href="https://www.jb51.net/article/257510.htm" >https://www.jb51.net/article/257510.htm<i class="fas fa-external-link-alt"></i></a></p></blockquote><h1 id="1-需求"><a href="#1-需求" class="headerlink" title="1.需求"></a>1.需求</h1><p>之前我在我的nas上部署了一个centos容器，当时脑子抽了，没想起来要多映射几个端口。只映射了容器的22端口（ssh）</p><p>对于应用开发而言，没有能够直接访问的端口可太蛋疼了。在centos里面开frp穿透出来访问吧，又太麻烦。</p><p>如果在绿联的控制台里面修改端口隐射，<strong>会直接创建一个新的容器</strong>，原有容器的信息会丢失。现在这个centos系统已经用了一段时间了，开发环境都配置好了。创建一个新容器就是得重头配置，虽然不是啥难事，但是太耗时间了！！！😥</p><p>于是就想着，能否通过修改配置文件的方式，实现修改容器的端口映射。</p><h1 id="2-操作"><a href="#2-操作" class="headerlink" title="2.操作"></a>2.操作</h1><h2 id="2-1-开启ssh并关闭docker服务"><a href="#2-1-开启ssh并关闭docker服务" class="headerlink" title="2.1 开启ssh并关闭docker服务"></a>2.1 开启ssh并关闭docker服务</h2><p>修改之前，<strong>需要开启绿联nas的ssh服务</strong>。绿联nas如何开启ssh参考 <a class="link"   href="https://www.bilibili.com/video/BV1J84y1C7Zu/?spm_id_from=333.337.search-card.all.click" >视频<i class="fas fa-external-link-alt"></i></a></p><p>链接上ssh之后，先使用<code>docker ps</code>，查看需要修改容器的id。注意，这里的id并不是完整的容器id，先记录下来。</p><p><img                       lazyload                     alt="image"                     data-src="https://img1.musnow.top/i/2023/03/4531c3a572e0afe317768fee05254943.png"                      alt="image-20230311193038037"                ></p><p>图中也能看到，当前这个centos容器只映射了22端口</p><hr><p>进入绿联的客户端，关闭docker服务</p><p><img                       lazyload                     alt="image"                     data-src="https://img1.musnow.top/i/2023/03/aa3879c8c27f9e13e4300376eec8176b.png"                      alt="image-20230311192756106"                ></p><p>命令行里面再次执行<code>docker ps</code>，确认docker服务确实已经关闭</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ docker ps</span><br><span class="line">Cannot connect to the Docker daemon at unix:///var/run/docker.sock. Is the docker daemon running?</span><br></pre></td></tr></table></figure><p>如果显示如上，则代表docker并没有在运行。</p><hr><h2 id="2-2-找到docker安装路径"><a href="#2-2-找到docker安装路径" class="headerlink" title="2.2 找到docker安装路径"></a>2.2 找到docker安装路径</h2><p>接下来要做的，就是查看docker安装的位置。对于群晖、威联通、绿联这种nas而言，其系统内对docker安装挂载的位置是不同的。比如绿联的nas自带了16gb的闪存，但docker的安装位置并不在这里面。</p><p>一般的centos系统（以我的云服务器为例），docker的安装位置应该是如下路径</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/var/lib/docker</span><br></pre></td></tr></table></figure><p>ls查看内部文件，如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># ls /var/lib/docker</span><br><span class="line">containers  image  network  overlay2  plugins  swarm  tmp  trust  volumes</span><br></pre></td></tr></table></figure><p>而绿联的系统并没有这个路径</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">can&#x27;t open &#x27;/var/lib/docker&#x27;: No such file or directory</span><br></pre></td></tr></table></figure><p>查看<code>/var/lib</code>，并没有发现docker文件夹</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># ls /var/lib/</span><br><span class="line">dbus   nginx  samba</span><br></pre></td></tr></table></figure><p>查看<code>/var</code>，发现了一个dockerd，猜测这是docker相关文件存放的位置</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># ls /var</span><br><span class="line">all_aria2.txt    dockerd          factory   </span><br></pre></td></tr></table></figure><p>里面只有一个json文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># ls /var/dockerd</span><br><span class="line">daemon.json</span><br></pre></td></tr></table></figure><p>cat命令查看，果不其然，是docker的安装路径</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># cat /var/dockerd/daemon.json</span><br><span class="line">&#123;&quot;data-root&quot;:&quot;/mnt/media_rw/2550c297-7334-455f-9fce-e0a00aad40c8/.ugreen_nas/6&quot;,&quot;log-level&quot;:&quot;warn&quot;,&quot;iptables&quot;:true,&quot;api-cors-header&quot;:&quot;*&quot;,&quot;host375&quot;],&quot;registry-mirrors&quot;:[&quot;https://registry.docker-cn.com&quot;]&#125;</span><br></pre></td></tr></table></figure><p>这就是docker的安装位置了</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/mnt/media_rw/2550c297-7334-455f-9fce-e0a00aad40c8/.ugreen_nas/6</span><br></pre></td></tr></table></figure><p>ls查看，文件结构和云服务器的docker安装位置基本一样，这代表我们找对了！</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># ls /mnt/media_rw/2550c297-7334-455f-9fce-e0a00aad40c8/.ugreen_nas/6</span><br><span class="line">buildkit    containerd  containers  image       network     overlay2    plugins     runtimes    swarm    </span><br><span class="line">tmp        trust       volumes</span><br></pre></td></tr></table></figure><h2 id="2-3-找到对应容器的配置文件路径"><a href="#2-3-找到对应容器的配置文件路径" class="headerlink" title="2.3 找到对应容器的配置文件路径"></a>2.3 找到对应容器的配置文件路径</h2><p>docker路径下的<code>containers</code>文件夹，包含了不同容器的配置<strong>文件夹</strong>。ls查看，发现都是一些看不懂的字符串。实际上，这里的字符串就是容器的id</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># ls /mnt/media_rw/2550c297-7334-455f-9fce-e0a00aad40c8/.ugreen_nas/6/containers</span><br><span class="line">2b8f29d7b4b0ad624fb02048cb91c569e6e52409fe246e1c741bdd13ed7242cf  9113e1ec4740726feb9623a897f81b9066bc1b63811bfc0a65875d8a2c46c603</span><br><span class="line">47aa763o2da18686c6301047ef57f24fb611a2ebea2066f0dbk68205a40777e3</span><br></pre></td></tr></table></figure><p>前面提到，<code>docker ps</code>显示的容器id并不是完整的。因为完整的很长很长，不可能在ps命令里面全显示出来。</p><p>我需要修改的目标容器，缩短的id如下，对应的正是<code>containers</code>文件夹里面的第一个文件夹</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2b8f29d7b4b0</span><br></pre></td></tr></table></figure><p>看看这个文件夹里面有啥东西</p><p><font color=Red>注意</font>：此时命令已经很长很长。避免出错，建议开个记事本，在里面把命令写好，再复制到终端中执行！</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ls -l /mnt/media_rw/2550c297-7334-455f-9fce-e0a00aad40c8/.ugreen_nas/6/containers/2b8f29d7b4b0ad624fb02048cb91c569e6e52409fe246e1c741bdd13ed7242cf</span><br></pre></td></tr></table></figure><p>得到的文件结构如下，我们需要修改的是<code>config.v2.json</code>和<code>hostconfig.json</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">-rw-r-----    1 root     root         87802 Mar 11 18:12 2b8f29d7b4b0ad624fb02048cb91c569e6e52409fe246e1c741bdd13ed7242cf-json.log</span><br><span class="line">drwx------    2 root     root          4096 Feb 23 18:42 checkpoints</span><br><span class="line">-rw-------    1 root     root          3300 Mar 11 18:12 config.v2.json</span><br><span class="line">-rw-r--r--    1 root     root          1925 Mar 11 18:12 hostconfig.json</span><br><span class="line">-rw-r--r--    1 root     root            13 Mar 11 18:12 hostname</span><br><span class="line">-rw-r--r--    1 root     root           174 Mar 11 18:12 hosts</span><br><span class="line">drwx--x---    2 root     root          4096 Feb 23 18:43 mounts</span><br><span class="line">-rw-r--r--    1 root     root            83 Mar 11 18:12 resolv.conf</span><br><span class="line">-rw-r--r--    1 root     root            71 Mar 11 18:12 resolv.conf.hash</span><br></pre></td></tr></table></figure><h2 id="2-4-备份"><a href="#2-4-备份" class="headerlink" title="2.4 备份"></a>2.4 备份</h2><p>在linux的命令行中操作，备份是必不可少的！使用cp命令，把配置文件复制一份，并在名字中添加上<code>.bak</code>予以区别</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cp 源文件 目标文件</span><br></pre></td></tr></table></figure><p>以下是cp命令备份<code>config.v2.json</code>文件的命令示例</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cp /mnt/media_rw/2550c297-7334-455f-9fce-e0a00aad40c8/.ugreen_nas/6/containers/2b8f29d7b4b0ad624fb02048cb91c569e6e52409fe246e1c741bdd13ed7242cf/config.v2.json /mnt/media_rw/2550c297-7334-455f-9fce-e0a00aad40c8/.ugreen_nas/6/containers/2b8f29d7b4b0ad624fb02048cb91c569e6e52409fe246e1c741bdd13ed7242cf/config.v2.bak.json</span><br></pre></td></tr></table></figure><p>备份了我们需要修改的两个文件后，接下来就是修改配置文件了</p><h2 id="2-5-修改配置文件"><a href="#2-5-修改配置文件" class="headerlink" title="2.5 修改配置文件"></a>2.5 修改配置文件</h2><h3 id="2-5-1-hostconfig-json"><a href="#2-5-1-hostconfig-json" class="headerlink" title="2.5.1  hostconfig.json"></a>2.5.1  hostconfig.json</h3><p>使用vim来进行编辑（编辑之前，可以用cat先复制出内容，放到vsc等编辑器中格式化，方便找到对应的位置）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim /mnt/media_rw/2550c297-7334-455f-9fce-e0a00aad40c8/.ugreen_nas/6/containers/2b8f29d7b4b0ad624fb02048cb91c569e6e52409fe246e1c741bdd13ed7242cf/hostconfig.json</span><br></pre></td></tr></table></figure><p>如下便是要修改的字段，可以看到里面只有对22端口的映射</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">&quot;PortBindings&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;22/tcp&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">            <span class="punctuation">&#123;</span></span><br><span class="line">                <span class="attr">&quot;HostIp&quot;</span><span class="punctuation">:</span> <span class="string">&quot;0.0.0.0&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;HostPort&quot;</span><span class="punctuation">:</span> <span class="string">&quot;22222&quot;</span></span><br><span class="line">            <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="punctuation">&#123;</span></span><br><span class="line">                <span class="attr">&quot;HostIp&quot;</span><span class="punctuation">:</span> <span class="string">&quot;::&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;HostPort&quot;</span><span class="punctuation">:</span> <span class="string">&quot;22222&quot;</span></span><br><span class="line">            <span class="punctuation">&#125;</span></span><br><span class="line">        <span class="punctuation">]</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>我们照猫画虎，直接添加上另外两个端口的映射。</p><p>在英文输入法下，按<code>i</code>进入vim的编辑模式，通过键盘移动光标到指定位置，修改文件</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">&quot;PortBindings&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;22/tcp&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">            <span class="punctuation">&#123;</span></span><br><span class="line">                <span class="attr">&quot;HostIp&quot;</span><span class="punctuation">:</span> <span class="string">&quot;0.0.0.0&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;HostPort&quot;</span><span class="punctuation">:</span> <span class="string">&quot;22222&quot;</span></span><br><span class="line">            <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="punctuation">&#123;</span></span><br><span class="line">                <span class="attr">&quot;HostIp&quot;</span><span class="punctuation">:</span> <span class="string">&quot;::&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;HostPort&quot;</span><span class="punctuation">:</span> <span class="string">&quot;22222&quot;</span></span><br><span class="line">            <span class="punctuation">&#125;</span></span><br><span class="line">        <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;50000/tcp&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">            <span class="punctuation">&#123;</span></span><br><span class="line">                <span class="attr">&quot;HostIp&quot;</span><span class="punctuation">:</span> <span class="string">&quot;0.0.0.0&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;HostPort&quot;</span><span class="punctuation">:</span> <span class="string">&quot;50000&quot;</span></span><br><span class="line">            <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="punctuation">&#123;</span></span><br><span class="line">                <span class="attr">&quot;HostIp&quot;</span><span class="punctuation">:</span> <span class="string">&quot;::&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;HostPort&quot;</span><span class="punctuation">:</span> <span class="string">&quot;50000&quot;</span></span><br><span class="line">            <span class="punctuation">&#125;</span></span><br><span class="line">        <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;50001/tcp&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">            <span class="punctuation">&#123;</span></span><br><span class="line">                <span class="attr">&quot;HostIp&quot;</span><span class="punctuation">:</span> <span class="string">&quot;0.0.0.0&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;HostPort&quot;</span><span class="punctuation">:</span> <span class="string">&quot;50001&quot;</span></span><br><span class="line">            <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="punctuation">&#123;</span></span><br><span class="line">                <span class="attr">&quot;HostIp&quot;</span><span class="punctuation">:</span> <span class="string">&quot;::&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;HostPort&quot;</span><span class="punctuation">:</span> <span class="string">&quot;50001&quot;</span></span><br><span class="line">            <span class="punctuation">&#125;</span></span><br><span class="line">        <span class="punctuation">]</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>编辑好了之后，按esc退出编辑模式，<code>:wq</code>保存并退出</p><hr><h3 id="2-5-2-config-v2-json"><a href="#2-5-2-config-v2-json" class="headerlink" title="2.5.2 config.v2.json"></a>2.5.2 config.v2.json</h3><p>这个文件需要修改的是如下字段</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">&quot;ExposedPorts&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;22/tcp&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span><span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>添加上刚刚在<code>hostconfig.json</code>里面新增的端口</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">&quot;ExposedPorts&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;22/tcp&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;50000/tcp&quot;</span><span class="punctuation">:</span><span class="punctuation">&#123;</span><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;50001/tcp&quot;</span><span class="punctuation">:</span><span class="punctuation">&#123;</span><span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>同样<code>:wq</code>保存并退出</p><h2 id="2-6-现在就已经修改好啦！"><a href="#2-6-现在就已经修改好啦！" class="headerlink" title="2.6 现在就已经修改好啦！"></a>2.6 现在就已经修改好啦！</h2><p>相同的位置还可以修改容器的hostname。</p><p>用docker安装的centos镜像，是不能在centos系统中修改容器hostname的（修改可以，但是不会生效）</p><h1 id="3-重启docker，查看是否修改成功"><a href="#3-重启docker，查看是否修改成功" class="headerlink" title="3.重启docker，查看是否修改成功"></a>3.重启docker，查看是否修改成功</h1><p>在客户端里面重启docker服务之后，使用docker ps命令查看端口映射是否修改成功</p><p><img                       lazyload                     alt="image"                     data-src="https://img1.musnow.top/i/2023/03/04cbabad9ae0b3f2dbe29136281063b8.png"                      alt="image-20230311195511866"                ></p><p>可以看到，多出了50000和50001端口，修改成功！</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;docker修改已有容器的端口映射&lt;/p&gt;</summary>
    
    
    
    <category term="docker真好玩" scheme="https://blog.musnow.top/categories/docker%E7%9C%9F%E5%A5%BD%E7%8E%A9/"/>
    
    
    <category term="Linux" scheme="https://blog.musnow.top/tags/Linux/"/>
    
    <category term="CentOS" scheme="https://blog.musnow.top/tags/CentOS/"/>
    
    <category term="Docker" scheme="https://blog.musnow.top/tags/Docker/"/>
    
  </entry>
  
  <entry>
    <title>【js】用html+javascript静态页面实现伪重定向</title>
    <link href="https://blog.musnow.top/2023/03/10/tools/16%E4%BD%BF%E7%94%A8js%E5%AE%9E%E7%8E%B0%E9%87%8D%E5%AE%9A%E5%90%91/"/>
    <id>https://blog.musnow.top/2023/03/10/tools/16%E4%BD%BF%E7%94%A8js%E5%AE%9E%E7%8E%B0%E9%87%8D%E5%AE%9A%E5%90%91/</id>
    <published>2023-03-10T11:50:31.000Z</published>
    <updated>2023-03-11T11:25:36.228Z</updated>
    
    <content type="html"><![CDATA[<p>javascript代码实现一个伪重定向</p><span id="more"></span><h1 id="1-前言"><a href="#1-前言" class="headerlink" title="1.前言"></a>1.前言</h1><p>本站的域名之前有修改过，<strong>但一些朋友的友链，和开往里面的链接尚未更新</strong>。旧的域名又米有备案，不能解析到国内服务器上用nginx进行30x转发。</p><p>这时候我就想到了一招，用js的代码来实现一个url的切换，相当于一个伪重定向。因为是静态文件，能直接部署到netlify等平台上。</p><p>百度了一下js是否支持这种语法，嘿，支持！</p><p>那不直接开整！</p><h1 id="2-代码"><a href="#2-代码" class="headerlink" title="2.代码"></a>2.代码</h1><p>关于http的30x状态码，其代表站点域名或路径更改</p><ul><li>301重定向：永久</li><li>302重定向：临时</li></ul><p>html代码部分很简单，设置body和站点标题都为301重定向，告诉访问者，站点已经换了新的域名</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span><span class="tag">&lt;<span class="name">title</span>&gt;</span>301 Moved Permanently<span class="tag">&lt;/<span class="name">title</span>&gt;</span><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">center</span>&gt;</span><span class="tag">&lt;<span class="name">h1</span>&gt;</span>301 Moved Permanently<span class="tag">&lt;/<span class="name">h1</span>&gt;</span><span class="tag">&lt;/<span class="name">center</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p><code>script</code>部分，通过<code>window</code>获取当前的域名，判断域名是否为目标域名（下文代码中的<code>旧域名</code>）</p><p>如果不是，则什么都不做。如果是，则覆盖url到新域名。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--放在head后，body前--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"><span class="keyword">var</span> path = <span class="variable language_">window</span>.<span class="property">location</span>.<span class="property">href</span>;</span></span><br><span class="line"><span class="language-javascript">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;current path:&quot;</span>,path)<span class="comment">//打印到控制台</span></span></span><br><span class="line"><span class="language-javascript">    <span class="comment">// 睡眠函数</span></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">function</span> <span class="title function_">sleep</span> (time) &#123;</span></span><br><span class="line"><span class="language-javascript">      <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve</span>) =&gt;</span> <span class="built_in">setTimeout</span>(resolve, time));</span></span><br><span class="line"><span class="language-javascript">    &#125;</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="comment">// 睡500ms,之后执行下面的内容</span></span></span><br><span class="line"><span class="language-javascript">    <span class="title function_">sleep</span>(<span class="number">500</span>).<span class="title function_">then</span>(<span class="function">() =&gt;</span> &#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="comment">// 如果url不是预先设定好的这个，则啥都不做</span></span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">if</span> (path!=<span class="string">&quot;旧域名1&quot;</span> &amp;&amp; path!=<span class="string">&quot;旧域名2&quot;</span>) &#123;</span></span><br><span class="line"><span class="language-javascript">          <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;url not match, do nothing&quot;</span>)</span></span><br><span class="line"><span class="language-javascript">        &#125;</span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">else</span>&#123;<span class="comment">// 否则重定向</span></span></span><br><span class="line"><span class="language-javascript">          <span class="variable language_">window</span>.<span class="property">location</span>.<span class="title function_">replace</span>(<span class="string">&quot;https://blog.musnow.top/&quot;</span>);</span></span><br><span class="line"><span class="language-javascript">        &#125;</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    &#125;)</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这里我还用sleep函数休眠了500ms，否则切换很快，访客不注意的话，还不一定能发现301重定向。</p><hr><p>如果你不需要sleep，那代码更少</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"><span class="keyword">var</span> path = <span class="variable language_">window</span>.<span class="property">location</span>.<span class="property">href</span>;</span></span><br><span class="line"><span class="language-javascript">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;current path:&quot;</span>,path)</span></span><br><span class="line"><span class="language-javascript">    <span class="comment">// 如果url不是预先设定好的这两个，则啥都不做</span></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">if</span> (path!=<span class="string">&quot;旧域名&quot;</span>) &#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;url not match, do nothing&quot;</span>)</span></span><br><span class="line"><span class="language-javascript">    &#125;</span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">else</span>&#123;<span class="comment">// 否则重定向</span></span></span><br><span class="line"><span class="language-javascript">       <span class="variable language_">window</span>.<span class="property">location</span>.<span class="title function_">replace</span>(<span class="string">&quot;https://blog.musnow.top/&quot;</span>);</span></span><br><span class="line"><span class="language-javascript">    &#125;</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><h1 id="3-netlify部署"><a href="#3-netlify部署" class="headerlink" title="3.netlify部署"></a>3.netlify部署</h1><p>将刚刚写好的代码写入一个<code>index.html</code>文件，再放入一个文件夹（netlify的上传只能上传文件夹）</p><p>如果你想，还可以在文件夹里面放一个<code>favicon.ico</code>作为临时的站点logo</p><p>打开netlify，找到Add new site，选择手动部署</p><p><img                       lazyload                     alt="image"                     data-src="https://img1.musnow.top/i/2023/03/640b1d697d4b2.png"                      alt="image-20230310200548549"                ></p><p>在这里上传文件夹</p><p><img                       lazyload                     alt="image"                     data-src="https://img1.musnow.top/i/2023/03/640b1d7ed3638.png"                      alt="image-20230310200727885"                ></p><p>部署好了之后，可以在domain settings里面配置域名为你的旧域名</p><p><img                       lazyload                     alt="image"                     data-src="https://img1.musnow.top/i/2023/03/640b1dfe2efe5.png"                      alt="image-20230310200935284"                ></p><h1 id="4-测试"><a href="#4-测试" class="headerlink" title="4.测试"></a>4.测试</h1><p>先访问旧域名，显示301重定向的信息</p><p><img                       lazyload                     alt="image"                     data-src="https://img1.musnow.top/i/2023/03/640b1e203e735.png"                      alt="image-20230310201009342"                ></p><p>休眠的时间到了之后，就会被重定向到当前的站点</p><p><img                       lazyload                     alt="image"                     data-src="https://img1.musnow.top/i/2023/03/640b1e6d4a595.png"                      alt="image-20230310201122790"                ></p><p>目的达成！</p><h1 id="5-添加上尾随参数"><a href="#5-添加上尾随参数" class="headerlink" title="5.添加上尾随参数"></a>5.添加上尾随参数</h1><p>如果你的站点有部署umami或者百度统计等<strong>访问统计</strong>服务，则可以在源码中跳转的链接里面加上来源</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">window</span>.<span class="property">location</span>.<span class="title function_">replace</span>(<span class="string">&quot;https://blog.musnow.top/?utm_source=旧域名&quot;</span>);</span><br></pre></td></tr></table></figure><p>这样，在访问统计中，就能得知有多少用户用了旧域名访问了你的站点</p><p><img                       lazyload                     alt="image"                     data-src="https://img1.musnow.top/i/2023/03/640b207623dc3.png"                      alt="image-20230310201912571"                ></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;javascript代码实现一个伪重定向&lt;/p&gt;</summary>
    
    
    
    <category term="差生文具多" scheme="https://blog.musnow.top/categories/%E5%B7%AE%E7%94%9F%E6%96%87%E5%85%B7%E5%A4%9A/"/>
    
    
    <category term="hexo" scheme="https://blog.musnow.top/tags/hexo/"/>
    
  </entry>
  
  <entry>
    <title>【Python】pip下载使用国内镜像源</title>
    <link href="https://blog.musnow.top/2023/03/10/Python/11pip%E5%AE%89%E8%A3%85%E4%BD%BF%E7%94%A8%E9%95%9C%E5%83%8F%E6%BA%90/"/>
    <id>https://blog.musnow.top/2023/03/10/Python/11pip%E5%AE%89%E8%A3%85%E4%BD%BF%E7%94%A8%E9%95%9C%E5%83%8F%E6%BA%90/</id>
    <published>2023-03-10T00:31:00.000Z</published>
    <updated>2023-03-18T03:00:54.486Z</updated>
    
    <content type="html"><![CDATA[<p>pip下载使用国内镜像源</p><span id="more"></span><h2 id="1-如何使用"><a href="#1-如何使用" class="headerlink" title="1.如何使用"></a>1.如何使用</h2><p>在直接用pip安装包的时候，有时候会非常非常慢</p><p>可以用下面的命令，在安装的时候使用清华的镜像源</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-i https://pypi.tuna.tsinghua.edu.cn/simple</span><br></pre></td></tr></table></figure><p>比如下面的操作</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip3.10 install -r requirements.txt -i https://pypi.tuna.tsinghua.edu.cn/simple</span><br></pre></td></tr></table></figure><p>速度直接起飞</p><h2 id="2-修改配置文件"><a href="#2-修改配置文件" class="headerlink" title="2.修改配置文件"></a>2.修改配置文件</h2><p>在用户的家目录下创建一个<code>.pip</code>文件夹，并在里面创建一个<code>pip.conf</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[global]</span><br><span class="line">index-url = https://pypi.tuna.tsinghua.edu.cn/simple</span><br><span class="line">[install]</span><br><span class="line">trusted-host = https://pypi.tuna.tsinghua.edu.cn</span><br></pre></td></tr></table></figure><p>保存后，查看是否配置成功</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ pip3.10 config list</span><br><span class="line">global.index-url=&#x27;https://pypi.tuna.tsinghua.edu.cn/simple&#x27;</span><br><span class="line">install.trusted-host=&#x27;https://pypi.tuna.tsinghua.edu.cn&#x27;</span><br></pre></td></tr></table></figure><p>这样就配置好了</p><hr><p>windows下pip配置文件路径如下（如果没有此文件，创建之）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">C:\Users\用户名\pip\pip.ini</span><br></pre></td></tr></table></figure><p>输入如下内容</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[global]</span><br><span class="line">index-url = https://pypi.tuna.tsinghua.edu.cn/simple</span><br><span class="line">[install]</span><br><span class="line">trusted-host = pypi.tuna.tsinghua.edu.cn</span><br></pre></td></tr></table></figure><h2 id="3-镜像源汇总"><a href="#3-镜像源汇总" class="headerlink" title="3.镜像源汇总"></a>3.镜像源汇总</h2><p>目前我测试能直接访问的镜像源有下面几个。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">清华 https://pypi.tuna.tsinghua.edu.cn/simple</span><br><span class="line">豆瓣 https://pypi.doubanio.com/simple/</span><br><span class="line">中科大 https://mirrors.bfsu.edu.cn/pypi/web/simple/</span><br><span class="line">阿里云 https://mirrors.aliyun.com/pypi/simple/</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;pip下载使用国内镜像源&lt;/p&gt;</summary>
    
    
    
    <category term="速通Python" scheme="https://blog.musnow.top/categories/%E9%80%9F%E9%80%9APython/"/>
    
    
    <category term="Python" scheme="https://blog.musnow.top/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>【Linux】浏览器写代码！部署code-server远程vscode网页</title>
    <link href="https://blog.musnow.top/2023/03/09/docker/10code-server/"/>
    <id>https://blog.musnow.top/2023/03/09/docker/10code-server/</id>
    <published>2023-03-09T13:45:33.000Z</published>
    <updated>2023-03-17T09:24:34.053Z</updated>
    
    <content type="html"><![CDATA[<p>部署code-server远程vscode网页，在浏览器上写代码！</p><span id="more"></span><p>参考文档 <a class="link"   href="https://developer.aliyun.com/article/876967#slide-7" >https://developer.aliyun.com/article/876967#slide-7<i class="fas fa-external-link-alt"></i></a></p><h1 id="1-什么是code-server？"><a href="#1-什么是code-server？" class="headerlink" title="1.什么是code-server？"></a>1.什么是code-server？</h1><p>注意，这不是在linux系统上安装vscode软件（和windows一样的vscode客户端）</p><blockquote><p>开源仓库 <a class="link"   href="https://github.com/coder/code-server" >https://github.com/coder/code-server<i class="fas fa-external-link-alt"></i></a></p></blockquote><p>code-server是一个社区项目（非微软官方）其作用是在你的linux主机（云服务器）上部署一个可以在<strong>浏览器</strong>上访问的vscode页面，类似官方的<code>vscode.dev</code></p><blockquote><p>微软官方推出的vscode网页版 <a class="link"   href="https://vscode.dev/" >https://vscode.dev/<i class="fas fa-external-link-alt"></i></a> </p><p>它可以通过浏览器的api访问你<strong>电脑上的本地文件</strong>，此时浏览器就是一个vscode客户端</p><p><img                       lazyload                     alt="image"                     data-src="https://img1.musnow.top/i/2023/03/6409e2f59a83a.png"                      alt="image-20230309214517648"                ></p></blockquote><p>code-server同理，其访问的是你linux服务器上的文件，作用类似于vscode插件<code>remote ssh</code>，让我们可以用浏览器，在任何电脑、<strong>平板</strong>上进行远程开发，无须下载vscode客户端或者ssh软件！</p><p><img                       lazyload                     alt="image"                     data-src="https://img1.musnow.top/i/2023/03/6409edd1712e7.png"                      alt="image-20230309223145036"                ></p><h2 id="1-1-官方的vscode-server"><a href="#1-1-官方的vscode-server" class="headerlink" title="1.1 官方的vscode-server?"></a>1.1 官方的vscode-server?</h2><p>微软官方确实有一个vscode-server，在官网可以下载。我测试了之后，发现它是打了一个隧道，通过<code>vscode.dev</code>的子域名访问，会转发到你的主机上。</p><p><img                       lazyload                     alt="image"                     data-src="https://img1.musnow.top/i/2023/03/6409f5464d748.png"                      alt="image-20230309230334118"                ></p><p>在我这里的测试，<strong>发现压根连不上微软的服务器</strong>。想想其实也很正常，因为vscode-server的文档页面连中文都没有，再加上微软的服务器，国内用不了也是意料之中</p><h1 id="2-安装"><a href="#2-安装" class="headerlink" title="2.安装"></a>2.安装</h1><h2 id="2-1-下载安装包"><a href="#2-1-下载安装包" class="headerlink" title="2.1 下载安装包"></a>2.1 下载安装包</h2><p>截至本文创作时间<code>23-03-09</code>，code-server的最新版本是<code>4.10.1</code>，可以用下面的命令获取到linux下的安装包</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget https://github.com/cdr/code-server/releases/download/v4.10.1/code-server-4.10.1-linux-amd64.tar.gz </span><br></pre></td></tr></table></figure><p>如果上面这个命令你无法访问，可以去github的releases里面手动下载安装包</p><blockquote><p><a class="link"   href="https://github.com/coder/code-server/releases/" >https://github.com/coder/code-server/releases/<i class="fas fa-external-link-alt"></i></a></p></blockquote><p>我的系统是amd64，即x86架构。在github里面也是找<code>linux amd64</code>的包进行安装</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ uname -a</span><br><span class="line">Linux 1c2261732150 5.10.120 #0 SMP Fri Jan 6 08:05:47 2023 x86_64 x86_64 x86_64 GNU/Linux</span><br></pre></td></tr></table></figure><p>如果你使用的是树莓派等设备，请用<code>uname -a</code>确认你的系统架构，并下载对应的包</p><hr><p>github的release下载慢，可以用下面这个网站加速（用迅雷下，速度起飞）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://doget.nocsdn.com/#/</span><br></pre></td></tr></table></figure><p>下载完成后，将压缩包用xftp传输到服务器上</p><h2 id="2-2-解压"><a href="#2-2-解压" class="headerlink" title="2.2 解压"></a>2.2 解压</h2><p>使用下面的命令解压刚刚下载好的压缩包</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar -zxvf code-server-4.10.1-linux-amd64.tar.gz</span><br></pre></td></tr></table></figure><p>给解压出来的文件夹改个短名字vsc</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mv code-server-4.10.1-linux-amd64 vsc</span><br></pre></td></tr></table></figure><p>cd进入这个文件夹</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cd vsc</span><br></pre></td></tr></table></figure><p><code>ls -l</code>，基本文件如下</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">total 792</span><br><span class="line">drwxr-xr-x   8 muxue muxue   4096 Mar  4 12:26 .</span><br><span class="line">drwx------   6 muxue muxue   4096 Mar  9 22:42 ..</span><br><span class="line">drwxr-xr-x   2 muxue muxue   4096 Mar  4 12:26 bin</span><br><span class="line">drwxr-xr-x   3 muxue muxue   4096 Mar  4 12:26 lib</span><br><span class="line">-rw-r--r--   1 muxue muxue   1084 Mar  3 17:13 LICENSE</span><br><span class="line">drwxr-xr-x 243 muxue muxue  12288 Mar  4 12:26 node_modules</span><br><span class="line">-rw-r--r--   1 muxue muxue 480100 Mar  4 12:26 npm-shrinkwrap.json</span><br><span class="line">drwxr-xr-x   5 muxue muxue   4096 Mar  3 17:13 out</span><br><span class="line">-rw-r--r--   1 muxue muxue   5235 Mar  4 12:24 package.json</span><br><span class="line">-rwxr-xr-x   1 muxue muxue   4877 Mar  3 17:13 postinstall.sh</span><br><span class="line">-rw-r--r--   1 muxue muxue   3056 Mar  3 17:13 README.md</span><br><span class="line">drwxr-xr-x   3 muxue muxue   4096 Mar  3 17:14 src</span><br><span class="line">-rw-r--r--   1 muxue muxue 180977 Mar  3 17:13 ThirdPartyNotices.txt</span><br><span class="line">drwxr-xr-x   2 muxue muxue   4096 Mar  3 17:14 typings</span><br><span class="line">-rw-r--r--   1 muxue muxue  76688 Mar  4 12:26 yarn.lock</span><br></pre></td></tr></table></figure><p>直接进入bin文件夹，我们需要用的可执行文件就在里头</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ ls</span><br><span class="line">code-server</span><br></pre></td></tr></table></figure><p>这个<code>code-server</code>就是我们要的可执行文件</p><h2 id="2-3-启动code-server"><a href="#2-3-启动code-server" class="headerlink" title="2.3 启动code-server"></a>2.3 启动code-server</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">export PASSWORD=&quot;配置一个密码&quot;</span><br><span class="line">code-server --port 8888 --host 0.0.0.0 --auth password</span><br></pre></td></tr></table></figure><p>上面这个命令，启动之后，会创建一个端口为8888的web服务，此时使用<code>ip:8888</code>的方式，应该就可以访问到你的code-server服务了！</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[2023-03-09T14:52:07.081Z] info  Wrote default config file to ~/.config/code-server/config.yaml</span><br><span class="line">[2023-03-09T14:52:07.516Z] info  code-server 4.10.0 ac1fba8bde0c3f29bf6bc27d3d7d75cb2390a7c2</span><br><span class="line">[2023-03-09T14:52:07.517Z] info  Using user-data-dir ~/.local/share/code-server</span><br><span class="line">[2023-03-09T14:52:07.532Z] info  Using config file ~/.config/code-server/config.yaml</span><br><span class="line">[2023-03-09T14:52:07.532Z] info  HTTP server listening on http://0.0.0.0:8888/</span><br><span class="line">[2023-03-09T14:52:07.532Z] info    - Authentication is enabled</span><br><span class="line">[2023-03-09T14:52:07.532Z] info      - Using password from $PASSWORD</span><br><span class="line">[2023-03-09T14:52:07.532Z] info    - Not serving HTTPS</span><br></pre></td></tr></table></figure><p>出现下面的页面，那就是安装成功了！输入你刚刚设置的密码，就可以像使用vscode一样使用code-server了！</p><p><img                       lazyload                     alt="image"                     data-src="https://img1.musnow.top/i/2023/03/6409f2f7b9a46.png"                      alt="image-20230309225342649"                ></p><h2 id="2-4-配置文件"><a href="#2-4-配置文件" class="headerlink" title="2.4 配置文件"></a>2.4 配置文件</h2><p>首次启动了之后，会在你的用户路径下生成一个<code>.config/code-server</code>文件夹，里面有一个<code>config.yaml</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ ls .config/code-server</span><br><span class="line">config.yaml</span><br></pre></td></tr></table></figure><p>打开这个文件，可以在里面配置code-server的密码，以及https访问。其余的配置项我还没有关注过，可以去看看github上的文档</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">bind-addr: 127.0.0.1:8080</span><br><span class="line">auth: password</span><br><span class="line">password: 64f1881b805917a449d80874</span><br><span class="line">cert: false</span><br></pre></td></tr></table></figure><p>默认的密码巨长，改成你自己的即可。在这里还可以修改默认绑定的ip和端口，后续启动code-server，就不需要手动指定了，直接运行即可</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./code-server</span><br></pre></td></tr></table></figure><h2 id="2-5-tmux后台运行"><a href="#2-5-tmux后台运行" class="headerlink" title="2.5 tmux后台运行"></a>2.5 tmux后台运行</h2><blockquote><p>nohup运行code-server有一点问题，所以要用tmux</p></blockquote><p>如果没有这个软件，先安装</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo yum install tmux</span><br></pre></td></tr></table></figure><p>创建一个新会话，你可以理解为这是一个脱离于bash的独立shell页面，即便当前bash退出了，code-server也不会退出</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tmux new -s vscode_online</span><br></pre></td></tr></table></figure><p>开启新会话后，进入vsc的bin目录，启动code-server，命令是不变的</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./code-server</span><br></pre></td></tr></table></figure><p><img                       lazyload                     alt="image"                     data-src="https://img1.musnow.top/i/2023/03/640a78b909107.png"                      alt="image-20230310082417260"                ></p><p>随后直接关掉当前bash，此时就已经实现了code-server的后台运行</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 接入会话</span></span><br><span class="line">tmux a -t vscode_online</span><br><span class="line"></span><br><span class="line"><span class="comment"># 结束会话</span></span><br><span class="line">tmux kill-session -t vscode_online</span><br></pre></td></tr></table></figure><h1 id="3-一些问题"><a href="#3-一些问题" class="headerlink" title="3.一些问题"></a>3.一些问题</h1><h2 id="3-1-nginx转发遇到1006错误"><a href="#3-1-nginx转发遇到1006错误" class="headerlink" title="3.1 nginx转发遇到1006错误"></a>3.1 nginx转发遇到1006错误</h2><p>我在采用nginx转发的时候，遇到了这个问题</p><p><img                       lazyload                     alt="image"                     data-src="https://img1.musnow.top/i/2023/03/6409e922986ac.png"                      alt="image-20230309221146320"                ></p><p>个人猜测，这大概率是因为我在<code>config.yaml</code>里面配置了<code>code-server</code>的https导致的</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">cert:</span> <span class="literal">false</span> <span class="comment"># 关闭https</span></span><br></pre></td></tr></table></figure><p>将cert修改回false，再次测试，发现还是有这个问题！</p><blockquote><p>实际上，如果你进行了nginx转发，并不需要配置code-server的https</p><p>保持默认的http即可</p></blockquote><hr><p>后来发现是我的nginx转发设置有问题，正确的转发配置如下</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">location</span> / &#123;</span><br><span class="line"><span class="attribute">proxy_pass</span>   http://127.0.0.1:8888;</span><br><span class="line"><span class="attribute">proxy_set_header</span> Host <span class="variable">$host</span>;</span><br><span class="line"><span class="attribute">proxy_set_header</span> Upgrade <span class="variable">$http_upgrade</span>;</span><br><span class="line"><span class="attribute">proxy_set_header</span> Connection upgrade;</span><br><span class="line"><span class="attribute">proxy_set_header</span> Accept-Encoding gzip;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面给出一个nginx的https的完整配置文件！</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">    <span class="attribute">listen</span> <span class="number">443</span> ssl;</span><br><span class="line">    <span class="attribute">server_name</span>  www.example.com;  <span class="comment"># 域名</span></span><br><span class="line">    <span class="comment"># 注意证书文件位置，是从/etc/nginx/下开始算起的</span></span><br><span class="line">    <span class="attribute">ssl_certificate</span> cert/example.com.crt; </span><br><span class="line">    <span class="attribute">ssl_certificate_key</span> cert/example.com.key;</span><br><span class="line">    <span class="attribute">ssl_session_timeout</span> <span class="number">5m</span>;</span><br><span class="line">    <span class="attribute">ssl_protocols</span> TLSv1 TLSv1.<span class="number">1</span> TLSv1.<span class="number">2</span>;</span><br><span class="line">    <span class="attribute">ssl_ciphers</span> ECDHE-RSA-AES128-GCM-SHA256:HIGH:!aNULL:!MD5:!RC4:!DHE;</span><br><span class="line">    <span class="attribute">ssl_prefer_server_ciphers</span> <span class="literal">on</span>;</span><br><span class="line"></span><br><span class="line">    <span class="attribute">client_max_body_size</span> <span class="number">1024m</span>;</span><br><span class="line"></span><br><span class="line">    <span class="section">location</span> / &#123;</span><br><span class="line">       <span class="attribute">proxy_set_header</span> Host <span class="variable">$host</span>;</span><br><span class="line">        <span class="attribute">proxy_set_header</span> Upgrade <span class="variable">$http_upgrade</span>;</span><br><span class="line">        <span class="attribute">proxy_set_header</span> Connection upgrade;</span><br><span class="line">        <span class="attribute">proxy_set_header</span> Accept-Encoding gzip;</span><br><span class="line">        <span class="comment"># 当下是直接用yum安装的nginx，可以直接用本地ip访问</span></span><br><span class="line">        <span class="comment"># 如果是docker安装的nginx，需要改为公网ip</span></span><br><span class="line">        <span class="attribute">proxy_pass</span> http://127.0.0.1:8888;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment"># 强制重定向http -&gt; https</span></span><br><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">    <span class="attribute">listen</span> <span class="number">80</span>; <span class="comment"># 监听80端口</span></span><br><span class="line">    <span class="attribute">server_name</span>  www.example.com;  <span class="comment"># 域名</span></span><br><span class="line">    <span class="comment">#把http的域名请求转成https</span></span><br><span class="line">    <span class="attribute">return</span> <span class="number">301</span> https://<span class="variable">$host</span><span class="variable">$request_uri</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-2-C-x2F-C-插件"><a href="#3-2-C-x2F-C-插件" class="headerlink" title="3.2 C&#x2F;C++插件"></a>3.2 C&#x2F;C++插件</h2><p>由于code-server是一个第三方项目，所以一些官方的插件（如pylance）直接在code-server的插件商店里面搜是没有的</p><p>我们需要去微软的vscode官网上下载插件的VSIX文件，使用本地文件的方式进行安装</p><blockquote><p><a class="link"   href="https://marketplace.visualstudio.com/VSCode" >https://marketplace.visualstudio.com/VSCode<i class="fas fa-external-link-alt"></i></a></p></blockquote><p><img                       lazyload                     alt="image"                     data-src="https://img1.musnow.top/i/2023/03/6409f4d54a065.png"                      alt="image-20230309230141057"                ></p><p>不过，pylance用这个办法依旧无法安装。看来有些插件只有官方的vsc才能安装</p><h2 id="3-3-本地文件"><a href="#3-3-本地文件" class="headerlink" title="3.3 本地文件"></a>3.3 本地文件</h2><p>如果你用过vscode的<code>remote-ssh</code>插件连过你这个服务器，用户目录下面会有两个文件夹</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">.vsc</span><br><span class="line">.vscode-server</span><br></pre></td></tr></table></figure><p>这两个文件夹是vscode的插件<code>remote-ssh</code>生成的，和本文安装的code-server无关！</p><h2 id="3-4-tmux常用语句"><a href="#3-4-tmux常用语句" class="headerlink" title="3.4 tmux常用语句"></a>3.4 tmux常用语句</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">tmux new　　创建默认名称的会话（在tmux命令模式使用new命令可实现同样的功能，其他命令同理，后文不再列出tmux终端命令）</span><br><span class="line"></span><br><span class="line">tmux new -s mysession　　创建名为mysession的会话</span><br><span class="line"></span><br><span class="line">tmux ls　　显示会话列表</span><br><span class="line"></span><br><span class="line">tmux a　　连接上一个会话</span><br><span class="line"></span><br><span class="line">tmux a -t mysession　　连接指定会话mysession</span><br><span class="line"></span><br><span class="line">tmux rename -t s1 s2　　重命名会话s1为s2</span><br><span class="line"></span><br><span class="line">tmux kill-session　　关闭上次打开的会话</span><br><span class="line"></span><br><span class="line">tmux kill-session -t s1　关闭会话s1</span><br><span class="line"></span><br><span class="line">tmux kill-session -a -t s1　　关闭除s1外的所有会话</span><br><span class="line"></span><br><span class="line">tmux kill-server　　关闭所有会话</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;部署code-server远程vscode网页，在浏览器上写代码！&lt;/p&gt;</summary>
    
    
    
    <category term="差生文具多" scheme="https://blog.musnow.top/categories/%E5%B7%AE%E7%94%9F%E6%96%87%E5%85%B7%E5%A4%9A/"/>
    
    
    <category term="Linux" scheme="https://blog.musnow.top/tags/Linux/"/>
    
    <category term="vscode" scheme="https://blog.musnow.top/tags/vscode/"/>
    
    <category term="CentOS" scheme="https://blog.musnow.top/tags/CentOS/"/>
    
  </entry>
  
  <entry>
    <title>【Docker】限制已运行容器的Cpu和内存</title>
    <link href="https://blog.musnow.top/2023/03/06/docker/9docker%E9%99%90%E5%88%B6%E5%AE%B9%E5%99%A8Cpu%E5%86%85%E5%AD%98/"/>
    <id>https://blog.musnow.top/2023/03/06/docker/9docker%E9%99%90%E5%88%B6%E5%AE%B9%E5%99%A8Cpu%E5%86%85%E5%AD%98/</id>
    <published>2023-03-06T09:45:33.000Z</published>
    <updated>2023-03-11T11:25:36.258Z</updated>
    
    <content type="html"><![CDATA[<p>docker限制已运行容器的Cpu和内存</p><span id="more"></span><h2 id="1-问题描述"><a href="#1-问题描述" class="headerlink" title="1.问题描述"></a>1.问题描述</h2><p>最近云服务器的内存经常不够用，而且是<strong>莫名其妙</strong>的增多，在腾讯云的控制台里面看，4g的内存占用了3.2g，就卡到连ssh都连不上了</p><blockquote><p>PS: 已换过网络和设备，确认不是网络问题导致无法ssh</p></blockquote><p><img                       lazyload                     alt="image"                     data-src="https://img1.musnow.top/i/2023/03/6405c2f8c3a35.png"                      alt="img"                ></p><p>实在没辙了，只能把我的几个不热门的kook-bot移植到replit白嫖，再限制一下lsky图床docker镜像的内存用量</p><blockquote><p>其实主要是<code>nsfw-api</code>的内存用量，我发现有人故意给我的图床上传h图。lsky后台由于鉴黄不通过，不允许上传，也看不到是谁干的。隔这压力测试呢？</p><p>我的图床基本只对自己的博客使用。开放游客上传，也只是方便大家临时上传一些图片，还请大家手下留情！！！😥</p></blockquote><p>这个操作我做了几次，也算是一个高频操作了。在此记录一下如何更改一个正在运行中容器的内存限制</p><h2 id="2-修改内存限制"><a href="#2-修改内存限制" class="headerlink" title="2.修改内存限制"></a>2.修改内存限制</h2><p>先使用ps命令查看当前容器和对应的id</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker ps</span><br></pre></td></tr></table></figure><p>可以看到，lsky图床和nsfw的镜像分别是第二个和第三个</p><p><img                       lazyload                     alt="image"                     data-src="https://img1.musnow.top/i/2023/03/6405c3777d10c.png"                      alt="image-20230306184202020"                ></p><p>再用stats命令查看当前的状态</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker stats</span><br></pre></td></tr></table></figure><p><img                       lazyload                     alt="image"                     data-src="https://img1.musnow.top/i/2023/03/6405c43bed272.png"                      alt="image-20230306184518474"                ></p><p>可以看到，图床的内存没有进行限制，nsfw的内存已经被限制到了618mb，当前已用565mb，基本要满了</p><p>重启一下容器，发现初始化的时候只需要100mb左右的内存，合计着现在就有人在往图床里面上传图片？🤣🤣🤣</p><p><img                       lazyload                     alt="image"                     data-src="https://img1.musnow.top/i/2023/03/6405c412e1f22.png"                      alt="image-20230306184437446"                ></p><p>这怎么行，直接给它内存限制干到512mb，能省一点内存是一点，不能因为图床导致我服务器卡死。</p><p>修改限制，要使用的是<code>container update</code>命令</p><blockquote><p><a class="link"   href="https://www.yiibai.com/docker/container_update.html#:~:text=docker%20container,update%20%E5%91%BD%E4%BB%A4%E7%94%A8%E4%BA%8E%E6%9B%B4%E6%96%B0%E4%B8%80%E4%B8%AA%E6%88%96%E5%A4%9A%E4%B8%AA%E5%AE%B9%E5%99%A8%E7%9A%84%E9%85%8D%E7%BD%AE%E3%80%82" >参考文档<i class="fas fa-external-link-alt"></i></a></p><table><thead><tr><th>名称,简写</th><th>默认值</th><th>描述</th></tr></thead><tbody><tr><td>–blkio-weight</td><td>0</td><td>阻塞IO(相对权重)，介于<code>10</code>和<code>1000</code>之间，或<code>0</code>禁用(默认为<code>0</code>)</td></tr><tr><td>–cpu-period</td><td>0</td><td>限制CPU CFS(完全公平的调度程序)周期</td></tr><tr><td>–cpu-quota</td><td>0</td><td>限制CPU CFS(完全公平的调度程序)配额</td></tr><tr><td>–cpu-rt-period</td><td>0</td><td>限制CPU实时周期(以微秒为单位)</td></tr><tr><td>–cpu-rt-runtime</td><td>0</td><td>以微秒为单位限制CPU实时运行时间</td></tr><tr><td>–cpu-shares, -c</td><td>0</td><td>CPU份额(相对权重)</td></tr><tr><td>–cpuset-cpus</td><td></td><td>允许执行的CPU(0-3,0)</td></tr><tr><td>–cpuset-mems</td><td></td><td>允许执行的内存率(0-3,0.1)</td></tr><tr><td>–kernel-memory</td><td></td><td>内核内存限制</td></tr><tr><td>–memory, -m</td><td></td><td>内存限制</td></tr><tr><td>–memory-reservation</td><td></td><td>内存软限制</td></tr><tr><td>–memory-swap</td><td></td><td>交换限制等于内存加交换：<code>-1</code>以启用无限制的交换</td></tr><tr><td>–restart</td><td></td><td>重新启动在容器退出时应用的策略</td></tr><tr><td>模板如下</td><td></td><td></td></tr></tbody></table></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker container update 容器名 --memory=&quot;2g&quot;  --memory-swap=&quot;-1&quot;</span><br></pre></td></tr></table></figure><p>上面的命令会限制容器的内存为2gb，交换内存设置为<code>-1</code>（以启用无限制的交换）</p><p>比如我现在想修改nsfw容器的内存限制，应该如下操作</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker container update nsfw-api --memory=&quot;0.5g&quot; </span><br></pre></td></tr></table></figure><p>然后发现报错了</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Error response from daemon: Cannot update container 418fc2a79fa7ad2e637babe17424ee60e9027ef4a7fada3f279864e76bdaaa10: Memory limit should be smaller than already set memoryswap limit, update the memoryswap at the same time</span><br></pre></td></tr></table></figure><p>大概意思是让我们同时更新交换内存</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker container update nsfw-api --memory=&quot;0.5g&quot;  --memory-swap=&quot;-1&quot;</span><br></pre></td></tr></table></figure><p>现在就ok了，执行成功会显示镜像的名字</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nsfw-api</span><br></pre></td></tr></table></figure><p>在<code>stats</code>看一下，发现已经修改成功了</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker stats</span><br></pre></td></tr></table></figure><p><img                       lazyload                     alt="image"                     data-src="https://img1.musnow.top/i/2023/03/6405c73f35462.png"                      alt="image-20230306185809744"                ></p><p>修改其他容器的效果也是一样的，目的已经达到啦！</p><h2 id="3-修改cpu限制"><a href="#3-修改cpu限制" class="headerlink" title="3.修改cpu限制"></a>3.修改cpu限制</h2><p>下面的命令意思是限制容器只能使用主机上两个cpu</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker container update  容器名 --cpus=2</span><br></pre></td></tr></table></figure><p>但我没有理解这个<code>两个cpu</code>是什么含义。考虑到大部分时期，cpu负载都不会很大，暂时先不设置这个了</p><blockquote><p><a class="link"   href="https://www.cnblogs.com/sparkdev/p/8052522.html" >https://www.cnblogs.com/sparkdev/p/8052522.html<i class="fas fa-external-link-alt"></i></a></p><p><a class="link"   href="https://zhuanlan.zhihu.com/p/388012843" >https://zhuanlan.zhihu.com/p/388012843<i class="fas fa-external-link-alt"></i></a></p></blockquote>]]></content>
    
    
    <summary type="html">&lt;p&gt;docker限制已运行容器的Cpu和内存&lt;/p&gt;</summary>
    
    
    
    <category term="docker真好玩" scheme="https://blog.musnow.top/categories/docker%E7%9C%9F%E5%A5%BD%E7%8E%A9/"/>
    
    
    <category term="Docker" scheme="https://blog.musnow.top/tags/Docker/"/>
    
  </entry>
  
  <entry>
    <title>【Linux】修改linux下的时区和系统时间</title>
    <link href="https://blog.musnow.top/2023/03/04/Linux/36linux%E4%BF%AE%E6%94%B9%E6%97%B6%E5%8C%BA/"/>
    <id>https://blog.musnow.top/2023/03/04/Linux/36linux%E4%BF%AE%E6%94%B9%E6%97%B6%E5%8C%BA/</id>
    <published>2023-03-04T01:30:55.000Z</published>
    <updated>2023-03-17T05:42:06.000Z</updated>
    
    <content type="html"><![CDATA[<p>用配置文件，修改linux系统下的时区（所用系统 CentOS8）</p><span id="more"></span><h2 id="1-问题来源"><a href="#1-问题来源" class="headerlink" title="1.问题来源"></a>1.问题来源</h2><p>在linux上使用python的logging模块的时候，发现了一个问题，那就是模块里面的<code>%(asctime)s</code>打印的时间并非东八区的时间，而是格林尼治时间，比东八区的时间少了8小时</p><p>对于日志来说，这怎么行？总不能每次看日志的时候，自己手动给时间加8小时吧！</p><h2 id="2-解决"><a href="#2-解决" class="headerlink" title="2.解决"></a>2.解决</h2><p>百度了一下后，发现是我系统的时区问题。这个Centos系统是用docker安装的，内部的时区没有正常设置</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">date</span><br></pre></td></tr></table></figure><p>通过date命令可以查看系统当前的时间</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Sat Mar  4 01:29:59 UTC 2023</span><br></pre></td></tr></table></figure><p>会发现是3月4日的凌晨1点，但实际上我是在上午9点写下的这篇博客</p><p><img                       lazyload                     alt="image"                     data-src="https://img1.musnow.top/i/2023/03/6402a0423fa7b.png"                      alt="image-20230304093451196"                ></p><p>这就需要我们修改时区了！</p><hr><p>刚开始，我尝试用<code>tzselect</code>命令进行时区的选择，再选择了上海时区后，系统的时间还是有问题。然后发现，需要修改文件配置，才能让时间生效</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">/etc/timezone <span class="comment"># 时区的配置</span></span><br><span class="line">/etc/localtime <span class="comment"># 时间</span></span><br><span class="line">/usr/share/zoneinfo/Asia <span class="comment">#这里边放着亚洲主要城市的时间</span></span><br></pre></td></tr></table></figure><p>而我的系统中，第一个文件压根不存在！</p><p>要用下面的两个命令来修改配置文件（root下执行）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo &quot;Asia/Shanghai&quot; &gt; /etc/timezone</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">rm -rf /etc/localtime</span><br><span class="line">ln -s /usr/share/zoneinfo/Asia/Shanghai /etc/localtime</span><br></pre></td></tr></table></figure><p>修改完毕，再次执行<code>date</code>命令，可以看到时间已经正常了</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Sat Mar  4 09:31:33 CST 2023</span><br></pre></td></tr></table></figure><p>python的logging模块中打印的时间也正常了</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[23-03-04 09:31:39] DEBUG:log.py:debug:9 | test in main</span><br><span class="line">[23-03-04 09:31:39] ERROR:log.py:exception:24 | Exception occurred</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File &quot;/home/kook/code/py-test/log.py&quot;, line 32, in test</span><br><span class="line">    a = 10/0</span><br><span class="line">ZeroDivisionError: division by zero</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;用配置文件，修改linux系统下的时区（所用系统 CentOS8）&lt;/p&gt;</summary>
    
    
    
    <category term="玩上Linux" scheme="https://blog.musnow.top/categories/%E7%8E%A9%E4%B8%8ALinux/"/>
    
    
    <category term="Linux" scheme="https://blog.musnow.top/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>【Python】解决SSL certificate problem unable to get local issuer certificate</title>
    <link href="https://blog.musnow.top/2023/02/24/Python/10ssl%E6%8A%A5%E9%94%99%E8%AF%81%E4%B9%A6%E9%94%99%E8%AF%AF%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95/"/>
    <id>https://blog.musnow.top/2023/02/24/Python/10ssl%E6%8A%A5%E9%94%99%E8%AF%81%E4%B9%A6%E9%94%99%E8%AF%AF%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95/</id>
    <published>2023-02-24T01:19:00.000Z</published>
    <updated>2023-03-12T04:31:19.924Z</updated>
    
    <content type="html"><![CDATA[<p>CentOS8 出现 SSL certificate problem: unable to get local issuer certificate 解决办法</p><span id="more"></span><h1 id="1-错误来源"><a href="#1-错误来源" class="headerlink" title="1.错误来源"></a>1.错误来源</h1><p>我在一个docker安装的<code>Centos8.5</code>系统中启动我自己写的kook机器人时，遇到了下面的bug</p><p><img                       lazyload                     alt="image"                     data-src="https://img1.musnow.top/i/2023/02/63f80f61bd112.png"                      alt="原图"                ></p><p>其大概意思是没有办法获取到本地的<code>issuer certificate</code>。如果你知道证书和CA的含义，那么大概能猜到这个报错是什么意思。</p><blockquote><p>所有站点的ssl证书，都需要经过CA机构的认证和颁发。操作系统会默认<strong>内嵌</strong>已有CA机构的公钥，以用于解密CA颁发的证书中的数字签名。</p></blockquote><p>因为CA机构是内嵌在操作系统本地的，如果一个证书的颁发机构不在本地已有CA中，该站点就会被报不安全。</p><p>而无法获取本地<code>issuer certificate</code>，我猜测意思就是没有办法获取道操作系统内嵌的CA</p><h1 id="2-解决"><a href="#2-解决" class="headerlink" title="2.解决"></a>2.解决</h1><p>刚开始我尝试过通过python的ssl模组取消证书验证、更新本地证书和openssl，都没有解决这个问题。</p><p>在Kook平台<code>khl.py</code>服务器的大佬帮助下，最终定位并解决了这个问题。</p><h2 id="2-1-更新本地ca包"><a href="#2-1-更新本地ca包" class="headerlink" title="2.1 更新本地ca包"></a>2.1 更新本地ca包</h2><p>先 <code>yum install ca-certificates</code>，已经装过的话那就是 <code>yum update ca-certificates</code> 如果不行再 <code>pip3 install certifi</code></p><p>操作完毕上面的步骤，发现本地已经安装了最新版本的<code>ca-certificates</code>，python也有安装<code>certifi</code>包</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">$ yum update ca-certificates</span><br><span class="line">Repository extras is listed more than once in the configuration</span><br><span class="line">Warning: failed loading &#x27;/etc/yum.repos.d/epel.repo&#x27;, skipping.</span><br><span class="line">Last metadata expiration check: 8:42:37 ago on Thu 23 Feb 2023 03:09:14 PM UTC.</span><br><span class="line">Dependencies resolved.</span><br><span class="line">Nothing to do.</span><br><span class="line">Complete!</span><br><span class="line"></span><br><span class="line">$ pip3.10 install  certifi</span><br><span class="line">Defaulting to user installation because normal site-packages is not writeable</span><br><span class="line">Requirement already satisfied: certifi in ./.local/lib/python3.10/site-packages (2022.12.7)</span><br><span class="line"></span><br><span class="line">$ pip3.10 install  certifi -U</span><br><span class="line">Defaulting to user installation because normal site-packages is not writeable</span><br><span class="line">Requirement already satisfied: certifi in ./.local/lib/python3.10/site-packages (2022.12.7)</span><br></pre></td></tr></table></figure><h2 id="2-2-查看本地主机的链接"><a href="#2-2-查看本地主机的链接" class="headerlink" title="2.2 查看本地主机的链接"></a>2.2 查看本地主机的链接</h2><p>于是尝试使用如下命令，看看主机是否能成功连接到<code>kaiheila.cn</code>(kookapp.cn) 并认证ssl证书</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">openssl s_client -connect www.kookapp.cn:443 -showcerts</span><br></pre></td></tr></table></figure><p>输出了如下的信息</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br></pre></td><td class="code"><pre><span class="line">depth=2 C = US, O = DigiCert Inc, OU = www.digicert.com, CN = DigiCert Global Root CA</span><br><span class="line">verify return:1</span><br><span class="line">depth=1 C = US, O = &quot;DigiCert, Inc.&quot;, CN = RapidSSL Global TLS RSA4096 SHA256 2022 CA1</span><br><span class="line">verify return:1</span><br><span class="line">depth=0 CN = *.kookapp.cn</span><br><span class="line">verify return:1</span><br><span class="line">CONNECTED(00000003)</span><br><span class="line">---</span><br><span class="line">Certificate chain</span><br><span class="line"> 0 s:CN = *.kookapp.cn</span><br><span class="line">   i:C = US, O = &quot;DigiCert, Inc.&quot;, CN = RapidSSL Global TLS RSA4096 SHA256 2022 CA1</span><br><span class="line">-----BEGIN CERTIFICATE-----</span><br><span class="line">MIIHkTCCBXmgAwIBAgIQCUlurlf6m1VXsuISNqlT8DANBgkqhkiG9w0BAQsFADBc</span><br><span class="line">MQswCQYDVQQGEwJVUzEXMBUGA1UEChMORGlnaUNlcnQsIEluYy4xNDAyBgNVBAMT</span><br><span class="line">K1JhcGlkU1NMIEdsb2JhbCBUTFMgUlNBNDA5NiBTSEEyNTYgMjAyMiBDQTEwHhcN</span><br><span class="line">MjIwNjE1MDAwMDAwWhcNMjMwNjE1MjM1OTU5WjAXMRUwEwYDVQQDDAwqLmtvb2th</span><br><span class="line">cHAuY24wggEiMA0GCSqGSIb3DQEBAQUAA4IBDwAwggEKAoIBAQDB1uHkQ/oEkGNl</span><br><span class="line">oVa6wHz424VznxL+eUt6AAfNhtIXeone8rtnJqeoDJ24lmBYUrL00tChCp4rdTdd</span><br><span class="line">crqPppDYSEY7+/U0hf39pDrmsGKZeeOu7JvANjtvqLFdXsqe5CnXtxAo5QUXB9gc</span><br><span class="line">kttoLTZZX5O1Gyi6mqDtsFCTaVpsQmZWVcbA21zLAdAZJyUyzM2VyfCUPQHs+VFE</span><br><span class="line">rcmA9SN8nkppLyf00lIHCWR6v9HYC2XgjHN2JX8ARJwTEddhHjvleMc/SlHncU6f</span><br><span class="line">pZ8itWx8NzBL6MwPKEjmHgKp0VYBMY6PHrSR/j/XtgOweodp1JBIr6yLLlyCu/lJ</span><br><span class="line">ksCwMUIZAgMBAAGjggOSMIIDjjAfBgNVHSMEGDAWgBTwnIX9op99j8lou9XUiU0d</span><br><span class="line">vtOQ/zAdBgNVHQ4EFgQUYe6lb4/s4J82aqWfNDaev2MD8k4wIwYDVR0RBBwwGoIM</span><br><span class="line">Ki5rb29rYXBwLmNuggprb29rYXBwLmNuMA4GA1UdDwEB/wQEAwIFoDAdBgNVHSUE</span><br><span class="line">FjAUBggrBgEFBQcDAQYIKwYBBQUHAwIwgZ8GA1UdHwSBlzCBlDBIoEagRIZCaHR0</span><br><span class="line">cDovL2NybDMuZGlnaWNlcnQuY29tL1JhcGlkU1NMR2xvYmFsVExTUlNBNDA5NlNI</span><br><span class="line">QTI1NjIwMjJDQTEuY3JsMEigRqBEhkJodHRwOi8vY3JsNC5kaWdpY2VydC5jb20v</span><br><span class="line">UmFwaWRTU0xHbG9iYWxUTFNSU0E0MDk2U0hBMjU2MjAyMkNBMS5jcmwwPgYDVR0g</span><br><span class="line">BDcwNTAzBgZngQwBAgEwKTAnBggrBgEFBQcCARYbaHR0cDovL3d3dy5kaWdpY2Vy</span><br><span class="line">dC5jb20vQ1BTMIGHBggrBgEFBQcBAQR7MHkwJAYIKwYBBQUHMAGGGGh0dHA6Ly9v</span><br><span class="line">Y3NwLmRpZ2ljZXJ0LmNvbTBRBggrBgEFBQcwAoZFaHR0cDovL2NhY2VydHMuZGln</span><br><span class="line">aWNlcnQuY29tL1JhcGlkU1NMR2xvYmFsVExTUlNBNDA5NlNIQTI1NjIwMjJDQTEu</span><br><span class="line">Y3J0MAkGA1UdEwQCMAAwggF/BgorBgEEAdZ5AgQCBIIBbwSCAWsBaQB3AOg+0No+</span><br><span class="line">9QY1MudXKLyJa8kD08vREWvs62nhd31tBr1uAAABgWbUskcAAAQDAEgwRgIhAL1q</span><br><span class="line">ZKig2NqYtlAVnaXtJ7Tk+OuROrPHGR8t2zyNTb6xAiEAsLL5yuvJ/WtIj0bLwbKR</span><br><span class="line">0/nFe/Juub3aZjrNvUhzZIIAdQA1zxkbv7FsV78PrUxtQsu7ticgJlHqP+Eq76gD</span><br><span class="line">wzvWTAAAAYFm1LJ6AAAEAwBGMEQCIDK3qkxuTUB1Dngycy9/LECyVXjlpi2eJBAC</span><br><span class="line">6oZPJQ/VAiBs1iupiYwavmD2m6QrDzzZrW2MJWx4LMxCtvf6pmN3NwB3ALc++yTf</span><br><span class="line">nE26dfI5xbpY9Gxd/ELPep81xJ4dCYEl7bSZAAABgWbUsnkAAAQDAEgwRgIhAL5v</span><br><span class="line">fkeeQAwowpkUhf0U/Z2fFiL8IY+QsCyED40zw0d1AiEA02UjHM3tztsrMn2xyzmT</span><br><span class="line">kVgXnly/OozP+LjdwdsTa6gwDQYJKoZIhvcNAQELBQADggIBAGdBom7y2NXOZL7K</span><br><span class="line">xtZFBFQCBJrEQOHZvuN4Etkmotb+0aVnrEZ/Qc5+zl86YqURcmOZgPhzSjuVfTvU</span><br><span class="line">sJJ1TkC/tMYofoo1Db7B5yRxQmjEYRNLFAZ8rbP/pd5Js8ZGWW7RcxqG+zebqDDD</span><br><span class="line">2CWvpiJNStu/yjWwdsFXQUwU0XOGUfwJDHD0eSBaa3uclAn3kUqF82l2X9qzvy9E</span><br><span class="line">exGjPOSWyNuksjeScr32OyNUrwo7RUYJU4Ztl8xaiaxcvg7u2/o9WWzPhHMVI6ij</span><br><span class="line">rJbj6Wn+BMe3SMYcR/L+foItjWAuOqOVB7IKO32JgCkP1vyl8AWs0up8ddI/9jn3</span><br><span class="line">px8ii0HphKJnkCPZNmLnnOhFXQjoPy2PRmKqusP0kleJw1ZpQXsQpm3yZqFggyFH</span><br><span class="line">8S4ii83kkHBynC89dlwlBIkF29Ds4mYjau6mZZxE69By7ptvFvcYREYslaRMxd16</span><br><span class="line">6PEf5mp5jBKSiI2iYcP8PQOudhObpkuw+KHz8ntkf++HeluuEiqsKyiyyiXm5dmR</span><br><span class="line">E/9uIUjPcQia5ohs2VpAgOLhLG6yphWCHQ6awFj9q3Ce1Mm5yXyZFvLXWGwoJj6j</span><br><span class="line">CVXAZDchwX4uiHW2fI3GHz1pTPg0L3NE/M2CHnQWJlh9cgOljmaZXCeKmLdA9phD</span><br><span class="line">+NQho5xVElRiF+rijlrkMutS7p1Y</span><br><span class="line">-----END CERTIFICATE-----</span><br><span class="line"> 1 s:C = US, O = &quot;DigiCert, Inc.&quot;, CN = RapidSSL Global TLS RSA4096 SHA256 2022 CA1</span><br><span class="line">   i:C = US, O = DigiCert Inc, OU = www.digicert.com, CN = DigiCert Global Root CA</span><br><span class="line">-----BEGIN CERTIFICATE-----</span><br><span class="line">MIIFyzCCBLOgAwIBAgIQCgWbJfVLPYeUzGYxR3U4ozANBgkqhkiG9w0BAQsFADBh</span><br><span class="line">MQswCQYDVQQGEwJVUzEVMBMGA1UEChMMRGlnaUNlcnQgSW5jMRkwFwYDVQQLExB3</span><br><span class="line">d3cuZGlnaWNlcnQuY29tMSAwHgYDVQQDExdEaWdpQ2VydCBHbG9iYWwgUm9vdCBD</span><br><span class="line">QTAeFw0yMjA1MDQwMDAwMDBaFw0zMTExMDkyMzU5NTlaMFwxCzAJBgNVBAYTAlVT</span><br><span class="line">MRcwFQYDVQQKEw5EaWdpQ2VydCwgSW5jLjE0MDIGA1UEAxMrUmFwaWRTU0wgR2xv</span><br><span class="line">YmFsIFRMUyBSU0E0MDk2IFNIQTI1NiAyMDIyIENBMTCCAiIwDQYJKoZIhvcNAQEB</span><br><span class="line">BQADggIPADCCAgoCggIBAKY5PJhwCX2UyBb1nelu9APen53D5+C40T+BOZfSFaB0</span><br><span class="line">v0WJM3BGMsuiHZX2IHtwnjUhLL25d8tgLASaUNHCBNKKUlUGRXGztuDIeXb48d64</span><br><span class="line">k7Gk7u7mMRSrj+yuLSWOKnK6OGKe9+s6oaVIjHXY+QX8p2I2S3uew0bW3BFpkeAr</span><br><span class="line">LBCU25iqeaoLEOGIa09DVojd3qc/RKqr4P11173R+7Ub05YYhuIcSv8e0d7qN1sO</span><br><span class="line">1+lfoNMVfV9WcqPABmOasNJ+ol0hAC2PTgRLy/VZo1L0HRMr6j8cbR7q0nKwdbn4</span><br><span class="line">Ar+ZMgCgCcG9zCMFsuXYl/rqobiyV+8U37dDScAebZTIF/xPEvHcmGi3xxH6g+dT</span><br><span class="line">CjetOjJx8sdXUHKXGXC9ka33q7EzQIYlZISF7EkbT5dZHsO2DOMVLBdP1N1oUp0/</span><br><span class="line">1f6fc8uTDduELoKBRzTTZ6OOBVHeZyFZMMdi6tA5s/jxmb74lqH1+jQ6nTU2/Mma</span><br><span class="line">hGNxUuJpyhUHezgBA6sto5lNeyqc+3Cr5ehFQzUuwNsJaWbDdQk1v7lqRaqOlYjn</span><br><span class="line">iomOl36J5txTs0wL7etCeMRfyPsmc+8HmH77IYVMUOcPJb+0gNuSmAkvf5QXbgPI</span><br><span class="line">Zursn/UYnP9obhNbHc/9LYdQkB7CXyX9mPexnDNO7pggNA2jpbEarLmZGi4grMmf</span><br><span class="line">AgMBAAGjggGCMIIBfjASBgNVHRMBAf8ECDAGAQH/AgEAMB0GA1UdDgQWBBTwnIX9</span><br><span class="line">op99j8lou9XUiU0dvtOQ/zAfBgNVHSMEGDAWgBQD3lA1VtFMu2bwo+IbG8OXsj3R</span><br><span class="line">VTAOBgNVHQ8BAf8EBAMCAYYwHQYDVR0lBBYwFAYIKwYBBQUHAwEGCCsGAQUFBwMC</span><br><span class="line">MHYGCCsGAQUFBwEBBGowaDAkBggrBgEFBQcwAYYYaHR0cDovL29jc3AuZGlnaWNl</span><br><span class="line">cnQuY29tMEAGCCsGAQUFBzAChjRodHRwOi8vY2FjZXJ0cy5kaWdpY2VydC5jb20v</span><br><span class="line">RGlnaUNlcnRHbG9iYWxSb290Q0EuY3J0MEIGA1UdHwQ7MDkwN6A1oDOGMWh0dHA6</span><br><span class="line">Ly9jcmwzLmRpZ2ljZXJ0LmNvbS9EaWdpQ2VydEdsb2JhbFJvb3RDQS5jcmwwPQYD</span><br><span class="line">VR0gBDYwNDALBglghkgBhv1sAgEwBwYFZ4EMAQEwCAYGZ4EMAQIBMAgGBmeBDAEC</span><br><span class="line">AjAIBgZngQwBAgMwDQYJKoZIhvcNAQELBQADggEBAAfjh/s1f5dDdfm0sNm74/dW</span><br><span class="line">MbbsxfYV1LoTpFt+3MSUWvSbiPQfUkoV57b5rutRJvnPP9mSlpFwcZ3e1nSUbi2o</span><br><span class="line">ITGA7RCOj23I1F4zk0YJm42qAwJIqOVenR3XtyQ2VR82qhC6xslxtNf7f2Ndx2G7</span><br><span class="line">Mem4wpFhyPDT2P6UJ2MnrD+FC//ZKH5/ERo96ghz8VqNlmL5RXo8Ks9rMr/Ad9xw</span><br><span class="line">Y4hyRvAz5920myUffwdUqc0SvPlFnahsZg15uT5HkK48tHR0TLuLH8aRpzh4KJ/Y</span><br><span class="line">p0sARNb+9i1R4Fg5zPNvHs2BbIve0vkwxAy+R4727qYzl3027w9jEFC6HMXRaDc=</span><br><span class="line">-----END CERTIFICATE-----</span><br><span class="line">---</span><br><span class="line">Server certificate</span><br><span class="line">subject=CN = *.kookapp.cn</span><br><span class="line"></span><br><span class="line">issuer=C = US, O = &quot;DigiCert, Inc.&quot;, CN = RapidSSL Global TLS RSA4096 SHA256 2022 CA1</span><br><span class="line"></span><br><span class="line">---</span><br><span class="line">No client certificate CA names sent</span><br><span class="line">Peer signing digest: SHA256</span><br><span class="line">Peer signature type: RSA-PSS</span><br><span class="line">Server Temp Key: X25519, 253 bits</span><br><span class="line">---</span><br><span class="line">SSL handshake has read 3993 bytes and written 392 bytes</span><br><span class="line">Verification: OK</span><br><span class="line">---</span><br><span class="line">New, TLSv1.3, Cipher is TLS_AES_256_GCM_SHA384</span><br><span class="line">Server public key is 2048 bit</span><br><span class="line">Secure Renegotiation IS NOT supported</span><br><span class="line">Compression: NONE</span><br><span class="line">Expansion: NONE</span><br><span class="line">No ALPN negotiated</span><br><span class="line">Early data was not sent</span><br><span class="line">Verify return code: 0 (ok)</span><br><span class="line">---</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>在这里面能看到如下内容</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SSL handshake has read 3993 bytes and written 392 bytes</span><br><span class="line">Verification: OK</span><br></pre></td></tr></table></figure><p>也就是说，我们的本地主机是能成功认证<code>kookapp.cn</code>的ssl证书的，那么问题就出现在python的ssl模块中了！</p><h2 id="2-3-检测python的ssl模块"><a href="#2-3-检测python的ssl模块" class="headerlink" title="2.3 检测python的ssl模块"></a>2.3 检测python的ssl模块</h2><p>python开启一个REPL，输入如下的两行代码</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> ssl</span><br><span class="line">ssl.create_default_context().cert_store_stats()</span><br></pre></td></tr></table></figure><p>输出的内容如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; import ssl</span><br><span class="line">&gt;&gt;&gt; ssl.create_default_context().cert_store_stats()</span><br><span class="line">&#123;&#x27;x509&#x27;: 0, &#x27;crl&#x27;: 0, &#x27;x509_ca&#x27;: 0&#125;</span><br></pre></td></tr></table></figure><p>这里就能看出来问题了，全都是0！难怪说没有办法获取本地的CA</p><p>作为对比，一台<strong>正常的</strong>windows11电脑输出如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; import ssl</span><br><span class="line">&gt;&gt;&gt; ssl.create_default_context().cert_store_stats()</span><br><span class="line">&#123;&#x27;x509&#x27;: 87, &#x27;crl&#x27;: 0, &#x27;x509_ca&#x27;: 84&#125;</span><br></pre></td></tr></table></figure><h2 id="2-4-解决错误"><a href="#2-4-解决错误" class="headerlink" title="2.4 解决错误"></a>2.4 解决错误</h2><p>找到了错误，那就得想办法解决！</p><p>python开启一个REPL，输入如下的两行代码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">import ssl</span><br><span class="line">ssl.get_default_verify_paths()</span><br></pre></td></tr></table></figure><p>输出内容如下，这是本地python查找ca证书的位置</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; import ssl</span><br><span class="line">&gt;&gt;&gt; ssl.get_default_verify_paths()</span><br><span class="line">DefaultVerifyPaths(cafile=None, capath=&#x27;/usr/local/openssl-1.1.1/ssl/certs&#x27;, openssl_cafile_env=&#x27;SSL_CERT_FILE&#x27;, openssl_cafile=&#x27;/usr/local/openssl-1.1.1/ssl/cert.pem&#x27;, openssl_capath_env=&#x27;SSL_CERT_DIR&#x27;, openssl_capath=&#x27;/usr/local/openssl-1.1.1/ssl/certs&#x27;)</span><br></pre></td></tr></table></figure><p>其中<code>/usr/local/openssl-1.1.1/ssl/cert.pem</code>中应该会保存CA的信息</p><p>查看本地的这个文件的内容</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ls /usr/local/openssl-1.1.1/ssl/cert.pem</span><br></pre></td></tr></table></figure><p>好家伙，发现文件压根不存在！</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ls: cannot access &#x27;/usr/local/openssl-1.1.1/ssl/cert.pem&#x27;: No such file or directory</span><br></pre></td></tr></table></figure><p>看看openssl的版本和路径</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">openssl  version -d</span><br></pre></td></tr></table></figure><p>输出如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">OPENSSLDIR: &quot;/etc/pki/tls&quot;</span><br></pre></td></tr></table></figure><p>于是看看这个目录下有没有我们需要的<code>cert.pem</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ ls /etc/pki/tls</span><br><span class="line">cert.pem  certs  ct_log_list.cnf  misc  openssl.cnf  private</span><br></pre></td></tr></table></figure><p>有！那么接下来要做的，就是创建一个软连接，将其弄到&#x2F;usr&#x2F;local中！</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ln -s /etc/pki/tls/cert.pem /usr/local/openssl-1.1.1/ssl/cert.pem</span><br></pre></td></tr></table></figure><h1 id="3-完美！"><a href="#3-完美！" class="headerlink" title="3.完美！"></a>3.完美！</h1><p>做完这一切后，再次运行机器人，这次么有报错了！</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ py3 main.py</span><br><span class="line">[FileManage] load all files</span><br><span class="line">[BOT] Start at: [23-02-24 00:25:29]</span><br><span class="line">[BOT.TASK] fetch_public_channel success</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>也成功响应了命令！</p><p><img                       lazyload                     alt="image"                     data-src="https://img1.musnow.top/i/2023/02/63f812d3abf94.png"                      alt="image-20230224092852118"                ></p><p>似乎这个问题在mac下更常见？由于没有使用过mac设备，本文不解释相关内容</p><p><img                       lazyload                     alt="image"                     data-src="https://img1.musnow.top/i/2023/02/63f81349c99b9.png"                      alt="image-20230224093050205"                ></p><p><img                       lazyload                     alt="image"                     data-src="https://img1.musnow.top/i/2023/03/640d558b80b56.png"                                     ></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;CentOS8 出现 SSL certificate problem: unable to get local issuer certificate 解决办法&lt;/p&gt;</summary>
    
    
    
    <category term="速通Python" scheme="https://blog.musnow.top/categories/%E9%80%9F%E9%80%9APython/"/>
    
    
    <category term="Python" scheme="https://blog.musnow.top/tags/Python/"/>
    
    <category term="CentOS" scheme="https://blog.musnow.top/tags/CentOS/"/>
    
  </entry>
  
  <entry>
    <title>【Nas】绿联安装CentOS8容器</title>
    <link href="https://blog.musnow.top/2023/02/23/nas/10%E7%BB%BF%E8%81%94%E5%AE%89%E8%A3%85centos/"/>
    <id>https://blog.musnow.top/2023/02/23/nas/10%E7%BB%BF%E8%81%94%E5%AE%89%E8%A3%85centos/</id>
    <published>2023-02-23T14:25:57.000Z</published>
    <updated>2023-03-11T11:25:36.235Z</updated>
    
    <content type="html"><![CDATA[<p>绿联安装CentOS8容器</p><span id="more"></span><h1 id="1-创建容器"><a href="#1-创建容器" class="headerlink" title="1.创建容器"></a>1.创建容器</h1><p>先在客户端安装容器，随后用xshell进入绿联的ssh（如何<a class="link"   href="https://www.bilibili.com/video/BV1J84y1C7Zu/?spm_id_from=333.337.search-card.all.click" >开启ssh参考视频<i class="fas fa-external-link-alt"></i></a>）</p><blockquote><p>简单说来，就是在客户端里面开启远程调试，将远程调试的验证码和下面的密码拼起来，就是绿联ssh的root密码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">L#W$%W1uGa</span><br></pre></td></tr></table></figure><p>端口是922，利用putty或者xshell等软件链接（推荐xshell）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh 绿联本地ip:922</span><br></pre></td></tr></table></figure><p>会出现提示框要你输入账户和密码，账户写root，密码用上面拼好的密码，直接复制后，<code>shift+ins</code>粘贴到终端后回车</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">注意，终端内填写密码是不会有任何提示的，需要盲敲</span><br></pre></td></tr></table></figure></blockquote><p>执行如下命令，以<strong>特权模式</strong>创建一个centos容器，并将容器内的22端口映射给主机的22222端口</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">docker run -d \</span><br><span class="line">-p 22222:22 \</span><br><span class="line">--name centos \</span><br><span class="line">--privileged=true \</span><br><span class="line">centos:latest \</span><br><span class="line">/usr/sbin/init</span><br></pre></td></tr></table></figure><p>搞定了之后，进绿联客户端，停止容器运行，设置一个文件路径给容器内部，方便docker容器和nas资料互传（不设置也不是不行）</p><p><img                       lazyload                     alt="image"                     data-src="https://img1.musnow.top/i/2023/02/63f74c586cb56.png"                      alt="image-20230223192152276"                ></p><p>注意，在客户端配置的时候，需要把所有能给的选项（<code>-i -t 高级选项</code>）全都勾上，避免docker安装的centos缺少权限；</p><hr><p>回到绿联的ssh终端，用下面的命令进入容器内部</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker exec -it centos /bin/bash</span><br></pre></td></tr></table></figure><p>你也可以用客户端里面的终端功能，但是那个太简陋了，不太好用。既然都已经能ssh连上绿联了，那完全没必要用客户端</p><h2 id="1-1-判断是否成功以特权模式安装"><a href="#1-1-判断是否成功以特权模式安装" class="headerlink" title="1.1 判断是否成功以特权模式安装"></a>1.1 判断是否成功以特权模式安装</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl </span><br></pre></td></tr></table></figure><p>执行此命令，看看是否有如下输出。如果没有，代表没有成功以特权模式安装。<code>systemctl</code>在linux中很常用，且开启容器的ssh也需要使用此命令！</p><p><img                       lazyload                     alt="image"                     data-src="https://img1.musnow.top/i/2023/02/63f74e0d90e2c.png"                      alt="image-20230223192918079"                ></p><p>如果没能成功使用，请重试上面的步骤</p><h1 id="2-更新软件"><a href="#2-更新软件" class="headerlink" title="2.更新软件"></a>2.更新软件</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum update -y &amp;&amp; yum upgrade -y</span><br></pre></td></tr></table></figure><p>第一次执行此命令的时候，大概率会出现下面的报错</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Error: Failed to download metadata for repo &#x27;appstream&#x27;: Cannot prepare internal mirrorlist</span><br></pre></td></tr></table></figure><p>参考 <a class="link"   href="https://blog.csdn.net/weixin_43252521/article/details/124409151" >Error: Failed to download metadata for repo ‘appstream‘: Cannot prepare internal mirrorlist<i class="fas fa-external-link-alt"></i></a> 博客，用下面的命令解决这个问题</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cd /etc/yum.repos.d/</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sed -i &#x27;s/mirrorlist/#mirrorlist/g&#x27; /etc/yum.repos.d/CentOS-*</span><br><span class="line">sed -i &#x27;s|#baseurl=http://mirror.centos.org|baseurl=http://vault.centos.org|g&#x27; /etc/yum.repos.d/CentOS-*</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum makecache</span><br></pre></td></tr></table></figure><p>执行<code>makecache</code>后，系统会获取一些内容，让后我们重新指向如下命令</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum update -y &amp;&amp; yum upgrade -y</span><br></pre></td></tr></table></figure><p>会进行一连串的更新，直到出现下面的complete窗口，代表成功！</p><p><img                       lazyload                     alt="image"                     data-src="https://img1.musnow.top/i/2023/02/63f74f439f368.png"                      alt="image-20230223193425765"                ></p><p><img                       lazyload                     alt="image"                     data-src="https://img1.musnow.top/i/2023/02/63f74edeaacc9.png"                      alt="image-20230223193247217"                ></p><h1 id="3-ssh链接"><a href="#3-ssh链接" class="headerlink" title="3.ssh链接"></a>3.ssh链接</h1><h2 id="3-1-安装passwd"><a href="#3-1-安装passwd" class="headerlink" title="3.1 安装passwd"></a>3.1 安装passwd</h2><p>一个linux系统，不能ssh链接可不行，我们需要更新一下内容，实现ssh链接</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install passwd</span><br></pre></td></tr></table></figure><p>先安装passwd命令，设置root的密码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">passwd</span><br></pre></td></tr></table></figure><p>会弹出来让你输入密码，盲敲就行</p><h2 id="3-2-安装vim和openssh"><a href="#3-2-安装vim和openssh" class="headerlink" title="3.2 安装vim和openssh"></a>3.2 安装vim和openssh</h2><p>用下面的命令安装vim和openssh</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install vim openssh-server openssh-clients -y</span><br></pre></td></tr></table></figure><p>安装完毕后，修改ssh的配置文件（vim的使用请百度）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/ssh/sshd_config</span><br></pre></td></tr></table></figure><p><strong>取消注释</strong>下面的字段即可开启ssh</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Port 22</span><br><span class="line">ListenAddress 0.0.0.0</span><br><span class="line">ListenAddress ::</span><br><span class="line"></span><br><span class="line">PermitRootLogin yes</span><br><span class="line">PubkeyAuthentication yes</span><br><span class="line">AuthorizedKeysFile .ssh/authorized_keys</span><br></pre></td></tr></table></figure><p>修改好了之后，退出终端；</p><p>用下面的命令重启ssh服务，并设置开机启动ssh</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">systemctl restart sshd.service</span><br><span class="line">systemctl enable sshd.service</span><br></pre></td></tr></table></figure><p>如果一切正常的话，这两个命令应该什么都不会输出！</p><h2 id="3-3-尝试ssh链接"><a href="#3-3-尝试ssh链接" class="headerlink" title="3.3 尝试ssh链接"></a>3.3 尝试ssh链接</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh 绿联本地ip:22222</span><br></pre></td></tr></table></figure><p>会弹出来让你验证登录，到这里就是ok了</p><p><img                       lazyload                     alt="image"                     data-src="https://img1.musnow.top/i/2023/02/63f750c5f3325.png"                      alt="image-20230223194054648"                ></p><h2 id="3-4-配置ls命令颜色"><a href="#3-4-配置ls命令颜色" class="headerlink" title="3.4 配置ls命令颜色"></a>3.4 配置ls命令颜色</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/profile</span><br></pre></td></tr></table></figure><p>在末尾添加如下字段</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">export LS_OPTIONS=&#x27;--color=auto&#x27;</span><br><span class="line">alias ls=&#x27;ls $LS_OPTIONS&#x27;</span><br><span class="line">alias ll=&#x27;ls $LS_OPTIONS -lA&#x27;</span><br></pre></td></tr></table></figure><p>随后重启容器即可</p><h2 id="3-5-配置yum阿狸源"><a href="#3-5-配置yum阿狸源" class="headerlink" title="3.5 配置yum阿狸源"></a>3.5 配置yum阿狸源</h2><p>备份原有源</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar -zcvf CentOS-bk.tar.gz /etc/yum.repos.d/CentOS-*</span><br></pre></td></tr></table></figure><p>看看本地的centos是什么版本</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat /etc/redhat-release</span><br></pre></td></tr></table></figure><p>我这里的版本是8.5</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CentOS Linux release 8.5.2111</span><br></pre></td></tr></table></figure><p>替换阿里源</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">curl -o /etc/yum.repos.d/CentOS-Base.repo http://mirrors.aliyun.com/repo/Centos-8.repo</span><br><span class="line">curl -o /etc/yum.repos.d/epel.repo http://mirrors.aliyun.com/repo/epel-8.repo</span><br></pre></td></tr></table></figure><p>重新生成缓存</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">yum clean all</span><br><span class="line">yum makecache</span><br></pre></td></tr></table></figure><p><img                       lazyload                     alt="image"                     data-src="https://img1.musnow.top/i/2023/02/63f7562e6d44a.png"                      alt="image-20230223200200975"                ></p><p>现在速度快多了！</p><h1 id="开用！"><a href="#开用！" class="headerlink" title="开用！"></a>开用！</h1><p>后续的使用就不再多说拉！既然你想安装centos，想必对linux的了解肯定比我多😂</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;绿联安装CentOS8容器&lt;/p&gt;</summary>
    
    
    
    <category term="捣鼓折腾nas" scheme="https://blog.musnow.top/categories/%E6%8D%A3%E9%BC%93%E6%8A%98%E8%85%BEnas/"/>
    
    
    <category term="CentOS" scheme="https://blog.musnow.top/tags/CentOS/"/>
    
    <category term="nas" scheme="https://blog.musnow.top/tags/nas/"/>
    
  </entry>
  
  <entry>
    <title>【Docker】配置CentOS容器时出现 Error Failed to download metadata for repo &#39;appstream&#39; Cannot prepare internal mirrorlist</title>
    <link href="https://blog.musnow.top/2023/02/23/docker/8docker%E5%AE%89%E8%A3%85centos%E9%81%87%E5%88%B0%E6%8A%A5%E9%94%99/"/>
    <id>https://blog.musnow.top/2023/02/23/docker/8docker%E5%AE%89%E8%A3%85centos%E9%81%87%E5%88%B0%E6%8A%A5%E9%94%99/</id>
    <published>2023-02-23T09:45:33.000Z</published>
    <updated>2023-03-12T03:52:02.657Z</updated>
    
    <content type="html"><![CDATA[<p>本站经常搬运一些其他博主文章，主要是为了持久化访问。避免日后他人删文or原文无法访问；所有搬运的文章都会写明原文地址，并且不会展示本站的<code>copyright_info</code></p><span id="more"></span><p>下文所出现的场景，是我在linux上使用docker安装centos容器时出现的！</p><hr><p>✨在学习使用 docker 技术过程中，基于 centos 镜像自定义新的镜像，其中基础镜像 centos 需要提前安装好 <a class="link"   href="https://so.csdn.net/so/search?q=vim&spm=1001.2101.3001.7020" >vim<i class="fas fa-external-link-alt"></i></a> 和 net-tools，然而在刚开始通过 <code>yum -y install vim</code> 安装 vim 时，便出现了错误提示信息：<br><img                       lazyload                     alt="image"                     data-src="https://img1.musnow.top/i/2023/03/640d4c609da98.png"                                     ></p><pre><code>Error: Failed to download metadata for repo &#39;appstream&#39;: Cannot prepare internal mirrorlist: No URLs in mirrorlist</code></pre><p>✨上面的报错信息意思是，<strong>从仓库 ‘appstream’ 下载元数据失败：由于镜像列表中没有 URL，不能准备内部镜像列表</strong>。</p><h1 id="🥎问题分析："><a href="#🥎问题分析：" class="headerlink" title="🥎问题分析："></a>🥎问题分析：</h1><ul><li>✨第一种可能的情况便是网络连接问题。检查是否可以连接外部网络，可以使用 <code>ping baidu.com</code> 查看是否有丢包情况。如果丢包，则进一步检查网络连接是否正常；如果没有丢包，继续阅读下文</li><li>✨那么第二种情况，便是 CentOS 已经停止维护的问题。2020 年 12 月 8 号，CentOS 官方宣布了停止维护 CentOS Linux 的计划，并推出了 CentOS Stream 项目，CentOS Linux 8 作为 RHEL 8 的复刻版本，生命周期缩短，于 2021 年 12 月 31 日停止更新并停止维护（EOL），</li><li>更多的信息可以查看 <a class="link"   href="https://blog.centos.org/2020/12/future-is-centos-stream/?spm=a2c4g.11186623.0.0.3b005eb35dW2Kg" >CentOS 官方公告<i class="fas fa-external-link-alt"></i></a>。<strong>如果需要更新 CentOS，需要将镜像从 <a class="link"   href="http://mirror.centos.org/" >mirror.centos.org<i class="fas fa-external-link-alt"></i></a> 更改为 <a class="link"   href="https://vault.centos.org/" >vault.centos.org<i class="fas fa-external-link-alt"></i></a></strong></li></ul><h1 id="🥎那么针对上面提到的第二种情况，给出的解决方法如下："><a href="#🥎那么针对上面提到的第二种情况，给出的解决方法如下：" class="headerlink" title="🥎那么针对上面提到的第二种情况，给出的解决方法如下："></a>🥎那么针对上面提到的第二种情况，给出的解决方法如下：</h1><ul><li><p>🔔 <strong>首先</strong>，进入到 yum 的 repos 目录</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cd /etc/yum.repos.d/</span><br></pre></td></tr></table></figure></li><li><p>🔔<strong>其次</strong>，修改 centos 文件内容</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sed -i &#x27;s/mirrorlist/#mirrorlist/g&#x27; /etc/yum.repos.d/CentOS-*</span><br><span class="line">sed -i &#x27;s|#baseurl=http://mirror.centos.org|baseurl=http://vault.centos.org|g&#x27; /etc/yum.repos.d/CentOS-*</span><br></pre></td></tr></table></figure></li><li><p>🔔 <strong>然后</strong>，生成缓存更新（第一次更新，速度稍微有点慢，耐心等待两分钟左右）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum makecache</span><br></pre></td></tr></table></figure></li><li><p>🔔 <strong>最后</strong>，运行 yum update 并重新安装 vim</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">yum update -y</span><br><span class="line">yum -y install vim</span><br></pre></td></tr></table></figure></li></ul><p>🎉<strong>至此，针对第二种情况出现的问题成功解决！</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">原文作者：ReadThroughLife</span><br><span class="line">原文地址：https://blog.csdn.net/weixin_43252521/article/details/124409151</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;本站经常搬运一些其他博主文章，主要是为了持久化访问。避免日后他人删文or原文无法访问；所有搬运的文章都会写明原文地址，并且不会展示本站的&lt;code&gt;copyright_info&lt;/code&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="docker真好玩" scheme="https://blog.musnow.top/categories/docker%E7%9C%9F%E5%A5%BD%E7%8E%A9/"/>
    
    
    <category term="CentOS" scheme="https://blog.musnow.top/tags/CentOS/"/>
    
    <category term="Docker" scheme="https://blog.musnow.top/tags/Docker/"/>
    
  </entry>
  
  <entry>
    <title>【C++】C++11中局部static变量的线程安全问题</title>
    <link href="https://blog.musnow.top/2023/02/20/cpp/29C++11%E5%B1%80%E9%83%A8%E9%9D%99%E6%80%81%E5%8F%98%E9%87%8F%E5%88%9D%E5%A7%8B%E5%8C%96%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E9%97%AE%E9%A2%98/"/>
    <id>https://blog.musnow.top/2023/02/20/cpp/29C++11%E5%B1%80%E9%83%A8%E9%9D%99%E6%80%81%E5%8F%98%E9%87%8F%E5%88%9D%E5%A7%8B%E5%8C%96%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E9%97%AE%E9%A2%98/</id>
    <published>2023-02-20T13:13:46.000Z</published>
    <updated>2023-03-10T14:54:08.274Z</updated>
    
    <content type="html"><![CDATA[<p>C++11中局部static变量的线程安全问题</p><span id="more"></span><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>大家都知道，在C++11标准中，要求局部静态变量初始化具有<a class="link"   href="https://so.csdn.net/so/search?q=%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8&spm=1001.2101.3001.7020" >线程安全<i class="fas fa-external-link-alt"></i></a>性，所以我们可以很容易实现一个线程安全的单例类：</p><pre><code>class Foo&#123;public:    static Foo *getInstance()    &#123;        static Foo s_instance;        return &amp;s_instance;    &#125;private:    Foo() &#123;&#125;&#125;;</code></pre><p>在C++标准中，是这样描述的（在<a class="link"   href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2012/n3337.pdf" >标准草案<i class="fas fa-external-link-alt"></i></a>的6.7节中）：</p><blockquote><p>such a variable is initialized the first time control passes through its declaration; such a variable is considered initialized upon the completion of its initialization. If the initialization exits by throwing an exception, the initialization is not complete, so it will be tried again the next time control enters the declaration. If control enters the declaration concurrently while the variable is being initialized, the concurrent execution shall wait for completion of the initialization. If control re-enters the declaration recursively while the variable is being initialized, the behavior is undefined.</p></blockquote><h1 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h1><p>标准关于局部静态变量初始化，有这么几点要求：</p><ol><li>变量在代码第一次执行到变量声明的地方时初始化。</li><li>初始化过程中发生异常的话视为未完成初始化，未完成初始化的话，需要下次有代码执行到相同位置时再次初始化。</li><li>在当前线程执行到需要初始化变量的地方时，如果有其他线程正在初始化该变量，则阻塞当前线程，直到初始化完成为止。</li><li>如果初始化过程中发生了对初始化的递归调用，则视为未定义行为。</li></ol><p>关于第4点，如果不明白，可以参考以下代码：</p><pre><code>class Bar&#123;public:    static Bar *getInstance()    &#123;        static Bar s_instance;        return &amp;s_instance;    &#125;private:    Bar()    &#123;        getInstance();    &#125;&#125;;</code></pre><h1 id="GCC的实现"><a href="#GCC的实现" class="headerlink" title="GCC的实现"></a>GCC的实现</h1><p>以GCC 7.3.0版本为例，我们来分析GCC是如何实现标准的。</p><h2 id="Foo-getInstance"><a href="#Foo-getInstance" class="headerlink" title="Foo::getInstance()"></a>Foo::getInstance()</h2><p>使用GCC编译后，我们使用gdb将文章开头的<code>Foo::getInstance()</code>反汇编：</p><pre><code>Dump of assembler code for function Foo::getInstance():   0x00005555555546ea &lt;+0&gt;:     push   %rbp   0x00005555555546eb &lt;+1&gt;:     mov    %rsp,%rbp=&gt; 0x00005555555546ee &lt;+4&gt;:     movzbl 0x20092b(%rip),%eax        # 0x555555755020 &lt;_ZGVZN3Foo11getInstanceEvE10s_instance&gt;   0x00005555555546f5 &lt;+11&gt;:    test   %al,%al   0x00005555555546f7 &lt;+13&gt;:    sete   %al   0x00005555555546fa &lt;+16&gt;:    test   %al,%al   0x00005555555546fc &lt;+18&gt;:    je     0x55555555472b &lt;Foo::getInstance()+65&gt;   0x00005555555546fe &lt;+20&gt;:    lea    0x20091b(%rip),%rdi        # 0x555555755020 &lt;_ZGVZN3Foo11getInstanceEvE10s_instance&gt;   0x0000555555554705 &lt;+27&gt;:    callq  0x5555555545b0 &lt;__cxa_guard_acquire@plt&gt;   0x000055555555470a &lt;+32&gt;:    test   %eax,%eax   0x000055555555470c &lt;+34&gt;:    setne  %al   0x000055555555470f &lt;+37&gt;:    test   %al,%al   0x0000555555554711 &lt;+39&gt;:    je     0x55555555472b &lt;Foo::getInstance()+65&gt;   0x0000555555554713 &lt;+41&gt;:    lea    0x2008fe(%rip),%rdi        # 0x555555755018 &lt;_ZZN3Foo11getInstanceEvE10s_instance&gt;   0x000055555555471a &lt;+48&gt;:    callq  0x555555554734 &lt;Foo::Foo()&gt;   0x000055555555471f &lt;+53&gt;:    lea    0x2008fa(%rip),%rdi        # 0x555555755020 &lt;_ZGVZN3Foo11getInstanceEvE10s_instance&gt;   0x0000555555554726 &lt;+60&gt;:    callq  0x5555555545a0 &lt;__cxa_guard_release@plt&gt;   0x000055555555472b &lt;+65&gt;:    lea    0x2008e6(%rip),%rax        # 0x555555755018 &lt;_ZZN3Foo11getInstanceEvE10s_instance&gt;   0x0000555555554732 &lt;+72&gt;:    pop    %rbp   0x0000555555554733 &lt;+73&gt;:    retq   End of assembler dump.</code></pre><p>在<code>+4</code>、<code>+20</code>、<code>+53</code>出现的<code>_ZGVZN3Foo11getInstanceEvE10s_instance</code>使用<code>c++filt</code>分析为<code>guard variable for Foo::getInstance()::s_instance</code>，而<code>+41</code>、<code>+65</code>位置出现的<code>_ZZN3Foo11getInstanceEvE10s_instance</code>则为<code>Foo::getInstance()::s_instance</code>。后者是<code>s_instance</code>这个局部静态变量，前者从名字看就知道是个<code>guard</code>标志变量，用来指示局部静态变量的初始化状态。</p><h3 id="4-18"><a href="#4-18" class="headerlink" title="+4 ~ +18"></a>+4 ~ +18</h3><p>测试<code>guard</code>变量的第一个字节，如果为<code>0</code>，代表<code>s_instance</code>未初始化，进入<code>+27</code>；否则代表<code>s_instance</code>已初始化，进入<code>+65</code>。</p><h3 id="20-～-27"><a href="#20-～-27" class="headerlink" title="+20 ～ +27"></a>+20 ～ +27</h3><p>以<code>guard</code>变量地址作为参数，执行<code>__cxa_guard_acquire</code>函数。</p><h3 id="32-～-39"><a href="#32-～-39" class="headerlink" title="+32 ～ +39"></a>+32 ～ +39</h3><p>测试返回值，如果为<code>0</code>，代表<code>s_instance</code>已初始化，进入<code>+65</code>；否则代表<code>s_instance</code>未初始化，进入<code>+41</code>。</p><h3 id="41-～-48"><a href="#41-～-48" class="headerlink" title="+41 ～ +48"></a>+41 ～ +48</h3><p>初始化<code>s_instance</code></p><h3 id="53-～-60"><a href="#53-～-60" class="headerlink" title="+53 ～ +60"></a>+53 ～ +60</h3><p>以<code>guard</code>变量地址作为参数，执行<code>__cxa_guard_release</code>函数。</p><h3 id="65-～-73"><a href="#65-～-73" class="headerlink" title="+65 ～ +73"></a>+65 ～ +73</h3><p>返回<code>s_instance</code>地址</p><h2 id="cxa-guard-acquire"><a href="#cxa-guard-acquire" class="headerlink" title="__cxa_guard_acquire"></a>__cxa_guard_acquire</h2><p>我们来看看<code>__cxa_guard_acquire</code>这个函数具体做了什么，该函数代码位于<code>gcc-7-7.3.0/gcc-7.3.0/libstdc++-v3/libsupc++/guard.cc</code>。由于这个函数针对不同平台做了不同的实现，有些我们不需要的代码，以我机器的设置，支持线程和futex系统调用，所以删除了一些不相关的代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> __cxa_guard_acquire (__guard *g)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// If the target can reorder loads, we need to insert a read memory</span></span><br><span class="line">    <span class="comment">// barrier so that accesses to the guarded variable happen after the</span></span><br><span class="line">    <span class="comment">// guard test.</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1</span></span><br><span class="line">    <span class="keyword">if</span> (_GLIBCXX_GUARD_TEST_AND_ACQUIRE (g))</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// If __atomic_* and futex syscall are supported, don&#x27;t use any global</span></span><br><span class="line">    <span class="comment">// mutex.</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2</span></span><br><span class="line">    <span class="keyword">if</span> (__gthread_active_p ())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> *gi = (<span class="type">int</span> *) (<span class="type">void</span> *) g;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3</span></span><br><span class="line">        <span class="type">const</span> <span class="type">int</span> guard_bit = _GLIBCXX_GUARD_BIT;</span><br><span class="line">        <span class="type">const</span> <span class="type">int</span> pending_bit = _GLIBCXX_GUARD_PENDING_BIT;</span><br><span class="line">        <span class="type">const</span> <span class="type">int</span> waiting_bit = _GLIBCXX_GUARD_WAITING_BIT;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 4</span></span><br><span class="line">            <span class="function"><span class="type">int</span> <span class="title">expected</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br><span class="line">            <span class="keyword">if</span> (__atomic_compare_exchange_n(gi, &amp;expected, pending_bit, <span class="literal">false</span>,</span><br><span class="line">                                            __ATOMIC_ACQ_REL,</span><br><span class="line">                                            __ATOMIC_ACQUIRE))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// This thread should do the initialization.</span></span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 5</span></span><br><span class="line">            <span class="keyword">if</span> (expected == guard_bit)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// Already initialized.</span></span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 6</span></span><br><span class="line">            <span class="keyword">if</span> (expected == pending_bit)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// Use acquire here.</span></span><br><span class="line"></span><br><span class="line">                <span class="comment">// 7</span></span><br><span class="line">                <span class="type">int</span> newv = expected | waiting_bit;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 8</span></span><br><span class="line">                <span class="keyword">if</span> (!__atomic_compare_exchange_n(gi, &amp;expected, newv, <span class="literal">false</span>,</span><br><span class="line">                                                 __ATOMIC_ACQ_REL,</span><br><span class="line">                                                 __ATOMIC_ACQUIRE))</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="comment">// 9</span></span><br><span class="line">                    <span class="keyword">if</span> (expected == guard_bit)</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="comment">// Make a thread that failed to set the</span></span><br><span class="line">                        <span class="comment">// waiting bit exit the function earlier,</span></span><br><span class="line">                        <span class="comment">// if it detects that another thread has</span></span><br><span class="line">                        <span class="comment">// successfully finished initialising.</span></span><br><span class="line">                        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 10</span></span><br><span class="line">                    <span class="keyword">if</span> (expected == <span class="number">0</span>)</span><br><span class="line">                        <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 11</span></span><br><span class="line">                expected = newv;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 12</span></span><br><span class="line">            <span class="built_in">syscall</span> (SYS_futex, gi, _GLIBCXX_FUTEX_WAIT, expected, <span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">acquire</span> (g);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>首先检测<code>guard</code>变量，<code>guard</code>变量等于<code>1</code>的话，直接返回<code>0</code>，代表<code>s_instance</code>已初始化，不需要再次初始化。</li><li>检测是否为多线程环境，如果没有多线程的话，也就没有必要去做额外工作来保证线程安全了。</li><li><code>guard_bit</code>表示<code>s_instance</code>已经初始化成功；<code>pending_bit</code>表示<code>s_instance</code>正在初始化；<code>waiting_bit</code>表示有其他线程正在等待<code>s_instance</code>的初始化。</li><li>使用一个原子操作来检测<code>guard</code>变量是否为<code>0</code>，如果为<code>0</code>，则由当前线程初始化<code>s_instance</code>，把<code>pending_bit</code>写入guard变量，返回<code>1</code>。如果不为<code>0</code>，则将guard当前值写入<code>expected</code>。</li><li>检测<code>expected</code>值是否为<code>guard_bit</code>，如果是，则<code>s_instance</code>已初始化完成，不再需要初始化，返回<code>0</code>。</li><li>检测<code>expected</code>值是否为<code>pending_bit</code>，如果是，说明<code>s_instance</code>正在初始化，且没有其他线程等待初始化。</li><li>将<code>newv</code>变量设置为<code>pending_bit | waiting_bit</code>，表示<code>s_instance</code>正在初始化且有线程正在等待初始化。</li><li>使用一个原子操作来检测<code>guard</code>变量是否为<code>pending_bit</code>，如果不是，说明有其他线程修改了<code>guard</code>变量，需要做进一步检测；如果是，说明没有其他线程修改<code>guard</code>变量，则将<code>pending_bit | waiting_bit</code>写入<code>guard</code>变量。</li><li>如果<code>expected</code>等于<code>guard_bit</code>，说明<code>s_instance</code>被初始化成功，不需要再初始化，返回<code>0</code>。</li><li>如果<code>expected</code>等于<code>0</code>，说明<code>s_instance</code>初始化失败，回到<code>4</code>重新开始检测。</li><li>如果在<code>8</code>中没有其他线程修改过<code>guard</code>变量，将<code>expected</code>设置为<code>pending_bit | waiting_bit</code>，表示<code>s_instance</code>正在初始化且有线程（也就是当前线程）正在等待初始化。</li><li>如果在<code>6</code>处没有进入if分支，说明<code>expected</code>等于<code>pending_bit | waiting_bit</code>，如果进入了if分支，由<code>11</code>可得，此时<code>expected</code>也被修改为了<code>pending_bit | waiting_bit</code>。总之，此时<code>s_instance</code>正在初始化且有线程正在等待初始化。利用<code>futex</code>系统调用，再次检测<code>guard</code>变量是否发生了变化，如果发生了变化，回到<code>4</code>重新开始检测；如果没有发生变化，仍然等于<code>pending_bit | waiting_bit</code>，则挂起当前线程。</li></ol><p>总之，<code>__cxa_guard_acquire</code>要么返回<code>0</code>要么返回<code>1</code>，用来指示<code>s_instance</code>已初始化或未初始化。<code>__cxa_guard_acquire</code>可能会导致当前线程挂起，这发生在<code>s_instance</code>正在初始化的时候。</p><h2 id="cxa-guard-release"><a href="#cxa-guard-release" class="headerlink" title="__cxa_guard_release"></a>__cxa_guard_release</h2><p>由于<code>__cxa_guard_acquire</code>可能导致当前线程挂起，因此需要在<code>s_instance</code>初始化完成后使用将<code>__cxa_guard_release</code>线程唤醒。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> __cxa_guard_release (__guard *g) <span class="keyword">throw</span> ()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// If __atomic_* and futex syscall are supported, don&#x27;t use any global</span></span><br><span class="line">    <span class="comment">// mutex.</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1</span></span><br><span class="line">    <span class="keyword">if</span> (__gthread_active_p ())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> *gi = (<span class="type">int</span> *) (<span class="type">void</span> *) g;</span><br><span class="line">        <span class="type">const</span> <span class="type">int</span> guard_bit = _GLIBCXX_GUARD_BIT;</span><br><span class="line">        <span class="type">const</span> <span class="type">int</span> waiting_bit = _GLIBCXX_GUARD_WAITING_BIT;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2</span></span><br><span class="line">        <span class="type">int</span> old = __atomic_exchange_n (gi, guard_bit, __ATOMIC_ACQ_REL);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3</span></span><br><span class="line">        <span class="keyword">if</span> ((old &amp; waiting_bit) != <span class="number">0</span>)</span><br><span class="line">            <span class="built_in">syscall</span> (SYS_futex, gi, _GLIBCXX_FUTEX_WAKE, INT_MAX);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">set_init_in_progress_flag</span>(g, <span class="number">0</span>);</span><br><span class="line">    _GLIBCXX_GUARD_SET_AND_RELEASE (g);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>检测是否为多线程环境</li><li>使用原子操作将<code>guard</code>变量置为<code>guard_bit</code>，同时获取<code>guard</code>变量原始值。</li><li>如果<code>guard</code>变量原始值包含<code>waiting_bit</code>，说明有线程挂起（或将要调用<code>futex</code>欲使线程挂起），调用<code>futex</code>唤醒挂起的进程。</li></ol><h2 id="cxa-guard-abort"><a href="#cxa-guard-abort" class="headerlink" title="__cxa_guard_abort"></a>__cxa_guard_abort</h2><p>由于<code>s_instance</code>可能初始化失败（本例中并未体现），因此还有一个<code>__cxa_guard_abort</code>函数。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> __cxa_guard_abort (__guard *g) <span class="keyword">throw</span> ()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// If __atomic_* and futex syscall are supported, don&#x27;t use any global</span></span><br><span class="line">    <span class="comment">// mutex.</span></span><br><span class="line">    <span class="keyword">if</span> (__gthread_active_p ())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> *gi = (<span class="type">int</span> *) (<span class="type">void</span> *) g;</span><br><span class="line">        <span class="type">const</span> <span class="type">int</span> waiting_bit = _GLIBCXX_GUARD_WAITING_BIT;</span><br><span class="line">        <span class="type">int</span> old = __atomic_exchange_n (gi, <span class="number">0</span>, __ATOMIC_ACQ_REL);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> ((old &amp; waiting_bit) != <span class="number">0</span>)</span><br><span class="line">            <span class="built_in">syscall</span> (SYS_futex, gi, _GLIBCXX_FUTEX_WAKE, INT_MAX);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">set_init_in_progress_flag</span>(g, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>与<code>__cxa_guard_release</code>基本一致，不同的地方在于会将<code>guard</code>变量置<code>0</code>。</p><h2 id="递归初始化调用"><a href="#递归初始化调用" class="headerlink" title="递归初始化调用"></a>递归初始化调用</h2><p>由于在C++11标准中，初始化如果发生了递归是未定义行为，所以GCC 7.3.0针对是否为<a class="link"   href="https://so.csdn.net/so/search?q=%E5%A4%9A%E7%BA%BF%E7%A8%8B&spm=1001.2101.3001.7020" >多线程<i class="fas fa-external-link-alt"></i></a>环境做了不同的处理。如果是多线程环境，不进行额外处理，会发生死锁；如果是单线程环境，则会抛异常。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// acquire() is a helper function used to acquire guard if thread support is</span></span><br><span class="line"><span class="comment">// not compiled in or is compiled in but not enabled at run-time.</span></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">int</span></span></span><br><span class="line"><span class="function"><span class="title">acquire</span><span class="params">(__guard *g)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// Quit if the object is already initialized.</span></span><br><span class="line">    <span class="keyword">if</span> (_GLIBCXX_GUARD_TEST(g))</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">init_in_progress_flag</span>(g))</span><br><span class="line">        <span class="built_in">throw_recursive_init_exception</span>();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">set_init_in_progress_flag</span>(g, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>看到了GCC如此复杂的实现，我的个人感想是还是不要自己造轮子来保证单例类的线程安全了，想要做到和GCC一样的高效还是比较难的，利用C++11标准的带来的便利就挺好。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">原文作者：imred</span><br><span class="line">原文链接：https://blog.csdn.net/imred/article/details/89069750</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;C++11中局部static变量的线程安全问题&lt;/p&gt;</summary>
    
    
    
    <category term="遇见C++" scheme="https://blog.musnow.top/categories/%E9%81%87%E8%A7%81C/"/>
    
    
    <category term="C++" scheme="https://blog.musnow.top/tags/C/"/>
    
    <category term="C++11" scheme="https://blog.musnow.top/tags/C-11/"/>
    
  </entry>
  
  <entry>
    <title>【Curl】通过curl模拟referer获取到有防盗链的图片</title>
    <link href="https://blog.musnow.top/2023/02/20/tools/15curl%E6%A8%A1%E6%8B%9Freferer%E8%8E%B7%E5%8F%96%E8%B5%84%E6%BA%90/"/>
    <id>https://blog.musnow.top/2023/02/20/tools/15curl%E6%A8%A1%E6%8B%9Freferer%E8%8E%B7%E5%8F%96%E8%B5%84%E6%BA%90/</id>
    <published>2023-02-20T04:20:31.000Z</published>
    <updated>2023-03-19T13:53:19.000Z</updated>
    
    <content type="html"><![CDATA[<p>本文所描述操作仅供学习curl命令，请勿用于盗刷他人图床等违规操作！🙅‍♀️</p><span id="more"></span><h1 id="1-说明"><a href="#1-说明" class="headerlink" title="1.说明"></a>1.说明</h1><p>当我想把51la添加到我的导航站点，却发现它的icon图标有防盗链，禁止空referer访问的；</p><p>这点完全可以理解，为了防止他人盗刷本站的图片，通常我们都需要给图片地址加上防盗链。</p><p><img                       lazyload                     alt="image"                     data-src="https://img1.musnow.top/i/2023/02/63f2fa1399fff.png"                      alt="image-20230220124149093"                ></p><p>其实51la提供了自己的icon，但这里提供的icon像素特别低，只有16*16，在我的导航站点上的显示就没有那么友好了</p><p><img                       lazyload                     alt="image"                     data-src="https://img1.musnow.top/i/2023/02/63f2fb32ccc10.png"                      alt="image-20230220124643681"                ></p><p><img                       lazyload                     alt="image"                     data-src="https://img1.musnow.top/i/2023/02/63f2fb5f7cf73.png"                      alt="image-20230220124728488"                ></p><p>所以我才想把稍微清晰一点的icon图标下载下来</p><h1 id="2-curl使用"><a href="#2-curl使用" class="headerlink" title="2.curl使用"></a>2.curl使用</h1><blockquote><p>参考 <a class="link"   href="https://www.ruanyifeng.com/blog/2019/09/curl-reference.html" >https://www.ruanyifeng.com/blog/2019/09/curl-reference.html<i class="fas fa-external-link-alt"></i></a></p></blockquote><p>要避开这个403访问权限，需要做的就是给请求头给定一个referer字段，告诉51la的服务器，我是通过他自己的域名访问图标文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">curl \</span><br><span class="line">-H &#x27;Referer: https://v6.51.la/&#x27; \</span><br><span class="line">https://v6-static.51.la/v6-static/202302161047/favicon.ico \</span><br><span class="line">-o favicon.ico</span><br></pre></td></tr></table></figure><p>对上面提到的几个参数做一定解释</p><ul><li>-H 设定请求头，需要符号http协议的标准<code>key: value</code></li><li>-o 将获取到的内容保存为文件，在后面指定文件名（这里我指定为了<code>favicon.ico</code>）</li></ul><p>在<code>linux</code>下用这个命令，就能成功拉取到51la的站点图片</p><p><img                       lazyload                     alt="image"                     data-src="https://img1.musnow.top/i/2023/02/63f2fb9421523.png"                      alt="image-20230220124820822"                ></p><p>如果不加referer字段，则还是会返回403</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ curl https://v6-static.51.la/v6-static/202302161047/favicon.ico </span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;&lt;title&gt;403 Forbidden&lt;/title&gt;&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;center&gt;&lt;h1&gt;403 Forbidden&lt;/h1&gt;&lt;/center&gt;</span><br><span class="line">&lt;hr&gt;&lt;center&gt;openresty&lt;/center&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><p>备注：windows下使用这个curl命令会报错，因为windows下的curl参数和linux下是不同的。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;本文所描述操作仅供学习curl命令，请勿用于盗刷他人图床等违规操作！🙅‍♀️&lt;/p&gt;</summary>
    
    
    
    <category term="差生文具多" scheme="https://blog.musnow.top/categories/%E5%B7%AE%E7%94%9F%E6%96%87%E5%85%B7%E5%A4%9A/"/>
    
    
    <category term="Linux" scheme="https://blog.musnow.top/tags/Linux/"/>
    
    <category term="curl" scheme="https://blog.musnow.top/tags/curl/"/>
    
  </entry>
  
  <entry>
    <title>【C++】thread|mutex|atomic|condition_variable</title>
    <link href="https://blog.musnow.top/2023/02/19/cpp/28C++%E7%BA%BF%E7%A8%8B/"/>
    <id>https://blog.musnow.top/2023/02/19/cpp/28C++%E7%BA%BF%E7%A8%8B/</id>
    <published>2023-02-19T15:30:46.000Z</published>
    <updated>2023-03-11T11:25:36.272Z</updated>
    
    <content type="html"><![CDATA[<p>本篇博客，让我们来认识一下C++中的线程操作</p><span id="more"></span><blockquote><p>所用编译器：vs2019</p><p>阅读本文前，建议先了解线程的概念 👉 <a href="https://blog.musnow.top/2022/12/23/note_linux/19%E7%BA%BF%E7%A8%8B%E4%BA%92%E6%96%A5/">线程概念</a></p></blockquote><h1 id="1-基本介绍"><a href="#1-基本介绍" class="headerlink" title="1.基本介绍"></a>1.基本介绍</h1><p>在不同的操作系统，windows、linux、mac上，都会对多线程操作提供自己的系统调用接口</p><p>为什么C++需要封装一个线程？直接用系统的接口不好吗？</p><p>在<a href="https://blog.musnow.top/2022/11/01/note_linux/14%E6%96%87%E4%BB%B6io/#1-%E4%BB%80%E4%B9%88%E6%98%AF%E6%96%87%E4%BB%B6%EF%BC%9F">Linux文件博客</a>中，已经谈过了这一点：对于C++、python、java这些<strong>跨平台</strong>的语言来说，如果直接用系统的接口，是可以实现对应操作的。但是，这样会导致代码<strong>只能在某一个特定平台</strong>，甚至是某一个版本的特定操作系统上才能正常运行，直接与跨平台的特性相违背。</p><p>解决的办法呢，就是对系统的接口套一个语言级别的软件层，<strong>封装系统的接口</strong>。并用<code>条件编译</code>的方式来识别不同的操作系统，已调用不同操作系统的系统接口，以实现跨平台性</p><h1 id="2-thread类"><a href="#2-thread类" class="headerlink" title="2.thread类"></a>2.thread类</h1><blockquote><p><a class="link"   href="https://legacy.cplusplus.com/reference/thread/thread/thread/" >https://legacy.cplusplus.com/reference/thread/thread/thread/<i class="fas fa-external-link-alt"></i></a></p></blockquote><h2 id="2-1-构造-x2F-赋值"><a href="#2-1-构造-x2F-赋值" class="headerlink" title="2.1 构造&#x2F;赋值"></a>2.1 构造&#x2F;赋值</h2><p><img                       lazyload                     alt="image"                     data-src="https://img1.musnow.top/i/2023/02/63f20f5b7be4e.png"                      alt="image-20230219195214155"                ></p><p><img                       lazyload                     alt="image"                     data-src="https://img1.musnow.top/i/2023/02/63f20f5f8605c.png"                      alt="image-20230219200034593"                ></p><p>线程是不允许拷贝构造和赋值重载的，但是其支持<strong>右值引用</strong>的重载（主要是为了匿名对象构造）也支持空构造</p><blockquote><p>右值：无法进行取地址的变量</p></blockquote><h2 id="2-2-get-id"><a href="#2-2-get-id" class="headerlink" title="2.2 get_id"></a>2.2 get_id</h2><p>对于线程而言，比较重要的就是这个id号了，其用于标识线程的唯一性</p><p><img                       lazyload                     alt="image"                     data-src="https://img1.musnow.top/i/2023/02/63f22efb3c6f0.png"                      alt="image-20230219221526489"                ></p><h2 id="2-3-join-x2F-detach"><a href="#2-3-join-x2F-detach" class="headerlink" title="2.3 join&#x2F;detach"></a>2.3 join&#x2F;detach</h2><p>创建好了一个线程，我们需要进行join等待或者detach分离</p><ul><li>如果主线程不需要获取子进程执行的结果，可以直接执行detach</li><li>如果需要等待子线程执行，则执行join</li></ul><p>为什么会产生这两个分歧呢？是因为join等待是有一定消耗的。如果我们不关心线程执行的返回值，应该采用detach尽量减小消耗</p><h2 id="2-4-使用示例"><a href="#2-4-使用示例" class="headerlink" title="2.4 使用示例"></a>2.4 使用示例</h2><p>相比于Linux系统提供的pthread接口，C++的使用方法更加直接</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; a + b &lt;&lt; endl;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="function">thread <span class="title">t1</span><span class="params">(Add, <span class="number">10</span>, <span class="number">20</span>)</span></span>;</span><br><span class="line"><span class="function">thread <span class="title">t2</span><span class="params">(Add, <span class="number">10</span>, <span class="number">30</span>)</span></span>;</span><br><span class="line">t1.<span class="built_in">join</span>();</span><br><span class="line">t2.<span class="built_in">join</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img                       lazyload                     alt="image"                     data-src="https://img1.musnow.top/i/2023/02/63f220e7cf62b.png"                      alt="image-20230219211523002"                ></p><h2 id="2-5-空构造和移动赋值"><a href="#2-5-空构造和移动赋值" class="headerlink" title="2.5 空构造和移动赋值"></a>2.5 空构造和移动赋值</h2><p>如果我们只是定义了一个t1，没有直接调用构造函数指定其要运行的函数（其实是调用了空构造）那么要怎么给这个线程指定函数呢？</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">thread t3;<span class="comment">//调用了空构造</span></span><br></pre></td></tr></table></figure><p>别忘了，虽然线程不支持拷贝构造，但他有移动赋值！</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">thread&amp; <span class="keyword">operator</span>= (thread&amp;&amp; rhs) <span class="keyword">noexcept</span>;</span><br></pre></td></tr></table></figure><p>我们要做的，就是采用匿名对象的方式，赋值给t3</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">thread t3;</span><br><span class="line">t3 = <span class="built_in">thread</span>(Add, <span class="number">20</span>, <span class="number">30</span>);</span><br><span class="line">t3.<span class="built_in">join</span>();</span><br></pre></td></tr></table></figure><p><img                       lazyload                     alt="image"                     data-src="https://img1.musnow.top/i/2023/02/63f22a162f785.png"                      alt="image-20230219215433403"                ></p><h2 id="2-6-joinable"><a href="#2-6-joinable" class="headerlink" title="2.6 joinable"></a>2.6 joinable</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">joinable</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">noexcept</span></span>;</span><br></pre></td></tr></table></figure><p>这个函数的作用是标识一个线程是否还能进行join；下面几种情况，线程不能被join</p><ul><li>只调用了空构造（都没有指定需要运行的函数怎么join等待？）</li><li>被move了（move会将对象变成将亡值，也就是右值）</li><li>该对象已经调用过join或者detach</li></ul><p>如果是在多层函数中调用的线程，那可能join之前就可以判断一下当前对象是否还能join</p><h2 id="2-7-swap-x2F-move"><a href="#2-7-swap-x2F-move" class="headerlink" title="2.7 swap&#x2F;move"></a>2.7 swap&#x2F;move</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">swap</span> <span class="params">(thread&amp; x)</span> <span class="keyword">noexcept</span></span>;</span><br></pre></td></tr></table></figure><p>该成员函数的作用是将另外一个线程切换给当前线程</p><p><img                       lazyload                     alt="image"                     data-src="https://img1.musnow.top/i/2023/02/63f23b7a0ba31.png"                      alt="image-20230219230844481"                ></p><p>其本质就是一个move移动赋值</p><p><img                       lazyload                     alt="image"                     data-src="https://img1.musnow.top/i/2023/02/63f23c727a61c.png"                      alt="image-20230219231249899"                ></p><p>被移动后的线程t3不再<code>joinable</code>，不会运行，也不能被join或detach</p><p><img                       lazyload                     alt="image"                     data-src="https://img1.musnow.top/i/2023/02/63f23bc928163.png"                      alt="image-20230219231000662"                ></p><p>强行join会报错</p><p><img                       lazyload                     alt="image"                     data-src="https://img1.musnow.top/i/2023/02/63f23bf8def67.png"                      alt="image-20230219231048460"                ></p><h2 id="2-8-linux下编译"><a href="#2-8-linux下编译" class="headerlink" title="2.8 linux下编译"></a>2.8 linux下编译</h2><p>由于std是对系统接口进行的封装\</p><p>所以在linux下编译带c++线程库的代码时，需要带上pthread库的选项</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">g++ test.cpp -o test -std=c++11 -lpthread</span><br></pre></td></tr></table></figure><h1 id="3-std-ref"><a href="#3-std-ref" class="headerlink" title="3.std::ref"></a>3.std::ref</h1><p>这里有一个特殊的函数ref，要想知道其作用，我们需要先看下面这个场景</p><h2 id="3-1-引用传参"><a href="#3-1-引用传参" class="headerlink" title="3.1 引用传参"></a>3.1 引用传参</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _CRT_SECURE_NO_WARNINGS 1</span></span><br><span class="line"><span class="comment">//#include &lt;stdio.h&gt;</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Print</span><span class="params">(<span class="type">int</span> n,<span class="type">int</span>&amp; a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; this_thread::<span class="built_in">get_id</span>() &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt;  a++ &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line"><span class="function">thread <span class="title">t1</span><span class="params">(Print,<span class="number">10</span>, count)</span></span>;</span><br><span class="line"><span class="function">thread <span class="title">t2</span><span class="params">(Print,<span class="number">10</span>, count)</span></span>;</span><br><span class="line">t1.<span class="built_in">join</span>();</span><br><span class="line">t2.<span class="built_in">join</span>();</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;main: &quot;</span> &lt;&lt; count &lt;&lt; endl;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个场景中，我想达到的目标是让t1和t2两个线程帮我们对count进行++，最终在main里面打印结果；可编译会发现报错，不给我们这样写</p><p><img                       lazyload                     alt="image"                     data-src="https://img1.musnow.top/i/2023/02/63f1fbf492ae1.png"                      alt="image-20230219183743136"                ></p><p>相同的代码在linux下也出现了编译错误，所用g++版本如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">g++ (GCC) 11.2.1 20220127 (Red Hat 11.2.1-9)</span><br></pre></td></tr></table></figure><p><img                       lazyload                     alt="image"                     data-src="https://img1.musnow.top/i/2023/02/63f1e519b4676.png"                      alt="image-20230219170012180"                ></p><p>为了确认具体的报错位置，我们先把<code>int&amp; a</code>的引用去掉，再看看情况</p><p><img                       lazyload                     alt="image"                     data-src="https://img1.musnow.top/i/2023/02/63f19d78e1d62.png"                      alt="image-20230219115434795"                ></p><p>能看到，在没有采用<strong>引用传参</strong>的情况下，函数中对count进行的操作并不会反馈到main中，因为采用的是<strong>传值</strong>，会进行拷贝。</p><h2 id="3-2-thread构造函数"><a href="#3-2-thread构造函数" class="headerlink" title="3.2 thread构造函数"></a>3.2 thread构造函数</h2><p>那为什么加上引用之后，会报错呢？这就和thread的构造函数有关系了</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">Fn</span>, <span class="keyword">class</span>... Args&gt;</span><br><span class="line"><span class="function"><span class="keyword">explicit</span> <span class="title">thread</span> <span class="params">(Fn&amp;&amp; fn, Args&amp;&amp;... args)</span></span>;</span><br></pre></td></tr></table></figure><p>如上，当我们构造一个线程对象的时候，采用的是<a href="https://blog.musnow.top/2022/09/28/note_cpp/20c++11%E7%89%B9%E6%80%A7/#7-%E5%8F%AF%E5%8F%98%E6%A8%A1%E6%9D%BF%E5%8F%82%E6%95%B0">可变模板参数</a>；在我的博客中写到过，可变模板参数需要采用<code>递归</code>来进行参数类型的推测。</p><p>由于底层实现的问题（也只能是这个原因了）在进行构造的完美转发时，所有的参数都采用了<code>拷贝</code>而不是引用传参。</p><p>这也就导致我们没有办法将一个参数通过<strong>引用</strong>传入线程需要执行的函数！</p><blockquote><p>用指针肯定是可以的，可C++搞出引用这个东西，就是为了避免使用指针</p></blockquote><h2 id="3-3-ref出场"><a href="#3-3-ref出场" class="headerlink" title="3.3 ref出场"></a>3.3 ref出场</h2><blockquote><p><a class="link"   href="https://legacy.cplusplus.com/reference/functional/ref/?kw=ref" >https://legacy.cplusplus.com/reference/functional/ref/?kw=ref<i class="fas fa-external-link-alt"></i></a></p></blockquote><p>于是乎，std库中就新增了一个库函数<code>ref</code>，来解决这个问题</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ref的用法</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt; <span class="function">reference_wrapper&lt;T&gt; <span class="title">ref</span> <span class="params">(T&amp; elem)</span> <span class="keyword">noexcept</span></span>;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt; <span class="function">reference_wrapper&lt;T&gt; <span class="title">ref</span> <span class="params">(reference_wrapper&lt;T&gt;&amp; x)</span> <span class="keyword">noexcept</span></span>;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt; <span class="function"><span class="type">void</span> <span class="title">ref</span> <span class="params">(<span class="type">const</span> T&amp;&amp;)</span> </span>= <span class="keyword">delete</span>;</span><br></pre></td></tr></table></figure><blockquote><p>Constructs an object of the appropriate <a class="link"   href="https://legacy.cplusplus.com/reference_wrapper" >reference_wrapper<i class="fas fa-external-link-alt"></i></a> type to hold a reference to elem.</p><p>If the argument is itself a <a class="link"   href="https://legacy.cplusplus.com/reference_wrapper" >reference_wrapper<i class="fas fa-external-link-alt"></i></a> <em>(2)</em>, it creates a copy of x instead.</p><p>The function calls the proper <a class="link"   href="https://legacy.cplusplus.com/reference_wrapper" >reference_wrapper<i class="fas fa-external-link-alt"></i></a> constructor.</p></blockquote><p>这个函数会构造一个合适的<code>reference_wrapper</code>对象，来管理一个变量的<strong>引用</strong>。如果参数本身就是<code>reference_wrapper</code>类型，则会调用<code>reference_wrapper</code>的拷贝构造。</p><p>而ref函数不能传递右值，其右值引用的重载是被<code>delete</code>的</p><p><img                       lazyload                     alt="image"                     data-src="https://img1.musnow.top/i/2023/02/63f1e6be2fd55.png"                      alt="image-20230219170711744"                ></p><h2 id="3-4-ref使用"><a href="#3-4-ref使用" class="headerlink" title="3.4 ref使用"></a>3.4 ref使用</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">thread <span class="title">t1</span><span class="params">(Print,<span class="number">10</span>, ref(count))</span></span>;</span><br><span class="line"><span class="function">thread <span class="title">t2</span><span class="params">(Print,<span class="number">10</span>, ref(count))</span></span>;</span><br><span class="line">t1.<span class="built_in">join</span>();</span><br><span class="line">t2.<span class="built_in">join</span>();</span><br></pre></td></tr></table></figure><p>使用了该库函数之后，编译不再报错，main中的值也成功被修改</p><p><img                       lazyload                     alt="image"                     data-src="https://img1.musnow.top/i/2023/02/63f1e573a7d52.png"                      alt="image-20230219170142211"                ></p><p>通过ref传递的参数，也会遵守函数本身的变量规则。如果函数本身没有采用引用传参，则还是调用传值参数，会进行拷贝；</p><p><img                       lazyload                     alt="image"                     data-src="https://img1.musnow.top/i/2023/02/63f1e703647b4.png"                      alt="image-20230219170821981"                ></p><p>为了避免后续出现这种问题，可以给所有对线程的左值传参都带上ref😏比如给两个线程函数传入同一把锁的时候，就需要采用<code>ref</code>进行引用传参</p><h1 id="4-指令重排"><a href="#4-指令重排" class="headerlink" title="4.指令重排"></a>4.指令重排</h1><blockquote><p><a class="link"   href="https://zhuanlan.zhihu.com/p/271701839" >谈谈指令重排 - 知乎<i class="fas fa-external-link-alt"></i></a></p><p><a class="link"   href="https://developer.aliyun.com/article/1155673#:~:text=%E6%8C%87%E4%BB%A4%E9%87%8D%E6%8E%92%E7%9A%84%E6%96%B9%E5%BC%8F%201%20%E7%BC%96%E8%AF%91%E5%99%A8%E4%BC%98%E5%8C%96%20%E9%87%8D%E6%96%B0%E5%AE%89%E6%8E%92%E8%AF%AD%E5%8F%A5%E7%9A%84%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F%202,%E6%8C%87%E4%BB%A4%E5%B9%B6%E8%A1%8C%E9%87%8D%E6%8E%92%20%E5%88%A9%E7%94%A8%E6%8C%87%E4%BB%A4%E7%BA%A7%E5%B9%B6%E8%A1%8C%E6%8A%80%E6%9C%AF%E5%B0%86%E5%A4%9A%E4%B8%AA%E6%8C%87%E4%BB%A4%E5%B9%B6%E8%A1%8C%E6%89%A7%E8%A1%8C%EF%BC%8C%E5%A6%82%E6%9E%9C%E6%8C%87%E4%BB%A4%E4%B9%8B%E5%89%8D%E6%B2%A1%E6%9C%89%E6%95%B0%E6%8D%AE%E4%BE%9D%E8%B5%96%EF%BC%8C%E5%A4%84%E7%90%86%E5%99%A8%E5%8F%AF%E4%BB%A5%E6%94%B9%E5%8F%98%E5%AF%B9%E5%BA%94%E6%9C%BA%E5%99%A8%E6%8C%87%E4%BB%A4%E7%9A%84%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F%203%20%E5%86%85%E5%AD%98%E7%B3%BB%E7%BB%9F%E9%87%8D%E6%8E%92%20%E7%94%B1%E4%BA%8E%E5%A4%84%E7%90%86%E4%BD%BF%E7%94%A8%E7%BC%93%E5%AD%98%E5%92%8C%E8%AF%BB%E5%86%99%E7%BC%93%E5%86%B2%E5%8C%BA%EF%BC%8C%E6%89%80%E4%BB%A5%E5%AE%83%E4%BB%AC%E6%98%AF%E4%B9%B1%E5%BA%8F%E7%9A%84" >面试官: 有了解过指令重排吗，什么是happens-before<i class="fas fa-external-link-alt"></i></a></p></blockquote><h2 id="4-1-什么是重排序"><a href="#4-1-什么是重排序" class="headerlink" title="4.1 什么是重排序"></a>4.1 什么是重排序</h2><p>首先，什么是重排序❓计算机在执行过程中，为了提高性能，会对编译器和编译器做<code>指令重排</code>。</p><p>这么做为啥可以提高性能呢❓</p><p>我们知道计算机在执行的时候都是一个个指令去执行，不同的指令可能操作的硬件不一样，在执行的过程中可能会产生<code>中断</code>。</p><p>打个比方，两个指令a和b他们操作的东西各不相同，如果加载a的时候停顿了，b就加载不到，但是实际上它们互补影响，我也可以先加载b在加载a，所以<code>指令重排</code>是减少停顿的一种方法，这样大大提高了效率。</p><h3 id="4-1-1-指令重排的方式"><a href="#4-1-1-指令重排的方式" class="headerlink" title="4.1.1 指令重排的方式"></a>4.1.1 指令重排的方式</h3><p>指令重排一般分为以下三种</p><ul><li><code>编译器优化</code> 重新安排语句的执行顺序</li><li><code>指令并行重排</code> 利用指令级并行技术将多个指令并行执行，如果指令之前没有数据依赖，处理器可以改变对应机器指令的执行顺序</li><li><code>内存系统重排</code> 由于处理使用缓存和读写缓冲区，所以它们是乱序的</li></ul><p>指令重排可以保证<code>串行语义</code>一致，但是没有义务保证<code>多线程间的语义</code>也一致**。所以在多线程下，指令重排序可能会导致一些问题</p><h2 id="4-2-实际场景"><a href="#4-2-实际场景" class="headerlink" title="4.2 实际场景"></a>4.2 实际场景</h2><p>以懒汉的单例模式为例</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取单例对象</span></span><br><span class="line"><span class="function"><span class="type">static</span> InfoMgr* <span class="title">GetInstance</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (_sp == <span class="literal">nullptr</span>)<span class="comment">//第一次检测保证单例</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function">unique_lock&lt;mutex&gt; <span class="title">lock</span><span class="params">(_mtx)</span></span>;</span><br><span class="line">        <span class="keyword">if</span> (_sp == <span class="literal">nullptr</span>)<span class="comment">//第二次检测保证线程安全</span></span><br><span class="line">        &#123;</span><br><span class="line">            _sp = <span class="keyword">new</span> InfoMgr;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> _sp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一般情况下，<code>new</code>一个新对象，执行的顺序应该是这样的</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">operator new</span><br><span class="line">构造对象</span><br><span class="line">赋值给_sp</span><br></pre></td></tr></table></figure><p>但编译器如果进行了指令重排，可能就会变成这样</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">operator new</span><br><span class="line">赋值给_sp</span><br><span class="line">构造对象</span><br></pre></td></tr></table></figure><p>如果一个线程执行到第二步<code>赋值给_sp</code>的时候，因为时间片到了被切换走了；其他线程来获取单例，就会导致<code>_sp</code>变量是一个已经被赋值了，但是其指向的是<strong>没有初始化的空对象</strong>，这是错误的！</p><h2 id="4-3-可行的解决办法：内存栅栏"><a href="#4-3-可行的解决办法：内存栅栏" class="headerlink" title="4.3 可行的解决办法：内存栅栏"></a>4.3 可行的解决办法：内存栅栏</h2><p>所谓内存栅栏，是系统提供的的接口，用于禁止cpu对指令的优化；</p><blockquote><p><a class="link"   href="https://blog.csdn.net/qq_16498553/article/details/128030833" >https://blog.csdn.net/qq_16498553/article/details/128030833<i class="fas fa-external-link-alt"></i></a></p></blockquote><p>但内存栈栏是系统接口，没有跨平台性；这里只做了解，知道有这个问题即可！</p><hr><p>在一般情况下，我们不需要担心<code>4.2</code>中提到的问题，因为指令优化是有严格规则的，不会对赋值和构造这类指令进行胡乱优化（因为这样优化并不会有效率提升啊）</p><p>但这也需要看具体平台的底层实现了！</p><h1 id="5-获取线程返回值"><a href="#5-获取线程返回值" class="headerlink" title="5.获取线程返回值"></a>5.获取线程返回值</h1><h2 id="5-1-输出型参数"><a href="#5-1-输出型参数" class="headerlink" title="5.1 输出型参数"></a>5.1 输出型参数</h2><p>在C语言中，想获取线程返回值，需要使用输出型参数（C++可以用引用传值）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">Add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b,<span class="type">int</span>&amp; out)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">out = a + b;</span><br><span class="line"><span class="keyword">return</span> out;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test2</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> ret = <span class="number">0</span>;</span><br><span class="line"><span class="function">thread <span class="title">t2</span><span class="params">(Add, <span class="number">10</span>, <span class="number">39</span>, ref(ret))</span></span>;</span><br><span class="line">t2.<span class="built_in">join</span>();</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;main: &quot;</span> &lt;&lt; ret &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img                       lazyload                     alt="image"                     data-src="https://img1.musnow.top/i/2023/02/63f21f423ea1b.png"                      alt="image-20230219210821383"                ></p><h2 id="5-2-lambda"><a href="#5-2-lambda" class="headerlink" title="5.2 lambda"></a>5.2 lambda</h2><p>在C++中，还可以使用lambda表达式，来在<code>main</code>中获取线程的返回值</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">Add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test2</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> ret = <span class="number">0</span>;</span><br><span class="line"><span class="function">thread <span class="title">t1</span><span class="params">([&amp;ret]() &#123; ret = Add(<span class="number">10</span>, <span class="number">29</span>); &#125;)</span></span>;</span><br><span class="line">t1.<span class="built_in">join</span>();</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;main: &quot;</span> &lt;&lt; ret &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img                       lazyload                     alt="image"                     data-src="https://img1.musnow.top/i/2023/02/63f219625e81a.png"                      alt="image-20230219204317460"                ></p><h1 id="6-函数重载问题"><a href="#6-函数重载问题" class="headerlink" title="6.函数重载问题"></a>6.函数重载问题</h1><p>在我测试的时候发现，如果一个函数具有重载，线程是不支持的；</p><p>具体的原因嘛，我猜和线程构造的可变模板参数有关系。</p><p><img                       lazyload                     alt="image"                     data-src="https://img1.musnow.top/i/2023/02/63f22aa4c21de.png"                      alt="img"                ></p><p>百度了一下，解决办法，是给第一个参数传入一个<strong>函数指针</strong>或者fuctional对象，手动指定使用的是哪一个函数。</p><p>当然，还有一个解决办法：线程调用的函数不要有重载😂</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">Add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b,<span class="type">int</span>&amp; out)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">out = a + b;</span><br><span class="line"><span class="keyword">return</span> out;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> tmp = a + b;</span><br><span class="line">cout &lt;&lt; tmp &lt;&lt; endl;;</span><br><span class="line"><span class="keyword">return</span> tmp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test2</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> ret = <span class="number">0</span>;</span><br><span class="line"><span class="comment">// 使用函数指针指定对应的函数</span></span><br><span class="line"><span class="function">thread <span class="title">t2</span><span class="params">(<span class="keyword">static_cast</span>&lt;<span class="type">int</span>(*)(<span class="type">int</span> a, <span class="type">int</span> b, <span class="type">int</span>&amp; out)&gt;(Add), <span class="number">10</span>, <span class="number">39</span>, ref(ret))</span></span>;</span><br><span class="line">t2.<span class="built_in">join</span>();</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;main: &quot;</span> &lt;&lt; ret &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img                       lazyload                     alt="image"                     data-src="https://img1.musnow.top/i/2023/02/63f22bfb930fa.png"                      alt="image-20230219220238736"                ></p><h1 id="7-this-thread"><a href="#7-this-thread" class="headerlink" title="7.this_thread"></a>7.this_thread</h1><p>std库中还用命名空间对线程的一些操作进行了封装</p><p><img                       lazyload                     alt="image"                     data-src="https://img1.musnow.top/i/2023/02/63f3137e63079.png"                      alt="image-20230220143023521"                ></p><ul><li>get_id 获取线程id号（其实线程类里面已经有这个东东了，但是为了方便函数中直接调用，又多开了一个函数）</li><li>yield 放弃自己的时间片</li><li>sleep_until 休眠到一个时间点（比如睡到明天早八）</li><li>sleep_for 休眠一定时间（睡2分钟）</li></ul><p>下面来对后面三个函数做一点解释（第一个就不解释了哈）</p><h2 id="7-1-yield"><a href="#7-1-yield" class="headerlink" title="7.1 yield"></a>7.1 yield</h2><p>yield的作用是让出当前线程的时间片；</p><p>我们知道每一个线程运行时都会有一个自己的时间片，时间片到了，就会进行线程的切换；</p><p>以下面的场景为例</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">volatile</span> <span class="type">bool</span> ready = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">count1m</span><span class="params">(<span class="type">int</span> id)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// 如果main没有设置ready信号，线程会一直让出自己的时间片，不会运行</span></span><br><span class="line"><span class="keyword">while</span> (!ready) </span><br><span class="line">&#123;            </span><br><span class="line">this_thread::<span class="built_in">yield</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 开始运行，++数据</span></span><br><span class="line"><span class="keyword">volatile</span> <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (i=<span class="number">0</span>; i &lt; <span class="number">10000000</span>; i++) </span><br><span class="line">&#123; </span><br><span class="line">; <span class="comment">// 循环体啥都不干</span></span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; id;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test4</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">thread threads[<span class="number">10</span>];</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;创建10个线程 计数\n&quot;</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i) </span><br><span class="line">&#123;</span><br><span class="line">threads[i] = <span class="built_in">thread</span>(count1m, i);</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;创建10个线程 完毕\n&quot;</span>;</span><br><span class="line">ready = <span class="literal">true</span>;<span class="comment">//设置状态，让线程开始运行</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;main set ture: &quot;</span> &lt;&lt; ready &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span>&amp; th : threads) </span><br><span class="line">&#123;</span><br><span class="line">th.<span class="built_in">join</span>();</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;\nmain join 成功&quot;</span> &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行结果</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">创建10个线程 计数</span><br><span class="line">创建10个线程 完毕</span><br><span class="line">main set ture: 1</span><br><span class="line">3746089215</span><br><span class="line">main join 成功</span><br></pre></td></tr></table></figure><p>在这个场景中，每一个线程被设置了task后，都会先进入一个while循环，等待主线程进行ready的设置</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (!ready) </span><br><span class="line">&#123;            </span><br><span class="line">;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时我们就可以在while循环中进行yield让线程<strong>让出自己</strong>的时间片。否则这个线程会一直疯狂访问ready，导致cpu占用提高。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 如果main没有设置ready信号，线程会一直让出自己的时间片，不会运行</span></span><br><span class="line"><span class="keyword">while</span> (!ready) </span><br><span class="line">&#123;            </span><br><span class="line">this_thread::<span class="built_in">yield</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这种<strong>轮询检测</strong>的场景下，使用yield能避免某一个线程长时间占用执行流，解决了其他线程的饥饿问题。</p><h2 id="7-2-sleep-until"><a href="#7-2-sleep-until" class="headerlink" title="7.2 sleep_until"></a>7.2 sleep_until</h2><p>用<a class="link"   href="https://legacy.cplusplus.com/reference/thread/this_thread/sleep_until/" >cplusplus<i class="fas fa-external-link-alt"></i></a>的示例代码来学习使用方法，这里涉及到了多个库函数，详见注释</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;chrono&gt;</span>  <span class="comment">//std::chrono</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iomanip&gt;</span> <span class="comment">//std::put_time</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ctime&gt;</span>   <span class="comment">//std::time_t, std::tm, std::localtime, std::mktime</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 直接把main当作一个线程</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test5</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">time_t</span> tt = chrono::system_clock::<span class="built_in">to_time_t</span>(chrono::system_clock::<span class="built_in">now</span>()); <span class="comment">// 获取当前时间的时间戳</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">tm</span>* ptm = <span class="built_in">localtime</span>(&amp;tt); <span class="comment">// 设置一个tm结构体，从当前时间戳创建</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Current time: &quot;</span> &lt;&lt; <span class="built_in">put_time</span>(ptm, <span class="string">&quot;%X&quot;</span>) &lt;&lt; <span class="string">&#x27;\n&#x27;</span>; <span class="comment">// 打印当前时间</span></span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Waiting for the next minute to begin...\n&quot;</span>;</span><br><span class="line">(ptm-&gt;tm_min)++; <span class="comment">// 设置ptm的min为下一分钟</span></span><br><span class="line">ptm-&gt;tm_sec = <span class="number">0</span>; <span class="comment">// 下一分钟的第0s</span></span><br><span class="line">this_thread::<span class="built_in">sleep_until</span>(chrono::system_clock::<span class="built_in">from_time_t</span>(<span class="built_in">mktime</span>(ptm))); <span class="comment">// 等待下一分钟开始运行</span></span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="built_in">put_time</span>(ptm, <span class="string">&quot;%X&quot;</span>) &lt;&lt; <span class="string">&quot; reached!\n&quot;</span>; <span class="comment">// 再次打印当前时间</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果如下，会等到下一分钟的第0s继续执行</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Current time: 15:13:40</span><br><span class="line">Waiting for the next minute to begin...</span><br><span class="line">15:14:00 reached!</span><br></pre></td></tr></table></figure><h2 id="7-3-sleep-for"><a href="#7-3-sleep-for" class="headerlink" title="7.3 sleep_for"></a>7.3 sleep_for</h2><p>这个函数的作用和windows、linux下都有的sleep函数一样，是睡指定的时间</p><p>需要用std中的<code>chrono</code>模块来指定运行的时间，支持从小时一直到纳秒</p><p><img                       lazyload                     alt="image"                     data-src="https://img1.musnow.top/i/2023/02/63f341a573324.png"                      alt="image-20230220174718938"                ></p><p>示例如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">test6</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">time_t</span> now;</span><br><span class="line"><span class="built_in">time</span>(&amp;now);<span class="comment">//获取当前时间戳</span></span><br><span class="line">cout &lt;&lt; now &lt;&lt; endl;</span><br><span class="line">this_thread::<span class="built_in">sleep_for</span>(chrono::<span class="built_in">seconds</span>(<span class="number">30</span>));<span class="comment">//睡30s</span></span><br><span class="line"><span class="built_in">time</span>(&amp;now);<span class="comment">//获取当前时间戳</span></span><br><span class="line">cout &lt;&lt; now &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，进程确实休眠了30s</p><p><img                       lazyload                     alt="image"                     data-src="https://img1.musnow.top/i/2023/02/63f31fbf07392.png"                      alt="image-20230220152240203"                ></p><h1 id="8-mutex"><a href="#8-mutex" class="headerlink" title="8.mutex"></a>8.mutex</h1><p>有了线程，那肯定离不开锁；关于线程加锁的问题，详见<a href="https://blog.musnow.top/2022/12/23/note_linux/19%E7%BA%BF%E7%A8%8B%E4%BA%92%E6%96%A5/#4-3-%E7%BA%BF%E7%A8%8B%E5%8A%A0%E9%94%81">我的linux博客</a></p><p>这里只对C++中锁的只用方法做一定演示</p><h2 id="8-1-构造"><a href="#8-1-构造" class="headerlink" title="8.1 构造"></a>8.1 构造</h2><p><img                       lazyload                     alt="image"                     data-src="https://img1.musnow.top/i/2023/02/63f3482920bbf.png"                      alt="image-20230220181505745"                ></p><p>锁的构造相对较简单，只有一个无参的构造，其不支持拷贝构造（比如函数传参中，一个锁被拷贝了，就失去了意义）</p><h2 id="8-2-成员函数"><a href="#8-2-成员函数" class="headerlink" title="8.2 成员函数"></a>8.2 成员函数</h2><p>其余成员就是一个锁的基本接口，对应的也是<code>pthread_mutex</code>中的几个接口</p><ul><li>lock 加锁，不能申请锁则阻塞等待</li><li>try_lock 测试是否能申请锁，不能申请则return</li><li>unlock 解锁</li></ul><p><img                       lazyload                     alt="image"                     data-src="https://img1.musnow.top/i/2023/02/63f3486d109dd.png"                      alt="image-20230220181614701"                ></p><h2 id="8-3-场景"><a href="#8-3-场景" class="headerlink" title="8.3 场景"></a>8.3 场景</h2><p>所谓加锁，保护的就是临界资源；比如在下面的代码示例中，全局变量<code>count1</code>就是一个临界资源，其能够被多个执行流访问。</p><p><font color=Red>注意：</font>如果你展开了std命名空间，其中有一个<code>count</code>函数，会和你自己定义的全局<code>count</code>变量冲突。刚开始我就定义了count，发现报错变量不明确。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> TOP 100</span></span><br><span class="line"><span class="keyword">volatile</span> <span class="type">int</span> count1 = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (count1 == TOP)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; this_thread::<span class="built_in">get_id</span>() &lt;&lt; <span class="string">&quot; : &quot;</span> &lt;&lt; count1++ &lt;&lt; endl;</span><br><span class="line">this_thread::<span class="built_in">sleep_for</span>(chrono::<span class="built_in">milliseconds</span>(<span class="number">10</span>));</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; this_thread::<span class="built_in">get_id</span>() &lt;&lt; <span class="string">&quot; : &quot;</span> &lt;&lt; count1 &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test7</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">thread threading[<span class="number">10</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">threading[i] = <span class="built_in">thread</span>(func);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">threading[i].<span class="built_in">join</span>();</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;main: &quot;</span> &lt;&lt; count1 &lt;&lt; endl;</span><br><span class="line">this_thread::<span class="built_in">sleep_for</span>(chrono::<span class="built_in">seconds</span>(<span class="number">2</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试的时候，就能看到一个很明显的冲突结果。31752线程已经++到100了，结果它努力的结果被其他两个线程直接复写；</p><p>当然，这里也有可能是显示器乱序打印的结果。要知道，显示器也是一个临界资源</p><p><img                       lazyload                     alt="image"                     data-src="https://img1.musnow.top/i/2023/02/63f34965d82fb.png"                      alt="image-20230220182023292"                ></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">mutex mtx;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (count1 == TOP)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 加锁的粒度要低</span></span><br><span class="line">mtx.<span class="built_in">lock</span>();</span><br><span class="line">cout &lt;&lt; this_thread::<span class="built_in">get_id</span>() &lt;&lt; <span class="string">&quot; : &quot;</span> &lt;&lt; count1++ &lt;&lt; endl;</span><br><span class="line">mtx.<span class="built_in">unlock</span>();</span><br><span class="line">this_thread::<span class="built_in">sleep_for</span>(chrono::<span class="built_in">milliseconds</span>(<span class="number">10</span>));</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; this_thread::<span class="built_in">get_id</span>() &lt;&lt; <span class="string">&quot; : &quot;</span> &lt;&lt; count1 &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>给访问count的函数添加上锁，就能避免掉上面出现的问题</p><p><img                       lazyload                     alt="image"                     data-src="https://img1.musnow.top/i/2023/02/63f34a2934127.png"                      alt="image-20230220182338849"                ></p><h1 id="9-CAS原子操作"><a href="#9-CAS原子操作" class="headerlink" title="9.CAS原子操作"></a>9.CAS原子操作</h1><p>在系统中，提供了一些指令，来实现原子操作！</p><h2 id="9-1-原理"><a href="#9-1-原理" class="headerlink" title="9.1 原理"></a>9.1 原理</h2><p>Compare And Set（或Compare And Swap），简称CAS。其是解决多线程<strong>并行</strong>情况下使用锁造成性能损耗的一种机制，采用这种<strong>无锁的原子操作</strong>可以实现线程安全，避免加锁的笨重性。</p><p>CAS操作包含三个操作数：内存位置（V）、预期原值（A）、新值(B)</p><p>具体操作流程请看下图：</p><p><img                       lazyload                     alt="image"                     data-src="https://img1.musnow.top/i/2023/02/63f362c326f23.png"                      alt="image-20230220200715839"                ></p><p>如果上面的图看不懂，还可以看下面这个图</p><p><img                       lazyload                     alt="image"                     data-src="https://img1.musnow.top/i/2023/02/63f363eb304d7.png"                      alt="image-20230220201332945"                ></p><p>文字描述如下：</p><ul><li>如果内存位置的值（V）与预期原值（A）相同，处理器会将该位置的值<strong>更新</strong>为新值（B） CAS 操作成功！</li><li>否则，处理器不做任何更改，只需要将<strong>当前位置的值进行返回</strong>即可</li></ul><p>CAS是实现<strong>自旋锁</strong>的基础，CAS 利用CPU指令保证了操作的原子性，以达到锁的效果，循环这个指令，直到成功为止。</p><h2 id="9-2-问题"><a href="#9-2-问题" class="headerlink" title="9.2 问题"></a>9.2 问题</h2><p>CAS也不是万能的，其在如下场景下可能会出现问题</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1.有线程a和b</span><br><span class="line">2.有全局变量，初始值为1</span><br><span class="line">3.线程a先来访问，拿走了初始值1</span><br><span class="line">4.发生线程切换，线程b来访问，拿走初始值1，更新为2，又修改回1</span><br><span class="line">5.发生线程切换，线程a继续访问，此时值依旧是1，线程a会认为没有问题，写入</span><br></pre></td></tr></table></figure><p>你可以看到，在上面的场景中，有一个线程把全局变量修改了之后又改了回去，这时候就没有办法从<strong>取值</strong>判断变量是否还是“原来的那个”了</p><blockquote><p>针对这种情况，java并发包中提供了一个带有标记的原子引用类”AtomicStampedReference”，它可以通过控制变量值的版本来保证CAS的正确性。</p></blockquote><p>C&#x2F;C++中有没有办法解决这个问题呢？我没百度到😂</p><h1 id="10-lock-guard"><a href="#10-lock-guard" class="headerlink" title="10.lock_guard"></a>10.lock_guard</h1><p>人如其名，这个类是一个守护锁。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">Mutex</span>&gt; <span class="keyword">class</span> <span class="title class_">lock_guard</span>;</span><br></pre></td></tr></table></figure><p>其运用了RAII的思路，能在构造的时候加锁，析构的时候解锁。我们就不需要自己操作了。</p><p>毕竟，代码一长起来，一个锁有没有被解开，是真的搞不清楚😥</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">mutex mtx;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test7</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> x = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> n = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> m = <span class="number">1000000</span>;</span><br><span class="line">cin &gt;&gt; n;</span><br><span class="line"><span class="function">vector&lt;thread&gt; <span class="title">threading</span><span class="params">(n)</span></span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">&#123;</span><br><span class="line">threading[i] = <span class="built_in">thread</span>([&amp;]() &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i++)</span><br><span class="line">&#123;</span><br><span class="line">lock_guard&lt;mutex&gt; <span class="built_in">t</span>(mtx);<span class="comment">//自动加锁解锁</span></span><br><span class="line">x++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">&#123;</span><br><span class="line">threading[i].<span class="built_in">join</span>();</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;main: &quot;</span> &lt;&lt; x &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img                       lazyload                     alt="image"                     data-src="https://img1.musnow.top/i/2023/02/63f366f3c1b90.png"                      alt="image-20230220202628663"                ></p><p>如果for循环中需要执行的代码很多，而只有x是临界资源的话，那就需要我们<code>手动控制</code>一下作用域<code>&#123;&#125;</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i++)</span><br><span class="line">&#123;</span><br><span class="line">             <span class="comment">//其他代码</span></span><br><span class="line">             &#123;</span><br><span class="line">                 <span class="function">lock_guard&lt;mutex&gt; <span class="title">t</span><span class="params">(mtx)</span></span>;<span class="comment">//自动加锁解锁</span></span><br><span class="line">   x++;</span><br><span class="line">             &#125;</span><br><span class="line">             <span class="comment">//其他代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="11-unique-lock"><a href="#11-unique-lock" class="headerlink" title="11.unique_lock"></a>11.unique_lock</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">Mutex</span>&gt; <span class="keyword">class</span> <span class="title class_">unique_lock</span>;</span><br></pre></td></tr></table></figure><p>如果你学习过智能指针，那肯定就知道这个命名的含义；</p><p><code>unique_lock</code>是<code>lock_graud</code>的增强版本，其在支持自动加锁解锁的前提下，还支持手动加锁解锁；</p><h2 id="11-1-使用示例"><a href="#11-1-使用示例" class="headerlink" title="11.1 使用示例"></a>11.1 使用示例</h2><p>下面就是一个标准的使用场景</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">threading[i] = <span class="built_in">thread</span>([&amp;]() &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i++)</span><br><span class="line">&#123;</span><br><span class="line">unique_lock&lt;mutex&gt; <span class="built_in">t</span>(mtx);<span class="comment">//自动加锁</span></span><br><span class="line">x++;</span><br><span class="line">t.<span class="built_in">unlock</span>(); <span class="comment">//手动解锁</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 模拟其他工作</span></span><br><span class="line">this_thread::<span class="built_in">sleep_for</span>(chrono::<span class="built_in">milliseconds</span>(<span class="number">100</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 又需要访问临界资源</span></span><br><span class="line">t.<span class="built_in">lock</span>();<span class="comment">// 手动解锁</span></span><br><span class="line">x++;</span><br><span class="line">&#125;<span class="comment">// 出作用域，自动解锁</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2 id="11-2-try-lock"><a href="#11-2-try-lock" class="headerlink" title="11.2 try_lock"></a>11.2 try_lock</h2><p>除了最基础的try_lock之外，这个类还支持for和until，和<code>this_thread</code>中的sleep是一样的含义</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">try_lock</span><br><span class="line">Lock mutex if not locked (public member function )</span><br><span class="line"></span><br><span class="line">try_lock_for</span><br><span class="line">Try to lock mutex during time span (public member function )</span><br><span class="line">加锁一直到指定时间解锁（加锁到明天早八）</span><br><span class="line"></span><br><span class="line">try_lock_until</span><br><span class="line">Try to lock mutex until time point (public member function )</span><br><span class="line">加锁xx时间（加锁100秒，时间到了自动解锁）</span><br></pre></td></tr></table></figure><p>时间到了之后，这个函数会进行解锁。如果用户在这之前已经手动解锁了，则什么都不会做</p><h2 id="11-3-release"><a href="#11-3-release" class="headerlink" title="11.3 release"></a>11.3 release</h2><p>这个函数的作用就很独特了，其将自己管理的锁释放掉，不再管理这个锁</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">mutex_type* <span class="title">release</span><span class="params">()</span> <span class="keyword">noexcept</span></span>;</span><br></pre></td></tr></table></figure><p>调用这个函数会返回托管互斥对象的<strong>指针</strong>，释放其所有权。调用后，unique_lock对象不再管理任何互斥对象（即，它处于与if默认构造相同的状态）。</p><p> 注意，此函数不会<strong>锁定或解锁</strong>返回的互斥对象。</p><p>说人话就是，不需要你RALL来管理这个锁了，交给用户自己管理！</p><h1 id="12-share-ptr"><a href="#12-share-ptr" class="headerlink" title="12.share_ptr"></a>12.share_ptr</h1><blockquote><p><code>share_ptr</code>的完整代码请看我的 <a class="link"   href="https://gitee.com/musnow/learn_cpp_code/tree/master/Cpp/23-02-19%20thread" >Gitee<i class="fas fa-external-link-alt"></i></a></p></blockquote><p>在智能指针中，<code>share_ptr</code>采用引用计数来判断有多少次拷贝（拷贝构造、赋值重载），只有拷贝计数器为1的时候，析构才需要释放资源。</p><p>在<code>share_ptr</code>内部有一个变量进行计数。既然有一个计数变量，那就需要保证多线程执行时的原子性！</p><h2 id="12-1-引用计数加锁"><a href="#12-1-引用计数加锁" class="headerlink" title="12.1 引用计数加锁"></a>12.1 引用计数加锁</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">AddRef</span><span class="params">()</span><span class="comment">//新增引用</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">_pMutex-&gt;<span class="built_in">lock</span>();</span><br><span class="line"></span><br><span class="line">++(*_pRefCount);</span><br><span class="line"></span><br><span class="line">_pMutex-&gt;<span class="built_in">unlock</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="12-2-释放"><a href="#12-2-释放" class="headerlink" title="12.2 释放"></a>12.2 释放</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Release</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">bool</span> flag = <span class="literal">false</span>;<span class="comment">//判断锁是否需要被释放</span></span><br><span class="line"></span><br><span class="line">_pMutex-&gt;<span class="built_in">lock</span>();</span><br><span class="line"><span class="keyword">if</span> (--(*_pRefCount) == <span class="number">0</span> &amp;&amp; _ptr)</span><br><span class="line">&#123;</span><br><span class="line">               <span class="comment">//进入了这个函数，代表引用计数为0</span></span><br><span class="line"><span class="keyword">delete</span> _ptr;</span><br><span class="line"><span class="keyword">delete</span> _pRefCount;</span><br><span class="line"><span class="comment">//标识需要释放锁</span></span><br><span class="line">flag = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">_pMutex-&gt;<span class="built_in">unlock</span>();<span class="comment">//解锁</span></span><br><span class="line"><span class="comment">//释放锁</span></span><br><span class="line"><span class="keyword">if</span> (flag)&#123;</span><br><span class="line"><span class="keyword">delete</span> _pMutex;</span><br><span class="line">           &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="12-3-注意事项"><a href="#12-3-注意事项" class="headerlink" title="12.3 注意事项"></a>12.3 注意事项</h2><p><code>share_ptr</code>的加锁只限于这个类对象本身的安全性，这个锁并<strong>不是</strong>用来保护<code>share_ptr</code>所指向的资源的！</p><h1 id="13-atomic"><a href="#13-atomic" class="headerlink" title="13.atomic"></a>13.atomic</h1><p>在全局变量中，计数器是很常用的类型。所以C++中还提供了一个可以进行原子操作的类，对这个变量进行的操作是具有原子性的，不需要我们进行加锁解锁</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt; <span class="keyword">struct</span> <span class="title class_">atomic</span>;</span><br></pre></td></tr></table></figure><h2 id="13-1-基本使用"><a href="#13-1-基本使用" class="headerlink" title="13.1 基本使用"></a>13.1 基本使用</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">atomic&lt;<span class="type">int</span>&gt; val=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test8</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; val &lt;&lt; endl;</span><br><span class="line">val++;</span><br><span class="line">cout &lt;&lt; val &lt;&lt; endl;</span><br><span class="line">val = <span class="number">20</span>;</span><br><span class="line">cout &lt;&lt; val &lt;&lt; endl;</span><br><span class="line">val--;</span><br><span class="line">cout &lt;&lt; val &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果是int类型，原子变量和普通的int变量的使用没有什么区别！</p><p><img                       lazyload                     alt="image"                     data-src="https://img1.musnow.top/i/2023/02/63f4830c02ad0.png"                      alt="image-20230221163836363"                ></p><p>可以看到，重载了以后，原子变量支持<code>++  --</code>，也支持直接赋值</p><p><img                       lazyload                     alt="image"                     data-src="https://img1.musnow.top/i/2023/02/63f48604478a8.png"                      alt="image-20230221165116759"                ></p><p>不过，这些方法标明了，只有整形家族和指针类型可以使用！</p><p><img                       lazyload                     alt="image"                     data-src="https://img1.musnow.top/i/2023/02/63f4862eea490.png"                      alt="image-20230221165159400"                ></p><h2 id="13-2-operator-x3D"><a href="#13-2-operator-x3D" class="headerlink" title="13.2 operator &#x3D;"></a>13.2 operator &#x3D;</h2><p>原子变量可以直接赋值，是因为其重载了 <code>operator =</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//set value (1)</span></span><br><span class="line">T <span class="keyword">operator</span>= (T val) <span class="keyword">noexcept</span>;</span><br><span class="line">T <span class="keyword">operator</span>= (T val) <span class="keyword">volatile</span> <span class="keyword">noexcept</span>;</span><br><span class="line"><span class="comment">//copy [deleted] (2)</span></span><br><span class="line">atomic&amp; <span class="keyword">operator</span>= (<span class="type">const</span> atomic&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">atomic&amp; <span class="keyword">operator</span>= (<span class="type">const</span> atomic&amp;) <span class="keyword">volatile</span> = <span class="keyword">delete</span>;</span><br></pre></td></tr></table></figure><h2 id="13-3-operator-T-x2F-load"><a href="#13-3-operator-T-x2F-load" class="headerlink" title="13.3 operator T&#x2F;load"></a>13.3 operator T&#x2F;load</h2><p><code>operator T </code>的作用，是支持<strong>隐式类型</strong>转换，这样原子变量在进行if比较的时候，会转换成重载后的类型</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">operator</span> <span class="title">T</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">volatile</span> <span class="keyword">noexcept</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">operator</span> <span class="title">T</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">noexcept</span></span>;</span><br></pre></td></tr></table></figure><p>在vs2019里面跳转源码，能看到重载后的这两个函数，其实是调用了load方法</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">_Ty</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">atomic</span> : _Choose_atomic_base_t&lt;_Ty&gt;&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line"><span class="keyword">operator</span> _Ty() <span class="type">const</span> <span class="keyword">volatile</span> <span class="keyword">noexcept</span> &#123;</span><br><span class="line">        <span class="built_in">static_assert</span>(_Deprecate_non_lock_free_volatile&lt;_Ty&gt;, <span class="string">&quot;Never fails&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>-&gt;<span class="built_in">load</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">operator</span> _Ty() <span class="type">const</span> <span class="keyword">noexcept</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>-&gt;<span class="built_in">load</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img                       lazyload                     alt="image"                     data-src="https://img1.musnow.top/i/2023/02/63f4844ba3f8a.png"                      alt="image-20230221164356074"                ></p><p>查看cplusplus的解释，load方法就是返回了其内部所包含的值</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">T <span class="title">load</span> <span class="params">(memory_order sync = memory_order_seq_cst)</span> <span class="type">const</span> <span class="keyword">volatile</span> <span class="keyword">noexcept</span></span>;</span><br><span class="line"><span class="function">T <span class="title">load</span> <span class="params">(memory_order sync = memory_order_seq_cst)</span> <span class="type">const</span> <span class="keyword">noexcept</span></span>;</span><br></pre></td></tr></table></figure><p><img                       lazyload                     alt="image"                     data-src="https://img1.musnow.top/i/2023/02/63f484917ab03.png"                      alt="image-20230221164506017"                ></p><p>这里还特意标注了，load方法的使用是原子性的</p><h2 id="13-4-exchange"><a href="#13-4-exchange" class="headerlink" title="13.4 exchange"></a>13.4 exchange</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">T <span class="title">exchange</span> <span class="params">(T val, memory_order sync = memory_order_seq_cst)</span> <span class="keyword">volatile</span> <span class="keyword">noexcept</span></span>;</span><br><span class="line"><span class="function">T <span class="title">exchange</span> <span class="params">(T val, memory_order sync = memory_order_seq_cst)</span> <span class="keyword">noexcept</span></span>;</span><br></pre></td></tr></table></figure><p><code>exchange</code>函数的作用是修改原子变量管理的值，其返回值是<strong>修改之前</strong>的变量</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Return value</span><br><span class="line">The contained value before the call.</span><br><span class="line">T is atomic&#x27;s template parameter (the type of the contained value).</span><br></pre></td></tr></table></figure><p>以下面的代码为例</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">atomic&lt;<span class="type">int</span>&gt; val=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test8</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; val &lt;&lt; endl;</span><br><span class="line"><span class="type">int</span> tmp = val.<span class="built_in">exchange</span>(<span class="number">450</span>);</span><br><span class="line">cout &lt;&lt; val &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; tmp &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到tmp接收到的结果是val的初始值0，val本身被修改为450</p><p><img                       lazyload                     alt="image"                     data-src="https://img1.musnow.top/i/2023/02/63f48556ad15c.png"                      alt="image-20230221164823139"                ></p><h2 id="13-5-store"><a href="#13-5-store" class="headerlink" title="13.5 store"></a>13.5 store</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">store</span> <span class="params">(T val, memory_order sync = memory_order_seq_cst)</span> <span class="keyword">volatile</span> <span class="keyword">noexcept</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">store</span> <span class="params">(T val, memory_order sync = memory_order_seq_cst)</span> <span class="keyword">noexcept</span></span>;</span><br></pre></td></tr></table></figure><p>这个函数的作用比exchange简单，其只修改存储的变量，没有返回值</p><hr><p>关于原子变量的介绍就这么多，下面来康康C++中的条件变量</p><h1 id="14-condition-variable"><a href="#14-condition-variable" class="headerlink" title="14.condition_variable"></a>14.condition_variable</h1><blockquote><p>条件变量的概念，参考 <a href="https://blog.musnow.top/2022/12/30/note_linux/20%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5/">linux 线程同步</a></p></blockquote><h2 id="14-1-构造和wait"><a href="#14-1-构造和wait" class="headerlink" title="14.1 构造和wait"></a>14.1 构造和wait</h2><p>条件变量，是用于线程同步操作的一个接口。在C++中，条件变量只有一个空构造</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//default (1)</span></span><br><span class="line"><span class="built_in">condition_variable</span>();</span><br><span class="line"><span class="comment">//copy [deleted] (2)</span></span><br><span class="line"><span class="built_in">condition_variable</span> (<span class="type">const</span> condition_variable&amp;) = <span class="keyword">delete</span>;</span><br></pre></td></tr></table></figure><p>当我们进行wait等待的时候，需要往条件变量内传入一个锁；进入wait函数，开始等待前会先解锁，退出函数前会加锁。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//unconditional (1)</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">wait</span> <span class="params">(unique_lock&lt;mutex&gt;&amp; lck)</span></span>;</span><br><span class="line"><span class="comment">//predicate (2)</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">Predicate</span>&gt;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">wait</span> <span class="params">(unique_lock&lt;mutex&gt;&amp; lck, Predicate pred)</span></span>;</span><br></pre></td></tr></table></figure><p>wait函数除了传入锁，还可以传入一个<code>Predicate pred</code>可执行函数体，来判断条件变量是否满足；</p><p>如果指定了pred，则只有当pred返回false时，该函数才会阻塞；并且只有当它变为true时，通知才能解除阻塞线程（这对于检查<strong>虚假唤醒</strong>特别有用）</p><ul><li>虚假唤醒，指的是一些代码错误的情况下，另外一个线程在条件尚未真正就绪的时候就唤醒了该线程</li><li>添加上判断条件，<strong>能在wait中判断条件是否已经真正满足</strong>，从而避免虚假唤醒</li></ul><p>wait内部对pred的检测是下面这样</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (!<span class="built_in">pred</span>()) <span class="built_in">wait</span>(lck);</span><br></pre></td></tr></table></figure><p>只有pred返回真的时候，才会跳出while循环，唤醒线程。</p><p>除了检测虚假唤醒，我们还可以用该执行体，对不同的线程<strong>指定不同的唤醒条件</strong>！</p><h2 id="14-2-其他接口"><a href="#14-2-其他接口" class="headerlink" title="14.2 其他接口"></a>14.2 其他接口</h2><p>其他接口的使用也很直接，其中wait_for和until前面已经介绍过了</p><ul><li>wait：在条件变量中阻塞等待，等待被唤醒</li><li>notify_one：唤醒在该条件变量等待下的一个线程</li><li>notify_all：唤醒在该条件变量下等待的所有线程</li></ul><p><img                       lazyload                     alt="image"                     data-src="https://img1.musnow.top/i/2023/02/63f48806d52a4.png"                      alt="image-20230221165951372"                ></p><h2 id="14-3-实际用例"><a href="#14-3-实际用例" class="headerlink" title="14.3 实际用例"></a>14.3 实际用例</h2><p>当下我们有两个线程，我们的目标是让t1和t2线程共同管理一个变量i，对其进行++，并实现t1打印奇数，t2打印偶数的功能（二者交错打印）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">test9</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// 目标：t1打印奇数，t2打印偶数，二者交错打印</span></span><br><span class="line">    <span class="type">bool</span> ready = <span class="literal">true</span>;</span><br><span class="line"><span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> n = <span class="number">100</span>;</span><br><span class="line">mutex mtx;</span><br><span class="line">condition_variable cv;</span><br><span class="line"></span><br><span class="line"><span class="comment">// t1打印奇数</span></span><br><span class="line"><span class="function">thread <span class="title">t1</span><span class="params">([&amp;]()&#123;</span></span></span><br><span class="line"><span class="params"><span class="function"><span class="keyword">while</span> (i &lt; n)</span></span></span><br><span class="line"><span class="params"><span class="function">&#123;</span></span></span><br><span class="line"><span class="params"><span class="function">            unique_lock&lt;mutex&gt; lock(mtx);</span></span></span><br><span class="line"><span class="params"><span class="function"></span></span></span><br><span class="line"><span class="params"><span class="function">            cout &lt;&lt; <span class="string">&quot;t1 : &quot;</span> &lt;&lt; this_thread::get_id() &lt;&lt; <span class="string">&quot; : &quot;</span> &lt;&lt; i &lt;&lt; endl;</span></span></span><br><span class="line"><span class="params"><span class="function">            i++;</span></span></span><br><span class="line"><span class="params"><span class="function">&#125;</span></span></span><br><span class="line"><span class="params"><span class="function">&#125;)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// t2打印偶数</span></span><br><span class="line"><span class="function">thread <span class="title">t2</span><span class="params">([&amp;]() &#123;</span></span></span><br><span class="line"><span class="params"><span class="function"><span class="keyword">while</span> (i &lt; n)</span></span></span><br><span class="line"><span class="params"><span class="function">&#123;</span></span></span><br><span class="line"><span class="params"><span class="function">unique_lock&lt;mutex&gt; lock(mtx);</span></span></span><br><span class="line"><span class="params"><span class="function">cout &lt;&lt;<span class="string">&quot;t2 : &quot;</span>&lt;&lt;this_thread::get_id() &lt;&lt; <span class="string">&quot; : &quot;</span> &lt;&lt; i &lt;&lt; endl;</span></span></span><br><span class="line"><span class="params"><span class="function">i++;</span></span></span><br><span class="line"><span class="params"><span class="function">&#125;</span></span></span><br><span class="line"><span class="params"><span class="function">&#125;)</span></span>;</span><br><span class="line"></span><br><span class="line">this_thread::<span class="built_in">sleep_for</span>(chrono::<span class="built_in">seconds</span>(<span class="number">3</span>));</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;t1:&quot;</span> &lt;&lt; t1.<span class="built_in">get_id</span>() &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;t2:&quot;</span> &lt;&lt; t2.<span class="built_in">get_id</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">t1.<span class="built_in">join</span>();</span><br><span class="line">t2.<span class="built_in">join</span>();</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当下已经实现出了二者的基本操作，但直接运行我们会发现，t1都已经打印到99了，t2才开始执行，完全不符合交错打印的需求</p><p><img                       lazyload                     alt="image"                     data-src="https://img1.musnow.top/i/2023/02/63f487e871e3c.png"                      alt="image-20230221165920681"                ></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">thread <span class="title">t1</span><span class="params">([&amp;]()&#123;</span></span></span><br><span class="line"><span class="params"><span class="function"><span class="keyword">while</span> (i &lt; n)</span></span></span><br><span class="line"><span class="params"><span class="function">&#123;</span></span></span><br><span class="line"><span class="params"><span class="function">&#123;</span></span></span><br><span class="line"><span class="params"><span class="function">unique_lock&lt;mutex&gt; lock(mtx);</span></span></span><br><span class="line"><span class="params"><span class="function">cout &lt;&lt; <span class="string">&quot;t1 : &quot;</span> &lt;&lt; this_thread::get_id() &lt;&lt; <span class="string">&quot; : &quot;</span> &lt;&lt; i &lt;&lt; endl;</span></span></span><br><span class="line"><span class="params"><span class="function">i++;</span></span></span><br><span class="line"><span class="params"><span class="function">&#125;</span></span></span><br><span class="line"><span class="params"><span class="function"></span></span></span><br><span class="line"><span class="params"><span class="function">this_thread::sleep_for(chrono::microseconds(<span class="number">100</span>));</span></span></span><br><span class="line"><span class="params"><span class="function">&#125;</span></span></span><br><span class="line"><span class="params"><span class="function">&#125;)</span></span>;</span><br></pre></td></tr></table></figure><p>如果在t1的while循环中加上一个休眠，t2的函数体保持不变，则会发现是t2直接加到了99，才让可怜巴巴的t1访问了临界资源（饥饿问题）</p><p><img                       lazyload                     alt="image"                     data-src="https://img1.musnow.top/i/2023/02/63f48a571b2b9.png"                      alt="image-20230221170943659"                ></p><p>这时候，我们就可以使用条件变量来实现线程相互唤醒和交错打印，代码如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 条件变量测试</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test9</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// 目标：t1打印奇数，t2打印偶数，二者交错打印</span></span><br><span class="line"><span class="type">bool</span> ready = <span class="literal">true</span>;</span><br><span class="line"><span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> n = <span class="number">100</span>;</span><br><span class="line">mutex mtx;</span><br><span class="line">condition_variable cv;</span><br><span class="line"></span><br><span class="line"><span class="comment">// t1打印奇数</span></span><br><span class="line"><span class="function">thread <span class="title">t1</span><span class="params">([&amp;]()&#123;</span></span></span><br><span class="line"><span class="params"><span class="function"><span class="keyword">while</span> (i &lt; n)</span></span></span><br><span class="line"><span class="params"><span class="function">&#123;</span></span></span><br><span class="line"><span class="params"><span class="function">            unique_lock&lt;mutex&gt; lock(mtx);</span></span></span><br><span class="line"><span class="params"><span class="function">            <span class="comment">//ready为假的时候，唤醒t1</span></span></span></span><br><span class="line"><span class="params"><span class="function">            cv.wait(lock, [&amp;ready]()&#123;<span class="keyword">return</span> !ready; &#125;);</span></span></span><br><span class="line"><span class="params"><span class="function"></span></span></span><br><span class="line"><span class="params"><span class="function">            cout &lt;&lt; <span class="string">&quot;t1 : &quot;</span> &lt;&lt; this_thread::get_id() &lt;&lt; <span class="string">&quot; : &quot;</span> &lt;&lt; i &lt;&lt; endl;</span></span></span><br><span class="line"><span class="params"><span class="function">            i++;</span></span></span><br><span class="line"><span class="params"><span class="function"></span></span></span><br><span class="line"><span class="params"><span class="function">            ready = <span class="literal">true</span>;</span></span></span><br><span class="line"><span class="params"><span class="function"></span></span></span><br><span class="line"><span class="params"><span class="function">            cv.notify_one();</span></span></span><br><span class="line"><span class="params"><span class="function">&#125;</span></span></span><br><span class="line"><span class="params"><span class="function">&#125;)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// t2打印偶数</span></span><br><span class="line"><span class="function">thread <span class="title">t2</span><span class="params">([&amp;]() &#123;</span></span></span><br><span class="line"><span class="params"><span class="function"><span class="keyword">while</span> (i &lt; n)</span></span></span><br><span class="line"><span class="params"><span class="function">&#123;</span></span></span><br><span class="line"><span class="params"><span class="function">unique_lock&lt;mutex&gt; lock(mtx);</span></span></span><br><span class="line"><span class="params"><span class="function">             <span class="comment">//ready为真的时候，唤醒t2</span></span></span></span><br><span class="line"><span class="params"><span class="function">cv.wait(lock, [&amp;ready]()&#123;<span class="keyword">return</span> ready; &#125;);</span></span></span><br><span class="line"><span class="params"><span class="function"></span></span></span><br><span class="line"><span class="params"><span class="function">cout &lt;&lt;<span class="string">&quot;t2 : &quot;</span>&lt;&lt;this_thread::get_id() &lt;&lt; <span class="string">&quot; : &quot;</span> &lt;&lt; i &lt;&lt; endl;</span></span></span><br><span class="line"><span class="params"><span class="function">i++;</span></span></span><br><span class="line"><span class="params"><span class="function">ready = <span class="literal">false</span>;</span></span></span><br><span class="line"><span class="params"><span class="function"></span></span></span><br><span class="line"><span class="params"><span class="function">cv.notify_one();</span></span></span><br><span class="line"><span class="params"><span class="function">&#125;</span></span></span><br><span class="line"><span class="params"><span class="function">&#125;)</span></span>;</span><br><span class="line"></span><br><span class="line">this_thread::<span class="built_in">sleep_for</span>(chrono::<span class="built_in">seconds</span>(<span class="number">3</span>));</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;t1:&quot;</span> &lt;&lt; t1.<span class="built_in">get_id</span>() &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;t2:&quot;</span> &lt;&lt; t2.<span class="built_in">get_id</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">t1.<span class="built_in">join</span>();</span><br><span class="line">t2.<span class="built_in">join</span>();</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行一下，可以看到我们成功通过条件变量，使这两个线程交错打印奇偶数！</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">t2 : 23208 : 0</span><br><span class="line">t1 : 24896 : 1</span><br><span class="line">t2 : 23208 : 2</span><br><span class="line">t1 : 24896 : 3</span><br><span class="line">t2 : 23208 : 4</span><br><span class="line">t1 : 24896 : 5</span><br><span class="line">t2 : 23208 : 6</span><br><span class="line">t1 : 24896 : 7</span><br><span class="line">t2 : 23208 : 8</span><br><span class="line">t1 : 24896 : 9</span><br><span class="line">t2 : 23208 : 10</span><br><span class="line">t1 : 24896 : 11</span><br><span class="line">//....</span><br><span class="line">t2 : 23208 : 90</span><br><span class="line">t1 : 24896 : 91</span><br><span class="line">t2 : 23208 : 92</span><br><span class="line">t1 : 24896 : 93</span><br><span class="line">t2 : 23208 : 94</span><br><span class="line">t1 : 24896 : 95</span><br><span class="line">t2 : 23208 : 96</span><br><span class="line">t1 : 24896 : 97</span><br><span class="line">t2 : 23208 : 98</span><br><span class="line">t1 : 24896 : 99</span><br><span class="line">t2 : 23208 : 100</span><br></pre></td></tr></table></figure><p>即便在t1中额外加上休眠，也不会影响输出结果的准确性！</p><p><img                       lazyload                     alt="image"                     data-src="https://img1.musnow.top/i/2023/02/63f48c6d2f8ff.png"                      alt="image-20230221171837565"                ></p><p>这便是条件变量对于线程同步控制的用法</p><h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>在学习过linux的线程基础和系统接口后，理解C++这里的多线程操作还算轻松！</p><p>C++语法学习的最后一块拼图也被补上了！</p><p><img                       lazyload                     alt="image"                     data-src="https://img1.musnow.top/i/2023/02/202211021535708.jpg"                      alt="QQ图片20220424132540"                ></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;本篇博客，让我们来认识一下C++中的线程操作&lt;/p&gt;</summary>
    
    
    
    <category term="遇见C++" scheme="https://blog.musnow.top/categories/%E9%81%87%E8%A7%81C/"/>
    
    
    <category term="C++" scheme="https://blog.musnow.top/tags/C/"/>
    
    <category term="C++11" scheme="https://blog.musnow.top/tags/C-11/"/>
    
  </entry>
  
</feed>
