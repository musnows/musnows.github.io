<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>慕雪的寒舍</title>
  
  <subtitle>雪下了一夜</subtitle>
  <link href="https://blog.musnow.top/atom.xml" rel="self"/>
  
  <link href="https://blog.musnow.top/"/>
  <updated>2023-02-20T04:54:15.895Z</updated>
  <id>https://blog.musnow.top/</id>
  
  <author>
    <name>muxue</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>【Curl】通过curl模拟referer获取到有防盗链的图片</title>
    <link href="https://blog.musnow.top/2023/02/20/tools/15curl%E6%A8%A1%E6%8B%9Freferer%E8%8E%B7%E5%8F%96%E8%B5%84%E6%BA%90/"/>
    <id>https://blog.musnow.top/2023/02/20/tools/15curl%E6%A8%A1%E6%8B%9Freferer%E8%8E%B7%E5%8F%96%E8%B5%84%E6%BA%90/</id>
    <published>2023-02-20T04:20:31.000Z</published>
    <updated>2023-02-20T04:54:15.895Z</updated>
    
    <content type="html"><![CDATA[<p>本文所描述操作仅供学习curl命令，请勿用于盗刷他人图床等违规操作！🙅‍♀️</p><span id="more"></span><h1 id="1-说明"><a href="#1-说明" class="headerlink" title="1.说明"></a>1.说明</h1><p>当我想把51la添加到我的导航站点，却发现它的icon图标有防盗链，禁止空referer访问的；</p><p>这点完全可以理解，为了防止他人盗刷本站的图片，通常我们都需要给图片地址加上防盗链。</p><p><img                       lazyload                     alt="image"                     data-src="https://img1.musnow.top/i/23/02/63f2fa1399fff.png"                      alt="image-20230220124149093"                ></p><p>其实51la提供了自己的icon，但这里提供的icon像素特别低，只有16*16，在我的导航站点上的显示就没有那么友好了</p><p><img                       lazyload                     alt="image"                     data-src="https://img1.musnow.top/i/23/02/63f2fb32ccc10.png"                      alt="image-20230220124643681"                ></p><p><img                       lazyload                     alt="image"                     data-src="https://img1.musnow.top/i/23/02/63f2fb5f7cf73.png"                      alt="image-20230220124728488"                ></p><p>所以我才想把稍微清晰一点的icon图标下载下来</p><h1 id="2-curl使用"><a href="#2-curl使用" class="headerlink" title="2.curl使用"></a>2.curl使用</h1><blockquote><p>参考 <a class="link"   href="https://www.ruanyifeng.com/blog/2019/09/curl-reference.html" >https://www.ruanyifeng.com/blog/2019/09/curl-reference.html<i class="fas fa-external-link-alt"></i></a></p></blockquote><p>要避开这个403访问，需要做的就是给请求头给定一个referer字段，告诉51la的服务器，我是通过他自己的域名访问图标文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">curl \</span><br><span class="line">-H &#x27;Referer: https://v6.51.la/&#x27; \</span><br><span class="line">https://v6-static.51.la/v6-static/202302161047/favicon.ico \</span><br><span class="line">-o favicon.ico</span><br></pre></td></tr></table></figure><p>对上面提到的几个参数做一定解释</p><ul><li>-H设定请求头，需要符号http协议的标准<code>key: value</code></li><li>-o将获取到的内容保存为文件，在后面指定文件名（这里我指定为了<code>favicon.ico</code>）</li></ul><p>在linux下用这个命令，就能成功拉取到51la的站点图片</p><p><img                       lazyload                     alt="image"                     data-src="https://img1.musnow.top/i/23/02/63f2fb9421523.png"                      alt="image-20230220124820822"                ></p><p>如果不加referer字段，则还是会返回403</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ curl https://v6-static.51.la/v6-static/202302161047/favicon.ico </span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;&lt;title&gt;403 Forbidden&lt;/title&gt;&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;center&gt;&lt;h1&gt;403 Forbidden&lt;/h1&gt;&lt;/center&gt;</span><br><span class="line">&lt;hr&gt;&lt;center&gt;openresty&lt;/center&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;本文所描述操作仅供学习curl命令，请勿用于盗刷他人图床等违规操作！🙅‍♀️&lt;/p&gt;</summary>
    
    
    
    <category term="差生文具多" scheme="https://blog.musnow.top/categories/%E5%B7%AE%E7%94%9F%E6%96%87%E5%85%B7%E5%A4%9A/"/>
    
    
    <category term="Linux" scheme="https://blog.musnow.top/tags/Linux/"/>
    
    <category term="curl" scheme="https://blog.musnow.top/tags/curl/"/>
    
  </entry>
  
  <entry>
    <title>【C++】thread线程 | mutex锁</title>
    <link href="https://blog.musnow.top/2023/02/19/note_cpp/28C++%E7%BA%BF%E7%A8%8B/"/>
    <id>https://blog.musnow.top/2023/02/19/note_cpp/28C++%E7%BA%BF%E7%A8%8B/</id>
    <published>2023-02-19T15:30:46.000Z</published>
    <updated>2023-02-20T07:03:18.434Z</updated>
    
    <content type="html"><![CDATA[<p>本篇博客，让我们来认识一下C++中的线程操作</p><span id="more"></span><blockquote><p>所用编译器 vs2019</p></blockquote><h1 id="1-基本介绍"><a href="#1-基本介绍" class="headerlink" title="1.基本介绍"></a>1.基本介绍</h1><p>在不同的操作系统，windows、linux、mac上，都会对多线程操作提供自己的系统调用接口</p><p>为什么C++需要封装一个线程？直接用系统的接口不好吗？</p><p>在<a href="https://blog.musnow.top/2022/11/01/note_linux/14%E6%96%87%E4%BB%B6io/#1-%E4%BB%80%E4%B9%88%E6%98%AF%E6%96%87%E4%BB%B6%EF%BC%9F">Linux文件博客</a>中，已经谈过了这一点：对于C++、python、java这些<strong>跨平台</strong>的语言来说，如果直接用系统的接口，是可以实现对应操作的。但是，这样会导致代码<strong>只能在某一个特定平台</strong>，甚至是某一个版本的特定操作系统上才能正常运行，直接与跨平台的特性相违背。</p><p>解决的办法呢，就是对系统的接口套一个语言级别的软件层，<strong>封装系统的接口</strong>。并用<code>条件编译</code>的方式来识别不同的操作系统，已调用不同操作系统的系统接口，以实现跨平台性</p><h1 id="2-thread类"><a href="#2-thread类" class="headerlink" title="2.thread类"></a>2.thread类</h1><blockquote><p><a class="link"   href="https://legacy.cplusplus.com/reference/thread/thread/thread/" >https://legacy.cplusplus.com/reference/thread/thread/thread/<i class="fas fa-external-link-alt"></i></a></p></blockquote><h2 id="2-1-构造-x2F-赋值"><a href="#2-1-构造-x2F-赋值" class="headerlink" title="2.1 构造&#x2F;赋值"></a>2.1 构造&#x2F;赋值</h2><p><img                       lazyload                     alt="image"                     data-src="https://img1.musnow.top/i/23/02/63f20f5b7be4e.png"                      alt="image-20230219195214155"                ></p><p><img                       lazyload                     alt="image"                     data-src="https://img1.musnow.top/i/23/02/63f20f5f8605c.png"                      alt="image-20230219200034593"                ></p><p>线程是不允许拷贝构造和赋值重载的，但是其支持<strong>右值引用</strong>的重载（主要是为了匿名对象构造）也支持空构造</p><blockquote><p>右值：无法进行取地址的变量</p></blockquote><h2 id="2-2-get-id"><a href="#2-2-get-id" class="headerlink" title="2.2 get_id"></a>2.2 get_id</h2><p>对于线程而言，比较重要的就是这个id号了，其用于标识线程的唯一性</p><p><img                       lazyload                     alt="image"                     data-src="https://img1.musnow.top/i/23/02/63f22efb3c6f0.png"                      alt="image-20230219221526489"                ></p><h2 id="2-3-join-x2F-detach"><a href="#2-3-join-x2F-detach" class="headerlink" title="2.3 join&#x2F;detach"></a>2.3 join&#x2F;detach</h2><p>创建好了一个线程，我们需要进行join等待或者detach分离</p><ul><li>如果主线程不需要获取子进程执行的结果，可以直接执行detach</li><li>如果需要等待子线程执行，则执行join</li></ul><p>为什么会产生这两个分歧呢？是因为join等待是有一定消耗的。如果我们不关心线程执行的返回值，应该采用detach尽量减小消耗</p><h2 id="2-4-使用示例"><a href="#2-4-使用示例" class="headerlink" title="2.4 使用示例"></a>2.4 使用示例</h2><p>相比于Linux系统提供的pthread接口，C++的使用方法更加直接</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; a + b &lt;&lt; endl;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="function">thread <span class="title">t1</span><span class="params">(Add, <span class="number">10</span>, <span class="number">20</span>)</span></span>;</span><br><span class="line"><span class="function">thread <span class="title">t2</span><span class="params">(Add, <span class="number">10</span>, <span class="number">30</span>)</span></span>;</span><br><span class="line">t1.<span class="built_in">join</span>();</span><br><span class="line">t2.<span class="built_in">join</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img                       lazyload                     alt="image"                     data-src="https://img1.musnow.top/i/23/02/63f220e7cf62b.png"                      alt="image-20230219211523002"                ></p><h2 id="2-5-空构造和移动赋值"><a href="#2-5-空构造和移动赋值" class="headerlink" title="2.5 空构造和移动赋值"></a>2.5 空构造和移动赋值</h2><p>如果我们只是定义了一个t1，没有直接调用构造函数指定其要运行的函数（其实是调用了空构造）那么要怎么给这个线程指定函数呢？</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">thread t3;<span class="comment">//调用了空构造</span></span><br></pre></td></tr></table></figure><p>别忘了，虽然线程不支持拷贝构造，但他有移动赋值！</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">thread&amp; <span class="keyword">operator</span>= (thread&amp;&amp; rhs) <span class="keyword">noexcept</span>;</span><br></pre></td></tr></table></figure><p>我们要做的，就是采用匿名对象的方式，赋值给t3</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">thread t3;</span><br><span class="line">t3 = <span class="built_in">thread</span>(Add, <span class="number">20</span>, <span class="number">30</span>);</span><br><span class="line">t3.<span class="built_in">join</span>();</span><br></pre></td></tr></table></figure><p><img                       lazyload                     alt="image"                     data-src="https://img1.musnow.top/i/23/02/63f22a162f785.png"                      alt="image-20230219215433403"                ></p><h2 id="2-6-joinable"><a href="#2-6-joinable" class="headerlink" title="2.6 joinable"></a>2.6 joinable</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">joinable</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">noexcept</span></span>;</span><br></pre></td></tr></table></figure><p>这个函数的作用是标识一个线程是否还能进行join；下面几种情况，线程不能被join</p><ul><li>只调用了空构造（都没有指定需要运行的函数怎么join等待？）</li><li>被move了（move会将对象变成将亡值，也就是右值）</li><li>该对象已经调用过join或者detach</li></ul><p>如果是在多层函数中调用的线程，那可能join之前就可以判断一下当前对象是否还能join</p><h2 id="2-7-swap-x2F-move"><a href="#2-7-swap-x2F-move" class="headerlink" title="2.7 swap&#x2F;move"></a>2.7 swap&#x2F;move</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">swap</span> <span class="params">(thread&amp; x)</span> <span class="keyword">noexcept</span></span>;</span><br></pre></td></tr></table></figure><p>该成员函数的作用是将另外一个线程切换给当前线程</p><p><img                       lazyload                     alt="image"                     data-src="https://img1.musnow.top/i/23/02/63f23b7a0ba31.png"                      alt="image-20230219230844481"                ></p><p>其本质就是一个move移动赋值</p><p><img                       lazyload                     alt="image"                     data-src="https://img1.musnow.top/i/23/02/63f23c727a61c.png"                      alt="image-20230219231249899"                ></p><p>被移动后的线程t3不再<code>joinable</code>，不会运行，也不能被join或detach</p><p><img                       lazyload                     alt="image"                     data-src="https://img1.musnow.top/i/23/02/63f23bc928163.png"                      alt="image-20230219231000662"                ></p><p>强行join会报错</p><p><img                       lazyload                     alt="image"                     data-src="https://img1.musnow.top/i/23/02/63f23bf8def67.png"                      alt="image-20230219231048460"                ></p><h1 id="3-std-ref"><a href="#3-std-ref" class="headerlink" title="3.std::ref"></a>3.std::ref</h1><p>这里有一个特殊的函数ref，要想知道其作用，我们需要先看下面这个场景</p><h2 id="3-1-引用传参"><a href="#3-1-引用传参" class="headerlink" title="3.1 引用传参"></a>3.1 引用传参</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _CRT_SECURE_NO_WARNINGS 1</span></span><br><span class="line"><span class="comment">//#include &lt;stdio.h&gt;</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Print</span><span class="params">(<span class="type">int</span> n,<span class="type">int</span>&amp; a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; this_thread::<span class="built_in">get_id</span>() &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt;  a++ &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line"><span class="function">thread <span class="title">t1</span><span class="params">(Print,<span class="number">10</span>, count)</span></span>;</span><br><span class="line"><span class="function">thread <span class="title">t2</span><span class="params">(Print,<span class="number">10</span>, count)</span></span>;</span><br><span class="line">t1.<span class="built_in">join</span>();</span><br><span class="line">t2.<span class="built_in">join</span>();</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;main: &quot;</span> &lt;&lt; count &lt;&lt; endl;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个场景中，我想达到的目标是让t1和t2两个线程帮我们对count进行++，最终在main里面打印结果；可编译会发现报错，不给我们这样写</p><p><img                       lazyload                     alt="image"                     data-src="https://img1.musnow.top/i/23/02/63f1fbf492ae1.png"                      alt="image-20230219183743136"                ></p><p>相同的代码在linux下也出现了编译错误，所用g++版本如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">g++ (GCC) 11.2.1 20220127 (Red Hat 11.2.1-9)</span><br></pre></td></tr></table></figure><p><img                       lazyload                     alt="image"                     data-src="https://img1.musnow.top/i/23/02/63f1e519b4676.png"                      alt="image-20230219170012180"                ></p><p>为了确认具体的报错位置，我们先把<code>int&amp; a</code>的引用去掉，再看看情况</p><p><img                       lazyload                     alt="image"                     data-src="https://img1.musnow.top/i/23/02/63f19d78e1d62.png"                      alt="image-20230219115434795"                ></p><p>能看到，在没有采用<strong>引用传参</strong>的情况下，函数中对count进行的操作并不会反馈到main中，因为采用的是<strong>传值</strong>，会进行拷贝。</p><h2 id="3-2-thread构造函数"><a href="#3-2-thread构造函数" class="headerlink" title="3.2 thread构造函数"></a>3.2 thread构造函数</h2><p>那为什么加上引用之后，会报错呢？这就和thread的构造函数有关系了</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">Fn</span>, <span class="keyword">class</span>... Args&gt;</span><br><span class="line"><span class="function"><span class="keyword">explicit</span> <span class="title">thread</span> <span class="params">(Fn&amp;&amp; fn, Args&amp;&amp;... args)</span></span>;</span><br></pre></td></tr></table></figure><p>如上，当我们构造一个线程对象的时候，采用的是<a href="https://blog.musnow.top/2022/09/28/note_cpp/20c++11%E7%89%B9%E6%80%A7/#7-%E5%8F%AF%E5%8F%98%E6%A8%A1%E6%9D%BF%E5%8F%82%E6%95%B0">可变模板参数</a>；在我的博客中写到过，可变模板参数需要采用<code>递归</code>来进行参数类型的推测。</p><p>由于底层实现的问题（也只能是这个原因了）在进行构造的完美转发时，所有的参数都采用了<code>拷贝</code>而不是引用传参。</p><p>这也就导致我们没有办法将一个参数通过<strong>引用</strong>传入线程需要执行的函数！</p><blockquote><p>用指针肯定是可以的，可C++搞出引用这个东西，就是为了避免使用指针</p></blockquote><h2 id="3-3-ref出场"><a href="#3-3-ref出场" class="headerlink" title="3.3 ref出场"></a>3.3 ref出场</h2><blockquote><p><a class="link"   href="https://legacy.cplusplus.com/reference/functional/ref/?kw=ref" >https://legacy.cplusplus.com/reference/functional/ref/?kw=ref<i class="fas fa-external-link-alt"></i></a></p></blockquote><p>于是乎，std库中就新增了一个库函数<code>ref</code>，来解决这个问题</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ref的用法</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt; <span class="function">reference_wrapper&lt;T&gt; <span class="title">ref</span> <span class="params">(T&amp; elem)</span> <span class="keyword">noexcept</span></span>;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt; <span class="function">reference_wrapper&lt;T&gt; <span class="title">ref</span> <span class="params">(reference_wrapper&lt;T&gt;&amp; x)</span> <span class="keyword">noexcept</span></span>;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt; <span class="function"><span class="type">void</span> <span class="title">ref</span> <span class="params">(<span class="type">const</span> T&amp;&amp;)</span> </span>= <span class="keyword">delete</span>;</span><br></pre></td></tr></table></figure><blockquote><p>Constructs an object of the appropriate <a class="link"   href="https://legacy.cplusplus.com/reference_wrapper" >reference_wrapper<i class="fas fa-external-link-alt"></i></a> type to hold a reference to elem.</p><p>If the argument is itself a <a class="link"   href="https://legacy.cplusplus.com/reference_wrapper" >reference_wrapper<i class="fas fa-external-link-alt"></i></a> <em>(2)</em>, it creates a copy of x instead.</p><p>The function calls the proper <a class="link"   href="https://legacy.cplusplus.com/reference_wrapper" >reference_wrapper<i class="fas fa-external-link-alt"></i></a> constructor.</p></blockquote><p>这个函数会构造一个合适的<code>reference_wrapper</code>对象，来管理一个变量的<strong>引用</strong>。如果参数本身就是<code>reference_wrapper</code>类型，则会调用<code>reference_wrapper</code>的拷贝构造。</p><p>而ref函数不能传递右值，其右值引用的重载是被<code>delete</code>的</p><p><img                       lazyload                     alt="image"                     data-src="https://img1.musnow.top/i/23/02/63f1e6be2fd55.png"                      alt="image-20230219170711744"                ></p><h2 id="3-4-ref使用"><a href="#3-4-ref使用" class="headerlink" title="3.4 ref使用"></a>3.4 ref使用</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">thread <span class="title">t1</span><span class="params">(Print,<span class="number">10</span>, ref(count))</span></span>;</span><br><span class="line"><span class="function">thread <span class="title">t2</span><span class="params">(Print,<span class="number">10</span>, ref(count))</span></span>;</span><br><span class="line">t1.<span class="built_in">join</span>();</span><br><span class="line">t2.<span class="built_in">join</span>();</span><br></pre></td></tr></table></figure><p>使用了该库函数之后，编译不再报错，main中的值也成功被修改</p><p><img                       lazyload                     alt="image"                     data-src="https://img1.musnow.top/i/23/02/63f1e573a7d52.png"                      alt="image-20230219170142211"                ></p><p>通过ref传递的参数，也会遵守函数本身的变量规则。如果函数本身没有采用引用传参，则还是调用传值参数，会进行拷贝；</p><p><img                       lazyload                     alt="image"                     data-src="https://img1.musnow.top/i/23/02/63f1e703647b4.png"                      alt="image-20230219170821981"                ></p><p>为了避免后续出现这种问题，可以给所有对线程的左值传参都带上ref😏比如给两个线程函数传入同一把锁的时候，就需要采用<code>ref</code>进行引用传参</p><h1 id="4-指令重排"><a href="#4-指令重排" class="headerlink" title="4.指令重排"></a>4.指令重排</h1><blockquote><p><a class="link"   href="https://zhuanlan.zhihu.com/p/271701839" >谈谈指令重排 - 知乎<i class="fas fa-external-link-alt"></i></a></p><p><a class="link"   href="https://developer.aliyun.com/article/1155673#:~:text=%E6%8C%87%E4%BB%A4%E9%87%8D%E6%8E%92%E7%9A%84%E6%96%B9%E5%BC%8F%201%20%E7%BC%96%E8%AF%91%E5%99%A8%E4%BC%98%E5%8C%96%20%E9%87%8D%E6%96%B0%E5%AE%89%E6%8E%92%E8%AF%AD%E5%8F%A5%E7%9A%84%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F%202,%E6%8C%87%E4%BB%A4%E5%B9%B6%E8%A1%8C%E9%87%8D%E6%8E%92%20%E5%88%A9%E7%94%A8%E6%8C%87%E4%BB%A4%E7%BA%A7%E5%B9%B6%E8%A1%8C%E6%8A%80%E6%9C%AF%E5%B0%86%E5%A4%9A%E4%B8%AA%E6%8C%87%E4%BB%A4%E5%B9%B6%E8%A1%8C%E6%89%A7%E8%A1%8C%EF%BC%8C%E5%A6%82%E6%9E%9C%E6%8C%87%E4%BB%A4%E4%B9%8B%E5%89%8D%E6%B2%A1%E6%9C%89%E6%95%B0%E6%8D%AE%E4%BE%9D%E8%B5%96%EF%BC%8C%E5%A4%84%E7%90%86%E5%99%A8%E5%8F%AF%E4%BB%A5%E6%94%B9%E5%8F%98%E5%AF%B9%E5%BA%94%E6%9C%BA%E5%99%A8%E6%8C%87%E4%BB%A4%E7%9A%84%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F%203%20%E5%86%85%E5%AD%98%E7%B3%BB%E7%BB%9F%E9%87%8D%E6%8E%92%20%E7%94%B1%E4%BA%8E%E5%A4%84%E7%90%86%E4%BD%BF%E7%94%A8%E7%BC%93%E5%AD%98%E5%92%8C%E8%AF%BB%E5%86%99%E7%BC%93%E5%86%B2%E5%8C%BA%EF%BC%8C%E6%89%80%E4%BB%A5%E5%AE%83%E4%BB%AC%E6%98%AF%E4%B9%B1%E5%BA%8F%E7%9A%84" >面试官: 有了解过指令重排吗，什么是happens-before<i class="fas fa-external-link-alt"></i></a></p></blockquote><h2 id="4-1-什么是重排序"><a href="#4-1-什么是重排序" class="headerlink" title="4.1 什么是重排序"></a>4.1 什么是重排序</h2><p>首先，什么是重排序❓计算机在执行过程中，为了提高性能，会对编译器和编译器做<code>指令重排</code>。</p><p>这么做为啥可以提高性能呢❓</p><p>我们知道计算机在执行的时候都是一个个指令去执行，不同的指令可能操作的硬件不一样，在执行的过程中可能会产生<code>中断</code>。</p><p>打个比方，两个指令a和b他们操作的东西各不相同，如果加载a的时候停顿了，b就加载不到，但是实际上它们互补影响，我也可以先加载b在加载a，所以<code>指令重排</code>是减少停顿的一种方法，这样大大提高了效率。</p><h3 id="4-1-1-指令重排的方式"><a href="#4-1-1-指令重排的方式" class="headerlink" title="4.1.1 指令重排的方式"></a>4.1.1 指令重排的方式</h3><p>指令重排一般分为以下三种</p><ul><li><code>编译器优化</code> 重新安排语句的执行顺序</li><li><code>指令并行重排</code> 利用指令级并行技术将多个指令并行执行，如果指令之前没有数据依赖，处理器可以改变对应机器指令的执行顺序</li><li><code>内存系统重排</code> 由于处理使用缓存和读写缓冲区，所以它们是乱序的</li></ul><p>指令重排可以保证<code>串行语义</code>一致，但是没有义务保证<code>多线程间的语义</code>也一致**。所以在多线程下，指令重排序可能会导致一些问题</p><h2 id="4-2-实际场景"><a href="#4-2-实际场景" class="headerlink" title="4.2 实际场景"></a>4.2 实际场景</h2><p>以懒汉的单例模式为例</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取单例对象</span></span><br><span class="line"><span class="function"><span class="type">static</span> InfoMgr* <span class="title">GetInstance</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (_sp == <span class="literal">nullptr</span>)<span class="comment">//第一次检测保证单例</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function">unique_lock&lt;mutex&gt; <span class="title">lock</span><span class="params">(_mtx)</span></span>;</span><br><span class="line">        <span class="keyword">if</span> (_sp == <span class="literal">nullptr</span>)<span class="comment">//第二次检测保证线程安全</span></span><br><span class="line">        &#123;</span><br><span class="line">            _sp = <span class="keyword">new</span> InfoMgr;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> _sp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一般情况下，<code>new</code>一个新对象，执行的顺序应该是这样的</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">operator new</span><br><span class="line">构造对象</span><br><span class="line">赋值给_sp</span><br></pre></td></tr></table></figure><p>但编译器如果进行了指令重排，可能就会变成这样</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">operator new</span><br><span class="line">赋值给_sp</span><br><span class="line">构造对象</span><br></pre></td></tr></table></figure><p>如果一个线程执行到第二步<code>赋值给_sp</code>的时候，因为时间片到了被切换走了；其他线程来获取单例，就会导致<code>_sp</code>变量是一个已经被赋值了，但是其指向的是<strong>没有初始化的空对象</strong>，这是错误的！</p><h2 id="4-3-可行的解决办法：内存栅栏"><a href="#4-3-可行的解决办法：内存栅栏" class="headerlink" title="4.3 可行的解决办法：内存栅栏"></a>4.3 可行的解决办法：内存栅栏</h2><p>所谓内存栅栏，是系统提供的的接口，用于禁止cpu对指令的优化；</p><blockquote><p><a class="link"   href="https://blog.csdn.net/qq_16498553/article/details/128030833" >https://blog.csdn.net/qq_16498553/article/details/128030833<i class="fas fa-external-link-alt"></i></a></p></blockquote><p>但内存栈栏是系统接口，没有跨平台性；这里只做了解，知道有这个问题即可！</p><hr><p>在一般情况下，我们不需要担心<code>4.2</code>中提到的问题，因为指令优化是有严格规则的，不会对赋值和构造这类指令进行胡乱优化（因为这样优化并不会有效率提升啊）</p><p>但这也需要看具体平台的底层实现了！</p><h1 id="5-获取线程返回值"><a href="#5-获取线程返回值" class="headerlink" title="5.获取线程返回值"></a>5.获取线程返回值</h1><h2 id="5-1-输出型参数"><a href="#5-1-输出型参数" class="headerlink" title="5.1 输出型参数"></a>5.1 输出型参数</h2><p>在C语言中，想获取线程返回值，需要使用输出型参数（C++可以用引用传值）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">Add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b,<span class="type">int</span>&amp; out)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">out = a + b;</span><br><span class="line"><span class="keyword">return</span> out;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test2</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> ret = <span class="number">0</span>;</span><br><span class="line"><span class="function">thread <span class="title">t2</span><span class="params">(Add, <span class="number">10</span>, <span class="number">39</span>, ref(ret))</span></span>;</span><br><span class="line">t2.<span class="built_in">join</span>();</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;main: &quot;</span> &lt;&lt; ret &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img                       lazyload                     alt="image"                     data-src="https://img1.musnow.top/i/23/02/63f21f423ea1b.png"                      alt="image-20230219210821383"                ></p><h2 id="5-2-lambda"><a href="#5-2-lambda" class="headerlink" title="5.2 lambda"></a>5.2 lambda</h2><p>在C++中，还可以使用lambda表达式，来在<code>main</code>中获取线程的返回值</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">Add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test2</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> ret = <span class="number">0</span>;</span><br><span class="line"><span class="function">thread <span class="title">t1</span><span class="params">([&amp;ret]() &#123; ret = Add(<span class="number">10</span>, <span class="number">29</span>); &#125;)</span></span>;</span><br><span class="line">t1.<span class="built_in">join</span>();</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;main: &quot;</span> &lt;&lt; ret &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img                       lazyload                     alt="image"                     data-src="https://img1.musnow.top/i/23/02/63f219625e81a.png"                      alt="image-20230219204317460"                ></p><h1 id="6-函数重载问题"><a href="#6-函数重载问题" class="headerlink" title="6.函数重载问题"></a>6.函数重载问题</h1><p>在我测试的时候发现，如果一个函数具有重载，线程是不支持的；</p><p>具体的原因嘛，我猜和线程构造的可变模板参数有关系。</p><p><img                       lazyload                     alt="image"                     data-src="https://img1.musnow.top/i/23/02/63f22aa4c21de.png"                      alt="img"                ></p><p>百度了一下，解决办法，是给第一个参数传入一个<strong>函数指针</strong>或者fuctional对象，手动指定使用的是哪一个函数。</p><p>当然，还有一个解决办法：线程调用的函数不要有重载😂</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">Add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b,<span class="type">int</span>&amp; out)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">out = a + b;</span><br><span class="line"><span class="keyword">return</span> out;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> tmp = a + b;</span><br><span class="line">cout &lt;&lt; tmp &lt;&lt; endl;;</span><br><span class="line"><span class="keyword">return</span> tmp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test2</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> ret = <span class="number">0</span>;</span><br><span class="line"><span class="comment">// 使用函数指针指定对应的函数</span></span><br><span class="line"><span class="function">thread <span class="title">t2</span><span class="params">(<span class="keyword">static_cast</span>&lt;<span class="type">int</span>(*)(<span class="type">int</span> a, <span class="type">int</span> b, <span class="type">int</span>&amp; out)&gt;(Add), <span class="number">10</span>, <span class="number">39</span>, ref(ret))</span></span>;</span><br><span class="line">t2.<span class="built_in">join</span>();</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;main: &quot;</span> &lt;&lt; ret &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img                       lazyload                     alt="image"                     data-src="https://img1.musnow.top/i/23/02/63f22bfb930fa.png"                      alt="image-20230219220238736"                ></p><h1 id="7-this-thread"><a href="#7-this-thread" class="headerlink" title="7.this_thread"></a>7.this_thread</h1><p>std库中还用命名空间对线程的一些操作进行了封装</p><p><img                       lazyload                     alt="image"                     data-src="https://img1.musnow.top/i/23/02/63f3137e63079.png"                      alt="image-20230220143023521"                ></p><ul><li>get_id 获取线程id号（其实线程类里面已经有这个东东了，但是为了方便函数中直接调用，又多开了一个函数）</li><li>yield 放弃自己的时间片</li><li>sleep_until 休眠到一个时间点（比如睡到明天早八）</li><li>sleep_for 休眠一定时间（睡2分钟）</li></ul><p>下面来对后面三个函数做一点解释（第一个就不解释了哈）</p><h2 id="7-1-yield"><a href="#7-1-yield" class="headerlink" title="7.1 yield"></a>7.1 yield</h2><p>yield的作用是让出当前线程的时间片；</p><p>我们知道每一个线程运行时都会有一个自己的时间片，时间片到了，就会进行线程的切换；</p><p>以下面的场景为例</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">volatile</span> <span class="type">bool</span> ready = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">count1m</span><span class="params">(<span class="type">int</span> id)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// 如果main没有设置ready信号，线程会一直让出自己的时间片，不会运行</span></span><br><span class="line"><span class="keyword">while</span> (!ready) </span><br><span class="line">&#123;            </span><br><span class="line">this_thread::<span class="built_in">yield</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 开始运行，++数据</span></span><br><span class="line"><span class="keyword">volatile</span> <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (i=<span class="number">0</span>; i &lt; <span class="number">10000000</span>; i++) </span><br><span class="line">&#123; </span><br><span class="line">; <span class="comment">// 循环体啥都不干</span></span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; id;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test4</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">thread threads[<span class="number">10</span>];</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;创建10个线程 计数\n&quot;</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i) </span><br><span class="line">&#123;</span><br><span class="line">threads[i] = <span class="built_in">thread</span>(count1m, i);</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;创建10个线程 完毕\n&quot;</span>;</span><br><span class="line">ready = <span class="literal">true</span>;<span class="comment">//设置状态，让线程开始运行</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;main set ture: &quot;</span> &lt;&lt; ready &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span>&amp; th : threads) </span><br><span class="line">&#123;</span><br><span class="line">th.<span class="built_in">join</span>();</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;\nmain join 成功&quot;</span> &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行结果</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">创建10个线程 计数</span><br><span class="line">创建10个线程 完毕</span><br><span class="line">main set ture: 1</span><br><span class="line">3746089215</span><br><span class="line">main join 成功</span><br></pre></td></tr></table></figure><p>在这个场景中，每一个线程被设置了task后，都会先进入一个while循环，等待主线程进行ready的设置</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 如果main没有设置ready信号，线程会一直让出自己的时间片，不会运行</span></span><br><span class="line"><span class="keyword">while</span> (!ready) </span><br><span class="line">&#123;            </span><br><span class="line">this_thread::<span class="built_in">yield</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时我们就可以在while循环中进行yield让线程<strong>让出自己</strong>的时间片。否则这个线程会一直疯狂访问ready，导致cpu占用提高。</p><p>在这种<strong>轮询检测</strong>的场景下，使用yield能避免某一个线程长时间占用执行流，解决了其他线程的饥饿问题。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;本篇博客，让我们来认识一下C++中的线程操作&lt;/p&gt;</summary>
    
    
    
    <category term="遇见C++" scheme="https://blog.musnow.top/categories/%E9%81%87%E8%A7%81C/"/>
    
    
    <category term="C++" scheme="https://blog.musnow.top/tags/C/"/>
    
    <category term="C++11" scheme="https://blog.musnow.top/tags/C-11/"/>
    
  </entry>
  
  <entry>
    <title>【Nas】tmm刮削器无法连接tmdb的解决办法（改host）</title>
    <link href="https://blog.musnow.top/2023/02/15/nas/9tmm%E5%88%AE%E5%89%8A%E6%97%A0%E6%B3%95%E8%AE%BF%E9%97%AE%E7%9A%84%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95/"/>
    <id>https://blog.musnow.top/2023/02/15/nas/9tmm%E5%88%AE%E5%89%8A%E6%97%A0%E6%B3%95%E8%AE%BF%E9%97%AE%E7%9A%84%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95/</id>
    <published>2023-02-15T13:25:57.000Z</published>
    <updated>2023-02-15T13:34:29.469Z</updated>
    
    <content type="html"><![CDATA[<p>tmm刮削器无法连接tmdb的解决办法（改host）</p><span id="more"></span><p>如题，最近发现自己windows电脑上的tmm又无法刮削了，打开系统host目一看，发现文件被清空了，得自己重新再搞一遍</p><h1 id="1-思路"><a href="#1-思路" class="headerlink" title="1.思路"></a>1.思路</h1><p>思路很简单，就是我们当前访问 <code>api.themoviedb.org</code>的域名，没有办法找到一个国内能成功访问的ip。所以就会报错 <code>timeout</code></p><p>修改host的作用，就是告诉系统，访问<code>api.themoviedb.org</code>的时候，先在本地hosts文件里面有的这些主机试一试，能成功就不需要去主动找host服务器了</p><p>所以我们只要将国内能访问的ip写入host就可以了</p><h1 id="2-找寻可用host"><a href="#2-找寻可用host" class="headerlink" title="2.找寻可用host"></a>2.找寻可用host</h1><p>有了上面的思路，下面要做的就是看看那些host可以访问</p><p>通过 <a class="link"   href="https://www.itdog.cn/ping/api.themoviedb.org" >ITDOG网站<i class="fas fa-external-link-alt"></i></a>，在线ping <code>api.themoviedb.org</code>站点，可以看到大部分地区的访问都是超时的</p><p><img                       lazyload                     alt="image"                     data-src="https://img1.musnow.top/i/23/02/63ecde92b026b.png"                      alt="image-20230215213018481"                ></p><p>我们要做的就是找到没有超时的这些ip，记录下来。特别是香港和台湾的</p><p><img                       lazyload                     alt="image"                     data-src="https://img1.musnow.top/i/23/02/63ecdee791f45.png"                      alt="image-20230215213225991"                ></p><p><img                       lazyload                     alt="image"                     data-src="https://img1.musnow.top/i/23/02/63ecdef38a4ed.png"                      alt="image-20230215213238033"                ></p><p>要想知道这些ip在你这个地方能不能访问，那就采用windows命令行进行ping，能获取到信息就是ok的</p><p><img                       lazyload                     alt="image"                     data-src="https://img1.musnow.top/i/23/02/63ecdf3e94acd.png"                      alt="image-20230215213353171"                ></p><h1 id="3-改host"><a href="#3-改host" class="headerlink" title="3.改host"></a>3.改host</h1><p>windows下的文件路径是</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">C:\Windows\System32\drivers\etc\hosts</span><br></pre></td></tr></table></figure><p>下面提供可用的host，建议采用上面的办法自己找一下，因为ip是会变动的</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">13.224.161.52 api.themoviedb.org</span><br><span class="line">99.84.192.81 api.themoviedb.org</span><br><span class="line">13.33.33.60 api.themoviedb.org</span><br><span class="line">13.224.167.74 api.themoviedb.org</span><br><span class="line">13.35.166.20 api.themoviedb.org</span><br><span class="line">202.182.98.125 api.themoviedb.org</span><br><span class="line">13.224.205.59 api.themoviedb.org</span><br><span class="line">54.230.184.46 api.themoviedb.org</span><br><span class="line">31.13.67.19 api.themoviedb.org</span><br><span class="line">99.84.224.92 api.themoviedb.org</span><br><span class="line">99.84.224.149 api.themoviedb.org</span><br><span class="line">99.86.149.118 api.themoviedb.org</span><br><span class="line">65.9.83.54 api.themoviedb.org</span><br><span class="line">99.86.149.118 api.themoviedb.org</span><br><span class="line">13.224.163.98 api.themoviedb.org</span><br></pre></td></tr></table></figure><p>添加完毕后，以管理员身份保存文件（否则权限不足无法写入）</p><p>现在应该就可以了</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;tmm刮削器无法连接tmdb的解决办法（改host）&lt;/p&gt;</summary>
    
    
    
    <category term="捣鼓折腾nas" scheme="https://blog.musnow.top/categories/%E6%8D%A3%E9%BC%93%E6%8A%98%E8%85%BEnas/"/>
    
    
    <category term="nas" scheme="https://blog.musnow.top/tags/nas/"/>
    
  </entry>
  
  <entry>
    <title>【网络】http(s)协议 | content-length详解</title>
    <link href="https://blog.musnow.top/2023/02/15/note_Linux/35http%E4%B8%ADcontent-length/"/>
    <id>https://blog.musnow.top/2023/02/15/note_Linux/35http%E4%B8%ADcontent-length/</id>
    <published>2023-02-15T04:30:55.000Z</published>
    <updated>2023-02-15T11:28:13.686Z</updated>
    
    <content type="html"><![CDATA[<p>本文通过一个线上实例，详细介绍http协议中的content-length字段。</p><span id="more"></span><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>http协议是互联网中最重要的协议之一，虽然看上去很简单，但是实际中经常遇到问题，我们就已经遇到好几次了。有长连接相关的，有报文解析相关的。对http协议不能一知半解，必须透彻理解才行。</p><p>本文通过一个线上实例，详细介绍http协议中的content-length字段。</p><h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><p>我们的手机App在做更新时会从服务器上下载的一些资源，一般都是一些小文件，更新的代码差不多是下面这样的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">update</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="type">URL</span> <span class="variable">url</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">URL</span>(<span class="string">&quot;http://172.16.59.129:8000/update/test.so&quot;</span>);</span><br><span class="line">    <span class="type">HttpURLConnection</span> <span class="variable">conn</span> <span class="operator">=</span> (HttpURLConnection) url.openConnection();</span><br><span class="line">    <span class="keyword">if</span>(conn.getResponseCode() == <span class="number">200</span>) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">totalLength</span> <span class="operator">=</span> conn.getContentLength();</span><br><span class="line"><span class="type">BufferedInputStream</span> <span class="variable">in</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedInputStream</span>(conn.getInputStream());</span><br><span class="line"><span class="type">byte</span>[] buffer = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">512</span>];</span><br><span class="line"><span class="type">int</span> <span class="variable">readLength</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">length</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>((length=in.read(buffer)) != -<span class="number">1</span>) &#123;</span><br><span class="line">readLength += length;</span><br><span class="line"><span class="comment">//进度条</span></span><br><span class="line">System.out.println(((<span class="type">float</span>)readLength) /((<span class="type">float</span>)(totalLength)));</span><br><span class="line">&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>比如上面的代码更新一个so文件，先通过content-length获取文件的总大小，然后读Stream，每读一段，就计算出当前读的总大小，除以content-length，用来显示进度条。</p><p>结果weblogic从10升级到12后，content-length一直返回-1，这样就不能显示进度条了，但是文件流还能正常读。把weblogic重启了，一开始还能返回content-length，一会又是-1了。</p><h1 id="原因分析"><a href="#原因分析" class="headerlink" title="原因分析"></a>原因分析</h1><p>Http协议的请求报文和回复报文都有header和body，body就是你要获取的资源，例如一个html页面，一个jpeg图片，而header是用来做某些约定的。例如客户端与服务端商定一些传输格式，客户端先获取头部，得知一些格式信息，然后才开始读取body。</p><blockquote><p>客户端： Accept-Encoding:gzip （给我压缩一下，我用的是流量，先下载下来我再慢慢解压吧）</p><p>服务端1：Content-Encoding:null(没有Content-Encoding头。 我不给压缩，CPU没空，你爱要不要）</p><p>服务端2：Content-Encoding:gzip (给你节省流量，压缩一下）</p></blockquote><blockquote><p>客户端：Connection: keep-alive (大哥，咱好不容易建了个TCP连接，下次接着用）</p><p>服务端1: Connection: keep-alive （都不容易，接着用）</p><p>服务端2: Connection: close (谁跟你接着用，我们这个TCP是一次性的，下次再找我还得重新连)</p></blockquote><p>http协议没有三次握手，一般客户端向服务端请求资源时，以服务端为准。还有一些header并没有协商的过程，而是服务端直接告诉客户端按什么来。例如上述的Content-Length，是服务端告诉客户端body的大小有多大。但是！服务端并不一定能准确的提前告诉你body有多大。服务端要先写header，再写body，如果要在header里把body大小写进去，就得提前知道body大小。如果这个body是动态生成的，服务端先生成完，再开始写header，这样需要很多额外的开销，所以header里不一定有content-length。</p><p>那客户端怎么知道body的大小呢？服务器有三种方式告诉你。</p><p>1.服务器已经知道资源大小，通过content-length这个header告诉你。</p><pre><code>Content-Length:1076(body的大小是1076B，你读取1076B就可以完成任务了）Transfer-Encoding: null</code></pre><p>2.服务器没法提前知道资源的大小，或者不愿意花费资源提前计算资源大小，就会把http回复报文中加一个header叫Transfer-Encoding:chunked，就是分块传输的意思。每一块都使用固定的格式，前边是块的大小，后面是数据，然后最后一块大小是0。这样客户端解析的时候就需要注意去掉一些无用的字段。</p><pre><code>Content-Length:nullTransfer-Encoding:chunked (接下来的body我要一块一块的传，每一块开始是这一块的大小，等我传到大小为0的块时，就没了）</code></pre><p>3.服务器不知道资源的大小，同时也不支持chunked的传输模式，那么就既没有content-length头，也没有transfer-encoding头，这种情况下必须使用短连接，以连接结束来标示数据传输结束，传输结束就能知道大小了。这时候服务器返回的header里Connection一定是close。</p><pre><code>Content-Length:null Transfer-Encoding:null Connection:close(我不知道大小，我也用不了chunked，啥时候我关了tcp连接，就说明传输结束了）</code></pre><h1 id="实验"><a href="#实验" class="headerlink" title="实验"></a>实验</h1><p>我通过nginx在虚拟机里做实验，默认nginx是支持chunked模式的，可以关掉。</p><p>使用的代码如下，可能会调整参数。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">update</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="type">URL</span> <span class="variable">url</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">URL</span>(<span class="string">&quot;http://172.16.59.129:8000/update/test.so&quot;</span>);</span><br><span class="line">    <span class="type">HttpURLConnection</span> <span class="variable">conn</span> <span class="operator">=</span> (HttpURLConnection) url.openConnection();</span><br><span class="line">    <span class="comment">//conn.setRequestProperty(&quot;Accept-Encoding&quot;, &quot;gzip&quot;);</span></span><br><span class="line">    <span class="comment">//conn.setRequestProperty(&quot;Connection&quot;, &quot;keep-alive&quot;);</span></span><br><span class="line">    conn.connect();</span><br><span class="line">    <span class="keyword">if</span>(conn.getResponseCode() == <span class="number">200</span>) &#123;</span><br><span class="line">        System.out.println(conn.getHeaderFields().keySet());</span><br><span class="line">        System.out.println(conn.getHeaderField(<span class="string">&quot;transfer-encoding&quot;</span>));</span><br><span class="line">        System.out.println(conn.getHeaderField(<span class="string">&quot;Content-Length&quot;</span>));</span><br><span class="line">        System.out.println(conn.getHeaderField(<span class="string">&quot;Content-Encoding&quot;</span>));</span><br><span class="line">        System.out.println(conn.getHeaderField(<span class="string">&quot;Connection&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="1-nginx在开启chunked-transfer-encoding的时候"><a href="#1-nginx在开启chunked-transfer-encoding的时候" class="headerlink" title="1.nginx在开启chunked_transfer_encoding的时候"></a>1.nginx在开启chunked_transfer_encoding的时候</h2><p>(1) 在reqeust header里不使用gzip，也就是不加<code>accept-encoding: gzip</code></p><table><thead><tr><th>test.so文件大小</th><th>结果</th></tr></thead><tbody><tr><td>100B</td><td>能正常返回content-length,没有transfer-encoding头</td></tr><tr><td>69M</td><td>能正常返回content-length,没有transfer-encoding头</td></tr><tr><td>3072M</td><td>能正常返回content-length,没有transfer-encoding头</td></tr></tbody></table><p>可以发现nginx不管资源多大，如果客户端不接受gzip的压缩格式，就不会使用chunked模式，而且跟是否使用短连接没关系。</p><p>(2)在request header里加入gzip，<code>accepting-encoding: gzip</code></p><table><thead><tr><th>test.so文件大小</th><th>结果</th></tr></thead><tbody><tr><td>100B</td><td>没有content-length,transfer-encoding&#x3D;trunked</td></tr><tr><td>69M</td><td>没有content-length,transfer-encoding&#x3D;trunked</td></tr><tr><td>3072M</td><td>没有content-length,transfer-encoding&#x3D;trunked</td></tr></tbody></table><p>可以看到nginx在开启<code>chunked_transfer_encoding</code>，并且客户端接受gzip的时候，会使用chunked模式，nginx开启gzip后不会计算资源的大小，直接用chunked模式。</p><h2 id="2-nginx关闭chunked-transfer-encoding"><a href="#2-nginx关闭chunked-transfer-encoding" class="headerlink" title="2.nginx关闭chunked_transfer_encoding"></a>2.nginx关闭chunked_transfer_encoding</h2><p>(1) 在reqeust header里不使用gzip，也就是不加<code>accept-encoding:gzip</code></p><table><thead><tr><th>test.so文件大小</th><th>结果</th></tr></thead><tbody><tr><td>100B</td><td>能正常返回content-length,没有transfer-encoding头</td></tr><tr><td>69M</td><td>能正常返回content-length,没有transfer-encoding头</td></tr><tr><td>3072M</td><td>能正常返回content-length,没有transfer-encoding头</td></tr></tbody></table><p>因为能很容易的知道文件大小，所以nginx还是能返回content-length。</p><p>(2)在request header里加入gzip，<code>accepting-encoding:gzip</code></p><table><thead><tr><th>test.so文件大小</th><th>结果</th></tr></thead><tbody><tr><td>100B</td><td>没有content-length和transfer-encoding头，不论客户端connection为keep-alive还是close，服务端返回的connection头都是close</td></tr><tr><td>69M</td><td>没有content-length和transfer-encoding头，不论客户端connection为keep-alive还是close，服务端返回的connection头都是close</td></tr><tr><td>3072M</td><td>没有content-length和transfer-encoding头，不论客户端connection为keep-alive还是close，服务端返回的connection头都是close</td></tr></tbody></table><p>这就是上面说的第三种情况，不知道大小，也不支持trunked，那就必须使用短连接来标示结束。</p><h1 id="问题解决方案"><a href="#问题解决方案" class="headerlink" title="问题解决方案"></a>问题解决方案</h1><p>咨询了中间件组的同事，以前也遇到类似的问题，因为升级了Weblogic导致客户端解析XML出错，因为使用了chunked模式，中间有一些格式化的字符，而客户端解析的代码并没有考虑chunked模式的解析，导致解析出错。</p><p>因为我们客户端必须用content-length展示进度，因此不能用chunked模式，Weblogic可以把chunked模式关闭。用下面的方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">#!java weblogic.WLST </span><br><span class="line"><span class="title function_">connect</span><span class="params">(<span class="string">&#x27;username’,&#x27;</span>password<span class="string">&#x27;, &#x27;</span>t3://localhost:<span class="number">7001</span><span class="string">&#x27;)</span></span></span><br><span class="line"><span class="string"><span class="params">edit()</span></span></span><br><span class="line"><span class="string"><span class="params">startEdit()</span></span></span><br><span class="line"><span class="string"><span class="params">cd(&quot;Servers/AdminServer/WebServer/AdminServer&quot;)</span></span></span><br><span class="line"><span class="string"><span class="params">cmo.setChunkedTransferDisabled(true)</span></span></span><br><span class="line"><span class="string"><span class="params">save()</span></span></span><br><span class="line"><span class="string"><span class="params">activate()</span></span></span><br><span class="line"><span class="string"><span class="params">exit()</span></span></span><br></pre></td></tr></table></figure><p>改了之后，确实不返回chunked了，但是也没有content-length，因为Weblogic就是不提前获取文件大小，而是强制加了<code>connection:close</code>，也就是前边说的第三种，通过连接结束标识数据结束。最后只能把这些资源放倒apache里了。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>一个好的http客户端，必须充分实现协议，不然就可能出问题，浏览器对于服务端可能产生的各种情况都很好的做了处理，但是自己实现http协议的解析时一定得注意考虑多种情况。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">文章作者：牛立新</span><br><span class="line">原文链接：https://www.cnblogs.com/nxlhero/p/11670942.html</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;本文通过一个线上实例，详细介绍http协议中的content-length字段。&lt;/p&gt;</summary>
    
    
    
    <category term="玩上Linux" scheme="https://blog.musnow.top/categories/%E7%8E%A9%E4%B8%8ALinux/"/>
    
    
    <category term="网络" scheme="https://blog.musnow.top/tags/%E7%BD%91%E7%BB%9C/"/>
    
    <category term="http" scheme="https://blog.musnow.top/tags/http/"/>
    
    <category term="nginx" scheme="https://blog.musnow.top/tags/nginx/"/>
    
  </entry>
  
  <entry>
    <title>【网络】http(s)协议 | 介绍</title>
    <link href="https://blog.musnow.top/2023/02/15/note_Linux/34http%E5%8D%8F%E8%AE%AE/"/>
    <id>https://blog.musnow.top/2023/02/15/note_Linux/34http%E5%8D%8F%E8%AE%AE/</id>
    <published>2023-02-15T03:30:55.000Z</published>
    <updated>2023-02-16T14:40:34.003Z</updated>
    
    <content type="html"><![CDATA[<p>已经学习过自己定制一个协议了，现在就来看看当下广泛使用的http协议吧</p><span id="more"></span><h1 id="1-介绍"><a href="#1-介绍" class="headerlink" title="1.介绍"></a>1.介绍</h1><blockquote><p>超文本传输协议（Hyper Text Transfer Protocol，HTTP）是一个简单的请求-响应协议，它通常运行在TCP之上。它指定了客户端可能发送给服务器什么样的消息以及得到什么样的响应。</p></blockquote><p>http和https是当下最通用的协议之一，我们访问的大部分网页用的都是这个协议；</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://www.bilibili.com/</span><br></pre></td></tr></table></figure><p>这两个协议主要的差别，那就是http是用明文传输数据的，我们的数据在互联网裸奔，可能有安全问题；相比之下，https传输数据的过程会对数据进行加密，但这也不代表https是完全安全的。</p><h2 id="1-1-url"><a href="#1-1-url" class="headerlink" title="1.1 url"></a>1.1 url</h2><p>要认识这两个协议，我们要从url的认识开始；</p><p><code>HTTP(S)</code> 不允许使用用户名或密码，一个合法的 <code>HTTP(S)</code> URL 格式如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http(s)://&lt;host&gt;:&lt;port&gt;/&lt;path&gt;?&lt;query&gt;#&lt;frag&gt;</span><br></pre></td></tr></table></figure><ul><li>开头为协议名：http 或 https 协议； </li><li><code>&lt;host&gt;</code>：主机名。一个 URL 中，既可以使用域名也可以使用 IP 表示主机地址</li><li><code>&lt;port&gt;</code>：端口。主机名和端口之间使用冒号分隔。端口是可选的，如果省略将采用默认端口，http 默认端口是 80，https 默认端口 443；</li><li><code>&lt;path&gt;</code>：资源路径。资源在网络主机上的路径，路径也是可选的，缺省访问默认资源； </li><li><code>&lt;query&gt;</code>：查询参数。格式为 key&#x3D;value，多个参数使用 &amp; 分隔；参数也是可选的； </li><li><code>&lt;frag&gt;</code>：片段。从 # 开始到最后，一般用于定位到资源内的一个片段，比如文档的一个章节；片段也是可选的。</li></ul><h3 id="1-1-1-栗子-①"><a href="#1-1-1-栗子-①" class="headerlink" title="1.1.1 栗子 ①"></a>1.1.1 栗子 ①</h3><p>接下来举一个具体的例子</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://blog.musnow.top/2022/08/07/note_linux/6gdb_g++_make_vim/#4-make-x2F-makefile</span><br></pre></td></tr></table></figure><p>如上是我的个人博客中的一篇文章</p><ul><li>协议是https</li><li>域名是<code>blog.musnow.top</code>，对应的就是<code>&lt;host&gt;:&lt;port&gt;</code>；这里隐藏了端口，会在下面说明。</li><li><code>/2022/08/07/note_linux/6gdb_g++_make_vim/</code>这一长串都是文件的路径，其标示了文件在服务器上存放的位置</li><li>这个url内没有带<code>&lt;query&gt;</code>参数</li><li><code>#4-make-x2F-makefile</code>对应的是<code>&lt;frag&gt;</code>片段，标识了我当前浏览的位置</li></ul><p>当你把这个url粘贴道浏览器，其会直接跳转到对应的标题位置，而不是这篇文章的页首；这就是<code>&lt;frag&gt;</code>片段的作用</p><p><img                       lazyload                     alt="image"                     data-src="https://img1.musnow.top/i/23/02/63ec475e3c6a2.png"                      alt="image-20230215104544655"                ></p><h3 id="1-1-2-栗子-②"><a href="#1-1-2-栗子-②" class="headerlink" title="1.1.2 栗子 ②"></a>1.1.2 栗子 ②</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://www.baidu.com/s?tn=68018901_39_oem_dg&amp;ie=utf-8&amp;word=test</span><br></pre></td></tr></table></figure><p>当我们在百度搜索单词<code>test</code>的时候，百度的url中就会出现<code>&lt;query&gt;</code>参数；</p><p>其中<code>?</code>是参数的开头，后续的一串以<code>&amp;</code>分隔的kv键值对，就是参数的内容。在这里面我们能看到<code>word=test</code>，我们查询的单词test就在这个参数后；</p><p>我们的搜索访问，就是将这些参数传送给服务器，再由百度的服务器返回搜素结果的。</p><h2 id="1-2-域名和端口隐藏"><a href="#1-2-域名和端口隐藏" class="headerlink" title="1.2 域名和端口隐藏"></a>1.2 域名和端口隐藏</h2><p>但我们日常访问的网页中，很少见到过<code>ip:端口</code>的形式，而大多是用域名为我们提供服务的</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://www.bilibili.com/</span><br></pre></td></tr></table></figure><p>这并不代表其背后不需要端口号。而是因为如果我们的访问<strong>不指定端口</strong>的时候，http(s)协议会采用默认端口号80或443，从而实现隐藏端口号提供服务</p><blockquote><p>http 默认端口是 80，https 默认端口 443</p></blockquote><p>毕竟对于用户而言，记住一个域名已经不容易了，还要记住你的服务是在哪一个端口，那就更难了；</p><p>而域名也不是凭空给我们提供服务的，每一个域名都需要绑定一个具体的公网ip（域名解析），才能为用户提供服务。在域名的背后，都是一个ip，每一个ip也就是一台服务器。</p><p>域名的作用，就是来隐藏掉ip这个无规律的长数字，方便用户访问；</p><blockquote><p>你觉得是记住<code>baidu.com</code>容易，还是记住<code>114.514.77.58</code>容易呢？</p></blockquote><p>在命令行使用ping工具，我们能知道一个网站服务器的ip是什么</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ping www.bilibili.com</span><br></pre></td></tr></table></figure><p>比如我们ping一下b站的域名，可以看到其公网ip是<code>183.131.147.29</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">正在 Ping a.w.bilicdn1.com [183.131.147.29] 具有 32 字节的数据:</span><br><span class="line">来自 183.131.147.29 的回复: 字节=32 时间=10ms TTL=55</span><br><span class="line">来自 183.131.147.29 的回复: 字节=32 时间=12ms TTL=55</span><br><span class="line">来自 183.131.147.29 的回复: 字节=32 时间=12ms TTL=55</span><br><span class="line">来自 183.131.147.29 的回复: 字节=32 时间=12ms TTL=55</span><br><span class="line"></span><br><span class="line">183.131.147.29 的 Ping 统计信息:</span><br><span class="line">    数据包: 已发送 = 4，已接收 = 4，丢失 = 0 (0% 丢失)，</span><br><span class="line">往返行程的估计时间(以毫秒为单位):</span><br><span class="line">    最短 = 10ms，最长 = 12ms，平均 = 11ms</span><br></pre></td></tr></table></figure><h2 id="1-3-ip-端口"><a href="#1-3-ip-端口" class="headerlink" title="1.3 ip:端口"></a>1.3 ip:端口</h2><p>我们可以用<code>ip:端口</code>来访问自己的服务（以下ip纯属虚构，如有撞车，纯属巧合）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">114.514.77.58:8080</span><br></pre></td></tr></table></figure><p>当我们把这个粘贴道浏览器，再复制粘贴出来的时候，我们会发现前面多了一个http</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://114.514.77.58:8080</span><br></pre></td></tr></table></figure><p>这是因为当我们使用ip访问一个服务的时候，浏览器会默认采用http的协议去访问，所以在前面加了一个我们看不到的<code>http://</code></p><h2 id="1-4-协议作用"><a href="#1-4-协议作用" class="headerlink" title="1.4 协议作用"></a>1.4 协议作用</h2><p>http协议的作用，就是向<strong>服务器</strong>申请特定的资源，再将资源拉取到本地进行展示or使用。</p><p>资源都是存在我们的服务器上的，当用户请求的时候，服务器必须要知道资源的路径，将其<code>read</code>打开读取，再<code>write</code>写给我们的客户端。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/2022/08/07/note_linux/6gdb_g++_make_vim/</span><br></pre></td></tr></table></figure><p>所以http的请求中才会带上资源的路径，这是方便服务器进行资源文件的读取；同时，文件的路径也是对一个文件的唯一标识，在告诉服务器文件路径的同时，也保证了我们请求的文件的唯一性，不会出现二义性；</p><hr><p>这时候又会出现一个问题，当我们访问网站的根目录的时候，没有提供文件的路径呀，那这时候，访问的什么文件呢？</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://www.baidu.com/</span><br></pre></td></tr></table></figure><p>实际上，我们访问的是服务器根目录的<code>index.html</code>文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">https://www.baidu.com/</span><br><span class="line">https://www.baidu.com/index.html</span><br></pre></td></tr></table></figure><p>你可以试着打开这两个链接，其出现的页面是完全一致的；</p><p><img                       lazyload                     alt="image"                     data-src="https://img1.musnow.top/i/23/02/63ec4cb9820b6.png"                      alt="image-20230215110843400"                ></p><p>类似于端口号隐藏，http协议也确定了当下使用的网页文件的命名为<code>index.html</code>，当我们访问一个网站的时候，就会默认访问根目录下的<code>index.html</code>文件（既然是默认的，那就可以直接隐藏）如果这个文件不存在，那就不会渲染出我们看到的网页！</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">index.html是用前端语言编写的网页代码</span><br></pre></td></tr></table></figure><p>同理，当我们访问博客的时候，读取道的也不是目录，而是目录下的<code>index.html</code>文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://blog.musnow.top/2022/08/07/note_linux/6gdb_g++_make_vim/</span><br></pre></td></tr></table></figure><p><img                       lazyload                     alt="image"                     data-src="https://img1.musnow.top/i/23/02/63ec4d38428a8.png"                      alt="image-20230215111050026"                ></p><p>我的博客使用的是hexo框架，其网页的源路径在github上开源了，可以帮助你理解url中的文件路径。</p><p>当前你看到的文件目录，就是博客服务的根目录。访问的博客首页，就是根目录下的<code>index.html</code></p><p><img                       lazyload                     alt="image"                     data-src="https://img1.musnow.top/i/23/02/63ec4d71b69ed.png"                      alt="image-20230215111147560"                ></p><p>用作示例的<a href="https://blog.musnow.top/2022/08/07/note_linux/6gdb_g++_make_vim/index.html">linux工具使用</a>博客，也可以根据它的路径，找到<code>index.html</code>文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/2022/08/07/note_linux/6gdb_g++_make_vim/</span><br></pre></td></tr></table></figure><p><img                       lazyload                     alt="image"                     data-src="https://img1.musnow.top/i/23/02/63ec4e066de99.png"                      alt="image-20230215111416443"                ></p><p>这便是http协议url中文件路径的作用！</p><p>这里的<code>/</code>根目录是<strong>服务端设置</strong>的，并不一定是（大概率不是）服务端linux服务器的根目录</p><h2 id="1-5-编码解码"><a href="#1-5-编码解码" class="headerlink" title="1.5 编码解码"></a>1.5 编码解码</h2><p>在url中，还会对一些特殊字符进行编解码，比如中文，和一些特殊的符号</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://blog.musnow.top/2022/08/07/note_linux/6gdb_g++_make_vim/#4-make-x2F-makefile</span><br></pre></td></tr></table></figure><p>比如在作为示例的url中，这里出现了<code>x2F</code>，而原文中是<code>4.make/makefile</code>;这里的编码就是为了避免<code>make/makefile</code>被识别成路径的标识符，从而出现错误。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://www.baidu.com/s?tn=68018901_39_oem_dg&amp;ie=utf-8&amp;word=%E4%BD%A0%E5%A5%BD</span><br></pre></td></tr></table></figure><p>当url路径中有中文的时候，也会被转码成特定的格式</p><p><img                       lazyload                     alt="image"                     data-src="https://img1.musnow.top/i/23/02/63ec503e1f0d6.png"                      alt="image-20230215112344227"                ></p><p>我们在浏览器上看到的依旧是中文，这是因为浏览器这段帮我们进行了解码</p><blockquote><p>将需要转码的字符转为16进制，然后从右到左，取4位(不足4位直接处理)，每2位做一位，前面加上%，编码成<code>%XY</code>格式</p></blockquote><h1 id="2-http协议请求格式"><a href="#2-http协议请求格式" class="headerlink" title="2.http协议请求格式"></a>2.http协议请求格式</h1><p>了解了http协议中的url网址，现在就可以进一步了解http协议的报头和报文了;</p><p>一个<code>http request/response</code>的基本格式如下</p><p><img                       lazyload                     alt="image"                     data-src="https://img1.musnow.top/i/23/02/63ec536219bf8.png"                      alt="image-20230215113707995"                ></p><p>在请求中，客户端会提供自己的请求方法（GET&#x2F;POST&#x2F;PUT等等），并提供url来标识自己需要的文件路径；这个url可能是短链接（截取根目录之后的部分），也有可能是完整的链接。</p><p>随后，就会跟上一大堆的请求参数，注意，这里的请求参数并不是url中的<code>&lt;query&gt;</code>参数，而是http协议自身的请求参数。每一个请求参数都用了<code>\r\n</code>作为分隔，这和我们写的<a href="https://blog.musnow.top/2023/02/11/note_linux/32tcp%E5%AE%9E%E7%8E%B0%E8%87%AA%E5%AE%9A%E4%B9%89%E5%8D%8F%E8%AE%AE/#3-1-%E5%8D%8F%E8%AE%AE%E5%AE%9A%E5%88%B6">自定义协议</a>中采用<code>\t</code>进行分割是相同的原理！</p><p>这几个部分中，请求的正文可以不带（为空）</p><h2 id="2-1-读取多长？"><a href="#2-1-读取多长？" class="headerlink" title="2.1 读取多长？"></a>2.1 读取多长？</h2><p>为了让协议读取的时候，能够知道什么时候读取完毕了报头，http协议提供了一个<code>\r\n</code>的空行，读取道这个空行，就代表报头读取完毕了，剩下的内容都是报文。</p><p>而为了标识报文的长度，http协议会在发送的时候提供一个参数<code>content-length</code>，用于标识报文的长度。在读取完毕报头后，肯定是读取到了这个<code>content-length</code>参数的，也就知道后续应该继续读取多长，才能读完整个协议字段！</p><p>关于这部分的介绍，可以查看另外一篇博客 <a href="https://blog.musnow.top/2023/02/15/note_Linux/35http%E4%B8%ADcontent-length/">http协议content-length详解</a></p><h2 id="2-2-响应的状态码"><a href="#2-2-响应的状态码" class="headerlink" title="2.2 响应的状态码"></a>2.2 响应的状态码</h2><p>和我们进程的退出状态一样，http也表明了一部分响应的状态码，其中我们日常最常见到的，是<code>404/403</code>这两个状态码</p><blockquote><p><a class="link"   href="https://baike.baidu.com/item/HTTP%E7%8A%B6%E6%80%81%E7%A0%81/5053660" >http状态码-百度百科<i class="fas fa-external-link-alt"></i></a></p></blockquote><p>状态码就是标识服务器提供的服务状态，告诉客户端它的请求是否成功了。如果状态码是200，代表请求是成功的。其余状态码会有各自的使用场景，比如404状态码，代表请求的资源不存在，所以才叫 <code>404 not found!</code></p><h1 id="3-实例"><a href="#3-实例" class="headerlink" title="3.实例"></a>3.实例</h1><p>完整代码详见 <a class="link"   href="https://gitee.com/musnow/raspberry-practice/tree/master/code" >Gitee<i class="fas fa-external-link-alt"></i></a></p><h2 id="3-1-前端页面"><a href="#3-1-前端页面" class="headerlink" title="3.1 前端页面"></a>3.1 前端页面</h2><p>由于本人并没有学习过前端语法，这里采用 <a class="link"   href="https://www.runoob.com/html/html-tutorial.html" >菜鸟教程<i class="fas fa-external-link-alt"></i></a> 提供的前端示例代码来演示</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;utf-8&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">title</span>&gt;</span>菜鸟教程(runoob.com)<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>我的第一个标题<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>我的第一个段落。<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>我们日常所访问的网页都是这样的代码，经由浏览器进行渲染，再展示出来</p><h2 id="3-2-服务端代码"><a href="#3-2-服务端代码" class="headerlink" title="3.2 服务端代码"></a>3.2 服务端代码</h2><p>由于http是基于tcp的，这里直接把之前写的tcpServer搬过来就能用！具体的代码解析请看注释，想必说的是很清楚的</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> CRLF <span class="string">&quot;\r\n&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CRLF_LEN strlen(CRLF)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SPACE <span class="string">&quot; &quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SPACE_LEN strlen(SPACE)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> HOME_PAGE <span class="string">&quot;index.html&quot;</span> <span class="comment">// 首页文件</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ROOT_PATH <span class="string">&quot;web&quot;</span> <span class="comment">// 网址根目录地址</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取http请求中的路径</span></span><br><span class="line"><span class="function">string <span class="title">getPath</span><span class="params">(string http_request)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">size_t</span> pos = http_request.<span class="built_in">find</span>(CRLF);<span class="comment">//找到第一行的分隔符</span></span><br><span class="line">    <span class="keyword">if</span>(pos == string::npos) </span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">    string request_line = http_request.<span class="built_in">substr</span>(<span class="number">0</span>, pos);<span class="comment">//取出第一行</span></span><br><span class="line">    <span class="comment">//请求的第一行：GET /a/b/c http/1.0</span></span><br><span class="line">    <span class="type">size_t</span> first = request_line.<span class="built_in">find</span>(SPACE);<span class="comment">// 找到第一个空格</span></span><br><span class="line">    <span class="keyword">if</span>(pos == string::npos) </span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="type">size_t</span> second = request_line.<span class="built_in">rfind</span>(SPACE); <span class="comment">// 从后往前找空格</span></span><br><span class="line">    <span class="keyword">if</span>(pos == string::npos) </span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="comment">// 找到两个空格了，两个空格之间的就是请求的路径</span></span><br><span class="line">    string path = request_line.<span class="built_in">substr</span>(first+SPACE_LEN, second - (first+SPACE_LEN));</span><br><span class="line">    <span class="keyword">if</span>(path.<span class="built_in">size</span>() == <span class="number">1</span> &amp;&amp; path[<span class="number">0</span>] == <span class="string">&#x27;/&#x27;</span>) &#123;</span><br><span class="line">        path += HOME_PAGE; <span class="comment">//再加上被隐藏的index.html文件名</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> path;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 读取文件</span></span><br><span class="line"><span class="function">string <span class="title">readFile</span><span class="params">(<span class="type">const</span> string &amp;recource)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">ifstream <span class="title">in</span><span class="params">(recource, ios::binary)</span></span>;</span><br><span class="line">    <span class="keyword">if</span>(!in.<span class="built_in">is_open</span>()) <span class="comment">//文件打开失败</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;404&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 内容</span></span><br><span class="line">    string content;</span><br><span class="line">    string line;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">getline</span>(in, line))</span><br><span class="line">    &#123;</span><br><span class="line">        content += line;</span><br><span class="line">    &#125;</span><br><span class="line">    in.<span class="built_in">close</span>();</span><br><span class="line">    <span class="keyword">return</span> content;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">handlerHttpRequest</span><span class="params">(<span class="type">int</span> sock)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;###########start#############&quot;</span> &lt;&lt; endl;<span class="comment">//打印一个分隔线</span></span><br><span class="line">    <span class="type">char</span> buffer[<span class="number">10240</span>];</span><br><span class="line">    <span class="type">ssize_t</span> s = <span class="built_in">read</span>(sock, buffer, <span class="built_in">sizeof</span>(buffer));</span><br><span class="line">    <span class="keyword">if</span>(s &gt; <span class="number">0</span>)&#123;</span><br><span class="line">        cout &lt;&lt; buffer &lt;&lt; endl;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;###########end############&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    string path = <span class="built_in">getPath</span>(buffer);</span><br><span class="line">    <span class="comment">// 假设用户请求的是 /a/b 路径</span></span><br><span class="line">    <span class="comment">// 那么服务端处理的时候，就需要添加根目录位置和默认的文件名</span></span><br><span class="line">    <span class="comment">// &lt;root&gt;/a/b/index.html</span></span><br><span class="line">    <span class="comment">// 在本次用例中，根目录为 ./web文件夹，所以完整的文件路径应该是</span></span><br><span class="line">    <span class="comment">// ./web/a/b/index.html</span></span><br><span class="line"></span><br><span class="line">    string resources = ROOT_PATH; <span class="comment">// 根目录路径</span></span><br><span class="line">    resources += path; <span class="comment">// 文件路径</span></span><br><span class="line">    <span class="built_in">logging</span>(DEBUG,<span class="string">&quot;[sockfd: %d] filePath: %s&quot;</span>,sock,resources.<span class="built_in">c_str</span>()); <span class="comment">// 打印用作debug</span></span><br><span class="line"></span><br><span class="line">    string html = <span class="built_in">readFile</span>(resources);<span class="comment">// 打开文件</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 开始响应</span></span><br><span class="line">    string response = <span class="string">&quot;HTTP/1.0 200 OK\r\n&quot;</span>;</span><br><span class="line">    <span class="comment">//如果readFile返回的是404，代表文件路径不存在</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">strcmp</span>(html.<span class="built_in">c_str</span>(),<span class="string">&quot;404&quot;</span>)==<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        response = <span class="string">&quot;HTTP/1.0 404 NOT FOUND\r\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 追加后续字段</span></span><br><span class="line">    response += <span class="string">&quot;Content-Type: text/html\r\n&quot;</span>;</span><br><span class="line">    response += (<span class="string">&quot;Content-Length: &quot;</span> + <span class="built_in">to_string</span>(html.<span class="built_in">size</span>()) + <span class="string">&quot;\r\n&quot;</span>);</span><br><span class="line">    response += <span class="string">&quot;\r\n&quot;</span>;</span><br><span class="line">    response += html;</span><br><span class="line">    <span class="comment">// 发送给用户</span></span><br><span class="line">    <span class="built_in">send</span>(sock, response.<span class="built_in">c_str</span>(), response.<span class="built_in">size</span>(), <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-3-测试"><a href="#3-3-测试" class="headerlink" title="3.3 测试"></a>3.3 测试</h2><p>启动服务器之前，请先打开你的云服务器防火墙中的对应端口；这里我绑定的是端口10000，在浏览器中用<code>ip:端口</code>的方式可以正常访问！</p><p><img                       lazyload                     alt="image"                     data-src="https://img1.musnow.top/i/23/02/63ec6f01b93dd.png"                      alt="image-20230215133459929"                ></p><p>这里标识的<code>不安全</code>是因为我们没有采用带加密的https协议，这不是当下需要考虑的问题。不管他就可以了。</p><p>按F12打开开发者页面，可以看到下方出现了完整的html代码，我们成功提供了服务！</p><p><img                       lazyload                     alt="image"                     data-src="https://img1.musnow.top/i/23/02/63ec720503cdc.png"                      alt="image-20230215134751216"                ></p><h2 id="3-4-后端打印的报文"><a href="#3-4-后端打印的报文" class="headerlink" title="3.4 后端打印的报文"></a>3.4 后端打印的报文</h2><p>在服务器后端，我们看到其打印出来了一个基本的http请求，和上面说明的格式是一样的。这里简单的进行一部分说明：</p><ul><li>GET：请求方式为获取数据</li><li><code>/</code>：请求的是根路径</li><li><code>HTTP/1.1</code>：使用的http协议版本</li><li><code>Connetion</code>：代表我们和服务器的链接方式，keep-alive代表保持连接</li><li><code>User-Agent</code>：客户端信息，可以看到是windows系统、Chrome内核的浏览器（我是用的是edge浏览器）</li><li>Accept: 支持接收的信息类型</li><li><code>Aceept-Encoding</code>: 对信息进行压缩</li><li><code>Accept-Language</code>：支持的语言</li><li><code>Cookie</code>：身份信息，后面会详细介绍</li></ul><p>其中出现了一个空行，代表报文结束；</p><p><img                       lazyload                     alt="image"                     data-src="https://img1.musnow.top/i/23/02/63ec78b4c5cf2.png"                      alt="image-20230215141623151"                ></p><p>往下滑，会发现浏览器还发出了第二个请求，路径是<code>/favicon.ico</code>，这是默认的站点头像文件的命名。因为我们的html文件中没有写明站点头像的路径，所以浏览器就尝试请求默认的头像文件</p><p>但是，当前我们的站点根目录web下并没有该文件，应该返回一个404状态码。</p><ul><li>请求中出现了一个新的参数<code>Referer</code>，代表是从当前网页请求头像的。相比之下，请求网页的报文中没有<code>Referer</code>参数</li></ul><p><img                       lazyload                     alt="image"                     data-src="https://img1.musnow.top/i/23/02/63ec8b10b0daf.png"                      alt="image-20230215153442298"                ></p><p>此时可以随便找个图片做头像，看看能不能加载出来；为了方便，我随便找了一张纯绿色的图片，并将其<a class="link"   href="http://www.ico51.cn/" >在线转换为ico<i class="fas fa-external-link-alt"></i></a>，放入了站点的根目录。</p><p>重启服务器进程，刷新浏览器再次请求，可以看到成功出现了站点的头像；</p><p><img                       lazyload                     alt="image"                     data-src="https://img1.musnow.top/i/23/02/63ec7575b082e.png"                      alt="image-20230215140232033"                ></p><h2 id="3-5-常见参数表"><a href="#3-5-常见参数表" class="headerlink" title="3.5 常见参数表"></a>3.5 常见参数表</h2><p><img                       lazyload                     alt="image"                     data-src="https://img1.musnow.top/i/23/02/63ec8de7299b2.png"                      alt="img"                ></p><h1 id="4-请求方法"><a href="#4-请求方法" class="headerlink" title="4.请求方法"></a>4.请求方法</h1><p>一般我们获取一个网页，用的都是GET方法。接下来用一个带按钮的表单创建请求，尝试向服务端发送<code>&lt;query&gt;</code>参数</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;utf-8&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">title</span>&gt;</span>菜鸟教程(runoob.com)<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>我的第一个标题<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>我的第一个段落。<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">&quot;/a/index.html&quot;</span> <span class="attr">method</span>=<span class="string">&quot;get&quot;</span>&gt;</span></span><br><span class="line">    Username: <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">name</span>=<span class="string">&quot;user&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">    Password: <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;password&quot;</span> <span class="attr">name</span>=<span class="string">&quot;passwd&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span> <span class="attr">value</span>=<span class="string">&quot;Submit&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="4-1-GET"><a href="#4-1-GET" class="headerlink" title="4.1 GET"></a>4.1 GET</h2><p>在method里面，我们指定了get方法，此时</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">&quot;/a/index.html&quot;</span> <span class="attr">method</span>=<span class="string">&quot;get&quot;</span>&gt;</span></span><br><span class="line">    Username: <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">name</span>=<span class="string">&quot;user&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">    Password: <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;password&quot;</span> <span class="attr">name</span>=<span class="string">&quot;passwd&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span> <span class="attr">value</span>=<span class="string">&quot;Submit&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure><p>此时页面中出现了两个输入框，供我们输入密码，且密码会显示为<code>****</code>而不是明文</p><p><img                       lazyload                     alt="image"                     data-src="https://img1.musnow.top/i/23/02/63ec89644d733.png"                      alt="image-20230215152726050"                ></p><p>点击按钮，会跳转到一个404页面，这是因为我们的<code>a/index.html</code>路径并不支持参数请求，所以发送了404错误码</p><p><img                       lazyload                     alt="image"                     data-src="https://img1.musnow.top/i/23/02/63ec89a063d20.png"                      alt="image-20230215152834203"                ></p><p>不过这不重要，我们看看后端打印的内容。其中参数是追加到url中，以明文传输过来的；正文部分为空，并没有携带参数</p><p><img                       lazyload                     alt="image"                     data-src="https://img1.musnow.top/i/23/02/63ec8b5dd10c0.png"                      alt="image-20230215153559515"                ></p><h2 id="4-2-POST"><a href="#4-2-POST" class="headerlink" title="4.2 POST"></a>4.2 POST</h2><p>将请求方法改成post，再次尝试</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">&quot;/a/index.html&quot;</span> <span class="attr">method</span>=<span class="string">&quot;post&quot;</span>&gt;</span></span><br><span class="line">    Username: <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">name</span>=<span class="string">&quot;user&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">    Password: <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;password&quot;</span> <span class="attr">name</span>=<span class="string">&quot;passwd&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span> <span class="attr">value</span>=<span class="string">&quot;Submit&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这时候能正常显示出<code>a/index.html</code>页面，url中不再带有参数</p><p><img                       lazyload                     alt="image"                     data-src="https://img1.musnow.top/i/23/02/63ec8beb1e0c5.png"                      alt="image-20230215153820898"                ></p><p>此时查看后端中的信息，能看到请求方法变为POST，参数出现在了正文部分，而不是url中</p><p><img                       lazyload                     alt="image"                     data-src="https://img1.musnow.top/i/23/02/63ec8c2e7faa5.png"                      alt="image-20230215153928118"                ></p><h2 id="4-3-GET-x2F-POST区别"><a href="#4-3-GET-x2F-POST区别" class="headerlink" title="4.3 GET&#x2F;POST区别"></a>4.3 GET&#x2F;POST区别</h2><p>这也是GET和POST方法的区别之一：</p><ul><li>GET方法通过url传参</li><li>POST方法会将url参数提取出来，拼接到正文部分</li></ul><p>由此能推出二者的安全性区别</p><ul><li>GET方法相对不安全，因为参数直接以明文贴在了url上</li><li>POST方法以正文传参，使用https协议的时候能进行加密，相对较安全</li></ul><h2 id="4-4-更多方法"><a href="#4-4-更多方法" class="headerlink" title="4.4 更多方法"></a>4.4 更多方法</h2><p>http请求还支持更多方法，如下</p><p><img                       lazyload                     alt="image"                     data-src="https://img1.musnow.top/i/23/02/63ec8daba6e19.png"                      alt="img"                ></p><h1 id="5-状态码"><a href="#5-状态码" class="headerlink" title="5.状态码"></a>5.状态码</h1><h2 id="5-1-状态码表"><a href="#5-1-状态码表" class="headerlink" title="5.1 状态码表"></a>5.1 状态码表</h2><p>下面是一个响应状态码的总表</p><p><img                       lazyload                     alt="image"                     data-src="https://img1.musnow.top/i/23/02/63ec8ef551dec.png"                      alt="image-20230215155118813"                ></p><h2 id="5-2-404-x2F-403状态码"><a href="#5-2-404-x2F-403状态码" class="headerlink" title="5.2 404&#x2F;403状态码"></a>5.2 404&#x2F;403状态码</h2><p>我们能看到404和403都是客户端状态码，为什么说是客户端错误呢？这是因为你向服务器请求了一个服务器没有的资源，<strong>这个问题不应该是服务器的问题</strong>。</p><p>这就好比你去西瓜摊买肉，人家压根不卖肉。问题出在你身上，你不应该找西瓜摊老板买肉。所以404状态码，应该是客户端的问题！</p><p>而403状态码的含义是<code>403 forbidden</code>，服务器拒绝了你的请求（你没有权限访问）这也是客户端的问题。你不能去超市买东西，然后问老板能不能让你看看老板的钱罐子。老板肯定不给你看啊！所以才会告诉你403，不给你访问。</p><h2 id="5-3-5xx状态码"><a href="#5-3-5xx状态码" class="headerlink" title="5.3 5xx状态码"></a>5.3 5xx状态码</h2><p>什么时候会出现服务器错误的5xx状态码呢？</p><p>当你请求一个服务，服务端需要处理之后给你返回结果。此时服务器在处理过程中，可能因为程序有bug提前退出，这时候就应该给客户端发送一个<code>5xx</code>状态码，标识服务器在处理你的请求的过程中，出现了错误，无法返回结果。</p><h2 id="5-4-301-x2F-302重定向"><a href="#5-4-301-x2F-302重定向" class="headerlink" title="5.4 301&#x2F;302重定向"></a>5.4 301&#x2F;302重定向</h2><p>关于3开头的状态码，主要谈谈下面这两个</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">301 永久重定向</span><br><span class="line">302 临时重定向</span><br></pre></td></tr></table></figure><p>为何一个是永久，一个是临时呢？</p><p>在http进行响应的时候，服务端可以发送一个<code>location</code>参数，发送一个新的url给客户端；我们的浏览器在收到这个参数后，会自动打开对应的页面</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Location: https://www.baidu.com/</span><br></pre></td></tr></table></figure><p>我们可以用上面的代码来测试一下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 尝试进行302重定向</span></span><br><span class="line">string response = <span class="string">&quot;HTTP/1.1 302 Temporarily moved\r\n&quot;</span>;</span><br><span class="line">response+= <span class="string">&quot;Location: https://www.baidu.com/\r\n&quot;</span>;</span><br><span class="line">response+= <span class="string">&quot;\r\n&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 发送给用户</span></span><br><span class="line"><span class="built_in">send</span>(sock, response.<span class="built_in">c_str</span>(), response.<span class="built_in">size</span>(), <span class="number">0</span>);</span><br></pre></td></tr></table></figure><p>此时访问我们自己的<code>IP:端口</code>，会跳转到百度的页面。这就是重定向的作用</p><p><img                       lazyload                     alt="image"                     data-src="https://img1.musnow.top/i/23/02/63ec9497019d5.png"                      alt="image-20230215161520817"                ></p><ul><li>那临时重定向和永久重定向有什么区别呢?</li></ul><p>假如我设立了一个公开站点，域名是<code>test.com</code>，这几年一直提供服务，积累了一部分的用户。过了一会，我不想要这个域名了，想换一个<code>test.cn</code>；可用户已经有那么多，大家都只记得你的<code>test.com</code>，如果直接更换域名，就会导致用户无法访问<code>test.com</code>，以为你跑路了，就放弃使用你的网页。</p><p>这样的结果显而易见：严重的客户流失！</p><p>所以，为了避免这个问题，我可以先将服务迁移到<code>test.cn</code>新域名，在旧域名<code>test.com</code>中设置一个301重定向到<code>test.cn</code>，告诉用户我换新域名了。这样持续一段时间后，等到<code>test.com</code>的使用者不多了，就可以考虑彻底取消<code>test.com</code>的解析，关停此域名了。</p><p>在上面的场景中，我是需要更换域名，是永久更换。我们就应该把状态码设置为301，告诉客户端这个域名将被永久重定向到另外一个域名上</p><hr><p>另外的情况是，我有一个<code>example.com</code>域名，我的服务需要进行维护；此时就将<code>example.com</code>重定向到另外一个域名<code>example.cn</code>，指向另外一个服务器，让这个服务器临时提供服务。</p><p>服务维护完毕后，就将重定向取消，继续使用当前的服务器。</p><p>这个场景中，重定向只是维护期间的一个临时策略，所以状态码设置成302，告诉客户端我只是临时进行重定向，我还会回来的。</p><h1 id="6-cookie-x2F-session"><a href="#6-cookie-x2F-session" class="headerlink" title="6.cookie&#x2F;session"></a>6.cookie&#x2F;session</h1><p>日常生活中，当我们在一个web页面中登录了（如github&#x2F;gitee&#x2F;csdn）这个网页在很长一段时间内都会保持登录，直到超时亦或者是出现了异地访问。</p><p>假如你现在有个网页，但是每次用户访问的时候，都需要重新输入用户名和密码，刚刚输入过了，换一个页面又不行了。这样一来，用户还会想用你这个服务吗？</p><p>为了避免此类问题，http协议就需要引入其他的参数，来维持用户的登录会话。cookie&#x2F;session便是因此而来的。</p><h2 id="6-1-set-cookie"><a href="#6-1-set-cookie" class="headerlink" title="6.1 set cookie"></a>6.1 set cookie</h2><p>服务端可以在响应头中带上<code>Set-Cookie</code>字段，给客户端设置上cookie</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">response += <span class="string">&quot;Set-Cookie: This is my cookie test\r\n&quot;</span>;</span><br></pre></td></tr></table></figure><p>打开f12开发者界面，能在其中看到我们设置的cookie</p><p><img                       lazyload                     alt="image"                     data-src="https://img1.musnow.top/i/23/02/63eca303c2533.png"                      alt="image-20230215171652910"                ></p><p>再次刷新网页，可以看到在之后的请求中，浏览器都会发送一次服务器设置的cookie。这样服务端在收到cookie后，就能解析到自己设置的cookie，确定了指定的用户</p><p><img                       lazyload                     alt="image"                     data-src="https://img1.musnow.top/i/23/02/63eca34befdf0.png"                      alt="image-20230215171805924"                ></p><p>在服务器端也能看到这个字段</p><p><img                       lazyload                     alt="image"                     data-src="https://img1.musnow.top/i/23/02/63eca54f23dfe.png"                      alt="image-20230215172640992"                ></p><h2 id="6-2-什么是cookie"><a href="#6-2-什么是cookie" class="headerlink" title="6.2 什么是cookie"></a>6.2 什么是cookie</h2><p>所谓cookie，其实就是浏览器帮我们存取了一定的身份信息在本地（内存or磁盘）</p><p>下一次打开特定的网页的时候，就能显示对应的身份信息（不一定是你的账户密码），并告诉服务器，服务器就识别到了你当前的用户，并为你保持登陆状态。</p><p>既然是保存在用户本地的，那就有可能被窃取。一些恶意软件就会去扫描你浏览器本地缓存中的cookie信息，对于一些安全性不高的网站而言，有了这个cookie，就相当于他有了你的账户，可以直接登录你的账户进行操作。</p><p>因此，引入了另外一种身份认证的方式 <code>cookie+session</code></p><h2 id="6-3-cookie-session"><a href="#6-3-cookie-session" class="headerlink" title="6.3 cookie+session"></a>6.3 cookie+session</h2><p>比起将身份信息存到客户端，存至服务端更为安全（攻击企业服务器的成本，比在用户端植入木马程序的成本更高）</p><ul><li>用户使用账户密码请求登录，服务器收到登录请求，验证成功后，给客户端返回一个<code>唯一字符串session_id</code>来标识用户</li><li>客户端下一次请求的时候，带上了这个唯一字符串</li><li>服务器收到请求，在本地的<code>session_id</code>库中查找这个id，找到后，就将用户信息匹配给客户端，相当于客户端登录成功了</li></ul><p>这样，就将原本存在用户本地的身份认证信息，<strong>存到了服务端中</strong>。客户端就只剩下一个孤零零的字符串id，不会有用户的私密信息。即便丢失，也不会影响用户的隐私。</p><ul><li>你可能会说，那我偷走这个id不也是一样的效果？</li></ul><p>其实没有那么简单，服务端可以将<code>session_id</code>和用户的ip或者终端User-Agent绑定，这样只要用户<strong>切换设备</strong>或者<strong>换了登录的地点</strong>（比如从三亚跑到了哈尔滨）就直接让<code>session_id</code>失效，要求用户重新登录。</p><h1 id="7-长短链接"><a href="#7-长短链接" class="headerlink" title="7.长短链接"></a>7.长短链接</h1><p>在早期的http协议中，采用的都是短链接，一次连接只能处理1次http请求。当时的网页大多以文字为主，数据量很小，一起请求也能够满足需求。</p><p>但现在时代已经变了，一个网页里面有图片，文字，音频，视频。这些文件的体积打起来之后，短链接的方式就不适用了。此时就出现了长链接，一次tcp链接，可以持续传输数据。</p><p>相比短链接，长链接连上之后，能持续传输数据，<strong>避免了tcp3次握手的消耗</strong>，提高了数据传输的效率！</p><h2 id="7-1-Connetion"><a href="#7-1-Connetion" class="headerlink" title="7.1 Connetion"></a>7.1 Connetion</h2><p>在本文的<code>3.4</code>中，便出现了这个参数，一般情况下，会有下面两种情况</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Connetion: keep-alive</span><br><span class="line">Connetion: closed</span><br></pre></td></tr></table></figure><p>其中<code>keep-alive</code>就是长链接，<code>closed</code>代表当前端口只支持短链接。</p><p>当客户端发送的请求头中包含<code>Connetion: keep-alive</code>字段，如果服务器支持长链接，就需要在响应头中也带上<code>Connetion: keep-alive</code>，这样双方协商成功，大家都可以使用长链接。</p><p>如果服务器的响应头中没有带<code>Connetion: keep-alive</code>，那么客户端就会认为服务器不支持长链接，下次请求的时候，会重新向服务器链接，再获取资源。</p><p>如果客户端和服务端任意一方的响应头中包含<code>Connetion: closed</code>，那么就会认为当前的会话只支持短链接，下次请求会重新建立链接。</p><h2 id="7-2-http和tcp的关系"><a href="#7-2-http和tcp的关系" class="headerlink" title="7.2 http和tcp的关系"></a>7.2 http和tcp的关系</h2><p>http虽然是基于tcp的，但http本身是无链接的。</p><blockquote><p>举个最明显的栗子，在你打开一个网页之后，你关闭掉自己的wifi，你的网页并不会因此消失。只是无法进行后续操作而已。</p></blockquote><p>http是一个无链接的应用层协议，其借助tcp进行数据的流式传输，但不一定需要客户端和服务端保持连接。</p><p>所以，http就可以借助单个tcp套接字<strong>持续的传输数据</strong>，也就天然地支持了长链接通信。</p><p>总结一下，http只是借用了tcp的能力，其无连接的特性和tcp没有关系！</p><h2 id="7-3-pipeline"><a href="#7-3-pipeline" class="headerlink" title="7.3 pipeline"></a>7.3 pipeline</h2><p>这其中会牵扯到一个<code>pipeline</code>，其维护了http长链接请求时的<strong>响应顺序</strong>。</p><p>比如人家需要加载一个网页，服务端应该先把网页的整体框架给用户加载出来，再给用户加载图片、视频、音频等资源。下图B站的加载就是一个很好的栗子。</p><p><img                       lazyload                     alt="image"                     data-src="https://img1.musnow.top/i/23/02/63ee31578364a.png"                      alt="image-20230216213625496"                ></p><p>否则乱序了，比如只出现了一个孤零零的图片，就会让人感觉非常奇怪。</p><h1 id="8-https"><a href="#8-https" class="headerlink" title="8.https"></a>8.https</h1><p>因为http的数据是无加密明文发送的，相对来说并不是非常的安全；为了实现数据加密，https在http的下层添加了一个<code>SSL/TLS</code>软件层，来进行数据加解密工作</p><p><img                       lazyload                     alt="image"                     data-src="https://img1.musnow.top/i/23/02/63ecc49657516.png"                      alt="image-20230215193931213"                ></p><h2 id="8-1-为啥要加密？"><a href="#8-1-为啥要加密？" class="headerlink" title="8.1 为啥要加密？"></a>8.1 为啥要加密？</h2><p>要知道，所有的加密工作，都是为了防止数据在中间传输的过程，被窃取或修改。如果我们请求一个网站登录的时候，数据包中就会包含我们的账户密码。如果被窃取，我们的隐私就泄露了。这是很难受的一件事！</p><blockquote><p>这也是为什么，我们经常能听到<code>免费公共wifi不安全</code>这一说法，因为我们在这个wifi上进行的所有数据交换，都会走这个wifi的路由器，很容易被<code>中间人</code>窃取并获取到我们的数据包。</p><p>这种情况下，https的加密就更有必要了！</p></blockquote><p>但是，加密解密是需要时间的，所以https响应的速度会稍慢于http。不过当下cpu的执行速度已经非常快，这点时间差距很小，不会特别影响我们的日常使用！</p><p>不过，加密并不是一个万金油，并不是说加密了之后的数据就一定能避免被窃取。但加密可以大大提高窃取破解的成本，无形中降低了数据被窃取的概率，保证了一定的数据安全。</p><h2 id="8-2-常见加密方式"><a href="#8-2-常见加密方式" class="headerlink" title="8.2 常见加密方式"></a>8.2 常见加密方式</h2><h3 id="8-2-1-对称加密"><a href="#8-2-1-对称加密" class="headerlink" title="8.2.1 对称加密"></a>8.2.1 对称加密</h3><p>所谓对称加密，好比有一个带锁的盒子，客户端和服务器都有一把钥匙。客户端先把信息丢进盒子里，再用🔑锁上盒子，发送给服务端。服务端用🔑打开盒子，取出数据。</p><p>因为客户端和服务器持有的钥匙是完全一致的，所以被称为对称加密。在加密的场景下，钥匙一般被称为<code>密钥</code></p><p>在网络场景里，<strong>对称加密是不可取的</strong>。只要客户端和服务端传输密钥的时候被窃取，那么双方的加密就失效了。因为是用同一个密钥来加密解密，我拿走了你的钥匙，自然就能打开你这把锁。</p><p>也就是说，<font color=orange>密钥的传输也需要加密</font>。但是这又引出一个问题，我都没有你的密钥，我怎么解密你发过来的密钥信息？这是一个<code>先有蛋还是先有鸡</code>的死循环！</p><h3 id="8-2-2-非对称加密"><a href="#8-2-2-非对称加密" class="headerlink" title="8.2.2 非对称加密"></a>8.2.2 非对称加密</h3><p>非对称加密场景下，会有一个公钥和私钥</p><ul><li>私钥对数据加密，变成密文</li><li>公钥对数据解密，变成明文</li></ul><p>二者也可以反过来</p><ul><li>私钥对数据解密</li><li>公钥对数据加密</li></ul><p>其中最常用的非对称加密，也就是我们在<a href="https://blog.musnow.top/2022/05/09/note_linux/1%E4%BD%BF%E7%94%A8ssh%E8%BF%9E%E6%8E%A5git/">git的ssh操作</a>中使用过的<code>rsa</code>密钥，其中就有一个<code>.pem</code>公钥和一个私钥。我们将公钥提供给github，私钥保存到本地，就能实现无密码上传数据到git仓库。</p><hr><p>但是非对称加密还是会存在中间人攻击的问题。先看如下图，你应该能发现，其中有一个重要的环节，<strong>就是服务端要把公钥发送给客户端</strong></p><p><img                       lazyload                     alt="image"                     data-src="https://img1.musnow.top/i/23/02/63ee25050db71.png"                      alt="image-20230216204344555"                ></p><p>在这个场景中，公钥是公开传输给客户端的，也就是后续服务器发送给客户端的所有信息，都可以被其他人用这个公钥解析出来；</p><p>整个环节中，只做到了客户端发送给服务器的信息安全，因为只有服务器拥有私钥，能解密出数据。</p><h3 id="8-2-3-双非对称"><a href="#8-2-3-双非对称" class="headerlink" title="8.2.3 双非对称"></a>8.2.3 双非对称</h3><p>这时候，我们可以采用双非对称密钥加密的方式！既然非对称只能保证单方的数据安全，那使用两个非对称，不就能保证双方数据安全了嘛！</p><ul><li>客户端和服务端交换公钥<code>a&#39; 和 b&#39;</code></li><li>客户端给服务端发信息：先用<code>a&#39;</code>对数据加密，再发送；只能由服务器解密，因为只有服务器有私钥a</li><li>服务端给客户端发信息：先用<code>b&#39;</code>对数据加密，再发送；只能由客户端解密，因为只有客户端有私钥b</li></ul><p><img                       lazyload                     alt="image"                     data-src="https://img1.musnow.top/i/23/02/63ee2acb5bf6c.png"                      alt="image-20230216210830169"                ></p><p>因为两份私钥都只有客户端和服务器自己拥有，所以黑客没有办法进行数据的窃取，也就保证了数据的安全。</p><p>即便中间人<strong>替换了交换的公钥</strong>，也会因为后续的通信，客户端or服务端<strong>本地的私钥</strong>无法正常解密，而发现数据被窃取！</p><p>但是但是，这样左还算有很大的<strong>缺点</strong></p><ul><li>效率太低（非对称加密解密负载太高，效率低下，特定场景下无法满足要求）</li><li>依旧可能存在安全问题</li></ul><h3 id="8-2-4-非对称-对称"><a href="#8-2-4-非对称-对称" class="headerlink" title="8.2.4 非对称+对称"></a>8.2.4 非对称+对称</h3><ul><li>服务端具有非对称公钥S和私钥S’</li><li>客⼾端发起请求，获取服务端公钥S</li><li>客⼾端在本地生成对称密钥C, 通过公钥S加密, 发送给服务器.</li><li>由于中间人没有私钥，即使截获了数据，也无法还原出内部的原文，也就无法获取到对称密钥</li><li>服务器通过私钥<code>S&#39;</code>解密，还原出客户端发送的对称密钥C，并且使用这个对称密钥加密给客户端发送的响应数据</li><li>后续客户端和服务端都采用密钥C来进行对称加密通信</li></ul><p>因为对称<strong>密钥C在传输过程中是加密</strong>的，只有客户端和服务端知道密钥是什么，也就实现了数据的安全通信！</p><h2 id="8-3-数据摘要（指纹）"><a href="#8-3-数据摘要（指纹）" class="headerlink" title="8.3 数据摘要（指纹）"></a>8.3 数据摘要（指纹）</h2><p>数字指纹(数据摘要)， 其基本原理是利⽤单向散列函数(<code>Hash函数</code>)对信息进行运算，生成⼀串<strong>固定长度</strong>的数字摘要。</p><p>常见的摘要算法有<code>MD5/SHA1/SHA256/SHA512</code>等；</p><p>数字指纹并不是⼀种加密机制，但可以用来判断<strong>数据有没有被窜改</strong>，亦或者是下载的数据包有没有出现损坏。</p><ul><li>同一个数据文件，用同一个方法生成的数据摘要是一致的</li><li>不同文件生成的数据摘要可能会撞车，但几率极低，可以认为具有唯一性！</li><li>我们无法用数据摘要反推出数据内容（怎么可能用一个字符串推测出原本的内容呢？那样还存放源文件干哈？😂）</li></ul><p>数据摘要在网盘产品中也有使用，当我们使用<strong>百度云盘、阿里云盘</strong>的时候，会遇到一个大的资源文件只用了<strong>短短几秒</strong>就成功上传到服务器的情况。此时，我们并不是真的用几秒就把数据传输上去了，而是经历了以下阶段</p><ul><li>网盘客户端对本地文件生成数据摘要</li><li>生成后，判断服务器端<strong>已有文件</strong>中，是否有同该数据摘要相同的文件</li><li>如果有，代表该文件已经存在了云盘中</li><li>服务器将该文件给你的账户建立一个软链接&#x2F;硬链接，就实现了<code>&quot;妙传&quot;</code></li><li>如果没有，则老老实实的从本地上传文件到云盘</li></ul><p>云盘厂家这么做的原因很简单：避免同一份文件被多次存储。当下网盘给用户的免费空间动则上T，如果所有文件都重复保存，那对于云服务器厂家来说，资源消耗太大了。</p><p>这个做法并不会产生数据隐私问题，一般只有电影等资源文件才有可能妙传成功。你可以使用一些“其他手段”，比如把资源打个压缩包，并在压缩包中随便丢另外一个文件，让文件的数据指纹和已有资源不相同，就不会进行<code>妙传</code>了。</p><h2 id="8-4-数字签名"><a href="#8-4-数字签名" class="headerlink" title="8.4 数字签名"></a>8.4 数字签名</h2><p>对数据摘要进行加密，生成的内容被称为<strong>数字签名</strong></p><h2 id="8-5-中间人攻击"><a href="#8-5-中间人攻击" class="headerlink" title="8.5 中间人攻击"></a>8.5 中间人攻击</h2><p>中间人攻击（Man-in-the-MiddleAttack），简称“<code>MITM攻击</code>”；</p><p>以<code>8.2.2</code>的单非对称加密为例，中间人可以在整个过程中进行<strong>偷梁换柱</strong>，窃取双方的信息</p><p><img                       lazyload                     alt="image"                     data-src="https://img1.musnow.top/i/23/02/63ee26a502a69.png"                      alt="image-20230216205047679"                ></p><p>透过这个栗子🌰，实际上，如果中间人在客户端和服务端<strong>开始通信之前</strong>就来窃听并<strong>准备换柱</strong>了，他就有可能替换双方密钥，从而解密双方发送的信息！</p><p>最重要的一点，是客户端or服务端<strong>都没有办法证明</strong>，当前的公钥是直接从服务端or客户端发来的，它们没有办法检验公钥的权威性，只能被动接受。由此给中间人<code>偷梁换柱</code>提供了可能。</p><h2 id="8-6-CA证书"><a href="#8-6-CA证书" class="headerlink" title="8.6 CA证书"></a>8.6 CA证书</h2><p>所谓CA证书，是由<strong>CA机构</strong>颁发的权威证书。CA机构在颁发证书时，会在证书中附带上该站点的域名，以及申请人（企业）的相关信息</p><ul><li>CA机构会有一个自己的私钥和公钥，其公钥向<strong>所有人</strong>公开</li><li>CA机构的私钥由其自己保存（私钥一定不能泄露）</li><li>当下的浏览器、操作系统都会内置认可的CA；只有被认可的CA，才能为站点提供ssl证书服务</li></ul><p>在我们windows本地就能看到当前操作系统认可的CA机构其公钥；在edge浏览器中，点击右上角选择，进入设置，在选择隐私页面，找到<code>管理证书</code></p><p><img                       lazyload                     alt="image"                     data-src="https://img1.musnow.top/i/23/02/63ee3dd712d42.png"                      alt="image-20230216222946008"                ></p><p>点击它，就能看到当前本地认可的CA</p><p><img                       lazyload                     alt="image"                     data-src="https://img1.musnow.top/i/23/02/63ee3e40b1733.png"                      alt="image-20230216223131725"                ></p><h3 id="8-6-1-ssl证书加密原理"><a href="#8-6-1-ssl证书加密原理" class="headerlink" title="8.6.1 ssl证书加密原理"></a>8.6.1 ssl证书加密原理</h3><p>当一个站点获取了ssl证书后，在向用户发送ssl证书中包含的公钥的同时，还会发送一个<strong>由CA机构</strong>对ssl证书公钥做的<strong>数字签名</strong></p><ul><li>ssl证书公钥的数字签名A，通过CA机构的<strong>私钥</strong>进行加密</li><li>ssl证书的公钥B</li></ul><p>当客户端收到这份信息之后，会采用hash函数对收到的ssl证书公钥进行数字签名，得到一个<strong>本地生成的数字签名C</strong></p><p>再用CA机构的公钥对传输过来的数字签名A进行解密，得到数字签名A的明文；判断由CA机构生成的ssl公钥数字签名A是否和本地生成的数字签名C相同；</p><ul><li>如果相同，则代表证书正确！</li><li>不相同，代表证书出现错误！</li></ul><p>画个图，大概就是下面这样</p><p><img                       lazyload                     alt="image"                     data-src="https://img1.musnow.top/i/23/02/63ee3aa8d2aa1.png"                      alt="image-20230216221611664"                ></p><p>由于当下发送的数据包中，同时存在ssl公钥的明文+由CA机构加密后的数字签名，中间人无法进行任何攻击修改！</p><ul><li>若修改ssl公钥，由于中间人没有CA机构的私钥，无法对修改后的ssl公钥生成对应的加密后数字签名</li><li>若使用CA公钥解密数字签名后修改……依旧会因为没有CA机构私钥，无法把修改后的签名加密回去</li><li>如果中间人用自己的私钥生成一个数字签名，但我不认识你这个CA，也不知道你的公钥是什么，怎么解密你的信息呢？</li></ul><p>综上，中间人要想偷梁换柱，只有一个办法了，那就是拿一个<strong>真的证书</strong>整体替换掉这个数据包。</p><p>可ssl证书中还包含了域名、站点主体等各类信息，我当下访问的是<code>baidu.com</code>，结果收到的证书是<code>qq.com</code>的，那肯定有问题啊！浏览器会直接拒绝访问！😂</p><p>当我们访问一些网站，<strong>浏览器报ssl证书过期</strong>，也是会出现一定的安全问题的！</p><h3 id="8-6-2-ssl证书-非对称-对称"><a href="#8-6-2-ssl证书-非对称-对称" class="headerlink" title="8.6.2 ssl证书+非对称+对称"></a>8.6.2 ssl证书+非对称+对称</h3><p>有了上面这个不能被篡改的ssl证书公钥，下面我们就可以利用<code>非对称+对称加密</code>的方式进行通信了</p><ul><li>客户端收到ssl证书，向服务器发送一个本地生成的密钥D（使用ssl证书公钥进行加密）</li><li>服务端收到密钥D的加密信息，使用ssl证书的私钥进行解密，获取到密钥D</li><li>客户端和服务端使用密钥D进行对称加密通信</li></ul><p>这样即解决了安全问题，又规避了非对称加密的效率问题，一举多得！</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;已经学习过自己定制一个协议了，现在就来看看当下广泛使用的http协议吧&lt;/p&gt;</summary>
    
    
    
    <category term="玩上Linux" scheme="https://blog.musnow.top/categories/%E7%8E%A9%E4%B8%8ALinux/"/>
    
    
    <category term="Linux" scheme="https://blog.musnow.top/tags/Linux/"/>
    
    <category term="网络" scheme="https://blog.musnow.top/tags/%E7%BD%91%E7%BB%9C/"/>
    
    <category term="http" scheme="https://blog.musnow.top/tags/http/"/>
    
  </entry>
  
  <entry>
    <title>【网络】自定义协议 | 序列化和反序列化 | Jsoncpp</title>
    <link href="https://blog.musnow.top/2023/02/12/note_Linux/33jsoncpp%E5%BA%8F%E5%88%97%E5%8C%96/"/>
    <id>https://blog.musnow.top/2023/02/12/note_Linux/33jsoncpp%E5%BA%8F%E5%88%97%E5%8C%96/</id>
    <published>2023-02-12T04:30:55.000Z</published>
    <updated>2023-02-15T03:55:37.798Z</updated>
    
    <content type="html"><![CDATA[<p>以tcpServer的<strong>计算器</strong>服务为例，实现用jsoncpp来进行序列化和反序列化</p><span id="more"></span><blockquote><p>阅读本文之前，请先阅读 <a href="https://blog.musnow.top/2023/02/11/note_linux/32tcp%E5%AE%9E%E7%8E%B0%E8%87%AA%E5%AE%9A%E4%B9%89%E5%8D%8F%E8%AE%AE/">自定义协议 | 序列化和反序列化 | 以tcpServer为例</a></p></blockquote><h1 id="1-安装包"><a href="#1-安装包" class="headerlink" title="1.安装包"></a>1.安装包</h1><p>我所用的系统是<code>centos7.6</code>，先用下面的命令查找相关的包</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo yum list | grep jsoncpp-devel</span><br></pre></td></tr></table></figure><p>显示出来的包如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Repository epel is listed more than once in the configuration</span><br><span class="line">jsoncpp-devel.x86_64                0.10.5-2.el7           @epel </span><br></pre></td></tr></table></figure><p>随后安装这个包</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo yum install jsoncpp</span><br></pre></td></tr></table></figure><p>不知道为什么，安装<code>jsoncpp-devel.x86_64</code>显示找不到相关包</p><h2 id="1-1-什么是json？"><a href="#1-1-什么是json？" class="headerlink" title="1.1 什么是json？"></a>1.1 什么是json？</h2><p>json是一个kv键值对的序列化方式，每一个key都对应了一个value</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line"><span class="attr">&quot;data&quot;</span><span class="punctuation">:</span> <span class="string">&quot;value&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>这就有点类似c++中的map，不过json能做的更多</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line"><span class="attr">&quot;data1&quot;</span><span class="punctuation">:</span> <span class="string">&quot;value&quot;</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;data2&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line"><span class="attr">&quot;key1&quot;</span><span class="punctuation">:</span><span class="string">&quot;value1&quot;</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;key2&quot;</span><span class="punctuation">:</span><span class="string">&quot;value2&quot;</span><span class="punctuation">,</span></span><br><span class="line">         <span class="attr">&quot;key3&quot;</span><span class="punctuation">:</span><span class="number">0</span><span class="punctuation">,</span></span><br><span class="line">         <span class="attr">&quot;key4&quot;</span><span class="punctuation">:</span><span class="keyword">true</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>json可以在里面嵌套添加更多的内容，不管是字符串还是整形，还能是bool类型的<code>true/false</code>；</p><p>因为json对反序列化序列化的控制很是不错，可读性也很好，所以被广泛使用！</p><p>相比于自己写一个序列化方式，直接用别人的轮子，也不错👻</p><p>类似的序列化框架还有<code>xml</code></p><h1 id="2-代码示例"><a href="#2-代码示例" class="headerlink" title="2.代码示例"></a>2.代码示例</h1><h2 id="2-1-序列化"><a href="#2-1-序列化" class="headerlink" title="2.1 序列化"></a>2.1 序列化</h2><p>相比我们自己写的序列化方式，json的使用简单多了</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">serialize</span><span class="params">(std::string&amp; out)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">     <span class="comment">//使用jsoncpp的代码</span></span><br><span class="line">    Json::Value root;</span><br><span class="line">    root[<span class="string">&quot;x&quot;</span>] = _x;</span><br><span class="line">    root[<span class="string">&quot;y&quot;</span>] = _y;</span><br><span class="line">    root[<span class="string">&quot;op&quot;</span>] = _ops;</span><br><span class="line"></span><br><span class="line">    Json::FastWriter fw; <span class="comment">// 这个是写成一行，对于计算机来说处理的负担小</span></span><br><span class="line">    <span class="comment">// Json::StyledWriter fw; // 这个会进行格式化，更好看（但是内容没差距）</span></span><br><span class="line">    out = fw.<span class="built_in">write</span>(root);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于<code>fw.write(root)</code>，其返回值是一个string，也方便我们接收</p><p><img                       lazyload                     alt="image"                     data-src="https://img1.musnow.top/i/23/02/63e87f6032516.png"                      alt="image-20230212135543386"                ></p><p>其中<code>FastWriter</code>和<code>StyledWriter</code>有一点区别，如下</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//FastWriter</span></span><br><span class="line"><span class="punctuation">&#123;</span><span class="attr">&quot;data&quot;</span><span class="punctuation">:</span> <span class="string">&quot;value&quot;</span><span class="punctuation">&#125;</span></span><br><span class="line"><span class="comment">//StyledWriter</span></span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line"><span class="attr">&quot;data&quot;</span><span class="punctuation">:</span> <span class="string">&quot;value&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>简单来说，<code>StyledWriter</code>会对我们的kv键值对进行格式化，更方便人类的阅读。而<code>FastWriter</code>是直接写成一整行，在传输的时候会方便一点（因为不需要<code>\n</code>）</p><h2 id="2-2-反序列化"><a href="#2-2-反序列化" class="headerlink" title="2.2 反序列化"></a>2.2 反序列化</h2><p>反序列化需要一个Reader来读取字符串，并将其内容根据键值隐射给成员变量</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">deserialize</span><span class="params">(<span class="type">const</span> std::string &amp;in)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//json</span></span><br><span class="line">    Json::Value root;</span><br><span class="line">    Json::Reader rd;</span><br><span class="line">    rd.<span class="built_in">parse</span>(in, root);</span><br><span class="line">    _x = root[<span class="string">&quot;x&quot;</span>].<span class="built_in">asInt</span>();</span><br><span class="line">    _y = root[<span class="string">&quot;y&quot;</span>].<span class="built_in">asInt</span>();</span><br><span class="line">    _ops = root[<span class="string">&quot;op&quot;</span>].<span class="built_in">asInt</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="3-测试"><a href="#3-测试" class="headerlink" title="3.测试"></a>3.测试</h1><p>因为jsoncpp是一个第三方库，我们链接的时候需要加上命令<code>-ljsoncpp</code></p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">tcpServer:tcpServer.cpp</span></span><br><span class="line">g++ -o <span class="variable">$@</span> <span class="variable">$^</span> -std=c++11 -lpthread -ljsoncpp</span><br></pre></td></tr></table></figure><p>发送消息后，可以看到，json帮我们格式化为如下形式的字符串</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span><span class="attr">&quot;op&quot;</span><span class="punctuation">:</span><span class="number">43</span><span class="punctuation">,</span><span class="attr">&quot;x&quot;</span><span class="punctuation">:</span><span class="number">1</span><span class="punctuation">,</span><span class="attr">&quot;y&quot;</span><span class="punctuation">:</span><span class="number">200</span><span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#123;</span><span class="attr">&quot;op&quot;</span><span class="punctuation">:</span><span class="number">43</span><span class="punctuation">,</span><span class="attr">&quot;x&quot;</span><span class="punctuation">:</span><span class="number">333</span><span class="punctuation">,</span><span class="attr">&quot;y&quot;</span><span class="punctuation">:</span><span class="number">234</span><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p><img                       lazyload                     alt="image"                     data-src="https://img1.musnow.top/i/23/02/63e8829420bc4.png"                      alt="image-20230212140924067"                ></p><h1 id="4-gcc给予宏定义"><a href="#4-gcc给予宏定义" class="headerlink" title="4.gcc给予宏定义"></a>4.gcc给予宏定义</h1><p>为了方便对序列化采用的方式进行控制，这里我使用了预处理指令<code>ifdef/endif</code>来进行判断，只要我们在文件头定义了<code>MYPROTOCOL</code>，这里就会采用我们自己的写的序列化方式，否则采用json</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MYPROTOCOL 1  <span class="comment">//如果define了这个，那就使用自己的代码</span></span></span><br></pre></td></tr></table></figure><p><img                       lazyload                     alt="image"                     data-src="https://img1.musnow.top/i/23/02/63e8bdcb448d6.png"                      alt="image-20230212182113854"                ></p><h2 id="4-1-命令行"><a href="#4-1-命令行" class="headerlink" title="4.1 命令行"></a>4.1 命令行</h2><p>但是在文件里面修改define还是不太方便，我们可以直接采用gcc的命令行参数的方式，进行define的插入（这么做之前，要先删除文件中对<code>MYPROTOCOL</code>的define）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">g++ -DMYPROTOCOL tcpServer.cpp -o tcpServer -lpthread -ljsoncpp</span><br><span class="line">g++ -DMYPROTOCOL tcpClient.cpp -o tcpClient -lpthread -ljsoncpp</span><br></pre></td></tr></table></figure><p>可以看到，不加编译指令编译出来的服务器，采用的是json的方式来序列化</p><p><img                       lazyload                     alt="image"                     data-src="https://img1.musnow.top/i/23/02/63e8bed2edae3.png"                      alt="image-20230212182627766"                ></p><p>添加了之后，就是用我们自己写的序列化方式来序列化了</p><p><img                       lazyload                     alt="image"                     data-src="https://img1.musnow.top/i/23/02/63e8bf7e58fae.png"                      alt="image-20230212182919150"                ></p><h2 id="4-2-makefile"><a href="#4-2-makefile" class="headerlink" title="4.2 makefile"></a>4.2 makefile</h2><p>因此，我们可以修改makefile来实现这一点</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"><span class="keyword">.PHONY</span>:all</span></span><br><span class="line"><span class="section">all:tcpClient tcpServer</span></span><br><span class="line">MYSELF=-DMYPROTOCOL</span><br><span class="line"></span><br><span class="line"><span class="section">tcpClient: tcpClient.cpp</span></span><br><span class="line">g++ <span class="variable">$(MYSELF)</span> -o <span class="variable">$@</span> <span class="variable">$^</span> -std=c++11 -lpthread -ljsoncpp</span><br><span class="line"><span class="section">tcpServer:tcpServer.cpp</span></span><br><span class="line">g++ <span class="variable">$(MYSELF)</span> -o <span class="variable">$@</span> <span class="variable">$^</span> -std=c++11 -lpthread -ljsoncpp</span><br><span class="line"></span><br><span class="line"><span class="meta"><span class="keyword">.PHONY</span>:clean</span></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">rm -f tcpClient tcpServer</span><br></pre></td></tr></table></figure><p>当我们需要用自己协议的时候，就在最前面加上</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MYSELF=-DMYPROTOCOL</span><br></pre></td></tr></table></figure><p>否则直接<strong>删除</strong>这个定义，或者注释掉后面的内容，就能采用jsoncpp</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MYSELF=<span class="comment">#-DMYPROTOCOL</span></span><br></pre></td></tr></table></figure><p>这样就方便一些了</p><p><img                       lazyload                     alt="image"                     data-src="https://img1.musnow.top/i/23/02/63e8c0cf35f88.png"                      alt="image-20230212183456024"                ></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;以tcpServer的&lt;strong&gt;计算器&lt;/strong&gt;服务为例，实现用jsoncpp来进行序列化和反序列化&lt;/p&gt;</summary>
    
    
    
    <category term="玩上Linux" scheme="https://blog.musnow.top/categories/%E7%8E%A9%E4%B8%8ALinux/"/>
    
    
    <category term="Linux" scheme="https://blog.musnow.top/tags/Linux/"/>
    
    <category term="网络" scheme="https://blog.musnow.top/tags/%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>【网络】自定义协议 | 序列化和反序列化 | 以tcpServer为例</title>
    <link href="https://blog.musnow.top/2023/02/11/note_Linux/32tcp%E5%AE%9E%E7%8E%B0%E8%87%AA%E5%AE%9A%E4%B9%89%E5%8D%8F%E8%AE%AE/"/>
    <id>https://blog.musnow.top/2023/02/11/note_Linux/32tcp%E5%AE%9E%E7%8E%B0%E8%87%AA%E5%AE%9A%E4%B9%89%E5%8D%8F%E8%AE%AE/</id>
    <published>2023-02-11T04:30:55.000Z</published>
    <updated>2023-02-15T03:55:44.139Z</updated>
    
    <content type="html"><![CDATA[<p>以tcpServer的<strong>计算器</strong>服务为例，实现一个自定义协议</p><span id="more"></span><blockquote><p>阅读本文之前，请先阅读 <a href="https://blog.musnow.top/2023/02/05/note_linux/29tcp%E4%BB%A3%E7%A0%81/">tcpServer</a></p><p>本文完整代码详见 <a class="link"   href="https://gitee.com/musnow/raspberry-practice/tree/master/code" >Gitee<i class="fas fa-external-link-alt"></i></a></p></blockquote><h1 id="1-重谈tcp"><a href="#1-重谈tcp" class="headerlink" title="1.重谈tcp"></a>1.重谈tcp</h1><p>注意，当下所对tcp的描述都是<strong>以简单、方便理解</strong>起见，后续会对tcp协议进行深入解读</p><h2 id="1-1-链接"><a href="#1-1-链接" class="headerlink" title="1.1 链接"></a>1.1 链接</h2><p>我们知道，tcp是面向连接的，客户端和服务端要先建立链接，才能开始通信</p><ul><li>在链接过程中，tcp采用三次握手</li><li>在断线过程中，tcp采用四次挥手</li></ul><p>举个日常生活中的栗子，帮助理解3次握手和4次挥手</p><p><img                       lazyload                     alt="image"                     data-src="https://img1.musnow.top/i/23/02/63e7000c46813.png"                      alt="image-20230211103933999"                ></p><h2 id="1-2-信息发送"><a href="#1-2-信息发送" class="headerlink" title="1.2 信息发送"></a>1.2 信息发送</h2><blockquote><p>假如我们现在需要发送结构化数据，那应该怎么办？</p></blockquote><p>我们知道，tcp是面向字节流的，也就是其能够发送任意数据。也能够发送<strong>C语言结构体</strong>的二进制数据；</p><ul><li>但能发送，就代表我们可以这么干吗？</li><li>答案自然是<strong>不行</strong>！</li></ul><p>不同平台，对<a href="https://blog.musnow.top/2022/01/28/note_c/40%E8%87%AA%E5%AE%9A%E4%B9%89%E7%B1%BB%E5%9E%8B%E8%AF%A6%E8%A7%A3/">结构体对齐</a>的配置不同，大小端不同，其最终对我们字节流的解析也就不一样。如果采用直接发送结构体数据的方式来通信，适配性极低，我们的客户端和服务端都会被限制在当前的系统环境中运行；</p><p>可是，哪怕是同一个系统，其内部对大小端的配置也有可能改变！到时候我们的代码恐怕就无法运行了！</p><p>同理，在当初编写<a class="link"   href="https://gitee.com/musnow/learn_c_code/tree/master/DAY_Code/DAY038%20%E9%80%9A%E8%AE%AF%E5%BD%95%E4%BB%A3%E7%A0%81" >C语言通讯录<i class="fas fa-external-link-alt"></i></a>的代码的时候，也不能采用直接将结构体数据写入文件的方式。后续代码升级、环境改变，<strong>都可能导致我们存在文件中的数据失效</strong>，这肯定是我们不希望看到的情况。</p><p>所以，为了解决这个问题，我们就应该将数据进行<code>序列化</code>之后再发送，客户端接收到信息后，进行<code>反序列化</code>解析出数据！</p><h1 id="2-序列化和反序列化"><a href="#2-序列化和反序列化" class="headerlink" title="2.序列化和反序列化"></a>2.序列化和反序列化</h1><h2 id="2-1-简介"><a href="#2-1-简介" class="headerlink" title="2.1 简介"></a>2.1 简介</h2><p>所谓序列化，就是将结构化的数据（可以暂时理解为c的结构体）转换成字符串的方式，发送出去</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">date</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">int</span> year;</span><br><span class="line">    <span class="type">int</span> month;</span><br><span class="line">    <span class="type">int</span> day;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>比如上面这个日期结构体，我们要想将其序列化，就可以用一个很简单的方式拼接成一个字符串（序列化）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">year-month-day</span><br></pre></td></tr></table></figure><p>客户端收到这个字符串之后，就可以通过查找分隔符<code>-</code>的方式，取出三个变量，将其转成int后存放回结构体（反序列化）</p><p>这样，我们就算是规定了一个序列化和反序列化的方式，也就是一个简单的<strong>协议</strong>！</p><hr><h2 id="2-2-编码解码"><a href="#2-2-编码解码" class="headerlink" title="2.2 编码解码"></a>2.2 编码解码</h2><p>这里还会出现另外一个问题，我要怎么知道我已经<strong>读取完毕</strong>了一个序列化后的数据呢？</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">2000-12-10</span><br><span class="line">10000-01-01</span><br></pre></td></tr></table></figure><p>如上，假设有一天，我们的年变成了五位数；这时候，服务端要怎么知道自己是否读取完毕了一个完整的序列化数据呢？</p><p>这就需要我们做好规定，<strong>将前n字节作为标识长度的数据</strong>。接收到数据后，先取出前n个字节，读取道此次消息的长度m，再往后读取m个字节的数据，成功取出完整的字符串;</p><ul><li>这个过程可以称作<strong>编码和解码</strong>的过程</li></ul><p>为了区分标识长度的数据和实际需要的序列化内容，我们可以在之中加上分隔符<code>\t</code>；但这也需要我们确认，传输的数据本身不能带上<code>\t</code>，否则会产生一系列的问题</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">10\t2000-12-10\t</span><br><span class="line">11\t10000-01-01\t</span><br></pre></td></tr></table></figure><p>以上的这一系列工作，都是<code>协议定制</code>的一部分！我们给服务端和客户端规定了一个序列化和反序列化的方式，让二者通信规避掉了平台的限制。毕竟任何平台对<strong>字符串</strong>解码出来的数据都会是相同的！</p><p>下面就用一个<strong>计算器</strong>的服务，来演示一下吧😏</p><h1 id="3-计算器服务"><a href="#3-计算器服务" class="headerlink" title="3.计算器服务"></a>3.计算器服务</h1><p>因为本文的重心是对协议定制的演示，所以这里的计算器<em>不考虑连续操作符</em>的情况，</p><h2 id="3-1-协议定制"><a href="#3-1-协议定制" class="headerlink" title="3.1 协议定制"></a>3.1 协议定制</h2><p>要想实现一个计算器，我们首先要搞明白计算器有几个成员</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">x+y</span><br><span class="line">x/y</span><br><span class="line">x*y</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>一般情况下，一个计算器只需要3个成员，分别是两个操作数和一个运算符，就能开始计算。所以我们需要将这里的三个字段设计成一个字符串，实现序列化；</p><p>比如我们应该规定序列化之后的数据应该是如下的，两个操作数和操作符之间应该要有<strong>空格</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a + b</span><br></pre></td></tr></table></figure><p>再在开头添加上数据长度的标识</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">数据长度\t公式\t</span><br><span class="line"></span><br><span class="line">7\t10 + 20\t</span><br><span class="line">8\t100 / 30\t</span><br><span class="line">9\t300 - 200\t</span><br></pre></td></tr></table></figure><p>对于服务端，我们需要返回两个参数：状态码和结果</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">退出状态 结果</span><br></pre></td></tr></table></figure><p>如果退出状态不为0，则代表出现错误，结果无效；只有退出结果为0，结果才是有效的。</p><p>同样的，也需要给服务器的序列化字符串添加上数据的长度</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">数据长度\t退出状态 结果\t</span><br></pre></td></tr></table></figure><p>这样就搞定了一个计算器的自定义协议；</p><h2 id="3-2-成员"><a href="#3-2-成员" class="headerlink" title="3.2 成员"></a>3.2 成员</h2><p>依照如上的协议，先把请求和返回的成员变量写好</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Request</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> _x;</span><br><span class="line">    <span class="type">int</span> _y;</span><br><span class="line">    <span class="type">char</span> _ops;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Response</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> _exitCode; <span class="comment">//计算服务的退出码</span></span><br><span class="line"><span class="type">int</span> _result;  <span class="comment">// 结果</span></span><br><span class="line">&#125;;  </span><br></pre></td></tr></table></figure><p>这些成员变量都设置为公有，方便在task里面进行处理（否则就需要写get函数，很麻烦）</p><p>同时，最好还是把协议中的分隔符给定义出来，方便后续统一使用or更改</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> CRLF <span class="string">&quot;\t&quot;</span>   <span class="comment">//分隔符</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CRLF_LEN strlen(CRLF) <span class="comment">//分隔符长度</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SPACE <span class="string">&quot; &quot;</span>   <span class="comment">//空格</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SPACE_LEN strlen(SPACE) <span class="comment">//空格长度</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> OPS <span class="string">&quot;+-*/%&quot;</span> <span class="comment">//运算符</span></span></span><br></pre></td></tr></table></figure><h2 id="3-3-编码解码"><a href="#3-3-编码解码" class="headerlink" title="3.3 编码解码"></a>3.3 编码解码</h2><p>对于请求和回应来说，编解码的操作是一样的，都是往字符串的开头添加上长度和分隔符</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">长度\t序列化字符串\t</span><br></pre></td></tr></table></figure><p>解码就是将长度和分隔符去掉，只解析出序列化字符串</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">序列化字符串</span><br></pre></td></tr></table></figure><p>编码解码的整个过程在注释里面都写明了😁为了方便请求和回应去使用，直接放到外头，不做类内封装</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//参数len为in的长度，是一个输出型参数。如果为0代表err</span></span><br><span class="line"><span class="function">std::string <span class="title">decode</span><span class="params">(std::string&amp; in,<span class="type">size_t</span>*len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">assert</span>(len);<span class="comment">//如果长度为0是错误的</span></span><br><span class="line">    <span class="comment">// 1.确认in的序列化字符串完整（分隔符）</span></span><br><span class="line">    *len=<span class="number">0</span>;</span><br><span class="line">    <span class="type">size_t</span> pos = in.<span class="built_in">find</span>(CRLF);<span class="comment">//查找分隔符</span></span><br><span class="line">    <span class="comment">//查找不到，err</span></span><br><span class="line">    <span class="keyword">if</span>(pos == std::string::npos)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;<span class="comment">//返回空串</span></span><br><span class="line">    &#125;   </span><br><span class="line">    <span class="comment">// 2.有分隔符，判断长度是否达标</span></span><br><span class="line">    <span class="comment">// 此时pos下标正好就是标识大小的字符长度</span></span><br><span class="line">    std::string inLenStr = in.<span class="built_in">substr</span>(<span class="number">0</span>,pos);<span class="comment">//提取字符串长度</span></span><br><span class="line">    <span class="type">size_t</span> inLen = <span class="built_in">atoi</span>(inLenStr.<span class="built_in">c_str</span>());<span class="comment">//转int</span></span><br><span class="line">    <span class="type">size_t</span> left = in.<span class="built_in">size</span>() - inLenStr.<span class="built_in">size</span>()- <span class="number">2</span>*CRLF_LEN;<span class="comment">//剩下的字符长度</span></span><br><span class="line">    <span class="keyword">if</span>(left&lt;inLen)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&quot;</span>; <span class="comment">//剩下的长度没有达到标明的长度</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 3.走到此处，字符串完整，开始提取序列化字符串</span></span><br><span class="line">    std::string ret = in.<span class="built_in">substr</span>(pos+CRLF_LEN,inLen);</span><br><span class="line">    *len = inLen;</span><br><span class="line">    <span class="comment">// 4.因为in中可能还有其他的报文（下一条）</span></span><br><span class="line">    <span class="comment">// 所以需要把当前的报文从in中删除，方便下次decode，避免二次读取</span></span><br><span class="line">    <span class="type">size_t</span> rmLen = inLenStr.<span class="built_in">size</span>() + ret.<span class="built_in">size</span>() + <span class="number">2</span>*CRLF_LEN;</span><br><span class="line">    in.<span class="built_in">erase</span>(<span class="number">0</span>,rmLen);</span><br><span class="line">    <span class="comment">// 5.返回</span></span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//编码不需要修改源字符串，所以const。参数len为in的长度</span></span><br><span class="line"><span class="function">std::string <span class="title">encode</span><span class="params">(<span class="type">const</span> std::string&amp; in,<span class="type">size_t</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::string ret = std::<span class="built_in">to_string</span>(len);<span class="comment">//将长度转为字符串添加在最前面，作为标识</span></span><br><span class="line">    ret+=CRLF;</span><br><span class="line">    ret+=in;</span><br><span class="line">    ret+=CRLF;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-4-request"><a href="#3-4-request" class="headerlink" title="3.4 request"></a>3.4 request</h2><p>编码解码写好了，先来处理比较麻烦的请求部分；说麻烦吧，其实大多数也是c++的string操作，要熟练运用string的各类成员函数，才能很好的实现</p><h3 id="3-4-1-构造"><a href="#3-4-1-构造" class="headerlink" title="3.4.1 构造"></a>3.4.1 构造</h3><p>比较重要的是这个构造函数，我们需要将用户的输入转成内部的三个成员</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">用户可能输入x+y，x+ y，x +y,x + y等等格式</span><br></pre></td></tr></table></figure><p>这里还需要注意，用户的输入不一定是标准的<code>X+Y</code>，里面可能在不同位置里面会有空格。为了统一方便处理，在解析之前，<strong>最好先把用户输入内的空格给去掉</strong>！</p><p>对于string而言，去掉空格就很简单了，直接一个遍历搞定</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 删除输入中的空格</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">rmSpace</span><span class="params">(std::string&amp; in)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::string tmp;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> e:in)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(e!=<span class="string">&#x27; &#x27;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            tmp+=e;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    in = tmp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>完成的构造如下，这里涉及到C语言的<a href="https://blog.musnow.top/2022/01/25/note_c/39%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%87%BD%E6%95%B0%E5%92%8C%E5%86%85%E5%AD%98%E5%87%BD%E6%95%B0/#1-7-strtok">函数strtok</a>，要复习复习</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将用户的输入转成内部成员</span></span><br><span class="line"><span class="comment">// 用户可能输入x+y，x+ y，x +y,x + y等等格式</span></span><br><span class="line"><span class="comment">// 提前修改用户输入（主要还是去掉空格），提取出成员</span></span><br><span class="line"><span class="built_in">Request</span>(std::string in,<span class="type">bool</span>* status)</span><br><span class="line">    :_x(<span class="number">0</span>),_y(<span class="number">0</span>),_ops(<span class="string">&#x27; &#x27;</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">rmSpace</span>(in);</span><br><span class="line">    <span class="comment">// 这里使用c的字符串，因为有strtok</span></span><br><span class="line">    <span class="type">char</span> buf[<span class="number">1024</span>];</span><br><span class="line">    <span class="comment">// 打印n个字符，多的会被截断</span></span><br><span class="line">    <span class="built_in">snprintf</span>(buf,<span class="built_in">sizeof</span>(buf),<span class="string">&quot;%s&quot;</span>,in.<span class="built_in">c_str</span>());</span><br><span class="line">    <span class="type">char</span>* left = <span class="built_in">strtok</span>(buf,OPS);</span><br><span class="line">    <span class="keyword">if</span>(!left)&#123;<span class="comment">//找不到</span></span><br><span class="line">        *status = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">char</span>*right = <span class="built_in">strtok</span>(<span class="literal">nullptr</span>,OPS);</span><br><span class="line">    <span class="keyword">if</span>(!right)&#123;<span class="comment">//找不到</span></span><br><span class="line">        *status = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// x+y, strtok会将+设置为\0</span></span><br><span class="line">    <span class="type">char</span> mid = in[<span class="built_in">strlen</span>(left)];<span class="comment">//截取出操作符</span></span><br><span class="line">    <span class="comment">//这是在原字符串里面取出来，buf里面的这个位置被改成\0了</span></span><br><span class="line"></span><br><span class="line">    _x = <span class="built_in">atoi</span>(left);</span><br><span class="line">    _y = <span class="built_in">atoi</span>(right);</span><br><span class="line">    _ops = mid;</span><br><span class="line">    *status=<span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-4-2-序列化"><a href="#3-4-2-序列化" class="headerlink" title="3.4.2 序列化"></a>3.4.2 序列化</h3><p>解析出成员以后，我们要做的就是对成员进行序列化，将其按指定的位置摆成一个字符串。这里采用了<strong>输出型参数</strong>的方式来序列化字符串，也可以改成用返回值的方式来操作。</p><p>这里需要注意的是，操作符本身就是<code>char</code>不能使用<code>to_string</code>来操作，会被转成<code>ascii</code>码，不符合我们的需求</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 序列化 （入参应该是空的）</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">serialize</span><span class="params">(std::string&amp; out)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// x + y</span></span><br><span class="line">    out.<span class="built_in">clear</span>(); <span class="comment">// 序列化的入参是空的</span></span><br><span class="line">    out+= std::<span class="built_in">to_string</span>(_x);</span><br><span class="line">    out+= SPACE;</span><br><span class="line">    out+= _ops;<span class="comment">//操作符不能用tostring，会被转成ascii</span></span><br><span class="line">    out+= SPACE;</span><br><span class="line">    out+= std::<span class="built_in">to_string</span>(_y);</span><br><span class="line">    <span class="comment">// 不用添加分隔符（这是encode要干的事情）</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-4-3-反序列化"><a href="#3-4-3-反序列化" class="headerlink" title="3.4.3 反序列化"></a>3.4.3 反序列化</h3><p>注意，思路不能搞错了。刚开始我认为<code>request</code>的反序列化应该针对的是服务器的返回值，<strong>实际并非如此</strong>！</p><p>在客户端和服务端都需要使用<code>request</code>，客户端进行序列化，服务端对接收到的结果利用<code>request</code>进行反序列化。request只关注于对请求的处理，而不处理服务器的返回值。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 反序列化</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">deserialize</span><span class="params">(<span class="type">const</span> std::string &amp;in)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// x + y 需要取出x，y和操作符</span></span><br><span class="line">    <span class="type">size_t</span> space1 = in.<span class="built_in">find</span>(SPACE); <span class="comment">//第一个空格</span></span><br><span class="line">    <span class="keyword">if</span>(space1 == std::string::npos)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">size_t</span> space2 = in.<span class="built_in">rfind</span>(SPACE); <span class="comment">//第二个空格</span></span><br><span class="line">    <span class="keyword">if</span>(space2 == std::string::npos)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 两个空格都存在，开始取数据</span></span><br><span class="line">    std::string dataX = in.<span class="built_in">substr</span>(<span class="number">0</span>,space1);</span><br><span class="line">    std::string dataY = in.<span class="built_in">substr</span>(space2+SPACE_LEN);<span class="comment">//默认取到结尾</span></span><br><span class="line">    std::string op = in.<span class="built_in">substr</span>(space1+SPACE_LEN,space2 -(space1+SPACE_LEN));</span><br><span class="line">    <span class="keyword">if</span>(op.<span class="built_in">size</span>()!=<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;<span class="comment">//操作符长度有问题</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//没问题了，转内部成员</span></span><br><span class="line">    _x = <span class="built_in">atoi</span>(dataX.<span class="built_in">c_str</span>());</span><br><span class="line">    _y = <span class="built_in">atoi</span>(dataY.<span class="built_in">c_str</span>());</span><br><span class="line">    _ops = op[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-5-response"><a href="#3-5-response" class="headerlink" title="3.5 response"></a>3.5 response</h2><h3 id="3-5-1-构造"><a href="#3-5-1-构造" class="headerlink" title="3.5.1 构造"></a>3.5.1 构造</h3><p>返回值的构造比较简单，因为是服务器处理结果之后的操作；这些成员变量都设置为了公有，方便后续修改。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Response</span>(<span class="type">int</span> code=<span class="number">0</span>,<span class="type">int</span> result=<span class="number">0</span>)</span><br><span class="line">    :_exitCode(code),_result(result)</span><br><span class="line">&#123;&#125;</span><br></pre></td></tr></table></figure><h3 id="3-5-2-序列化"><a href="#3-5-2-序列化" class="headerlink" title="3.5.2 序列化"></a>3.5.2 序列化</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 入参是空的</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">serialize</span><span class="params">(std::string&amp; out)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// code ret</span></span><br><span class="line">    out.<span class="built_in">clear</span>();</span><br><span class="line">    out+= std::<span class="built_in">to_string</span>(_exitCode);</span><br><span class="line">    out+= SPACE;</span><br><span class="line">    out+= std::<span class="built_in">to_string</span>(_result);</span><br><span class="line">    out+= CRLF;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-5-3-反序列化"><a href="#3-5-3-反序列化" class="headerlink" title="3.5.3 反序列化"></a>3.5.3 反序列化</h3><p>响应的反序列化只需要处理一个空格，相对来说较为简单</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 反序列化</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">deserialize</span><span class="params">(<span class="type">const</span> std::string &amp;in)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 只有一个空格</span></span><br><span class="line">    <span class="type">size_t</span> space = in.<span class="built_in">find</span>(SPACE);</span><br><span class="line">    <span class="keyword">if</span>(space == std::string::npos)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    std::string dataCode = in.<span class="built_in">substr</span>(<span class="number">0</span>,space);</span><br><span class="line">    std::string dataRes = in.<span class="built_in">substr</span>(space+SPACE_LEN);</span><br><span class="line">    _exitCode = <span class="built_in">atoi</span>(dataCode.<span class="built_in">c_str</span>());</span><br><span class="line">    _result = <span class="built_in">atoi</span>(dataRes.<span class="built_in">c_str</span>());</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-6-客户端"><a href="#3-6-客户端" class="headerlink" title="3.6 客户端"></a>3.6 客户端</h2><p>之前写的客户端，并没有进行序列化操作，所以我们需要添加上序列化操作，并对服务器的返回值进行反序列化。这期间需要加上一系列判断；</p><p>为了限制篇幅，下面只贴出来客户端的循环操作；详情参考注释。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 客户端发现的消息</span></span><br><span class="line">string message;</span><br><span class="line"><span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">    message.<span class="built_in">clear</span>();<span class="comment">//每次循环开始，都清空一下msg</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;请输入你的消息# &quot;</span>;</span><br><span class="line">    <span class="built_in">getline</span>(cin, message);<span class="comment">//获取输入</span></span><br><span class="line">    <span class="comment">// 如果客户端输入了quit，则退出</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">strcasecmp</span>(message.<span class="built_in">c_str</span>(), <span class="string">&quot;quit&quot;</span>) == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="comment">// 向服务端发送消息</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1.创建一个request（分离参数）</span></span><br><span class="line">    <span class="type">bool</span> reqStatus = <span class="literal">true</span>;</span><br><span class="line">    <span class="function">Request <span class="title">req</span><span class="params">(message,&amp;reqStatus)</span></span>;</span><br><span class="line">    <span class="keyword">if</span>(!reqStatus)&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;make req err!&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 2.序列化和编码</span></span><br><span class="line">    string package;</span><br><span class="line">    req.<span class="built_in">serialize</span>(package);<span class="comment">//序列化</span></span><br><span class="line">    package = <span class="built_in">encode</span>(package,package.<span class="built_in">size</span>());<span class="comment">//编码</span></span><br><span class="line">    <span class="comment">// 3.发送给服务器</span></span><br><span class="line">    <span class="type">ssize_t</span> s = <span class="built_in">write</span>(sock,package.<span class="built_in">c_str</span>(), package.<span class="built_in">size</span>());</span><br><span class="line">    <span class="keyword">if</span> (s &gt; <span class="number">0</span>) <span class="comment">// 写入成功</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 4.获取服务器的结果</span></span><br><span class="line">        <span class="type">char</span> buff[BUFFER_SIZE];</span><br><span class="line">        <span class="type">size_t</span> s = <span class="built_in">read</span>(sock, buff, <span class="built_in">sizeof</span>(buff)<span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">if</span>(s &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            buff[s] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        std::string echoPackage = buff;</span><br><span class="line">        Response resp;</span><br><span class="line">        <span class="type">size_t</span> len = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 5.解码和反序列化</span></span><br><span class="line">        std::string tmp = <span class="built_in">decode</span>(echoPackage, &amp;len);</span><br><span class="line">        <span class="keyword">if</span>(len &gt; <span class="number">0</span>)<span class="comment">//解码成功</span></span><br><span class="line">        &#123;</span><br><span class="line">            echoPackage = tmp;</span><br><span class="line">            <span class="keyword">if</span>(resp.<span class="built_in">deserialize</span>(echoPackage))<span class="comment">//反序列化并判断</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;ECHO [exitcode: %d] %d\n&quot;</span>, resp._exitCode, resp._result);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                cerr &lt;&lt; <span class="string">&quot;server echo deserialize err!&quot;</span> &lt;&lt; endl;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            cerr &lt;&lt; <span class="string">&quot;server echo decode err!&quot;</span> &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (s &lt;= <span class="number">0</span>) <span class="comment">// 写入失败</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-7-服务端"><a href="#3-7-服务端" class="headerlink" title="3.7 服务端"></a>3.7 服务端</h2><p>服务端无须修改代码，需要修改的是task消息队列中处理的任务；这就是之前做好封装的好处，因为只需要修改task里面传入的函数指针，就算是修改了服务器所进行的服务</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 提供服务（通过线程池）</span></span><br><span class="line"><span class="function">Task <span class="title">t</span><span class="params">(conet,senderIP,senderPort,CaculateService)</span></span>;</span><br><span class="line">_tpool-&gt;<span class="built_in">push</span>(t);</span><br></pre></td></tr></table></figure><p>如下是计算器服务的代码</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">CaculateService</span><span class="params">(<span class="type">int</span> sockfd, <span class="type">const</span> std::string &amp;clientIP, <span class="type">uint16_t</span> clientPort)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">assert</span>(sockfd &gt;= <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">assert</span>(!clientIP.<span class="built_in">empty</span>());</span><br><span class="line">    <span class="built_in">assert</span>(clientPort &gt; <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    std::string inbuf;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        Request req;</span><br><span class="line">        <span class="type">char</span> buf[BUFFER_SIZE];</span><br><span class="line">        <span class="comment">// 1.读取客户端发送的信息</span></span><br><span class="line">        <span class="type">ssize_t</span> s = <span class="built_in">read</span>(sockfd, buf, <span class="built_in">sizeof</span>(buf) - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (s == <span class="number">0</span>)</span><br><span class="line">        &#123;   <span class="comment">// s == 0代表对方发送了空消息，视作客户端主动退出</span></span><br><span class="line">            <span class="built_in">logging</span>(DEBUG, <span class="string">&quot;client quit: %s[%d]&quot;</span>, clientIP.<span class="built_in">c_str</span>(), clientPort);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(s&lt;<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 出现了读取错误，打印日志后断开连接</span></span><br><span class="line">            <span class="built_in">logging</span>(DEBUG, <span class="string">&quot;read err: %s[%d] = %s&quot;</span>, clientIP.<span class="built_in">c_str</span>(), clientPort, <span class="built_in">strerror</span>(errno));</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 2.读取成功</span></span><br><span class="line">        buf[s] = <span class="string">&#x27;\0&#x27;</span>; <span class="comment">// 手动添加字符串终止符</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">strcasecmp</span>(buf, <span class="string">&quot;quit&quot;</span>) == <span class="number">0</span>)</span><br><span class="line">        &#123; <span class="comment">// 客户端主动退出</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 3.开始服务</span></span><br><span class="line">        inbuf = buf;</span><br><span class="line">        <span class="type">size_t</span> packageLen = inbuf.<span class="built_in">size</span>();</span><br><span class="line">        <span class="comment">// 3.1.解码和反序列化客户端传来的消息</span></span><br><span class="line">        std::string package = <span class="built_in">decode</span>(inbuf, &amp;packageLen);<span class="comment">//解码</span></span><br><span class="line">        <span class="keyword">if</span>(packageLen==<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="built_in">logging</span>(DEBUG, <span class="string">&quot;decode err: %s[%d] status: %d&quot;</span>, clientIP.<span class="built_in">c_str</span>(), clientPort, packageLen);</span><br><span class="line">            <span class="keyword">continue</span>;<span class="comment">//报文不完整或有误</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">logging</span>(DEBUG,<span class="string">&quot;package: %s[%d] = %s&quot;</span>,clientIP.<span class="built_in">c_str</span>(), clientPort,package.<span class="built_in">c_str</span>());</span><br><span class="line">        <span class="type">bool</span> deStatus = req.<span class="built_in">deserialize</span>(package); <span class="comment">// 反序列化</span></span><br><span class="line">        <span class="keyword">if</span>(deStatus) <span class="comment">// 获取消息反序列化成功</span></span><br><span class="line">        &#123;</span><br><span class="line">            req.<span class="built_in">debug</span>(); <span class="comment">// 打印信息</span></span><br><span class="line">            <span class="comment">// 3.2.获取结构化的相应</span></span><br><span class="line">            Response resp = <span class="built_in">Caculater</span>(req);</span><br><span class="line">            <span class="comment">// 3.3.序列化和编码响应</span></span><br><span class="line">            std::string echoStr;</span><br><span class="line">            resp.<span class="built_in">serialize</span>(echoStr);</span><br><span class="line">            echoStr = <span class="built_in">encode</span>(echoStr,echoStr.<span class="built_in">size</span>());</span><br><span class="line">            <span class="comment">// 3.4.写入，发送返回值给客户端</span></span><br><span class="line">            <span class="built_in">write</span>(sockfd, echoStr.<span class="built_in">c_str</span>(), echoStr.<span class="built_in">size</span>());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="comment">// 客户端消息反序列化失败</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">logging</span>(DEBUG, <span class="string">&quot;deserialize err: %s[%d] status: %d&quot;</span>, clientIP.<span class="built_in">c_str</span>(), clientPort, deStatus);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">close</span>(sockfd);</span><br><span class="line">    <span class="built_in">logging</span>(DEBUG, <span class="string">&quot;server quit: %s[%d] %d&quot;</span>,clientIP.<span class="built_in">c_str</span>(), clientPort, sockfd);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中有一个计算函数，比较简单，通过switch case语句，计算结果，并判断操作数是否有问题。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Response <span class="title">Caculater</span><span class="params">(<span class="type">const</span> Request&amp; req)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Response resp;<span class="comment">//构造函数中已经指定了exitcode为0</span></span><br><span class="line">    <span class="keyword">switch</span> (req._ops)</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;+&#x27;</span>:</span><br><span class="line">        resp._result = req._x + req._y;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;-&#x27;</span>:</span><br><span class="line">        resp._result = req._x - req._y;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;*&#x27;</span>:</span><br><span class="line">        resp._result = req._x * req._y;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;%&#x27;</span>:</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(req._y == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            resp._exitCode = <span class="number">-1</span>;<span class="comment">//取模错误</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        resp._result = req._x % req._y;<span class="comment">//取模是可以操作负数的</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;/&#x27;</span>:</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(req._y == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            resp._exitCode = <span class="number">-2</span>;<span class="comment">//除0错误</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        resp._result = req._x / req._y;<span class="comment">//取模是可以操作负数的</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        resp._exitCode = <span class="number">-3</span>;<span class="comment">//操作符非法</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> resp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样，我们的序列化处理就成功了！测试一下吧</p><h1 id="4-测试"><a href="#4-测试" class="headerlink" title="4.测试"></a>4.测试</h1><p>运行服务器，可以看到，服务器能成功处理客户端的计算，并返回结果</p><p><img                       lazyload                     alt="image"                     data-src="https://img1.musnow.top/i/23/02/63e86fed80298.png"                      alt="image-20230212124940995"                ></p><p>输入quit，服务器会打印信息，并退出服务</p><p><img                       lazyload                     alt="image"                     data-src="https://img1.musnow.top/i/23/02/63e87096915d4.png"                      alt="image-20230212125238473"                ></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;以tcpServer的&lt;strong&gt;计算器&lt;/strong&gt;服务为例，实现一个自定义协议&lt;/p&gt;</summary>
    
    
    
    <category term="玩上Linux" scheme="https://blog.musnow.top/categories/%E7%8E%A9%E4%B8%8ALinux/"/>
    
    
    <category term="Linux" scheme="https://blog.musnow.top/tags/Linux/"/>
    
    <category term="网络" scheme="https://blog.musnow.top/tags/%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>【Git】如何修改本地仓库的用户名和邮箱</title>
    <link href="https://blog.musnow.top/2023/02/11/tools/13%E4%BF%AE%E6%94%B9git%E7%94%A8%E6%88%B7%E5%90%8D%E5%92%8C%E9%82%AE%E7%AE%B1/"/>
    <id>https://blog.musnow.top/2023/02/11/tools/13%E4%BF%AE%E6%94%B9git%E7%94%A8%E6%88%B7%E5%90%8D%E5%92%8C%E9%82%AE%E7%AE%B1/</id>
    <published>2023-02-11T01:19:28.000Z</published>
    <updated>2023-02-11T01:18:56.643Z</updated>
    
    <content type="html"><![CDATA[<p>最近我修改了我gitee和github的用户名还有邮箱，所以需要对本地仓库配置的用户名和邮箱进行更改</p><span id="more"></span><h1 id="1-命令"><a href="#1-命令" class="headerlink" title="1.命令"></a>1.命令</h1><p> 刚开始我使用的是如下命令</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git config --global user.email &quot;邮箱&quot;</span><br><span class="line">git config --global user.name &quot;用户名&quot;</span><br></pre></td></tr></table></figure><p>但是很不辛，这个命令没有用，因为它是用来初始化你的git环境的，对已有的git仓库不起作用</p><p>但是我们在<code>linux</code>下可以添加上另外一个参数来实现</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git config --global --replace-all user.email &quot;邮箱&quot; </span><br><span class="line">git config --global --replace-all user.name &quot;用户名&quot;</span><br></pre></td></tr></table></figure><p>这样就修改成功了</p><p><img                       lazyload                     alt="image"                     data-src="https://img1.musnow.top/i/23/02/63e6eaa589b3b.png"                      alt="image-20230211090846508"                ></p><blockquote><p>这个命令在windows下似乎无法识别，会弹出git的命令行帮助</p><p><img                       lazyload                     alt="image"                     data-src="https://img1.musnow.top/i/23/02/63e6ec242c79e.png"                      alt="image-20230211091516456"                ></p></blockquote><p>但是，修改成功后的提交，只对未来的提交有效；这里必须得吐槽一下gitee和github统计提交的不同之处</p><ul><li>gitee统计提交依据的是用户名+邮箱，只要有一个不对就无法统计</li><li>github统计提交只依据邮箱，只要你邮箱对了，用户名是不管你的</li></ul><p>所以要想让gitee的统计能生效，那就必须要修改之前所有提交信息中的用户名和邮箱</p><p><img                       lazyload                     alt="image"                     data-src="https://img1.musnow.top/i/23/02/63e6eba93dc9c.png"                      alt="image-20230211091313728"                ></p><h1 id="2-修改之前提交中的用户名和邮箱"><a href="#2-修改之前提交中的用户名和邮箱" class="headerlink" title="2.修改之前提交中的用户名和邮箱"></a>2.修改之前提交中的用户名和邮箱</h1><blockquote><p><a class="link"   href="https://cloud.tencent.com/developer/article/1946705#:~:text=%E5%A6%82%E6%9E%9C%E9%9C%80%E8%A6%81%E4%BF%AE%E6%94%B9%20git%20%E5%9C%A8%E6%9C%AC%E5%9C%B0%E7%9A%84%E5%85%A8%E5%B1%80%E9%82%AE%E7%AE%B1%E5%92%8C%E7%94%A8%E6%88%B7%E5%90%8D%EF%BC%8C%E6%89%A7%E8%A1%8C%E4%B8%8B%E9%9D%A2%E7%9A%84%E5%91%BD%E4%BB%A4%E3%80%82%20git%20config%20--global%20user.name%20%22%E8%BE%93%E5%85%A5%E4%BD%A0%E7%9A%84%E7%94%A8%E6%88%B7%E5%90%8D%22,%22%E8%BE%93%E5%85%A5%E4%BD%A0%E7%9A%84%E9%82%AE%E7%AE%B1%22%20%E7%8E%B0%E5%9C%A8%E6%88%91%E4%BB%AC%E5%B7%B2%E7%BB%8F%E8%AE%BE%E7%BD%AE%E5%A5%BD%E4%BA%86%E6%9C%AC%E5%9C%B0%20git%20%E7%9A%84%20user.name%20%E5%92%8C%20user.email%20%E4%BF%A1%E6%81%AF%E3%80%82" >参考博客<i class="fas fa-external-link-alt"></i></a></p></blockquote><p>复制如下代码到一个本文编辑器里面，将内部的邮箱和用户信息修改</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">git filter-branch -f --env-filter &#x27;</span><br><span class="line">OLD_EMAIL=&quot;原来的邮箱&quot;</span><br><span class="line">CORRECT_NAME=&quot;现在的名字&quot;</span><br><span class="line">CORRECT_EMAIL=&quot;现在的邮箱&quot;</span><br><span class="line">if [ &quot;$GIT_COMMITTER_EMAIL&quot; = &quot;$OLD_EMAIL&quot; ]</span><br><span class="line">then</span><br><span class="line">    export GIT_COMMITTER_NAME=&quot;$CORRECT_NAME&quot;</span><br><span class="line">    export GIT_COMMITTER_EMAIL=&quot;$CORRECT_EMAIL&quot;</span><br><span class="line">fi</span><br><span class="line">if [ &quot;$GIT_AUTHOR_EMAIL&quot; = &quot;$OLD_EMAIL&quot; ]</span><br><span class="line">then</span><br><span class="line">    export GIT_AUTHOR_NAME=&quot;$CORRECT_NAME&quot;</span><br><span class="line">    export GIT_AUTHOR_EMAIL=&quot;$CORRECT_EMAIL&quot;</span><br><span class="line">fi</span><br><span class="line">&#x27; --tag-name-filter cat -- --branches --tags</span><br></pre></td></tr></table></figure><p>随后将其粘贴到git命令行中，回车执行</p><p><img                       lazyload                     alt="image"                     data-src="https://img1.musnow.top/i/23/02/63e6eb4885b41.png"                      alt="image-20230211091136866"                ></p><p><img                       lazyload                     alt="image"                     data-src="https://img1.musnow.top/i/23/02/63e6ec56eebd5.png"                      alt="image-20230211091607229"                ></p><p>执行完毕，就能看到所有git提交的用户名和邮箱都修改成功了！接下来要做的就是强制提交</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push -f</span><br></pre></td></tr></table></figure><p>强制提交了之后，之前显示不出来的信息和小绿点，现在也能正常显示了</p><p><img                       lazyload                     alt="image"                     data-src="https://img1.musnow.top/i/23/02/63e6eb7339c69.png"                      alt="image-20230211091219547"                ></p><p>如果用上面的命令修改失败的话，那就尝试执行下面的命令</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git filter-branch -f --index-filter &#x27;git rm --cached --ignore-unmatch Rakefile&#x27; HEAD</span><br></pre></td></tr></table></figure><p>随后再重试上面的命令，应该就OK了</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;最近我修改了我gitee和github的用户名还有邮箱，所以需要对本地仓库配置的用户名和邮箱进行更改&lt;/p&gt;</summary>
    
    
    
    <category term="差生文具多" scheme="https://blog.musnow.top/categories/%E5%B7%AE%E7%94%9F%E6%96%87%E5%85%B7%E5%A4%9A/"/>
    
    
    <category term="Linux" scheme="https://blog.musnow.top/tags/Linux/"/>
    
    <category term="git" scheme="https://blog.musnow.top/tags/git/"/>
    
  </entry>
  
  <entry>
    <title>【Python】教你白嫖replit部署kook-ticket-bot</title>
    <link href="https://blog.musnow.top/2023/02/09/note_Python/9%E7%99%BD%E5%AB%96replist%E9%83%A8%E7%BD%B2ticket%E6%9C%BA%E5%99%A8%E4%BA%BA/"/>
    <id>https://blog.musnow.top/2023/02/09/note_Python/9%E7%99%BD%E5%AB%96replist%E9%83%A8%E7%BD%B2ticket%E6%9C%BA%E5%99%A8%E4%BA%BA/</id>
    <published>2023-02-09T10:19:00.000Z</published>
    <updated>2023-02-10T03:54:48.991Z</updated>
    
    <content type="html"><![CDATA[<p>教你白嫖replit部署kook的ticket机器人</p><span id="more"></span><h1 id="1-前言"><a href="#1-前言" class="headerlink" title="1.前言"></a>1.前言</h1><p>最近有不少老哥来找我咨询有关ticket机器人的事情，当前ticket机器人需要云服务器才能部署，有些不太友好（要钱啊！而且也不是人人都会安装python环境）</p><p>所以在这里利用<a class="link"   href="https://replit.com/" >replit<i class="fas fa-external-link-alt"></i></a>和<a class="link"   href="https://uptimerobot.com/" >uptimerobot<i class="fas fa-external-link-alt"></i></a>两个平台，给大家介绍一个白嫖的方法，实现部署<a class="link"   href="https://gitee.com/musnow/Kook-Ticket-Bot/tree/main" >kook-ticket-bot<i class="fas fa-external-link-alt"></i></a></p><p><font color=Red>注意！</font>replit上的免费仓库，默认是<strong>公开</strong>的，也就是所有人都能访问到你这个仓库里面的文件，包括bot的token和日志信息！若您的ticket-bot对数据私密性要求较高，请<strong>自购服务器</strong>或找开发者代为部署！</p><h1 id="2-准备"><a href="#2-准备" class="headerlink" title="2.准备"></a>2.准备</h1><h2 id="2-1-注册账户"><a href="#2-1-注册账户" class="headerlink" title="2.1 注册账户"></a>2.1 注册账户</h2><p>这两个平台国内访问缓慢，如果实在进不去，就下载一个<code>steam++</code>(又称watt toolkit)</p><blockquote><p><a class="link"   href="https://gitee.com/rmbgame/SteamTools/releases/tag/2.8.6" >https://gitee.com/rmbgame/SteamTools/releases/tag/2.8.6<i class="fas fa-external-link-alt"></i></a></p></blockquote><p>如图，下载exe就可以了</p><p><img                       lazyload                     alt="image"                     data-src="https://img1.musnow.top/i/23/02/63e4c97b28c87.png"                      alt="image-20230209182251919"                ></p><p>安装打开以后，把这一堆无差别勾上，点一键加速，应该就ok了，访问会稍微快一点</p><p><img                       lazyload                     alt="image"                     data-src="https://img1.musnow.top/i/23/02/63e4c99abf86a.png"                      alt="image-20230209182323805"                ></p><p>随后就是注册这两个平台的账户了，应该不需要教吧（doge）</p><h2 id="2-2-打开gitee仓库"><a href="#2-2-打开gitee仓库" class="headerlink" title="2.2 打开gitee仓库"></a>2.2 打开gitee仓库</h2><blockquote><p><a class="link"   href="https://gitee.com/musnow/Kook-Ticket-Bot/tree/main/code" >https://gitee.com/musnow/Kook-Ticket-Bot/tree/main/code<i class="fas fa-external-link-alt"></i></a></p></blockquote><p>为了方便访问，我将ticket-bot在gitee也传了一份，大家打开仓库的code目录，准备拷贝代码</p><h2 id="2-3-申请kook开发者"><a href="#2-3-申请kook开发者" class="headerlink" title="2.3 申请kook开发者"></a>2.3 申请kook开发者</h2><blockquote><p><a class="link"   href="https://developer.kookapp.cn/app/index" >https://developer.kookapp.cn/app/index<i class="fas fa-external-link-alt"></i></a></p></blockquote><p>到kook的开发者平台，加入官方频道申请承为开发者，获取创建bot的权限；有了权限之后，新建一个应用</p><p><img                       lazyload                     alt="image"                     data-src="https://img1.musnow.top/i/23/02/63e4cad5ec685.png"                      alt="image-20230209182839605"                ></p><p><img                       lazyload                     alt="image"                     data-src="https://img1.musnow.top/i/23/02/63e4cba500721.png"                      alt="image-20230209183206514"                ></p><p>随后进入机器人页面，复制这里的token，先保存起来，后面要用（一会再来复制也行）</p><p><img                       lazyload                     alt="image"                     data-src="https://img1.musnow.top/i/23/02/63e4cbd3db568.png"                      alt="image-20230209183253285"                ></p><p>进入邀请页面，给予机器人管理员权限（这样是为了方便，不然得钩一大堆）</p><p>然后复制上面的邀请链接到浏览器，邀请机器人进入你的服务器</p><p><img                       lazyload                     alt="image"                     data-src="https://img1.musnow.top/i/23/02/63e4cc23379a8.png"                      alt="image-20230209183412507"                ></p><p><img                       lazyload                     alt="image"                     data-src="https://img1.musnow.top/i/23/02/63e4cc59c0389.png"                      alt="image-20230209183507516"                ></p><h1 id="3-开始部署"><a href="#3-开始部署" class="headerlink" title="3.开始部署"></a>3.开始部署</h1><h2 id="3-1-创建python"><a href="#3-1-创建python" class="headerlink" title="3.1 创建python"></a>3.1 创建python</h2><p>来到replit，创建仓库</p><p><img                       lazyload                     alt="image"                     data-src="https://img1.musnow.top/i/23/02/63e4cc934caf7.png"                      alt="image-20230209183604137"                ></p><p>选择python，然后给它取个名字</p><p><img                       lazyload                     alt="image"                     data-src="https://img1.musnow.top/i/23/02/63e4cca3b57b2.png"                      alt="image-20230209183621372"                ></p><p>创建之后进入这个项目</p><p><img                       lazyload                     alt="image"                     data-src="https://img1.musnow.top/i/23/02/63e4ccf8373da.png"                      alt="image-20230209183745982"                ></p><h2 id="3-2-添加代码文件"><a href="#3-2-添加代码文件" class="headerlink" title="3.2 添加代码文件"></a>3.2 添加代码文件</h2><p>进来之后是这样的页面，只有一个<code>main.py</code>，其他什么都无</p><p><img                       lazyload                     alt="image"                     data-src="https://img1.musnow.top/i/23/02/63e4cd2483286.png"                      alt="image-20230209183829907"                ></p><p>点击左上角这个小按钮，创建一个新文件，命名为<code>keepal.py</code></p><p><img                       lazyload                     alt="image"                     data-src="https://img1.musnow.top/i/23/02/63e4cd99c5447.png"                      alt="image-20230209184027580"                ></p><p>复制如下代码到<code>keepal.py</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># encoding: utf-8</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> Flask</span><br><span class="line"><span class="keyword">from</span> threading <span class="keyword">import</span> Thread</span><br><span class="line"><span class="comment"># 初始化</span></span><br><span class="line">app = Flask(<span class="string">&#x27; &#x27;</span>)</span><br><span class="line"><span class="comment"># 设立根路径作为api调用</span></span><br><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">&#x27;/&#x27;</span></span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">home</span>():</span><br><span class="line">  text = <span class="string">&quot;ticket bot online!&quot;</span></span><br><span class="line">  <span class="built_in">print</span>(text)</span><br><span class="line">  <span class="keyword">return</span> text</span><br><span class="line"><span class="comment"># 开始运行，绑定ip和端口</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">run</span>():</span><br><span class="line">  app.run(host=<span class="string">&#x27;0.0.0.0&#x27;</span>,port = <span class="number">8000</span>)</span><br><span class="line"><span class="comment"># 通过线程运行</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">keep_alive</span>():</span><br><span class="line">  t= Thread(target=run)</span><br><span class="line">  t.start()</span><br></pre></td></tr></table></figure><p>随后，就开始根据我仓库的代码，创建同名文件，并将代码复制进去</p><blockquote><p>github的代码更加新，如果能打开github，请在github复制代码：<a class="link"   href="https://github.com/musnows/Kook-Ticket-Bot" >https://github.com/musnows/Kook-Ticket-Bot<i class="fas fa-external-link-alt"></i></a></p><p>实在打不开，再来gitee：<a class="link"   href="https://gitee.com/musnow/Kook-Ticket-Bot/tree/main/code" >https://gitee.com/musnow/Kook-Ticket-Bot/tree/main/code<i class="fas fa-external-link-alt"></i></a></p></blockquote><p>main就不用创建了，默认已经有了，直接把代码复制进去就行了；所有文件添加完毕之后，应该是下面这样的</p><p><img                       lazyload                     alt="image"                     data-src="https://img1.musnow.top/i/23/02/63e4d089ce45e.png"                      alt="image-20230209185259526"                ></p><p>这样，代码就添加好了</p><h2 id="3-3-添加配置文件"><a href="#3-3-添加配置文件" class="headerlink" title="3.3 添加配置文件"></a>3.3 添加配置文件</h2><p>接下来就是更具仓库的README添加各类配置文件</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">config/config.json <span class="comment">#机器人token配置</span></span><br><span class="line">config/TicketConf.json <span class="comment"># ticket配置</span></span><br><span class="line">log/TicketLog.json <span class="comment">#ticket日志</span></span><br><span class="line">log/TicketMsgLog.json <span class="comment"># 消息记录</span></span><br><span class="line">log/ColorID.json <span class="comment"># 表情回应上角色</span></span><br></pre></td></tr></table></figure><p>先把如上的几个文件全部建立好，然后根据<a class="link"   href="https://gitee.com/musnow/Kook-Ticket-Bot/blob/main/README.md" >仓库的README<i class="fas fa-external-link-alt"></i></a>往里面添加键值，这里不重复README中已有内容</p><p>很多操作都需要复制ID，先在设置高级设置中开启开发者模式</p><p><img                       lazyload                     alt="image"                     data-src="https://img1.musnow.top/i/23/02/63e4d159b33fa.png"                      alt="image-20230209185627493"                ></p><p>下面给出一个<code>TicketConf.json</code>中需要配置的几项的样例</p><p><img                       lazyload                     alt="image"                     data-src="https://img1.musnow.top/i/23/02/63e4d287f32c9.png"                      alt="image-20230209190129489"                ></p><p><img                       lazyload                     alt="image"                     data-src="https://img1.musnow.top/i/23/02/63e4d2e8b0e74.png"                      alt="image-20230209190306382"                ></p><p>在这里重申，添加了这两个角色id之后，<strong>必须要给予用户对应的角色</strong>（特别是腐竹）才能操作bot的命令，否则提示权限不足</p><p>配置为文件添加完毕之后，应该是下面这样的</p><p><img                       lazyload                     alt="image"                     data-src="https://img1.musnow.top/i/23/02/63e4d7db5ccc3.png"                      alt="image-20230209192413122"                ></p><h2 id="3-4-开始运行"><a href="#3-4-开始运行" class="headerlink" title="3.4 开始运行"></a>3.4 开始运行</h2><p>开始运行前的最后一步，进入<code>main.py</code>，取消对最后两行代码的注释</p><p><img                       lazyload                     alt="image"                     data-src="https://img1.musnow.top/i/23/02/63e4d41360485.png"                      alt="image-20230209190805189"                ></p><p>这个时候就可以点击顶部的run，尝试运行bot了，变成下面的样子那就是在运行了</p><p><img                       lazyload                     alt="image"                     data-src="https://img1.musnow.top/i/23/02/63e4d358873d0.png"                      alt="image-20230209190458439"                ></p><p>刚开始打印会提示这个，代表没有找到对应的包</p><p><img                       lazyload                     alt="image"                     data-src="https://img1.musnow.top/i/23/02/63e4d367a7794.png"                      alt="image-20230209190513475"                ></p><p>工具tools里面选择packges，在里面搜索khl.py</p><p><img                       lazyload                     alt="image"                     data-src="https://img1.musnow.top/i/23/02/63e4d37809943.png"                      alt="image-20230209190529916"                ></p><p><img                       lazyload                     alt="image"                     data-src="https://img1.musnow.top/i/23/02/63e4d3d2dae7e.png"                      alt="image-20230209190601848"                ></p><p>如下提示，安装成功！</p><p><img                       lazyload                     alt="image"                     data-src="https://img1.musnow.top/i/23/02/63e4d3cfc2cc7.png"                      alt="image-20230209190657593"                ></p><p>在点击运行，出现如图所示的页面，那就是运行成功了！</p><p><img                       lazyload                     alt="image"                     data-src="https://img1.musnow.top/i/23/02/63e4d437ebe6e.png"                      alt="image-20230209190841115"                ></p><p>现在进kook里面，先测试一下我们的bot是否在线</p><p><img                       lazyload                     alt="image"                     data-src="https://img1.musnow.top/i/23/02/63e4d45c3ee99.png"                      alt="image-20230209190918053"                ></p><p>测试通过！后台也打印出了日志</p><p><img                       lazyload                     alt="image"                     data-src="https://img1.musnow.top/i/23/02/63e4d48dd932c.png"                      alt="image-20230209191007686"                ></p><h2 id="3-5-uptimeRobot"><a href="#3-5-uptimeRobot" class="headerlink" title="3.5 uptimeRobot"></a>3.5 uptimeRobot</h2><p>别急别急，虽然到这里已经ok了，但我们还有一个步骤要做</p><p>进入uptimeRobot，需要创建一个监控实例，来调用我们的<code>keepal</code>模组中的函数，保证我们的bot不会因为replit的策略而下线</p><p><img                       lazyload                     alt="image"                     data-src="https://img1.musnow.top/i/23/02/63e4d4c987b38.png"                      alt="image-20230209191107440"                ></p><p>点击<code>add new monitor</code>，选择http</p><p><img                       lazyload                     alt="image"                     data-src="https://img1.musnow.top/i/23/02/63e4d4d329cad.png"                      alt="image-20230209191116969"                ></p><p><img                       lazyload                     alt="image"                     data-src="https://img1.musnow.top/i/23/02/63e4d4f293359.png"                      alt="image-20230209191148477"                ></p><p>按如下所示填写</p><ul><li>name随便填个英文名</li><li>url填在replit复制的链接</li><li>intervel是单次监控的间隔，选择1-5分钟都可以</li><li>timeout默认30s不需要修改</li><li>两个ssl取消勾选</li></ul><p><img                       lazyload                     alt="image"                     data-src="https://img1.musnow.top/i/23/02/63e4d55ecb6e0.png"                      alt="image-20230209191336353"                ></p><p>建议勾选上这个，在bot下线的时候，会向你的邮箱发送通知</p><p><img                       lazyload                     alt="image"                     data-src="https://img1.musnow.top/i/23/02/63e4d5ab3b849.png"                      alt="image-20230209191453032"                ></p><p>配置完毕，点击右下角的create</p><p><img                       lazyload                     alt="image"                     data-src="https://img1.musnow.top/i/23/02/63e4d5d51fadc.png"                      alt="image-20230209191534999"                ></p><p>这时候就会开始运行了！下方的<code>pause</code>可以暂停运行。</p><p><img                       lazyload                     alt="image"                     data-src="https://img1.musnow.top/i/23/02/63e4d60795e56.png"                      alt="image-20230209191625292"                ></p><p>如果你create完毕，发现是黑色的，那就点击一下<code>start</code>让他开始运行</p><h1 id="4-日志文件"><a href="#4-日志文件" class="headerlink" title="4.日志文件"></a>4.日志文件</h1><p>默认的所有打印都会打印到控制台里面，运行时间久了，replit的控制台可能无法获取到所有信息。所以我们需要对输出进行重定向</p><p>如果你需要日志文件（我建议一定要这么做！）那就需在main里面添加一部分代码</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#标准输出重定向至文件</span></span><br><span class="line">file =  <span class="built_in">open</span>(<span class="string">&#x27;./log/log.txt&#x27;</span>, <span class="string">&#x27;a&#x27;</span>)</span><br><span class="line">sys.stdout = file </span><br><span class="line">sys.stderr = file</span><br></pre></td></tr></table></figure><p>添加到开头<code>start_time</code>以后即可</p><p><img                       lazyload                     alt="image"                     data-src="https://img1.musnow.top/i/23/02/63e4e3a4815e1.png"                      alt="image-20230209201430435"                ></p><p>现在更新了代码以后，只需要取消开头这里的注释即可</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 标准输出重定向至文件</span></span><br><span class="line">logDup(<span class="string">&#x27;./log/log.txt&#x27;</span>)</span><br></pre></td></tr></table></figure><p><img                       lazyload                     alt="image"                     data-src="https://img1.musnow.top/i/23/02/63e4e89784e2b.png"                      alt="image-20230209203537248"                ></p><p>这样做还不够，bot有一个特殊的kill命令，执行此kill命令，可以刷新缓冲区，避免出现数据在缓冲区中没有写入到文件，导致丢失日志</p><p><strong>如果你想退出bot，建议使用kill命令来操作</strong>！</p><h1 id="大功告成！"><a href="#大功告成！" class="headerlink" title="大功告成！"></a>大功告成！</h1><p>现在你可以根据help去测试一下各类命令是否能正常工作啦</p><p><img                       lazyload                     alt="image"                     data-src="https://img1.musnow.top/i/23/02/63e4d65f0d1ba.png"                      alt="image-20230209191752878"                ></p><p><img                       lazyload                     alt="image"                     data-src="https://img1.musnow.top/i/23/02/63e4d66ef26cc.png"                      alt="image-20230209191808588"                ></p><p><img                       lazyload                     alt="image"                     data-src="https://img1.musnow.top/i/23/02/63e4d88927a1e.png"                      alt="image-20230209192707010"                ></p><p>注意，关闭ticket之后可能会出现这个报错，这是因为用户从来没有给bot发送过信息，导致bot无法用户发送私信，<strong>忽略</strong>此报错即可（新版本已经取消了这个报错）</p><p><img                       lazyload                     alt="image"                     data-src="https://img1.musnow.top/i/23/02/63e4d688ea0df.png"                      alt="image-20230209191834582"                ></p><p>因为replit是免费的，所以bot的反应可能有些迟钝，正常情况！</p><p><font color=Red>再次提醒！</font>replit上的免费仓库，默认是<strong>公开</strong>的，也就是所有人都能访问到你这个仓库里面的文件，包括bot的token和日志信息！若您的ticket-bot对数据私密性要求较高，请<strong>自购服务器</strong>或找开发者代为部署！</p><blockquote><p>你可以<a class="link"   href="https://replit.com/@Aewait/ticket#keepal.py" >fork我这次部署的bot<i class="fas fa-external-link-alt"></i></a>（23-02-10）但是后续的代码更新还是需要自己操作哦！</p></blockquote>]]></content>
    
    
    <summary type="html">&lt;p&gt;教你白嫖replit部署kook的ticket机器人&lt;/p&gt;</summary>
    
    
    
    <category term="速通Python" scheme="https://blog.musnow.top/categories/%E9%80%9F%E9%80%9APython/"/>
    
    
    <category term="Python" scheme="https://blog.musnow.top/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>【Linux】实现守护进程 | 以tcpServer为例</title>
    <link href="https://blog.musnow.top/2023/02/09/note_Linux/30%E5%AE%88%E6%8A%A4%E8%BF%9B%E7%A8%8B/"/>
    <id>https://blog.musnow.top/2023/02/09/note_Linux/30%E5%AE%88%E6%8A%A4%E8%BF%9B%E7%A8%8B/</id>
    <published>2023-02-09T06:08:30.000Z</published>
    <updated>2023-02-09T06:45:42.561Z</updated>
    
    <content type="html"><![CDATA[<p>本文将以tcp服务器代码为基本，讲述如何将进程守护进程化，后台运行</p><span id="more"></span><h1 id="1-守护进程"><a href="#1-守护进程" class="headerlink" title="1.守护进程"></a>1.守护进程</h1><p>所谓守护进程，就是和其他进程没有关系的进程；其独立运行于系统后台，除非自己退出或收到信号终止，否则会一直运行下去</p><h2 id="1-1-进程组"><a href="#1-1-进程组" class="headerlink" title="1.1 进程组"></a>1.1 进程组</h2><p>在我们使用的bash中，同一时刻只会有一个<strong>前台进程组</strong></p><p><img                       lazyload                     alt="image"                     data-src="https://img1.musnow.top/i/23/02/63e457da7126b.png"                      alt="image-20230209101802180"                ></p><p>如图，当一个前台进程开始运行之后，我们没有办法在当前终端开启<strong>第二个前台进程</strong>。</p><p>在运行的命令后面加&amp;，临时让当前进程<strong>在后台运行</strong>。注意，此时tcp虽然在后台运行了， 但对于它而言，<code>stdin/stdout/stderr</code>的文件描述符依旧指向的是当前bash的输入输出，所以它的日志依旧会打印到当前终端上。</p><p>用<code>ps</code>命令查看当前进程的信息，其中<code>ppid</code>是当前进程的父进程，也就是当前bash，<code>pid</code>是进程编号，<code>pgid</code>是进程的组编号，可以看到这个组编号和grep命令的组编号是不同的。</p><p><img                       lazyload                     alt="image"                     data-src="https://img1.musnow.top/i/23/02/63e45ba4133c4.png"                      alt="image-20230209103412568"                ></p><p>我们用这个c语言的代码调用两次fork，相当于创建了3个子进程。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    fork();</span><br><span class="line">    fork();</span><br><span class="line">    sleep(<span class="number">100</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时再来查看进程信息，能看到这4个进程的进程组pgid是相同的，而且和<strong>第一个test的pid相同</strong>；这说明第一个test就是<strong>父进程</strong>，后面的3个都是子进程。</p><p><img                       lazyload                     alt="image"                     data-src="https://img1.musnow.top/i/23/02/63e45da7770c3.png"                      alt="image-20230209104248061"                ></p><h2 id="1-2-进程会话"><a href="#1-2-进程会话" class="headerlink" title="1.2 进程会话"></a>1.2 进程会话</h2><p>这里还有一个我们之前没有太多了解的信息，进程的<strong>sid</strong>是什么？</p><p>还是上面的例子，在图中能看到，我们执行的test和grep的sid都是相同的，而且都等于第一个test进程的ppid（bash的pid）</p><p><img                       lazyload                     alt="image"                     data-src="https://img1.musnow.top/i/23/02/63e45da7770c3.png"                      alt="image-20230209104248061"                ></p><p>这表明图中的5个进程同属于一个进程会话，<strong>这个会话就是我们当前打开的bash</strong>，并用sid来表示进程会话；</p><blockquote><p>这也是为什么我们登录linux的时候一定会有一个终端，linux系统就是创建会话并加载bash，来给用户提供服务的。</p></blockquote><p>既然存在会话，那就肯定会有会话的资源上限。一旦满了，<strong>就会开始杀掉一些进程</strong>。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./test &amp;</span><br></pre></td></tr></table></figure><p>即便我们用&amp;让进程在后台运行，其也有可能收到会话的<code>创建/关闭</code>的影响而被操作系统干掉🧐比如我们将<strong>当前正在运行进程的bash关掉</strong>，其前台进程会被直接终止，后台进程也会受到影响（有可能终止有可能不终止，取决于系统）</p><p>这和我们对tcp服务器的需求不一致：我们需要的是让tcp服务器的进程能一直稳定的在后台运行，<strong>让操作系统别去管它</strong>；除非系统内存满了，负载重到实在没有办法的时候，操作系统才能过来把他刀了。</p><p>为了不让守护进程受到进程会话的影响，我们就必须让其能够独立出来，<strong>自成一个进程组和一个新会话</strong></p><p>👆这种独立的进程，就可以被称为<code>守护进程/精灵进程</code></p><h1 id="2-实现"><a href="#2-实现" class="headerlink" title="2.实现"></a>2.实现</h1><h2 id="2-1-自己写"><a href="#2-1-自己写" class="headerlink" title="2.1 自己写"></a>2.1 自己写</h2><p>别以为写这个很难哦，实际特别简单！</p><h3 id="2-1-1-setsid"><a href="#2-1-1-setsid" class="headerlink" title="2.1.1 setsid"></a>2.1.1 setsid</h3><p>这里需要用到的setsid接口，其作用如名字一般，是设置当前进程的进程会话组</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="type">pid_t</span> <span class="title function_">setsid</span><span class="params">(<span class="type">void</span>)</span>;</span><br></pre></td></tr></table></figure><p>但是调用这个函数有一个要求：调用的进程不能是进程组的组长！</p><p>比如下图中，第一个test就是进程组的组长，它不能调用这个函数。会报错</p><p><img                       lazyload                     alt="image"                     data-src="https://img1.musnow.top/i/23/02/63e45da7770c3.png"                      alt="image-20230209104248061"                ></p><p>那要怎么让自己不成为进程组的组长呢？很简单，创建一个子进程就ok了！</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (fork() &gt; <span class="number">0</span>)</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);<span class="comment">//父进程直接退出</span></span><br></pre></td></tr></table></figure><h3 id="2-1-2-重定向到dev-x2F-null"><a href="#2-1-2-重定向到dev-x2F-null" class="headerlink" title="2.1.2 重定向到dev&#x2F;null"></a>2.1.2 重定向到dev&#x2F;null</h3><blockquote><p>如果你不知道什么是<code>/dev/null</code>，简而言之，这是一个linux下的数据垃圾桶。和windows的回收站会存放删除的资料不同，这个垃圾桶是个黑洞，丢进去的东西不会被存放，是直接丢弃的！</p></blockquote><p>守护进程需要把默认的<code>0.1.2</code>文件描述符都重定向到<code>dev/null</code>，是因为设置成独立的进程组和进程会话了之后，当前进程是没有和bash关联的。</p><p>此时，默认这个<code>0 1 2</code>所指向的bash是<strong>无效</strong>的！如果不重定向，使用cout打印的时候，就会引发异常（可以理解为往一个不存在的文件中写内容），服务器直接退出了，无法实现守护进程。</p><p>重定向了之后，所有的打印输出都会被丢到<code>/dev/null</code>这个文件垃圾桶中，也就不需要担心上述的问题。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ((fd = open(<span class="string">&quot;/dev/null&quot;</span>, O_RDWR)) != <span class="number">-1</span>) <span class="comment">// fd == 3</span></span><br><span class="line">&#123;</span><br><span class="line">    dup2(fd, STDIN_FILENO);</span><br><span class="line">    dup2(fd, STDOUT_FILENO);</span><br><span class="line">    dup2(fd, STDERR_FILENO);</span><br><span class="line">    <span class="comment">// 6. 关闭掉不需要的fd</span></span><br><span class="line">    <span class="comment">// 因为fd只是临时用于重定向，操作完毕了就可以关掉了</span></span><br><span class="line">    <span class="keyword">if</span>(fd &gt; STDERR_FILENO) </span><br><span class="line">        close(fd);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>你可能会疑惑，那日志信息也被丢到垃圾桶里面了，怎么办？</p><p>很简单，因为我们服务器的日志都统一使用了<code>log.hpp</code>里面的<code>logging</code>函数，所以只需要对<code>logging</code>函数的输出重定向到日志文件里面，就ok了！</p><h3 id="2-1-3-chdir（选做）"><a href="#2-1-3-chdir（选做）" class="headerlink" title="2.1.3 chdir（选做）"></a>2.1.3 chdir（选做）</h3><p>这个操作的目的是修改工作路径。作为服务器进程，很多日志信息是存放在<code>/etc/</code>目录而不是当前路径下的，为了安全，也应该使用<code>绝对路径</code>而不用相对路径，避免出现工作目录切换而导致的无法读写文件的问题</p><p>不过，如果使用绝对路径，即便我们不修改工作目录，也是能正常访问的；所以这个操作是选做的</p><h3 id="2-1-4-信号捕捉"><a href="#2-1-4-信号捕捉" class="headerlink" title="2.1.4 信号捕捉"></a>2.1.4 信号捕捉</h3><p>自己写这个函数有个好处，那就是我们可以在里面自定义捕捉一些信号，给这些信号 加上自己的自定义方法；</p><p>比如<code>SIGPIPE</code>就是管道的信号，当管道的读端关闭的时候，写端会被终止；此时写端就会收到这个信号。如果不对这个信号进行<code>SIG_IGN</code>忽略，我们的服务器会直接终止！</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">signal(SIGPIPE, SIG_IGN);</span><br></pre></td></tr></table></figure><p>除了这个信号，我们还可以对2号或者3号信号进行自定义捕捉，设定退出信号，让服务器能够<strong>安全退出</strong>（保存日志信息到磁盘，释放资源等；虽然进程退出之后操作系统会帮我们干这些事，但我们这么写能让项目更规范）</p><h3 id="2-1-5-完整代码"><a href="#2-1-5-完整代码" class="headerlink" title="2.1.5 完整代码"></a>2.1.5 完整代码</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span> <span class="comment">// O_RDWR 需要</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">daemonize</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> fd = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 1. 忽略SIGPIPE (管道读写，读端关闭，写端会收到信号终止)</span></span><br><span class="line">    signal(SIGPIPE, SIG_IGN);</span><br><span class="line">    <span class="comment">// 2. 更改进程的工作目录</span></span><br><span class="line">    <span class="comment">// chdir(); // 可以改，可以不改</span></span><br><span class="line">    <span class="comment">// 3. 让自己不要成为进程组组长</span></span><br><span class="line">    <span class="keyword">if</span> (fork() &gt; <span class="number">0</span>)</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="comment">// 4. 设置自己是一个独立的会话</span></span><br><span class="line">    setsid();</span><br><span class="line">    <span class="comment">// 5. 重定向0,1,2</span></span><br><span class="line">    <span class="keyword">if</span> ((fd = open(<span class="string">&quot;/dev/null&quot;</span>, O_RDWR)) != <span class="number">-1</span>) <span class="comment">// fd == 3</span></span><br><span class="line">    &#123;</span><br><span class="line">        dup2(fd, STDIN_FILENO);</span><br><span class="line">        dup2(fd, STDOUT_FILENO);</span><br><span class="line">        dup2(fd, STDERR_FILENO);</span><br><span class="line">        <span class="comment">// 6. 关闭掉不需要的fd</span></span><br><span class="line">        <span class="comment">// 因为fd只是临时用于重定向，操作完毕了就可以关掉了</span></span><br><span class="line">        <span class="keyword">if</span>(fd &gt; STDERR_FILENO) </span><br><span class="line">            close(fd);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 这里还有另外一种操作，就是把stdin/stdout/stderr给close了</span></span><br><span class="line">    <span class="comment">// 但是这样会导致只要有打印输出的代码，进程会就异常退出</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>没错，就这一点点代码，就能让我们的tcp服务器变成守护进程！</p><p><img                       lazyload                     alt="image"                     data-src="https://img1.musnow.top/i/23/02/63e487fbb466e.png"                      alt="image-20230209134324709"                ></p><p>此时我们的客户端依旧能正常连接服务端，获取结果</p><p><img                       lazyload                     alt="image"                     data-src="https://img1.musnow.top/i/23/02/63e48818b281f.png"                      alt="image-20230209134353714"                ></p><h2 id="2-2-nohup"><a href="#2-2-nohup" class="headerlink" title="2.2 nohup"></a>2.2 nohup</h2><p>no hang up（不挂起），用于在系统后台不挂断地运行命令，退出终端不会影响程序的运行。用nohup命令执行一个进程，<strong>就能让这个进程成为不受终端退出影响的进程</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nohup ./test &amp;</span><br></pre></td></tr></table></figure><p>此时，nohup会在当前目录下创建一个<code>nohup.out</code>文件，用于记录test进程的输出信息（如果通过了<code>&gt;</code>或<code>&gt;&gt;</code>执行了重定向，则不会创建）</p><p><img                       lazyload                     alt="image"                     data-src="https://img1.musnow.top/i/23/02/63e463b45c460.png"                      alt="image-20230209110836838"                ></p><p>通过ps可已看到，当前test进程的<strong>进程会话</strong>还是和bash相同，但我们关闭当前bash，这个test进程依旧能正常运行，只不过父进程会变成操作系统<code>1</code>，我们的目的也算是达到了</p><p><img                       lazyload                     alt="image"                     data-src="https://img1.musnow.top/i/23/02/63e46502f3387.png"                      alt="image-20230209111411664"                ></p><h2 id="2-3-deamon接口"><a href="#2-3-deamon接口" class="headerlink" title="2.3 deamon接口"></a>2.3 deamon接口</h2><p>linux系统中有一个接口<code>daemon</code>，可以帮我们实现守护进程</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">daemon</span><span class="params">(<span class="type">int</span> nochdir, <span class="type">int</span> noclose)</span>;</span><br></pre></td></tr></table></figure><p>了解过守护进程的写法了之后，这两个参数的作用就很明显了</p><ul><li>第一个参数nochdir表明是否需要修改工作目录；如果设置为0，则切换工作目录到<code>/</code>系统根目录</li><li>第二个参数noclose表明是否需要重定向基础io到<code>/dev/null</code>；设置为0则重定向</li></ul><p>以下是man手册中的说明</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">If nochdir is zero, daemon() changes the calling process&#x27;s current working directory to the root directory (&quot;/&quot;); otherwise, the  cur‐</span><br><span class="line">rent working directory is left unchanged.</span><br><span class="line"></span><br><span class="line">If noclose is zero, daemon() redirects standard input, standard output and standard error to /dev/null; otherwise, no changes are made</span><br><span class="line">to these file descriptors.</span><br></pre></td></tr></table></figure><p>我们直接用一个简单代码来演示</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//不需要修改工作目录，第一个参数设为1</span></span><br><span class="line">    <span class="comment">//因为没有进行打印，重定向设置成1，不进行重定向</span></span><br><span class="line">    <span class="type">int</span> ret = daemon(<span class="number">1</span>,<span class="number">1</span>);</span><br><span class="line">    sleep(<span class="number">100</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行之后可以看到，这个进程的父id是操作系统，其自成一个进程组和进程会话；和我们自己写的函数作用相同</p><p><img                       lazyload                     alt="image"                     data-src="https://img1.musnow.top/i/23/02/63e482494ff4d.png"                      alt="image-20230209131905946"                ></p><h1 id="3-重定向log"><a href="#3-重定向log" class="headerlink" title="3.重定向log"></a>3.重定向log</h1><p>因为守护进程把输入输出丢到了垃圾捅里面，所以我们就需要重定向日志的输出</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> LOG_PATH <span class="string">&quot;./log.txt&quot;</span> <span class="comment">//工作路径下的log.txt</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 这个类只用于重定向，不需要在里面加其他东西</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Logdup</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Logdup</span>()</span><br><span class="line">        :_fdout(<span class="number">-1</span>),_fderr(<span class="number">-1</span>)</span><br><span class="line">    &#123;&#125;</span><br><span class="line">    <span class="built_in">Logdup</span>(<span class="type">const</span> <span class="type">char</span>* pout=LOG_PATH,<span class="type">const</span> <span class="type">char</span>* perr=<span class="string">&quot;&quot;</span>)</span><br><span class="line">        :_fdout(<span class="number">-1</span>),_fderr(<span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//如果只传入了第一个pout，则代表将perr和pout重定向为一个路径</span></span><br><span class="line">        <span class="built_in">umask</span>(<span class="number">0</span>);</span><br><span class="line">        <span class="type">int</span> logfd = <span class="built_in">open</span>(pout, O_WRONLY | O_CREAT | O_APPEND, <span class="number">0666</span>);</span><br><span class="line">        <span class="built_in">assert</span>(logfd != <span class="number">-1</span>);</span><br><span class="line">        _fdout = _fderr = logfd;<span class="comment">//赋值可以连等</span></span><br><span class="line">        <span class="comment">//判断是不是空串</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">strcmp</span>(perr,<span class="string">&quot;&quot;</span>)!=<span class="number">0</span>)<span class="comment">//不相同，代表单独设置了err的路径</span></span><br><span class="line">        &#123;</span><br><span class="line">            logfd = <span class="built_in">open</span>(perr, O_WRONLY | O_CREAT | O_APPEND, <span class="number">0666</span>);</span><br><span class="line">            <span class="built_in">assert</span>(logfd != <span class="number">-1</span>);</span><br><span class="line">            _fderr = logfd;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">dup2</span>(_fdout, <span class="number">1</span>);<span class="comment">//重定向stdout</span></span><br><span class="line">        <span class="built_in">dup2</span>(_fderr, <span class="number">2</span>);<span class="comment">//重定向stderr</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">Logdup</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(_fdout!= <span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">fsync</span>(_fdout);</span><br><span class="line">            <span class="built_in">fsync</span>(_fderr);</span><br><span class="line">            <span class="comment">// 先写盘再关闭</span></span><br><span class="line">            <span class="built_in">close</span>(_fdout);</span><br><span class="line">            <span class="built_in">close</span>(_fderr);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> _fdout;<span class="comment">//重定向的日志文件描述符</span></span><br><span class="line">    <span class="type">int</span> _fderr;<span class="comment">//重定向的错误文件描述符</span></span><br><span class="line">&#125;;c</span><br></pre></td></tr></table></figure><p>做完这一切之后，我们运行服务器，的确创建了log.txt文件，可里面空空如也</p><p><img                       lazyload                     alt="image"                     data-src="https://img1.musnow.top/i/23/02/63e493ab4ff59.png"                      alt="image-20230209143230108"                ></p><p>这是因为我们的数据其实都被写道了缓冲区里面，我们需要在logging里面添加一个刷新机制，才能让数据尽快写入到硬盘中，避免日志丢失</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">fflush(out); <span class="comment">// 将C缓冲区中的数据刷新到OS</span></span><br><span class="line">fsync(fileno(out));<span class="comment">// 将OS中的数据写入硬盘</span></span><br></pre></td></tr></table></figure><p>此时再运行服务器，就能看到日志很快被写入文件里面了。</p><p><img                       lazyload                     alt="image"                     data-src="https://img1.musnow.top/i/23/02/63e4957c97194.png"                      alt="image-20230209144101425"                ></p><h1 id="over"><a href="#over" class="headerlink" title="over"></a>over</h1><p>搞定啦！</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;本文将以tcp服务器代码为基本，讲述如何将进程守护进程化，后台运行&lt;/p&gt;</summary>
    
    
    
    <category term="玩上Linux" scheme="https://blog.musnow.top/categories/%E7%8E%A9%E4%B8%8ALinux/"/>
    
    
    <category term="Linux" scheme="https://blog.musnow.top/tags/Linux/"/>
    
    <category term="网络" scheme="https://blog.musnow.top/tags/%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>【Linux】popen pclose接口介绍</title>
    <link href="https://blog.musnow.top/2023/02/09/note_Linux/31popen_pclose/"/>
    <id>https://blog.musnow.top/2023/02/09/note_Linux/31popen_pclose/</id>
    <published>2023-02-08T23:28:54.000Z</published>
    <updated>2023-02-11T02:23:02.198Z</updated>
    
    <content type="html"><![CDATA[<p>本篇文章简单讲述了c语言接口<code>popen/pclose</code>的用法</p><span id="more"></span><h1 id="1-函数作用"><a href="#1-函数作用" class="headerlink" title="1.函数作用"></a>1.函数作用</h1><p>函数定义如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">FILE *<span class="title function_">popen</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *command, <span class="type">const</span> <span class="type">char</span> *type)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">pclose</span><span class="params">(FILE *stream)</span>;</span><br></pre></td></tr></table></figure><h2 id="1-1-popen"><a href="#1-1-popen" class="headerlink" title="1.1 popen"></a>1.1 popen</h2><p>popen函数会创建一个管道，fork后调用shell来打开进程。由于管道的定义是单向的，第二个参数type只能指定读或写，不能同时指定读和写；</p><p>所得到的管道相应地是只读或只写的</p><pre><code>   The  popen()  function opens a process by creating a pipe, forking, and invoking the shell.  Since a pipe is by definition unidirectional, the type argument may specify only reading or writing, not both; the resulting stream is correspondingly read-only or write-only.</code></pre><p>简单说来，popen会自动帮我们fork创建子进程和一个管道，将我们传入的参数<code>command</code>在shell中执行后，将返回值以<strong>管道文件</strong>的形式发送给调用方。</p><p>如果调用<code>fork或pipe</code>失败，或者不能分配内存，将返回NULL；否则返回标准I&#x2F;O流。<code>popen()</code>没有为内存分配失败设置errno值。如果调用fork()或pipe()时出现错误，errno被设为相应的错误类型。如果type参数不合法，errno将返回<code>EINVAL</code></p><h2 id="1-2-pclose"><a href="#1-2-pclose" class="headerlink" title="1.2 pclose"></a>1.2 pclose</h2><blockquote><p>这个函数没有什么好说的，是用来关掉popen打开的文件的（即popen的返回值）</p></blockquote><p>但是，它的返回值可有说到了，其返回值就是我们终端操作的退出状态，以标识命令是否成功执行</p><p>但是这个返回是通过<code>wait4</code>得到的，如果<code>wait4</code>出现错误，就会返回-1并设置<code>errno</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">The pclose() function returns -1 if wait4(2) returns an error, or some other error is detected.  In the event of an error, these functions set errnro to indicate the cause of the error.</span><br></pre></td></tr></table></figure><p>这里还出现了一个新的错误码<code>errnro</code>，但是经过我的一番百度，没有发现任何地方有对errnro的说明，man手册下方又变成了errno</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">If pclose() cannot obtain the child status, errno is set to ECHILD.</span><br></pre></td></tr></table></figure><p>而且编译执行的时候，<code>errnro</code>是会报错的，所以姑且认为这里是man手册出错了！</p><p><img                       lazyload                     alt="image"                     data-src="https://img1.musnow.top/i/23/02/63e439f90e1c6.png"                      alt="image-20230209081025661"                ></p><p><code>errno</code>才是正确的</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> ret = pclose(f);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;pclose: %d | %s\n&quot;</span>,ret,strerror(errno));</span><br></pre></td></tr></table></figure><p><img                       lazyload                     alt="image"                     data-src="https://img1.musnow.top/i/23/02/63e43a0fdac19.png"                      alt="image-20230209081056203"                ></p><h1 id="2-代码示例"><a href="#2-代码示例" class="headerlink" title="2.代码示例"></a>2.代码示例</h1><h2 id="2-1-popen读"><a href="#2-1-popen读" class="headerlink" title="2.1 popen读"></a>2.1 popen读</h2><p>以下方最简单的ls命令为例，我们以读方式打开，popen就会将ls的执行结果写到文件里面返回给我们</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    FILE *f;</span><br><span class="line">    <span class="type">char</span> readBuf[<span class="number">1024</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line">    f = popen(<span class="string">&quot;ls&quot;</span>,<span class="string">&quot;r&quot;</span>);</span><br><span class="line">    fread(readBuf,<span class="number">1024</span>,<span class="number">1</span>,f);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>,readBuf);</span><br><span class="line">    pclose(f);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译后执行结果如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ ./test</span><br><span class="line">test</span><br><span class="line">test.cpp</span><br><span class="line">    </span><br></pre></td></tr></table></figure><h2 id="2-2-popen写"><a href="#2-2-popen写" class="headerlink" title="2.2 popen写"></a>2.2 popen写</h2><p>和读不同，如果用写方式执行popen，命令的输出结果会直接打印到屏幕上</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">test2</span><span class="params">(FILE* f)</span></span><br><span class="line">&#123;</span><br><span class="line">    f = popen(<span class="string">&quot;ls&quot;</span>,<span class="string">&quot;w&quot;</span>);</span><br><span class="line">    <span class="type">int</span> ret = pclose(f);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;pclose: %d | %s\n&quot;</span>,ret,strerror(errno));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">makefile  test  test.cpp</span><br><span class="line">pclose: 0 | Success</span><br></pre></td></tr></table></figure><p>这里我还以为后续可以接着往管道里面写数据，让他继续执行命令</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">test2</span><span class="params">(FILE* f)</span></span><br><span class="line">&#123;</span><br><span class="line">    f = popen(<span class="string">&quot;ls&quot;</span>,<span class="string">&quot;w&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 缓冲区中写入数据</span></span><br><span class="line">    <span class="built_in">strcpy</span>(readBuf,<span class="string">&quot;ls -l&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;cmd: %s\n&quot;</span>,readBuf);</span><br><span class="line">    <span class="comment">// 写道管道文件中</span></span><br><span class="line">    fwrite(readBuf,<span class="number">1024</span>,<span class="number">1</span>,f);</span><br><span class="line">    <span class="type">int</span> ret = pclose(f);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;pclose: %d | %s\n&quot;</span>,ret,strerror(errno));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可测试的结果告诉我，并不行</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cmd: ls -l</span><br><span class="line">makefile  test  test.cpp</span><br><span class="line">pclose: 0 | Success</span><br></pre></td></tr></table></figure><p>网上的资料大多数都是只演示了<strong>r</strong>方法，我不确定这里是不是我写的代码有问题，还是说本来就是这样的。暂且停留在这里吧！</p><h1 id="end"><a href="#end" class="headerlink" title="end"></a>end</h1><p>关于popen和pclose的简单介绍到这里就结束了，欢迎评论区交流</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;本篇文章简单讲述了c语言接口&lt;code&gt;popen/pclose&lt;/code&gt;的用法&lt;/p&gt;</summary>
    
    
    
    <category term="玩上Linux" scheme="https://blog.musnow.top/categories/%E7%8E%A9%E4%B8%8ALinux/"/>
    
    
    <category term="Linux" scheme="https://blog.musnow.top/tags/Linux/"/>
    
    <category term="C语言" scheme="https://blog.musnow.top/tags/C%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title>【C++】using的三种用法</title>
    <link href="https://blog.musnow.top/2023/02/08/note_cpp/27using%E7%9A%84%E4%B8%89%E7%A7%8D%E7%94%A8%E6%B3%95/"/>
    <id>https://blog.musnow.top/2023/02/08/note_cpp/27using%E7%9A%84%E4%B8%89%E7%A7%8D%E7%94%A8%E6%B3%95/</id>
    <published>2023-02-08T11:30:46.000Z</published>
    <updated>2023-02-08T11:40:58.093Z</updated>
    
    <content type="html"><![CDATA[<p>C++ using的三种用法，这个之前还没有接触过</p><span id="more"></span><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ClassOne</span> </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="type">int</span> w;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line"><span class="type">int</span> a;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ClassTwo</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="keyword">using</span> ModuleType = ClassOne;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> ClassType&gt;<span class="keyword">class</span> <span class="title class_">ClassThree</span> : <span class="keyword">private</span> ClassType</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">typename</span> ClassType::ModuleType;</span><br><span class="line">ModuleType m;</span><br><span class="line"><span class="built_in">ClassThree</span>() = <span class="keyword">default</span>;</span><br><span class="line"><span class="keyword">virtual</span> ~<span class="built_in">ClassThree</span>() = <span class="keyword">default</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">ClassThree&lt;ClassTwo&gt;::ModuleType a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上面代码中，一共有三处使用了<code>using</code>，分别是第3,16,22行，它们的作用为：</p><ul><li>引入命名空间</li><li>指定别名</li><li>在子类中引用基类的成员</li></ul><h2 id="引入命名空间"><a href="#引入命名空间" class="headerlink" title="引入命名空间"></a>引入<a class="link"   href="https://so.csdn.net/so/search?q=%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4&spm=1001.2101.3001.7020" >命名空间<i class="fas fa-external-link-alt"></i></a></h2><p>指定命名空间是C++ <code>using namespace</code>中最常被用到的地方，在第3行中的：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br></pre></td></tr></table></figure><h2 id="指定别名"><a href="#指定别名" class="headerlink" title="指定别名"></a>指定别名</h2><p><code>using</code>的另一个作用是指定别名，一般都是<code>using a = b;</code>这样的形式出现，比如在13行中：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> ModuleType = ClassOne;</span><br></pre></td></tr></table></figure><p><code>ModuleType</code> 是<code>ClassOne</code>的一个别名。<br><code>using</code>这个作用也比较常见，比如在vector.h中就有：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">_Ty</span>,<span class="keyword">class</span> <span class="title class_">_Alloc</span> = allocator&lt;_Ty&gt;&gt;<span class="keyword">class</span> vector: <span class="keyword">public</span> _Vector_alloc&lt;_Vec_base_types&lt;_Ty, _Alloc&gt;&gt;</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="keyword">using</span> value_type = _Ty;</span><br><span class="line"><span class="keyword">using</span> allocator_type = _Alloc;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>即<code>value_type</code> 是<code>_Ty</code>的一个别名，<code>value_type a;</code> 和<code>_Ty a;</code>是同样的效果。</p><blockquote><p>可以理解为C++中的<code>typedef</code></p></blockquote><h2 id="在子类中引用基类的成员"><a href="#在子类中引用基类的成员" class="headerlink" title="在子类中引用基类的成员"></a>在子类中引用<a class="link"   href="https://so.csdn.net/so/search?q=%E5%9F%BA%E7%B1%BB&spm=1001.2101.3001.7020" >基类<i class="fas fa-external-link-alt"></i></a>的成员</h2><p><code>using</code>的第三个作用是子类中引用基类的成员，一般都是<code>using CBase::a;</code>这样的形式出现，比如在22行中：</p><pre><code>using typename ClassType::ModuleType;</code></pre><p>它和一般形式有些区别，就是它加了个<code>typename</code> 修饰，这是因为类<code>ClassThree</code>本身是个模板类，它的基类<code>ClassType</code>是个模板，这个<code>typename</code> 和<code>using</code>其实没有什么关系。如果<code>ClassType</code>不是模板的话，这行代码就可以写成：</p><pre><code>using ClassType::ModuleType;</code></pre><p>剩下的就是using的作用，它引用了基类中的成员<code>ModuleType</code>， <code>ModuleType</code>又是类<code>ClassOne</code>的别名，所以后面<code>ModuleType m;</code>相当于定义对象m，对于子类成员m来说，这样的效果和下面是相同的：</p><pre><code>typename ClassType::ModuleType m;</code></pre><p>不同之处在于<code>using</code>还修改了基类成员的访问权限，子类<code>ClassThree</code> 私有继承<code>ClassType</code>，所以<code>ClassType</code>中共有成员<code>ModuleType</code> 在子类<code>ClassThree</code> 是私有的，它不能被外部访问。但是使用<code>using</code>后，在<code>main()</code>函数中可以使用。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">版权声明：本文为博主原创文章，遵循 [CC 4.0 BY-SA] 版权协议，转载请附上原文出处链接和本声明。</span><br><span class="line">本文链接：https://blog.csdn.net/chaipp0607/article/details/100128842</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;C++ using的三种用法，这个之前还没有接触过&lt;/p&gt;</summary>
    
    
    
    <category term="遇见C++" scheme="https://blog.musnow.top/categories/%E9%81%87%E8%A7%81C/"/>
    
    
    <category term="C++" scheme="https://blog.musnow.top/tags/C/"/>
    
    <category term="C++11" scheme="https://blog.musnow.top/tags/C-11/"/>
    
  </entry>
  
  <entry>
    <title>【Linux】来写一个tcp的服务端+客户端</title>
    <link href="https://blog.musnow.top/2023/02/05/note_Linux/29tcp%E4%BB%A3%E7%A0%81/"/>
    <id>https://blog.musnow.top/2023/02/05/note_Linux/29tcp%E4%BB%A3%E7%A0%81/</id>
    <published>2023-02-05T04:30:55.000Z</published>
    <updated>2023-02-09T06:09:01.681Z</updated>
    
    <content type="html"><![CDATA[<p>今天让我们来写一个tcp的服务器&#x2F;客户端代码</p><span id="more"></span><blockquote><p>完整代码见我的gitee <a class="link"   href="https://gitee.com/musnow/raspberry-practice/tree/master/code" >连接<i class="fas fa-external-link-alt"></i></a></p><p>阅读本文前，建议先阅读👉 <a href="https://blog.musnow.top/2023/02/01/note_linux/27udp%E4%BB%A3%E7%A0%81/">udp服务器</a></p></blockquote><h1 id="1-基本框架"><a href="#1-基本框架" class="headerlink" title="1.基本框架"></a>1.基本框架</h1><p>tcp的服务器和udp服务器初始化接口是非常相似的，区别就在于要选择<code>字节流</code>进行初始化</p><p>但是到运行状态就不同了</p><ul><li>tcp是需要连接的</li><li>udp不需要连接</li></ul><p>所以就会出现分歧：udp可以用sendto和receve来发送&#x2F;接收信息，服务端只需要监听特定端口收到了什么信息；</p><p>但tcp并不能这么做，在通信之前，tcp服务器必须要和客户端建立链接。</p><p>举个不恰当的例子，udp服务器好比一个水盆，等待水的注入；而tcp服务器是个水管，必须要两头连通了，才能开始注水</p><h2 id="1-1-类成员"><a href="#1-1-类成员" class="headerlink" title="1.1 类成员"></a>1.1 类成员</h2><p>类的成员变量和udp很相似，都是需要服务器的ip、端口、sockfd这些信息。为了更容易区分，将tcp服务器的<code>socket fd</code>改为<code>_listenSock</code>，意为监听端口</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">TcpServer</span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// 服务器端口号</span></span><br><span class="line">    <span class="type">uint16_t</span> _port;</span><br><span class="line">    <span class="comment">// 服务器ip地址</span></span><br><span class="line">    string _ip;</span><br><span class="line">    <span class="comment">// 服务器socket fd信息</span></span><br><span class="line">    <span class="type">int</span> _listenSock;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="1-2-头文件"><a href="#1-2-头文件" class="headerlink" title="1.2 头文件"></a>1.2 头文件</h2><p>这里对头文件进行一定的说明，因为服务器代码中的头文件实在太多了</p><p>当你需要使用一个接口的时候，可以去采用man手册来获取该接口的头文件信息</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="comment">// 头文件太多了，所以新起一个文件</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cassert&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ctype.h&gt;</span><span class="comment">//判断字符串大写小写接口需要的库</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;strings.h&gt;</span><span class="comment">// 忽略大小写比较strcasecmp</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span>  <span class="comment">//很多liunx系统接口都需要这个</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span> <span class="comment">// 网络</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netinet/in.h&gt;</span> <span class="comment">// 网络</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span> <span class="comment">// 网络</span></span></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SOCKET_ERR 1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BIND_ERR   2</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LISTEN_ERR 3</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> USAGE_ERR  4</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CONN_ERR   5</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BUFFER_SIZE 1024</span></span><br></pre></td></tr></table></figure><h1 id="2-初始化"><a href="#2-初始化" class="headerlink" title="2.初始化"></a>2.初始化</h1><p>接口的介绍就跟随实现一步一步来吧</p><h2 id="2-1-构造sock"><a href="#2-1-构造sock" class="headerlink" title="2.1 构造sock"></a>2.1 构造sock</h2><p>这里出现了tcp和udp第一个不同之处，tcp是面向字节流的，udp面向的是数据报</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">TcpServer</span>(<span class="type">uint16_t</span> port,<span class="type">const</span> string&amp; ip=<span class="string">&quot;&quot;</span>)</span><br><span class="line"> :_port(port), _ip(ip), _listenSock(<span class="number">-1</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 1.创建socket套接字,采用字节流（即tcp）</span></span><br><span class="line">    _listenSock = <span class="built_in">socket</span>(AF_INET, SOCK_STREAM, <span class="number">0</span>); <span class="comment">//本质是打开了一个文件</span></span><br><span class="line">    <span class="keyword">if</span> (_listenSock &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">logging</span>(FATAL, <span class="string">&quot;socket:%s:%d&quot;</span>, <span class="built_in">strerror</span>(errno), _listenSock);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">logging</span>(DEBUG, <span class="string">&quot;socket create success: %d&quot;</span>, _listenSock);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-2-初始化sockaddr-in"><a href="#2-2-初始化sockaddr-in" class="headerlink" title="2.2 初始化sockaddr_in"></a>2.2 初始化sockaddr_in</h2><p>继续，初始化sockaddr_in的操作和udp是完全一致的</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 2. 绑定网络信息，指明ip+port</span></span><br><span class="line"><span class="comment">// 2.1 先填充基本信息到 struct sockaddr_in</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> local;</span><br><span class="line"><span class="built_in">memset</span>(&amp;local,<span class="number">0</span>,<span class="built_in">sizeof</span>(local));<span class="comment">//初始化</span></span><br><span class="line"><span class="comment">// 协议家族，设置为ipv4</span></span><br><span class="line">local.sin_family = AF_INET; </span><br><span class="line"><span class="comment">// 端口，需要进行 本地-&gt;网络转换</span></span><br><span class="line">local.sin_port = <span class="built_in">htons</span>(_port);</span><br><span class="line"><span class="comment">// 配置ip</span></span><br><span class="line"><span class="comment">// 如果初始化时候的ip为空，则调用INADDR_ANY代表任意ip。否则对传入的ip进行转换后赋值</span></span><br><span class="line">local.sin_addr.s_addr = _ip.<span class="built_in">empty</span>() ? <span class="built_in">htonl</span>(INADDR_ANY) : <span class="built_in">inet_addr</span>(_ip.<span class="built_in">c_str</span>());</span><br></pre></td></tr></table></figure><h2 id="2-3-bind"><a href="#2-3-bind" class="headerlink" title="2.3 bind"></a>2.3 bind</h2><p>也是一样，绑定服务器的ip和端口</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 2.2 绑定ip端口</span></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">bind</span>(_listenSock,(<span class="type">const</span> <span class="keyword">struct</span> sockaddr *)&amp;local, <span class="built_in">sizeof</span>(local)) == <span class="number">-1</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">logging</span>(FATAL, <span class="string">&quot;bind: %s:%d&quot;</span>, <span class="built_in">strerror</span>(errno), _listenSock);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">logging</span>(DEBUG,<span class="string">&quot;socket bind success: %d&quot;</span>, _listenSock);</span><br></pre></td></tr></table></figure><h2 id="2-4-监听listen"><a href="#2-4-监听listen" class="headerlink" title="2.4 监听listen"></a>2.4 监听listen</h2><p>对于tcp服务器来说，成员变量的<code>_listenSock</code>是用来监听的，即找个老哥一直盯着云服务器的这个端口，看看有没有需要连接它的客户端</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span>          <span class="comment">/* See NOTES */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">listen</span><span class="params">(<span class="type">int</span> sockfd, <span class="type">int</span> backlog)</span>;</span><br></pre></td></tr></table></figure><p>其中第一个参数是我们的<code>_listenSock</code>，第二个参数是用于限制在阻塞等待连接的数量</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">The backlog argument defines the maximum length to which the queue of pending connections for sockfd may grow.   If  a connection  request arrives when the queue is full, the client may receive an error with an indication of ECONNREFUSED or, if the underlying protocol supports retransmission, the request may be ignored so that a later reattempt  at  con‐nection succeeds.</span><br></pre></td></tr></table></figure><p>翻译过来就是，<code>backlog</code>参数限制了能被阻塞等待连接的数量。如果超过这个数量，则会返回一个<code>ECONNREFUSED</code>错误。亦或者如果协议支持重传，多余的请求会被忽略，后续可以重传</p><p>man手册下面的notes还有更多解释</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">The behavior of the backlog argument on TCP sockets changed with Linux 2.2.  Now it specifies  the  queue  length  for completely  established  sockets waiting to be accepted, instead of the number of incomplete connection requests.  The maximum length of the queue for incomplete sockets can be set using /proc/sys/net/ipv4/tcp_max_syn_backlog.  When syn‐cookies are enabled there is no logical maximum length and this setting is ignored.  See tcp(7) for more information.</span><br><span class="line"></span><br><span class="line"> If  the  backlog  argument is greater than the value in /proc/sys/net/core/somaxconn, then it is silently truncated to that value; the default value in this file is 128.  In kernels before 2.4.25, this  limit  was  a  hard  coded  value,SOMAXCONN, with the value 128.</span><br></pre></td></tr></table></figure><p>如果<code>backlog</code>参数高于<code>/proc/sys/net/core/somaxconn</code>中的默认值128，则会被截断为128</p><hr><p>在我们这里，将其设置为5即可，反正也是做测试嘛，问题不大</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 3.监听</span></span><br><span class="line"><span class="comment">// tcp服务器是需要连接的，连接之前要先监听有没有人来连</span></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">listen</span>(_listenSock, <span class="number">5</span>) &lt; <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">logging</span>(FATAL, <span class="string">&quot;listen: %s&quot;</span>, <span class="built_in">strerror</span>(errno));</span><br><span class="line">    <span class="built_in">exit</span>(LISTEN_ERR);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">logging</span>(DEBUG, <span class="string">&quot;listen: %s, %d&quot;</span>, <span class="built_in">strerror</span>(errno), _listenSock);</span><br></pre></td></tr></table></figure><h1 id="3-运行"><a href="#3-运行" class="headerlink" title="3.运行"></a>3.运行</h1><p>初始化到这就完毕了，下面就是开跑了</p><h2 id="3-1-accept"><a href="#3-1-accept" class="headerlink" title="3.1 accept"></a>3.1 accept</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span>          <span class="comment">/* See NOTES */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">accept</span><span class="params">(<span class="type">int</span> sockfd, <span class="keyword">struct</span> sockaddr *addr, <span class="type">socklen_t</span> *addrlen)</span>;</span><br></pre></td></tr></table></figure><p>这个接口的作用就相当于tcp中的<code>recevefrom</code>，传参是完全相同的；与之不同的是，该函数的返回值是一个全新的<code>sockfd</code></p><ul><li>tcp需要和客户端建立链接</li><li>链接需要用socket fd 来管理</li><li>所以accept必须返回新的socket fd，让服务端有办法管理新的链接和已有链接</li><li>原有的socket fd不受影响</li><li>如果没有客户端来连接，进程会在accept内阻塞等待</li></ul><p>下为man手册中的描述</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">The  accept()  system  call  is  used  with connection-based socket types (SOCK_STREAM, SOCK_SEQPACKET).  It extracts the first connection request on the queue of pending connections for the listening socket, sockfd, creates a new connected  socket,  and  returns  a  new  file descriptor referring to that socket.  The newly created socket is not in the listening state.  The original socket sockfd is unaffected by this call.</span><br></pre></td></tr></table></figure><p>举个例子，tcp服务器自身的socket fd只会用来监听端口上有没有消息，当监听到有消息并通过<code>accept</code>建立连接后，就会让另外一位服务员来对这个连接提供服务。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> peer;</span><br><span class="line">    <span class="type">socklen_t</span> len = <span class="built_in">sizeof</span>(peer);</span><br><span class="line">    <span class="comment">// 获取连接</span></span><br><span class="line">    <span class="type">int</span> conet = <span class="built_in">accept</span>(_listenSock,(<span class="keyword">struct</span> sockaddr*)&amp;peer,&amp;len);</span><br><span class="line">    <span class="keyword">if</span>(conet&lt;<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">logging</span>(FATAL, <span class="string">&quot;accept: %s&quot;</span>, <span class="built_in">strerror</span>(errno));</span><br><span class="line">        <span class="built_in">exit</span>(CONN_ERR);<span class="comment">//连接错误</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//。。。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意这里len的参数是<code>socklen_t</code>，其本质上是一个无符号整形</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">__socklen_t</span> <span class="type">socklen_t</span>;</span><br><span class="line">__STD_TYPE __U32_TYPE <span class="type">__socklen_t</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __U32_TYPEunsigned int</span></span><br></pre></td></tr></table></figure><h2 id="3-2-获取连接信息"><a href="#3-2-获取连接信息" class="headerlink" title="3.2 获取连接信息"></a>3.2 获取连接信息</h2><p>这部分和udp是完全相同的，通过accept返回的socket fd，获取用户的ip和端口耨</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取连接信息</span></span><br><span class="line">string senderIP = <span class="built_in">inet_ntoa</span>(peer.sin_addr);<span class="comment">// 来源ip</span></span><br><span class="line"><span class="type">uint16_t</span> senderPort = <span class="built_in">ntohs</span>(peer.sin_port); <span class="comment">// 来源端口</span></span><br><span class="line"><span class="built_in">logging</span>(DEBUG, <span class="string">&quot;accept: %s | %s[%d], socket fd: %d&quot;</span>, <span class="built_in">strerror</span>(errno), senderIP.<span class="built_in">c_str</span>(), senderPort, conet);</span><br></pre></td></tr></table></figure><p>其实到这里，我们就可以运行服务器进行测试了。因为tcp的特性，我们不需要写客户端，直接用浏览器就能连上服务端</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc,<span class="type">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//参数只有两个（端口/ip）所以参数个数应该是2-3</span></span><br><span class="line">    <span class="keyword">if</span>(argc!=<span class="number">2</span> &amp;&amp; argc!=<span class="number">3</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Usage: &quot;</span> &lt;&lt; argv[<span class="number">0</span>] &lt;&lt; <span class="string">&quot; port [ip]&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    string ip;</span><br><span class="line">    <span class="comment">// 3个参数，有ip</span></span><br><span class="line">    <span class="keyword">if</span>(argc==<span class="number">3</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        ip = argv[<span class="number">2</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">TcpServer <span class="title">t</span><span class="params">(atoi(argv[<span class="number">1</span>]),ip)</span></span>;</span><br><span class="line">    t.<span class="built_in">start</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>先编译后执行代码，让tcp服务器运行起来</p><p><img                       lazyload                     alt="image"                     data-src="https://img1.musnow.top/i/23/02/63e198bcc215e.png"                      alt="image-20230207081805916"                ></p><p>随后在浏览器的地址栏输入<code>公网ip:端口</code>（先要开启防火墙内的端口）</p><p><img                       lazyload                     alt="image"                     data-src="https://img1.musnow.top/i/23/02/63e198b144512.png"                      alt="image-20230207081754768"                ></p><p>此时会发现什么都加载不出来，这是对的，因为我们并没有写前端，也没有提供任何服务。但是来到后台，可以看到出现了一个新的连接，并显示出了ip+端口</p><p><img                       lazyload                     alt="image"                     data-src="https://img1.musnow.top/i/23/02/63e19990d9e97.png"                      alt="image-20230207082138291"                ></p><h2 id="3-3-提供服务（线程）"><a href="#3-3-提供服务（线程）" class="headerlink" title="3.3 提供服务（线程）"></a>3.3 提供服务（线程）</h2><p>接下来要做的，就是写一个简单的服务了，这里我写的是字符串转ASCII码，会将发出去的字符串的ascii码加加起来后返回</p><h3 id="3-3-1-问题1-如何通信"><a href="#3-3-1-问题1-如何通信" class="headerlink" title="3.3.1 问题1 如何通信"></a>3.3.1 问题1 如何通信</h3><p>此时问题就来了，tcp服务器不能使用recevefrom和sendto，那么获取到socket之后要怎么进行通信呢？</p><p>答案是：<strong>用linux的文件读写接口</strong>，read和write。别忘了，socket fd本质上就是一个linux下的文件描述符！</p><h3 id="3-3-2-问题2-多客户端"><a href="#3-3-2-问题2-多客户端" class="headerlink" title="3.3.2 问题2 多客户端"></a>3.3.2 问题2 多客户端</h3><p>tcp服务器要想给多个客户端提供服务，就必须采用多线程&#x2F;多进程的方式来实现操作。否则会出现一个严重的问题，服务端因为提供服务而没有<code>accept</code>，无法链接上下一个客户端</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//accept 获取到链接上的客户端</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">         <span class="comment">//如果在这里提供服务，则会其他连接会在listen里面阻塞</span></span><br><span class="line">    <span class="comment">//只有当前服务终止了，其他客户端的其中之一才能连上服务器</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-3-3-问题3-线程传参"><a href="#3-3-3-问题3-线程传参" class="headerlink" title="3.3.3 问题3 线程传参"></a>3.3.3 问题3 线程传参</h3><p>既然需要采用多线程服务，那就需要设定好给线程传的参数。理论上来说，我们只需要传入accept的返回值<code>socket fd</code>即可进行<code>read/write</code></p><p>但实际上，我们还需要打印debug消息，要知道当前是谁向你发送了这条消息，ip和端口是什么。</p><p>为了方便操作，这里封装一个结构体，将socket fd，客户端的ip+端口封装成一个参数进行传参（<strong>线程的函数只能传入一个参数</strong>）</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ClientData</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">int</span> _fd;</span><br><span class="line">    <span class="type">uint16_t</span> _port;</span><br><span class="line">    <span class="built_in">string</span> _ip;</span><br><span class="line">    TcpServer* _this;</span><br><span class="line"></span><br><span class="line">    ClientData(<span class="type">int</span> fd,<span class="type">uint16_t</span> port,<span class="type">const</span> <span class="built_in">string</span>&amp; ip,TcpServer* this1)</span><br><span class="line">        :_fd(fd),_port(port), _ip(ip),_this(this1)</span><br><span class="line">    &#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>你可能会想到另外一个办法，那就是在tcp服务器的class中新增一个map成员变量，用于映射socket fd和客户端信息的键值对，但是这无法实现。</p><p>因为在类中设计的多线程函数，为了去掉默认传入的<code>this</code>指针，必须要设置成<code>static</code>静态的，此时该静态函数<strong>无法访问</strong>类内成员！</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 因为需要取消this指针，所以需要设置成静态的</span></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span>* <span class="title">threadRoutine</span><span class="params">(<span class="type">void</span>*args)</span></span></span><br><span class="line"><span class="function"></span>&#123;   </span><br><span class="line">    <span class="built_in">pthread_detach</span>(<span class="built_in">pthread_self</span>()); <span class="comment">//设置线程分离</span></span><br><span class="line">    ClientData* data=(ClientData*)args;</span><br><span class="line">    <span class="comment">// 通过预先设置的this指针来访问类内成员，并进行传参</span></span><br><span class="line">    data-&gt;_this-&gt;<span class="built_in">transService</span>(data-&gt;_fd,data-&gt;_ip,data-&gt;_port);</span><br><span class="line">    <span class="keyword">delete</span> data;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-3-4-服务代码"><a href="#3-3-4-服务代码" class="headerlink" title="3.3.4 服务代码"></a>3.3.4 服务代码</h3><p>解决了上面的问题，就可以继续往下看看服务端的代码了</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 提供服务</span></span><br><span class="line"><span class="type">pthread_t</span> service;</span><br><span class="line"><span class="comment">// 因为这个成员使用范围极小，所以采用new/delete，避免占用太多空间</span></span><br><span class="line">ClientData* data = <span class="keyword">new</span> <span class="built_in">ClientData</span>(conet,senderPort,senderIP,<span class="keyword">this</span>);</span><br><span class="line"><span class="built_in">pthread_create</span>(&amp;service,<span class="literal">nullptr</span>,threadRoutine,(<span class="type">void</span>*)data);</span><br></pre></td></tr></table></figure><p>在accept之后，通过线程操作用线程来提供服务</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span>* <span class="title">threadRoutine</span><span class="params">(<span class="type">void</span>*args)</span></span></span><br><span class="line"><span class="function"></span>&#123;   </span><br><span class="line">    <span class="built_in">pthread_detach</span>(<span class="built_in">pthread_self</span>()); <span class="comment">//设置线程分离</span></span><br><span class="line">    ClientData* data=(ClientData*)args;</span><br><span class="line">    <span class="comment">// 通过预先设置的this指针来访问类内成员，并进行传参</span></span><br><span class="line">    data-&gt;_this-&gt;<span class="built_in">transService</span>(data-&gt;_fd,data-&gt;_ip,data-&gt;_port);</span><br><span class="line">    <span class="keyword">delete</span> data;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>threadRoutine</code>的作用就是把线程的单参数转为多参数，传给真正用来服务的函数。函数的操作很简单，就是Linux下文件操作的读写。</p><p>读写成功后，将客户端发来的信息转成ASCII码的和发回给客户端</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">transService</span><span class="params">(<span class="type">int</span> sockfd, <span class="type">const</span> string &amp;clientIp, <span class="type">uint16_t</span> clientPort)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">assert</span>(sockfd &gt;= <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">assert</span>(!clientIp.<span class="built_in">empty</span>());</span><br><span class="line">    <span class="built_in">assert</span>(clientPort&gt;<span class="number">0</span>);</span><br><span class="line">    <span class="comment">// 开始服务</span></span><br><span class="line">    <span class="type">char</span> buf[BUFFER_SIZE];</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 读取客户端发来的信息,s是读取到的字节数</span></span><br><span class="line">        <span class="type">ssize_t</span> s = <span class="built_in">read</span>(sockfd, buf, <span class="built_in">sizeof</span>(buf)<span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">if</span>(s&gt;<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            buf[s]=<span class="string">&#x27;\0&#x27;</span>;<span class="comment">//手动添加字符串终止符</span></span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">strcasecmp</span>(buf,<span class="string">&quot;quit&quot;</span>)==<span class="number">0</span>)</span><br><span class="line">            &#123;<span class="comment">//客户端主动退出</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 服务</span></span><br><span class="line">            string tmp = buf;</span><br><span class="line">            <span class="type">int</span> ret = <span class="built_in">str2ascii</span>(tmp);<span class="comment">//获取字符串的ascii总和</span></span><br><span class="line">            cout &lt;&lt; ret &lt;&lt; endl;</span><br><span class="line">            string retS =  <span class="built_in">to_string</span>(ret);<span class="comment">//转字符串</span></span><br><span class="line">            cout &lt;&lt; retS &lt;&lt; endl;</span><br><span class="line">            <span class="built_in">write</span>(sockfd,retS.<span class="built_in">c_str</span>(),retS.<span class="built_in">size</span>());<span class="comment">//写入</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (s == <span class="number">0</span>)</span><br><span class="line">        &#123;<span class="comment">//s == 0代表对方关闭,客户端退出</span></span><br><span class="line">            <span class="built_in">logging</span>(DEBUG, <span class="string">&quot;client quit: %s[%d]&quot;</span>, clientIp.<span class="built_in">c_str</span>(), clientPort);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">logging</span>(DEBUG, <span class="string">&quot;read err: %s[%d] -  %s&quot;</span>, clientIp.<span class="built_in">c_str</span>(), clientPort, <span class="built_in">strerror</span>(errno));</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">close</span>(sockfd);</span><br><span class="line">    <span class="built_in">logging</span>(DEBUG,<span class="string">&quot;server quit %d&quot;</span>,sockfd);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// 服务函数可以不暴露</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">str2ascii</span><span class="params">(<span class="type">const</span> string&amp; str)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="type">int</span> ret = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> e:str)</span><br><span class="line">        &#123;</span><br><span class="line">            ret += e;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="3-4-提供服务（子进程）"><a href="#3-4-提供服务（子进程）" class="headerlink" title="3.4 提供服务（子进程）"></a>3.4 提供服务（子进程）</h2><p>上面的代码采用的是线程来提供服务，除了线程，我们还有父子进程的方式，也能避免阻塞</p><p>需要注意的是，父子进程都需要关闭掉对方使用的文件描述符，避免出现文件描述符在服务结束后还没有关闭的情况</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">pid_t</span> id = fork();</span><br><span class="line"><span class="keyword">if</span>(id == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">close</span>(_listenSock);<span class="comment">//因为子进程不需要监听，所以关闭掉监听socket</span></span><br><span class="line">    <span class="comment">//子进程</span></span><br><span class="line">    <span class="built_in">transService</span>(conet, senderIP, senderPort);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);<span class="comment">// 服务结束后，退出，子进程会进入僵尸状态等待父进程回收</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 父进程</span></span><br><span class="line"><span class="built_in">close</span>(conet); <span class="comment">// 因为此时是子进程提供服务，conet会有拷贝，相当于有两个进程打开了该文件</span></span><br><span class="line"><span class="comment">// 如果父进程不关闭，即便子进程结束服务了，该文件描述符也会保持开启</span></span><br><span class="line"><span class="type">pid_t</span> ret = <span class="built_in">waitpid</span>(id, <span class="literal">nullptr</span>, <span class="number">0</span>);</span><br></pre></td></tr></table></figure><p>直接这样写有一个很大的问题，那就是父进程没有办法正常释放子进程的资源</p><ul><li>如果进行阻塞等待，那就违背了初衷，完全没有意义</li><li>如果进行非阻塞等待，在<code>waitpid</code>结束之后，父进程直接去干其他事了，完全忘记了这里的这个子进程</li></ul><p>所以我们要做的，就是在子进程退出，向<strong>父进程发送信号</strong>的时候回收子进程</p><h3 id="3-4-1-信号回收"><a href="#3-4-1-信号回收" class="headerlink" title="3.4.1 信号回收"></a>3.4.1 信号回收</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">signal(SIGCHLD, FreeChild);<span class="comment">//自定义捕捉</span></span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 回收子进程</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">FreeChild</span><span class="params">(<span class="type">int</span> signo)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">assert</span>(signo == SIGCHLD);</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//如果没有子进程了，waitpid就会调用失败</span></span><br><span class="line">        <span class="type">pid_t</span> id = <span class="built_in">waitpid</span>(<span class="number">-1</span>, <span class="literal">nullptr</span>, WNOHANG); <span class="comment">// 非阻塞等待</span></span><br><span class="line">        <span class="keyword">if</span> (id &gt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;父进程等待成功, child pid: &quot;</span> &lt;&lt; id &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(id == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//还有子进程没有退出</span></span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;尚有未退出的子进程，父进程继续运行&quot;</span> &lt;&lt; endl;</span><br><span class="line">            <span class="keyword">break</span>;<span class="comment">//退出等待子进程</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;父进程等待所有子进程结束&quot;</span> &lt;&lt; endl;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>除了自定义捕捉，我们还可以设置成ignore不搭理子进程，这样子进程退出的时候就会被系统自动释放</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">signal(SIGCHLD, SIG_IGN);</span><br></pre></td></tr></table></figure><h3 id="3-4-2-爷爷进程"><a href="#3-4-2-爷爷进程" class="headerlink" title="3.4.2 爷爷进程"></a>3.4.2 爷爷进程</h3><p>这里还有另外一个骚操作，那就是在创建子进程之后，再创建一个子进程</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 提供服务（孙子进程）-2</span></span><br><span class="line"><span class="type">pid_t</span> id = fork();</span><br><span class="line"><span class="keyword">if</span>(id == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">close</span>(_listenSock);<span class="comment">//因为子进程不需要监听，所以关闭掉监听socket</span></span><br><span class="line">    <span class="comment">//又创建一个子进程，大于0代表是父进程，即创建完子进程后父进程直接退出</span></span><br><span class="line">    <span class="keyword">if</span>(fork()&gt;<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 孙子进程执行</span></span><br><span class="line">    <span class="built_in">transService</span>(conet, senderIP, senderPort);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);<span class="comment">// 服务结束后，退出，子进程会进入僵尸状态等待父进程回收</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 爷爷进程</span></span><br><span class="line"><span class="built_in">close</span>(conet); </span><br><span class="line"><span class="type">pid_t</span> ret = <span class="built_in">waitpid</span>(id, <span class="literal">nullptr</span>, <span class="number">0</span>); <span class="comment">//此时就可以直接用阻塞式等待了</span></span><br><span class="line"><span class="built_in">assert</span>(ret &gt; <span class="number">0</span>);<span class="comment">//ret如果不大于0，则代表等待发生了错误</span></span><br></pre></td></tr></table></figure><p>采用这种办法以后，由于父进程退出了，<strong>孙子进程会直接被操作系统接管</strong>。下图中能看到这些进程的父进程都是<strong>1</strong>，即操作系统。这时候我们也不需要担心子进程的释放问题了</p><p><img                       lazyload                     alt="image"                     data-src="https://img1.musnow.top/i/23/02/63e1c184403cd.png"                      alt="image-20230207111205871"                ></p><h1 id="4-客户端"><a href="#4-客户端" class="headerlink" title="4.客户端"></a>4.客户端</h1><p>客户端部分的代码和udp也很相似，只不过将sendto改成了write</p><p>下方提供了客户端的代码，都写了注释😁</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;utils.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// ./clientTcp serverIp serverPort</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (argc != <span class="number">3</span>)<span class="comment">//客户端必须要有3个参数</span></span><br><span class="line">    &#123;</span><br><span class="line">        cerr &lt;&lt; <span class="string">&quot;Usage:\n\t&quot;</span> &lt;&lt; argv[<span class="number">0</span>] &lt;&lt; <span class="string">&quot; serverIp serverPort&quot;</span> &lt;&lt; endl;</span><br><span class="line">        cerr &lt;&lt; <span class="string">&quot;Example:\n\t&quot;</span> &lt;&lt; argv[<span class="number">0</span>] &lt;&lt; <span class="string">&quot; 127.0.0.1 8080\n&quot;</span></span><br><span class="line">                &lt;&lt; endl;</span><br><span class="line">        <span class="built_in">exit</span>(USAGE_ERR);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 解析服务端的ip和端口</span></span><br><span class="line">    string serverIp = argv[<span class="number">1</span>];</span><br><span class="line">    <span class="type">uint16_t</span> serverPort = <span class="built_in">atoi</span>(argv[<span class="number">2</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1. 创建tcp的socket SOCK_STREAM</span></span><br><span class="line">    <span class="type">int</span> sock = <span class="built_in">socket</span>(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (sock &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        cerr &lt;&lt; <span class="string">&quot;socket: &quot;</span> &lt;&lt; <span class="built_in">strerror</span>(errno) &lt;&lt; endl;</span><br><span class="line">        <span class="built_in">exit</span>(SOCKET_ERR);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. connect，发起链接请求，你想谁发起请求呢？？当然是向服务器发起请求喽</span></span><br><span class="line">    <span class="comment">// 2.1 先填充需要连接的远端主机的基本信息</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> server;</span><br><span class="line">    <span class="built_in">memset</span>(&amp;server, <span class="number">0</span>, <span class="built_in">sizeof</span>(server));</span><br><span class="line">    server.sin_family = AF_INET;</span><br><span class="line">    server.sin_port = <span class="built_in">htons</span>(serverPort);</span><br><span class="line">    <span class="built_in">inet_aton</span>(serverIp.<span class="built_in">c_str</span>(), &amp;server.sin_addr);</span><br><span class="line">    <span class="comment">// 2.2 发起请求，connect 会自动bind</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">connect</span>(sock, (<span class="type">const</span> <span class="keyword">struct</span> sockaddr *)&amp;server, <span class="built_in">sizeof</span>(server)) != <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        cerr &lt;&lt; <span class="string">&quot;connect: &quot;</span> &lt;&lt; <span class="built_in">strerror</span>(errno) &lt;&lt; endl;</span><br><span class="line">        <span class="built_in">exit</span>(CONN_ERR);</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;connect success: &quot;</span> &lt;&lt; sock &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 客户端发现的消息</span></span><br><span class="line">    string message;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        message.<span class="built_in">clear</span>();<span class="comment">//每次循环开始，都清空一下msg</span></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;请输入你的消息# &quot;</span>;</span><br><span class="line">        <span class="built_in">getline</span>(cin, message);<span class="comment">//获取输入</span></span><br><span class="line">        <span class="comment">// 如果客户端输入了quit，则退出</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">strcasecmp</span>(message.<span class="built_in">c_str</span>(), <span class="string">&quot;quit&quot;</span>) == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="comment">// 向服务端发送消息</span></span><br><span class="line">        <span class="type">ssize_t</span> s = <span class="built_in">write</span>(sock, message.<span class="built_in">c_str</span>(), message.<span class="built_in">size</span>());</span><br><span class="line">        <span class="keyword">if</span> (s &gt; <span class="number">0</span>) <span class="comment">// 写入成功</span></span><br><span class="line">        &#123;</span><br><span class="line">            message.<span class="built_in">clear</span>();<span class="comment">//清空输入的消息</span></span><br><span class="line">            message.<span class="built_in">resize</span>(BUFFER_SIZE);</span><br><span class="line">            <span class="comment">// 因为string的c_str本质上是返回地址，所以强转后是可以往里面写入的</span></span><br><span class="line">            s = <span class="built_in">read</span>(sock, (<span class="type">char</span> *)(message.<span class="built_in">c_str</span>()), BUFFER_SIZE);<span class="comment">// 获取服务端的结果</span></span><br><span class="line">            <span class="keyword">if</span> (s &gt; <span class="number">0</span>)<span class="comment">// 读取成功</span></span><br><span class="line">            &#123;</span><br><span class="line">                message[s] = <span class="string">&#x27;\0&#x27;</span>;<span class="comment">//追加\0</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 打印返回值</span></span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;Server Echo# &quot;</span> &lt;&lt; message &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (s &lt;= <span class="number">0</span>) <span class="comment">// 写入失败</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 关闭文件描述符</span></span><br><span class="line">    <span class="built_in">close</span>(sock);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-1-运行测试"><a href="#4-1-运行测试" class="headerlink" title="4.1 运行测试"></a>4.1 运行测试</h2><p>先运行服务端，再运行客户端，客户端输入后，服务短会返回字符串的ascii码总和</p><p><img                       lazyload                     alt="image"                     data-src="https://img1.musnow.top/i/23/02/63e1aff8cb944.png"                      alt="image-20230207095713615"                ></p><p>而客户端输入quit后，在服务端可以看到客户端退出，但服务端并没有推出，正在等待下一个连接</p><p><img                       lazyload                     alt="image"                     data-src="https://img1.musnow.top/i/23/02/63e1b0576b69f.png"                      alt="image-20230207095848863"                ></p><h1 id="5-线程池"><a href="#5-线程池" class="headerlink" title="5.线程池"></a>5.线程池</h1><p>在上面的操作中，每次提供服务都需要当场新建一个线程。对于tcp这种要求高性能的网络服务器而言，其实是不太合适的。理论上来说，我们希望越早给客户建立联系越好，而不是食客都来了老板才去买菜。</p><p>这时候，就可以把我们写的<a href="https://blog.musnow.top/2023/01/19/note_linux/22%E7%BA%BF%E7%A8%8B%E6%B1%A0/">线程池</a>和tcp服务器给联系起来！</p><blockquote><p>线程池的代码见我的<a class="link"   href="https://gitee.com/musnow/raspberry-practice/tree/master/code/" >gitee<i class="fas fa-external-link-alt"></i></a>，此处只说明task类的编写</p></blockquote><h2 id="5-1-task"><a href="#5-1-task" class="headerlink" title="5.1 task"></a>5.1 task</h2><p>先前编写线程池的时候，将线程池要处理的任务写成了一个task类，并规定所有task类都需要提供一个<code>()操作符重载</code>，即仿函数。这样线程池就可以一视同仁的处理这些工作，我们只需要将新增的工作添加到线程池的任务队列里面</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Task</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">using</span> <span class="type">callback_t</span> = std::function&lt;<span class="built_in">void</span> (<span class="type">int</span>, std::string, <span class="type">uint16_t</span>)&gt;;<span class="comment">//相当于typedef</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Task</span>() = <span class="keyword">default</span>;</span><br><span class="line">    <span class="comment">// 将需要调用的函数传入，相当于通用</span></span><br><span class="line">    <span class="built_in">Task</span>(<span class="type">int</span> sockfd, <span class="type">const</span> std::string &amp;clientIP, <span class="type">uint16_t</span> clientPort,<span class="type">callback_t</span> func)</span><br><span class="line">        : _sockfd(sockfd), _ip(clientIP), _port(clientPort),_func(func)</span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 仿函数</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">logging</span>(DEBUG, <span class="string">&quot;TID[%p] = %s:%d START&quot;</span>,\</span><br><span class="line">            <span class="built_in">pthread_self</span>(), _ip.<span class="built_in">c_str</span>(), _port);</span><br><span class="line"></span><br><span class="line">        _func(_sockfd, _ip, _port);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">logging</span>(DEBUG, <span class="string">&quot;TID[%p] = %s:%d END  &quot;</span>,\</span><br><span class="line">            <span class="built_in">pthread_self</span>(), _ip.<span class="built_in">c_str</span>(), _port);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> _sockfd;</span><br><span class="line">    std::string _ip;</span><br><span class="line">    <span class="type">uint16_t</span> _port;</span><br><span class="line">    <span class="type">callback_t</span> _func;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这里，我又将task队列给封装成了一个可以接收函数指针的方式。这样一来，只要我们任务的函数参数为<code>(SOCKET,IP,PROT)</code>，就能传入给这个task类，让线程池来运行</p><h2 id="5-2-tcpServer的处理"><a href="#5-2-tcpServer的处理" class="headerlink" title="5.2 tcpServer的处理"></a>5.2 tcpServer的处理</h2><p>因为需要线程池，我们在tcpserver中添加一个线程池的指针，通过线程池的类名来获取单例，赋值给成员变量。并让获取到的单例线程池开始运行</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 4.获取线程池 单例</span></span><br><span class="line">_tpool = ThreadPool&lt;Task&gt;::<span class="built_in">getInstance</span>(<span class="number">4</span>);</span><br><span class="line">_tpool-&gt;<span class="built_in">start</span>();<span class="comment">//开始运行</span></span><br></pre></td></tr></table></figure><p>在<code>start</code>函数中，则将之前的任务函数实例化为一个task，并将其push到线程池的任务队列中</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 提供服务（通过线程池）</span></span><br><span class="line"><span class="function">Task <span class="title">t</span><span class="params">(conet,senderIP,senderPort,transService)</span></span>;</span><br><span class="line">_tpool-&gt;<span class="built_in">push</span>(t);</span><br></pre></td></tr></table></figure><p>这样，就能通过线程池来提供服务了！</p><h2 id="5-3-运行测试"><a href="#5-3-运行测试" class="headerlink" title="5.3 运行测试"></a>5.3 运行测试</h2><p>可以看到，我们的线程池正确运行了任务，给客户端提供了ascii返回值</p><p><img                       lazyload                     alt="image"                     data-src="https://img1.musnow.top/i/23/02/63e44fa8f139b.png"                      alt="image-20230209094304860"                ></p><p>使用<code>ps -aL</code>命令查看轻量级进程，可以看到有4个线程在为我们服务</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"> PID   LWP TTY          TIME CMD</span><br><span class="line">7288  7288 pts/8    00:00:00 tcpServer</span><br><span class="line">7288  7289 pts/8    00:00:00 handler</span><br><span class="line">7288  7290 pts/8    00:00:00 handler</span><br><span class="line">7288  7291 pts/8    00:00:00 handler</span><br><span class="line">7288  7292 pts/8    00:00:00 handler</span><br><span class="line">7441  7441 pts/9    00:00:00 tcpClient</span><br><span class="line">7632  7632 pts/7    00:00:00 ps</span><br></pre></td></tr></table></figure><p>此时，即便我们多开几个终端，tcp服务器也能正常提供服务</p><p><img                       lazyload                     alt="image"                     data-src="https://img1.musnow.top/i/23/02/63e4507c8c76f.png"                      alt="image-20230209094632613"                ></p><p>但是！如果出现了一个尴尬的情况，线程池中的线程&lt;当前需要连接的客户端数量，会发生什么呢？</p><h2 id="5-4-task等待问题"><a href="#5-4-task等待问题" class="headerlink" title="5.4 task等待问题"></a>5.4 task等待问题</h2><p>为了测试，我们将线程池单例中的线程个数初始化为2个</p><p><img                       lazyload                     alt="image"                     data-src="https://img1.musnow.top/i/23/02/63e450bd253f3.png"                      alt="image-20230209094741651"                ></p><p>此时，我们发现第三个客户端会进入阻塞状态，但实际上它已经成功链接上了服务器，task也被插入到了任务队列里面，<strong>只不过当前没有空闲的线程来运行它</strong></p><p><img                       lazyload                     alt="image"                     data-src="https://img1.musnow.top/i/23/02/63e451f2d5c8f.png"                      alt="image-20230209095249694"                ></p><p>如果我们把左侧其中一个客户端退出，最右侧的客户端就能正常收到服务器返回的结果了</p><p><img                       lazyload                     alt="image"                     data-src="https://img1.musnow.top/i/23/02/63e452570e754.png"                      alt="image-20230209095429982"                ></p><p>要解决这个问题，我们就需要让线程池有能力判断是否出现了阻塞问题，并扩容线程来解决阻塞。</p><p>可是这又引出了另外一个问题：如果空闲了很久都没有任务过来，多出来的线程不就是在白白消耗资源吗？</p><p>实际上，线程池适合处理的，应该是<strong>短小的任务</strong>，而不是一个<code>while(1)</code>循环；</p><blockquote><p>但是我还没有学习到如何将其修改为服务于短小任务的线程池，仍待后续的精进</p></blockquote>]]></content>
    
    
    <summary type="html">&lt;p&gt;今天让我们来写一个tcp的服务器&amp;#x2F;客户端代码&lt;/p&gt;</summary>
    
    
    
    <category term="玩上Linux" scheme="https://blog.musnow.top/categories/%E7%8E%A9%E4%B8%8ALinux/"/>
    
    
    <category term="Linux" scheme="https://blog.musnow.top/tags/Linux/"/>
    
    <category term="线程" scheme="https://blog.musnow.top/tags/%E7%BA%BF%E7%A8%8B/"/>
    
    <category term="网络" scheme="https://blog.musnow.top/tags/%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>【Python】自动解析markdown中的图片并保存</title>
    <link href="https://blog.musnow.top/2023/02/04/note_Python/8python%E8%87%AA%E5%8A%A8%E5%8C%96%E4%B8%8B%E8%BD%BDmd%E6%96%87%E4%BB%B6%E4%B8%AD%E5%9B%BE%E7%89%87/"/>
    <id>https://blog.musnow.top/2023/02/04/note_Python/8python%E8%87%AA%E5%8A%A8%E5%8C%96%E4%B8%8B%E8%BD%BDmd%E6%96%87%E4%BB%B6%E4%B8%AD%E5%9B%BE%E7%89%87/</id>
    <published>2023-02-04T00:19:00.000Z</published>
    <updated>2023-02-08T11:10:23.695Z</updated>
    
    <content type="html"><![CDATA[<p>python自动化下载&#x2F;上传md中图片实在是太方便了</p><span id="more"></span><h1 id="1-起因"><a href="#1-起因" class="headerlink" title="1.起因"></a>1.起因</h1><p>为什么需要python来下载md里面的图片？原因很简单，那就是需要把图片保存下来，上传到第二个图床（迁移）</p><p>对于阿里云OSS来说，有两种迁移办法</p><ul><li>使用官方的数据导出功能</li><li>使用api接口遍历oss目录下载所有图片</li></ul><p>这两种办法都不是那么方便，所以我选择了第三种</p><ul><li>解析本地md文件中的img url，下载图片并保存到本地</li></ul><p>那要怎么做呢？👇</p><h1 id="2-教程"><a href="#2-教程" class="headerlink" title="2.教程"></a>2.教程</h1><p>我在github找到了这个项目 👉 <a class="link"   href="https://github.com/Deali-Axy/Markdown-Image-Parser" >Deali-Axy&#x2F;Markdown-Image-Parser<i class="fas fa-external-link-alt"></i></a></p><p>作者的代码写的很棒，但是README里面却少了一个重要的启动教程，那就是你需要在当前目录下创建一个<code>files</code>文件夹（md文件放到这里面），对应启动项里面开启的根目录</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    files_list = get_files_list(os.path.abspath(os.path.join(<span class="string">&#x27;.&#x27;</span>, <span class="string">&#x27;files&#x27;</span>)))</span><br></pre></td></tr></table></figure><p>随后，执行<code>python spider.py</code>，开始运行，脚本会自动将md转成html并下载图片</p><p>我将作者的代码进一步细化，并修改了一部分bug👇建议使用我fork的版本</p><p><a class="link"   href="https://github.com/musnows/Markdown-Image-Parser" >https://github.com/musnows/Markdown-Image-Parser<i class="fas fa-external-link-alt"></i></a></p><h2 id="2-1-UnicodeDecodeError"><a href="#2-1-UnicodeDecodeError" class="headerlink" title="2.1 UnicodeDecodeError"></a>2.1 UnicodeDecodeError</h2><p>在启动的时候，你可能会遇到这个报错</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">UnicodeDecodeError: &#x27;utf-8&#x27; codec can&#x27;t decode byte 0xbc in position 2: invalid start byt</span><br></pre></td></tr></table></figure><p>解决办法参考 👉 <a class="link"   href="https://blog.csdn.net/sunflower_sara/article/details/103957385" >点我<i class="fas fa-external-link-alt"></i></a></p><p>解决办法是将打开文件编码的<code>utf-8</code> 修改成<code>ISO-8859-1</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(file, encoding=<span class="string">&#x27;ISO-8859-1&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">           md_content = f.read()</span><br></pre></td></tr></table></figure><h2 id="2-2-request-failed"><a href="#2-2-request-failed" class="headerlink" title="2.2 request failed"></a>2.2 request failed</h2><p>因为作者并没有写判断，此时就会出现一个严重问题：本地图片也会进行<code>requests</code>请求</p><p>比如我的md里面就有一些图片是本地的<code>img/图片文件名</code>，这个代码依旧对这个路径当做网络路径进行请求，于是就出现了报错</p><p>所以就需要在<code>download_pics</code>函数中对url进行判断，这里可以写成下面的格式（因为我知道我的阿里云OSS链接里面不包含<code>img</code>文件夹，所以<code>img/</code>的图片是本地文件</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">download_pics</span>(<span class="params">url, file,MDfilename</span>):</span><br><span class="line">    <span class="keyword">if</span> <span class="string">&#x27;img/&#x27;</span> <span class="keyword">in</span> url:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;不处理本地图片: &#x27;</span>, url)</span><br><span class="line">        <span class="keyword">return</span></span><br></pre></td></tr></table></figure><p>但是这样其实还是有点呆呆的，我们直接判断http在不在里面不就知道是不是网络图片了😂</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">download_pics</span>(<span class="params">url, file,MDfilename</span>):</span><br><span class="line">    <span class="keyword">if</span> <span class="string">&#x27;http&#x27;</span> <span class="keyword">not</span> <span class="keyword">in</span> url:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;不处理本地图片: &#x27;</span>, url)</span><br><span class="line">        <span class="keyword">return</span></span><br></pre></td></tr></table></figure><h2 id="2-3-图片保存路径"><a href="#2-3-图片保存路径" class="headerlink" title="2.3 图片保存路径"></a>2.3 图片保存路径</h2><p>默认情况下，图片会保存到子文件夹下的markdown文件名目录</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">targer_dir = os.path.join(dirname,assert_dir)</span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> os.path.exists(targer_dir):</span><br><span class="line">     os.mkdir(targer_dir)</span><br></pre></td></tr></table></figure><p>这样其实非常非常不方便管理，<strong>有几个md文档就有几个md图片路径</strong>，可太难受了</p><p>所以我们需要注释掉这部分代码，直接选择一个根目录进行图片的保存</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">targer_dir =<span class="string">&#x27;./files/img/&#x27;</span> <span class="comment"># 所有图片都保存到 ./files/img/ 文件夹里面</span></span><br></pre></td></tr></table></figure><h2 id="2-4-try-x2F-except"><a href="#2-4-try-x2F-except" class="headerlink" title="2.4 try&#x2F;except"></a>2.4 try&#x2F;except</h2><p>作者代码里面的最最最大漏洞，那就是没有对for循环里面的请求进行<code>try/except</code></p><p>这样就会导致，如果有一个图片请求失败，整个<strong>进程会直接终止</strong>！</p><p>那么问题就来了，即便这个程序会在遍历的时候打印当前处理的文件名字，但这需要用户去翻命令行输出，再找到到底是哪一个图片发生错误，非常非常非常难受！</p><p>如果重新执行，那就相当与把已经下好的图片又重下一遍，浪费OSS的流量。</p><p>所以我们必须要给for循环内部添加上异常捕获，如果遇到错误，<strong>就将这个图片的url存下来</strong>，继续往后执行！</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> file <span class="keyword">in</span> files_list:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&#x27;正在处理：<span class="subst">&#123;file&#125;</span>&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(file, encoding=<span class="string">&#x27;ISO-8859-1&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">        md_content = f.read()</span><br><span class="line"></span><br><span class="line">    pics_list = get_pics_list(md_content)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&#x27;发现图片 <span class="subst">&#123;<span class="built_in">len</span>(pics_list)&#125;</span> 张&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> index, pic <span class="keyword">in</span> <span class="built_in">enumerate</span>(pics_list):</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">f&#x27;正在下载第 <span class="subst">&#123;index + <span class="number">1</span>&#125;</span> 张图片...&#x27;</span>)</span><br><span class="line">            MDfilename = os.path.basename(file) <span class="comment"># 当前处理的md文件的名字</span></span><br><span class="line">            download_pics(pic, file,MDfilename)</span><br><span class="line">            time.sleep(<span class="number">0.5</span>) <span class="comment"># 避免下载超速</span></span><br><span class="line">        <span class="keyword">except</span> KeyboardInterrupt:</span><br><span class="line">            os.abort()</span><br><span class="line">        <span class="keyword">except</span>:</span><br><span class="line">            <span class="built_in">print</span>(traceback.format_exc())</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> MDfilename <span class="keyword">not</span> <span class="keyword">in</span> err_img:</span><br><span class="line">                err_img[MDfilename]=[]</span><br><span class="line">            <span class="comment"># 添加图片</span></span><br><span class="line">            err_img[MDfilename].append(pic)</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;图片获取错误：&quot;</span>,pic)</span><br><span class="line">            time.sleep(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&#x27;处理完成。&#x27;</span>)</span><br><span class="line">write_file(<span class="string">&#x27;err.json&#x27;</span>,err_img)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&#x27;写入err完成&#x27;</span>)</span><br></pre></td></tr></table></figure><p>完整代码见我的github仓库</p><h2 id="2-5-上传到lsky图床"><a href="#2-5-上传到lsky图床" class="headerlink" title="2.5 上传到lsky图床"></a>2.5 上传到lsky图床</h2><p>现在我要迁移的图床是lsky，所以为了方便，可以在将图片保存到本地的同时，将图片上传到lsky图床</p><p>注意，上传之前，请在<strong>用户组</strong>将图片上传的格式改为原始文件命名，否则重命名了那就什么都没了！</p><p><img                       lazyload                     alt="image"                     data-src="https://img1.musnow.top/i/23/02/202302040839352.png"                      alt="image-20230204083922313"                ></p><blockquote><p>还发现了一个离谱的问题，那就是一些图片上传了之后，lsky还是会给他改名字！！！</p><p><img                       lazyload                     alt="image"                     data-src="https://img1.musnow.top/i/23/02/202302040840449.png"                      alt="image-20230204084005425"                ></p><p>比如这个gif，他的alt里面是原始名字，但是url并不是！！！你说这离谱不</p><p>解决方法那就是把本地的图片打一个压缩包，传到云服务器后台存储路径中覆盖一遍，把没有的图片给添加上</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">unzip -o ~/docker/img.zip -d ~/docker/lsky/storage/app/uploads/23/02</span><br></pre></td></tr></table></figure></blockquote><p>上传之前，先获取token</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">lsky</span>():</span><br><span class="line">    url = <span class="string">&quot;服务器地址/api/v1/tokens&quot;</span></span><br><span class="line">    params = &#123;</span><br><span class="line">        <span class="string">&#x27;email&#x27;</span>:<span class="string">&#x27;账户邮箱&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;password&#x27;</span>:<span class="string">&#x27;密码&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    res = requests.post(url,  params=params)  <span class="comment"># 请求api</span></span><br><span class="line">    <span class="keyword">return</span> res.json()</span><br></pre></td></tr></table></figure><p>结果如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;&#x27;status&#x27;: True, &#x27;message&#x27;: &#x27;success&#x27;, &#x27;data&#x27;: &#123;&#x27;token&#x27;: &#x27;这里会返回token&#x27;&#125;&#125;</span><br></pre></td></tr></table></figure><p>随后是上传的代码，注意兰空必须要用<code>open &#39;rb&#39;</code>重新打开一边图片，所以参数给<code>img_path</code>也就是图片的路径即可</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 兰空图床</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">lsky_upload</span>(<span class="params">img_path:<span class="built_in">str</span></span>):</span><br><span class="line">    url = <span class="string">&quot;你的兰空图床服务器/api/v1/upload&quot;</span></span><br><span class="line">    header = &#123;</span><br><span class="line">        <span class="string">&quot;Authorization&quot;</span>: <span class="string">&quot;Bearer 你的兰空token&quot;</span>,</span><br><span class="line">        <span class="string">&quot;Accept&quot;</span>: <span class="string">&quot;application/json&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">    img = <span class="built_in">open</span>(img_path, <span class="string">&#x27;rb&#x27;</span>)</span><br><span class="line">    params = &#123;<span class="string">&#x27;strategy_id&#x27;</span>: <span class="number">1</span>&#125;</span><br><span class="line">    myfiles = &#123;<span class="string">&#x27;file&#x27;</span>: img&#125;</span><br><span class="line">    res = requests.post(url, headers=header, params=params,</span><br><span class="line">                        files=myfiles)  <span class="comment"># 请求api</span></span><br><span class="line">    <span class="keyword">return</span> res.json()</span><br></pre></td></tr></table></figure><p>在<code>download_pics</code>的末尾添加如下代码，并对兰空图床的返回值进行判断，如果上传错误，同样添加到错误图片中！</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 上传lsky</span></span><br><span class="line">res = lsky_upload(img_path=<span class="string">f&quot;<span class="subst">&#123;targer_dir&#125;</span>/<span class="subst">&#123;filename&#125;</span>&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(res)</span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> res[<span class="string">&#x27;status&#x27;</span>]:</span><br><span class="line">    <span class="keyword">global</span> err_img</span><br><span class="line">    <span class="keyword">if</span> MDfilename <span class="keyword">not</span> <span class="keyword">in</span> err_img:</span><br><span class="line">        err_img[MDfilename]=[]</span><br><span class="line">     </span><br><span class="line">    err_img[MDfilename].append(url)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;兰空上传错误！&quot;</span>,url)</span><br><span class="line">    time.sleep(<span class="number">1</span>)</span><br></pre></td></tr></table></figure><p>上传成功的返回值status是True</p><h1 id="3-开始自动化上传"><a href="#3-开始自动化上传" class="headerlink" title="3.开始自动化上传"></a>3.开始自动化上传</h1><p>将上面的bug修改好了之后，就可以正式运行，在保存图片到本地的同时，上传到兰空图床了！</p><p><img                       lazyload                     alt="image"                     data-src="https://img1.musnow.top/i/23/02/202302040801036.png"                      alt="image-20230204074327382"                ></p><p>图片也都成功保存到本地了</p><p><img                       lazyload                     alt="image"                     data-src="https://img1.musnow.top/i/23/02/63e383010349e.png"                      alt="image-20230208190951728"                ></p><p>上传完毕之后，也能在err里面看到错误的图片路径，以便重新处理。</p><p>可以看到这里面有一部分是gitee和csdn的链接，这些图片有<strong>防盗链</strong>，而且图片尾部添加了其他字段，导致lsky没有办法将其识别为图片（却少图片格式后缀）</p><p>不过我的目标是将<strong>阿里云OSS的图片转到lsky</strong>，这些本来就不是阿里云OSS的图片和我的目的无关！</p><p><img                       lazyload                     alt="image"                     data-src="https://img1.musnow.top/i/23/02/202302040801756.png"                      alt="image-20230204080115678"                ></p><p>做完这一切，最让我感慨的是，我的阿里云oss里面有1g的图片，实际用的却只有下面这一丢丢；其他估计都是重复上传的</p><p><img                       lazyload                     alt="image"                     data-src="https://img1.musnow.top/i/23/02/63ddaea630477.png"                      alt="image-20230204085611110"                ></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;python自动化下载&amp;#x2F;上传md中图片实在是太方便了&lt;/p&gt;</summary>
    
    
    
    <category term="速通Python" scheme="https://blog.musnow.top/categories/%E9%80%9F%E9%80%9APython/"/>
    
    
    <category term="图床" scheme="https://blog.musnow.top/tags/%E5%9B%BE%E5%BA%8A/"/>
    
    <category term="Python" scheme="https://blog.musnow.top/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>【Docker】配置wiki js</title>
    <link href="https://blog.musnow.top/2023/02/02/docker/7docker%E9%83%A8%E7%BD%B2wikijs/"/>
    <id>https://blog.musnow.top/2023/02/02/docker/7docker%E9%83%A8%E7%BD%B2wikijs/</id>
    <published>2023-02-02T09:45:33.000Z</published>
    <updated>2023-02-05T08:15:19.819Z</updated>
    
    <content type="html"><![CDATA[<p>wikijs是一个在线多人协作（带git版本管理）的wiki套件</p><span id="more"></span><p>相比于其他wiki的展示功能为主，wikijs将权限管理+多人协作作为了首个要素，其支持富文本编辑器&#x2F;mardown编辑器&#x2F;html源码编辑</p><h1 id="1-Docker-cli部署"><a href="#1-Docker-cli部署" class="headerlink" title="1.Docker-cli部署"></a>1.Docker-cli部署</h1><blockquote><p>在云服务器安装 <a class="link"   href="https://docs.requarks.io/install/ubuntu" >https://docs.requarks.io/install/ubuntu<i class="fas fa-external-link-alt"></i></a></p></blockquote><p>可以跟着官方的指令走，下面节选了最终3个创建容器的命令</p><hr><p>配置密钥</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> -p /etc/wiki</span><br><span class="line"></span><br><span class="line"><span class="comment"># Generate DB secret</span></span><br><span class="line">openssl rand -<span class="built_in">base64</span> 32 &gt; /etc/wiki/.db-secret</span><br><span class="line"></span><br><span class="line"><span class="comment"># Create internal docker network</span></span><br><span class="line">docker network create wikinet</span><br><span class="line"></span><br><span class="line"><span class="comment"># Create data volume for PostgreSQL</span></span><br><span class="line">docker volume create pgdata</span><br></pre></td></tr></table></figure><p>配置数据库</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">docker create \</span><br><span class="line">--name=db \</span><br><span class="line">-e POSTGRES_DB=wiki \</span><br><span class="line">-e POSTGRES_USER=wiki \</span><br><span class="line">-e POSTGRES_PASSWORD_FILE=/etc/wiki/.db-secret \</span><br><span class="line">-v /etc/wiki/.db-secret:/etc/wiki/.db-secret:ro \</span><br><span class="line">-v pgdata:/var/lib/postgresql/data \</span><br><span class="line">--restart=unless-stopped \</span><br><span class="line">-h db \</span><br><span class="line">--network=wikinet \</span><br><span class="line">postgres:11</span><br></pre></td></tr></table></figure><p>配置主容器</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">docker create --name=wiki \</span><br><span class="line">-e DB_TYPE=postgres \</span><br><span class="line">-e DB_HOST=db \</span><br><span class="line">-e DB_PORT=5432 \</span><br><span class="line">-e DB_PASS_FILE=/etc/wiki/.db-secret \</span><br><span class="line">-v /etc/wiki/.db-secret:/etc/wiki/.db-secret:ro \</span><br><span class="line">-e DB_USER=wiki \</span><br><span class="line">-e DB_NAME=wiki \</span><br><span class="line">-e UPGRADE_COMPANION=1 \</span><br><span class="line">--restart=unless-stopped \</span><br><span class="line">-h wiki \</span><br><span class="line">--network=wikinet \</span><br><span class="line">-p 3000:3000 -p 3443:3443 \</span><br><span class="line">ghcr.io/requarks/wiki:2</span><br></pre></td></tr></table></figure><p>升级伴侣</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">docker create \</span><br><span class="line">--name=wiki-update-companion \</span><br><span class="line">-v /var/run/docker.sock:/var/run/docker.sock:ro \</span><br><span class="line">--restart=unless-stopped \</span><br><span class="line">-h wiki-update-companion \</span><br><span class="line">--network=wikinet \</span><br><span class="line">ghcr.io/requarks/wiki-update-companion:latest</span><br></pre></td></tr></table></figure><p>配置防火墙</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">sudo ufw allow ssh</span><br><span class="line">sudo ufw allow http</span><br><span class="line">sudo ufw allow https</span><br><span class="line"></span><br><span class="line">sudo ufw --force enable</span><br></pre></td></tr></table></figure><p>运行容器</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker start db</span><br><span class="line">docker start wiki</span><br><span class="line">docker start wiki-update-companion</span><br></pre></td></tr></table></figure><p>到这一步，就可以用<code>3000</code>端口访问了</p><h1 id="2-docker-compose部署（推荐）"><a href="#2-docker-compose部署（推荐）" class="headerlink" title="2.docker-compose部署（推荐）"></a>2.docker-compose部署（推荐）</h1><p><a class="link"   href="https://docs.requarks.io/install/docker" >https://docs.requarks.io/install/docker<i class="fas fa-external-link-alt"></i></a></p><p>docker-compose最好的一点就是方便管理，不需要单独管理上面的3个容器，而是用一条命令就能同时启停容器</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">&quot;3&quot;</span></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">db:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">postgres:11-alpine</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="attr">POSTGRES_DB:</span> <span class="string">wiki</span></span><br><span class="line">      <span class="attr">POSTGRES_PASSWORD:</span> <span class="string">wikijsrocks</span></span><br><span class="line">      <span class="attr">POSTGRES_USER:</span> <span class="string">wikijs</span></span><br><span class="line">    <span class="attr">logging:</span></span><br><span class="line">      <span class="attr">driver:</span> <span class="string">&quot;none&quot;</span></span><br><span class="line">    <span class="attr">restart:</span> <span class="string">unless-stopped</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">db-data:/var/lib/postgresql/data</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">wiki:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">ghcr.io/requarks/wiki:2</span></span><br><span class="line">    <span class="attr">depends_on:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">db</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="attr">DB_TYPE:</span> <span class="string">postgres</span></span><br><span class="line">      <span class="attr">DB_HOST:</span> <span class="string">db</span></span><br><span class="line">      <span class="attr">DB_PORT:</span> <span class="number">5432</span></span><br><span class="line">      <span class="attr">DB_USER:</span> <span class="string">wikijs</span></span><br><span class="line">      <span class="attr">DB_PASS:</span> <span class="string">wikijsrocks</span></span><br><span class="line">      <span class="attr">DB_NAME:</span> <span class="string">wiki</span></span><br><span class="line">    <span class="attr">restart:</span> <span class="string">unless-stopped</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;80:3000&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="attr">volumes:</span></span><br><span class="line">  <span class="attr">db-data:</span></span><br></pre></td></tr></table></figure><h1 id="3-配置证书let’s-encrpy"><a href="#3-配置证书let’s-encrpy" class="headerlink" title="3.配置证书let’s encrpy"></a>3.配置证书let’s encrpy</h1><p>配置证书需要多指定两个环境变量，分别是你的域名以及用于申请证书的邮箱</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-e &quot;LETSENCRYPT_DOMAIN=wiki.example.com&quot; \</span><br><span class="line">-e &quot;LETSENCRYPT_EMAIL=admin@example.com&quot; \</span><br><span class="line">-p 443:3443</span><br></pre></td></tr></table></figure><p>如果不这么做，则需要在nginx反向代理上配置证书</p><h1 id="4-评论"><a href="#4-评论" class="headerlink" title="4.评论"></a>4.评论</h1><p>默认的评论连回复都不支持，也没有一个管理页面和通知，如果要把wiki展示出来，这样就非常不方便</p><p>建议配置一下artalk评论系统 <a href="https://blog.musnow.top/2023/01/05/docker/wikijs%E4%BD%BF%E7%94%A8artalk%E8%AF%84%E8%AE%BA%E7%B3%BB%E7%BB%9F/">教程</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;wikijs是一个在线多人协作（带git版本管理）的wiki套件&lt;/p&gt;</summary>
    
    
    
    <category term="差生文具多" scheme="https://blog.musnow.top/categories/%E5%B7%AE%E7%94%9F%E6%96%87%E5%85%B7%E5%A4%9A/"/>
    
    
    <category term="wikijs" scheme="https://blog.musnow.top/tags/wikijs/"/>
    
    <category term="Docker" scheme="https://blog.musnow.top/tags/Docker/"/>
    
  </entry>
  
  <entry>
    <title>【C语言】可变参数列表</title>
    <link href="https://blog.musnow.top/2023/02/01/note_c/46%E5%8F%AF%E5%8F%98%E5%8F%82%E6%95%B0%E5%88%97%E8%A1%A8/"/>
    <id>https://blog.musnow.top/2023/02/01/note_c/46%E5%8F%AF%E5%8F%98%E5%8F%82%E6%95%B0%E5%88%97%E8%A1%A8/</id>
    <published>2023-02-01T12:41:59.000Z</published>
    <updated>2023-02-11T02:52:09.412Z</updated>
    
    <content type="html"><![CDATA[<p>本篇博客让我们来认识一下C语言学习过程中往往被忽略的<code>可变参数列表</code></p><span id="more"></span><p>所谓可变参数，就是一个不限定参数数量的函数，我们可以往里面传入任意个数的参数，以达成某些目的。</p><p>关联：<a href="https://blog.musnow.top/2022/09/28/note_cpp/20c++11%E7%89%B9%E6%80%A7/#7-%E5%8F%AF%E5%8F%98%E6%A8%A1%E6%9D%BF%E5%8F%82%E6%95%B0">C++11可变模板参数</a></p><h1 id="1-函数"><a href="#1-函数" class="headerlink" title="1.函数"></a>1.函数</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdarg.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">va_start</span><span class="params">(va_list ap, last)</span>;</span><br><span class="line">type <span class="title function_">va_arg</span><span class="params">(va_list ap, type)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">va_end</span><span class="params">(va_list ap)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">va_copy</span><span class="params">(va_list dest, va_list src)</span>;</span><br></pre></td></tr></table></figure><h2 id="1-1-va-start"><a href="#1-1-va-start" class="headerlink" title="1.1 va_start"></a>1.1 va_start</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">va_start</span><span class="params">(va_list ap, last_arg)</span>;</span><br></pre></td></tr></table></figure><ul><li><strong>ap</strong>: 这是一个 <strong>va_list</strong> 类型的对象，它用来存储通过 <strong>va_arg</strong> 获取额外参数时所必需的信息</li><li>这个函数的作用是初始化 <code>ap</code> 变量，它与 <strong>va_arg</strong> 和 <strong>va_end</strong> 函数一起使用。</li></ul><ul><li><strong>last_arg</strong> 是最后一个传递给函数的已知的固定参数，<strong>即省略号之前的参数</strong>。</li></ul><p>要想设置一个带可变参数的函数，函数声明是下面这样的</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">test</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b, ...)</span>;</span><br></pre></td></tr></table></figure><p>这里出现的省略号就是可变参数的特征，而变量b就是va_start函数需要的<code>last_arg</code></p><h2 id="1-2-va-arg"><a href="#1-2-va-arg" class="headerlink" title="1.2 va_arg"></a>1.2 va_arg</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">type <span class="title function_">va_arg</span><span class="params">(va_list ap, type)</span>;</span><br></pre></td></tr></table></figure><p>这个函数的作用是来提取可变参数列表中的参数。注意，每次提取的参数是直接返回的，并没有放到变量ap中。</p><p>每次对va_arg的调用都会修改ap，以便下次调用时，返回下一个参数；推断参数的时候需要指定type，如果当前参数类型和type不统一，就会发生<strong>不可预知</strong>的错误（man手册里面说的）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">If ap is passed to a function that uses va_arg(ap,type) then the value of ap is undefined after the return of that function.</span><br></pre></td></tr></table></figure><p>如果ap被传递给<code>va_arg(ap,type)</code>，则在该函数返回后，ap的值未定义。</p><h2 id="1-3-va-end"><a href="#1-3-va-end" class="headerlink" title="1.3 va_end"></a>1.3 va_end</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">va_end</span><span class="params">(va_list ap)</span>;</span><br></pre></td></tr></table></figure><p>每一个<code>va_start</code>都需要有一个配套的<code>va_end</code>，其用于清空ap</p><p>可以把他俩的关系理解为<code>malloc/free</code>，记得加上就行</p><h2 id="1-4-va-copy"><a href="#1-4-va-copy" class="headerlink" title="1.4 va_copy"></a>1.4 va_copy</h2><p>这个函数的作用是将可变参数列表从第二个参数<code>src</code>拷贝到第一个参数<code>dest</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> va_copy（va_list dest，va_list src）;</span><br></pre></td></tr></table></figure><p>其也能够<strong>初始化</strong><code>dest</code>。调用了<code>va_copy</code>后，无须调用<code>va_start</code>初始化<code>dest</code>，但<code>va_end</code>还是需要的。</p><h1 id="2-简单示例"><a href="#2-简单示例" class="headerlink" title="2.简单示例"></a>2.简单示例</h1><h2 id="2-1-打印多个参数"><a href="#2-1-打印多个参数" class="headerlink" title="2.1 打印多个参数"></a>2.1 打印多个参数</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdarg.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">print</span><span class="params">(<span class="type">int</span> num_args,...)</span></span><br><span class="line">&#123;</span><br><span class="line">    va_list ap;</span><br><span class="line">    va_start(ap,num_args);<span class="comment">//初始化可变参数</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;num_args;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,va_arg(ap,<span class="type">int</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    va_end(ap);<span class="comment">//结束对ap的使用</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    print(<span class="number">5</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行该函数，会打印如下结果</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ ./test</span><br><span class="line">1 2 3 4 5 </span><br></pre></td></tr></table></figure><p>这就表明了，<code>...</code>省略号之前的参数，和<code>va_arg</code>返回可变参数其实是没有关系的。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">print</span><span class="params">(<span class="type">int</span> num_args,...)</span></span><br><span class="line">&#123;</span><br><span class="line">    va_list ap;</span><br><span class="line">    va_start(ap,num_args);<span class="comment">//初始化可变参数</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">8</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,va_arg(ap,<span class="type">int</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    va_end(ap);<span class="comment">//结束对ap的使用</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    print(<span class="number">5</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>即便在最后都没有使用<code>num_args</code>，也不会影响结果的正确性。<code>va_start</code>需要这个参数，其实是用来标识可变参数的起点。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ ./test</span><br><span class="line">1 2 3 4 5 6 7 8 </span><br></pre></td></tr></table></figure><h2 id="2-2-多参数求和"><a href="#2-2-多参数求和" class="headerlink" title="2.2 多参数求和"></a>2.2 多参数求和</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdarg.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="comment">// 采用可变参数，第一个参数用于标识参数数量</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sum</span><span class="params">(<span class="type">int</span> num_args, ...)</span></span><br><span class="line">&#123;</span><br><span class="line">   <span class="type">int</span> val = <span class="number">0</span>;</span><br><span class="line">   va_list ap;</span><br><span class="line">   <span class="type">int</span> i;</span><br><span class="line"></span><br><span class="line">   va_start(ap, num_args);</span><br><span class="line">   <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; num_args; i++)</span><br><span class="line">   &#123;</span><br><span class="line">      val += va_arg(ap, <span class="type">int</span>);</span><br><span class="line">   &#125;</span><br><span class="line">   va_end(ap);</span><br><span class="line"> </span><br><span class="line">   <span class="keyword">return</span> val;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">test1</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;10、20 和 30 的和 = %d\n&quot;</span>,  sum(<span class="number">3</span>, <span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>) );</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;4、20、25 和 30 的和 = %d\n&quot;</span>,  sum(<span class="number">4</span>, <span class="number">4</span>, <span class="number">20</span>, <span class="number">25</span>, <span class="number">30</span>) );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ ./test</span><br><span class="line">10、20 和 30 的和 = 60</span><br><span class="line">4、20、25 和 30 的和 = 79</span><br></pre></td></tr></table></figure><h1 id="3-利用可变参数实现log类"><a href="#3-利用可变参数实现log类" class="headerlink" title="3.利用可变参数实现log类"></a>3.利用可变参数实现log类</h1><p>现在有了可变参数，我们就可以接用这个参数来进行日志的打印了</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ctime&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdarg&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cassert&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cerrno&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DEBUG 0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NOTICE 1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> WARINING 2</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FATAL 3</span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">char</span> *log_level[]=&#123;<span class="string">&quot;DEBUG&quot;</span>, <span class="string">&quot;NOTICE&quot;</span>, <span class="string">&quot;WARINING&quot;</span>, <span class="string">&quot;FATAL&quot;</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 采用可变参数列表</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">logging</span><span class="params">(<span class="type">int</span> level, <span class="type">const</span> <span class="type">char</span> *format, ...)</span></span><br><span class="line">&#123;</span><br><span class="line">    assert(level &gt;= DEBUG || level &lt;= FATAL);</span><br><span class="line"></span><br><span class="line">    <span class="type">char</span> *name = getenv(<span class="string">&quot;USER&quot;</span>);<span class="comment">// 获取环境变量中的用户（执行命令的用户）</span></span><br><span class="line"></span><br><span class="line">    <span class="type">char</span> logInfo[<span class="number">1024</span>];</span><br><span class="line">    <span class="comment">// 获取可变参数列表</span></span><br><span class="line">    va_list ap; <span class="comment">// ap -&gt; char*</span></span><br><span class="line">    va_start(ap, format);</span><br><span class="line"></span><br><span class="line">    vsnprintf(logInfo, <span class="keyword">sizeof</span>(logInfo)<span class="number">-1</span>, format, ap);</span><br><span class="line"></span><br><span class="line">    va_end(ap); <span class="comment">// ap = NULL</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根据日志等级选择打印到stderr/stdout</span></span><br><span class="line">    FILE *out = (level == FATAL) ? <span class="built_in">stderr</span>:<span class="built_in">stdout</span>;</span><br><span class="line">    <span class="comment">// 格式化打印到文件中</span></span><br><span class="line">    <span class="built_in">fprintf</span>(out, <span class="string">&quot;%s | %u | %s | %s\n&quot;</span>, \</span><br><span class="line">        log_level[level], \</span><br><span class="line">        (<span class="type">unsigned</span> <span class="type">int</span>)time(nullptr),\</span><br><span class="line">        name == nullptr ? <span class="string">&quot;unknow&quot;</span>:name,\</span><br><span class="line">        logInfo);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-1-vsnprint"><a href="#3-1-vsnprint" class="headerlink" title="3.1 vsnprint"></a>3.1 vsnprint</h2><p>作用：使用<code>vsnprintf()</code>用于向一个字符串缓冲区打印格式化字符串，且可以限定打印的格式化字符串的最大长度。</p><p>此函数需要C99或者C++11及以上版本才能支持。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">vsnprintf</span><span class="params">(<span class="type">char</span>* sbuf, <span class="type">size_t</span> n, <span class="type">const</span> <span class="type">char</span>* format, va_list arg)</span>;</span><br></pre></td></tr></table></figure><ul><li>第一个参数：目标缓冲区（字符数组）</li><li>第二个参数，限定最多打印到缓冲区的字符数量为<code>n-1</code>个（留位置给<code>\0</code>）</li><li>第三个参数，打印的格式（如<code>%d:%s</code>）</li><li>第四个参数，可变参数arg，需要用<code>va_start</code>初始化</li></ul><p><strong>返回</strong>：成功打印到sbuf中的字符的个数，不包括末尾追加的\0。如果格式化解析失败，则返回负数。</p><p>用这个函数，就能把我们的来源字符串给输入到缓冲区<code>char logInfo[1024];</code>中</p><h2 id="3-2-fprintf"><a href="#3-2-fprintf" class="headerlink" title="3.2 fprintf"></a>3.2 fprintf</h2><p>使用<code>fprintf</code>，将printf的输出打印到指定文件中；用法和<code>printf</code>是一样的</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">fprintf</span><span class="params">(FILE *stream, <span class="type">const</span> <span class="type">char</span> *format, ...)</span>;</span><br></pre></td></tr></table></figure><p>这样是为了区分<code>stderr/stdout</code>。同时添加上执行命令的用户信息，以及当前的时间戳</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">fprintf</span>(out, <span class="string">&quot;%s | %u | %s | %s\n&quot;</span>, \</span><br><span class="line">    log_level[level], \</span><br><span class="line">    (<span class="type">unsigned</span> <span class="type">int</span>)time(nullptr),\</span><br><span class="line">    name == nullptr ? <span class="string">&quot;unknow&quot;</span>:name,\</span><br><span class="line">    logInfo);</span><br></pre></td></tr></table></figure><h2 id="3-3-运行结果"><a href="#3-3-运行结果" class="headerlink" title="3.3 运行结果"></a>3.3 运行结果</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    logging(DEBUG, <span class="string">&quot;socket create success: %d&quot;</span>, <span class="number">114514</span>);</span><br><span class="line">    logging(FATAL, <span class="string">&quot;socket:%s:%d&quot;</span>, strerror(errno), <span class="number">11234</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ ./test</span><br><span class="line">DEBUG | 1675322313 | muxue | socket create success: 114514</span><br><span class="line">FATAL | 1675322313 | muxue | socket:Success:11234</span><br></pre></td></tr></table></figure><h1 id="The-end"><a href="#The-end" class="headerlink" title="The end"></a>The end</h1><p>对于可变参数的简单介绍就到这里！基本的使用能看懂久OK啦！</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;本篇博客让我们来认识一下C语言学习过程中往往被忽略的&lt;code&gt;可变参数列表&lt;/code&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="初识C语言" scheme="https://blog.musnow.top/categories/%E5%88%9D%E8%AF%86C%E8%AF%AD%E8%A8%80/"/>
    
    
    <category term="C语言" scheme="https://blog.musnow.top/tags/C%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title>【Linux】来写一个udp的服务端+客户端</title>
    <link href="https://blog.musnow.top/2023/02/01/note_Linux/27udp%E4%BB%A3%E7%A0%81/"/>
    <id>https://blog.musnow.top/2023/02/01/note_Linux/27udp%E4%BB%A3%E7%A0%81/</id>
    <published>2023-02-01T07:30:54.000Z</published>
    <updated>2023-02-10T08:24:29.074Z</updated>
    
    <content type="html"><![CDATA[<p>来写一个udp的代码</p><span id="more"></span><h1 id="1-socket编程接口"><a href="#1-socket编程接口" class="headerlink" title="1.socket编程接口"></a>1.socket编程接口</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建 socket 文件描述符 (TCP/UDP, 客户端 + 服务器)</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">socket</span><span class="params">(<span class="type">int</span> domain, <span class="type">int</span> type, <span class="type">int</span> protocol)</span>;</span><br><span class="line"><span class="comment">// 绑定端口号 (TCP/UDP, 服务器)      </span></span><br><span class="line"><span class="type">int</span> <span class="title function_">bind</span><span class="params">(<span class="type">int</span> socket, <span class="type">const</span> <span class="keyword">struct</span> sockaddr *address,</span></span><br><span class="line"><span class="params">         <span class="type">socklen_t</span> address_len)</span>;</span><br><span class="line"><span class="comment">// 开始监听socket (TCP, 服务器)</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">listen</span><span class="params">(<span class="type">int</span> socket, <span class="type">int</span> backlog)</span>;</span><br><span class="line"><span class="comment">// 接收请求 (TCP, 服务器)</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">accept</span><span class="params">(<span class="type">int</span> socket, <span class="keyword">struct</span> sockaddr* address,</span></span><br><span class="line"><span class="params">         <span class="type">socklen_t</span>* address_len)</span>;</span><br><span class="line"><span class="comment">// 建立连接 (TCP, 客户端)</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">connect</span><span class="params">(<span class="type">int</span> sockfd, <span class="type">const</span> <span class="keyword">struct</span> sockaddr *addr,</span></span><br><span class="line"><span class="params">         <span class="type">socklen_t</span> addrlen)</span>;</span><br></pre></td></tr></table></figure><p>linux下一切皆文件，socket接口也不例外。其返回值本质上就是一个fd文件描述符，这样我们对网络的发送&#x2F;接收操作，就转换成了对文件的写入&#x2F;读取操作了</p><p>在这里面有一个比较重要的结构<code>sockaddr</code>需要说明一番</p><h2 id="1-1-sockaddr"><a href="#1-1-sockaddr" class="headerlink" title="1.1 sockaddr"></a>1.1 sockaddr</h2><p>socket是一层抽象的网络编程接口，适用于各种底层网络协议，如IPv4&#x2F;IPv6。同时，这个接口还可以用于系统内部的通信。这就实现了用一个接口来干两件事。</p><p>为此，就必须要在传值中进行一些修改。该接口新增了一个<code>sockaddr</code>，用来接收目标信息。这个值的参数可以是<code>sockaddr_in/scokaddr_un/sockadd_in6</code>之中的任意一个（需要强转指针）</p><p><code>sockaddr</code>本身不存放任何信息。</p><p>这个参数可接收的结构体中，固定前16位就是用于标识符的。传到处理函数中，就会判断前16位中的标识符的类型，以确定传入参数的类型，再执行不同的实现</p><ul><li>比如传入的<code>scokaddr_un</code>，前16位是<code>AF_UNIX</code>，那么当前使用的就是<strong>本地通信</strong></li><li><code>sockaddr_in</code>是ipv4通信，<code>sockaddr_in6</code>是ipv6通信</li></ul><p><img                       lazyload                     alt="image"                     data-src="https://img1.musnow.top/i/23/02/20236d2a0690427f302e7a9895bbd40884c1.png"                      alt="image-20230201150711386"                ></p><p>你可能会有疑惑，既然<code>sockaddr</code>不存放信息，那为何不把这个参数设置为一个<code>void*</code>的指针？反正最后都是进了函数之后判断参数类型，<code>void*</code>指针也能达成目标呀🧐</p><p>这个问题的答案很简单：当初设计这套接口的时候，C语言还不支持<code>void*</code>😂</p><hr><h2 id="1-2-存放位置"><a href="#1-2-存放位置" class="headerlink" title="1.2 存放位置"></a>1.2 存放位置</h2><p>因为<code>sockaddr_in</code>这类的结构体，最终都需要被操作系统载入并实现网络操作。所以它们肯定是需要载入内核中的</p><p>但这并不意味着这类结构体是存放在内核里面的，而是存放在<strong>用户栈</strong>，用户态和内核态交换的时候，通过接口传值载入到内核的空间进行使用</p><h1 id="2-server"><a href="#2-server" class="headerlink" title="2.server"></a>2.server</h1><p>了解了上面的信息，接下来，认识一下如果想建立一个<code>udp</code>server，需要怎么操作吧！</p><p>以下是一个server的类，包含了端口、ip、socker fd三个基本信息</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">UdpServer</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">UdpServer</span>(<span class="type">uint16_t</span> port,<span class="type">const</span> string&amp; ip=<span class="string">&quot;&quot;</span>)</span><br><span class="line">     : _port((<span class="type">uint16_t</span>)port), _ip(ip), _sockfd(<span class="number">-1</span>)</span><br><span class="line">    &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// 服务器端口号</span></span><br><span class="line">    <span class="type">uint16_t</span> _port;</span><br><span class="line">    <span class="comment">// 服务器ip地址</span></span><br><span class="line">    string _ip;</span><br><span class="line">    <span class="comment">// 服务器socket fd信息</span></span><br><span class="line">    <span class="type">int</span> _sockfd;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="2-1-创建套接字"><a href="#2-1-创建套接字" class="headerlink" title="2.1 创建套接字"></a>2.1 创建套接字</h2><p>这里需要用的是下面这个接口</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">socket</span><span class="params">(<span class="type">int</span> domain, <span class="type">int</span> type, <span class="type">int</span> protocol)</span>;</span><br></pre></td></tr></table></figure><ul><li>第一个参数domain标识该socker的作用域</li></ul><p>可以设置为本地，也可以设置为网络。支持如下参数</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Name                Purpose                          Man page</span><br><span class="line">AF_UNIX, AF_LOCAL   Local communication              unix(7)</span><br><span class="line">AF_INET             IPv4 Internet protocols          ip(7)</span><br><span class="line">AF_INET6            IPv6 Internet protocols          ipv6(7)</span><br><span class="line">AF_IPX              IPX - Novell protocols</span><br><span class="line">AF_NETLINK          Kernel user interface device     netlink(7)</span><br><span class="line">AF_X25              ITU-T X.25 / ISO-8208 protocol   x25(7)</span><br><span class="line">AF_AX25             Amateur radio AX.25 protocol</span><br><span class="line">AF_ATMPVC           Access to raw ATM PVCs</span><br><span class="line">AF_APPLETALK        Appletalk                        ddp(7)</span><br><span class="line">AF_PACKET           Low level packet interface       packet(7)</span><br></pre></td></tr></table></figure><p>因为我们要创建的是一个网络服务器，所以这里设置为<code>AF_INET</code>，也就是IPV4的服务</p><ul><li>第二个参数type指代套接字的类型，决定了通信时的报文类型</li></ul><p>这里支持流式（TCP）或者用户数据报（UDP），以及RAW原始格式（能够直接访问协议，方便debug）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">SOCK_STREAM   Provides sequenced, reliable, two-way, connection-based byte streams. An out-of-band data  transmission  mechanism  may  be supported.</span><br><span class="line"></span><br><span class="line">SOCK_DGRAM    Supports datagrams (connectionless, unreliable messages of a fixed maximum length).</span><br><span class="line"></span><br><span class="line"> SOCK_RAW        Provides raw network protocol access.</span><br></pre></td></tr></table></figure><p>更多支持的参数参考man手册</p><ul><li>第三个参数指代协议，在网络应用中，设置为<strong>0</strong>即可</li></ul><p>返回值是一个linux系统的<strong>文件描述符</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">RETURN VALUE</span><br><span class="line">       On success, a file descriptor for the new socket is returned.  On error, -1 is returned, and errno is set appropriately.</span><br></pre></td></tr></table></figure><hr><p>这样，我们就能写出第一行代码，以及对这个代码的返回值判断</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">_sockfd = socket(AF_INET, SOCK_DGRAM, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span> (_sockfd &lt; <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">    logging(FATAL, <span class="string">&quot;socket:%s:%d&quot;</span>, strerror(errno), _sockfd);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为socket是文件描述符，为了规范，我们还可以在析构函数里面调用一下<code>close</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">~<span class="built_in">UdpServer</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">close</span>(_sockfd);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-2-配置sockaddr-in"><a href="#2-2-配置sockaddr-in" class="headerlink" title="2.2 配置sockaddr_in"></a>2.2 配置sockaddr_in</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 2. 绑定网络信息，指明ip+port</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">local</span>;</span></span><br><span class="line"><span class="built_in">memset</span>(&amp;local,<span class="number">0</span>,<span class="keyword">sizeof</span>(local));<span class="comment">//配置为 0</span></span><br></pre></td></tr></table></figure><p>因为用的是<code>ipv4</code>的网络通信，所以这里需要初始化一个<code>sockaddr_in</code>类型</p><p>此时在vscode的代码补全中，可以看到4个成员，需要对它们赋值以配置服务器信息</p><p><img                       lazyload                     alt="image"                     data-src="https://img1.musnow.top/i/23/02/202302021529616.png"                      alt="image-20230202152944512"                ></p><p>首先是把协议家族设置为<code>IPV4</code>，端口配置为函数参数中的端口</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 协议家族，设置为ipv4</span></span><br><span class="line">local.sin_family = AF_INET; </span><br><span class="line"><span class="comment">// 端口，需要进行 本地-&gt;网络转换</span></span><br><span class="line">local.sin_port = htons(_port);</span><br></pre></td></tr></table></figure><p>随后配置ip</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 如果初始化时候的ip为空，则调用INADDR_ANY代表任意ip。否则对传入的ip进行转换后赋值</span></span><br><span class="line">local.sin_addr.s_addr = _ip.empty() ? htonl(INADDR_ANY) : inet_addr(ip_.c_str());</span><br></pre></td></tr></table></figure><p>这里采用了<code>?:</code>三目操作符，如果类构造的时候传入的ip是空（没有配置ip）那就直接设置为任意ip，否则传入成员变量；</p><p>这样对<code>sockaddr_in</code>的配置就完成了。</p><h3 id="2-2-1-inet-addr"><a href="#2-2-1-inet-addr" class="headerlink" title="2.2.1 inet_addr"></a>2.2.1 inet_addr</h3><p>这里需要使用<code>inet_addr</code>函数对传入的字符串类型的ip（如<code>192.168.0.1</code>）进行转换</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">in_addr_t</span> <span class="title function_">inet_addr</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *cp)</span>;<span class="comment">//对字符串ip进行转换</span></span><br></pre></td></tr></table></figure><p>因为对于网络来说，它并不认识字符串类型的ip，而是要用网络字节流规定的类型。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Internet address.  */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">uint32_t</span> <span class="type">in_addr_t</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">in_addr</span></span></span><br><span class="line"><span class="class">  &#123;</span></span><br><span class="line">    <span class="type">in_addr_t</span> s_addr;</span><br><span class="line">  &#125;;</span><br></pre></td></tr></table></figure><p>对于该接口的底层做一个简单的说明：其实就是利用<code>位段</code>，将数据转换为一个特殊的类型</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//示例，非底层实现</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ip</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">uint32_t</span> part1:<span class="number">8</span>;</span><br><span class="line">    <span class="type">uint32_t</span> part2:<span class="number">8</span>;</span><br><span class="line">    <span class="type">uint32_t</span> part3:<span class="number">8</span>;</span><br><span class="line">    <span class="type">uint32_t</span> part4:<span class="number">8</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-2-2-inet-ntoa"><a href="#2-2-2-inet-ntoa" class="headerlink" title="2.2.2 inet_ntoa"></a>2.2.2 inet_ntoa</h3><p>同样的，如果我们作为客户端接受到了网络请求中的ip，可以用<code>inet_ntoa</code>将其转换为字符串类型。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> *<span class="title function_">inet_ntoa</span><span class="params">(<span class="keyword">struct</span> in_addr in)</span>;</span><br></pre></td></tr></table></figure><p>这里就引申出了一个问题：返回值的<code>char*</code>是存在哪里的？是静态区还是<code>malloc</code>？</p><p><img                       lazyload                     alt="image"                     data-src="https://img1.musnow.top/i/23/02/202302031015260.png"                      alt="image-20230203101540180"                ></p><p>手册告诉我们，这个函数是维护了一个static变量来存放返回的ip的。</p><p>因此，该函数并<strong>不是一个线程安全</strong>的函数，在<code>APUE</code>中明确标明了这一点</p><hr><h2 id="2-3-bind绑定ip端口"><a href="#2-3-bind绑定ip端口" class="headerlink" title="2.3 bind绑定ip端口"></a>2.3 bind绑定ip端口</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span>          <span class="comment">/* See NOTES */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">bind</span><span class="params">(<span class="type">int</span> sockfd, <span class="type">const</span> <span class="keyword">struct</span> sockaddr *addr,</span></span><br><span class="line"><span class="params">         <span class="type">socklen_t</span> addrlen)</span>;</span><br></pre></td></tr></table></figure><p>这个接口的作用就是指定socket和sockaddr进行绑定。第三个参数是addr元素的大小（不是指针大小，别搞错了）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 2.2 绑定ip端口</span></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">bind</span>(_sockfd,(<span class="type">const</span> <span class="keyword">struct</span> sockaddr *)&amp;local, <span class="built_in">sizeof</span>(local)) == <span class="number">-1</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">logging</span>(FATAL, <span class="string">&quot;bind: %s:%d&quot;</span>, <span class="built_in">strerror</span>(errno), _sockfd);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">logging</span>(DEBUG,<span class="string">&quot;socket bind success: %d&quot;</span>, _sockfd);</span><br></pre></td></tr></table></figure><p>绑定了之后，我们的服务器就配置成功了</p><p>测试一下，可以看到编译没有报错，也能正常运行！</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[muxue@bt-7274:~/git/linux/code/23-02-01 udp]$ make udpServer</span><br><span class="line">g++ -o udpServer udpServer.cpp -std=c++11</span><br><span class="line">[muxue@bt-7274:~/git/linux/code/23-02-01 udp]$ ./udpServer</span><br><span class="line">DEBUG | 1675326460 | muxue | socket create success: 3</span><br><span class="line">DEBUG | 1675326460 | muxue | socket bind success: 3</span><br></pre></td></tr></table></figure><h3 id="2-3-1-main"><a href="#2-3-1-main" class="headerlink" title="2.3.1 main"></a>2.3.1 main</h3><p>现在先来简单写一下main函数中启动服务的命令行参数吧</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc,<span class="type">char</span>* argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//参数只有两个（端口/ip）所以参数个数应该是2-3</span></span><br><span class="line">    <span class="keyword">if</span>(argc!=<span class="number">2</span> &amp;&amp; argc!=<span class="number">3</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Usage: &quot;</span> &lt;&lt; argv[<span class="number">0</span>] &lt;&lt; <span class="string">&quot; port [ip]&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    <span class="built_in">string</span> ip;</span><br><span class="line">    <span class="comment">// 3个参数，有ip</span></span><br><span class="line">    <span class="keyword">if</span>(argc==<span class="number">3</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        ip = argv[<span class="number">2</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    UdpServer <span class="title function_">s</span><span class="params">(atoi(argv[<span class="number">1</span>]),ip)</span>;</span><br><span class="line">    s.start();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为了测试，先把<code>start()</code>函数设置为一个死循环</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">start</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;running &quot;</span> &lt;&lt; getpid() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译运行，可以看到错误提示是可以用的。正确添加参数之后，也能绑定并开始运行</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[muxue@bt-7274:~/git/linux/code/23-02-01 udp]$ make udpServer</span><br><span class="line">g++ -o udpServer udpServer.cpp -std=c++11</span><br><span class="line">[muxue@bt-7274:~/git/linux/code/23-02-01 udp]$ ./udpServer</span><br><span class="line">Usage: ./udpServer port [ip]</span><br><span class="line">[muxue@bt-7274:~/git/linux/code/23-02-01 udp]$ ./udpServer 8080</span><br><span class="line">DEBUG | 1675327610 | muxue | socket create success: 3</span><br><span class="line">DEBUG | 1675327610 | muxue | socket bind success: 3</span><br><span class="line">running 4467</span><br><span class="line">running 4467</span><br><span class="line">running 4467</span><br><span class="line">^C</span><br></pre></td></tr></table></figure><p>注意，<code>bind</code>这个函数是<strong>不允许你绑定云服务器的公网ip的</strong>。因为云服务器并不是直接暴露在公网上的，而是由提供商的入口服务器进入内网，在进入你的服务器。所以他不允许你绑定公网ip；</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ ./udpServer 8080 云服务器公网ip</span><br><span class="line">DEBUG | 1675327690 | muxue | socket create success: 3</span><br><span class="line">FATAL | 1675327690 | muxue | bind: Cannot assign requested address:3</span><br></pre></td></tr></table></figure><p>一般情况下，可以选择不绑定ip，或者绑定本地端口<code>127.0.0.1</code></p><blockquote><p>如果绑定了<code>127.0.0.1</code>，那么服务只有本地可以访问。不绑定端口，就会默认绑定成<code>0.0.0.0</code>，允许本地和远程端口连接</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ ./udpServer 8080 127.0.0.1</span><br><span class="line">DEBUG | 1675327757 | muxue | socket create success: 3</span><br><span class="line">DEBUG | 1675327757 | muxue | socket bind success: 3</span><br><span class="line">running 5067</span><br><span class="line">running 5067</span><br></pre></td></tr></table></figure><h3 id="2-3-2-netstat"><a href="#2-3-2-netstat" class="headerlink" title="2.3.2 netstat"></a>2.3.2 netstat</h3><p>可以用<code>netstat -lnup</code>命令查看当前开放的端口信息</p><p><img                       lazyload                     alt="image"                     data-src="https://img1.musnow.top/i/23/02/202302021651339.png"                      alt="image-20230202165149257"                ></p><p>可以看到，第一行就是我们的udp服务器，本地端口是我们绑定的<code>127.0.0.1:8080</code>，远程端口是<code>0.0.0.0:*</code>，代表允许任何远程ip的任何端口来访问</p><h2 id="2-4-开始运行"><a href="#2-4-开始运行" class="headerlink" title="2.4 开始运行"></a>2.4 开始运行</h2><p>上面的操作只是初始化了这个udp服务器的信息，并没有让它真正的运行起来；</p><p>接下来要做的就是让服务器开始接收信息，并在屏幕上打印出来</p><h3 id="2-4-1-recvfrom"><a href="#2-4-1-recvfrom" class="headerlink" title="2.4.1 recvfrom"></a>2.4.1 recvfrom</h3><p>这个接口的作用是来接收信息</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">ssize_t</span> <span class="title function_">recvfrom</span><span class="params">(<span class="type">int</span> sockfd, <span class="type">void</span> *buf, <span class="type">size_t</span> len, <span class="type">int</span> flags,</span></span><br><span class="line"><span class="params">                 <span class="keyword">struct</span> sockaddr *src_addr, <span class="type">socklen_t</span> *addrlen)</span>;</span><br></pre></td></tr></table></figure><ul><li>第一个参数是前面创建的套接字</li><li>第二个参数是用来接收信息的缓冲区</li><li>第三个参数是缓冲区的大小</li><li>第四个参数是标识符，设置为0，代表<strong>阻塞等待</strong></li><li>第五个参数，输出型参数，获取发送方的信息</li><li>第六个参数，输入输出型参数，需要初始化为<code>sizeof(src_addr)</code></li></ul><p>函数的返回值是接收到的数据的长度，没有接收到或者接受失败，则为<code>-1</code></p><p>示例如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> inBuf[BUF_SIZE];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">peer</span>;</span>      <span class="comment">//输出型参数</span></span><br><span class="line"><span class="type">socklen_t</span> len = <span class="keyword">sizeof</span>(peer); <span class="comment">//输入输出型参数</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// peer和len都是输出型参数，用于获取发送方的信息</span></span><br><span class="line"><span class="comment">// len是输入输出型参数，需要以sizeof(peer)初始化后传入</span></span><br><span class="line"><span class="comment">// 第三个参数0为默认等待方式（阻塞等待）</span></span><br><span class="line"><span class="type">ssize_t</span> s = recvfrom(_sockfd, inBuf, <span class="keyword">sizeof</span>(inBuf)<span class="number">-1</span>,<span class="number">0</span>,(<span class="keyword">struct</span> sockaddr *)&amp;peer, &amp;len);</span><br><span class="line"><span class="keyword">if</span> (s &gt; <span class="number">0</span>) <span class="comment">// s代表获取到的数据长度，不为0代表成功获取</span></span><br><span class="line">&#123;</span><br><span class="line">    inBuf[s] = <span class="string">&#x27;\0&#x27;</span>; <span class="comment">//末尾追加&#x27;\0&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (s == <span class="number">-1</span>) <span class="comment">// -1没有收到信息，错误</span></span><br><span class="line">&#123;</span><br><span class="line">    logging(WARINING, <span class="string">&quot;recvfrom: %s:%d&quot;</span>, strerror(errno), _sockfd);</span><br><span class="line">    <span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样就能在<code>inBuf</code>中直接获取到发送信息的内容</p><h2 id="2-5-服务端start"><a href="#2-5-服务端start" class="headerlink" title="2.5 服务端start"></a>2.5 服务端start</h2><p>以下是服务端运行的完整代码</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">start</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">char</span> inBuf[BUF_SIZE];<span class="comment">//接收到信息的缓冲区</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> peer;      <span class="comment">//输出型参数</span></span><br><span class="line">        <span class="type">socklen_t</span> len = <span class="built_in">sizeof</span>(peer); <span class="comment">//输入输出型参数</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// peer和len都是输出型参数，用于获取发送方的信息</span></span><br><span class="line">        <span class="comment">// len是输入输出型参数，需要以sizeof(peer)初始化后传入</span></span><br><span class="line">        <span class="comment">// 第三个参数0为默认等待方式（阻塞等待）</span></span><br><span class="line">        <span class="type">ssize_t</span> s = <span class="built_in">recvfrom</span>(_sockfd, inBuf, <span class="built_in">sizeof</span>(inBuf)<span class="number">-1</span>,<span class="number">0</span>,(<span class="keyword">struct</span> sockaddr *)&amp;peer, &amp;len);</span><br><span class="line">        <span class="keyword">if</span> (s &gt; <span class="number">0</span>) <span class="comment">// s代表获取到的数据长度，不为0代表成功获取</span></span><br><span class="line">        &#123;</span><br><span class="line">            inBuf[s] = <span class="string">&#x27;\0&#x27;</span>; <span class="comment">//末尾追加&#x27;\0&#x27;</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (s == <span class="number">-1</span>) <span class="comment">// -1没有收到信息，错误</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">logging</span>(WARINING, <span class="string">&quot;recvfrom: %s:%d&quot;</span>, <span class="built_in">strerror</span>(errno), _sockfd);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        string senderIP = <span class="built_in">inet_ntoa</span>(peer.sin_addr);<span class="comment">// 来源ip</span></span><br><span class="line">        <span class="type">uint16_t</span> senderPort = <span class="built_in">ntohs</span>(peer.sin_port); <span class="comment">// 来源端口</span></span><br><span class="line">        <span class="built_in">logging</span>(NOTICE, <span class="string">&quot;[%s:%d]# %s&quot;</span>, senderIP.<span class="built_in">c_str</span>(),senderPort, inBuf);<span class="comment">//打印信息</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果你想让另外一台主机访问这个服务，则需要在<strong>云服务器控制台和linux系统</strong>中同时开放对应的udp端口</p><blockquote><p>参考 <a href="https://blog.musnow.top/2023/01/21/note_linux/24%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%BC%80%E6%94%BE%E7%AB%AF%E5%8F%A3%E9%97%AE%E9%A2%98/">【Linux】设置系统防火墙</a></p></blockquote><h1 id="3-client"><a href="#3-client" class="headerlink" title="3.client"></a>3.client</h1><p>有了服务端，也要有对应的客户端来发送消息；除了发送消息的部分，其余操作和服务端基本一致。</p><h2 id="3-1-sendto"><a href="#3-1-sendto" class="headerlink" title="3.1 sendto"></a>3.1 sendto</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">ssize_t</span> <span class="title function_">send</span><span class="params">(<span class="type">int</span> sockfd, <span class="type">const</span> <span class="type">void</span> *buf, <span class="type">size_t</span> len, <span class="type">int</span> flags)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">ssize_t</span> <span class="title function_">sendto</span><span class="params">(<span class="type">int</span> sockfd, <span class="type">const</span> <span class="type">void</span> *buf, <span class="type">size_t</span> len, <span class="type">int</span> flags,</span></span><br><span class="line"><span class="params">               <span class="type">const</span> <span class="keyword">struct</span> sockaddr *dest_addr, <span class="type">socklen_t</span> addrlen)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">ssize_t</span> <span class="title function_">sendmsg</span><span class="params">(<span class="type">int</span> sockfd, <span class="type">const</span> <span class="keyword">struct</span> msghdr *msg, <span class="type">int</span> flags)</span>;</span><br></pre></td></tr></table></figure><p>这里我们要用的是<code>sendto</code>接口</p><ul><li>第一个参数是socket套接字</li><li>第二个参数是用于输入的缓冲区</li><li>第三个参数是缓冲区的类型</li><li>第四个参数是标识符，也设置为0</li><li>第五个参数和第六个参数与<code>recvfrom</code>一致，为目标服务器的信息</li></ul><p>关于flag参数，man手册中有更多选项，这里我们依旧传入0采用默认策略</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">The flags argument is the bitwise OR of zero or more of the following flags.</span><br></pre></td></tr></table></figure><h2 id="3-2-客户端需不需要手动bind"><a href="#3-2-客户端需不需要手动bind" class="headerlink" title="3.2 客户端需不需要手动bind?"></a>3.2 客户端需不需要手动bind?</h2><p>首先我们要明确一点，bind函数并没有规定一定要是服务端才能使用。也就是说，要不要使用bind是程序猿自己的选择。</p><p>答案其实很简单：那就是不需要手动bind</p><p>首先我们要知道一点：如果一个网络进程在启动的时候没有手动bind端口，系统是会自动分配一个未使用的端口给它的</p><ul><li>对于服务器来说，<code>IP:端口</code>必须固定，否则没有办法给客户端提供稳定的服务。客户又不能拆了你的应用程序修改源码中的端口！</li><li>而对于客户端来说，端口应该让系统自动分配。因为这样能避免冲突问题。不然如果有另外一个应用占用了客户端bind的端口，那这个程序就会因为<strong>端口冲突</strong>而一直打不开！</li></ul><p>所以，客户端不需要我们调用bind函数，只需要配置好服务端的目标ip和目标端口就行了</p><h2 id="3-3-代码示例"><a href="#3-3-代码示例" class="headerlink" title="3.3 代码示例"></a>3.3 代码示例</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cassert&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;strings.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">server</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ./udpClient server_ip server_port</span></span><br><span class="line"><span class="comment">// 客户端要连接server，必须知道server对应的ip和port</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (argc != <span class="number">3</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Usage:\n\t&quot;</span> &lt;&lt; argv[<span class="number">0</span>] &lt;&lt; <span class="string">&quot; server_ip server_port&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 1. 根据命令行，设置要访问的服务器IP</span></span><br><span class="line">    <span class="built_in">string</span> server_ip = argv[<span class="number">1</span>];</span><br><span class="line">    <span class="type">uint16_t</span> server_port = atoi(argv[<span class="number">2</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 创建客户端</span></span><br><span class="line">    <span class="comment">// 2.1 创建socket</span></span><br><span class="line">    <span class="type">int</span> sockfd = socket(AF_INET, SOCK_DGRAM, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(sockfd&lt;<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;socket 创建失败&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    bzero(&amp;server, <span class="keyword">sizeof</span>(server));<span class="comment">//这个函数相当于memset全0</span></span><br><span class="line"></span><br><span class="line">    server.sin_family = AF_INET;<span class="comment">//ipv4</span></span><br><span class="line">    server.sin_port = htons(server_port);<span class="comment">//目标服务器端口</span></span><br><span class="line">    server.sin_addr.s_addr = inet_addr(server_ip.c_str());<span class="comment">//目标ip</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. 通讯过程</span></span><br><span class="line">    <span class="built_in">string</span> buffer;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cerr</span> &lt;&lt; <span class="string">&quot;Please Enter# &quot;</span>;</span><br><span class="line">        getline(<span class="built_in">cin</span>, buffer);</span><br><span class="line">        <span class="comment">// 发送消息给server</span></span><br><span class="line">        sendto(sockfd, buffer.c_str(), buffer.size(), <span class="number">0</span>,</span><br><span class="line">               (<span class="type">const</span> <span class="keyword">struct</span> sockaddr *)&amp;server, <span class="keyword">sizeof</span>(server)); </span><br><span class="line">        <span class="comment">// 首次调用sendto函数的时候，client会自动bind自己的ip和port</span></span><br><span class="line">        <span class="comment">// 客户端不应该自己绑定端口，否则端口被占用=客户端不能用</span></span><br><span class="line">    &#125;</span><br><span class="line">    close(sockfd);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-4-运行测试"><a href="#3-4-运行测试" class="headerlink" title="3.4 运行测试"></a>3.4 运行测试</h2><p>这里提供一个makefile，来快速编译服务端&#x2F;客户端的源码</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"><span class="keyword">.PHONY</span>:all</span></span><br><span class="line"><span class="section">all:udpClient udpServer</span></span><br><span class="line"></span><br><span class="line"><span class="section">udpClient: udpClient.cpp</span></span><br><span class="line">g++ -o <span class="variable">$@</span> <span class="variable">$^</span> -std=c++11 -lpthread</span><br><span class="line"><span class="section">udpServer:udpServer.cpp</span></span><br><span class="line">g++ -o <span class="variable">$@</span> <span class="variable">$^</span> -std=c++11</span><br><span class="line"></span><br><span class="line"><span class="meta"><span class="keyword">.PHONY</span>:clean</span></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">rm -f udpClient udpServer</span><br></pre></td></tr></table></figure><p>运行服务器，指定8080端口启动。再运行客户端，指定<code>127.0.0.1</code>本地ip和8080端口</p><p><img                       lazyload                     alt="image"                     data-src="https://img1.musnow.top/i/23/02/202302022129061.png"                      alt="image-20230202212859925"                ></p><p>可以看到，右侧我们收到的信息，都在左侧被打印了出来，同时显示了来源ip和端口</p><h2 id="3-5-windows客户端"><a href="#3-5-windows客户端" class="headerlink" title="3.5 windows客户端"></a>3.5 windows客户端</h2><p>让我没想到的是，windows上网络的接口和linux很相似；这里提供一个windows下的udp客户端，向我们的云服务器发送信息</p><p>注：进行测试前，一定要在防火墙里面开放云服务器对应的udp端口</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _WINSOCK_DEPRECATED_NO_WARNINGS 1<span class="comment">//屏蔽报错</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;winsock2.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> comment(lib,<span class="string">&quot;ws2_32.lib&quot;</span>)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BUFFER_SIZE  1024    <span class="comment">//缓冲区大小</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    WSADATA WSAData;</span><br><span class="line">    <span class="comment">//初始化</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">WSAStartup</span>(<span class="built_in">MAKEWORD</span>(<span class="number">2</span>, <span class="number">2</span>), &amp;WSAData) != <span class="number">0</span>) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;初始化失败!&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;    </span><br><span class="line">    <span class="comment">//创建客户端用于通信的Socket</span></span><br><span class="line">    SOCKET sock_Client = <span class="built_in">socket</span>(AF_INET, SOCK_DGRAM, IPPROTO_UDP);</span><br><span class="line">    <span class="comment">//服务器的地址数据结构</span></span><br><span class="line">    SOCKADDR_IN addr_server;   </span><br><span class="line">    addr_server.sin_family = AF_INET;</span><br><span class="line">    addr_server.sin_port = <span class="built_in">htons</span>(<span class="number">10000</span>);<span class="comment">// 目标端口</span></span><br><span class="line">    addr_server.sin_addr.S_un.S_addr = <span class="built_in">inet_addr</span>(<span class="string">&quot;127.0.0.1&quot;</span>); <span class="comment">//目标公网ip(需要改成你自己的)</span></span><br><span class="line"></span><br><span class="line">    string sendBuf;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) </span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;请输入要传送的数据: &quot;</span>;</span><br><span class="line">        <span class="built_in">getline</span>(cin,sendBuf);</span><br><span class="line">        <span class="built_in">sendto</span>(sock_Client, sendBuf.<span class="built_in">c_str</span>(),sendBuf.<span class="built_in">size</span>(), <span class="number">0</span>, (<span class="type">const</span> SOCKADDR*)&amp;addr_server, <span class="built_in">sizeof</span>(addr_server));</span><br><span class="line">        cout &lt;&lt; sendBuf.<span class="built_in">size</span>() &lt;&lt; <span class="string">&quot;: &quot;</span> &lt;&lt; sendBuf &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">closesocket</span>(sock_Client);</span><br><span class="line">    <span class="built_in">WSACleanup</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试一下，可以看到云服务器成功收到了信息，但因为windows和linux的文字编码问题，没能正确显示出中文</p><p><img                       lazyload                     alt="image"                     data-src="https://img1.musnow.top/i/23/02/202302022133966.png"                      alt="image-20230202213301914"                ></p><p>发送英文信息是没有问题的！</p><p><img                       lazyload                     alt="image"                     data-src="https://img1.musnow.top/i/23/02/202302022133864.png"                      alt="image-20230202213359805"                ></p><h1 id="4-更进一步"><a href="#4-更进一步" class="headerlink" title="4.更进一步"></a>4.更进一步</h1><h2 id="4-1-记录用户"><a href="#4-1-记录用户" class="headerlink" title="4.1 记录用户"></a>4.1 记录用户</h2><p>有用户给你发送信息，理论上来说，服务端应该记录下用户，以备debug;</p><p>这部分并不难，我们记录下用户的ip和端口，还有用户的peer结构体，在服务器里面维护一个map来存放就可以了</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">CheckUser</span><span class="params">(<span class="keyword">struct</span> sockaddr_in peer)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    string tmp = <span class="built_in">inet_ntoa</span>(peer.sin_addr);<span class="comment">// 来源ip</span></span><br><span class="line">    tmp += <span class="string">&#x27;:&#x27;</span>;</span><br><span class="line">    tmp += <span class="built_in">to_string</span>(<span class="built_in">ntohs</span>(peer.sin_port));<span class="comment">// 来源端口</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在map中用ip端口来标识用户</span></span><br><span class="line">    <span class="keyword">auto</span> it = _usrMap.<span class="built_in">find</span>(tmp);</span><br><span class="line">    <span class="keyword">if</span>(it == _usrMap.<span class="built_in">end</span>())<span class="comment">// 没找到</span></span><br><span class="line">    &#123;</span><br><span class="line">        _usrMap.<span class="built_in">insert</span>(&#123;tmp,peer&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-2-客户端接收回信"><a href="#4-2-客户端接收回信" class="headerlink" title="4.2 客户端接收回信"></a>4.2 客户端接收回信</h2><p>客户端发送信息给服务器后，可以来接收一下服务器的回信。比如在日常生活中，我们发邮件的时候，需要等待对方回信，这才表明你的信对方确实收到了，而不是丢在半路上了</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用多线程操作，来获取服务器传回的信息</span></span><br><span class="line"><span class="type">pthread_t</span> t;</span><br><span class="line">pthread_create(&amp;t, nullptr, recverAndPrint, (<span class="type">void</span> *)&amp;sockfd);</span><br></pre></td></tr></table></figure><p>为了方便，这里采用多线程的方式来操作；客户端在接收到服务器的回信后，会打印出来</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> *<span class="title">recverAndPrint</span><span class="params">(<span class="type">void</span> *args)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> sockfd = *(<span class="type">int</span> *)args;</span><br><span class="line">        <span class="type">char</span> buffer[<span class="number">1024</span>];</span><br><span class="line">        <span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> temp;</span><br><span class="line">        <span class="type">socklen_t</span> len = <span class="built_in">sizeof</span>(temp);</span><br><span class="line">        <span class="type">ssize_t</span> s = <span class="built_in">recvfrom</span>(sockfd, buffer, <span class="built_in">sizeof</span>(buffer), <span class="number">0</span>, (<span class="keyword">struct</span> sockaddr *)&amp;temp, &amp;len);</span><br><span class="line">        <span class="keyword">if</span> (s &gt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            buffer[s] = <span class="number">0</span>;<span class="comment">//将接收到的信息打印出来（服务器返回的）</span></span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;server echo# &quot;</span> &lt;&lt; buffer &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-3-消息路由"><a href="#4-3-消息路由" class="headerlink" title="4.3 消息路由"></a>4.3 消息路由</h2><p>所谓消息路由，就是把接收到的消息广播给所有用户。可以理解为一个简单的聊天室。</p><p>上面我们已经获取并记录了信息，下面要做的就是把信息重新发给其他用户；操作和客户端的发送是一样的</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">MsgRoute</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* inBuf,<span class="type">size_t</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> user;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> e:_usrMap)</span><br><span class="line">    &#123;</span><br><span class="line">        user.sin_family = AF_INET;<span class="comment">//ipv4</span></span><br><span class="line">        user.sin_port = e.second.sin_port;<span class="comment">//用户端口</span></span><br><span class="line">        user.sin_addr.s_addr = e.second.sin_addr.s_addr;<span class="comment">//用户ip</span></span><br><span class="line">        <span class="comment">// 向用户发送信息</span></span><br><span class="line">        <span class="built_in">sendto</span>(_sockfd, inBuf, len, <span class="number">0</span>,</span><br><span class="line">               (<span class="type">const</span> <span class="keyword">struct</span> sockaddr *)&amp;user, <span class="built_in">sizeof</span>(user)); </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试，可以看到，服务端把收到的消息发送给了用户</p><p><img                       lazyload                     alt="image"                     data-src="https://img1.musnow.top/i/23/02/202302031037760.png"                      alt="image-20230203103733686"                ></p><p>再新增一个客户端进行测试，可以看到两个客户都收到了服务器的回信</p><p><img                       lazyload                     alt="image"                     data-src="https://img1.musnow.top/i/23/02/202302031040599.png"                      alt="image-20230203104025510"                ></p><p>这里对于聊天室来说还有一个小问题，那就是聊天框里面并不会二次出现你的消息。也就是服务器不会把你发送的消息再转发给你。</p><p>我们在消息路由函数里面进行判断即可！</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">MsgRoute</span><span class="params">(<span class="keyword">struct</span> sockaddr_in peer,<span class="type">const</span> <span class="type">char</span>* inBuf,<span class="type">size_t</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> user;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> e:_usrMap)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 如果ip和端口都相等，就代表是发送消息的用户</span></span><br><span class="line">        <span class="keyword">if</span>(e.second.sin_port != peer.sin_port || e.second.sin_addr.s_addr != peer.sin_addr.s_addr)</span><br><span class="line">        &#123;</span><br><span class="line">            user.sin_family = AF_INET;<span class="comment">//ipv4</span></span><br><span class="line">            user.sin_port = e.second.sin_port;<span class="comment">//用户端口</span></span><br><span class="line">            user.sin_addr.s_addr = e.second.sin_addr.s_addr;<span class="comment">//用户ip</span></span><br><span class="line">            <span class="comment">// 向用户发送信息</span></span><br><span class="line">            <span class="built_in">sendto</span>(_sockfd, inBuf, len, <span class="number">0</span>,</span><br><span class="line">                   (<span class="type">const</span> <span class="keyword">struct</span> sockaddr *)&amp;user, <span class="built_in">sizeof</span>(user)); </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为乱序打印的问题，所以看的可能不是很明显。但是我们的目的已经达到了！</p><p><img                       lazyload                     alt="image"                     data-src="https://img1.musnow.top/i/23/02/202302031045691.png"                      alt="image-20230203104506634"                ></p><p>这样打印看的不是很清楚，可以使用管道文件来实现输出重定向</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">mkfifo</span> fifo <span class="comment">#创建一个fifo管道文件</span></span><br></pre></td></tr></table></figure><p>运行客户端的时候，指定输出</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./udpClient 127.0.0.1 1000 &gt; fifo</span><br></pre></td></tr></table></figure><p>在另外一个bash里面，用cat来获取输出</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat &lt; fifo</span><br></pre></td></tr></table></figure><p>这就不会出现乱序打印的问题了。</p><p><code>fifo</code>是一个管道文件，需要执行cat后（读端），客户端（写端）才能运行</p><h1 id="5-more…"><a href="#5-more…" class="headerlink" title="5.more…"></a>5.more…</h1><p>关于udp编程的操作到这里就Over啦，现在我们认识了大部分的网络接口，下一步的目标，就是实现tcp服务器啦！</p><p><img                       lazyload                     alt="image"                     data-src="https://img1.musnow.top/i/23/02/202211031202574.jpg"                      alt="QQ图片20220416195218"                ></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;来写一个udp的代码&lt;/p&gt;</summary>
    
    
    
    <category term="玩上Linux" scheme="https://blog.musnow.top/categories/%E7%8E%A9%E4%B8%8ALinux/"/>
    
    
    <category term="Linux" scheme="https://blog.musnow.top/tags/Linux/"/>
    
    <category term="线程" scheme="https://blog.musnow.top/tags/%E7%BA%BF%E7%A8%8B/"/>
    
    <category term="网络" scheme="https://blog.musnow.top/tags/%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>【Linux】man什么都搜不了，No manual entry for xxx的解决方案</title>
    <link href="https://blog.musnow.top/2023/02/01/note_Linux/28man%E4%BB%80%E4%B9%88%E9%83%BD%E6%90%9C%E4%B8%8D%E4%BA%86%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/"/>
    <id>https://blog.musnow.top/2023/02/01/note_Linux/28man%E4%BB%80%E4%B9%88%E9%83%BD%E6%90%9C%E4%B8%8D%E4%BA%86%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/</id>
    <published>2023-02-01T07:28:54.000Z</published>
    <updated>2023-02-06T05:33:14.184Z</updated>
    
    <content type="html"><![CDATA[<p>man什么都搜不了，<code>No manual entry for xxx</code>的解决方案</p><span id="more"></span><blockquote><p>系统 <code>CentOS 7.6</code></p></blockquote><h1 id="1-问题描述"><a href="#1-问题描述" class="headerlink" title="1.问题描述"></a>1.问题描述</h1><p>今天查手册的时候，发现man什么都查不了。不管是系统接口还是函数，都显示没有入口文档（No manual entry for）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[muxue@bt-7274:~/git]$ man pthread_create</span><br><span class="line">No manual entry for pthread_create</span><br><span class="line">[muxue@bt-7274:~/git]$ man bind</span><br><span class="line">No manual entry for bind</span><br><span class="line">[muxue@bt-7274:~/git]$ man man</span><br><span class="line">No manual entry for man</span><br><span class="line">[muxue@bt-7274:~/git]$ man ls</span><br><span class="line">No manual entry for ls</span><br></pre></td></tr></table></figure><p>这可得难受了，要知道，我的博客里面关于接口定义的说明，很多都是从man手册里面复制出来的。</p><p>在root下尝试了安装，并<code>yum update</code>更新之后，还是无法使用</p><p><img                       lazyload                     alt="image"                     data-src="https://img1.musnow.top/i/23/02/20234f1dfd4135534d9e10641d4cf6d78ad9.png"                      alt="image-20230201172842758"                ></p><p>于是我就去stackoverflow提了个问题 【<a class="link"   href="https://stackoverflow.com/questions/75306427/centos7-6-no-manual-entry-for-any-command/75307997#75307997" >点我<i class="fas fa-external-link-alt"></i></a>】 然后又自己解决了这个问题😂</p><h1 id="2-解决"><a href="#2-解决" class="headerlink" title="2.解决"></a>2.解决</h1><p>感谢kook频道的大佬，一眼就看出来这个是<strong>环境变量</strong>的问题</p><h2 id="2-1-重装man"><a href="#2-1-重装man" class="headerlink" title="2.1 重装man"></a>2.1 重装man</h2><p>先试试<code>reinstall</code>重装</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum reinstall man-pages</span><br></pre></td></tr></table></figure><p><img                       lazyload                     alt="image"                     data-src="https://img1.musnow.top/i/23/02/20233fb444672228130fbb49fa9e30f094db.png"                      alt="image-20230201172950992"                ></p><h2 id="2-2-查看环境变量"><a href="#2-2-查看环境变量" class="headerlink" title="2.2 查看环境变量"></a>2.2 查看环境变量</h2><p>安装完毕，查看<code>MANPATH</code>的环境变量，可以看到当前指向的是<code>devtoolset-11</code>里面的man</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># echo $MANPATH</span><br><span class="line">/opt/rh/devtoolset-11/root/usr/share/man</span><br></pre></td></tr></table></figure><p>罪魁祸首就找到了！几天前，我升级了云服务器的gcc版本【<a href="https://blog.musnow.top/2023/01/31/note_linux/26%E5%8D%87%E7%BA%A7gcc/">教程</a>】当时安装的就是<code>devtoolset-11</code>；</p><p>所以，情况就是升级的过程中，man的环境变量被修改了！</p><p>我们要做的就是给他改回来</p><h2 id="2-3-修改成正确的环境变量"><a href="#2-3-修改成正确的环境变量" class="headerlink" title="2.3 修改成正确的环境变量"></a>2.3 修改成正确的环境变量</h2><p>先用<code>whereis man</code>找一下man的安装路径，一般都是<code>/usr/share/man</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># whereis man</span><br><span class="line">man: /usr/bin/man /usr/share/man /usr/share/man/man7/man.7.gz /usr/share/man/man1/man.1.gz /usr/share/man/man1p/man.1p.gz</span><br></pre></td></tr></table></figure><p>将<code>/usr/share/man</code>导入到环境变量</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">export MANPATH=/usr/share/man</span><br></pre></td></tr></table></figure><p>此时再man，发现已经活过来了</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">man man</span><br></pre></td></tr></table></figure><p><img                       lazyload                     alt="image"                     data-src="https://img1.musnow.top/i/23/02/2023d40e2420e1cb2bcb833a7b26cc1fda3d.png"                      alt="image-20230201174145668"                ></p><h2 id="2-4-永久生效"><a href="#2-4-永久生效" class="headerlink" title="2.4 永久生效"></a>2.4 永久生效</h2><p><code>export MANPATH=/usr/share/man</code>只是暂时修改当前bash的环境变量，要想完全生效，需要修改bash的配置文件</p><p>注意：修改配置文件之前，一定要cp进行备份，避免修改boom！</p><ul><li>用户目录下的<code>.bashrc</code></li></ul><p>在里面添加如下命令</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MANPATH=/usr/share/man</span><br></pre></td></tr></table></figure><p>然后再<code>source</code>使其生效</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">source .bashrc</span><br></pre></td></tr></table></figure><p>此时，当前用户的bash就能正常使用man了，但是其他用户还是不行。这就需要我们修改系统的配置文件</p><ul><li>系统配置文件<code>/etc/bashrc</code></li></ul><p>注意，系统的配置文件需要输入的是命令。在新建bash的时候会执行。如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">export MANPATH=/usr/share/man</span><br></pre></td></tr></table></figure><p>同样的，<code>source</code>使其生效</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">source /etc/bashrc</span><br></pre></td></tr></table></figure><p>现在就OK了！此时其他用户也能正常使用man了</p><p><img                       lazyload                     alt="image"                     data-src="https://img1.musnow.top/i/23/02/202381ed4687d2271277a05c57ee4ea3f8eb.png"                      alt="image-20230201174533765"                ></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;man什么都搜不了，&lt;code&gt;No manual entry for xxx&lt;/code&gt;的解决方案&lt;/p&gt;</summary>
    
    
    
    <category term="玩上Linux" scheme="https://blog.musnow.top/categories/%E7%8E%A9%E4%B8%8ALinux/"/>
    
    
    <category term="Linux" scheme="https://blog.musnow.top/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>【Linux】CentOS7.6 升级 gcc/g++</title>
    <link href="https://blog.musnow.top/2023/01/31/note_Linux/26%E5%8D%87%E7%BA%A7gcc/"/>
    <id>https://blog.musnow.top/2023/01/31/note_Linux/26%E5%8D%87%E7%BA%A7gcc/</id>
    <published>2023-01-31T06:53:33.000Z</published>
    <updated>2023-02-06T05:33:14.182Z</updated>
    
    <content type="html"><![CDATA[<p><code>CentOS 7.6</code> 升级 gcc&#x2F;g++的方法，不一定适用于其他linux系统</p><span id="more"></span><h1 id="1-查看版本"><a href="#1-查看版本" class="headerlink" title="1.查看版本"></a>1.查看版本</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">g++ -v</span><br><span class="line">gcc -v</span><br></pre></td></tr></table></figure><p>当前查看版本，发现是<code>4.8.5</code>，这已经是2015年的旧版本了，对<code>c++11</code>的支持不是很完善，为了方便学习和编写新版本的代码，升级一下还是可以的</p><p>如果你的系统上没有gcc&#x2F;g++，则尝试用下面的方法安装</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install -y gcc gcc-c++</span><br></pre></td></tr></table></figure><p>示例</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">[root@bt-7274:~]# yum install -y gcc gcc-c++</span><br><span class="line">Loaded plugins: fastestmirror, langpacks, product-id, search-disabled-repos, subscription-manager</span><br><span class="line"></span><br><span class="line">This system is not registered with an entitlement server. You can use subscription-manager to register.</span><br><span class="line"></span><br><span class="line">Repository epel is listed more than once in the configuration</span><br><span class="line">Loading mirror speeds from cached hostfile</span><br><span class="line"> * centos-sclo-rh: ftp.sjtu.edu.cn</span><br><span class="line"> * centos-sclo-sclo: ftp.sjtu.edu.cn</span><br><span class="line">Package gcc-4.8.5-44.el7.x86_64 already installed and latest version</span><br><span class="line">Package gcc-c++-4.8.5-44.el7.x86_64 already installed and latest version</span><br><span class="line">Nothing to do</span><br></pre></td></tr></table></figure><h1 id="2-升级"><a href="#2-升级" class="headerlink" title="2.升级"></a>2.升级</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum list dev\*gcc</span><br></pre></td></tr></table></figure><p>用这个命令查看可以安装的版本有哪些</p><p><img                       lazyload                     alt="image"                     data-src="https://img1.musnow.top/i/23/02/2023e2d07ed5ccb26478c7cdbeec0390128b.png"                      alt="image-20230131152231287"                ></p><p>可以看到最新版本已经是11了，那我们就直接安装最新版本的吧</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install devtoolset-11-gcc devtoolset-11-gcc-c++</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Installed:</span><br><span class="line">  devtoolset-11-gcc.x86_64 0:11.2.1-9.1.el7                                                     devtoolset-11-gcc-c++.x86_64 0:11.2.1-9.1.el7                                                    </span><br><span class="line"></span><br><span class="line">Dependency Installed:</span><br><span class="line">  devtoolset-11-binutils.x86_64 0:2.36.1-1.el7.2                 devtoolset-11-libstdc++-devel.x86_64 0:11.2.1-9.1.el7                 devtoolset-11-runtime.x86_64 0:11.1-2.el7                </span><br><span class="line"></span><br><span class="line">Complete!</span><br></pre></td></tr></table></figure><p>看到<code>complete</code>就代表安装over了</p><h1 id="3-生效"><a href="#3-生效" class="headerlink" title="3.生效"></a>3.生效</h1><p>现在要做的就是让新安装的版本生效</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">source /opt/rh/devtoolset-11/enable</span><br></pre></td></tr></table></figure><p><img                       lazyload                     alt="image"                     data-src="https://img1.musnow.top/i/23/02/2023353e2912ec1b34749038460d695ec896.png"                      alt="image-20230131152404244"                ></p><p>不过这样做，只能在当前bash生效，新建一个bash就会发现还是<code>4.8.5</code>。要做的就是吧这个语句写入bashrc的配置文件中，让每次新建bash的时候自动执行一次就OK了</p><p>要修改的是<code>/etc/bashrc</code>，强烈建议修改之前先备份一下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cp /etc/bashrc ~/bashrc.bak</span><br></pre></td></tr></table></figure><p>随后执行下面俩命令</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">echo &quot;source /opt/rh/devtoolset-11/enable&quot; &gt;&gt; /etc/bashrc</span><br><span class="line">source /etc/bashrc</span><br></pre></td></tr></table></figure><p>现在就OK了，新建一个bash，再<code>gcc -v</code>，发现已经是新版本了</p><p><img                       lazyload                     alt="image"                     data-src="https://img1.musnow.top/i/23/02/2023e4a9daec01153873216cb998d3fafa39.png"                      alt="image-20230131152622618"                ></p><h1 id="4-关于man失效问题"><a href="#4-关于man失效问题" class="headerlink" title="4.关于man失效问题"></a>4.关于man失效问题</h1><p>升级了版本后，可能导致man手册失效。这是因为man的环境变量被修改了</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># echo $MANPATH</span><br><span class="line">/opt/rh/devtoolset-11/root/usr/share/man</span><br></pre></td></tr></table></figure><p>如果你需要使用man命令，则还需要重新修改一下<code>MANPATH</code>环境变量</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">export MANPATH=/usr/share/man</span><br></pre></td></tr></table></figure><p>解决参考 <a href="https://blog.musnow.top/2023/02/01/note_linux/28man%E4%BB%80%E4%B9%88%E9%83%BD%E6%90%9C%E4%B8%8D%E4%BA%86%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/">man什么都搜不了的解决方案</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;code&gt;CentOS 7.6&lt;/code&gt; 升级 gcc&amp;#x2F;g++的方法，不一定适用于其他linux系统&lt;/p&gt;</summary>
    
    
    
    <category term="玩上Linux" scheme="https://blog.musnow.top/categories/%E7%8E%A9%E4%B8%8ALinux/"/>
    
    
    <category term="Linux" scheme="https://blog.musnow.top/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>【Vercel】教你部署imsyy/home个人主页</title>
    <link href="https://blog.musnow.top/2023/01/29/docker/6vercel%E9%83%A8%E7%BD%B2home/"/>
    <id>https://blog.musnow.top/2023/01/29/docker/6vercel%E9%83%A8%E7%BD%B2home/</id>
    <published>2023-01-29T03:01:28.000Z</published>
    <updated>2023-02-19T05:55:55.572Z</updated>
    
    <content type="html"><![CDATA[<p>本篇博客教你如何部署一个自己的个人主页</p><p>项目地址：<a class="link"   href="https://github.com/imsyy/home" >https://github.com/imsyy/home<i class="fas fa-external-link-alt"></i></a></p><span id="more"></span><h1 id="1-fork仓库-vercel部署"><a href="#1-fork仓库-vercel部署" class="headerlink" title="1.fork仓库+vercel部署"></a>1.fork仓库+vercel部署</h1><p>首先我们点击fork，将仓库复刻到自己的账户</p><p><img                       lazyload                     alt="image"                     data-src="https://img1.musnow.top/i/23/02/2023aba411b0ac6370303c705e2f480036f1.png"                      alt="image-20230129110045979"                ></p><p>随后进入vercel，点击<code>dashboard-add new-project</code></p><p><img                       lazyload                     alt="image"                     data-src="https://img1.musnow.top/i/23/02/2023ce424f9c15949615acc3101c594d7c50.png"                      alt="image-20230129105710157"                ></p><p>选择你复刻的仓库</p><p><img                       lazyload                     alt="image"                     data-src="https://img1.musnow.top/i/23/02/202351daf52ab8c4cd540f926b05586fb72f.png"                      alt="image-20230129105752537"                ></p><p>然后什么都不用改，直接deploy</p><p><img                       lazyload                     alt="image"                     data-src="https://img1.musnow.top/i/23/02/2023e67fd53c570dcc1f1320208457df0561.png"                      alt="image-20230129105758875"                ></p><p>等待部署成功，点击domains，在这里添加个<strong>你自己的域名</strong>+解析。否则vercel默认的域名<strong>无法直接访问</strong></p><p><img                       lazyload                     alt="image"                     data-src="https://img1.musnow.top/i/23/02/20237643e5a077d24cf9f1b7e6ed0f1f8c29.png"                      alt="image-20230129105917245"                ></p><p>到这里就已经部署成功了，可以不用管vercel了；</p><p><strong>克隆</strong>下我们fork的仓库，接下来就是修改配置文件！</p><blockquote><p>备注，env中已有的配置在这里不提</p></blockquote><h2 id="1-1-本地预览"><a href="#1-1-本地预览" class="headerlink" title="1.1 本地预览"></a>1.1 本地预览</h2><p>本地预览需要我们在本地安装好<code>node.js</code>环境以及npm包管理器，随后安装yarn</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install yarn</span><br></pre></td></tr></table></figure><p>安装完成后，先执行<code>yarn install</code>安装依赖项</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yarn install</span><br></pre></td></tr></table></figure><p>依赖项搞定了，用dev查看预览页面</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yarn dev</span><br></pre></td></tr></table></figure><p>注意，第一次查看预览页面的时候，加载会非常慢，这是正常情况</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">VITE v3.1.8  ready in 844 ms</span><br><span class="line"></span><br><span class="line">➜  Local:   http://127.0.0.1:3000/                       </span><br><span class="line">➜  Network: use --host to expose    </span><br></pre></td></tr></table></figure><p>后续的修改，可以先在本地预览成功后，再部署到vercel</p><hr><h2 id="1-2-部署到云服务器"><a href="#1-2-部署到云服务器" class="headerlink" title="1.2 部署到云服务器"></a>1.2 部署到云服务器</h2><p>如果你想部署到云服务器，则使用</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yarn build</span><br></pre></td></tr></table></figure><p>会生成一个<code>dist</code>文件夹，弄到云服务器上就可以了（不会用，没试过）</p><h2 id="1-3-vercel访问问题"><a href="#1-3-vercel访问问题" class="headerlink" title="1.3 vercel访问问题"></a>1.3 vercel访问问题</h2><p>如果根据上面的步骤设置了解析后，还是出现访问缓慢甚至无法访问的问题，可以将域名的A或者cname解析更改为下面的国内访问较快的解析</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">76.223.126.88</span><br><span class="line">cname-china.vercel-dns.com</span><br></pre></td></tr></table></figure><p><img                       lazyload                     alt="image"                     data-src="https://img1.musnow.top/i/23/02/63f1b9de1ee49.png"                      alt="image-20230219135544219"                ></p><h1 id="2-社交链接"><a href="#2-社交链接" class="headerlink" title="2.社交链接"></a>2.社交链接</h1><p>这里光是修改<code>.env</code>是不够的，因为作者暂时还没有写社交链接的判断，即便你把所有社交链接的环境变量都注释掉，他还是会显示出来</p><p>这里需要我们修改代码，不算难，一步一步来就行</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">src\components\SocialLinks\index.vue</span><br></pre></td></tr></table></figure><p>打开这个文件，最顶部是<code>&lt;/template&gt;</code>包裹的一个<code>div</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;!-- 社交链接 --&gt;</span><br><span class="line">  &lt;div class=&quot;social&quot;&gt;</span><br><span class="line">  ....</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br></pre></td></tr></table></figure><p>我们需要修改的就是这里面的代码</p><h2 id="2-1-注释掉不需要的"><a href="#2-1-注释掉不需要的" class="headerlink" title="2.1 注释掉不需要的"></a>2.1 注释掉不需要的</h2><p>比如下面这一个<code>&lt;a &lt;/a&gt; </code>包裹的就是tg的社交链接。如果你不需要，那就直接把它注释掉</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- &lt;a</span><br><span class="line">   id=&quot;telegram&quot;</span><br><span class="line">   :href=&quot;socialLinks.telegram&quot;</span><br><span class="line">   target=&quot;_blank&quot;</span><br><span class="line">   @mouseenter=&quot;changeTip&quot;</span><br><span class="line">   @mouseleave=&quot;leaveTip&quot;</span><br><span class="line">   &gt;</span><br><span class="line">    &lt;Icon size=&quot;24&quot;&gt;</span><br><span class="line">        &lt;Telegram /&gt;</span><br><span class="line">    &lt;/Icon&gt;</span><br><span class="line">&lt;/a&gt; --&gt;</span><br></pre></td></tr></table></figure><h2 id="2-2-增加没有的社交链接"><a href="#2-2-增加没有的社交链接" class="headerlink" title="2.2 增加没有的社交链接"></a>2.2 增加没有的社交链接</h2><p>根据上面这个模板的格式，我们可以新增自己需要的社交链接，比如我就新增了一个gitee的链接。需要修改的只有<code>id</code>和<code>icon</code>里面的图标名字<code>GitSquare</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;a</span><br><span class="line">  id=&quot;gitee&quot;</span><br><span class="line">  :href=&quot;socialLinks.gitee&quot;</span><br><span class="line">  target=&quot;_blank&quot;</span><br><span class="line">  @mouseenter=&quot;changeTip&quot;</span><br><span class="line">  @mouseleave=&quot;leaveTip&quot;</span><br><span class="line">&gt;</span><br><span class="line">  &lt;Icon size=&quot;24&quot;&gt;</span><br><span class="line">    &lt;GitSquare /&gt;</span><br><span class="line">  &lt;/Icon&gt;</span><br><span class="line">&lt;/a&gt;</span><br></pre></td></tr></table></figure><p>这里的Icon图标都是从一个本地文件导入的，文件路径为</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">node_modules\@vicons\fa\es\index.d.ts</span><br></pre></td></tr></table></figure><p>你可以在这里面<strong>搜索已有的图标名字</strong>，并回到社交链接的 <code>src\components\SocialLinks\index.vue</code> 文件，修改如图所示的代码，新增图标（必须要在这里新增， 再去html里面引用）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">import &#123; Github, Qq, Telegram, Twitter,GitSquare &#125; from &quot;@vicons/fa&quot;;</span><br></pre></td></tr></table></figure><p><img                       lazyload                     alt="image"                     data-src="https://img1.musnow.top/i/23/02/2023cdb8da0fce5407b8f77e4363d2a21efd.png"                      alt="image-20230129110914215"                ></p><p>最后，在TipData中新增一个点击会显示的文字，这里的id要和上面写的一样</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">let socialTipData = &#123;</span><br><span class="line">  github: &quot;去 Github 看看&quot;,</span><br><span class="line">  gitee: &quot;去 Gitee 看看&quot;,</span><br><span class="line">  qq: &quot;有什么事吗&quot;,</span><br><span class="line">  email: &quot;来封 Email&quot;,</span><br><span class="line">  telegram: &quot;你懂的 ~&quot;,</span><br><span class="line">  twitter: &quot;你懂的 ~&quot;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在社交链接的地址里面，新增gitee的地址，参考已有的github的地址的写法</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">const socialLinks = reactive(&#123;</span><br><span class="line">  github: &quot;https://github.com/&quot; + import.meta.env.VITE_SOCIAL_GITHUB,</span><br><span class="line">  gitee: &quot;https://gitee.com/&quot; + import.meta.env.VITE_SOCIAL_GITEE,</span><br><span class="line">  ...</span><br></pre></td></tr></table></figure><p>最后，还需要在鼠标移入移出事件中，新增一个case，照着已有的抄就行</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">case &quot;gitee&quot;:</span><br><span class="line">  socialTip.value = socialTipData.gitee;</span><br><span class="line">  return true;</span><br></pre></td></tr></table></figure><p>最后的最后，回到<code>.env</code>环境变量，新增一个<code>VITE_SOCIAL_GITEE</code>，填写你的gitee用户名</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">VITE_SOCIAL_GITEE = &quot;ewait&quot;</span><br></pre></td></tr></table></figure><p>搞定啦！</p><p><img                       lazyload                     alt="image"                     data-src="https://img1.musnow.top/i/23/02/2023bb64405854c6b13bed42cadd891f5636.png"                      alt="image-20230129111632726"                ></p><h2 id="2-3-添加没有的icon"><a href="#2-3-添加没有的icon" class="headerlink" title="2.3 添加没有的icon"></a>2.3 添加没有的icon</h2><p>如果一个图标在本地路径没有，可以试着用下面的办法导入一个本地图片，或者是图片url</p><p>本地图片的存储路径为<code>public/images/</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;a</span><br><span class="line">  id=&quot;gitee&quot;</span><br><span class="line">  :href=&quot;socialLinks.gitee&quot;</span><br><span class="line">  target=&quot;_blank&quot;</span><br><span class="line">  @mouseenter=&quot;changeTip&quot;</span><br><span class="line">  @mouseleave=&quot;leaveTip&quot;</span><br><span class="line">&gt;</span><br><span class="line">  &lt;img </span><br><span class="line">    src=&quot;/images/icon/gitee.png&quot; height=&quot;24&quot;</span><br><span class="line">  /&gt;</span><br><span class="line">&lt;/a&gt;</span><br></pre></td></tr></table></figure><p>但是上面这样弄会有边距问题，可以看到gitee和qq之间的边距比右侧更短，暂时没找到解决办法</p><p><img                       lazyload                     alt="image"                     data-src="https://img1.musnow.top/i/23/02/2023f12fd716cf6254b184529452ccbf50d9.png"                      alt="image-20230129122440630"                ></p><p><strong>嗨嗨嗨</strong>，经过半小时的折腾，我找到解决办法了。在本地<code>yarn dev</code>中f12找到如下的代码，这里要做的就是看其他图标的代码是怎么写的</p><p><img                       lazyload                     alt="image"                     data-src="https://img1.musnow.top/i/23/02/2023039bb387bd3486582dc0c1e341a75b91.png"                      alt="image-20230129125650024"                ></p><p>这里能看到，他们都用了一个<code>span</code>的<code>xicon class</code>，我们要做的，就是给这个img也加上一个<code>xicon</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;a</span><br><span class="line">  id=&quot;gitee&quot;</span><br><span class="line">  :href=&quot;socialLinks.gitee&quot;</span><br><span class="line">  target=&quot;_blank&quot;</span><br><span class="line">  @mouseenter=&quot;changeTip&quot;</span><br><span class="line">  @mouseleave=&quot;leaveTip&quot;</span><br><span class="line">&gt;</span><br><span class="line">  &lt;span class=&quot;xicon&quot; style=&quot;font-size: 24px;&quot;&gt;</span><br><span class="line">    &lt;img src=&quot;/images/icon/gitee.png&quot; height=&quot;24&quot;/&gt;</span><br><span class="line">  &lt;/span&gt;</span><br><span class="line">&lt;/a&gt;</span><br></pre></td></tr></table></figure><p>现在就OK了！</p><p><img                       lazyload                     alt="image"                     data-src="https://img1.musnow.top/i/23/02/202304eeb7589e45560266d33d7fc65cb3f2.png"                      alt="image-20230129125808923"                ></p><h2 id="2-4-添加env判断，若为空不显示"><a href="#2-4-添加env判断，若为空不显示" class="headerlink" title="2.4 添加env判断，若为空不显示"></a>2.4 添加env判断，若为空不显示</h2><p>作者写的版本是写死的，即便你的env里面没有那个社交链接，他还是会展示在主页上。我的需求就是如果env里面<code>没有这个社交链接/为空</code>，那就不展示这个社交链接的图标</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># 社交链接</span><br><span class="line">VITE_SOCIAL_GITHUB = &quot;Aewait&quot;</span><br><span class="line">VITE_SOCIAL_GITEE = &quot;ewait&quot;</span><br><span class="line">VITE_SOCIAL_QQ = &quot;&quot;</span><br><span class="line">VITE_SOCIAL_EMAIL = &quot;&quot;</span><br><span class="line">VITE_SOCIAL_TELEGRAM = &quot;&quot;</span><br></pre></td></tr></table></figure><p>比如我个人的需求就不需要后面的3个，那就把环境变量设置为空，<strong>且自动不展示</strong></p><p>这时候要做的就是修改代码，添加一个判断语句（我没学过前端，百度到的）</p><p>先在社交链接的文件里面，添加下面这个变量定义（可以理解为他就是一个类，通过<code>类名.变量</code>的方式访问）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">let socialEnv = &#123;</span><br><span class="line">  github: import.meta.env.VITE_SOCIAL_GITHUB,</span><br><span class="line">  gitee: import.meta.env.VITE_SOCIAL_GITEE,</span><br><span class="line">  kook: import.meta.env.VITE_SOCIAL_KOOK,</span><br><span class="line">  qq: import.meta.env.VITE_SOCIAL_QQ,</span><br><span class="line">  email: import.meta.env.VITE_SOCIAL_EMAIL,</span><br><span class="line">  telegram: import.meta.env.VITE_SOCIAL_TELEGRAM,</span><br><span class="line">  twitter: import.meta.env.VITE_SOCIAL_TWITTER,</span><br><span class="line">  travellings: import.meta.env.VITE_SOCIAL_TRAVELLINGS,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>随后要做的，就是在最上面的<code>div class=&quot;link&quot;</code>里面添加一个判断语句（需要给每一项都添加，注意名字别搞混了）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;span v-if=&quot;socialEnv.twitter&quot;&gt;</span><br><span class="line">  &lt;a</span><br><span class="line">    id=&quot;twitter&quot;</span><br><span class="line">    :href=&quot;socialLinks.twitter&quot;</span><br><span class="line">    target=&quot;_blank&quot;</span><br><span class="line">    @mouseenter=&quot;changeTip&quot;</span><br><span class="line">    @mouseleave=&quot;leaveTip&quot;</span><br><span class="line">  &gt;</span><br><span class="line">    &lt;Icon size=&quot;24&quot;&gt;</span><br><span class="line">      &lt;Twitter /&gt;</span><br><span class="line">    &lt;/Icon&gt;</span><br><span class="line">  &lt;/a&gt;</span><br><span class="line">&lt;/span&gt;</span><br></pre></td></tr></table></figure><p>这时候，就会自动判断这个环境变量是不是为空，如果为空那就不显示</p><hr><h3 id="测试一下"><a href="#测试一下" class="headerlink" title="测试一下"></a>测试一下</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">VITE_SOCIAL_GITHUB = &quot;Aewait&quot;</span><br><span class="line">VITE_SOCIAL_GITEE = &quot;ewait&quot;</span><br><span class="line">VITE_SOCIAL_KOOK = &quot;https://kook.top/gpbTwZ&quot;</span><br><span class="line">VITE_SOCIAL_QQ = &quot;&quot;</span><br><span class="line">VITE_SOCIAL_EMAIL = &quot;&quot;</span><br><span class="line">VITE_SOCIAL_TELEGRAM = &quot;&quot;</span><br><span class="line">VITE_SOCIAL_TWITTER = &quot;&quot;</span><br><span class="line">VITE_SOCIAL_TRAVELLINGS = &quot;https://www.travellings.cn/go.html&quot;</span><br></pre></td></tr></table></figure><p><img                       lazyload                     alt="image"                     data-src="https://img1.musnow.top/i/23/02/2023dfd4f71e730c3dce6ee1eb093ea2a4cb.png"                      alt="image-20230130112314998"                ></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">VITE_SOCIAL_GITHUB = &quot;&quot;</span><br><span class="line">VITE_SOCIAL_GITEE = &quot;ewait&quot;</span><br><span class="line">VITE_SOCIAL_KOOK = &quot;https://kook.top/gpbTwZ&quot;</span><br><span class="line">VITE_SOCIAL_QQ = &quot;111&quot;</span><br><span class="line">VITE_SOCIAL_EMAIL = &quot;&quot;</span><br><span class="line">VITE_SOCIAL_TELEGRAM = &quot;&quot;</span><br><span class="line">VITE_SOCIAL_TWITTER = &quot;&quot;</span><br><span class="line">VITE_SOCIAL_TRAVELLINGS = &quot;https://www.travellings.cn/go.html&quot;</span><br></pre></td></tr></table></figure><p><img                       lazyload                     alt="image"                     data-src="https://img1.musnow.top/i/23/02/2023ca772df0f8fe07c4ef5fbd980dd923ec.png"                      alt="image-20230130112352368"                ></p><p>完美达成目标！</p><h3 id="变量复用"><a href="#变量复用" class="headerlink" title="变量复用"></a>变量复用</h3><p>可以把原本的<code>socialLinks</code>改成使用<code>socialEnv</code>，避免两个都是import，太长了不好看</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">let socialEnv = &#123;</span><br><span class="line">  github: import.meta.env.VITE_SOCIAL_GITHUB,</span><br><span class="line">  gitee: import.meta.env.VITE_SOCIAL_GITEE,</span><br><span class="line">  kook: import.meta.env.VITE_SOCIAL_KOOK,</span><br><span class="line">  qq: import.meta.env.VITE_SOCIAL_QQ,</span><br><span class="line">  email: import.meta.env.VITE_SOCIAL_EMAIL,</span><br><span class="line">  telegram: import.meta.env.VITE_SOCIAL_TELEGRAM,</span><br><span class="line">  twitter: import.meta.env.VITE_SOCIAL_TWITTER,</span><br><span class="line">  travellings: import.meta.env.VITE_SOCIAL_TRAVELLINGS,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 社交链接地址</span><br><span class="line">const socialLinks = reactive(&#123;</span><br><span class="line">  github: &quot;https://github.com/&quot; + socialEnv.github,</span><br><span class="line">  gitee: &quot;https://gitee.com/&quot; + socialEnv.gitee,</span><br><span class="line">  kook: socialEnv.kook,</span><br><span class="line">  qq: &quot;https://wpa.qq.com/msgrd?v=3&amp;uin=&quot; +</span><br><span class="line">    socialEnv.qq +</span><br><span class="line">    &quot;&amp;site=qq&amp;menu=yes&quot;,</span><br><span class="line">  email: &quot;mailto:&quot; + socialEnv.email,</span><br><span class="line">  telegram: &quot;https://t.me/&quot; + socialEnv.telegram,</span><br><span class="line">  twitter: &quot;https://twitter.com/&quot; + socialEnv.twitter,</span><br><span class="line">  travellings: socialEnv.travellings,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h1 id="3-站点首页文字字体"><a href="#3-站点首页文字字体" class="headerlink" title="3.站点首页文字字体"></a>3.站点首页文字字体</h1><blockquote><p><a class="link"   href="https://github.com/imsyy/home/issues/49" >https://github.com/imsyy/home/issues/49<i class="fas fa-external-link-alt"></i></a></p></blockquote><p>如果你修改了站点首页的文字，会发现一部分文字没办法正常显示</p><p><img                       lazyload                     alt="image"                     data-src="https://img1.musnow.top/i/23/02/2023b9a0f8e2a3d93ab3a2aecbe6e110ab38.png"                      alt="image-20230129112006589"                ></p><p>根据作者在issue里面提供的链接，下载了完整的字体文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">https://file.4everland.app/font/Other/Pacifico-Regular.ttf</span><br><span class="line">如果上面的链接坏了，可以去我的仓库里面下</span><br><span class="line">https://github.com/musnows/Aewait/blob/main/Pacifico-Regular.ttf</span><br></pre></td></tr></table></figure><p>将其粘贴到以下路径，覆盖原本的字体文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public/font</span><br></pre></td></tr></table></figure><p>现在就Ok了</p><p><img                       lazyload                     alt="image"                     data-src="https://img1.musnow.top/i/23/02/202353987c55bd2242d25a29c611c738e1b9.png"                      alt="image-20230129112052406"                ></p><h1 id="4-网站logo配置"><a href="#4-网站logo配置" class="headerlink" title="4.网站logo配置"></a>4.网站logo配置</h1><h2 id="4-1-浏览器顶部图标"><a href="#4-1-浏览器顶部图标" class="headerlink" title="4.1 浏览器顶部图标"></a>4.1 浏览器顶部图标</h2><p>修改<code>index.html</code>中的如下字段</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;stylesheet&quot;</span> <span class="attr">href</span>=<span class="string">&quot;https://s1.hdslb.com/bfs/static/jinkela/long/font/regular.css&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;icon&quot;</span> <span class="attr">href</span>=<span class="string">&quot;/images/icon/myPNG.jpg&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;apple-touch-icon&quot;</span> <span class="attr">href</span>=<span class="string">&quot;/images/icon/myPNG-r.jpg&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure><p>将你自己的logo图标放到<code>public/images</code>下即可。这里修改的是浏览器顶部的图标</p><h2 id="4-2-主页图标"><a href="#4-2-主页图标" class="headerlink" title="4.2 主页图标"></a>4.2 主页图标</h2><p>主页图标的路径如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">src/components/Message/index.vue</span><br></pre></td></tr></table></figure><p>里面有注释，找到字段修改即可</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- Logo --&gt;</span><br><span class="line">&lt;div class=&quot;logo&quot;&gt;</span><br><span class="line">  &lt;img class=&quot;logo-img&quot; src=&quot;/images/icon/logo.png&quot; alt=&quot;logo&quot; /&gt;</span><br><span class="line">  &lt;div class=&quot;name&quot;&gt;</span><br><span class="line">    &lt;span class=&quot;bg&quot;&gt;&#123;&#123; siteUrl[0] &#125;&#125;&lt;/span&gt;</span><br><span class="line">    &lt;span class=&quot;sm&quot;&gt;.&#123;&#123; siteUrl[1] &#125;&#125;&lt;/span&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure><h1 id="5-网站链接配置"><a href="#5-网站链接配置" class="headerlink" title="5.网站链接配置"></a>5.网站链接配置</h1><p>在环境变量<code>.env</code>中写明了配置网站的位置</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 网站链接</span><br><span class="line">## 请在 src/components/Links/index.vue 中设置</span><br></pre></td></tr></table></figure><p>首先是这里的图标，还是在老位置<code>node_modules\@vicons\fa\es\index.d.ts</code>，找你需要的图标导入</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">import &#123;</span><br><span class="line">  Link,</span><br><span class="line">  Blog,</span><br><span class="line">  CompactDisc,</span><br><span class="line">  Cloud,</span><br><span class="line">  Compass,</span><br><span class="line">  Book,</span><br><span class="line">  Flask,</span><br><span class="line">  GitSquare,</span><br><span class="line">  Image,</span><br><span class="line">  GitAlt</span><br><span class="line">&#125; from &quot;@vicons/fa&quot;;</span><br></pre></td></tr></table></figure><p>随后网站链接就照着抄，起一个新的就可以了</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  icon: Compass,</span><br><span class="line">  name: &quot;起始页&quot;,</span><br><span class="line">  link: &quot;https://nav.imsyy.top/&quot;,</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><p>建议链接不超过6个，不然就会变成下面这样</p><p><img                       lazyload                     alt="image"                     data-src="https://img1.musnow.top/i/23/02/20236ccfa2fa6af7ee282130c96f82fc0468.png"                      alt="image-20230129113936262"                ></p><h1 id="6-footer配置"><a href="#6-footer配置" class="headerlink" title="6.footer配置"></a>6.footer配置</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">src\components\Footer\index.vue</span><br></pre></td></tr></table></figure><p>在页脚配置网站用户和链接，修改如下字段</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;span</span><br><span class="line">  &gt;Copyright&amp;nbsp;&amp;copy;&amp;nbsp;&#123;&#123; fullYear &#125;&#125;</span><br><span class="line">  &lt;a href=&quot;链接&quot;&gt;名字&lt;/a&gt;</span><br><span class="line">&lt;/span&gt;</span><br></pre></td></tr></table></figure><p>如果你的站点经过了备案，修改如下字段</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;a href=&quot;https://beian.miit.gov.cn&quot; target=&quot;_blank&quot;</span><br><span class="line">  &gt;豫ICP备2022018134号-1&lt;/a</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure><p>如果没有备案，可以把这部分注释掉</p><h1 id="7-音乐播放器配置"><a href="#7-音乐播放器配置" class="headerlink" title="7.音乐播放器配置"></a>7.音乐播放器配置</h1><p>这部分可能有老哥不太清楚，我顺便说一下吧!</p><p>在环境变量里面，修改最底部的播放id就可以了</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"># 歌曲 API 地址</span><br><span class="line">## 备用：https://api.wuenci.com/meting/api/</span><br><span class="line">VITE_SONG_API = &quot;https://api-meting.imsyy.top&quot;</span><br><span class="line"># 歌曲服务器 ( netease-网易云, tencent-qq音乐 )</span><br><span class="line">VITE_SONG_SERVER = &quot;netease&quot;</span><br><span class="line"># 播放类型 ( song-歌曲, playlist-播放列表, album-专辑, search-搜索, artist-艺术家 )</span><br><span class="line">VITE_SONG_TYPE = &quot;playlist&quot;</span><br><span class="line"># 播放 ID</span><br><span class="line">VITE_SONG_ID = &quot;2893005411&quot;</span><br></pre></td></tr></table></figure><p>id在哪儿找？登陆你的网页版网易云&#x2F;QQ音乐，找到一个歌单</p><p><img                       lazyload                     alt="image"                     data-src="https://img1.musnow.top/i/23/02/2023a0f52c419f2ba5b309e09de992f76fbb.png"                      alt="image-20230129113433710"                ></p><p>此处网页链接里面的ID就是播放id，复制过来就OK了</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">https://music.163.com/#/playlist?id=2024518101</span><br><span class="line">ID是2024518101</span><br></pre></td></tr></table></figure><h1 id="8-背景图设置"><a href="#8-背景图设置" class="headerlink" title="8.背景图设置"></a>8.背景图设置</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">src/components/store/index.vue</span><br></pre></td></tr></table></figure><p>这里有不少配置项，其中关于壁纸种类有3中</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">state</span>: <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        <span class="attr">innerWidth</span>: <span class="literal">null</span>, <span class="comment">// 当前窗口宽度</span></span><br><span class="line">        <span class="attr">coverType</span>: <span class="string">&quot;0&quot;</span>, <span class="comment">// 壁纸种类</span></span><br><span class="line">        <span class="attr">musicIsOk</span>: <span class="literal">false</span>, <span class="comment">// 音乐是否加载完成</span></span><br><span class="line">        <span class="attr">musicVolume</span>: <span class="number">0</span>, <span class="comment">// 音乐音量;</span></span><br><span class="line">        <span class="attr">musicOpenState</span>: <span class="literal">false</span>, <span class="comment">// 音乐面板开启状态</span></span><br><span class="line">        <span class="attr">backgroundShow</span>: <span class="literal">false</span>, <span class="comment">// 壁纸展示状态</span></span><br><span class="line">        <span class="attr">boxOpenState</span>: <span class="literal">false</span>, <span class="comment">// 盒子开启状态</span></span><br><span class="line">        <span class="attr">mobileOpenState</span>: <span class="literal">true</span>, <span class="comment">// 移动端开启状态</span></span><br><span class="line">        <span class="attr">mobileFuncState</span>: <span class="literal">false</span>, <span class="comment">// 移动端功能区开启状态</span></span><br><span class="line">        <span class="attr">setOpenState</span>: <span class="literal">false</span>, <span class="comment">// 设置页面开启状态</span></span><br><span class="line">        <span class="attr">playerState</span>: <span class="literal">false</span>, <span class="comment">// 当前播放状态</span></span><br><span class="line">        <span class="attr">playerTitle</span>: <span class="literal">null</span>, <span class="comment">// 当前播放歌曲名</span></span><br><span class="line">        <span class="attr">playerArtist</span>: <span class="literal">null</span>, <span class="comment">// 当前播放歌手名</span></span><br><span class="line">        <span class="attr">playerLrc</span>: <span class="string">&quot;歌词加载中&quot;</span>, <span class="comment">// 当前播放歌词</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><p>可以在backgound里面找到壁纸3个种类的不同：0是本地壁纸，随机1到10（可以在本地新增你喜欢的壁纸，并修改这里的随机数范围）</p><p>0是默认的几张本地壁纸，1是bing，2是随机风景，3是随机二刺螈👻</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;el-radio label=<span class="string">&quot;0&quot;</span> size=<span class="string">&quot;large&quot;</span> border&gt;默认壁纸&lt;/el-radio&gt;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">el-radio</span> <span class="attr">label</span>=<span class="string">&quot;1&quot;</span> <span class="attr">size</span>=<span class="string">&quot;large&quot;</span> <span class="attr">border</span>&gt;</span>每日一图<span class="tag">&lt;/<span class="name">el-radio</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">el-radio</span> <span class="attr">label</span>=<span class="string">&quot;2&quot;</span> <span class="attr">size</span>=<span class="string">&quot;large&quot;</span> <span class="attr">border</span>&gt;</span>随机风景<span class="tag">&lt;/<span class="name">el-radio</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">el-radio</span> <span class="attr">label</span>=<span class="string">&quot;3&quot;</span> <span class="attr">size</span>=<span class="string">&quot;large&quot;</span> <span class="attr">border</span>&gt;</span>随机动漫<span class="tag">&lt;/<span class="name">el-radio</span>&gt;</span></span></span><br></pre></td></tr></table></figure><p>咳咳，才发现原来背景图可以在前端直接设置呀？点击左侧留言，再点击时间胶囊右侧的设置按钮。不过目前只能设置这一个内容，而且这个设置随着网页刷新会被覆盖掉，建议在后端设置好默认的壁纸</p><p><img                       lazyload                     alt="image"                     data-src="https://img1.musnow.top/i/23/02/2023b117617632908357a2f1267b45ad80f1.png"                      alt="image-20230201212127748"                ></p><h1 id="9-时间胶囊增加站点运行时间"><a href="#9-时间胶囊增加站点运行时间" class="headerlink" title="9.时间胶囊增加站点运行时间"></a>9.时间胶囊增加站点运行时间</h1><p>点击左侧的网站介绍（就是社交链接上面那个面板）能打开时间胶囊。默认显示的信息挺不错的，但是还空了一块，这不得把站点运行时间给加上？</p><blockquote><p>参考 <a class="link"   href="https://blog.csdn.net/jay_chou345/article/details/110201897" >https://blog.csdn.net/jay_chou345/article/details/110201897<i class="fas fa-external-link-alt"></i></a></p></blockquote><p>将这一串代码添加到<code>src/components/TimeCapsule</code>的<code>&lt;script setup&gt;</code>和<code>&lt;/script&gt;</code>之间</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 站点存活时间</span></span><br><span class="line"><span class="keyword">let</span> runTime = &#123;</span><br><span class="line">  <span class="attr">year</span>: <span class="keyword">import</span>.<span class="property">meta</span>.<span class="property">env</span>.<span class="property">VITE_SITE_YAER</span>,</span><br><span class="line">  <span class="attr">month</span>: <span class="keyword">import</span>.<span class="property">meta</span>.<span class="property">env</span>.<span class="property">VITE_SITE_MONTH</span>,</span><br><span class="line">  <span class="attr">day</span>: <span class="keyword">import</span>.<span class="property">meta</span>.<span class="property">env</span>.<span class="property">VITE_SITE_DAY</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">secondToDate</span>(<span class="params">second</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (!second) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">var</span> time = <span class="keyword">new</span> <span class="title class_">Array</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">  <span class="keyword">if</span> (second &gt;= <span class="number">365</span> * <span class="number">24</span> * <span class="number">3600</span>) &#123;</span><br><span class="line">      time[<span class="number">0</span>] = <span class="built_in">parseInt</span>(second / (<span class="number">365</span> * <span class="number">24</span> * <span class="number">3600</span>));</span><br><span class="line">      second %= <span class="number">365</span> * <span class="number">24</span> * <span class="number">3600</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (second &gt;= <span class="number">24</span> * <span class="number">3600</span>) &#123;</span><br><span class="line">      time[<span class="number">1</span>] = <span class="built_in">parseInt</span>(second / (<span class="number">24</span> * <span class="number">3600</span>));</span><br><span class="line">      second %= <span class="number">24</span> * <span class="number">3600</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (second &gt;= <span class="number">3600</span>) &#123;</span><br><span class="line">      time[<span class="number">2</span>] = <span class="built_in">parseInt</span>(second / <span class="number">3600</span>);</span><br><span class="line">      second %= <span class="number">3600</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (second &gt;= <span class="number">60</span>) &#123;</span><br><span class="line">      time[<span class="number">3</span>] = <span class="built_in">parseInt</span>(second / <span class="number">60</span>);</span><br><span class="line">      second %= <span class="number">60</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (second &gt; <span class="number">0</span>) &#123;</span><br><span class="line">      time[<span class="number">4</span>] = second;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> time;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">setTime</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="comment">//month要少一个月，不然会出问题。即month的范围为 0-11</span></span><br><span class="line">  <span class="keyword">var</span> create_time = <span class="title class_">Math</span>.<span class="title function_">round</span>(<span class="keyword">new</span> <span class="title class_">Date</span>(<span class="title class_">Date</span>.<span class="title function_">UTC</span>(runTime.<span class="property">year</span>, runTime.<span class="property">month</span>,runTime.<span class="property">day</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>)).<span class="title function_">getTime</span>() / <span class="number">1000</span>);</span><br><span class="line">  <span class="keyword">var</span> timestamp = <span class="title class_">Math</span>.<span class="title function_">round</span>((<span class="keyword">new</span> <span class="title class_">Date</span>().<span class="title function_">getTime</span>() + <span class="number">8</span> * <span class="number">60</span> * <span class="number">60</span> * <span class="number">1000</span>) / <span class="number">1000</span>);</span><br><span class="line">  <span class="keyword">var</span> currentTime = <span class="title function_">secondToDate</span>((  timestamp-create_time));</span><br><span class="line">  <span class="keyword">var</span> currentTimeHtml = currentTime[<span class="number">0</span>] + <span class="string">&#x27; 年 &#x27;</span> + currentTime[<span class="number">1</span>] + <span class="string">&#x27; 天 &#x27;</span></span><br><span class="line">      + currentTime[<span class="number">2</span>] + <span class="string">&#x27; 时 &#x27;</span> + currentTime[<span class="number">3</span>] + <span class="string">&#x27; 分 &#x27;</span> + currentTime[<span class="number">4</span>]</span><br><span class="line">      + <span class="string">&#x27; 秒&#x27;</span>;</span><br><span class="line">  <span class="keyword">if</span>(<span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;htmer_time&quot;</span>)!=<span class="literal">null</span>)</span><br><span class="line">      <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;htmer_time&quot;</span>).<span class="property">innerHTML</span> = <span class="string">&quot;本站已经苟活 &quot;</span>+currentTimeHtml;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 即时刷新站点存活时间</span></span><br><span class="line"><span class="built_in">setInterval</span>(setTime, <span class="number">1000</span>);</span><br></pre></td></tr></table></figure><p>随后在顶部的模板末尾的<code>&lt;/div&gt;</code>前添加如下代码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;span class=&quot;text&quot;&gt;</span><br><span class="line">  &lt;p id=&quot;htmer_time&quot;&gt;&lt;/p&gt;</span><br><span class="line">&lt;/span&gt;</span><br></pre></td></tr></table></figure><p>环境变量<code>.env</code>中添加如下字段</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 站点运行时间（显示在时间胶囊中）</span><br><span class="line">## 注意：月份的范围是0-11，否则会有bug</span><br><span class="line">VITE_SITE_YAER = 2023</span><br><span class="line">VITE_SITE_MONTH = 0</span><br><span class="line">VITE_SITE_DAY  = 1</span><br></pre></td></tr></table></figure><p>这样就OK啦！</p><p><img                       lazyload                     alt="image"                     data-src="https://img1.musnow.top/i/23/02/202321bceee011eec103e4c679055464e7f7.png"                      alt="image-20230201220013087"                ></p><p>当我开了一个<code>pull request</code>后，源项目作者提供了一个更简单的代码版本。该版本更加精简，但是不能显示秒数，不过完全够用了！</p><blockquote><p><a class="link"   href="https://github.com/imsyy/home/pull/63" >https://github.com/imsyy/home/pull/63<i class="fas fa-external-link-alt"></i></a></p></blockquote><p>环境变量</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">VITE_SITE_START = &quot;2020-10-24&quot;</span><br></pre></td></tr></table></figure><p>vue中代码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;span class=&quot;text&quot;&gt;</span><br><span class="line">    &lt;p id=&quot;htmer_time&quot;&gt;&#123;&#123; startDateText &#125;&#125;&lt;/p&gt;</span><br><span class="line">&lt;/span&gt;</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> startDate = <span class="title function_">ref</span>(<span class="keyword">import</span>.<span class="property">meta</span>.<span class="property">env</span>.<span class="property">VITE_SITE_START</span>);</span><br><span class="line"><span class="keyword">let</span> startDateText = <span class="title function_">ref</span>(<span class="literal">null</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 建站日期统计函数</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">siteDateStatistics</span> = (<span class="params">startDate</span>) =&gt; &#123;</span><br><span class="line">    <span class="keyword">const</span> currentDate = <span class="keyword">new</span> <span class="title class_">Date</span>();</span><br><span class="line">    <span class="keyword">const</span> differenceInTime = currentDate.<span class="title function_">getTime</span>() - startDate.<span class="title function_">getTime</span>();</span><br><span class="line">    <span class="keyword">const</span> differenceInDays = differenceInTime / (<span class="number">1000</span> * <span class="number">3600</span> * <span class="number">24</span>);</span><br><span class="line">    <span class="keyword">const</span> differenceInMonths = differenceInDays / <span class="number">30</span>;</span><br><span class="line">    <span class="keyword">const</span> differenceInYears = differenceInMonths / <span class="number">12</span>;</span><br><span class="line">    <span class="keyword">if</span> (differenceInYears &gt;= <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">`本站已经苟活了 <span class="subst">$&#123;<span class="built_in">Math</span>.floor(differenceInYears)&#125;</span> 年 <span class="subst">$&#123;<span class="built_in">Math</span>.floor(differenceInMonths % <span class="number">12</span>)&#125;</span> 月 <span class="subst">$&#123;<span class="built_in">Math</span>.round(differenceInDays % <span class="number">30</span>)&#125;</span> 天`</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (differenceInMonths &gt;= <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">`本站已经苟活了 <span class="subst">$&#123;<span class="built_in">Math</span>.floor(differenceInMonths)&#125;</span> 月 <span class="subst">$&#123;<span class="built_in">Math</span>.round(differenceInDays % <span class="number">30</span>)&#125;</span> 天`</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">`本站已经苟活了 <span class="subst">$&#123;<span class="built_in">Math</span>.round(differenceInDays)&#125;</span> 天`</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">onMounted</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    startDateText.<span class="property">value</span> = <span class="title function_">siteDateStatistics</span>(<span class="keyword">new</span> <span class="title class_">Date</span>(startDate.<span class="property">value</span>));</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h1 id="10-关闭新春灯笼"><a href="#10-关闭新春灯笼" class="headerlink" title="10.关闭新春灯笼"></a>10.关闭新春灯笼</h1><p>春节假期结束辣！我们首页的新春灯笼也要取下来了</p><p>找到<code>App.vue</code>,注释掉里面的import</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 新春灯笼</span><br><span class="line">// import &quot;@/utils/lantern.js&quot;;</span><br></pre></td></tr></table></figure><h1 id="More…"><a href="#More…" class="headerlink" title="More…"></a>More…</h1><p>有任何问题，欢迎评论提问</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;本篇博客教你如何部署一个自己的个人主页&lt;/p&gt;
&lt;p&gt;项目地址：&lt;a class=&quot;link&quot;   href=&quot;https://github.com/imsyy/home&quot; &gt;https://github.com/imsyy/home&lt;i class=&quot;fas fa-external-link-alt&quot;&gt;&lt;/i&gt;&lt;/a&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="差生文具多" scheme="https://blog.musnow.top/categories/%E5%B7%AE%E7%94%9F%E6%96%87%E5%85%B7%E5%A4%9A/"/>
    
    
    <category term="hexo" scheme="https://blog.musnow.top/tags/hexo/"/>
    
    <category term="git" scheme="https://blog.musnow.top/tags/git/"/>
    
    <category term="vercel" scheme="https://blog.musnow.top/tags/vercel/"/>
    
  </entry>
  
</feed>
