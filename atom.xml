<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>慕雪的寒舍</title>
  
  <subtitle>雪下了一夜</subtitle>
  <link href="https://blog.musnow.top/atom.xml" rel="self"/>
  
  <link href="https://blog.musnow.top/"/>
  <updated>2024-07-21T06:11:00.000Z</updated>
  <id>https://blog.musnow.top/</id>
  
  <author>
    <name>慕雪年华</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>【Docker】Docker学习04 | dockerfile的编写</title>
    <link href="https://blog.musnow.top/posts/188682082/"/>
    <id>https://blog.musnow.top/posts/188682082/</id>
    <published>2024-07-21T06:04:27.000Z</published>
    <updated>2024-07-21T06:11:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>适用于hexo-butterfly主题的front-matter模板。</p><p>dockerfile是构建docker镜像的基础，它规定了一系列语法，让我们可以在某个基础镜像之上，添加自己需要的操作，打包出一个自己的镜像。</p><h1 id="1-dockerfile基本语法"><a href="#1-dockerfile基本语法" class="headerlink" title="1. dockerfile基本语法"></a>1. dockerfile基本语法</h1><p>下面是dockerfile的基本语法和其对应的功能，dockerfile中的每一个指令都对应的<strong>镜像的一层</strong>。</p><p>除了这些构建语法外，在dockerfile中使用<code>#</code>开头的行代表注释行。注意，<strong>注释只能单成一行</strong>，不能在已有语句末尾追加。</p><table><thead><tr><th>语法</th><th>说明</th></tr></thead><tbody><tr><td>FROM</td><td>指定基础镜像</td></tr><tr><td>RUN</td><td>在基础镜像上需要执行的命令（构建命令）</td></tr><tr><td>WORKDIR</td><td>其实就是cd的意思，设置镜像的工作目录</td></tr><tr><td>VOLUME</td><td>设置需要挂载文件实现持久化的目录</td></tr><tr><td>EXPOSE</td><td>指定容器对外暴露的端口</td></tr><tr><td>ENV</td><td>设置镜像中的环境变量</td></tr><tr><td>ARG</td><td>设置dockerfile<strong>构建过程中</strong>的环境变量</td></tr><tr><td>ENTRYPOINT</td><td>设置默认的可执行文件</td></tr><tr><td>HEALTHCHECK</td><td>在容器启动的时候进行健康检查</td></tr><tr><td>MAINTAINER</td><td>设置维护者信息（弃用，推荐用LABEL替代）</td></tr><tr><td>LABEL</td><td>给镜像添加元数据（如镜像作者）</td></tr><tr><td>ADD</td><td>添加本地&#x2F;远程的目录或文件</td></tr><tr><td>COPY</td><td>拷贝文件&#x2F;目录</td></tr><tr><td>ONBUILD</td><td>只有FROM基于当前镜像的时候才会执行</td></tr><tr><td>SHELL</td><td>设置镜像默认使用的shell</td></tr><tr><td>STOPSIGNAL</td><td>设置特定的系统信号来让容器退出</td></tr><tr><td>USER</td><td>设置<strong>执行构建命令</strong>的用户和用户组ID</td></tr></tbody></table><p>本文对这些命令的解释只停留于基础，更详细的介绍建议查看<a href="https://docs.docker.com/reference/dockerfile/">dockerfile</a>文档。</p><h1 id="2-dockerfile语法详解"><a href="#2-dockerfile语法详解" class="headerlink" title="2. dockerfile语法详解"></a>2. dockerfile语法详解</h1><h2 id="2-1-FROM"><a href="#2-1-FROM" class="headerlink" title="2.1. FROM"></a>2.1. FROM</h2><p>这个是指定当前需要构建的镜像的<strong>基础镜像</strong>，dockerfile文件中必须要有FROM字段。</p><p>比如我们有一个项目，需要在ubuntu环境上运行，我们就可以指定当前镜像是基于ubuntu镜像的。</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> ubuntu:<span class="number">22.04</span></span><br></pre></td></tr></table></figure><p>这时候就出现了一个问题了，这些<strong>基础镜像</strong>是怎么制作出来的？以<a href="https://github.com/CentOS/sig-cloud-instance-images/blob/CentOS-7.6.1810/docker/Dockerfile">CentOS 7.6</a>为例，官方的dockerfile是这么写的。</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> scratch</span><br><span class="line"><span class="keyword">ADD</span><span class="language-bash"> centos-7-docker.tar.xz /</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">LABEL</span><span class="language-bash"> org.label-schema.schema-version=<span class="string">&quot;1.0&quot;</span> \</span></span><br><span class="line"><span class="language-bash">    org.label-schema.name=<span class="string">&quot;CentOS Base Image&quot;</span> \</span></span><br><span class="line"><span class="language-bash">    org.label-schema.vendor=<span class="string">&quot;CentOS&quot;</span> \</span></span><br><span class="line"><span class="language-bash">    org.label-schema.license=<span class="string">&quot;GPLv2&quot;</span> \</span></span><br><span class="line"><span class="language-bash">    org.label-schema.build-date=<span class="string">&quot;20181204&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">CMD</span><span class="language-bash"> [<span class="string">&quot;/bin/bash&quot;</span>]</span></span><br></pre></td></tr></table></figure><p>第一行的<code>FROM scratch</code>代表从“空”开始创建镜像，而第二行的ADD代表添加了一个文件。从仓库的文件路径中可以看到，官方使用了一个centos的<code>tar.xz</code>系统包（这个压缩包里面是系统运行的必要二进制文件）</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/07/b6ef336c8962fcb547f8b3ae8b94953a.png" alt="image.png"></p><p>下载下来，解压看看，内部其实就是一个centos系统的根路径下的必要内容。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">❯ tree -L 1 /tmp/centos7</span><br><span class="line">/tmp/centos7</span><br><span class="line">├── anaconda-post.log</span><br><span class="line">├── bin -&gt; usr/bin</span><br><span class="line">├── dev</span><br><span class="line">├── etc</span><br><span class="line">├── home</span><br><span class="line">├── lib -&gt; usr/lib</span><br><span class="line">├── lib64 -&gt; usr/lib64</span><br><span class="line">├── media</span><br><span class="line">├── mnt</span><br><span class="line">├── opt</span><br><span class="line">├── proc</span><br><span class="line">├── root</span><br><span class="line">├── run</span><br><span class="line">├── sbin -&gt; usr/sbin</span><br><span class="line">├── srv</span><br><span class="line">├── sys</span><br><span class="line">├── tmp</span><br><span class="line">├── usr</span><br><span class="line">└── var</span><br><span class="line"></span><br><span class="line">18 directories, 1 file</span><br></pre></td></tr></table></figure><p>至此可以明确一个概念，我们需要制作一个镜像，有两种方式：</p><ul><li>一个是基于开源的镜像的基础上二次构建；</li><li>第二种方式就是像centos官方一样，制作系统的二进制文件，从0开始构建镜像。</li></ul><p>如果不是有神马特殊需要，直接使用<strong>第一种方式</strong>，基于已有开源镜像的基础来构建镜像就够了。</p><h2 id="2-2-RUN"><a href="#2-2-RUN" class="headerlink" title="2.2. RUN"></a>2.2. RUN</h2><p>RUN字段指定了在基础镜像上需要执行的命令，通常用于安装环境。这些命令都等同于直接在基础镜像的shell中运行的命令。</p><p>RUN有两种语法格式，一种是直接写命令，另外一种是用exec的格式将命令和选项拼接起来。</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">RUN</span><span class="language-bash"> &lt;需要运行的命令&gt;</span></span><br><span class="line"><span class="comment"># 等价于直接运行命令</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> [<span class="string">&quot;apt&quot;</span>,<span class="string">&quot;install&quot;</span>,<span class="string">&quot;vim&quot;</span>] </span></span><br><span class="line"><span class="comment"># 等价于 RUN apt install vim</span></span><br></pre></td></tr></table></figure><p>比如我们创建一个ubuntu的容器，尝试在里面安装一个<code>net-tools</code>软件包，可以如下编写dockerfile。</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> ubuntu:<span class="number">22.04</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> apt intstall -y net-tools</span></span><br></pre></td></tr></table></figure><p>如果你需要执行多个环境配置的命令，使用<code>&amp;&amp;</code>将其连接，而不要写多个RUN命令</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> ubuntu:<span class="number">22.04</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> apt -y update &amp;&amp; \</span></span><br><span class="line"><span class="language-bash">apt intstall -y net-tools</span></span><br></pre></td></tr></table></figure><h2 id="2-3-MAINTAINER和LABEL"><a href="#2-3-MAINTAINER和LABEL" class="headerlink" title="2.3. MAINTAINER和LABEL"></a>2.3. MAINTAINER和LABEL</h2><p>MAINTAINER和LABEL都是用于给docker镜像打标签的。你可以理解为给他身上挂个名牌，这样其他人就可以从名牌上看到和这个镜像相关的一些信息。</p><p>使用<code>docker inspect ubuntu:22.04</code>命令，可以看到ubuntu镜像上挂着的一些名牌。</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line"><span class="attr">&quot;Labels&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">                <span class="attr">&quot;org.opencontainers.image.ref.name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;ubuntu&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;org.opencontainers.image.version&quot;</span><span class="punctuation">:</span> <span class="string">&quot;22.04&quot;</span></span><br><span class="line">            <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>而且我们基于<code>ubuntu:22.04</code>镜像构建的其他镜像，也会包含这个名牌。这可以让使用者在没有看到dockerfile的情况下，了解到你构建的镜像是基于ubuntu的。</p><p>下面的LABEL和MAINTAINER的语法格式，都是<code>key=value</code>的形式。</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">LABEL</span><span class="language-bash"> &lt;key&gt;=&lt;value&gt; &lt;key&gt;=&lt;value&gt; &lt;key&gt;=&lt;value&gt; ...</span></span><br><span class="line"><span class="comment"># MAINTAINER 会设置镜像详情中的Author字段</span></span><br><span class="line"><span class="keyword">MAINTAINER</span> &lt;name&gt;</span><br></pre></td></tr></table></figure><p>来简单试试吧</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> ubuntu:<span class="number">22.04</span></span><br><span class="line"><span class="keyword">MAINTAINER</span> musnows</span><br><span class="line"><span class="keyword">LABEL</span><span class="language-bash"> build.in=<span class="string">&quot;vmware-ubuntu&quot;</span></span></span><br></pre></td></tr></table></figure><p>使用这个dockerfile构建的镜像，会有下面的LABEL，且Author字段是<code>MAINTAINER</code>设置的musnows（ubuntu基础镜像中Author字段为空）</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line"><span class="attr">&quot;Author&quot;</span><span class="punctuation">:</span> <span class="string">&quot;musnows&quot;</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;Config&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line"><span class="attr">&quot;Labels&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">                <span class="attr">&quot;build.in&quot;</span><span class="punctuation">:</span> <span class="string">&quot;vmware-ubuntu&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;org.opencontainers.image.ref.name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;ubuntu&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;org.opencontainers.image.version&quot;</span><span class="punctuation">:</span> <span class="string">&quot;22.04&quot;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>另外，dockerfile的官方文档中提到，下面这个LABEL和MAINTAINER是对应的</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">LABEL</span><span class="language-bash"> org.opencontainers.image.authors=<span class="string">&quot;SvenDowideit@home.org.au&quot;</span></span></span><br></pre></td></tr></table></figure><p>但经过我的测试，这个LABEL不会修改Author字段（只有MAINTAINER会修改Author字段）。你可以根据自己的需要选择使用LABEL还是MAINTAINER。</p><h2 id="2-4-SHELL"><a href="#2-4-SHELL" class="headerlink" title="2.4. SHELL"></a>2.4. SHELL</h2><p>这个命令用于设置镜像默认使用的SHELL。</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SHELL</span><span class="language-bash"> [<span class="string">&quot;executable&quot;</span>, <span class="string">&quot;parameters&quot;</span>]</span></span><br></pre></td></tr></table></figure><p>在<a href="https://docs.docker.com/reference/dockerfile/#shell">官方文档</a>中，有列出Linux和Windows下默认使用的SHELL是什么。如果它们不符合你的要求，比如你需要使用<code>/bin/bash</code>作为你的shell，则可以自行更换。</p><blockquote><p>The SHELL instruction allows the default shell used for the shell form of commands to be overridden. The default shell on Linux is<code>[&quot;/bin/sh&quot;, &quot;-c&quot;]</code>, and on Windows is <code>[&quot;cmd&quot;, &quot;/S&quot;, &quot;/C&quot;]</code>. The SHELL instruction must be written in JSON form in a Dockerfile.</p></blockquote><h2 id="2-5-WORKDIR"><a href="#2-5-WORKDIR" class="headerlink" title="2.5. WORKDIR"></a>2.5. WORKDIR</h2><p>设置docker构建过程和最终程序运行使用的工作路径。默认的工作路径是<code>/</code>根路径。如果指定的WORKDIR路径不存在，则会被创建。</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">WORKDIR</span><span class="language-bash"> /path/to/workdir</span></span><br></pre></td></tr></table></figure><p>另外，工作路径采用的是追加的方式，比如下方设置了多个工作路径，那么最终的工作路径是<code>/a/b/c/</code>这个目录。你可以理解为它本质上就是一个CD命令。</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">WORKDIR</span><span class="language-bash"> /a</span></span><br><span class="line"><span class="keyword">WORKDIR</span><span class="language-bash"> b</span></span><br><span class="line"><span class="keyword">WORKDIR</span><span class="language-bash"> c</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> <span class="built_in">pwd</span></span></span><br></pre></td></tr></table></figure><p>工作路径可以使用环境变量，前提这个环境变量是在dockerfile中被显式设置的</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ENV</span> DIRPATH=/path</span><br><span class="line"><span class="keyword">WORKDIR</span><span class="language-bash"> <span class="variable">$DIRPATH</span>/<span class="variable">$DIRNAME</span></span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> <span class="built_in">pwd</span></span></span><br></pre></td></tr></table></figure><p>此时pwd命令的输出是<code>/path/$DIRNAME</code>。</p><h2 id="2-6-COPY"><a href="#2-6-COPY" class="headerlink" title="2.6. COPY"></a>2.6. COPY</h2><p>COPY命令有两种方式，如果路径中包含空格，则必须使用第二种形式（将路径使用英文双引号括起来）</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">COPY</span><span class="language-bash"> [OPTIONS] &lt;src&gt; ... &lt;dest&gt;</span></span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> [OPTIONS] [<span class="string">&quot;&lt;src&gt;&quot;</span>, ... <span class="string">&quot;&lt;dest&gt;&quot;</span>]</span></span><br></pre></td></tr></table></figure><p>COPY命令支持使用<code>*</code>来匹配任意字符，<code>?</code>匹配单个字符。如果需要拷贝名称中包含<code>[]</code>的特殊文件，则需要使用Golang转义规则对文件名进行转义。详见<a href="https://docs.docker.com/reference/dockerfile/#copy">官方文档</a>。</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 将本地文件 app.py 复制到镜像的 /app 目录</span></span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> app.py /app/</span></span><br><span class="line"><span class="comment"># 将整个本地目录 my_app 复制到镜像的 /app 目录</span></span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> my_app/ /app/</span></span><br><span class="line"><span class="comment"># 复制所有以 .py 结尾的文件到镜像的 /app 目录</span></span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> *.py /app/</span></span><br><span class="line"><span class="comment"># 将 src 目录中所有文件复制到 /app 目录</span></span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> src/* /app/</span></span><br></pre></td></tr></table></figure><h3 id="2-6-1-选项说明"><a href="#2-6-1-选项说明" class="headerlink" title="2.6.1. 选项说明"></a>2.6.1. 选项说明</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">--from</span><br><span class="line">--chown</span><br><span class="line">--chmod</span><br><span class="line">--link</span><br><span class="line">--parents</span><br><span class="line">--exclude</span><br></pre></td></tr></table></figure><h4 id="2-6-1-1-–from"><a href="#2-6-1-1-–from" class="headerlink" title="2.6.1.1. –from"></a>2.6.1.1. –from</h4><p><code>--from</code>选项允许COPY从多段构建中拷贝文件，或从其他镜像中拷贝文件。</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">COPY</span><span class="language-bash"> [--from=&lt;image|stage|context&gt;] &lt;src&gt; ... &lt;dest&gt;</span></span><br></pre></td></tr></table></figure><p>比如我们可以从nginx镜像中直接拷贝配置文件，对应选项中的image</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">COPY</span><span class="language-bash"> --from=nginx:latest /etc/nginx/nginx.conf /nginx.conf</span></span><br></pre></td></tr></table></figure><p>我们还可以从多段构建中拷贝文件，对应选项中的stage。</p><p>下面是官网中一个多段构建的dockefile，在基础镜像alpine中使用clang编译了<code>hello.c</code>的程序，随后将这个程序的可执行文件移动到一个空的镜像中。这就相当于空镜像里面直接添加了一个可执行文件。不过这只是个例子，经过我的测试，这个镜像并不能正常运行😑。</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># syntax=docker/dockerfile:1</span></span><br><span class="line"><span class="keyword">FROM</span> alpine AS build</span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> . .</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> apk add clang</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> clang -o /hello hello.c</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">FROM</span> scratch</span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> --from=build /hello /</span></span><br></pre></td></tr></table></figure><p>在docker build命令中，可以指定多个构建的上下文，并在dockerfile中选择其中某个上下文中的文件进行拷贝，对应选项中的context。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 运行 Docker 构建时，指定两个构建上下文</span></span><br><span class="line">docker build -t myapp \</span><br><span class="line">  --build-context source1=. \</span><br><span class="line">  --build-context source2=../other-folder \</span><br><span class="line">  -f Dockerfile .</span><br></pre></td></tr></table></figure><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 在 Dockerfile 中，从指定的构建上下文 &quot;source2&quot; 中复制文件</span></span><br><span class="line"><span class="keyword">FROM</span> alpine:latest</span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> --from=source2 /extra-files/ /app/</span></span><br></pre></td></tr></table></figure><h4 id="2-6-1-2-–chown-–chmod"><a href="#2-6-1-2-–chown-–chmod" class="headerlink" title="2.6.1.2. –chown,–chmod"></a>2.6.1.2. –chown,–chmod</h4><p>这两个选项只有在Linux中构建镜像的时候才有效</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">COPY</span><span class="language-bash"> [--<span class="built_in">chown</span>=&lt;user&gt;:&lt;group&gt;] [--<span class="built_in">chmod</span>=&lt;perms&gt; ...] &lt;src&gt; ... &lt;dest&gt;</span></span><br></pre></td></tr></table></figure><p>在COPY的时候，默认是使用0号PGID&#x2F;PUID进行操作的。如果你想避免默认的root权限，可以通过这两个选项进行修改。参数和linux本地的chown&#x2F;chmod命令一致。</p><h4 id="2-6-1-3-–link"><a href="#2-6-1-3-–link" class="headerlink" title="2.6.1.3. –link"></a>2.6.1.3. –link</h4><p>详见<a href="https://docs.docker.com/reference/dockerfile/#copy---link">官方文档</a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">COPY [--link[=&lt;boolean&gt;]] &lt;src&gt; ... &lt;dest&gt;</span><br></pre></td></tr></table></figure><p>下面的图片展示了使用<code>--link</code>和不使用这个选项时的区别。使用link的时候，会从一个空镜像里面构建文件，再最终合并到原有镜像上。</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/07/919bea31fa7c37892d94c569cf17382b.png" alt="image.png"></p><h4 id="2-6-1-4-–parents"><a href="#2-6-1-4-–parents" class="headerlink" title="2.6.1.4. –parents"></a>2.6.1.4. –parents</h4><p>在拷贝文件的时候保留父目录。目前尚未在稳定版中推出此功能，需要使用<code>docker/dockerfile:1.7-labs</code>版本。</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">COPY</span><span class="language-bash"> [--parents[=&lt;boolean&gt;]] &lt;src&gt; ... &lt;dest&gt;</span></span><br></pre></td></tr></table></figure><p>举个例子，当我们使用如下语句，拷贝a.txt到镜像中时，最终会存在<code>/app/a.txt</code>文件</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">COPY</span><span class="language-bash"> ./b/a.txt /app/</span></span><br></pre></td></tr></table></figure><p>但如果加上了保留父目录的选项，则会保留这个txt文件的父目录b，最终会存在<code>/app/b/a.txt</code>文件</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">COPY</span><span class="language-bash"> --parents ./b/a.txt /app/</span></span><br></pre></td></tr></table></figure><p>在同时拷贝多个文件的时候，这样做就有效果了。如下所示，第一行的copy没有设置保留父目录，此时两个文件中的<code>a.txt</code>最终只在镜像内保留了一个（应该保留的是y的那一个），出现了文件被覆盖的问题。使用了<code>--parents</code>选项就不会有这个问题了。</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># syntax=docker/dockerfile:1.7-labs</span></span><br><span class="line"><span class="keyword">FROM</span> scratch</span><br><span class="line"></span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> ./x/a.txt ./y/a.txt /no_parents/</span></span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> --parents ./x/a.txt ./y/a.txt /parents/</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># /no_parents/a.txt</span></span><br><span class="line"><span class="comment"># /parents/x/a.txt</span></span><br><span class="line"><span class="comment"># /parents/y/a.txt</span></span><br></pre></td></tr></table></figure><h4 id="2-6-1-5-–excule"><a href="#2-6-1-5-–excule" class="headerlink" title="2.6.1.5. –excule"></a>2.6.1.5. –excule</h4><p>允许在拷贝的时候忽略某些路径中的内容。目前尚未在稳定版中推出此功能，需要使用<code>docker/dockerfile:1.7-labs</code>版本。</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">COPY</span><span class="language-bash"> [--exclude=&lt;path&gt; ...] &lt;src&gt; ... &lt;dest&gt;</span></span><br></pre></td></tr></table></figure><h2 id="2-7-ADD"><a href="#2-7-ADD" class="headerlink" title="2.7. ADD"></a>2.7. ADD</h2><p>ADD命令是更加高级的COPY命令，它有两种形式。如果路径中包含空格，则必须使用第二种形式（将路径使用英文双引号括起来）</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ADD</span><span class="language-bash"> [OPTIONS] &lt;src&gt; ... &lt;dest&gt;</span></span><br><span class="line"><span class="keyword">ADD</span><span class="language-bash"> [OPTIONS] [<span class="string">&quot;&lt;src&gt;&quot;</span>, ... <span class="string">&quot;&lt;dest&gt;&quot;</span>]</span></span><br></pre></td></tr></table></figure><p>当源文件是tar压缩文件，压缩方式为gzip、bzip或xz的情况下，ADD命令会自动将压缩包中的内容解压并复制到目标路径中。但是这个解压是不可以关闭的，即如果你不需要解压压缩包，则只能使用COPY命令。</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 将 archive.tar.gz 解压缩到镜像的 /app 目录</span></span><br><span class="line"><span class="keyword">ADD</span><span class="language-bash"> archive.tar.gz /app/</span></span><br><span class="line"><span class="comment"># 从 URL 下载文件并放在镜像的 /app 目录</span></span><br><span class="line"><span class="keyword">ADD</span><span class="language-bash"> https://example.com/file.txt /app/</span></span><br></pre></td></tr></table></figure><h3 id="2-7-1-选项说明"><a href="#2-7-1-选项说明" class="headerlink" title="2.7.1. 选项说明"></a>2.7.1. 选项说明</h3><p>下面是可选的OPTIONS</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">--keep-git-dir</span><br><span class="line">--checksum</span><br><span class="line">--chown</span><br><span class="line">--chmod</span><br><span class="line">--link</span><br><span class="line">--exclude</span><br></pre></td></tr></table></figure><h4 id="2-7-1-1-–keep-git-dir"><a href="#2-7-1-1-–keep-git-dir" class="headerlink" title="2.7.1.1. –keep-git-dir"></a>2.7.1.1. –keep-git-dir</h4><p> 默认情况下，如果src是一个git仓库连接，则ADD会忽略<code>.git</code>目录。将下面这个选项设置为true，则会保留<code>.git</code>目录</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">--keep-git-dir=&lt;boolean&gt; </span><br><span class="line"><span class="comment"># 示例</span></span><br><span class="line">ADD --keep-git-dir=<span class="literal">true</span> https://github.com/moby/buildkit.git<span class="comment">#v0.10.1 /buildkit</span></span><br></pre></td></tr></table></figure><h4 id="2-7-1-2-–checksum"><a href="#2-7-1-2-–checksum" class="headerlink" title="2.7.1.2. –checksum"></a>2.7.1.2. –checksum</h4><p>如果src是一个HTTP的连接（只支持HTTP&#x2F;HTTPS下载的文件），则可以使用checksum设置这个文件的校验和，ADD命令会在下载了文件之后自动进行校验，判断是否下载成功。</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ADD</span><span class="language-bash"> [--checksum=&lt;<span class="built_in">hash</span>&gt;] &lt;src&gt; ... &lt;<span class="built_in">dir</span>&gt;</span></span><br><span class="line"><span class="comment"># 示例</span></span><br><span class="line"><span class="keyword">ADD</span><span class="language-bash"> --checksum=sha256:24454f830cdb571e2c4ad15481119c43b3cafd48dd869a9b2945d1036d1dc68d https://mirrors.edge.kernel.org/pub/linux/kernel/Historic/linux-0.01.tar.gz /</span></span><br></pre></td></tr></table></figure><h4 id="2-7-1-3-剩余选项"><a href="#2-7-1-3-剩余选项" class="headerlink" title="2.7.1.3. 剩余选项"></a>2.7.1.3. 剩余选项</h4><p>剩下的几个选项，和COPY命令中的选项作用一致，详情可查看上文中对COPY命令的说明。</p><h2 id="2-8-CMD"><a href="#2-8-CMD" class="headerlink" title="2.8. CMD"></a>2.8. CMD</h2><p>CMD命令指定了容器以神马命令启动，同时它也可以是ENTRYPOINT的扩展</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 直接设置这个命令</span></span><br><span class="line"><span class="keyword">CMD</span><span class="language-bash"> executable param1 parma2</span></span><br><span class="line"><span class="comment"># 等价于上面这样直接设置</span></span><br><span class="line"><span class="keyword">CMD</span><span class="language-bash"> [<span class="string">&quot;executable&quot;</span>,<span class="string">&quot;param1&quot;</span>,<span class="string">&quot;param2&quot;</span>]</span></span><br><span class="line"><span class="comment"># 如果设置了ENTREPOINT，可以在后面使用CMD设置额外的命令选项（可以被docker run改变）</span></span><br><span class="line"><span class="comment"># 注意，ENTREPOINT必须采用exec格式才能使用CMD继续追加命令选项！</span></span><br><span class="line"><span class="keyword">CMD</span><span class="language-bash"> [<span class="string">&quot;param1&quot;</span>,<span class="string">&quot;param2&quot;</span>]</span></span><br></pre></td></tr></table></figure><p>如果一个容器没有指定ENTREPOINT或者CMD，则必须在docker run的时候指定才能正常运行。如果一个容器<strong>只指定了CMD</strong>，则可以被docker run指定的命令覆盖。</p><h2 id="2-9-ENTRYPOINT"><a href="#2-9-ENTRYPOINT" class="headerlink" title="2.9. ENTRYPOINT"></a>2.9. ENTRYPOINT</h2><p>ENTRYPOINT指定了容器以神马命令启动，同样有exec和shell两种格式。</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># exec格式</span></span><br><span class="line"><span class="comment"># 注意，ENTREPOINT必须采用exec格式才能使用CMD继续追加命令选项！</span></span><br><span class="line"><span class="keyword">ENTRYPOINT</span><span class="language-bash"> [<span class="string">&quot;executable&quot;</span>, <span class="string">&quot;param1&quot;</span>, <span class="string">&quot;param2&quot;</span>]</span></span><br><span class="line"><span class="comment"># shell格式</span></span><br><span class="line"><span class="keyword">ENTRYPOINT</span><span class="language-bash"> <span class="built_in">command</span> param1 param2</span></span><br></pre></td></tr></table></figure><p>设置了ENTRYPOINT后，在docker run里面提供的命令就不再是启动命令，而是发送给ENTRYPOINT命令的参数了。</p><p>前文提到了可以在ENTRYPOINT之后进一步设置CMD来启动进程，如下所示，下面这个dockerfile，最终启动进程使用的命令是<code>top -b -c</code>。其中<code>-c</code>选项会被docker run提供的命令覆盖（此时docker run提供的命令是发送给ENTRYPOINT命令的参数，会覆盖CMD）</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> ubuntu</span><br><span class="line"><span class="keyword">ENTRYPOINT</span><span class="language-bash"> [<span class="string">&quot;top&quot;</span>, <span class="string">&quot;-b&quot;</span>]</span></span><br><span class="line"><span class="keyword">CMD</span><span class="language-bash"> [<span class="string">&quot;-c&quot;</span>]</span></span><br></pre></td></tr></table></figure><p>我们可以写个自己的程序来验证一下这里的命令行参数</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc,<span class="type">char</span>*argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Run as: %s &quot;</span>,argv[<span class="number">0</span>]);</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i&lt;argc;i++)&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s &quot;</span>,argv[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个程序会把我们提供的命令行参数打印出来</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ gcc test.c -o test</span><br><span class="line">$ ./test -c -o</span><br><span class="line">Run as: ./test -c -o </span><br></pre></td></tr></table></figure><p>使用如下dockerfile来进行操作</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># syntax=docker/dockerfile:1</span></span><br><span class="line"><span class="keyword">FROM</span> alpine AS build</span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> . .</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> apk add clang</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> clang -o /test test.c</span></span><br><span class="line"><span class="keyword">ENTRYPOINT</span><span class="language-bash"> [<span class="string">&quot;/test&quot;</span>,<span class="string">&quot;-entry&quot;</span>]</span></span><br><span class="line"><span class="keyword">CMD</span><span class="language-bash"> [<span class="string">&quot;-cmd&quot;</span>]</span></span><br></pre></td></tr></table></figure><p>使用如下命令，可见CMD的参数会追加在原有命令行参数之后，而且会被docker run使用的命令覆盖。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ docker build . -t myub</span><br><span class="line">$ docker run myub</span><br><span class="line">Run as: /test -entry -cmd </span><br><span class="line">$ docker run myub -run -h</span><br><span class="line">Run as: /test -entry -run -h </span><br></pre></td></tr></table></figure><p>根据dockerfile的官方文档，你可以用ENTRYPOINT指定稳定的命令选项，并使用CMD指定一些可用的命令选项</p><blockquote><p>You can use the exec form of ENTRYPOINT to set fairly stable default commands and arguments and then use either form of CMD to set additional defaults that are more likely to be changed.</p></blockquote><h2 id="2-10-ARG和ENV"><a href="#2-10-ARG和ENV" class="headerlink" title="2.10. ARG和ENV"></a>2.10. ARG和ENV</h2><h3 id="2-10-1-介绍"><a href="#2-10-1-介绍" class="headerlink" title="2.10.1. 介绍"></a>2.10.1. 介绍</h3><p>在介绍的表格里面说明了这两个语法的区别</p><ul><li>ARG：设置镜像构建过程中使用的环境变量，只有构建过程中才有效，构建完成的镜像中不包括这个环境变量，可以在<code>docker build</code>中通过<code>--build-arg &lt;varname&gt;=&lt;value&gt;</code>覆盖；</li><li>ENV：构建过程和镜像中都会存在的环境变量，可以在<code>docker run</code>中通过<code>-e &lt;key&gt;=&lt;value&gt;</code>来覆盖；</li></ul><p>同时这两个命令的语法也有细微区别，即ARG可以省略环境变量的默认值（相当于要求build的时候传入）</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ARG</span> &lt;name&gt;[=&lt;default value&gt;]</span><br><span class="line"><span class="keyword">ENV</span> &lt;key&gt;=&lt;value&gt; ...</span><br></pre></td></tr></table></figure><h3 id="2-10-2-ENV测试"><a href="#2-10-2-ENV测试" class="headerlink" title="2.10.2. ENV测试"></a>2.10.2. ENV测试</h3><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> ubuntu:<span class="number">22.04</span></span><br><span class="line"><span class="comment"># env设置的环境变量，在构建过程和实际的容器中都会存在</span></span><br><span class="line"><span class="keyword">ENV</span> MY_VAR=from_dockerfile</span><br><span class="line"><span class="keyword">CMD</span><span class="language-bash"> <span class="built_in">echo</span> <span class="string">&quot;MY_VAR is <span class="variable">$&#123;MY_VAR&#125;</span>&quot;</span></span></span><br></pre></td></tr></table></figure><p>使用这个dockerfile构建一个镜像，并创建容器</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker build . -t myub:<span class="built_in">test</span> -f dockefile</span><br><span class="line">docker run --<span class="built_in">rm</span> myub:<span class="built_in">test</span>  <span class="comment"># --rm会在容器运行完毕后自动删除</span></span><br></pre></td></tr></table></figure><p>容器会在终端中输出我们刚刚设置的环境变量。注意这里我们是使用CMD命令来执行的这个echo语句，CMD是在容器创建之后，执行的命令，也就是ENV的设置已经保留到了容器中。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ docker run --rm myub:test</span><br><span class="line">MY_VAR is from_dockerfile</span><br></pre></td></tr></table></figure><p>使用<code>-it</code>交互式地创建这个容器，在容器内的终端中使用env命令也可以看到这个环境变量</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -it --rm myub:test /bin/bash</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/07/42915bc3579a24611a1c599a5a34111f.png" alt="image.png"></p><p>在docker run命令中用<code>-e</code>选项，可以覆盖这个环境变量</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run --<span class="built_in">rm</span> -e MY_VAR=from_docker_run myub:<span class="built_in">test</span> </span><br></pre></td></tr></table></figure><p>执行效果如下，最终打印的环境变量是我们run命令中配置的了（容器内的环境变量也会被修改）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ docker run --rm -e MY_VAR=from_docker_run myub:test</span><br><span class="line">MY_VAR is from_docker_run</span><br></pre></td></tr></table></figure><p>修改dockerfile中的CMD为RUN，让echo命令在构建过程中执行</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> ubuntu:<span class="number">22.04</span></span><br><span class="line"><span class="comment"># env设置的环境变量，在构建过程和实际的容器中都会存在</span></span><br><span class="line"><span class="keyword">ENV</span> MY_VAR=from_dockerfile</span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> <span class="built_in">echo</span> <span class="string">&quot;MY_VAR is <span class="variable">$&#123;MY_VAR&#125;</span>&quot;</span></span></span><br></pre></td></tr></table></figure><p>可以看到，构建过程中，ENV环境变量也生效了。</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/07/178160d2912a0bdb3f056fada0ba1716.png" alt="image.png"></p><p>当然，生效的前提是ENV在RUN之前，如果ENV在RUN之后，那自然是无效了。</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/07/c3270bc5e9800978ae8f56845f6d1797.png" alt="image.png"></p><p>另外，ENV指定的环境变量必须赋值初始值，否则语法会报错</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> ubuntu:<span class="number">22.04</span></span><br><span class="line"><span class="comment"># env设置的环境变量，在构建过程和实际的容器中都会存在</span></span><br><span class="line"><span class="comment"># 这里省略等于号是不支持的语法，如果不知道环境变量设置什么值，可以先等于空串</span></span><br><span class="line"><span class="keyword">ENV</span> MY_VAR </span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> <span class="built_in">echo</span> <span class="string">&quot;MY_VAR is <span class="variable">$&#123;MY_VAR&#125;</span>&quot;</span></span></span><br></pre></td></tr></table></figure><p>docker build的时候会提示语法错误，ENV必须要有两个参数（即必须要给定初始值）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">dockerfile:3</span><br><span class="line">--------------------</span><br><span class="line">   1 |     FROM ubuntu:22.04</span><br><span class="line">   2 |     # env设置的环境变量，在构建过程和实际的容器中都会存在</span><br><span class="line">   3 | &gt;&gt;&gt; ENV MY_VAR</span><br><span class="line">   4 |     RUN echo &quot;MY_VAR is $&#123;MY_VAR&#125;&quot;</span><br><span class="line">   5 |     </span><br><span class="line">--------------------</span><br><span class="line">ERROR: failed to solve: ENV must have two arguments</span><br></pre></td></tr></table></figure><h3 id="2-10-3-ARG测试"><a href="#2-10-3-ARG测试" class="headerlink" title="2.10.3. ARG测试"></a>2.10.3. ARG测试</h3><p>将ENV改成ARG，继续测试</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> ubuntu:<span class="number">22.04</span></span><br><span class="line"><span class="comment"># arg设置的环境变量，在构建过程中才会存在</span></span><br><span class="line"><span class="keyword">ARG</span> MY_VAR=from_dockerfile</span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> <span class="built_in">echo</span> <span class="string">&quot;MY_VAR is <span class="variable">$&#123;MY_VAR&#125;</span>&quot;</span></span></span><br></pre></td></tr></table></figure><p>可见环境变量在构建过程中生效了</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/07/0a9ed50597d6f6e35f426909a9f03b48.png" alt="image.png"></p><p>在docker build命令中可以覆盖dockerfile中设置的环境变量</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker build . -t myub --build-arg MY_VAR=from_docker_build</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/07/19045a7063d5d2b04c2a2c3f76b95184.png" alt="image.png"></p><p>另外，ARG设置的时候，环境变量之后是可以不带等于号的。此时相当于没有设置这个环境变量。</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> ubuntu:<span class="number">22.04</span></span><br><span class="line"><span class="comment"># arg设置的环境变量，在构建过程中才会存在</span></span><br><span class="line"><span class="keyword">ARG</span> MY_VAR</span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> <span class="built_in">echo</span> <span class="string">&quot;MY_VAR is <span class="variable">$&#123;MY_VAR&#125;</span>&quot;</span></span></span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/07/d456a37f4282fb622a60249fb4641a12.png" alt="image.png"></p><h2 id="2-11-VOLUME"><a href="#2-11-VOLUME" class="headerlink" title="2.11. VOLUME"></a>2.11. VOLUME</h2><p>在docker volume的解析中已经说明了数据卷的重要性。只要你的容器运行过程中，有需要持久化保存的重要数据，则都建议使用VOLUME在dockerfile中标出。这样即便用户没有主动绑定指定路径的数据卷，docker也会自动创建匿名数据卷来保存这里面的数据，不至于出现数据丢失问题。</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># exec格式</span></span><br><span class="line"><span class="keyword">VOLUME</span><span class="language-bash"> [<span class="string">&quot;/data&quot;</span>]</span></span><br><span class="line"><span class="comment"># shell格式，等价于[&quot;/data1&quot;,&quot;/data2&quot;]</span></span><br><span class="line"><span class="keyword">VOLUME</span><span class="language-bash"> /data1 /data2</span></span><br></pre></td></tr></table></figure><p>下面是官网上给出的一些说明。比如在json格式中，必须用双引号括起来目录名，不能使用单引号；volume的挂载是基于宿主机的，所以不能在dockerfile中指定最终挂载的host-dir，必须用户手动使用docker run命令来指定，或者由docker自行创建volume数据卷。</p><blockquote><p>Keep the following things in mind about volumes in the Dockerfile.</p><p>Volumes on Windows-based containers: When using Windows-based containers, the destination of a volume inside the container must be one of:</p><ul><li>a non-existing or empty directory</li><li>a drive other than <code>C:</code></li></ul><p>Changing the volume from within the Dockerfile: If any build steps change the data within the volume after it has been declared, those changes will be discarded.</p><p>JSON formatting: The list is parsed as a JSON array. You must enclose words with double quotes <code>(&quot;)</code> rather than single quotes <code>(&#39;)</code>.</p><p>The host directory is declared at container run-time: The host directory (the mountpoint) is, by its nature, host-dependent. This is to preserve image portability, since a given host directory can’t be guaranteed to be available on all hosts. For this reason, you can’t mount a host directory from within the Dockerfile. The VOLUME instruction does not support specifying a host-dir parameter. You must specify the mountpoint when you create or run the container.</p></blockquote><h2 id="2-12-EXPOSE"><a href="#2-12-EXPOSE" class="headerlink" title="2.12. EXPOSE"></a>2.12. EXPOSE</h2><p>指定容器需要对外提供服务的端口。比如nginx的80和443端口。且可以在dockerfile中设置默认绑定的端口值。</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">EXPOSE</span> &lt;port&gt; [&lt;port&gt;/&lt;protocol&gt;...]</span><br></pre></td></tr></table></figure><p>当一个EXPOSE的端口没有被用户设置，也没有默认值时，docker会自动绑定一个未被使用的端口给他。</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 暴露3000端口给外部（默认是tcp）</span></span><br><span class="line"><span class="keyword">EXPOSE</span> <span class="number">3000</span></span><br><span class="line"><span class="comment"># 暴露6000端口给外部，并设置默认绑定宿主机的60000端口</span></span><br><span class="line"><span class="keyword">EXPOSE</span> <span class="number">6000</span> <span class="number">60000</span>/tcp</span><br><span class="line"><span class="comment"># 暴露10000的udp端口给外部，并设置默认绑定宿主机的12000端口</span></span><br><span class="line"><span class="keyword">EXPOSE</span> <span class="number">10000</span>/udp <span class="number">12000</span>/udp</span><br></pre></td></tr></table></figure><p>注意，这里的默认绑定端口设置，只有在bridge模式创建容器的时候才会生效。如果用户使用host模式，那么就会采用<strong>原有端口</strong>（比如暴露6000端口，使用host模式就会直接绑定宿主机的6000端口，和默认值无关）绑定在宿主机上。</p><p>在host模式中，容器可以绑定宿主机的任意未使用端口，即便这些端口没有在EXPOSE中被设置。所以，如果你不想容器中的网络进程影响宿主机上的有效端口数量，则建议使用bridge模式来增强隔离性。</p><p>不管EXPOSE是如何设置的，在docker run中都可以被覆盖</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -p 80:80/tcp -p 80:80/udp ...</span><br></pre></td></tr></table></figure><p>另外，EXPOSE只是代表容器“想要”使用这些端口，最终端口的bind操作是由容器内的进程来处理的。当然，使用bridge选项时，docker引擎会帮容器先确认宿主机的端口可用并占用，再由容器内的进程bind容器内的端口，对外提供服务。</p><h2 id="2-13-ONBUILD"><a href="#2-13-ONBUILD" class="headerlink" title="2.13. ONBUILD"></a>2.13. ONBUILD</h2><p>ONBUILD指定的dockerfile语句会在尝试基于当前镜像构建镜像的时候被启用。</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ONBUILD</span> &lt;INSTRUCTION&gt;</span><br></pre></td></tr></table></figure><p>来测试一下</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> ubuntu:<span class="number">22.04</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> <span class="built_in">echo</span> <span class="string">&quot;running build&quot;</span></span></span><br><span class="line"><span class="keyword">ONBUILD</span> <span class="keyword">RUN</span><span class="language-bash"> <span class="built_in">echo</span> <span class="string">&quot;on build&quot;</span></span></span><br></pre></td></tr></table></figure><p>可以看到，构建的时候，只有不带<code>ONBUILD</code>选项的命令才被执行了</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/07/769e9b38abe47a9d1a772a4775bbda6e.png" alt="image.png"></p><p>我们基于这个构建出来的镜像，再写一个dockerfile</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> myub:latest </span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> <span class="built_in">echo</span> <span class="string">&quot;running build from myub&quot;</span></span></span><br></pre></td></tr></table></figure><p>可以看到，构建过程会先执行父镜像ONBUILD设置的命令，再执行自己dockerfile中的命令</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/07/182ae6b6d386df0988ab3883ab8b9be6.png" alt="image.png"></p><h2 id="2-14-STOPSIGNAL"><a href="#2-14-STOPSIGNAL" class="headerlink" title="2.14. STOPSIGNAL"></a>2.14. STOPSIGNAL</h2><p>STOPSIGNAL设置docker内<strong>运行的进程</strong>在收到什么信号的时候会终止，即docker stop某个容器时，docker会给容器内进程发送的信号。</p><p>这里的signal可以是信号的名称（如<code>SIGKILL</code>）也可以是信号的编号。默认值是<code>SIGTERM</code>。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">STOPSIGNAL signal</span><br></pre></td></tr></table></figure><p>关于信号的编号和名称，可以在linux下使用<code>kill -l</code>命令查看</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">$ kill -l</span><br><span class="line"> 1) SIGHUP       2) SIGINT       3) SIGQUIT      4) SIGILL       5) SIGTRAP</span><br><span class="line"> 6) SIGABRT      7) SIGBUS       8) SIGFPE       9) SIGKILL     10) SIGUSR1</span><br><span class="line">11) SIGSEGV     12) SIGUSR2     13) SIGPIPE     14) SIGALRM     15) SIGTERM</span><br><span class="line">16) SIGSTKFLT   17) SIGCHLD     18) SIGCONT     19) SIGSTOP     20) SIGTSTP</span><br><span class="line">21) SIGTTIN     22) SIGTTOU     23) SIGURG      24) SIGXCPU     25) SIGXFSZ</span><br><span class="line">26) SIGVTALRM   27) SIGPROF     28) SIGWINCH    29) SIGIO       30) SIGPWR</span><br><span class="line">31) SIGSYS      34) SIGRTMIN    35) SIGRTMIN+1  36) SIGRTMIN+2  37) SIGRTMIN+3</span><br><span class="line">38) SIGRTMIN+4  39) SIGRTMIN+5  40) SIGRTMIN+6  41) SIGRTMIN+7  42) SIGRTMIN+8</span><br><span class="line">43) SIGRTMIN+9  44) SIGRTMIN+10 45) SIGRTMIN+11 46) SIGRTMIN+12 47) SIGRTMIN+13</span><br><span class="line">48) SIGRTMIN+14 49) SIGRTMIN+15 50) SIGRTMAX-14 51) SIGRTMAX-13 52) SIGRTMAX-12</span><br><span class="line">53) SIGRTMAX-11 54) SIGRTMAX-10 55) SIGRTMAX-9  56) SIGRTMAX-8  57) SIGRTMAX-7</span><br><span class="line">58) SIGRTMAX-6  59) SIGRTMAX-5  60) SIGRTMAX-4  61) SIGRTMAX-3  62) SIGRTMAX-2</span><br><span class="line">63) SIGRTMAX-1  64) SIGRTMAX</span><br></pre></td></tr></table></figure><p>在docker run和docker create中可以使用<code>--stop-signal</code>选项覆盖dockerfile中的设置。</p><h2 id="2-15-HEALTHCHECK"><a href="#2-15-HEALTHCHECK" class="headerlink" title="2.15. HEALTHCHECK"></a>2.15. HEALTHCHECK</h2><p><a href="https://docs.docker.com/reference/dockerfile/#healthcheck">https://docs.docker.com/reference/dockerfile/#healthcheck</a></p><p>用于检查容器的健康状态，如果检查失败（可以设置重试次数），则会将容器标记为<strong>不健康</strong>。这可以方便集群化管理，特别是解决某些容器内服务器进程虽然仍在运行，但因为某些原因已经无法提供服务的情况。</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 基础语法</span></span><br><span class="line"><span class="keyword">HEALTHCHECK</span><span class="language-bash"> [OPTIONS] CMD <span class="built_in">command</span></span></span><br><span class="line"><span class="comment"># 禁用健康检查，包括从父镜像继承下来的检查</span></span><br><span class="line"><span class="keyword">HEALTHCHECK</span><span class="language-bash"> NONE</span></span><br></pre></td></tr></table></figure><p>下面是一个示例，docker会每5分钟使用curl检查一下<code>http://localhost:8080/</code>是否可以被访问，如果超过3秒还没有反应，则认为它不能被访问。</p><p>当curl返回的状态码不是2xx&#x2F;3xx的时候，则exit 1表示不成功。告知HEALTHCHECK认为容器不健康。</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">HEALTHCHECK</span><span class="language-bash"> --interval=5m --<span class="built_in">timeout</span>=3s \</span></span><br><span class="line"><span class="language-bash">  CMD curl -f http://localhost:8080/ || <span class="built_in">exit</span> 1</span></span><br></pre></td></tr></table></figure><p>一次检查可能不太好，我们可以设置重试次数（<strong>默认会重试3次</strong>），下面就使用retries指定了重试两次</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">HEALTHCHECK</span><span class="language-bash"> --interval=5m --<span class="built_in">timeout</span>=3s --retries=2 \</span></span><br><span class="line"><span class="language-bash">  CMD curl -f http://localhost:8080/ || <span class="built_in">exit</span> 1</span></span><br></pre></td></tr></table></figure><h2 id="2-16-USER"><a href="#2-16-USER" class="headerlink" title="2.16. USER"></a>2.16. USER</h2><p>指定用于执行构建命令和最终执行CMD&#x2F;ENTRYPOINT命令使用的用户&#x2F;用户组。</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">USER</span> &lt;<span class="keyword">user</span>&gt;[:&lt;group&gt;]</span><br><span class="line"><span class="keyword">USER</span> UID[:GID]</span><br></pre></td></tr></table></figure><blockquote><p>Note that when specifying a group for the user, the user will have only the specified group membership. Any other configured group memberships will be ignored.</p></blockquote><h1 id="3-验证dockerfile命令对镜像层数的影响"><a href="#3-验证dockerfile命令对镜像层数的影响" class="headerlink" title="3. 验证dockerfile命令对镜像层数的影响"></a>3. 验证dockerfile命令对镜像层数的影响</h1><p>前文提到，dockerfile中的一条命令就是一层，如果冗余的命令过多，会让构建出来的dockerfile层级过多。下面通过一个例子来实际验证一下。</p><blockquote><p>参考 <a href="https://developer.aliyun.com/article/981453">Docker 进阶之镜像分层详解</a></p></blockquote><h2 id="3-1-查看基础镜像的层级"><a href="#3-1-查看基础镜像的层级" class="headerlink" title="3.1. 查看基础镜像的层级"></a>3.1. 查看基础镜像的层级</h2><p>测试基于<code>ubuntu:22.04</code>的镜像，首先使用<code>docker inspect</code>命令查看这个镜像的所有层</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker inspect ubuntu:22.04</span><br></pre></td></tr></table></figure><p>得到的结果如下，其中<code>RootFS/Layers</code>是这个镜像的所有层级。可见ubuntu的镜像只有一层。</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">[</span></span><br><span class="line">    <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;Id&quot;</span><span class="punctuation">:</span> <span class="string">&quot;sha256:52882761a72a60649edff9a2478835325d084fb640ea32a975e29e12a012025f&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;RepoTags&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">            <span class="string">&quot;ubuntu:22.04&quot;</span></span><br><span class="line">        <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;RepoDigests&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">            <span class="string">&quot;ubuntu@sha256:a6d2b38300ce017add71440577d5b0a90460d0e57fd7aec21dd0d1b0761bbfb2&quot;</span></span><br><span class="line">        <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;Parent&quot;</span><span class="punctuation">:</span> <span class="string">&quot;&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;Comment&quot;</span><span class="punctuation">:</span> <span class="string">&quot;&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;Created&quot;</span><span class="punctuation">:</span> <span class="string">&quot;2024-04-27T13:18:37.512234142Z&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;DockerVersion&quot;</span><span class="punctuation">:</span> <span class="string">&quot;24.0.5&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;Author&quot;</span><span class="punctuation">:</span> <span class="string">&quot;&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;Config&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;Hostname&quot;</span><span class="punctuation">:</span> <span class="string">&quot;&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;Domainname&quot;</span><span class="punctuation">:</span> <span class="string">&quot;&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;User&quot;</span><span class="punctuation">:</span> <span class="string">&quot;&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;AttachStdin&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">false</span></span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;AttachStdout&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">false</span></span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;AttachStderr&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">false</span></span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;Tty&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">false</span></span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;OpenStdin&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">false</span></span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;StdinOnce&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">false</span></span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;Env&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">                <span class="string">&quot;PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin&quot;</span></span><br><span class="line">            <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;Cmd&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">                <span class="string">&quot;/bin/bash&quot;</span></span><br><span class="line">            <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;Image&quot;</span><span class="punctuation">:</span> <span class="string">&quot;sha256:2252dc08ad59a3723b856050e7848a7fe152b469dd24cf30b0a910b7c615766c&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;Volumes&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">null</span></span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;WorkingDir&quot;</span><span class="punctuation">:</span> <span class="string">&quot;&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;Entrypoint&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">null</span></span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;OnBuild&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">null</span></span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;Labels&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">                <span class="attr">&quot;org.opencontainers.image.ref.name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;ubuntu&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;org.opencontainers.image.version&quot;</span><span class="punctuation">:</span> <span class="string">&quot;22.04&quot;</span></span><br><span class="line">            <span class="punctuation">&#125;</span></span><br><span class="line">        <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;Architecture&quot;</span><span class="punctuation">:</span> <span class="string">&quot;amd64&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;Os&quot;</span><span class="punctuation">:</span> <span class="string">&quot;linux&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;Size&quot;</span><span class="punctuation">:</span> <span class="number">77863352</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;GraphDriver&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;Data&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">                <span class="attr">&quot;MergedDir&quot;</span><span class="punctuation">:</span> <span class="string">&quot;/var/lib/docker/overlay2/fbc6cfc7d29a6660ebf2a172548649ec0ce6a2578f369a2076b13f6f8a1b375c/merged&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;UpperDir&quot;</span><span class="punctuation">:</span> <span class="string">&quot;/var/lib/docker/overlay2/fbc6cfc7d29a6660ebf2a172548649ec0ce6a2578f369a2076b13f6f8a1b375c/diff&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;WorkDir&quot;</span><span class="punctuation">:</span> <span class="string">&quot;/var/lib/docker/overlay2/fbc6cfc7d29a6660ebf2a172548649ec0ce6a2578f369a2076b13f6f8a1b375c/work&quot;</span></span><br><span class="line">            <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;Name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;overlay2&quot;</span></span><br><span class="line">        <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;RootFS&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;Type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;layers&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;Layers&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">                <span class="string">&quot;sha256:629ca62fb7c791374ce57626d6b8b62c76378be091a0daf1a60d32700b49add7&quot;</span></span><br><span class="line">            <span class="punctuation">]</span></span><br><span class="line">        <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;Metadata&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;LastTagTime&quot;</span><span class="punctuation">:</span> <span class="string">&quot;0001-01-01T00:00:00Z&quot;</span></span><br><span class="line">        <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">]</span></span><br></pre></td></tr></table></figure><p>通过docker history命令可以查看这个镜像的构建过程，虽然这里显示了多行，但实际上有效的行只有ADD了ubuntu的系统二进制文件的那一行，其他行都是对这个镜像的基础设置和元数据设置，并没有给镜像实际添加文件。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ docker history  ubuntu:22.04</span><br><span class="line">IMAGE          CREATED      CREATED BY                                      SIZE      COMMENT</span><br><span class="line">52882761a72a   9 days ago   /bin/sh -c #(nop)  CMD [&quot;/bin/bash&quot;]            0B        </span><br><span class="line">&lt;missing&gt;      9 days ago   /bin/sh -c #(nop) ADD file:a5d32dc2ab15ff0d7…   77.9MB    </span><br><span class="line">&lt;missing&gt;      9 days ago   /bin/sh -c #(nop)  LABEL org.opencontainers.…   0B        </span><br><span class="line">&lt;missing&gt;      9 days ago   /bin/sh -c #(nop)  LABEL org.opencontainers.…   0B        </span><br><span class="line">&lt;missing&gt;      9 days ago   /bin/sh -c #(nop)  ARG LAUNCHPAD_BUILD_ARCH     0B        </span><br><span class="line">&lt;missing&gt;      9 days ago   /bin/sh -c #(nop)  ARG RELEASE                  0B  </span><br></pre></td></tr></table></figure><h2 id="3-2-构建两个镜像"><a href="#3-2-构建两个镜像" class="headerlink" title="3.2. 构建两个镜像"></a>3.2. 构建两个镜像</h2><p>下面用两个dockerfile来基于ubuntu构建两个新的镜像。两个dockerfile执行的内容都是一致的，只不过第一个dockerfile中将命令都合并了，第二个dockerfile将命令拆分了。</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 构建myub:1</span></span><br><span class="line"><span class="keyword">FROM</span> ubuntu:<span class="number">22.04</span></span><br><span class="line"><span class="comment"># 在build-essential中会下载tzdata，会交互式的让用户选择时区</span></span><br><span class="line"><span class="comment"># 所以需要设置apt为非交互模式</span></span><br><span class="line"><span class="keyword">ARG</span> DEBIAN_FRONTEND=noninteractive</span><br><span class="line"><span class="keyword">ENV</span> TZ=Asia/Shanghai</span><br><span class="line"><span class="comment"># 更新和安装软件</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> apt-get -y update &amp;&amp; \</span></span><br><span class="line"><span class="language-bash">apt-get -y upgrade &amp;&amp; \</span></span><br><span class="line"><span class="language-bash">apt-get install -y \</span></span><br><span class="line"><span class="language-bash">cmake git vim curl wget \</span></span><br><span class="line"><span class="language-bash">net-tools \</span></span><br><span class="line"><span class="language-bash">openssh-server \</span></span><br><span class="line"><span class="language-bash">build-essential \</span></span><br><span class="line"><span class="language-bash">python3</span></span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/07/63b064c75ef93cd63201a46033c02e5b.png" alt="image.png"></p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 构建myub:2</span></span><br><span class="line"><span class="keyword">FROM</span> ubuntu:<span class="number">22.04</span></span><br><span class="line"><span class="comment"># 在build-essential中会下载tzdata，会交互式的让用户选择时区</span></span><br><span class="line"><span class="comment"># 所以需要设置apt为非交互模式</span></span><br><span class="line"><span class="keyword">ARG</span> DEBIAN_FRONTEND=noninteractive</span><br><span class="line"><span class="keyword">ENV</span> TZ=Asia/Shanghai</span><br><span class="line"><span class="comment"># 更新软件源</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> apt-get -y update</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> apt-get -y upgrade</span></span><br><span class="line"><span class="comment"># 安装一些常用工具</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> apt-get install -y \</span></span><br><span class="line"><span class="language-bash">cmake git vim curl wget \</span></span><br><span class="line"><span class="language-bash">net-tools openssh-server</span></span><br><span class="line"><span class="comment"># 安装依赖</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> apt-get install -y build-essential </span></span><br><span class="line"><span class="comment"># 安装python</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> apt-get install -y python3</span></span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/07/27c2753f592acd2b16e90f50c406c38d.png" alt="image.png"></p><h2 id="3-3-查看构建的两个镜像包含的层级"><a href="#3-3-查看构建的两个镜像包含的层级" class="headerlink" title="3.3. 查看构建的两个镜像包含的层级"></a>3.3. 查看构建的两个镜像包含的层级</h2><p>分别用<code>docker history</code>查看这两个镜像的层级，根据刚刚<code>docker build</code>命令的输出，以2b9f开头的是第一个镜像（命令都写一起了），以8156开头的是命令被拆分了的docker镜像。</p><p>这里能看到第一个现象，虽然两个镜像一个是被拆分的RUN构建出来的，另外一个并没有被拆分，但最终构建出来的镜像大小并没有明显的区别（其实只是本次测试的情况没有区别，其他情况下，一般合并命令构建出来的镜像会更小）。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ docker images</span><br><span class="line">REPOSITORY   TAG       IMAGE ID       CREATED         SIZE</span><br><span class="line">&lt;none&gt;       &lt;none&gt;    8156b17c21a3   2 minutes ago   598MB</span><br><span class="line">&lt;none&gt;       &lt;none&gt;    2b9f30d55cc3   9 minutes ago   596MB</span><br><span class="line">ubuntu       22.04     52882761a72a   9 days ago      77.9MB</span><br></pre></td></tr></table></figure><p>先给这两个镜像打个tag（最好是docker build的时候就用<code>-t</code>选项打tag，我忘记了）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker tag 2b9f30d55cc3 myub:1</span><br><span class="line">docker tag 8156b17c21a3 myub:2</span><br></pre></td></tr></table></figure><p>先来看命令合并的这个，可见它只在原有镜像的基础上，多了RUN命令的这一层。ARG&#x2F;ENV命令虽然会在history中被显示，但并不会增加层级。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">$ docker history myub:1</span><br><span class="line">IMAGE          CREATED          CREATED BY                                      SIZE      COMMENT</span><br><span class="line">2b9f30d55cc3   10 minutes ago   RUN |1 DEBIAN_FRONTEND=noninteractive /bin/s…   518MB     buildkit.dockerfile.v0</span><br><span class="line">&lt;missing&gt;      10 minutes ago   ENV TZ=Asia/Shanghai                            0B        buildkit.dockerfile.v0</span><br><span class="line">&lt;missing&gt;      10 minutes ago   ARG DEBIAN_FRONTEND=noninteractive              0B        buildkit.dockerfile.v0</span><br><span class="line">&lt;missing&gt;      9 days ago       /bin/sh -c #(nop)  CMD [&quot;/bin/bash&quot;]            0B        </span><br><span class="line">&lt;missing&gt;      9 days ago       /bin/sh -c #(nop) ADD file:a5d32dc2ab15ff0d7…   77.9MB    </span><br><span class="line">&lt;missing&gt;      9 days ago       /bin/sh -c #(nop)  LABEL org.opencontainers.…   0B        </span><br><span class="line">&lt;missing&gt;      9 days ago       /bin/sh -c #(nop)  LABEL org.opencontainers.…   0B        </span><br><span class="line">&lt;missing&gt;      9 days ago       /bin/sh -c #(nop)  ARG LAUNCHPAD_BUILD_ARCH     0B        </span><br><span class="line">&lt;missing&gt;      9 days ago       /bin/sh -c #(nop)  ARG RELEASE                  0B    </span><br></pre></td></tr></table></figure><p>通过docker inspect查看详细信息，在Layers中只能看到两层，即对应一条RUN命令创建出来的镜像层。</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line"><span class="attr">&quot;RootFS&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;Type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;layers&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;Layers&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">                <span class="string">&quot;sha256:629ca62fb7c791374ce57626d6b8b62c76378be091a0daf1a60d32700b49add7&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="string">&quot;sha256:2a381621675d1e9a462aa951211a3cf6938a480fcd82796cb18ef85234696014&quot;</span></span><br><span class="line">            <span class="punctuation">]</span></span><br><span class="line">        <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>再来看看命令被拆分的镜像，层数就多了起来</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">$ docker history myub:2</span><br><span class="line">IMAGE          CREATED         CREATED BY                                      SIZE      COMMENT</span><br><span class="line">8156b17c21a3   8 minutes ago   RUN |1 DEBIAN_FRONTEND=noninteractive /bin/s…   10.5kB    buildkit.dockerfile.v0</span><br><span class="line">&lt;missing&gt;      8 minutes ago   RUN |1 DEBIAN_FRONTEND=noninteractive /bin/s…   56.1MB    buildkit.dockerfile.v0</span><br><span class="line">&lt;missing&gt;      8 minutes ago   RUN |1 DEBIAN_FRONTEND=noninteractive /bin/s…   413MB     buildkit.dockerfile.v0</span><br><span class="line">&lt;missing&gt;      9 minutes ago   RUN |1 DEBIAN_FRONTEND=noninteractive /bin/s…   0B        buildkit.dockerfile.v0</span><br><span class="line">&lt;missing&gt;      9 minutes ago   RUN |1 DEBIAN_FRONTEND=noninteractive /bin/s…   50.9MB    buildkit.dockerfile.v0</span><br><span class="line">&lt;missing&gt;      9 minutes ago   ENV TZ=Asia/Shanghai                            0B        buildkit.dockerfile.v0</span><br><span class="line">&lt;missing&gt;      9 minutes ago   ARG DEBIAN_FRONTEND=noninteractive              0B        buildkit.dockerfile.v0</span><br><span class="line">&lt;missing&gt;      9 days ago      /bin/sh -c #(nop)  CMD [&quot;/bin/bash&quot;]            0B        </span><br><span class="line">&lt;missing&gt;      9 days ago      /bin/sh -c #(nop) ADD file:a5d32dc2ab15ff0d7…   77.9MB    </span><br><span class="line">&lt;missing&gt;      9 days ago      /bin/sh -c #(nop)  LABEL org.opencontainers.…   0B        </span><br><span class="line">&lt;missing&gt;      9 days ago      /bin/sh -c #(nop)  LABEL org.opencontainers.…   0B        </span><br><span class="line">&lt;missing&gt;      9 days ago      /bin/sh -c #(nop)  ARG LAUNCHPAD_BUILD_ARCH     0B        </span><br><span class="line">&lt;missing&gt;      9 days ago      /bin/sh -c #(nop)  ARG RELEASE                  0B  </span><br></pre></td></tr></table></figure><p><code>myub:2</code>相比<code>myub:1</code>额外多了4层，也对应的RUN命令的个数</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line"><span class="attr">&quot;RootFS&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;Type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;layers&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;Layers&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">                <span class="string">&quot;sha256:629ca62fb7c791374ce57626d6b8b62c76378be091a0daf1a60d32700b49add7&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="string">&quot;sha256:2ae784f0abd479326b00d2fbe2ba96a16e46056e386275d6f57988fe2ecf3034&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="string">&quot;sha256:fa903b82d02c9769bc58b795b9c1789a45dca63be57e81c7e15df3de2618bda0&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="string">&quot;sha256:3c2f1f7362025cbbb03b9a5760fc7fd72e940b1b768002ec6e15bc677e2657e4&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="string">&quot;sha256:86d0ee2ab97d64cee7d15598f4374bfe1ff940d89d945bbaf66e947e20068a1e&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="string">&quot;sha256:e72805c5ca21af8edf5f6d539da83e62c083436b1a58d00a394b2bf0b6be4a87&quot;</span></span><br><span class="line">            <span class="punctuation">]</span></span><br><span class="line">        <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><h2 id="3-4-分层的影响？"><a href="#3-4-分层的影响？" class="headerlink" title="3.4. 分层的影响？"></a>3.4. 分层的影响？</h2><p>先说结论：根据你的业务需要，选择合适的层数来构建docker镜像。</p><p>docker分层其中之一的目的，就是让构建镜像的时候能更多的<strong>用上缓存</strong>。假设构建容器A和容器B中有相同的操作，<strong>会构建出一个相同的镜像层</strong>，那么这个镜像层<strong>只需要存储一次就行了</strong>，而且下次执行相同的构建操作时，也可以直接使用这个缓存！容器运行的时候，这些镜像的<strong>只读层</strong>同样可以共享，节省了占用的空间。</p><p>所以，<strong>适当</strong>的加多RUN的层数，<strong>且将相同的构建命令放在同一个RUN中</strong>，是可以方便多个容器的构建的。因为单层RUN的缓存能被下一次相同的构建直接用上，构建效率提高！</p><p>同理，在pull拉取远程镜像的时候，如果某一层在本地已有了，也能直接使用本地已有缓存，避免重复拉取。这就好比APP的“增量更新”功能，镜像那么大，如果每一次都得全量下载，网络不好的时候就有的一等了。只拉取有变化的层数，能大大提高效率。</p><p>但是，如果层数太多，新增了太多的小层，那么每一个小层的变化都会使<strong>后续构建的缓存失效</strong>！具体场景也需要具体的考量！</p><h2 id="3-5-分层缓存测试"><a href="#3-5-分层缓存测试" class="headerlink" title="3.5. 分层缓存测试"></a>3.5. 分层缓存测试</h2><h3 id="3-5-1-拉取镜像缓存命中"><a href="#3-5-1-拉取镜像缓存命中" class="headerlink" title="3.5.1. 拉取镜像缓存命中"></a>3.5.1. 拉取镜像缓存命中</h3><p>当我们pull一个redis的6.2版本时，因为之前没有pull过，需要全量下载。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">$ docker pull redis:6.2                 </span><br><span class="line">6.2: Pulling from library/redis</span><br><span class="line">b0a0cf830b12: Pull complete </span><br><span class="line">57ad18570194: Pull complete </span><br><span class="line">056356a7a403: Pull complete </span><br><span class="line">c3351a5ba2a8: Pull complete </span><br><span class="line">1042efef0b42: Pull complete </span><br><span class="line">9f26115a8134: Pull complete </span><br><span class="line">4f4fb700ef54: Pull complete </span><br><span class="line">68d2d706a2f6: Pull complete </span><br><span class="line">Digest: sha256:d4948d011cc38e94f0aafb8f9a60309bd93034e07d10e0767af534512cf012a9</span><br><span class="line">Status: Downloaded newer image for redis:6.2</span><br><span class="line">docker.io/library/redis:6.2</span><br></pre></td></tr></table></figure><p>但当我们pull一个redis的7.0版本时，就不需要全量下载了，因为有一层和6.2版本是一致的，会显示<code>Already exists</code>，使用了本地缓存。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">$ docker pull redis:7.0</span><br><span class="line">7.0: Pulling from library/redis</span><br><span class="line">b0a0cf830b12: Already exists </span><br><span class="line">ea9699b63e68: Pull complete </span><br><span class="line">bf380b81aa96: Pull complete </span><br><span class="line">0164b64ea927: Pull complete </span><br><span class="line">e06189a3bd9d: Pull complete </span><br><span class="line">81fd2c0406f8: Pull complete </span><br><span class="line">4f4fb700ef54: Pull complete </span><br><span class="line">e3a29842ec15: Pull complete </span><br><span class="line">Digest: sha256:084f7275d9a3abc11d9f8905c3377e61e1464880af941b1eb68b8605863000e4</span><br><span class="line">Status: Downloaded newer image for redis:7.0</span><br><span class="line">docker.io/library/redis:7.0</span><br></pre></td></tr></table></figure><h3 id="3-5-2-构建缓存命中"><a href="#3-5-2-构建缓存命中" class="headerlink" title="3.5.2. 构建缓存命中"></a>3.5.2. 构建缓存命中</h3><p>先来看看构建缓存给命中的例子，来个dockerfile3，这里我们前几个命令都和上文构建<code>myub:2</code>使用的命令相同，但是最终安装的软件不同。</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 构建myub:3</span></span><br><span class="line"><span class="keyword">FROM</span> ubuntu:<span class="number">22.04</span></span><br><span class="line"><span class="comment"># 在build-essential中会下载tzdata，会交互式的让用户选择时区</span></span><br><span class="line"><span class="comment"># 所以需要设置apt为非交互模式</span></span><br><span class="line"><span class="keyword">ARG</span> DEBIAN_FRONTEND=noninteractive</span><br><span class="line"><span class="keyword">ENV</span> TZ=Asia/Shanghai</span><br><span class="line"><span class="comment"># 更新软件源</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> apt-get -y update</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> apt-get -y upgrade</span></span><br><span class="line"><span class="comment"># 安装一些常用工具</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> apt-get install -y \</span></span><br><span class="line"><span class="language-bash">python3 vim git cmake net-tools sqlite3</span></span><br></pre></td></tr></table></figure><p>在build的输出中可以看到，前两层<code>apt-get -y update</code>和<code>apt-get -y upgrade</code>直接命中了本地已有的缓存，无需再次构建！</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/07/89162d9895887d381a368e97f7926add.png" alt="image.png"></p><p>不过，<code>apt-get update/upgrade</code>这两个命令的结果是会随着ubuntu系统软件源的更新而进一步变化的。如果想获取最新的软件源，在docker build的时候，可以选择不使用本地的docker缓存，来构建最新的镜像。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker build --no-cache . -t imageName </span><br></pre></td></tr></table></figure><h3 id="3-5-3-构建缓存失效"><a href="#3-5-3-构建缓存失效" class="headerlink" title="3.5.3. 构建缓存失效"></a>3.5.3. 构建缓存失效</h3><p>再来看看什么时候缓存会失效。首先，如果将这里的<code>apt-get</code>命令合并，那么就无法使用本地的缓存了，还是需要重新拉取ubuntu的软件源，执行构建过程。</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 构建myub:4</span></span><br><span class="line"><span class="keyword">FROM</span> ubuntu:<span class="number">22.04</span></span><br><span class="line"><span class="comment"># 在build-essential中会下载tzdata，会交互式的让用户选择时区</span></span><br><span class="line"><span class="comment"># 所以需要设置apt为非交互模式</span></span><br><span class="line"><span class="keyword">ARG</span> DEBIAN_FRONTEND=noninteractive</span><br><span class="line"><span class="keyword">ENV</span> TZ=Asia/Shanghai</span><br><span class="line"><span class="comment"># 更新软件源</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> apt-get -y update &amp;&amp; \</span></span><br><span class="line"><span class="language-bash">apt-get -y upgrade &amp;&amp; \</span></span><br><span class="line"><span class="language-bash">apt-get install -y \</span></span><br><span class="line"><span class="language-bash">python3 vim git cmake net-tools sqlite3</span></span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/07/46f8a4287cf5627aa18fc67b179728df.png" alt="image.png"></p><p>而在原本构建<code>myub:2</code>的过程中，我们有很多的小层，这些小层的变化，同样会让这一层和下层的缓存都失效</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 构建myub:5</span></span><br><span class="line"><span class="keyword">FROM</span> ubuntu:<span class="number">22.04</span></span><br><span class="line"><span class="comment"># 在build-essential中会下载tzdata，会交互式的让用户选择时区</span></span><br><span class="line"><span class="comment"># 所以需要设置apt为非交互模式</span></span><br><span class="line"><span class="keyword">ARG</span> DEBIAN_FRONTEND=noninteractive</span><br><span class="line"><span class="keyword">ENV</span> TZ=Asia/Shanghai</span><br><span class="line"><span class="comment"># 更新软件源</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> apt-get -y update</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> apt-get -y upgrade</span></span><br><span class="line"><span class="comment"># 安装一些常用工具（这个小层和myub:2不同，多安装了sqlite3）</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> apt-get install -y \</span></span><br><span class="line"><span class="language-bash">cmake git vim curl wget \</span></span><br><span class="line"><span class="language-bash">net-tools openssh-server sqlite3</span></span><br><span class="line"><span class="comment"># 安装依赖</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> apt-get install -y build-essential </span></span><br><span class="line"><span class="comment"># 安装python</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> apt-get install -y python3</span></span><br></pre></td></tr></table></figure><p>可以看到，因为RUN命令中多安装了sqlite3，不光这一层需要重新构建，后面没有变动的两层同样需要重新构建，大大增加了构建耗时。</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/07/9243f568cf729a28fd1ae4f6f8f8c4f7.png" alt="image.png"></p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/07/95c6449bd4943ace8de5a4ea2f53a5e4.png" alt="image.png"></p><p>如果我们想新增一个sqlite3包，直接在最后添加一个新的命令，反而可以用上原本的缓存，飞速构建</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 构建myub:6</span></span><br><span class="line"><span class="keyword">FROM</span> ubuntu:<span class="number">22.04</span></span><br><span class="line"><span class="comment"># 在build-essential中会下载tzdata，会交互式的让用户选择时区</span></span><br><span class="line"><span class="comment"># 所以需要设置apt为非交互模式</span></span><br><span class="line"><span class="keyword">ARG</span> DEBIAN_FRONTEND=noninteractive</span><br><span class="line"><span class="keyword">ENV</span> TZ=Asia/Shanghai</span><br><span class="line"><span class="comment"># 更新软件源</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> apt-get -y update</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> apt-get -y upgrade</span></span><br><span class="line"><span class="comment"># 安装一些常用工具</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> apt-get install -y \</span></span><br><span class="line"><span class="language-bash">cmake git vim curl wget \</span></span><br><span class="line"><span class="language-bash">net-tools openssh-server</span></span><br><span class="line"><span class="comment"># 安装依赖</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> apt-get install -y build-essential </span></span><br><span class="line"><span class="comment"># 安装python</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> apt-get install -y python3</span></span><br><span class="line"><span class="comment"># 额外安装sqlite3</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> apt-get install -y sqlite3</span></span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/07/a40126981c119fc06da0912fc904fd6a.png" alt="image.png"></p><h1 id="4-如何减少docker构建镜像的大小？"><a href="#4-如何减少docker构建镜像的大小？" class="headerlink" title="4.如何减少docker构建镜像的大小？"></a>4.如何减少docker构建镜像的大小？</h1><p>参考：<a href="https://blog.csdn.net/qq_39213171/article/details/107789804">Dockerfile最小化构建镜像：减少层数、清理无用数据、多段构建</a></p>]]></content>
    
    
    <summary type="html">Docker学习第4话，学习编写dockerfile。</summary>
    
    
    
    <category term="编程学习" scheme="https://blog.musnow.top/categories/%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="Docker真好玩" scheme="https://blog.musnow.top/categories/%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0/Docker%E7%9C%9F%E5%A5%BD%E7%8E%A9/"/>
    
    
    <category term="Docker" scheme="https://blog.musnow.top/tags/Docker/"/>
    
  </entry>
  
  <entry>
    <title>【Docker】Docker学习03 | Docker的volume</title>
    <link href="https://blog.musnow.top/posts/2851039659/"/>
    <id>https://blog.musnow.top/posts/2851039659/</id>
    <published>2024-07-21T06:03:27.000Z</published>
    <updated>2024-07-21T06:04:32.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-引入"><a href="#1-引入" class="headerlink" title="1. 引入"></a>1. 引入</h1><p>在docker的基本知识讲解中，提到了docker镜像是由一层一层文件系统构成的。这一系列文件系统是一系列的<code>只读层</code>。当我们创建一个容器的时候，Docker会读取镜像（只读），并在镜像的顶部再添加一层<strong>读写层</strong>。</p><p>这种读写层和只读层的组合被称为<code>联合文件系统</code>（Union File System &#x2F; Unoin FS）。</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/07/24a33dd11665a155144ee96587f745f4.png" alt="image.png"></p><p>如果正在运行的容器修改了现有的文件，这些文件会被拷贝出底层的只读层，放到最顶部的容器读写层中，读写层中文件的未修改版本仍然存放在镜像的只读层中。</p><table><thead><tr><th>层</th><th>文件</th><th>说明</th></tr></thead><tbody><tr><td>读写层</td><td>app.ini</td><td>当出现写操作的时候，从只读层中拷贝到读写层</td></tr><tr><td>只读层</td><td>app.ini</td><td></td></tr></tbody></table><p>当基于相同的镜像创建第二个容器时，还是会创建一个<strong>没有任何数据修改</strong>的全新容器。在之前的容器中的任何修改<strong>只会保留在原有容器</strong>中，实现了容器和镜像的隔离。</p><p>这种读写层的操作带来了以下的问题：</p><ol><li>当容器不再存在的时候，数据不持久化；</li><li>如果另外一个进程需要使用容器内的数据，难以将其从容器内取出；</li><li>容器的可写层与容器当前运行的宿主机紧密相连，难以将其移动到另外一台主机上；</li><li>写入容器的可写层需要存储驱动<code>Storage Dirver</code>来管理这个文件系统，存储驱动提供了一个使用Linux内核的联合文件系统；与直接将数据写入宿主机的文件系统的方式，这种额外的抽象层降低了性能。</li></ol><p>为了能持久化这些修改过的数据，并且能够很容易实现容器间进行数据的共享，docker提出了volume的概念，同时也提供了多种数据持久化的方式。</p><h1 id="2-docker提供的持久化策略"><a href="#2-docker提供的持久化策略" class="headerlink" title="2. docker提供的持久化策略"></a>2. docker提供的持久化策略</h1><p>docker提供两种文件持久化的策略，分别是volume和mount，其中mount还分为<code>bind mount</code>（将容器内路径和宿主机的文件路径绑定）和<code>tmpfs mount</code>（数据只存在于宿主机的内存中）。</p><p>通过volume和bind mount持久化的文件都可以称之为docker的数据卷。数据卷是在容器默认的联合文件系统之外的文件或目录，它可以在宿主机上直接被访问。即便容器删除，数据卷中的内容也不会丢失。</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/07/fdc07e592ab6ecbbe91ffcbdc1db123f.png" alt="image.png"></p><p>tips:</p><ul><li><strong>Volumes</strong> are stored in a part of the host filesystem which is managed by Docker (<code>/var/lib/docker/volumes/</code> on Linux). Non-Docker processes should not modify this part of the filesystem. Volumes are the best way to persist data in Docker.</li><li><strong>Bind mounts</strong> may be stored anywhere on the host system. They may even be important system files or directories. Non-Docker processes on the Docker host or a Docker container can modify them at any time.</li><li><strong>tmpfs mounts</strong> are stored in the host system’s memory only, and are never written to the host system’s filesystem.</li></ul><p>下面对这三种不同的文件持久化方式进行测试</p><h1 id="3-volumes"><a href="#3-volumes" class="headerlink" title="3. volumes"></a>3. volumes</h1><h2 id="3-1-测试：自动创建的volume"><a href="#3-1-测试：自动创建的volume" class="headerlink" title="3.1. 测试：自动创建的volume"></a>3.1. 测试：自动创建的volume</h2><p>以<code>mysql:5.7</code>镜像为例，下面是一个创建容器的命令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">docker run -d \</span><br><span class="line">--name=<span class="string">&quot;testMysql&quot;</span> \</span><br><span class="line">-e MYSQL_ROOT_PASSWORD=<span class="string">&quot;123456&quot;</span> \</span><br><span class="line">mysql:5.7</span><br></pre></td></tr></table></figure><p>创建容器之前，先看看当前系统上的docker volume有哪些</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ docker volume ls</span><br><span class="line">DRIVER    VOLUME NAME</span><br><span class="line">local     53b8da5cc9f94a856e263d36ae69aea754be90a5a8b5b4848850af6e35503770</span><br><span class="line">local     act-toolcache</span><br></pre></td></tr></table></figure><p>执行了这个命令后，mysql容器被创建且正常运行，再次查看当前系统上的docker volume，可以发现多了一个新的volume。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">DRIVER    VOLUME NAME</span><br><span class="line">local     0cd65f1432c653ec08d7d8c3c50f645b97e0f26d139f1debb0c7fead3dafdfa4</span><br><span class="line">local     53b8da5cc9f94a856e263d36ae69aea754be90a5a8b5b4848850af6e35503770</span><br><span class="line">local     act-toolcache</span><br></pre></td></tr></table></figure><p>进入新创建的这个docker volume在宿主机上的路径，看看这里面有什么东西</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">❯ sudo ls -al /var/lib/docker/volumes/0cd65f1432c653ec08d7d8c3c50f645b97e0f26d139f1debb0c7fead3dafdfa4/_data</span><br><span class="line">total 188484</span><br><span class="line">drwxrwxrwt 5  999 docker     4096 May  6 16:56 .</span><br><span class="line">drwx-----x 3 root root       4096 May  6 16:56 ..</span><br><span class="line">-rw-r----- 1  999 docker       56 May  6 16:56 auto.cnf</span><br><span class="line">-rw------- 1  999 docker     1676 May  6 16:56 ca-key.pem</span><br><span class="line">-rw-r--r-- 1  999 docker     1112 May  6 16:56 ca.pem</span><br><span class="line">-rw-r--r-- 1  999 docker     1112 May  6 16:56 client-cert.pem</span><br><span class="line">-rw------- 1  999 docker     1676 May  6 16:56 client-key.pem</span><br><span class="line">-rw-r----- 1  999 docker     1318 May  6 16:56 ib_buffer_pool</span><br><span class="line">-rw-r----- 1  999 docker 79691776 May  6 16:56 ibdata1</span><br><span class="line">-rw-r----- 1  999 docker 50331648 May  6 16:56 ib_logfile0</span><br><span class="line">-rw-r----- 1  999 docker 50331648 May  6 16:56 ib_logfile1</span><br><span class="line">-rw-r----- 1  999 docker 12582912 May  6 16:56 ibtmp1</span><br><span class="line">drwxr-x--- 2  999 docker     4096 May  6 16:56 mysql</span><br><span class="line">lrwxrwxrwx 1  999 docker       27 May  6 16:56 mysql.sock -&gt; /var/run/mysqld/mysqld.sock</span><br><span class="line">drwxr-x--- 2  999 docker     4096 May  6 16:56 performance_schema</span><br><span class="line">-rw------- 1  999 docker     1680 May  6 16:56 private_key.pem</span><br><span class="line">-rw-r--r-- 1  999 docker      452 May  6 16:56 public_key.pem</span><br><span class="line">-rw-r--r-- 1  999 docker     1112 May  6 16:56 server-cert.pem</span><br><span class="line">-rw------- 1  999 docker     1676 May  6 16:56 server-key.pem</span><br><span class="line">drwxr-x--- 2  999 docker    12288 May  6 16:56 sys</span><br></pre></td></tr></table></figure><p>如果你对MySQL比较熟悉，应该就能认出来，这就是MySQL在<code>/var/lib/mysql</code>中存放的数据，我们可以做个简单的验证，使用如下命令，直接链接到这个新创建的容器的MySQL命令行中。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker <span class="built_in">exec</span> -it testMysql mysql -uroot -p123456</span><br></pre></td></tr></table></figure><p>我们在MySQL里面创建一个testdb数据库和一个stu表</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 创建数据库</span></span><br><span class="line"><span class="keyword">create</span> database testdb;</span><br><span class="line"><span class="comment">-- 进入testdb数据库</span></span><br><span class="line">use testdb;</span><br><span class="line"><span class="comment">-- 创建stu表</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> stu(</span><br><span class="line">id <span class="type">int</span> <span class="keyword">primary</span> key,</span><br><span class="line">name <span class="type">varchar</span>(<span class="number">30</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>操作完成后，exit退出容器，再次查看刚刚的volume目录。可以看到多了一个名为<code>testdb</code>的文件夹。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">❯ sudo ls -al /var/lib/docker/volumes/0cd65f1432c653ec08d7d8c3c50f645b97e0f26d139f1debb0c7fead3dafdfa4/_data</span><br><span class="line">total 188488</span><br><span class="line">drwxrwxrwt 6  999 docker     4096 May  6 17:15 .</span><br><span class="line">drwx-----x 3 root root       4096 May  6 16:56 ..</span><br><span class="line">-rw-r----- 1  999 docker       56 May  6 16:56 auto.cnf</span><br><span class="line">-rw------- 1  999 docker     1676 May  6 16:56 ca-key.pem</span><br><span class="line">-rw-r--r-- 1  999 docker     1112 May  6 16:56 ca.pem</span><br><span class="line">-rw-r--r-- 1  999 docker     1112 May  6 16:56 client-cert.pem</span><br><span class="line">-rw------- 1  999 docker     1676 May  6 16:56 client-key.pem</span><br><span class="line">-rw-r----- 1  999 docker     1318 May  6 16:56 ib_buffer_pool</span><br><span class="line">-rw-r----- 1  999 docker 79691776 May  6 17:15 ibdata1</span><br><span class="line">-rw-r----- 1  999 docker 50331648 May  6 17:15 ib_logfile0</span><br><span class="line">-rw-r----- 1  999 docker 50331648 May  6 16:56 ib_logfile1</span><br><span class="line">-rw-r----- 1  999 docker 12582912 May  6 16:56 ibtmp1</span><br><span class="line">drwxr-x--- 2  999 docker     4096 May  6 16:56 mysql</span><br><span class="line">lrwxrwxrwx 1  999 docker       27 May  6 16:56 mysql.sock -&gt; /var/run/mysqld/mysqld.sock</span><br><span class="line">drwxr-x--- 2  999 docker     4096 May  6 16:56 performance_schema</span><br><span class="line">-rw------- 1  999 docker     1680 May  6 16:56 private_key.pem</span><br><span class="line">-rw-r--r-- 1  999 docker      452 May  6 16:56 public_key.pem</span><br><span class="line">-rw-r--r-- 1  999 docker     1112 May  6 16:56 server-cert.pem</span><br><span class="line">-rw------- 1  999 docker     1676 May  6 16:56 server-key.pem</span><br><span class="line">drwxr-x--- 2  999 docker    12288 May  6 16:56 sys</span><br><span class="line">drwxr-x--- 2  999 docker     4096 May  6 17:15 testdb</span><br></pre></td></tr></table></figure><p>查看该文件夹，能看到刚刚我们创建的stu表的本地文件。可见这就是MySQL的本地路径。如果你在宿主机上直接使用apt安装一个MySQL&#x2F;MariaDB，也可以在宿主机的<code>/var/lib/mysql</code>中看到类似的文件。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">❯ sudo ls -al /var/lib/docker/volumes/0cd65f1432c653ec08d7d8c3c50f645b97e0f26d139f1debb0c7fead3dafdfa4/_data/testdb</span><br><span class="line">total 120</span><br><span class="line">drwxr-x--- 2 999 docker  4096 May  6 17:15 .</span><br><span class="line">drwxrwxrwt 6 999 docker  4096 May  6 17:15 ..</span><br><span class="line">-rw-r----- 1 999 docker    65 May  6 17:15 db.opt</span><br><span class="line">-rw-r----- 1 999 docker  8586 May  6 17:15 stu.frm</span><br><span class="line">-rw-r----- 1 999 docker 98304 May  6 17:15 stu.ibd</span><br></pre></td></tr></table></figure><p>通过<code>docker inspect testMysql</code>命令，可以查询到这个容器的配置详情，其中的Mount部分就有刚刚看到的volume，其中<code>Source</code>字段就是这个volume在宿主机上的路径，<code>Destination</code>字段是volume对应的容器内路径。</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;Mounts&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">            <span class="punctuation">&#123;</span></span><br><span class="line">                <span class="attr">&quot;Type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;volume&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;Name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;0cd65f1432c653ec08d7d8c3c50f645b97e0f26d139f1debb0c7fead3dafdfa4&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;Source&quot;</span><span class="punctuation">:</span> <span class="string">&quot;/var/lib/docker/volumes/0cd65f1432c653ec08d7d8c3c50f645b97e0f26d139f1debb0c7fead3dafdfa4/_data&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;Destination&quot;</span><span class="punctuation">:</span> <span class="string">&quot;/var/lib/mysql&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;Driver&quot;</span><span class="punctuation">:</span> <span class="string">&quot;local&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;Mode&quot;</span><span class="punctuation">:</span> <span class="string">&quot;&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;RW&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;Propagation&quot;</span><span class="punctuation">:</span> <span class="string">&quot;&quot;</span></span><br><span class="line">            <span class="punctuation">&#125;</span></span><br><span class="line">        <span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>再去找找<a href="https://github.com/docker-library/mysql/blob/master/Dockerfile.debian">MySQL容器的dockerfile</a>，也可以在里面看到一行关于<a href="https://github.com/docker-library/mysql/blob/e384941f162df943146e314f12097cf69c3609fa/Dockerfile.debian#L85">volume</a>的配置</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">VOLUME /var/lib/mysql</span><br></pre></td></tr></table></figure><p>由此可见，对于创建容器，如果没有在run命令中主动mount某个volume或路径时，docker会自动创建一个随机命名的volume（保持唯一性），并将容器内的路径和这个volume绑定。</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/07/6ef358884bc4f9af99bfc7ef5a530c4a.png" alt="image.png"></p><p>另外，一个volume的只能对应容器内的一个路径。如果容器在dockerfile中指定了多个不同路径的volume，则Docker也会创建多个volume与之对应。</p><h2 id="3-2-测试：主动指定volume"><a href="#3-2-测试：主动指定volume" class="headerlink" title="3.2. 测试：主动指定volume"></a>3.2. 测试：主动指定volume</h2><p>我们可以在run命令中指定容器路径和某个volume进行绑定，也可以写入一个volume的名字，在创建容器的同时创建这个volume。</p><p>下面这两种创建方式，都会在<code>/var/lib/docker/volumes</code>中创建一个名为<code>test_mysql_2</code>的volume。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建volume</span></span><br><span class="line">docker volume create test_mysql_2</span><br><span class="line"><span class="comment"># 绑定</span></span><br><span class="line">docker run -d \</span><br><span class="line">--name=<span class="string">&quot;testMysql2&quot;</span> \</span><br><span class="line">-v test_mysql_2:/var/lib/mysql \</span><br><span class="line">-e MYSQL_ROOT_PASSWORD=<span class="string">&quot;123456&quot;</span> \</span><br><span class="line">mysql:5.7</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建容器的时候直接创建volume</span></span><br><span class="line">docker run -d \</span><br><span class="line">--name=<span class="string">&quot;testMysql2&quot;</span> \</span><br><span class="line">-v test_mysql_2:/var/lib/mysql \</span><br><span class="line">-e MYSQL_ROOT_PASSWORD=<span class="string">&quot;123456&quot;</span> \</span><br><span class="line">mysql:5.7</span><br></pre></td></tr></table></figure><p>执行命令后，可以看到新创建出来的volume</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">❯ docker volume ls</span><br><span class="line">DRIVER    VOLUME NAME</span><br><span class="line">local     0cd65f1432c653ec08d7d8c3c50f645b97e0f26d139f1debb0c7fead3dafdfa4</span><br><span class="line">local     53b8da5cc9f94a856e263d36ae69aea754be90a5a8b5b4848850af6e35503770</span><br><span class="line">local     act-toolcache</span><br><span class="line">local     test_mysql_2</span><br></pre></td></tr></table></figure><p>通过<code>docker inspect testMysql2</code>命令，可以看到Mount中的信息</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;Mounts&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">            <span class="punctuation">&#123;</span></span><br><span class="line">                <span class="attr">&quot;Type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;volume&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;Name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;test_mysql_2&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;Source&quot;</span><span class="punctuation">:</span> <span class="string">&quot;/var/lib/docker/volumes/test_mysql_2/_data&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;Destination&quot;</span><span class="punctuation">:</span> <span class="string">&quot;/var/lib/mysql&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;Driver&quot;</span><span class="punctuation">:</span> <span class="string">&quot;local&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;Mode&quot;</span><span class="punctuation">:</span> <span class="string">&quot;z&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;RW&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;Propagation&quot;</span><span class="punctuation">:</span> <span class="string">&quot;&quot;</span></span><br><span class="line">            <span class="punctuation">&#125;</span></span><br><span class="line">        <span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><h2 id="3-3-绑定volume的权限选项"><a href="#3-3-绑定volume的权限选项" class="headerlink" title="3.3. 绑定volume的权限选项"></a>3.3. 绑定volume的权限选项</h2><p>这里能发现字段<code>Mode</code>有变化，由空串变成了小写的<code>z</code>。这个是什么意思呢？</p><ul><li><code>z</code>（小写）：代表绑定的目录由多个容器共享，其他容器也可以挂载这个volume；</li><li><code>Z</code>（大写）：代表绑定的目录由单个容器私有，其他容器无法挂载；</li></ul><p>在使用<code>-v</code>绑定某个路径的时候，可以在路径后面再添加一个选项，来指定权限和绑定模式。方式如下，在容器内路径后再追加一个冒号</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-v volume名字或宿主机路径:容器内路径:[权限选项]</span><br></pre></td></tr></table></figure><p>权限的可选项有四种，默认情况下，给定的是rw读写权限。</p><ul><li>大写Z</li><li>小写z</li><li>ro（只读）</li><li>rw（读写）</li></ul><p>其中<code>:z</code>和<code>:Z</code>选项是和SELinux有关的，具体可以参考<a href="https://docs.docker.com/reference/cli/docker/container/run/#volumes-from">官方文档</a>和<a href="https://linux.cn/article-14319-1.html">Linux中国</a>的文章。</p><blockquote><p>在Ubuntu上，SELinux工具集默认应该是没有启用的。</p></blockquote><p>注意，如果你使用<code>:Z</code>（大写）选项绑定了宿主机中诸如<code>/</code>、<code>/usr</code>、<code>/home</code>的目录，你可能会因为权限问题，直接无法使用宿主机！使用该选项的时候需要慎重！</p><h1 id="4-mount"><a href="#4-mount" class="headerlink" title="4. mount"></a>4. mount</h1><h2 id="4-1-bind-mount"><a href="#4-1-bind-mount" class="headerlink" title="4.1. bind mount"></a>4.1. bind mount</h2><h3 id="4-1-1-说明"><a href="#4-1-1-说明" class="headerlink" title="4.1.1. 说明"></a>4.1.1. 说明</h3><p>bind mount是docker早期就已经存在的数据持久化方式，其支持将容器的内的路径映射到某个宿主机上的路径，实现容器和宿主机文件的同步。绑定挂载直接使用了宿主机的文件系统，性能更佳。</p><p>绑定路径在docker run命令中和volume类似，都可以使用<code>-v</code>选项来实现</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-v 宿主机路径:容器内路径</span><br></pre></td></tr></table></figure><p>下面是一个示例</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用root用户，在宿主机上创建路径</span></span><br><span class="line"><span class="built_in">mkdir</span> /data/mysql</span><br><span class="line"><span class="comment"># docker容器绑定这个路径</span></span><br><span class="line">docker run -d \</span><br><span class="line">--name=<span class="string">&quot;testMysql3&quot;</span> \</span><br><span class="line">-v /data/mysql:/var/lib/mysql \</span><br><span class="line">-e MYSQL_ROOT_PASSWORD=<span class="string">&quot;123456&quot;</span> \</span><br><span class="line">mysql:5.7</span><br></pre></td></tr></table></figure><p>这样这个docker安装的MySQL容器内的所有数据都会被写入宿主机的<code>/data/mysql</code>路径中，我们可以直接备份这个路径实现对MySQL数据的保留。</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/07/04de1e3846636800c9e7f58c550065a3.png" alt="image.png"></p><h3 id="4-1-2-源路径的说明"><a href="#4-1-2-源路径的说明" class="headerlink" title="4.1.2. 源路径的说明"></a>4.1.2. 源路径的说明</h3><p>注意绑定挂载时<code>-v</code>选项中的<strong>路径</strong>和<strong>volume</strong>的区别。我们知道，在Linux命令行中，直接输入一个目录&#x2F;文件的名称，<strong>会默认是当前路径下的内容</strong>。</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd  folder   等价于 cd ./folder</span><br><span class="line">vim test.txt 等价于 vim ./test.txt</span><br></pre></td></tr></table></figure><p>而在docker run命令的<code>-v</code>选项中，源路径source输入直接为某个目录名的时候，会认为是volume的名称！而不是当前路径下的文件！</p><p>假设我们当前运行docker run的终端路径中有一个<strong>folder文件夹</strong>，我们想将这个文件夹映射到docker容器内的<code>/data</code>路径，推荐的写法如下（推荐使用绝对路径来设置源主机上的路径）。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-v $&#123;PWD&#125;/folder:/data</span><br></pre></td></tr></table></figure><p>错误的写法如下，直接写一个folder会以之为名<strong>创建一个新的volume</strong>，不符合我们的需要！</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-v folder:/data</span><br></pre></td></tr></table></figure><p>这一点在新建容器的时候一定要注意！个人推荐维持一个原则，即使用bind mount的时候一定要用<strong>绝对路径</strong>来设置宿主机上的文件路径。</p><h3 id="4-1-3-bind-mount的弊端"><a href="#4-1-3-bind-mount的弊端" class="headerlink" title="4.1.3. bind mount的弊端"></a>4.1.3. bind mount的弊端</h3><p>绑定挂载也有弊端</p><ul><li><strong>Bind mounts allow access to sensitive files</strong> One side effect of using bind mounts, for better or for worse, is that you can change the host filesystem via processes running in a container, including creating, modifying, or deleting important system files or directories. This is a powerful ability which can have security implications, including impacting non-Docker processes on the host system.</li></ul><p>翻译过来就是，绑定挂载（特别是以读写方式挂载）会让docker容器有权限修改宿主机的任何文件，甚至包括宿主机的系统文件。存在安全性问题。</p><p>这一点在<a href="https://linux.cn/article-14319-1.html">Linux中国</a>关于SELinux的文章中就有介绍，比如我们将宿主机的<code>/</code>路径直接绑定到容器的<code>/test</code>路径中时，使用<code>docker exec</code>进入这个容器的终端，我们会拥有<strong>容器内的root权限</strong>（即可以对当前登录的这个容器内的文件做任意修改），此时就直接可以通过编辑容器内的<code>/test</code>路径，来删除&#x2F;修改宿主机上的重要文件。</p><h3 id="4-1-4-docker-run-的-–mount-选项"><a href="#4-1-4-docker-run-的-–mount-选项" class="headerlink" title="4.1.4. docker run 的 –mount 选项"></a>4.1.4. docker run 的 –mount 选项</h3><p>除了<code>-v</code>选项，还可以用<code>--mount</code>选项来挂载数据卷，效果一致。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">docker run -d \</span><br><span class="line">--name=<span class="string">&quot;testMysql4&quot;</span> \</span><br><span class="line">--mount <span class="built_in">type</span>=<span class="built_in">bind</span>,<span class="built_in">source</span>=/data/mysql,target=/var/lib/mysql \</span><br><span class="line">-e MYSQL_ROOT_PASSWORD=<span class="string">&quot;123456&quot;</span> \</span><br><span class="line">mysql:5.7</span><br></pre></td></tr></table></figure><p>mount选项中，绑定的选项都用参数名写出来了，相对来说会更好理解，但是命令也变得复杂了。</p><table><thead><tr><th>key</th><th>value</th></tr></thead><tbody><tr><td>type</td><td>bind&#x2F;volume&#x2F;tmpfs</td></tr><tr><td>source&#x2F;src</td><td>docker host上的一个目录或文件</td></tr><tr><td>destination&#x2F;dst&#x2F;target</td><td>容器内的一个目录或文件</td></tr><tr><td>readonly</td><td>挂载为只读</td></tr><tr><td>option</td><td>额外选项</td></tr></tbody></table><p>如果需要指定readonly，直接在target后面添加该选项即可。添加了只读选项后，容器内对于这个路径就只能读，不能写入了。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">--mount type=bind,source=/data/mysql,target=/var/lib/mysql,readonly</span><br></pre></td></tr></table></figure><p>当使用mount选项来绑定volume的时候，<strong>可以省略type</strong>，此时docker会自动以source写入的字符串作为volume的名字，创建一个新volume并与当前容器进行绑定。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">docker run -d \</span><br><span class="line">--name=<span class="string">&quot;testMysql4&quot;</span> \</span><br><span class="line">--mount <span class="built_in">source</span>=mysql_vol,target=/var/lib/mysql \</span><br><span class="line">-e MYSQL_ROOT_PASSWORD=<span class="string">&quot;123456&quot;</span> \</span><br><span class="line">mysql:5.7</span><br></pre></td></tr></table></figure><h2 id="4-2-tmpfs-mount"><a href="#4-2-tmpfs-mount" class="headerlink" title="4.2. tmpfs mount"></a>4.2. tmpfs mount</h2><p>当容器为了性能原因，需要高频读写某些缓存文件（比如jellyfin镜像就有一个cache目录的volume，内部是一些缓存文件），或者为了安全性考虑不打算将一些数据写入磁盘的时候，我们可以使用tmpfs mount，将指定的路径绑定到宿主机的内存上。</p><p>对于nginx容器而言，其默认会有一个nginx的欢迎页面，存放在<code>/usr/share/nginx/html</code>路径中，这个欢迎页面可能会被经常的读取，占用空间也不大，所以我们可以将其放入内存中。</p><p>可以使用mount选项来进行绑定</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 直接绑定</span></span><br><span class="line">docker run -d -it \</span><br><span class="line">  -p 80:80 \</span><br><span class="line">  --name tmptest \</span><br><span class="line">  --mount <span class="built_in">type</span>=tmpfs,target=/usr/share/nginx/html \</span><br><span class="line">  nginx:latest</span><br><span class="line"><span class="comment"># 绑定时添加权限选项,1770代表全局可写</span></span><br><span class="line">docker run -d -it \</span><br><span class="line">  -p 80:80 \</span><br><span class="line">  --name tmptest \</span><br><span class="line">  --mount <span class="built_in">type</span>=tmpfs,target=/usr/share/nginx/html,tmpfs-mode=1770 \</span><br><span class="line">  nginx:latest</span><br></pre></td></tr></table></figure><p>也可以使用tmpfs选项来绑定</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">docker run -d -it \</span><br><span class="line">  -p 80:80 \</span><br><span class="line">  --name tmptest \</span><br><span class="line">  --tmpfs /usr/share/nginx/html \</span><br><span class="line">  nginx:latest</span><br></pre></td></tr></table></figure><p>更多相关的参数，可以参考docker的官方文档<a href="https://docs.docker.com/storage/tmpfs/">storage&#x2F;tmpfs</a>。</p><h2 id="4-3-bind-mount和volume的区别"><a href="#4-3-bind-mount和volume的区别" class="headerlink" title="4.3. bind mount和volume的区别"></a>4.3. bind mount和volume的区别</h2><p>docker官方其实一直都推荐我们使用volume来实现数据持久化，而不是使用bind mount。来看看二者的区别吧。</p><table><thead><tr><th>区别</th><th>bind mount</th><th>volume</th></tr></thead><tbody><tr><td>source位置</td><td>任意指定</td><td><code>/var/lib/docker/volumes</code></td></tr><tr><td>source路径为空</td><td>覆盖容器中的内容</td><td>容器内数据复制到volume</td></tr><tr><td>权限控制</td><td>读写&#x2F;只读</td><td>读写&#x2F;只读</td></tr><tr><td>单个文件</td><td>支持</td><td>不支持，只能是目录</td></tr><tr><td>移植性</td><td>弱,与hostpath绑定</td><td>强,无需指定hostpath</td></tr></tbody></table><h1 id="5-持久化和数据卷"><a href="#5-持久化和数据卷" class="headerlink" title="5. 持久化和数据卷"></a>5. 持久化和数据卷</h1><p>数据卷的最大特点是它的生命周期独立于容器的生命周期，即便容器被删除，<strong>数据卷中的内容也不会被删除</strong>（tmpfs除外，它的内容本来就没有写入磁盘）。当使用<code>docker rm</code>删除某个容器的时候，docker并不会主动删除和容器关联的数据卷。</p><ul><li>数据卷可在容器之间共享或重用数据。</li><li>数据卷的更改可以直接生效。</li><li>数据卷的生命周期一直持续到没有容器使用它为止。</li><li>对数据卷操作不会影响到镜像本身。</li><li>数据卷可以完成容器到宿主机、宿主机到容器以及容器到容器之间的数据共享。</li></ul><p>可见数据卷的好处还是多多的。所以，当你打算删除某个数据卷的时候，一定要确保这个数据卷里面的文件是完全无用了！</p><h1 id="6-参考文档"><a href="#6-参考文档" class="headerlink" title="6. 参考文档"></a>6. 参考文档</h1><ul><li><a href="https://colynn.github.io/2022-05-02-docker-volume/">理解并正确使用docker volume&#x2F;bind mount</a></li><li><a href="http://docker.baoshu.red/data_management/volume.html">docker volume详解</a></li><li><a href="https://blog.container-solutions.com/understanding-volumes-docker">Understanding Volumes in Docker</a></li></ul>]]></content>
    
    
    <summary type="html">Docker学习第3话，详解docker的volume</summary>
    
    
    
    <category term="编程学习" scheme="https://blog.musnow.top/categories/%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="Docker真好玩" scheme="https://blog.musnow.top/categories/%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0/Docker%E7%9C%9F%E5%A5%BD%E7%8E%A9/"/>
    
    
    <category term="Docker" scheme="https://blog.musnow.top/tags/Docker/"/>
    
  </entry>
  
  <entry>
    <title>【Docker】Docker学习02 | Docker-cli的基本命令</title>
    <link href="https://blog.musnow.top/posts/347805151/"/>
    <id>https://blog.musnow.top/posts/347805151/</id>
    <published>2024-07-21T06:02:27.000Z</published>
    <updated>2024-07-21T06:04:24.000Z</updated>
    
    <content type="html"><![CDATA[<p>简单了解一下docker client的常用命令，更多命令可以查看<a href="https://www.runoob.com/docker/docker-command-manual.html">完整命令列表</a>。不同命令之间的关系，可以查看下图。</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/07/ae4ba91e6c24459450a04bf77a3208e4.png" alt="image.png"></p><h1 id="基础命令"><a href="#基础命令" class="headerlink" title="基础命令"></a>基础命令</h1><p>docker的帮助命令和基本信息</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker --<span class="built_in">help</span>  <span class="comment"># 查看帮助命令</span></span><br><span class="line">docker version <span class="comment"># 查看docker信息，会显示client和server的版本</span></span><br><span class="line">docker info <span class="comment"># 显示当前docker的详细信息，包括有几个容器等</span></span><br></pre></td></tr></table></figure><h1 id="镜像相关命令"><a href="#镜像相关命令" class="headerlink" title="镜像相关命令"></a>镜像相关命令</h1><h2 id="docker-pull"><a href="#docker-pull" class="headerlink" title="docker pull"></a>docker pull</h2><p>用于下载镜像，当不指定tag的时候，会默认拉取latest版本（大部分镜像都会维护一个tag为latest的镜像）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull 镜像名:tag</span><br></pre></td></tr></table></figure><p>如果你不知道某个镜像是否存在，可以用docker search命令来查询它。</p><h2 id="docker-images"><a href="#docker-images" class="headerlink" title="docker images"></a>docker images</h2><p>查看当前本地已有的镜像的相关信息</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker images</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/07/71334bf9b04c97e757138e3b39c651bd.png" alt="image.png"></p><p>可以使用<code>docker images prune</code>快速删除所有未被容器使用且没有被tag的镜像层。</p><h2 id="docker-tag"><a href="#docker-tag" class="headerlink" title="docker tag"></a>docker tag</h2><p>该命令用于给一个已有的镜像设置一个tag（设置镜像的名字）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker tag 镜像id 命名镜像</span><br></pre></td></tr></table></figure><p>每个docker镜像都有个标识（镜像的完整名字），通常由仓库名、镜像名和标签组成。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">仓库名/镜像上传者名/镜像本身名字:tag</span><br></pre></td></tr></table></figure><p>且为了区分镜像的上传者，镜像名中通常以<strong>斜杠</strong>来分割镜像上传者和镜像本身的名字。默认情况下，使用的仓库都是官方的docker hub，所以镜像的<strong>仓库名会被省略</strong>。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">musnows/ImagesName:tag </span><br></pre></td></tr></table></figure><p>如果你使用了docker的镜像源（比如<a href="https://docker.nju.edu.cn/">南京大学</a>的镜像源），那么拉取下来的镜像中就会有仓库的名字。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker.nju.edu.cn/jellyfin/jellyfin:latest</span><br></pre></td></tr></table></figure><h2 id="docker-rmi"><a href="#docker-rmi" class="headerlink" title="docker rmi"></a>docker rmi</h2><p>可以使用<code>docker rmi</code>命令来删除某个镜像，需要提供镜像的<code>名字:tag</code>或者镜像的ID。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker rmi 镜像ID</span><br><span class="line">docker rmi 镜像名:tag</span><br></pre></td></tr></table></figure><p>如果要删除某个镜像，这个镜像必须没有关联的容器（需要先把关联的容器删除），才能被删除。否则删除请求会被拒绝。当然，可以使用<code>-f</code>选项来强制删除某个镜像。</p><p>另外，如果使用<code>镜像名:tag</code>的方式删除某个镜像时，并不一定会触发删除操作。因为同一个镜像可能会被打上多个tag，这时候只删除其中一个tag，相当于取消tag的操作。如果确定需要删除这个镜像，直接使用镜像的ID来删除是更好的办法。</p><p>如下所示，可以看到同一个镜像有两个不同的tag</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">REPOSITORY   TAG       IMAGE ID       CREATED        SIZE</span><br><span class="line">t            1         fa725ab19121   4 hours ago    432MB</span><br><span class="line">t            2         fa725ab19121   4 hours ago    432MB</span><br></pre></td></tr></table></figure><p>此时我们删除其中一个tag，可以看到返回的说明是<code>Untagged</code>，相当于是取消了对这个镜像的<code>t:1</code>这个tag。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ docker rmi t:1</span><br><span class="line">Untagged: t:1</span><br></pre></td></tr></table></figure><p>把<code>t:2</code>这个tag也给删除，才会真正删除镜像</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ docker rmi t:2 -f</span><br><span class="line">Untagged: t:2</span><br><span class="line">Deleted: sha256:fa725ab19121bd9c5628757049f5da5d4002f1ee10e41c4a87c33ab343d4ff28</span><br></pre></td></tr></table></figure><h2 id="docker-inspect"><a href="#docker-inspect" class="headerlink" title="docker inspect"></a>docker inspect</h2><p>这个命令用于查询某个容器&#x2F;镜像的元数据，会以json格式返回元数据</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker inspect [OPTIONS] NAME|ID [NAME|ID...]</span><br></pre></td></tr></table></figure><h2 id="docker-save-x2F-load"><a href="#docker-save-x2F-load" class="headerlink" title="docker save&#x2F;load"></a>docker save&#x2F;load</h2><p>docker save和docker load命令相对应，用于将一个镜像打包成tar格式的文件，方便在不同主机上进行传输。其他主机可以用load命令加载一个导出的镜像</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 打包本地镜像</span></span><br><span class="line">docker save linux:monitor -o linux-monitor.tar</span><br><span class="line"><span class="comment"># 在其他主机上加载镜像</span></span><br><span class="line">docker load -i linux-monitor.tar</span><br></pre></td></tr></table></figure><p>为了减少导出镜像的文件大小，还可以用gzip命令来压缩导出的镜像包的体积</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 通过管道，将docker save的结果传输给gzip工具，进行压缩</span></span><br><span class="line">docker save &lt;myimage&gt;:&lt;tag&gt; | gzip &gt; &lt;myimage&gt;_&lt;tag&gt;.tar.gz</span><br><span class="line"><span class="comment"># gzip解压之后，通过管道传输给docker load命令</span></span><br><span class="line">gunzip -c &lt;myimage&gt;_&lt;tag&gt;.tar.gz | docker load</span><br></pre></td></tr></table></figure><h2 id="【重点】docker-build"><a href="#【重点】docker-build" class="headerlink" title="【重点】docker build"></a>【重点】docker build</h2><p>docker build命令用于从docker file中构建一个docker的镜像，参考<a href="https://www.runoob.com/docker/docker-build-command.html">菜鸟教程</a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker build [OPTIONS] PATH | URL | -</span><br></pre></td></tr></table></figure><p>OPTIONS说明：</p><ul><li>–build-arg&#x3D;[] :设置镜像创建时的变量；</li><li>–cpu-shares :设置 cpu 使用权重；</li><li>–cpu-period :限制 CPU CFS周期；</li><li>–cpu-quota :限制 CPU CFS配额；</li><li>–cpuset-cpus :指定使用的CPU id；</li><li>–cpuset-mems :指定使用的内存 id；</li><li>–disable-content-trust :忽略校验，默认开启；</li><li>-f :指定要使用的Dockerfile路径；</li><li>–force-rm :设置镜像过程中删除中间容器；</li><li>–isolation :使用容器隔离技术；</li><li>–label&#x3D;[] :设置镜像使用的元数据；</li><li>-m :设置内存最大值；</li><li>–memory-swap :设置Swap的最大值为内存+swap，”-1”表示不限swap；</li><li>–no-cache :创建镜像的过程不使用缓存；</li><li>–pull :尝试去更新镜像的新版本；</li><li>–quiet, -q :安静模式，成功后只输出镜像 ID；</li><li>–rm :设置镜像成功后删除中间容器；</li><li>–shm-size :设置&#x2F;dev&#x2F;shm的大小，默认值是64M；</li><li>–ulimit :Ulimit配置。</li><li>–squash :将 Dockerfile 中所有的操作压缩为一层。</li><li>–tag, -t: 镜像的名字及标签，通常 name:tag 或者 name 格式；可以在一次构建中为一个镜像设置多个标签。</li><li>–network: 默认 default。在构建期间设置RUN指令的默认网络模式；</li></ul><p>示例1：使用<code>.</code>当前路径下的dockerfile构建镜像，tag为<code>runoob/ubuntu:v1</code>。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker build -t runoob/ubuntu:v1 .</span><br></pre></td></tr></table></figure><p>示例2：使用指定路径<code>/path/to/a/Dockerfile</code>中的dockerfile，从<code>.</code>当前目录中指定上下文（即docker需要拷贝的内容是以当前目录为PWD进行计算相对路径的），构建镜像</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker build -f /path/to/a/Dockerfile .</span><br></pre></td></tr></table></figure><p>示例3：使用<code>-f</code>手动指定dockerfile的名字为<code>base.dockerfile</code>（如果没有指定，则默认会<strong>忽略大小写</strong>在当前目录下搜索名为<code>dockerfile</code>的文件），并设置了docker镜像的默认网络模式是host，这个网络模式下docker容器会直接使用宿主机的端口。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker build --network host -f base.dockerfile .</span><br></pre></td></tr></table></figure><h1 id="容器相关命令"><a href="#容器相关命令" class="headerlink" title="容器相关命令"></a>容器相关命令</h1><h2 id="docker-ps"><a href="#docker-ps" class="headerlink" title="docker ps"></a>docker ps</h2><p>查看当前正在运行的容器。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker ps</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/07/7212bae043d3d720edc43cd614582cab.png" alt="image.png"></p><p>使用<code>-a</code>选项可以看到所有容器，包括创建了但没有运行的容器（停止状态的容器）。</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/07/08a7b9e5f2885524380a9ed4b756fabb.png" alt="image.png"></p><p>所有使用容器名操作的命令，都可以使用容器的<code>container id</code>进行操作，后文不再重复。</p><h2 id="docker-start-x2F-stop-x2F-restart"><a href="#docker-start-x2F-stop-x2F-restart" class="headerlink" title="docker start&#x2F;stop&#x2F;restart"></a>docker start&#x2F;stop&#x2F;restart</h2><p>用于对某个容器进行操作</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker start 容器名   <span class="comment"># 运行</span></span><br><span class="line">docker stop 容器名    <span class="comment"># 停止</span></span><br><span class="line">docker restart 容器名 <span class="comment"># 重启</span></span><br></pre></td></tr></table></figure><h2 id="docker-rm"><a href="#docker-rm" class="headerlink" title="docker rm"></a>docker rm</h2><p>这个命令用于删除某个容器。容器必须是停止状态才能被删除。同样可以使用<code>-f</code>选项强制删除某个正在运行的容器。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker rm 容器名</span><br></pre></td></tr></table></figure><h2 id="docker-stats"><a href="#docker-stats" class="headerlink" title="docker stats"></a>docker stats</h2><p>这个命令可以查看当前正在运行的容器状态，包括容器占用的内存&#x2F;CPU百分比等性能信息</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker stats <span class="comment"># 查看所有容器的运行状态</span></span><br><span class="line">docker stats 容器名 <span class="comment"># 查看某个容器的运行状态</span></span><br></pre></td></tr></table></figure><h2 id="docker-exec"><a href="#docker-exec" class="headerlink" title="docker exec"></a>docker exec</h2><p>这个命令用于进入某个正在运行的容器的终端，或者说是在某个容器中执行命令。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker exec -it 容器名 需要执行的命令</span><br></pre></td></tr></table></figure><p>比如我们想进入项目所用的<code>linux_monitor</code>容器的终端，使用的是如下命令。这个命令本质上是在容器内执行<code>/bin/bash</code>命令，相当于启动了一个容器内的终端。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker exec -it linux_monitor /bin/bash</span><br></pre></td></tr></table></figure><p>进入容器后，执行exit命令即会退出容器内的终端。</p><h2 id="docker-attach"><a href="#docker-attach" class="headerlink" title="docker attach"></a>docker attach</h2><p>想直接进入容器终端，还有另外一个命令。这个命令会直接进入容器内的终端。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker attach 容器名</span><br></pre></td></tr></table></figure><p>对比一下attach和exec命令</p><ul><li>attach 不会在容器中创建进程执行额外的命令，只是附着到容器上。</li><li>exec 会在运行的容器上<strong>创建进程执行新的命令</strong>。</li></ul><p>如果docker容器是使用<code>/bin/bash</code>作为shell启动的，则可以使用attach来直接访问它。如果不是，则需要在容器内创建一个bash的进程。</p><h2 id="docker-cp"><a href="#docker-cp" class="headerlink" title="docker cp"></a>docker cp</h2><p>从容器内拷贝文件到宿主机上</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker cp 容器id:容器内路径 宿主机上的目的路径</span><br></pre></td></tr></table></figure><h2 id="【重点】docker-run"><a href="#【重点】docker-run" class="headerlink" title="【重点】docker run"></a>【重点】docker run</h2><p>docker run命令用于从镜像中创建一个容器，参考<a href="https://www.runoob.com/docker/docker-run-command.html">菜鸟教程</a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run [OPTIONS] IMAGE [COMMAND] [ARG...]</span><br></pre></td></tr></table></figure><p>OPTIONS说明：</p><ul><li><strong>-a stdin:</strong> 指定标准输入输出内容类型，可选 STDIN&#x2F;STDOUT&#x2F;STDERR 三项；</li><li><strong>-d:</strong> 后台运行容器，并返回容器ID；</li><li><strong>-i:</strong> 以交互模式运行容器，通常与 -t 同时使用；</li><li><strong>-t:</strong> 为容器重新分配一个伪输入终端，通常与 -i 同时使用；</li><li><strong>-P:</strong> 随机端口映射，容器内部端口<strong>随机</strong>映射到主机的端口</li><li><strong>-p:</strong> 指定端口映射，格式为：主机(宿主)端口:容器端口</li><li><strong>–name&#x3D;”nginx-lb”:</strong> 为容器指定一个名称；</li><li><strong>–dns 8.8.8.8:</strong> 指定容器使用的DNS服务器，默认和宿主一致；</li><li><strong>–dns-search example.com:</strong> 指定容器DNS搜索域名，默认和宿主一致；</li><li><strong>-h “mars”:</strong> 指定容器的hostname；</li><li><strong>-e username&#x3D;”ritchie”:</strong> 设置环境变量；</li><li><strong>–env-file&#x3D;[]:</strong> 从指定文件读入环境变量；</li><li><strong>–cpuset&#x3D;”0-2” or –cpuset&#x3D;”0,1,2”:</strong> 绑定容器到指定CPU运行；</li><li><strong>-m</strong>:设置容器使用内存最大值；</li><li><strong>–net&#x3D;”bridge”:</strong> 指定容器的网络连接类型，支持 bridge&#x2F;host&#x2F;none&#x2F;container: 四种类型</li><li><strong>–link&#x3D;[]:</strong> 添加链接到另一个容器；</li><li><strong>–expose&#x3D;[]:</strong> 开放一个端口或一组端口；</li><li><strong>–volume , -v:</strong> 绑定一个卷</li><li><strong>–rm</strong>：当容器内程序退出的时候，自动删除容器，用于测试运行。不能和<code>-d</code>一起使用。</li></ul><p>示例：使用nginx镜像创建一个容器，并在后台运行。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker run -d \</span><br><span class="line">--name mynginx </span><br><span class="line">nginx:latest</span><br></pre></td></tr></table></figure><p>当默认创建一个容器的时候，docker会给这个容器创建一个卷，就好比虚拟机的虚拟磁盘。当某个容器被删除，和它关联的卷也就失效了。所以，如果你在容器内部对容器运行的程序做了配置上的修改，删除这个容器后就会失效。</p><p>为了避免这种情况，我们一般都会将容器中的某个存放配置文件和数据的路径给<strong>映射</strong>到宿主机，这样容器对这个路径的修改就会直接写入到宿主机的文件系统中（持久化），即便容器删除也不会影响。</p><p>比如nginx的配置文件都在<code>/etc/nginx</code>中，我们可以把这个目录映射到宿主机的<code>/root/docker/nginx</code>路径中，这样就可以直接通过修改宿主机中的路径来修改容器中nginx的配置，同时nginx容器的配置也实现了持久化，即便容器删除也不会丢失。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">docker run -d \</span><br><span class="line">--name mynginx \</span><br><span class="line">-v /root/docker/nginx:/etc/nginx</span><br><span class="line">nginx:latest</span><br></pre></td></tr></table></figure><p>当前状态下我们没有设置这个容器的网络环境，一般情况下，容器都会以默认的bridge桥接网络链接到宿主机中，即容器是通过宿主机的网卡做桥接（类似于虚拟机的NAT模式）上网的。</p><p>比如上方配置的nginx容器，它并不会对宿主机的80&#x2F;443端口收到的请求做任何操作，因为它没有映射到宿主机上。如果我们想让容器能处理宿主机收到的数据，则需要进行容器的端口映射。如下所示，我们使用了两个<code>-p</code>选项，分别映射了80端口和443端口到宿主机的80和443端口（冒号左侧是宿主机的端口，右侧是容器内的端口）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">docker run -d \</span><br><span class="line">--name mynginx \</span><br><span class="line">-v /root/docker/nginx:/etc/nginx \</span><br><span class="line">-p 80:80 \</span><br><span class="line">-p 443:443 \</span><br><span class="line">nginx:latest</span><br></pre></td></tr></table></figure><p>当然，也可以直接用host网络模式运行nginx容器，这样nginx默认绑定的80和443就是直接绑定的宿主机的端口了</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">docker run -d \</span><br><span class="line">--name mynginx \</span><br><span class="line">-v /root/docker/nginx:/etc/nginx \</span><br><span class="line">--net=&quot;host&quot; \</span><br><span class="line">nginx:latest</span><br></pre></td></tr></table></figure><p>关于docker run中<code>-v</code>命令和<code>--mount</code>命令以及绑定数据卷的说明，请参考<a href="https://wiki.musnow.top/doc/38/">docker volume</a>中的介绍。</p><h2 id="docker-volume"><a href="#docker-volume" class="headerlink" title="docker volume"></a>docker volume</h2><p>volume是docker中的数据卷，可以用下方的命令来操作这些数据卷。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">docker volume <span class="built_in">ls</span> <span class="comment"># 查看所有数据卷</span></span><br><span class="line">docker volume <span class="built_in">rm</span> 数据卷ID <span class="comment"># 删除某个卷</span></span><br><span class="line">docker volume inspect 数据卷ID <span class="comment"># 查看某个数据卷的详细信息</span></span><br><span class="line">docker volume prune <span class="comment"># 删除没有使用的数据卷</span></span><br><span class="line">docker volume create 数据卷名字</span><br></pre></td></tr></table></figure><p>关于数据卷的知识，可以看<a href="https://wiki.musnow.top/doc/38/">docker volume</a>的介绍。</p><h2 id="docker-logs"><a href="#docker-logs" class="headerlink" title="docker logs"></a>docker logs</h2><p>docker logs可以查看某个容器的日志输出</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker logs 容器ID</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">Docker学习第2话，docker-cli的基本命令</summary>
    
    
    
    <category term="编程学习" scheme="https://blog.musnow.top/categories/%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="Docker学习" scheme="https://blog.musnow.top/categories/%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0/Docker%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="Docker" scheme="https://blog.musnow.top/tags/Docker/"/>
    
  </entry>
  
  <entry>
    <title>【Docker】Docker学习01 | 什么是docker？</title>
    <link href="https://blog.musnow.top/posts/1177093765/"/>
    <id>https://blog.musnow.top/posts/1177093765/</id>
    <published>2024-07-21T06:01:27.000Z</published>
    <updated>2024-07-21T06:04:27.000Z</updated>
    
    <content type="html"><![CDATA[<p>因为本人没有学习过docker，虽然部署过很多镜像，但是对于docker底层的实现一概不知。趁学习一个新项目的契机，将docker的相关概念了解清楚。</p><p>如果你想和我一起学习docker，请关注本站的<code>编程学习/Docker学习</code>专栏。后续和docker概念相关的内容都会放到这个分类里面，而折腾docker镜像和开源软件的内容则保留在<code>编程学习/Docker真好玩</code>中。</p><h1 id="1-docker和虚拟机的区别"><a href="#1-docker和虚拟机的区别" class="headerlink" title="1.docker和虚拟机的区别"></a>1.docker和虚拟机的区别</h1><h2 id="1-1-简述"><a href="#1-1-简述" class="headerlink" title="1.1 简述"></a>1.1 简述</h2><p>虚拟机和Docker都是在原有主机的基础上添加了抽象层，通过这些抽象层来实现特定的功能。</p><blockquote><p>这就好比C语言中的文件操作实际上封装了Linux和Windows的文件系统调用接口。这一层封装就是一层抽象层，通过封装，C语言实现了跨平台的统一文件函数接口。</p></blockquote><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/07/1eead7f84081f888a29a54f02d70918e.png" alt="image.png"></p><p>虚拟机：虚拟机是通过Hypervisor（虚拟机管理系统）来虚拟出网卡、CPU、内存等虚拟硬件，再在其上方建立一个虚拟机。每个虚拟机都有独立的操作系统，都有自己独立的系统内核。</p><p>docker容器：容器是利用linux下的<strong>namespace</strong>，将文件系统、进程、网络、设备等资源进行一定隔离，再使用<strong>cgroup</strong>对容器权限、资源进行限制（比如限制某个容器只能占用最多512MB的内存），最终让容器之间互不影响，容器无法影响宿主机。这些操作都是由宿主机的<code>Docker Engine</code>来实现和管理的。</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/07/95345379d7ce18153ab8f81f1cb8fdcf.png" alt="image.png"></p><blockquote><p>上图源自 <a href="https://docs.microsoft.com/en-us/virtualization/windowscontainers/deploy-containers/media/docker-on-linux.png">微软官方文档</a></p></blockquote><h2 id="1-2-什么是GuestOS"><a href="#1-2-什么是GuestOS" class="headerlink" title="1.2 什么是GuestOS"></a>1.2 什么是GuestOS</h2><p>GuestOS（Guest Operating System）是指在虚拟化环境中运行的操作系统。</p><p>在虚拟化技术中，物理服务器上的虚拟化软件（如VMware、KVM、VirtualBox等）可以创建一个或多个虚拟的计算环境，每个环境都可以独立运行一个操作系统，这个操作系统就是 GuestOS。</p><h2 id="1-3-什么是namespace"><a href="#1-3-什么是namespace" class="headerlink" title="1.3 什么是namespace"></a>1.3 什么是namespace</h2><p>好比C++中的namespace，Linux内核中的namespace可以限制某个进程能“看到”的资源。</p><p>它是一种将全局系统资源划分为独立单元的资源隔离方法，对文件系统、进程、网络、设备等资源进行隔离，使得在不同命名空间中运行的进程看到的资源是不同的，彼此之间相互隔离，容器内的进程认为它们运行在独立的环境中，而不会看到主机上其他容器的影响。</p><h2 id="1-4-什么是cgroup"><a href="#1-4-什么是cgroup" class="headerlink" title="1.4 什么是cgroup"></a>1.4 什么是cgroup</h2><p>cgroup是一种用于限制和隔离一个或一组进程对系统资源使用的机制，将一组进程组织在一个控制组中，为这个控制组分配特定的资源限制与优先级，包括 CPU资源、内存、网络等。确保容器在共享主机上合理利用系统资源，避免资源竞争和过度使用。</p><h1 id="2-docker的优势"><a href="#2-docker的优势" class="headerlink" title="2.docker的优势"></a>2.docker的优势</h1><p>docker因自身的特性，相比虚拟机有很多优势：</p><ol><li>运行在容器上的Docker的程序，直接使用的都是宿主机的硬件资源，<strong>而且Docker比虚拟机有更少的抽象层</strong>，因此在cpu、内存、利用率上，Docker将会在效率上具有更大的优势。(效率高)</li><li>Docker直接利用宿主机的系统内核，避免了虚拟机启动时所需要的系统引导时间和操作系统运行的资源消耗，利用Docker能够在几秒钟之内启动大量的容器，是虚拟机无法办到的。快速启动低资源消耗的优点，使Docker在弹性云平台自动运维系统方面具有很好的应用场景。（速度快）</li><li>容器的启动时间是秒级的，大量节约开发、测试、部署的时间。而且因为Docker以统一的方式进行操作和部署，更方便自动化持续集成&#x2F;持续部署。</li><li>还有一个非常关键的点，就是Docker能够高效地部署和扩容，Docker容器几乎可以在任意平台上运行，包括虚拟机、物理机、公有云、私有云、个人电脑、服务器等，这种兼容性，可以让用户把一个应用程序从一个平台直接迁移到另外一个平台。（部署简单）</li></ol><p>但是，<strong>虚拟机的安全性比容器好一些</strong>，docker与宿主机共享内核、文件系统等资源，更有可能对其他容器、宿主机造成影响。</p><h1 id="3-docker的基本组成"><a href="#3-docker的基本组成" class="headerlink" title="3.docker的基本组成"></a>3.docker的基本组成</h1><h2 id="3-1-简述"><a href="#3-1-简述" class="headerlink" title="3.1 简述"></a>3.1 简述</h2><p>docker包括客户端docker client、服务端docker host，以及远程镜像仓库docker registry。</p><p>平时我们使用的docker命令（包括<code>docker-compose</code>工具），其实操作的都是 <code>docker cli</code> 客户端，它的作用是把这些命令发送给本地的 <code>docker.sock</code> 服务端，让服务端来执行docker容器的创建、运行、维护等操作。</p><ul><li>镜像 Images：可以认为是一个docker构建环境的系统模板，镜像中包括相关的依赖项、项目文件、如何开始运行等信息。镜像是由一层一层的文件系统构建而成的，每一层文件系统是下一层的增量变化。每个镜像都是静态的，被创建后就无法改变；</li><li>容器 Container：容器是某个正在运行的镜像，是镜像的实体。同一个镜像可以创建出多个不同的容器，且不同容器之间通过Linux内核的namespace和cgroup等技术实现相互隔离，拥有自己独立的文件系统、进程地址空间、网络空间等。</li></ul><p>有了镜像，我们可以在不同的Linux主机上，创建容器来统一项目运行的环境，避免在不同系统上安装项目依赖项的繁琐。这可以降低项目部署的难度，提高效率。同时，让项目在容器中运行，也能减少对宿主机的影响，可以避免出现<strong>两个不同的项目依赖项冲突</strong>而无法运行的情况。</p><p>本项目使用docker，就是为了实现不同机器上运行环境的统一，毕竟整个项目涉及到了很多依赖项，如果一个一个安装的话，较为麻烦且容易出错。</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/07/9ed214ba2ac9e206a396c4c4f361eec1.png" alt="image.png"></p><h2 id="3-2-docker镜像是什么？"><a href="#3-2-docker镜像是什么？" class="headerlink" title="3.2 docker镜像是什么？"></a>3.2 docker镜像是什么？</h2><p><strong>Docker 镜像</strong> 是一个特殊的文件系统，除了提供容器运行时所需的程序、库、资源、配置等文件外，还包含了一些为运行时准备的一些配置参数（如匿名卷、环境变量、用户等）。镜像 <strong>不包含</strong> 任何动态数据，其内容在构建之后也不会被改变。</p><p>我们都知道，操作系统分为 <strong>内核</strong> 和 <strong>用户空间</strong>。对于 <code>Linux</code> 而言，内核启动后，会挂载 <code>root</code> 文件系统为其提供用户空间支持。而 <strong>Docker 镜像</strong>（<code>Image</code>），就相当于是一个 <code>root</code> 文件系统。比如官方镜像 <code>ubuntu:18.04</code> 就包含了完整的一套 Ubuntu 18.04 最小系统的 <code>root</code> 文件系统。</p><p>Docker镜像是由<strong>多层</strong>的文件系统构建而成的，<strong>每一层文件系统是下一层的增量变化</strong>。对于Ubuntu&#x2F;CentOS这种基础镜像而言，它们一般都只有一层。但对于基于这两个镜像构建的其他Docker镜像，则会出现多层，具体取决于镜像构建使用的DockerFile。</p><h2 id="3-3-docker容器是什么？"><a href="#3-3-docker容器是什么？" class="headerlink" title="3.3 docker容器是什么？"></a>3.3 docker容器是什么？</h2><p>容器是镜像的实体。</p><p>容器在运行的时候，会在镜像文件的<strong>只读层</strong>上方创建一个<strong>读写层</strong>，并在这个读写层中进行文件的读写和运行。同时容器也可以暴露出端口，或与宿主机的某个文件&#x2F;文件路径绑定，来对外提供网络服务，和数据的持久化。</p><h1 id="4-docker-run的运行过程"><a href="#4-docker-run的运行过程" class="headerlink" title="4.docker run的运行过程"></a>4.docker run的运行过程</h1><p>当我们执行 docker run 命令创建一个容器的时候，会执行如下操作。</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/07/322b5ba46918cff1844b38699a262e11.png" alt="image.png"></p><p>当本机找不到指定的镜像时，会自动去docker hub或者预先配置好的docker镜像源仓库中，查询这个镜像并进行下载（查询不到则提示“镜像不存在”）。找到指定的镜像后，会自动执行docker pull操作将镜像下载至本地，随后以该镜像，按docker run命令给定参数创建容器并运行。</p>]]></content>
    
    
    <summary type="html">Docker学习第1话，什么是docker？</summary>
    
    
    
    <category term="编程学习" scheme="https://blog.musnow.top/categories/%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="Docker学习" scheme="https://blog.musnow.top/categories/%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0/Docker%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="Docker" scheme="https://blog.musnow.top/tags/Docker/"/>
    
  </entry>
  
  <entry>
    <title>【Docker】如何让子用户直接使用docker命令</title>
    <link href="https://blog.musnow.top/posts/3987990807/"/>
    <id>https://blog.musnow.top/posts/3987990807/</id>
    <published>2024-07-21T03:58:24.000Z</published>
    <updated>2024-07-21T05:56:42.000Z</updated>
    
    <content type="html"><![CDATA[<p>通过用户组，让子用户可以直接使用docker命令。</p><h2 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h2><p>正常情况下，使用一个子用户来执行docker命令，会出现如下提示</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ docker ps</span><br><span class="line">permission denied while trying to connect to the Docker daemon socket at unix:///var/run/docker.sock: Get &quot;http://%2Fvar%2Frun%2Fdocker.sock/v1.45/containers/json&quot;: dial unix /var/run/docker.sock: connect: permission denied</span><br></pre></td></tr></table></figure><p>这个提示中的关键词是<code>permission denied</code>，即我们当前的子用户没有权限来执行这个命令。只有加上sudo之后才能以root身份执行这个命令。</p><h2 id="操作"><a href="#操作" class="headerlink" title="操作"></a>操作</h2><p>子用户可以通过加入docker的用户组的方式来直接使用docker命令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">sudo groupadd docker <span class="comment"># 创建docker用户组（安装docker的时候会被创建）</span></span><br><span class="line">sudo usermod -aG docker <span class="variable">$&#123;USER&#125;</span> <span class="comment"># 当前用户加入docker用户组</span></span><br><span class="line">sudo systemctl restart docker   <span class="comment"># 重启docker服务</span></span><br><span class="line">newgrp docker  <span class="comment"># 用相同的用户，以docker群组的身份登录bash</span></span><br><span class="line">docker ps <span class="comment"># 现在不用sudo也能执行docker命令了</span></span><br></pre></td></tr></table></figure><p>执行了上面这些命令后，不需要sudo子用户也可以执行docker命令啦。</p><p>不过做这个配置的同时也要保证你的子用户不会被入侵！</p>]]></content>
    
    
    <summary type="html">通过用户组，让子用户可以直接使用docker命令。</summary>
    
    
    
    <category term="编程学习" scheme="https://blog.musnow.top/categories/%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="Docker真好玩" scheme="https://blog.musnow.top/categories/%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0/Docker%E7%9C%9F%E5%A5%BD%E7%8E%A9/"/>
    
    
    <category term="Docker" scheme="https://blog.musnow.top/tags/Docker/"/>
    
  </entry>
  
  <entry>
    <title>【思源笔记】思源笔记配置S3同步</title>
    <link href="https://blog.musnow.top/posts/1277165852/"/>
    <id>https://blog.musnow.top/posts/1277165852/</id>
    <published>2024-07-16T12:41:44.000Z</published>
    <updated>2024-07-20T22:44:48.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-写在前面"><a href="#1-写在前面" class="headerlink" title="1. 写在前面"></a>1. 写在前面</h2><p><a href="https://b3log.org/siyuan/">思源笔记</a>是一款由国人开发的本地优先，支持双链、块级的开源笔记软件。</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/07/2a32b8f8acb8cc9f68982a7041db8297.png" alt="image.png"></p><p>思源笔记采用json作为数据存储格式，编辑器兼容MarkDown语法且编辑体验极佳（堪比Typora）。最重要的是，<strong>自带同步功能</strong>。它是我目前使用过的所有笔记软件中，最适合个人多设备使用的笔记软件，既能简单的实现多设备同步，又能保证数据本地化，不受在线笔记产品会员资费、云服务宕机的困扰。</p><blockquote><p>你可以在官网找到下载页面，也可以去Github Release中下载：<a href="https://b3log.org/siyuan/download.html">https://b3log.org/siyuan/download.html</a></p></blockquote><p>思源笔记基础版本提供了几乎所有笔记相关的功能，会员版本分为永久买断功能特性和年付订阅，详见<a href="https://b3log.org/siyuan/pricing.html">价格页面</a>:</p><ul><li>永久买断：在所有基础功能的基础上，提供S3&#x2F;WEBDAV同步功能（需自行使用第三方服务）</li><li>年付订阅：在永久买断的基础上，提供官方的同步功能（8GB空间），且支持图床（可以将自己的图片上传至官方图床并在博客中引用）和剪藏、微信收集箱（通过微信公众号实时记录笔记并保存到思源笔记中）功能。</li><li>注意，若年付订阅者想使用S3&#x2F;WEBDAV同步功能，<strong>则需要保持按年付费</strong>，会员失效后无法使用S3&#x2F;WEBDAV功能，若想永久使用这两个功能，也需要购买永久买断的功能特性。</li></ul><p>如下图所示，<strong>付费版本和免费版本的区别只有同步功能是否可以使用</strong>，不会存在基础笔记共的限制。个人感觉目前64元买断的价格还是非常香的（之前早鸟付费是48元）。考虑到这里标了个原价96，建议对思源笔记感兴趣，且使用后觉得确实不错的老哥趁早购买功能特性，不排除后续可能会恢复原价96的情况。</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/07/bd7cf06a72bae304c8222f78bf126f94.png" alt="image.png"></p><p>另外，除非你不太想折腾S3同步（本文就是教你怎么做的），个人其实不太建议购买年付订阅：</p><ul><li>一是提供的同步空间有点小（社区里不少用户反馈认为8GB太少了，虽然对于我来说是够用）；</li><li>二是S3的配置并不算麻烦，而官方提供的同步功能和S3同步基本没有体验差异。只要敢于尝试配置S3，完全可以省下这笔钱。</li></ul><p>不过这里有个小提醒，不管是功能特性还是年付订阅均<strong>不支持退款</strong>，付款前请三思。</p><h2 id="2-什么是思源笔记的S3-x2F-WEBDAV同步？"><a href="#2-什么是思源笔记的S3-x2F-WEBDAV同步？" class="headerlink" title="2. 什么是思源笔记的S3&#x2F;WEBDAV同步？"></a>2. 什么是思源笔记的S3&#x2F;WEBDAV同步？</h2><h3 id="2-1-说明"><a href="#2-1-说明" class="headerlink" title="2.1. 说明"></a>2.1. 说明</h3><p>思源笔记本身是一个<strong>本地</strong>的笔记软件，提供了端到端加密的S3&#x2F;WEBDAV或官方提供的同步功能。当你安装思源笔记后，在默认的思源用户指南笔记本中，可以看到有一整个章节都是关于数据安全的描述：</p><ul><li>思源云端同步使用端到端加密，密码在本地通过内置密钥加密保存，除使用者之外的任何第三方均无法在云端获得明文数据。</li><li>加密和解密过程完全在本地设备上进行</li><li>加密算法为业界公认安全的 AES GCM；</li></ul><p>端到端加密同步功能，简单来说，就是思源笔记使用一个密钥，先在你的电脑上将需要同步的笔记内容加密成密文，然后发送给云端。当这些数据在网络中开始流动时，它们已经是加密后的内容了，<strong>对于不知道密钥的其他人来说，这一堆数据和乱码没有区别</strong>。而在你需要同步的另外一台设备中，它会下载云端的加密内容，数据在流入这台设备之前也是一堆乱码，只能在你的设备中，通过相同的密钥才能正确还原出最初的笔记内容。</p><p>端到端加密功能，意味着除非你自己知道你的数据库密钥，否则即便别人获取到了你存放在云端的全量同步数据，<strong>也无法解密内容</strong>。这样一来也完全避免了云端服务商可能存在的扫盘而带来的隐私担忧。与之对应的是，<strong>如果你忘记了你的数据库密钥</strong>，且没有进行其他备份的话，那么任何人都没有办法解密你的云端笔记数据了。</p><p>思源提供S3和WEBDAV这两个不同的云端存储服务协议进行同步。<strong>其中S3协议的可靠性和稳定性远远优于WEBDAV</strong>，除非特殊情况，否则百分百不推荐使用WEBDAV进行同步。</p><p>当你配置了S3&#x2F;WEBDAV同步之后，只需要在其他设备上使用相同的同步配置以及数据库密钥，即可以实现多设备的同步。思源提供了<strong>三种同步选项</strong>，分别是完全手动、半自动（客户端开启和关闭的时候会自动同步一次，其余时间手动同步）、自动同步（停止修改后30S自动同步一次）。</p><blockquote><p>这里推荐手机APP采用<strong>全手动</strong>模式，因为手机端界面按钮较小，极其容易误触导致意外修改一些内容，完全手动同步可以避免这些意外修改的内容被上传。电脑客户端根据您自己的需要选择半自动或全自动。另外，手机APP也可以在设置中配置为<strong>默认只读</strong>状态，这样可以避免修改笔记内容。</p></blockquote><p>但需要注意的是，思源的加密仅限于同步到云端的数据，你的<strong>笔记在设备本地是明文存储的</strong>。也就是说，如果你的设备丢失，那么任何人都可以<strong>在设备本地的硬盘中读取到你的笔记明文内容</strong>。除非你对笔记所在文件夹使用其他软件或系统功能进行了加密，比如微软的BitLocker。</p><p>作为一个本地优先的笔记软件，配置了同步后，即便没有网络，也丝毫不影响你浏览本地已有笔记内容（只不过会有一个无法同步的提示）。这一点对于我个人来说非常重要，我已经遇到过两次因为云端服务商产品协议更改或服务器访问波动导致我急需阅读笔记的时候无法阅读了。在那之后，我就把我所有的笔记内容全都转为纯本地了，包括笔记内的图片附件。</p><p>思源对大文本（超过4W字）的笔记支持也非常不错，毕竟是个本地笔记软件，性能基本取决于你的电脑配置。不过要注意尽量别把思源的工作空间放在机械硬盘上。</p><blockquote><p>我曾使用过语雀存放我计算机网络的笔记（大约5.7W字），语雀会直接卡到完全不能动弹，整个页面都卡死了。即便我过几天再上去打开那个文档，也依旧是这样。不过flowus对这种大文本支持也还算不错，不会卡死。但是flowus的免费用户直接限制成了200MB的存储空间也太抠了，我一个计算机网络笔记里面的图片和附件就不止这么多了。</p></blockquote><p>咳咳，不跑题了，回到正文。</p><h3 id="2-2-思源的同步配置和工作空间"><a href="#2-2-思源的同步配置和工作空间" class="headerlink" title="2.2. 思源的同步配置和工作空间"></a>2.2. 思源的同步配置和工作空间</h3><blockquote><p>本文将以2024-07-17可下载到的最新思源版本<code>V3.1.1</code>做演示。</p></blockquote><p>思源笔记以<code>工作空间</code>为基础，独立进行各类主题、设置、密钥、同步配置。工作空间就是你的电脑上的一个文件夹，在这个工作空间中产生的各类笔记本和附件，都会被存放到这个工作空间的文件夹中。每个工作空间之间相互独立，没有任何关联，也需要进行独立的同步配置，和obisidian的vault是同一个概念。</p><p>为了避免出现同步错误，每个工作空间不可共用S3的bucket或同一个WEBDAV的同步路径。正确配置方式是每一个工作空间<strong>独立使用</strong>一个S3同步的bucket或者WEBDAV同步目录。</p><p>另外，因为思源笔记经常会实时进行本地文件的索引，所以不能将思源笔记的工作空间文件夹选择放在坚果云、OneDrive这类会进行实时同步的同步目录中，<strong>必须将思源的工作空间文件夹存放在一个和其他任何软件都没有任何关系的文件目录中</strong>。若想同步，请使用思源笔记自带的同步功能；若想备份，思源笔记的设置中有一个<code>导出-导出DATA</code>功能，这个功能会将整个工作空间的笔记和附件全量导出为一个压缩包，可以在另外一个设备上进行导入或上传至云盘进行备份。</p><p>在你初次打开思源笔记的界面下，也会有相关的提示。</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/07/92ce5419aa5e159e68dca2e1a39ca0be.png" alt="image.png"></p><p>选择工作空间文件夹的时候也会有提示，不能放在同步盘的路径中。如上文所述，在一个和其他任何软件都没有关系的独立文件夹中创建一个文件夹来存放思源笔记的工作空间，选中这个文件夹后，下方的弹窗点击确定就可以了。</p><p><strong>这只是个每次都会出现的提示</strong>，并不代表你当前选中的文件夹有这些第三方同步盘配置。</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/07/7f858cb23ae59c2d46d4491f8fdabaca.png" alt="image.png"></p><h3 id="2-3-什么是S3协议？"><a href="#2-3-什么是S3协议？" class="headerlink" title="2.3. 什么是S3协议？"></a>2.3. 什么是S3协议？</h3><p>S3是一个对象存储的公共协议，目前国内主流的云服务厂商如阿里云、腾讯云、七牛云等等都会提供兼容S3协议的对象存储的服务。您可以选择任意一家您熟悉的支持对象存储的服务提供商来配置思源的S3同步，并不局限于本文举例的服务商。</p><p>如果您是第一次使用思源笔记，且没有接触过S3对象存储，个人推荐有免费额度的<strong>七牛云</strong>作为入门选择。我已经使用七牛云超过一年了，暂未遇到过收到影响的无法访问的情况，稳定性还是不错的。</p><p>几乎所有服务商的对象存储服务，都是分为两个计费项的：</p><ul><li>流量计费；</li><li>存储空间计费；</li></ul><p>存储空间计费比较好理解，就是为你存储空间占用的硬盘容量付钱。流量付费对于小白来说可能没有听说过，因为商用宽带是很贵的，所以云服务厂家为您提供服务时，需要收取带宽的流量费用。一般情况下来说，都是<strong>上传不计费（公网流入不计费），下载才计费（外网流出计费）</strong>。举个例子，您使用思源笔记，将本地的文件同步到S3时，使用的是<code>上传</code>宽带，这一部分是不计费的；而在另外一台设备上，将云端的内容同步到本地时，使用的是<code>下载</code>操作，会产生公网流出流量，这一部分就需要计费了。</p><blockquote><p>公网&#x2F;外网流出：“流出”是针对于云服务而言的，您从云服务上下载文件，对于云服务器来说是把文件发送给您的设备，数据流向是从云服务器到您的设备上的，这会产生从云服务器出去的流量，即为公网流出&#x2F;外网流出流量。</p></blockquote><p>如果您的设备不多，这部分由同步产生的下载流量费用是不高的。以我个人举例，我使用的思源笔记目前存储空间只有1GB，在七牛云产生的资费只有极低的外网流出流量的费用。</p><p>如下是2024年6月的账单，可以看到存储空间容量直接扣除了免费的额度，不用钱。</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/07/e246955816ceef383e0dceb4f7c02a5c.png" alt="image.png"></p><p>外网流出流量2.68GB，扣费0.77元。</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/07/58892f2e7d28d94f96bc41efa0ef47d7.png" alt="image.png"></p><p>PUT&#x2F;DELETE和GET请求都没有超过免费额度，都不用钱。</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/07/9b7bc32056f81b49039199e2b4d9743a.png" alt="image.png"></p><p>还需要解释的一点是，假设您的某个工作空间A只在设备B上存在，并配置了S3同步。此时虽然没有第二个设备去访问这个S3存储桶进行<code>下载</code>同步操作，但实际上你的当前设备B也会需要去访问云端空间，下载数据库进行与本地的对比和验证操作的，这样思源才能知道本地的工作空间A已经成功同步到S3的bucket中了。<strong>所以即便您的工作空间只存在于B设备上，但依旧会产生少许的外网流出流量</strong>。</p><h2 id="3-配置思源S3同步"><a href="#3-配置思源S3同步" class="headerlink" title="3. 配置思源S3同步"></a>3. 配置思源S3同步</h2><h3 id="3-1-初始化数据仓库密钥"><a href="#3-1-初始化数据仓库密钥" class="headerlink" title="3.1. 初始化数据仓库密钥"></a>3.1. 初始化数据仓库密钥</h3><p>初次使用思源时，创建了一个工作空间后，要做的第一件事是在<code>设置-关于</code>中，初始化你的仓库密钥。思源会使用这个密钥进行端到端加密，密钥只有你当前使用的设备能知道。</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/07/1003cc7ab75d392c3a727ceaf8b29f08.png" alt="image.png"></p><p>点击自动生成密钥，这里会提示您如果在其他设备上已经有工作空间时，应该选择导入密钥。而我们当前是新建的一个工作空间，需要初始化密钥，点击确定即可。</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/07/3dd380d46081974cce118403a3e06d5d.png" alt="image.png"></p><p>密钥初始化完毕后，这里会显示复制密钥字符串，如果你需要在其他设备上同步这个工作空间的内容，可以在这里复制密钥，然后在另外一台设备上（比如手机app或者另外一台电脑）思源app设置的<code>设置-关于-数据仓库密钥</code>中，选择<strong>导入密钥</strong>。两台设备只有密钥一致，才能正确解密云端同步的数据。</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/07/7521b39d5081c25ee529b5ccc488b8c9.png" alt="image.png"></p><h3 id="3-2-思源S3同步界面"><a href="#3-2-思源S3同步界面" class="headerlink" title="3.2. 思源S3同步界面"></a>3.2. 思源S3同步界面</h3><p>思源的S3同步界面是在<code>右上角按钮-设置-云端</code>里面的，在使用同步功能之前，需要先在<strong>账户</strong>一栏登录你的思源账户（用于验证是否购买了订阅）。</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/07/2df437c04fb0dc9213678ff62a421653.png" alt="image.png"></p><p>登录了之后，云端选项就会开放，在下拉菜单中选择S3即可。</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/07/480859be7370f05529b8829c01904a60.png" alt="image.png"></p><p>你可以先记住这里的几个配置条目，后文会一一说明它们的对应内容。</p><h3 id="3-3-配置七牛云KODO"><a href="#3-3-配置七牛云KODO" class="headerlink" title="3.3. 配置七牛云KODO"></a>3.3. 配置七牛云KODO</h3><p>使用浏览器打开 <a href="https://www.qiniu.com/">七牛云</a> 官网， 注册账户。</p><p>七牛云的S3对象存储服务名为KODO，在它的<a href="https://www.qiniu.com/prices/kodo">定价页面</a>，你可以看到七牛云提供了每月10GB的免费存储空间和10GB的CDN回源流量额度。对于思源笔记的用途而言，CDN是用不上的，所以这个10G的CDN回源流量额度是用不到的，<strong>但10GB的存储空间额度可以用上了</strong>。至于后续的PUT&#x2F;DELETE还有GET的免费额度可以不用管，基本是用不完的。</p><p>这里也说明了上传流量是免费的，符合前文关于S3计费项目的介绍。</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/07/284ac975a2928deb82469434bd5426c0.png" alt="image.png"></p><p>另外，在这个页面也有一个<a href="https://www.qiniu.com/prices/kodo?tab=calc">价格计算器</a>，你可以根据你的存储空间容量和设备数量来估计你最终会流出多少流量以及产生的资费。思源笔记的容量大小可以打开本地工作空间的文件夹查看内部data文件夹的占用空间。</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/07/db52829d391cd219ec5be752b65a4bf3.png" alt="image.png"></p><p>每个月的外网流出流量（也就是你的同步下载流量）平均到每月大概是在笔记本容量的1.5倍左右。注意：这只是个我根据个人情况<strong>猜测出来的大概比例</strong>，不代表实际情况，只用于预估价格。</p><p>如下图所示，假设你有10GB的笔记容量空间，那么外网流出流量一个月可能会需要15GB，那么每个月产生的资费是4.35元左右。这只是流出流量的费用，因为10GB的存储空间是免费的，<strong>只有超出10GB存储空间的免费额度，才需要对存储空间进行按量计费</strong>。</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/07/9ca445e8b78103c7743e4aeeaae6d5a9.png" alt="image.png"></p><p>现在你已经了解定价啦，来看看怎么配置七牛云的S3同步吧。登录七牛云后，点击右上角账户旁边的控制台按钮，进入后台，点击产品与方案，选择对象存储kodo。你可以在这里选择将其钉住，这样会直接显示在侧边栏上。</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/07/0706e3ee43433f31fa2789e222f35a35.png" alt="image.png"></p><p>在对象存储栏目中，点击空间管理，点击新建空间，这会创建一个bucket，也对应的思源S3同步中bucket一栏的填写项。</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/07/b9463c8ecd8c05327a5155b9145cc241.png" alt="image.png"></p><p>bucket的名字根据你的喜好填写，<strong>建议填写辨识度高的名字</strong>，而不要填写一个诸如siyuan这类没有什么辨识度的名字。辨识度高的名字方便你后续创建更多bucket来对应其他思源工作空间或其他软件。</p><p>地域的选择采取就近原则，除非你人在国外，否则请不要选择非大陆地域。</p><p>访问控制选择<strong>私有</strong>，这代表只有拥有你的七牛云账户和相关密钥的软件可以访问这个bucket，其他任何人都没有办法直接访问这个bucket。</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/07/384a403c846ce69b5d0437b53008dbe2.png" alt="image.png"></p><p>点击确定后，会弹出如下的提示。这里是很多新手朋友不太理解的一点，什么是测试域名？为什么有效期只有30天？实际上，这个域名是用于<strong>公开bucket</strong>的访问的，刚刚我们创建bucket的时候已经选择了私有，<strong>这个域名对于思源同步来说没有任何用处</strong>，也就不用管他的30天过期说明！直接点击<code>好的,我知道了</code>忽略这个提示即可！</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/07/ea73be35361f1647eb68fa5b810e2258.png" alt="image.png"></p><p>现在我们已经创建了一个新的bucket，点击它的名字，即可进入bucket的管理页面</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/07/ca825415de2154c81ad5fc4e82c60b8d.png" alt="image.png"></p><p>在bucket的空间概览中，可以看到当前bucket的存储空间占用量，以及外网流出流量统计。我们需要记录的是右下角的这个存储空间域名。这个存储空间域名的格式如下所示</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">http(s)://siyuan-bucket-1.s3.cn-east-1.qiniucs.com</span><br><span class="line">http(s)://&lt;bucket名字&gt;.s3.cn-east-1.qiniucs.com</span><br><span class="line">http(s)://&lt;bucket名字&gt;.&lt;协议&gt;.cn-east-1.qiniucs.com</span><br><span class="line">http(s)://&lt;bucket名字&gt;.&lt;协议&gt;.&lt;区域名字&gt;.qiniucs.com</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/07/f8bf7b43794bb2c22fd9a51f7988c20a.png" alt="image.png"></p><p>回到思源的配置中，现在可以填写一部分内容了</p><ul><li>Bucket：对应刚刚你创建的存储空间的名字，在我的示例中，是<code>siyuan-bucket-1</code>;</li><li>Endpoint：填写域名中除了bucket名字以外的部分，即<code>https://s3.cn-east-1.qiniucs.com</code>；</li><li>Region：填写域名中显示的区域名字，即<code>cn-east-1</code>；</li></ul><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/07/d6d18a4d349bb3384f256082620f76b3.png" alt="image.png"></p><p>还剩下两个内容分别是Access Key和Secret Key，正如它们的名字翻译过来的结果，这两个是访问你这个bucket的用户密钥，也是你的七牛云账户的密钥。这是你的<strong>私密信息</strong>，请一定<strong>不要将用户密钥发送给任何人或发送到论坛上</strong>！</p><p>这两个密钥的获取位置是在七牛云界面的右上角，鼠标移动到你的用户头像位置，会弹出一个选择框，点击里面的密钥管理。</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/07/4ab349939ae1115bf41ecc1c2c60f8c6.png" alt="image.png"></p><p>这里我已经创建过两组密钥了，我不记得新用户进到这个界面时是否会有一个创建密钥的提示了。总之你可以创建一组密钥，然后分别复制这里的<strong>AK和SK</strong>，填写到思源笔记的Access Key和Secret Key中，同步配置就完成了！</p><blockquote><p>如果你认为你的七牛云密钥已经泄漏，可以选择停用密钥，停用后删除这个密钥，再重新创建一个新密钥即可。</p></blockquote><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/07/723f04ab1bc1f51300e4bf2dfe07706d.png" alt="image.png"></p><p>填写完毕后，点击下方的启用云端同步</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/07/9082891d4b4817ef75a96e99354c2c09.png" alt="image.png"></p><p>在同步方式中，可以选择前文提到过的三种不同方式。对于电脑客户端而言，选择自动同步或者手动同步都是可以的；而对于手机APP而言，强烈推荐选择完全手动同步。</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/07/731b4f2549605e64575e9e63bc1e68ad.png" alt="image.png"></p><p>这里又会出现另外一个会让小白感到困扰的设置，在云端同步目录的设置中，你会发现你的七牛云账户里面的所有bucket都会显示出来。但是！刚刚在S3的同步配置中有一个Bucket填写项，我们使用的Bucket已经在填写项目中被<strong>固定</strong>了，所以这里的bucket选项是毫无意义的！<strong>它是留给WEBDAV协议选择文件路径使用的</strong>！使用了S3协议后，请忽略这个<code>云端同步目录</code>配置项。</p><p>正如前文提到过的，请针对<strong>每一个工作空间配置一个对应的Bucket</strong>，请不要多个工作空间公用同一个bucket！</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/07/846620eca1ae0a2485b07f2df3d45a2f.png" alt="image.png"></p><p>现在我创建了一个测试笔记本，点击左上角的这个<strong>小云图标</strong>，即可进行同步操作。</p><blockquote><p>顺带提一嘴，你可能会在文档树中看到<code>思源用户指南</code>这个笔记本，请不要在这个笔记中记录任何笔记！每次启动思源的时候，<strong>这个笔记本都会被重置</strong>！他是一个说明书，并不是一个可用的笔记本。一定要在文档树中<code>右键-新建笔记本</code>来做你的记录！</p></blockquote><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/07/2e07bd704af10290cb5ef8449fb28b5c.png" alt="image.png"></p><p>同步时，左下角会显示实时进度。</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/07/70b0e714f197963591e412662e5a966d.png" alt="image.png"></p><p>同步完毕后，我们可以来到七牛云的bucket的文件管理中，查看是否有新增的数据。如下图所示，刚刚我新建的bucket中已经出现了一个repo文件夹，且内部已有文件，这就代表你的同步配置完成啦！</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/07/92474957afc3dfd8203b51a2336ebd5d.png" alt="image.png"></p><p>这里的repo文件和本地工作空间路径中的repo文件夹内容是一致的，都是使用数据库密钥加密后的笔记内容。</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/07/f47a493cc9fdd4cab4084f24c307ef69.png" alt="image.png"></p><h3 id="3-4-如何将同步配置导入其他设备？"><a href="#3-4-如何将同步配置导入其他设备？" class="headerlink" title="3.4. 如何将同步配置导入其他设备？"></a>3.4. 如何将同步配置导入其他设备？</h3><p>注意：<strong>两台设备请保证思源的版本一致，数据仓库密钥一致，再进行同步</strong>。个人建议关闭思源客户端的自动更新功能，只要你使用当前版本没有遇到任何问题，建议维持版本，不进行更新。我现在还在使用<code>v2.11.4</code>老版本呢。</p><p>在<code>设置-云端</code>中，会有一个导入和导出的按钮，在这里可以快捷的导出你的云端配置，并在其他设备的云端设置中进行导入。</p><blockquote><p>请注意区分 云端的导入&#x2F;导出 和 设置中的导出 选项，<code>设置-导出-导出DATA</code>是将你的全量笔记数据导出为一个压缩包，方便在其他设备上直接导入笔记或备份笔记。而<code>设置-云端-导出</code>则只是导出你的云端配置项目，方便在其他设备上直接引用相同的云端配置项而不需要重新填写而已！</p></blockquote><p>注意：导出的压缩包内文件是明文存储的，你的AccessKey和SecretKey都是明文。所以，<strong>请在导入其他设备后，尽快删除压缩包</strong>，避免AccessKey和SecretKey泄漏！</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/07/697b546ceaecff9365b3b46bce82d4d8.png" alt="image.png"></p><p>在其他设备导入云端配置后，启用云端同步，将同步选项改为<code>完全手动同步</code>，并手动点击小云图标，选择下载数据。等待云端的数据被下载完毕之后，再修改为其他同步方式。这样能最大限度的保障同步数据不出错！</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/07/cc7ca5c616e1c0670d32a9ea35141f3b.png" alt="image.png"></p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/07/72a6d2b5d430eb96520a5750e2e4803a.png" alt="image.png"></p><p>另外，如果你尝试用QQ或微信的文件传输助手将这个云端同步压缩包发送给手机，需要注意的是QQ的文件传输助手收到的压缩包文件，没有办法在手机自带的文件管理器中被找到，也就没有办法导入思源APP中。<strong>建议使用数据线连接手机和电脑，将导出的云端同步配置压缩包传输到手机上</strong>。您还可以同时把导出的DATA压缩包也传至手机，先在手机APP中导入DATA和云端配置，再执行一次下载云端数据到本地，这样可以节省一部分流量费用。</p><h2 id="4-其他服务商的配置教程"><a href="#4-其他服务商的配置教程" class="headerlink" title="4. 其他服务商的配置教程"></a>4. 其他服务商的配置教程</h2><p>这里给大家贴出其他服务商配置思源S3的教程。因为上文第三点已经带大家走过一遍配置流程了，其他云服务厂商的配置都是大同小异，所以这里就只贴出其他服务商如何找到思源S3所需配置项的条目，对应填入云端配置项中就OK啦。需要特别注意一点，不管您使用哪一个服务商，在开通对象存储服务的时候，一定要选标准的对象存储类型，不要选择低频访问、冷归档之类的对象存储类型！</p><ul><li>七牛云KODO：<a href="https://developer.qiniu.com/kodo/4088/s3-access-domainname">AWS S3 兼容 - 服务域名</a>，<a href="https://developer.qiniu.com/af/kb/1479/how-to-access-or-locate-the-access-key-and-secret-key">怎么获取或者找到 Access Key 和 Secret Key</a>;</li><li>阿里云OSS：<a href="https://help.aliyun.com/zh/oss/user-guide/regions-and-endpoints">OSS访问域名</a>，<a href="https://help.aliyun.com/zh/ram/user-guide/create-an-accesskey-pair?spm=a2c4g.53045.0.0.68147f80YkG9tZ#task-2245479">创建AccessKey</a>;</li><li>腾讯云COS：<a href="https://cloud.tencent.com/document/product/436/41284">在兼容 S3 的第三方应用中使用 COS 的通用配置</a>;</li><li>又拍云存储：<a href="https://help.upyun.com/knowledge-base/aws-s3%e5%85%bc%e5%ae%b9/">AWS S3协议兼容</a>;</li></ul><p>这里再次对对象存储服务的资费做一个解释，毕竟这是初次接触这类云服务的小白最容易看不懂的东西。</p><p>以<a href="https://help.aliyun.com/zh/oss/product-overview/billable-items/">阿里云OSS</a>为例，你会看到阿里云OSS提供存储的资源包，如下图所示，40GB的标准存储一年是费用是9元。这个40GB的资源包和七牛云提供的免费10GB存储容量一样，<strong>都是只抵消了存储空间的按量付费</strong>！即如果您使用阿里云OSS，购买了这个40GB的资源包后，40GB以内的存储空间都不会进行按量计费，只有超过40GB的空间才会需要按量计费。</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/07/a0d141b1d102562cec42a2ce4ea0a30c.png" alt="image-20240719064441734"></p><p>那么我们需不需要购买这个资费包呢？可以来算一笔账，看看按量付费要多少GB的存储空间才需要9元。根据阿里云<a href="https://help.aliyun.com/zh/oss/product-overview/storage-fees">OSS存储空间资费</a>文档，<strong>标准本地冗余存储</strong>的按量付费的计算公式如下<br>$$<br>按量付费：存储费用&#x3D;存储量（GB）×月单价÷30（天）÷24（小时）<br>$$<br>在<a href="https://www.aliyun.com/price/product?spm=a2c4g.11186623.0.0.387e7bbezYDEsc#/oss/detail/ossbag">价格页面</a>可以看到OSS的存储空间按量付费单价和外网流出流量的付费单价。</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/07/1f67a335d5b937023c0e66f248810b76.png" alt="image-20240719065211076"></p><p>根据<code>0.12元/GB/月</code>，我们可以算出一年是<code>1.44元/GB</code>，进一步计算<code>9 ÷ 1.44 = 6.25</code>，得出结论，当你的存储空间容量低于<code>6.25GB</code>时，可以不用去购买OSS的存储空间资费包。如果您的思源笔记内容庞大，则在存储空间占用大于6GB的时候，就可以考虑购买40GB的资费包了！</p><p>顺带计算一下外网流出流量的价格，还是以上文提到的每月平均外网流出流量是占用存储空间的1.5倍计算，假设你有占用了6GB存储空间的笔记，那么每个月的外网流出流量预估是9GB，直接按忙时价格计算，外网流出流量资费是<code>4.5元/月</code>，同时还需<code>0.72元</code>的6GB月存储空间费用，合计<code>5.22元</code>每月。</p><p>对于阿里云OSS的新用户，您可以领取一次<a href="https://help.aliyun.com/zh/oss/product-overview/free-quota-for-new-users">20GB存储空间和2GB外网流出流量&#x2F;3月</a>的免费额度，这篇文档中还提到了一些地域的OSS会有每月5GB的标准存储和外网流出流量的免费额度，但根据思源论坛的反馈，中国香港地域和海外地域的OSS在大陆访问效果并不好，连通性差，不建议省这笔钱！</p><h2 id="5-The-end"><a href="#5-The-end" class="headerlink" title="5. The end"></a>5. The end</h2><p>到这里，云端的配置就大功告成啦！主要是如何找到对象存储服务地域节点的域名，以及用户的AccessKey和SecretKey。这一部分操作都可以去查阅各大云服务厂商编写过的文档。想必聪明的你已经学会啦！</p><p>感谢大家支持！如果在配置过程中有任何问题，都可以在评论区与我交流。如果本文帮助到了你，也可以在评论区互动一下，这会让慕雪感觉自己的努力有收获，非常感谢！</p>]]></content>
    
    
    <summary type="html">一步一步引导诸位配置思源笔记的S3同步。</summary>
    
    
    
    <category term="编程学习" scheme="https://blog.musnow.top/categories/%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="Docker真好玩" scheme="https://blog.musnow.top/categories/%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0/Docker%E7%9C%9F%E5%A5%BD%E7%8E%A9/"/>
    
    
    <category term="Docker" scheme="https://blog.musnow.top/tags/Docker/"/>
    
  </entry>
  
  <entry>
    <title>【leetcode】647.回文子串</title>
    <link href="https://blog.musnow.top/posts/3816992778/"/>
    <id>https://blog.musnow.top/posts/3816992778/</id>
    <published>2024-07-14T02:08:13.000Z</published>
    <updated>2024-07-14T03:03:19.000Z</updated>
    
    <content type="html"><![CDATA[<p>leetcode刷题笔记-647.回文子串</p><h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><blockquote><p><a href="https://leetcode.cn/problems/palindromic-substrings/">https://leetcode.cn/problems/palindromic-substrings/</a></p></blockquote><p>给你一个字符串 s ，请你统计并返回这个字符串中 回文子串 的数目。</p><p>回文字符串 是正着读和倒过来读一样的字符串。</p><p>子字符串 是字符串中的由连续字符组成的一个序列。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">示例 1：</span><br><span class="line">输入：s = &quot;abc&quot;</span><br><span class="line">输出：3</span><br><span class="line">解释：三个回文子串: &quot;a&quot;, &quot;b&quot;, &quot;c&quot;</span><br><span class="line"></span><br><span class="line">示例 2：</span><br><span class="line">输入：s = &quot;aaa&quot;</span><br><span class="line">输出：6</span><br><span class="line">解释：6个回文子串: &quot;a&quot;, &quot;a&quot;, &quot;a&quot;, &quot;aa&quot;, &quot;aa&quot;, &quot;aaa&quot;</span><br></pre></td></tr></table></figure><p>提示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1 &lt;= s.length &lt;= 1000</span><br><span class="line">s 由小写英文字母组成</span><br></pre></td></tr></table></figure><h1 id="思路一：双指针法"><a href="#思路一：双指针法" class="headerlink" title="思路一：双指针法"></a>思路一：双指针法</h1><p>我们可以遍历整个字符串，用双指针法从当前下标开始扩张寻找回文子串。找寻相同的字符，如果找到了，则将结果集加一（回文子串个数）。</p><p>这里需要注意的是，回文子串有两种情况，一种是奇数长度，我们从中间位置开始扩张就OK了，另外一种是偶数长度，我们必须从中间两位开始扩张。</p><p>这个思路比较好理解，所以直接上代码。主要还是注意奇数和偶数这两种不同的回文子串长度。偶数情况可以从<code>(i-1,i)</code>开始找，也可以从<code>(i,i+1)</code>开始找，最终结果都是等价的。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">countSubstrings</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (s.<span class="built_in">size</span>() &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> s.<span class="built_in">size</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> result = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; s.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            result += <span class="built_in">subStringExtend</span>(s, i, i, s.<span class="built_in">size</span>());     <span class="comment">// 奇数</span></span><br><span class="line">            result += <span class="built_in">subStringExtend</span>(s, i, i + <span class="number">1</span>, s.<span class="built_in">size</span>()); <span class="comment">// 偶数</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 从left/right开始往两头扩展，返回最长回文子串长度</span></span><br><span class="line">    <span class="comment">// 分为二者相等（奇数长度）二者不等（偶数长度）的情况</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">subStringExtend</span><span class="params">(<span class="type">const</span> string&amp; s, <span class="type">int</span> left, <span class="type">int</span> right, <span class="type">int</span> end)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> result = <span class="number">0</span>; <span class="comment">// 字符自己也认为是一个长度</span></span><br><span class="line">        <span class="keyword">while</span> (left &gt;= <span class="number">0</span> &amp;&amp; right &lt; end &amp;&amp; s[left] == s[right]) &#123;</span><br><span class="line">            left--;</span><br><span class="line">            right++;</span><br><span class="line">            <span class="comment">// 结果长度</span></span><br><span class="line">            result++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/07/df29ff97cd6c91a9429382adb4d27a47.png" alt="image.png"></p><h1 id="思路二：动态规划"><a href="#思路二：动态规划" class="headerlink" title="思路二：动态规划"></a>思路二：动态规划</h1><p>动态规划的思路就在<a href="https://blog.musnow.top/posts/2092587888">516最长回文子序列</a>题目里面接触过了。</p><p>动态规划的思路主要还是在于回文子串的特性是只需要判断首末两个字符是否相同。如果相同，再根据之前判断的结果，看这两个字符中间的部分是否回文，就能得出整体是否回文。</p><p>定义二维bool数组dp，长和宽都是字符串的长度；<code>dp[i][j]</code>的含义是i和j之间的子串是否为回文子串。</p><p>此时递推就只有<code>s[i]==s[j]</code>的情况需要进行操作，分为三种长度</p><ol><li>长度为1，一个字符是回文；</li><li>长度为2，两个字符相同，比如<code>aa</code>，也是回文；</li><li>长度大于2，可能是奇数回文也可能是偶数回文子串，判断<code>dp[i+1][j-1]</code>是否为true。</li></ol><p>根据这个递推关系，i和j的遍历顺序也需要进行修改，首先j肯定大于i，所以j是从i开始正序遍历的（因为j依赖于j-1）；而i依赖于i+1，所以i是从最后一个字符开始倒叙遍历的。</p><p>初始化的时候，只需要初始化矩阵中i和j相等的部分，相当于一个字符，是回文子串。</p><p>完整代码如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">countSubstrings</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (s.<span class="built_in">size</span>() &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> s.<span class="built_in">size</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 代表s中i和j下标之间是否是回文子串</span></span><br><span class="line">        vector&lt;vector&lt;<span class="type">bool</span>&gt;&gt; <span class="built_in">dp</span>(s.<span class="built_in">size</span>(), <span class="built_in">vector</span>&lt;<span class="type">bool</span>&gt;(s.<span class="built_in">size</span>(), <span class="literal">false</span>));</span><br><span class="line">        <span class="comment">// 初始化，i和j相同的时候肯定是回文，初始化为true</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; s.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            dp[i][i] = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> result = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 开始遍历，依赖项是i+1和j-1，所以i倒叙遍历，j正序遍历</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = s.<span class="built_in">size</span>() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = i; j &lt; s.<span class="built_in">size</span>(); j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (s[i] == s[j]) &#123;</span><br><span class="line">                    <span class="comment">// 只有一个字符，或者两个字符，是回文</span></span><br><span class="line">                    <span class="keyword">if</span> (<span class="built_in">abs</span>(i - j) + <span class="number">1</span> &lt;= <span class="number">2</span>) &#123;</span><br><span class="line">                        result++;</span><br><span class="line">                        dp[i][j] = <span class="literal">true</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// 偶数回文和奇数回文的情况等价，需要判断中间是否回文</span></span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span> (dp[i + <span class="number">1</span>][j - <span class="number">1</span>]) &#123;</span><br><span class="line">                        result++;</span><br><span class="line">                        dp[i][j] = <span class="literal">true</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/07/88be5cf1b9174388e1e9428a851cd66c.png" alt="image.png"></p>]]></content>
    
    
    <summary type="html">leetcode刷题笔记-647.回文子串</summary>
    
    
    
    <category term="编程学习" scheme="https://blog.musnow.top/categories/%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="把题目都给刷干净" scheme="https://blog.musnow.top/categories/%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0/%E6%8A%8A%E9%A2%98%E7%9B%AE%E9%83%BD%E7%BB%99%E5%88%B7%E5%B9%B2%E5%87%80/"/>
    
    
    <category term="OJ刷题" scheme="https://blog.musnow.top/tags/OJ%E5%88%B7%E9%A2%98/"/>
    
    <category term="leetcode" scheme="https://blog.musnow.top/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>【leetcode】72.编辑距离问题</title>
    <link href="https://blog.musnow.top/posts/3809163346/"/>
    <id>https://blog.musnow.top/posts/3809163346/</id>
    <published>2024-07-14T01:29:40.000Z</published>
    <updated>2024-07-14T01:45:22.000Z</updated>
    
    <content type="html"><![CDATA[<p>leetcode刷题笔记-72.编辑距离问题</p><h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><blockquote><p><a href="https://leetcode.cn/problems/edit-distance/">https://leetcode.cn/problems/edit-distance/</a></p></blockquote><p>给你两个单词 word1 和 word2， 请返回将 word1 转换成 word2 所使用的最少操作数  。</p><p>你可以对一个单词进行如下三种操作：</p><ul><li>插入一个字符</li><li>删除一个字符</li><li>替换一个字符</li></ul><p>示例</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">示例 1：</span><br><span class="line">输入：word1 = &quot;horse&quot;, word2 = &quot;ros&quot;</span><br><span class="line">输出：3</span><br><span class="line">解释：</span><br><span class="line">horse -&gt; rorse (将 &#x27;h&#x27; 替换为 &#x27;r&#x27;)</span><br><span class="line">rorse -&gt; rose (删除 &#x27;r&#x27;)</span><br><span class="line">rose -&gt; ros (删除 &#x27;e&#x27;)</span><br><span class="line"></span><br><span class="line">示例 2：</span><br><span class="line">输入：word1 = &quot;intention&quot;, word2 = &quot;execution&quot;</span><br><span class="line">输出：5</span><br><span class="line">解释：</span><br><span class="line">intention -&gt; inention (删除 &#x27;t&#x27;)</span><br><span class="line">inention -&gt; enention (将 &#x27;i&#x27; 替换为 &#x27;e&#x27;)</span><br><span class="line">enention -&gt; exention (将 &#x27;n&#x27; 替换为 &#x27;x&#x27;)</span><br><span class="line">exention -&gt; exection (将 &#x27;n&#x27; 替换为 &#x27;c&#x27;)</span><br><span class="line">exection -&gt; execution (插入 &#x27;u&#x27;)</span><br></pre></td></tr></table></figure><p>提示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">0 &lt;= word1.length, word2.length &lt;= 500</span><br><span class="line">word1 和 word2 由小写英文字母组成</span><br></pre></td></tr></table></figure><h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p>这道题基于<a href="https://blog.musnow.top/posts/1692714843">583.两个字符串的删除操作</a>上，将只可以删除一个字符改成了可以进行删除、替换、插入操作。但本质还是两个字符串进行比较，所以大部份代码都是一模一样的，只有比较时两个字符不相同的时候的操作才有区别。</p><p>首先是定义dp数组，还是采用常用的定义方式</p><ul><li><code>dp[i][j]</code>：将字符串1的i之前和字符串2的j之前变成相同字符串的最少操作次数。</li></ul><p>然后是确定dp数组的递推，首先是<code>word1[i-1]</code>和<code>word2[j-1]</code>相同和不相同这两种大情况</p><ul><li>当<code>word1[i-1] == word2[j-1]</code>，相当于不需要进行操作，<code>dp[i][j]=dp[i-1][j-1]</code>;</li><li>当<code>word[i-1] != word2[j-1]</code>，就需要进行编辑修改了；</li></ul><p>当二者不同的时候，有多种方式进行修改，题目给出的是删除、替换、插入。但其实插入和删除是等价的！给出下面这两个字符串</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">word1=&quot;a&quot; word2=&quot;ab&quot;</span><br></pre></td></tr></table></figure><p>假设我们进行删除，可以从word2中删除b字符，操作数是1；而进行插入是给word1插入一个字符b，操作数也是1。二者的操作数相同，那么递推公式也就相同，所以插入和删除可以认为是一种操作方式！</p><p>和583题不同的点就在于有一个<strong>替换</strong>的操作方式，当两个字符不同的时候，我们可以直接替换其中一个字符串中的字符，替换后两个字符就相等了，也就变成了<code>word1[i-1] == word2[j-1]</code>的情况，<code>dp[i][j]==dp[i-1][j-1]+1</code>;</p><p>最终的递推方案如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (word1[i<span class="number">-1</span>] == word2[j<span class="number">-1</span>]) &#123;</span><br><span class="line"><span class="comment">// 二者相等，不需要做额外操作，沿用前一位的结果</span></span><br><span class="line">dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>];</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// 二者不相等，分为三种操作情况，其中插入一个字符和删除一个字符等价</span></span><br><span class="line"><span class="comment">// 1.在word1中删除一个字符</span></span><br><span class="line"><span class="type">int</span> action1 = dp[i - <span class="number">1</span>][j] + <span class="number">1</span>;</span><br><span class="line"><span class="comment">// 2.在word2中删除一个字符</span></span><br><span class="line"><span class="type">int</span> action2 = dp[i][j - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line"><span class="comment">// 3.二者都删除一个字符</span></span><br><span class="line"><span class="type">int</span> action3 = dp[i - <span class="number">1</span>][j - <span class="number">1</span>] + <span class="number">2</span>;</span><br><span class="line"><span class="comment">// 4.在word1或者word2中替换一个字符，那就是使用一次操作让二者相等</span></span><br><span class="line"><span class="type">int</span> action4 = dp[i - <span class="number">1</span>][j - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line"><span class="comment">// 得到最小值</span></span><br><span class="line">dp[i][j] =</span><br><span class="line"><span class="built_in">min</span>(<span class="built_in">min</span>(action1, action2), <span class="built_in">min</span>(action3, action4));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但实际上，这里完全可以省略583题目中<strong>两个字符串中都删除字符</strong>的操作，因为它的值很明显比替换字符需要的操作数多一次，进行min计算是没有意义的。</p><p>初始化和遍历方式都和583题目完全一样，可以去看站内之前写的<a href="https://blog.musnow.top/posts/1692714843">583题目</a>的题解，这里就不赘述了。</p><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><p>完整代码如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">minDistance</span><span class="params">(string word1, string word2)</span> </span>&#123;</span><br><span class="line">        <span class="type">size_t</span> sz1 = word1.<span class="built_in">size</span>(), sz2 = word2.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span> (sz1 == <span class="number">0</span> || sz2 == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> sz1 == <span class="number">0</span> ? sz2 : sz1;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 1中i之前和2中j之前的字符串的最小编辑距离</span></span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dp</span>(sz1 + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(sz2 + <span class="number">1</span>, <span class="number">0</span>));</span><br><span class="line">        <span class="comment">// 初始化情况，dp[0][0]是两个空字符串，不需要编辑，初始化为0</span></span><br><span class="line">        <span class="comment">// i=0的情况和j=0的情况都是初始化为另外一个字符串的长度</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= sz1; i++) &#123;</span><br><span class="line">            dp[i][<span class="number">0</span>] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= sz2; j++) &#123;</span><br><span class="line">            dp[<span class="number">0</span>][j] = j;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 开始遍历</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= sz1; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= sz2; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (word1[i - <span class="number">1</span>] == word2[j - <span class="number">1</span>]) &#123;</span><br><span class="line">                    <span class="comment">// 二者相等，不需要做额外操作，沿用前一位的结果</span></span><br><span class="line">                    dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>];</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// 二者不相等，分为三种操作情况，其中插入一个字符和删除一个字符等价</span></span><br><span class="line">                    <span class="comment">// 1.在word1中删除一个字符</span></span><br><span class="line">                    <span class="type">int</span> action1 = dp[i - <span class="number">1</span>][j] + <span class="number">1</span>;</span><br><span class="line">                    <span class="comment">// 2.在word2中删除一个字符</span></span><br><span class="line">                    <span class="type">int</span> action2 = dp[i][j - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">                    <span class="comment">// 3.二者都删除一个字符，但这会比第四点耗费多一次操作，没意义</span></span><br><span class="line">                    <span class="comment">// int action3 = dp[i - 1][j - 1] + 2;</span></span><br><span class="line">                    <span class="comment">// 4.在word1或者word2中替换一个字符，那就是使用一次操作让二者相等</span></span><br><span class="line">                    <span class="type">int</span> action4 = dp[i - <span class="number">1</span>][j - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">                    <span class="comment">// 得到最小值</span></span><br><span class="line">                    dp[i][j] = <span class="built_in">min</span>(<span class="built_in">min</span>(action1, action2), action4);</span><br><span class="line">                    <span class="comment">// cout &lt;&lt; i &lt;&lt; &quot; &quot; &lt;&lt; j &lt;&lt; &quot;:&quot; &lt;&lt; dp[i][j] &lt;&lt; endl;</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[sz1][sz2];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/07/89371c34c3d6a3dacfa8f4ce0db8fa16.png" alt="image.png"></p>]]></content>
    
    
    <summary type="html">leetcode刷题笔记-72.编辑距离问题</summary>
    
    
    
    <category term="编程学习" scheme="https://blog.musnow.top/categories/%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="把题目都给刷干净" scheme="https://blog.musnow.top/categories/%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0/%E6%8A%8A%E9%A2%98%E7%9B%AE%E9%83%BD%E7%BB%99%E5%88%B7%E5%B9%B2%E5%87%80/"/>
    
    
    <category term="OJ刷题" scheme="https://blog.musnow.top/tags/OJ%E5%88%B7%E9%A2%98/"/>
    
    <category term="leetcode" scheme="https://blog.musnow.top/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>【leetcode】583.两个字符串的删除操作</title>
    <link href="https://blog.musnow.top/posts/1692714843/"/>
    <id>https://blog.musnow.top/posts/1692714843/</id>
    <published>2024-07-07T11:30:28.000Z</published>
    <updated>2024-07-07T11:48:25.000Z</updated>
    
    <content type="html"><![CDATA[<p>leetcode刷题笔记-583.两个字符串的删除操作。</p><h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><blockquote><p><a href="https://leetcode.cn/problems/delete-operation-for-two-strings/">https://leetcode.cn/problems/delete-operation-for-two-strings/</a></p></blockquote><p>给定两个单词 word1 和 word2 ，返回使得 word1 和  word2 相同所需的最小步数。</p><p>每步 可以删除任意一个字符串中的一个字符。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">示例 1：</span><br><span class="line">输入: word1 = &quot;sea&quot;, word2 = &quot;eat&quot;</span><br><span class="line">输出: 2</span><br><span class="line">解释: 第一步将 &quot;sea&quot; 变为 &quot;ea&quot; ，第二步将 &quot;eat &quot;变为 &quot;ea&quot;</span><br><span class="line"></span><br><span class="line">示例  2:</span><br><span class="line">输入：word1 = &quot;leetcode&quot;, word2 = &quot;etco&quot;</span><br><span class="line">输出：4</span><br></pre></td></tr></table></figure><p>提示</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1 &lt;= word1.length, word2.length &lt;= 500</span><br><span class="line">word1 和 word2 只包含小写英文字母</span><br></pre></td></tr></table></figure><h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p>本题要求将两个字符串变成相同的字符串，对于给出的所有用例，肯定是能变成相同的，最大的删除操作数就是将两个字符串的所有字符都删除（即两个字符串的长度之和），此时会得到两个空字符串，空字符串自然是相等的。至于其他情况，需要求的是<strong>最少</strong>操作次数，我们需要用<strong>动态规划</strong>的思路来解题。</p><p>这道题和之前写过的<a href="https://blog.musnow.top/posts/3193784003">115题：不同的子序列</a>非常相似，在115题中，是用s的子序列去匹配t整个字符串，t字符串不能改变，只能在s中删除字母。但本题是求两个字符串怎么通过一些操作变成相同的字符串，每一步都可以从两个字符串其中一个字符串中删除一个字符，两个字符串都能被修改。</p><p>先来走动态规划的流程吧！第一步是确定dp数组的含义。</p><ul><li><code>dp[i][j]</code>：字符串a中下标i-1和字符串b中下标i-1及其之前的字符串需要至少几次操作能变成相同的字符串。</li><li>这里也可以理解为字符串a中前i个字符组成的字符串与字符串b中前j个字符组成的字符串需要至少几次操作能变成相同的字符串。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dp</span>(word1.<span class="built_in">size</span>() + <span class="number">1</span>,</span><br><span class="line">                       <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(word2.<span class="built_in">size</span>() + <span class="number">1</span>, <span class="number">0</span>));</span><br></pre></td></tr></table></figure><p>然后是确定递推公式</p><ul><li>情况一：<code>a[i-1] == b[j-1]</code>，此时不需要删除字符，沿用<code>dp[i-1][j-1]</code>的结果就行了。</li><li>情况二：<code>a[i-1] != b[j-1]</code>，此时需要删除字符，有三种删除方式，取其中最小值即可：<ul><li>删除a中的字符，结果为<code>dp[i-1][j]+1</code>;</li><li>删除b中的字符，结果为<code>dp[i][j-1]+1</code>;</li><li>把a和b中的这俩字符都删了，结果为<code>dp[i-1][j-1]+2</code>;</li></ul></li></ul><p>dp数组的遍历顺序，因为<code>dp[i][j]</code>很明显是依赖于<code>dp[i-1][j-1]</code>的，所以需要从左到右遍历。</p><p>再确定如何初始化dp数组，也分为三种情况：</p><ul><li><code>i=0,j=0</code>的情况，两个都是空字符串，不需要做删除操作，初始化为0；</li><li><code>i=0</code>或<code>j=0</code>的情况，一个是空字符串，另外一个字符串需要做的操作次数是字符串的长度次。</li></ul><p>最终的初始化代码如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// i和j都为0的时候不需要操作，初始化为0（通过构造函数初始化）</span></span><br><span class="line"><span class="comment">// 当i=0或者j=0的时候，需要的操作次数是当前的字符串长度，即需要将当前字符串全部删除才能和空字符串相同</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= word1.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">    dp[i][<span class="number">0</span>] = i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= word2.<span class="built_in">size</span>(); j++) &#123;</span><br><span class="line">    dp[<span class="number">0</span>][j] = j;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><p>完整代码如下，思路明白了代码还是很好写的</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">minDistance</span><span class="params">(string word1, string word2)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 如果有一个长度为0，那么需要做的操作是另外一个字符串的长度次</span></span><br><span class="line">        <span class="keyword">if</span> (word1.<span class="built_in">size</span>() == <span class="number">0</span> || word2.<span class="built_in">size</span>() == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> word1.<span class="built_in">size</span>() == <span class="number">0</span> ? word2.<span class="built_in">size</span>() : word1.<span class="built_in">size</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// dp数组，代表a中i-1和b中j-1的字符串相同需要操作的最少次数（i和j可以认为是字符串长度）</span></span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dp</span>(word1.<span class="built_in">size</span>() + <span class="number">1</span>,</span><br><span class="line">                               <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(word2.<span class="built_in">size</span>() + <span class="number">1</span>, <span class="number">0</span>));</span><br><span class="line">        <span class="comment">// i和j都为0的时候不需要操作，初始化为0（通过构造函数初始化）</span></span><br><span class="line">        <span class="comment">// 当i=0或者j=0的时候，需要的操作次数是当前的字符串长度，即需要将当前字符串全部删除才能和空字符串相同</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= word1.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            dp[i][<span class="number">0</span>] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= word2.<span class="built_in">size</span>(); j++) &#123;</span><br><span class="line">            dp[<span class="number">0</span>][j] = j;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 开始递推</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= word1.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= word2.<span class="built_in">size</span>(); j++) &#123;</span><br><span class="line">                <span class="comment">// 情况1，二者相同，不需要删除</span></span><br><span class="line">                <span class="keyword">if</span> (word1[i - <span class="number">1</span>] == word2[j - <span class="number">1</span>]) &#123;</span><br><span class="line">                    dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>];</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="comment">// 情况2，不同</span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="comment">// 把word1中的字符串删除，需要的操作次数是dp[i-1][j]+1</span></span><br><span class="line">                    <span class="comment">// 把word2中的字符串删除，需要的操作次数是dp[i][j-1]+1</span></span><br><span class="line">                    <span class="comment">// 把word1和2中的字符串都删除，需要的操作次数是dp[i-1][j-1]+2</span></span><br><span class="line">                    <span class="comment">// 取三种情况最小值作为最终结果。</span></span><br><span class="line">                    dp[i][j] = <span class="built_in">min</span>(dp[i - <span class="number">1</span>][j] + <span class="number">1</span>,</span><br><span class="line">                                   <span class="built_in">min</span>(dp[i][j - <span class="number">1</span>] + <span class="number">1</span>, dp[i - <span class="number">1</span>][j - <span class="number">1</span>] + <span class="number">2</span>));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// dp数组右下角的值就是最终结果</span></span><br><span class="line">        <span class="keyword">return</span> dp[word1.<span class="built_in">size</span>()][word2.<span class="built_in">size</span>()];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/07/c4a7e94f23264e9d36aec1931f96f0d6.png" alt="image.png"></p><p>注意提交到leetcode时候可能会提示返回值不匹配，将函数开头的if里面加一个对<code>int</code>类型的强转就行了。</p>]]></content>
    
    
    <summary type="html">leetcode刷题笔记-583.两个字符串的删除操作</summary>
    
    
    
    <category term="编程学习" scheme="https://blog.musnow.top/categories/%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="把题目都给刷干净" scheme="https://blog.musnow.top/categories/%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0/%E6%8A%8A%E9%A2%98%E7%9B%AE%E9%83%BD%E7%BB%99%E5%88%B7%E5%B9%B2%E5%87%80/"/>
    
    
    <category term="OJ刷题" scheme="https://blog.musnow.top/tags/OJ%E5%88%B7%E9%A2%98/"/>
    
    <category term="leetcode" scheme="https://blog.musnow.top/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>【Linux】升级OpenSSH版本规避远程代码执行漏洞</title>
    <link href="https://blog.musnow.top/posts/3307105016/"/>
    <id>https://blog.musnow.top/posts/3307105016/</id>
    <published>2024-07-06T01:53:14.000Z</published>
    <updated>2024-07-06T15:01:54.000Z</updated>
    
    <content type="html"><![CDATA[<p>升级OpenSSH版本规避远程代码执行漏洞。</p><h1 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h1><p>今天早上逛别人的博客的时候看到了这个重磅消息。OpenSSH爆出能远程通过root身份执行任意代码的漏洞，影响版本是 <code>8.5p1 &lt;= OpenSSH &lt; 9.8p1</code>，奇安信的报告可以<a href="https://www.secrss.com/articles/67636?app=1">点我</a>查看。</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/07/3b52c18c721324a209cb2a710faa7b90.png"></p><p>上我的几个云服务器（ubuntu22.04和CentOS8Strem）看了看版本，Ubuntu的服务器中招了</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ sshd -V</span><br><span class="line">unknown option -- V</span><br><span class="line">OpenSSH_8.9p1 Ubuntu-3ubuntu0.6, OpenSSL 3.0.2 15 Mar 2022</span><br><span class="line">usage: sshd [-46DdeiqTt] [-C connection_spec] [-c host_cert_file]</span><br><span class="line">            [-E log_file] [-f config_file] [-g login_grace_time]</span><br><span class="line">            [-h host_key_file] [-o option] [-p port] [-u len]</span><br></pre></td></tr></table></figure><p>CentOS的服务器因为依赖项确实老旧，没有中招，因祸得福了属于是。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># sshd -V</span><br><span class="line">unknown option -- v</span><br><span class="line">OpenSSH_8.0p1, OpenSSL 1.1.1k  FIPS 25 Mar 2021</span><br><span class="line">usage: sshd [-46DdeiqTt] [-C connection_spec] [-c host_cert_file]</span><br><span class="line">            [-E log_file] [-f config_file] [-g login_grace_time]</span><br><span class="line">            [-h host_key_file] [-o option] [-p port] [-u len]</span><br></pre></td></tr></table></figure><p>不过本次攻击如果服务器上有fail2ban的话能被拦截掉。我的服务器都安装了1panel里面的fail2ban组件，好欸！</p><h1 id="修复措施"><a href="#修复措施" class="headerlink" title="修复措施"></a>修复措施</h1><blockquote><p>参考博客：<a href="https://learnku.com/articles/87482">https://learnku.com/articles/87482</a> 和论坛 <a href="https://linux.do/t/topic/124761">https://linux.do/t/topic/124761</a></p></blockquote><p>编译和安装依赖项</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 安装编译依赖</span></span><br><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get install -y build-essential zlib1g-dev libssl-dev</span><br><span class="line"></span><br><span class="line"><span class="comment"># 下载指定版本源码</span></span><br><span class="line">wget https://cdn.openbsd.org/pub/OpenBSD/OpenSSH/portable/openssh-9.8p1.tar.gz</span><br><span class="line"></span><br><span class="line"><span class="comment"># 解压并进入目录</span></span><br><span class="line">tar -xzf openssh-9.8p1.tar.gz</span><br><span class="line"><span class="built_in">cd</span> openssh-9.8p1</span><br><span class="line"></span><br><span class="line"><span class="comment"># 编译和安装</span></span><br><span class="line">./configure</span><br><span class="line">make</span><br><span class="line">sudo make install</span><br><span class="line"></span><br><span class="line"><span class="comment"># 重启</span></span><br><span class="line">sudo systemctl restart ssh</span><br></pre></td></tr></table></figure><p>可以用下面的命令一键升级（和上面的一致只是整合在一起了）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get update &amp;&amp; sudo apt-get install -y build-essential zlib1g-dev libssl-dev &amp;&amp; wget https://cdn.openbsd.org/pub/OpenBSD/OpenSSH/portable/openssh-9.8p1.tar.gz &amp;&amp; tar -xzf openssh-9.8p1.tar.gz &amp;&amp; <span class="built_in">cd</span> openssh-9.8p1 &amp;&amp; ./configure &amp;&amp; make &amp;&amp; sudo make install &amp;&amp; sudo systemctl restart ssh</span><br></pre></td></tr></table></figure><p>处理后重新看看版本更新了没有，如下所示就是OK了——吗？</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># ssh -V</span><br><span class="line">OpenSSH_9.8p1, OpenSSL 3.0.2 15 Mar 2022</span><br></pre></td></tr></table></figure><p>实际上，上文的步骤只更新了ssh（客户端），而且是一个环境变量导致的“假更新”，sshd（服务端）还没有变化，还是旧版本。用可执行文件的<strong>绝对路径</strong>查看版本就会漏出鸡脚，依然是旧版本没有被正常升级。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># /usr/bin/ssh -V</span><br><span class="line">OpenSSH_8.9p1 Ubuntu-3ubuntu0.10, OpenSSL 3.0.2 15 Mar 2022</span><br></pre></td></tr></table></figure><p>要更新一下软连接，才能正确更新ssh&#x2F;sshd。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 备份原来的ssh组件</span></span><br><span class="line"><span class="built_in">mv</span> /usr/sbin/sshd /usr/sbin/sshd.old</span><br><span class="line"><span class="built_in">mv</span> /usr/bin/ssh /usr/bin/ssh.old</span><br><span class="line"><span class="built_in">mv</span> /usr/bin/ssh-keygen /usr/bin/ssh-keygen.old</span><br><span class="line"><span class="comment"># 更新</span></span><br><span class="line"><span class="built_in">cp</span> /usr/local/bin/ssh /usr/bin/ssh</span><br><span class="line"><span class="built_in">cp</span> /usr/local/bin/ssh-keygen /usr/bin/ssh-keygen</span><br><span class="line"><span class="built_in">cp</span> /usr/local/sbin/sshd /usr/sbin/sshd</span><br><span class="line"><span class="comment"># 重启服务</span></span><br><span class="line">sudo systemctl restart ssh</span><br><span class="line">sudo systemctl restart sshd</span><br></pre></td></tr></table></figure><p>如下所示，更新成功。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># sshd -V</span><br><span class="line">OpenSSH_9.8p1, OpenSSL 3.0.2 15 Mar 2022</span><br><span class="line"># ssh -V</span><br><span class="line">OpenSSH_9.8p1, OpenSSL 3.0.2 15 Mar 2022</span><br></pre></td></tr></table></figure><p>注意，必须使用cp来修改文件，而不能使用软连接！</p><h1 id="后续"><a href="#后续" class="headerlink" title="后续"></a>后续</h1><p>注意，升级完毕sshd后会导致服务器的ssh密钥发生变化，如果你的本地曾经链接过这个主机，会出现本地记录的公钥和服务器升级ssh后重新发送的公钥不一致的情况。</p><p>这时候需要修改<code>C:\Users\用户名\.ssh\known_hosts</code>这个文件（使用记事本打开就行了），将里面对应云服务器IP开头的记录全部删除，再重新链接服务器。</p><p>如果您不执行这一步操作，一些严格检查密钥的ssh终端软件可能会无法连接服务器，比如vscode的remote ssh插件，tabby则会在重新链接服务器的时候弹出密钥不一致的警告。反正修改一下准没错，修改了之后重新接受并保存云服务器发过来的新密钥就可以了。</p><p>PS：vscode的remove ssh插件在出现密钥不一致的时候会显示链接不上远程服务器，但是在错误日志中会打印出密钥不一致和开启了严格检查相关的字样（当然打印的错误信息是全英文的），我也是因此定位到这个问题的。所以说遇到问题的时候，不要有畏难情绪，一定要敢于看日志，敢于查日志。</p>]]></content>
    
    
    <summary type="html">升级OpenSSH版本规避远程代码执行漏洞</summary>
    
    
    
    <category term="编程学习" scheme="https://blog.musnow.top/categories/%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="Linux" scheme="https://blog.musnow.top/categories/%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0/Linux/"/>
    
    
    <category term="Linux" scheme="https://blog.musnow.top/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>【docker】使用github action来自动发布项目到dockerhub</title>
    <link href="https://blog.musnow.top/posts/92024430/"/>
    <id>https://blog.musnow.top/posts/92024430/</id>
    <published>2024-06-27T14:04:31.000Z</published>
    <updated>2024-07-01T03:03:04.000Z</updated>
    
    <content type="html"><![CDATA[<p>使用github action来自动发布项目到dockerhub。参考 <a href="https://msdemt.github.io/p/github-action-build-docker/">https://msdemt.github.io/p/github-action-build-docker/</a> 博客</p><h1 id="1-准备工作"><a href="#1-准备工作" class="headerlink" title="1.准备工作"></a>1.准备工作</h1><h2 id="1-1-dockerhub-token"><a href="#1-1-dockerhub-token" class="headerlink" title="1.1 dockerhub token"></a>1.1 dockerhub token</h2><blockquote><p><a href="https://hub.docker.com/settings/security">https://hub.docker.com/settings/security</a></p></blockquote><p>登录dockerhub，在用户的account settings里面获取用户token</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/06/e5a6a9c655d9db35241803283107f9b6.png" alt="image.png"></p><p>将其添加到github仓库的secrets里面，具体位置是仓库设置中的 Secrets and variables 里面的 Actions 栏目中，如下图所示，添加 Repository secrets。</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/06/5f6bbb25c29e36438a077c77b0b2f7f8.png" alt="image.png"></p><p>需要添加的是<code>DOCKER_USERNAME</code>为你的docker用户名（注意是用户名，不是邮箱），还有<code>DOCKER_TOKEN</code>为刚刚我们在dockerhub中获取的token。</p><h2 id="1-2-获取github操作token"><a href="#1-2-获取github操作token" class="headerlink" title="1.2 获取github操作token"></a>1.2 获取github操作token</h2><blockquote><p><a href="https://github.com/settings/tokens">https://github.com/settings/tokens</a></p></blockquote><p>到GitHub的用户设置中，创建一个token，需要给予repo、workflow、packages权限。如果你不知道给予什么权限，直接全给他选上，保障这个token不泄露给外部就可以了。</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/06/d34671906803fd55ffe656bd4643f6d5.png" alt="image.png"></p><p>另外，expiration是过期日期，如果你担心泄漏造成问题，可以设置一个过期时间，但是需要到时间后去更新仓库的secrets。</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/06/6df1058ec2b9b838df0451d1d9dd2dfe.png" alt="image.png"></p><p>点击确定以后会得到token，复制他，同样是到github仓库的secrets里面添加一个 <code>RELEASE_TOKEN</code> 变量。</p><h1 id="2-上传workflows文件"><a href="#2-上传workflows文件" class="headerlink" title="2.上传workflows文件"></a>2.上传workflows文件</h1><h2 id="2-1-添加如下yml文件"><a href="#2-1-添加如下yml文件" class="headerlink" title="2.1 添加如下yml文件"></a>2.1 添加如下yml文件</h2><p>前期的准备工作已经搞定了，现在就是添加一个github action的yml文件了。</p><p>在你的仓库里面创建一个<code>.github/workflows</code>文件夹，并在里面创建一个<code>.yml</code>文件，写入如下内容。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">name:</span> <span class="string">docker</span> <span class="string">images</span> <span class="string">cicd</span></span><br><span class="line"><span class="comment"># 触发器设置</span></span><br><span class="line"><span class="attr">on:</span></span><br><span class="line">  <span class="attr">push:</span></span><br><span class="line">    <span class="attr">branches:</span> [ <span class="string">&quot;main&quot;</span> ]</span><br><span class="line">  <span class="attr">pull_request:</span></span><br><span class="line">    <span class="attr">branches:</span> [ <span class="string">&quot;main&quot;</span> ]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 项目任务，任务之间可以并行调度</span></span><br><span class="line"><span class="attr">jobs:</span></span><br><span class="line">  <span class="attr">build:</span></span><br><span class="line">  <span class="comment"># 选择云端运行的环境</span></span><br><span class="line">    <span class="attr">runs-on:</span> <span class="string">ubuntu-latest</span></span><br><span class="line">    <span class="attr">steps:</span></span><br><span class="line">    <span class="comment"># uses代表使用一个模块，此处使用的是checkout模块，将github项目文件导入到当前环境中</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">uses:</span> <span class="string">actions/checkout@v3</span></span><br><span class="line">    <span class="comment"># 使用with跟在后面来为前面的模块输入参数</span></span><br><span class="line">      <span class="attr">with:</span></span><br><span class="line">        <span class="attr">submodules:</span> <span class="string">&#x27;true&#x27;</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Set</span> <span class="string">up</span> <span class="string">QEMU</span></span><br><span class="line">      <span class="attr">uses:</span> <span class="string">docker/setup-qemu-action@v2</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Set</span> <span class="string">up</span> <span class="string">Docker</span> <span class="string">Buildx</span></span><br><span class="line">      <span class="attr">uses:</span> <span class="string">docker/setup-buildx-action@v2</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Login</span> <span class="string">to</span> <span class="string">DockerHub</span></span><br><span class="line">      <span class="attr">uses:</span> <span class="string">docker/login-action@v2</span></span><br><span class="line">      <span class="attr">with:</span></span><br><span class="line">    <span class="comment"># 这里用到了github的secrets功能，避免账户和密码随仓库泄露</span></span><br><span class="line">       <span class="attr">username:</span> <span class="string">$&#123;&#123;</span> <span class="string">secrets.DOCKER_USERNAME</span> <span class="string">&#125;&#125;</span></span><br><span class="line">       <span class="attr">password:</span> <span class="string">$&#123;&#123;</span> <span class="string">secrets.DOCKER_TOKEN</span> <span class="string">&#125;&#125;</span></span><br><span class="line">    <span class="comment"># 设置当前的发行版本tag</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Release</span> <span class="string">version</span></span><br><span class="line">      <span class="attr">id:</span> <span class="string">release_version</span></span><br><span class="line">      <span class="attr">run:</span> <span class="string">|</span></span><br><span class="line"><span class="string">        app_version=$(cat version.py |sed -ne &quot;s/APP_VERSION\s=\s&#x27;v\(.*\)&#x27;/\1/gp&quot;)</span></span><br><span class="line"><span class="string">        echo &quot;app_version=$app_version&quot; &gt;&gt; $GITHUB_ENV</span></span><br><span class="line"><span class="string"></span>    <span class="comment"># 开始构建镜像</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Build</span> <span class="string">and</span> <span class="string">push</span></span><br><span class="line">      <span class="attr">uses:</span> <span class="string">docker/build-push-action@v2</span></span><br><span class="line">      <span class="attr">with:</span></span><br><span class="line">        <span class="attr">context:</span> <span class="string">.</span></span><br><span class="line">        <span class="attr">file:</span> <span class="string">dockerfile</span></span><br><span class="line">        <span class="attr">build-args:</span> <span class="string">|</span></span><br><span class="line"><span class="string">          GITHUB_TOKEN=$&#123;&#123; secrets.RELEASE_TOKEN &#125;&#125;</span></span><br><span class="line"><span class="string"></span>        <span class="attr">platforms:</span> <span class="string">|</span></span><br><span class="line"><span class="string">          linux/amd64</span></span><br><span class="line"><span class="string">          linux/arm64</span></span><br><span class="line"><span class="string">          linux/arm</span></span><br><span class="line"><span class="string"></span>        <span class="attr">push:</span> <span class="literal">true</span></span><br><span class="line">        <span class="comment"># 指定用户/仓库名</span></span><br><span class="line">        <span class="attr">tags:</span> <span class="string">|</span></span><br><span class="line"><span class="string">          $&#123;&#123; secrets.DOCKER_USERNAME &#125;&#125;/kook-ticket-bot:latest</span></span><br><span class="line"><span class="string">          $&#123;&#123; secrets.DOCKER_USERNAME &#125;&#125;/kook-ticket-bot:$&#123;&#123; env.app_version &#125;&#125;</span></span><br><span class="line"><span class="string"></span>    <span class="comment"># 这里是通过md文件自动生成dockerhub描述的模块，也可以不需要</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Docker</span> <span class="string">Hub</span> <span class="string">Description</span></span><br><span class="line">      <span class="attr">uses:</span> <span class="string">peter-evans/dockerhub-description@v3</span></span><br><span class="line">      <span class="attr">with:</span></span><br><span class="line">        <span class="attr">username:</span> <span class="string">$&#123;&#123;</span> <span class="string">secrets.DOCKER_USERNAME</span> <span class="string">&#125;&#125;</span></span><br><span class="line">        <span class="attr">password:</span> <span class="string">$&#123;&#123;</span> <span class="string">secrets.DOCKER_PASSWORD</span> <span class="string">&#125;&#125;</span></span><br><span class="line">        <span class="attr">repository:</span> <span class="string">$&#123;&#123;</span> <span class="string">secrets.DOCKER_USERNAME</span> <span class="string">&#125;&#125;/kook-ticket-bot</span></span><br><span class="line">        <span class="attr">readme-filepath:</span> <span class="string">./README.md</span></span><br></pre></td></tr></table></figure><p>对这里面的内容做一定说明，其中<code>secrets.</code>使用的就是我们刚刚添加到github仓库中的变量，分别用于访问github仓库和登录dockerhub。</p><blockquote><p>你会发现最末尾通过readme文件自动生成dockerhub的描述部分，多出来了一个上文没有提到的<code>secrets.DOCKER_PASSWORD</code>，这个是你dockerhub账户的密码。如果你不需要自动生成dockerhub的描述，那就可以把最后一个<code>Docker Hub Description</code>条目直接删除了，否则需要添加这个secrets。</p></blockquote><p>项目中我使用了<code>version.py</code>文件来存放最新的版本号，该文件需要在项目的根路径中创建，内容格式如下</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">APP_VERSION = <span class="string">&#x27;版本号&#x27;</span></span><br></pre></td></tr></table></figure><p>使用这个workflows文件，你只需要修改<code>$&#123;&#123; secrets.DOCKER_USERNAME &#125;&#125;/kook-ticket-bot</code>里面右侧的镜像名字为你的项目名字，将<code>file: dockerfile</code>这里的dockerfile设置为你项目中dockerfile的文件路径就可以了。</p><p>另外，在这个yml中，指定了三个平台的docker镜像，这里可以根据你自己的实际需要来减少一些平台。毕竟大部分用户用的都是amd64（即x86）的电脑，如果没有用户需要使用arm平台，可以把后两项删除，以加快github action的运行速度。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">platforms:</span> <span class="string">|</span></span><br><span class="line"><span class="string">  linux/amd64</span></span><br><span class="line"><span class="string">  linux/arm64</span></span><br><span class="line"><span class="string">  linux/arm</span></span><br></pre></td></tr></table></figure><p>最终完成action的截图如下</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/06/de256712cbc7eeb5a0b09c51b21fa424.png" alt="image.png"></p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/06/66332edc975a36e9f3e7c76b8d336554.png" alt="image.png"></p><h2 id="2-2-关于GITHUB-REPOSITORY-NAME-PART环境变量"><a href="#2-2-关于GITHUB-REPOSITORY-NAME-PART环境变量" class="headerlink" title="2.2 关于GITHUB_REPOSITORY_NAME_PART环境变量"></a>2.2 关于GITHUB_REPOSITORY_NAME_PART环境变量</h2><p>在别的github action教学文章中，会提到使用<code>$&#123;&#123; env.GITHUB_REPOSITORY_NAME_PART &#125;&#125;</code>来直接用github的仓库名字作为镜像名。但经过我的测试，这个方法<strong>不适用于本文</strong>的这个workflows文件，使用该环境变量会导致容器的名字多出来一个尾随的<code>/</code>，最终的镜像名字变成了<code>用户名/镜像名/:tag</code>，不符合dockerhub中镜像的命名规范。以下是具体的actions执行错误截图。</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/06/e8cc4604fa2b465f6ff37f8cc8862a69.png" alt="image.png"></p><h1 id="The-end"><a href="#The-end" class="headerlink" title="The end"></a>The end</h1><p>不过，根据github actions上的warning，我这个workflows文件已经是老版本的了，里面使用的很多特性都即将不再支持，所以只是个临时用用的权宜之计，后续得去找个另外的yaml文件来处理这个docker镜像了。</p>]]></content>
    
    
    <summary type="html">使用github action来自动发布项目到dockerhub</summary>
    
    
    
    <category term="编程学习" scheme="https://blog.musnow.top/categories/%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="Docker真好玩" scheme="https://blog.musnow.top/categories/%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0/Docker%E7%9C%9F%E5%A5%BD%E7%8E%A9/"/>
    
    
    <category term="Docker" scheme="https://blog.musnow.top/tags/Docker/"/>
    
  </entry>
  
  <entry>
    <title>【win】解决windows打游戏卡输入法的问题</title>
    <link href="https://blog.musnow.top/posts/104528985/"/>
    <id>https://blog.musnow.top/posts/104528985/</id>
    <published>2024-06-26T03:04:23.000Z</published>
    <updated>2024-06-27T14:04:07.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>APEX在24.06.26更新了四人赛的新版本，然后，您猜怎么着？卡输入法啦！昨天的旧版本都不卡的，不愧是重生，引入了新的BUG。</p><p>本片博文来告诉各位游戏玩家，如何让你的游戏不会卡输入法。</p><p>给不打游戏的老哥科普一下：卡输入法一般指<strong>卡中文输入法</strong>，即部分游戏与中文输入法不兼容，在游戏全屏的时候，WASD会直接呼出中文输入法，导致游戏退出全屏，且不响应玩家的输入。如果在和其他玩家干架的时候遇到这个问题，那就GG了。</p><h1 id="添加ENG语言选项"><a href="#添加ENG语言选项" class="headerlink" title="添加ENG语言选项"></a>添加ENG语言选项</h1><p>在windows设置中找到语言和区域，在这里添加一个英文语言，一般添加 <code>英语（美国）</code> 这个语言，只需要选择基本输入法就行了，语言包什么的都可以不用选。</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/06/d558dfff82b9867940d095c535c00d97.png" alt="image.png"></p><p>打游戏的时候，在状态栏右下角将语言切换为ENG，就不会卡输入法了。</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/06/f23fd8f3f31318f12d2ed88edabf9eb3.png" alt="image.png"></p><h1 id="关闭快捷键"><a href="#关闭快捷键" class="headerlink" title="关闭快捷键"></a>关闭快捷键</h1><p>默认情况下，切换输入法会有两个快捷键，一个是WIN+空格，一个是ALT+SHIFT，这两个快捷键都极其容易在打游戏的时候误触，所以我们需要把快捷键给改了。</p><p>在win11的<code>设置-时间和语言-输入-高级键盘设置</code>中，找到<strong>输入语言热键</strong>选项，将输入语言的热键全都设置为无。这样ALT+SHIFT的快捷键就被删了。</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/06/e520841c3cc8fc6b17718029b44f7e4a.png" alt="image.png"></p><p>现在就只能用<code>WIN+空格</code>切换输入法了，直接用键盘把WIN给锁了就行了（一般都是FN+WIN快捷键），稍微好一点的键盘都有锁WIN这个功能。</p><p>部分游戏本也有锁WIN的功能，一般是在游戏本的控制台里面（据我所知拯救者和华硕的游戏本都有这个功能，其他品牌不清楚）。如果是商务本，那基本就没有这个功能了，考虑外接键盘吧。</p><p>根据我个人核显本、带独立显卡的轻薄本、游戏本都用过一圈的使用经历，目前就没有几个笔记本电脑能做到打游戏键盘完全不烫手的。<strong>为了避免低温烫伤</strong>，请不要使用笔记本自带键盘打游戏，这可关系到个人健康！哪怕买个最烂的薄膜键盘，也好过烫烫烫！</p>]]></content>
    
    
    <summary type="html">解决windows打游戏卡输入法的问题</summary>
    
    
    
    <category term="差生文具多" scheme="https://blog.musnow.top/categories/%E5%B7%AE%E7%94%9F%E6%96%87%E5%85%B7%E5%A4%9A/"/>
    
    <category term="电脑使用小贴士" scheme="https://blog.musnow.top/categories/%E5%B7%AE%E7%94%9F%E6%96%87%E5%85%B7%E5%A4%9A/%E7%94%B5%E8%84%91%E4%BD%BF%E7%94%A8%E5%B0%8F%E8%B4%B4%E5%A3%AB/"/>
    
    
    <category term="windows" scheme="https://blog.musnow.top/tags/windows/"/>
    
  </entry>
  
  <entry>
    <title>【Python】使用py脚本按序号重命名md文档</title>
    <link href="https://blog.musnow.top/posts/2939398257/"/>
    <id>https://blog.musnow.top/posts/2939398257/</id>
    <published>2024-06-21T02:12:32.000Z</published>
    <updated>2024-06-21T11:54:48.000Z</updated>
    
    <content type="html"><![CDATA[<p>前情提要：我的HEXO是用obsidian管理的，本地使用FreeFileSync将obsidian中CODE目录里面的所有文件（这个目录里面都是博客）镜像同步到HEXO配置的<code>_posts</code>目录里面。</p><p>为了方便按时间排序我的文档，我每次写新博客的时候，都会按序号命名。但是之前将一些大文件夹里面的md文件进行了细分归纳，导致某些文件夹里面的md文件<strong>序号不再连续</strong>，看起来非常奇怪，自己改肯定不方便，直接写个python脚本来处理一下这种情况吧。</p><p>我的md文件是这样命名的</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">序号.文件名.md</span><br></pre></td></tr></table></figure><p>在某个文件夹下会出现这种情况，即文件的序号不连续。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1.文件a.md</span><br><span class="line">3.文件b.md</span><br><span class="line">10.文件c.md</span><br></pre></td></tr></table></figure><p>我想达成的目标就是让这三个文件按连续的序号重新命名，并添加前导0，就像这样</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">01.文件a.md</span><br><span class="line">02.文件b.md</span><br><span class="line">03.文件c.md</span><br></pre></td></tr></table></figure><p>将需求直接喂给GPT，给出了下面这个脚本，个人测试完全莫得问题，贴出来分享给大家。自己写也不是写不出来，主要就是懒，实在是太懒了。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">rename_md_files</span>(<span class="params">folder_path</span>):</span><br><span class="line">    <span class="comment"># 获取所有md文件</span></span><br><span class="line">    files = [f <span class="keyword">for</span> f <span class="keyword">in</span> os.listdir(folder_path) <span class="keyword">if</span> f.endswith(<span class="string">&#x27;.md&#x27;</span>)]</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 使用正则表达式匹配文件名中的数字</span></span><br><span class="line">    pattern = re.<span class="built_in">compile</span>(<span class="string">r&#x27;^(\d+)\..+\.md$&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 提取出所有匹配的文件</span></span><br><span class="line">    matched_files = []</span><br><span class="line">    <span class="keyword">for</span> file <span class="keyword">in</span> files:</span><br><span class="line">        <span class="keyword">match</span> = pattern.<span class="keyword">match</span>(file)</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">match</span>:</span><br><span class="line">            matched_files.append((<span class="built_in">int</span>(<span class="keyword">match</span>.group(<span class="number">1</span>)), file))</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 按照原始数字顺序排序</span></span><br><span class="line">    matched_files.sort()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 重新编号</span></span><br><span class="line">    <span class="keyword">for</span> new_index, (old_index, old_name) <span class="keyword">in</span> <span class="built_in">enumerate</span>(matched_files, start=<span class="number">1</span>):</span><br><span class="line">        new_name = <span class="string">f&quot;<span class="subst">&#123;new_index:02d&#125;</span>.<span class="subst">&#123;old_name.split(<span class="string">&#x27;.&#x27;</span>, <span class="number">1</span>)[<span class="number">1</span>]&#125;</span>&quot;</span></span><br><span class="line">        old_path = os.path.join(folder_path, old_name)</span><br><span class="line">        new_path = os.path.join(folder_path, new_name)</span><br><span class="line">        os.rename(old_path, new_path)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;Renamed &#x27;<span class="subst">&#123;old_name&#125;</span>&#x27; to &#x27;<span class="subst">&#123;new_name&#125;</span>&#x27;&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">traverse_and_rename</span>(<span class="params">folder_path</span>):</span><br><span class="line">    <span class="keyword">for</span> root, dirs, files <span class="keyword">in</span> os.walk(folder_path):</span><br><span class="line">        rename_md_files(root)</span><br><span class="line">        <span class="keyword">for</span> <span class="built_in">dir</span> <span class="keyword">in</span> dirs:</span><br><span class="line">            traverse_and_rename(os.path.join(root, <span class="built_in">dir</span>))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用示例</span></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    folder_path = <span class="string">r&quot;path/to/folder&quot;</span>  <span class="comment"># 替换为你的文件夹路径</span></span><br><span class="line">    traverse_and_rename(folder_path)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;The End.&quot;</span>)</span><br></pre></td></tr></table></figure><p>修改脚本最末尾需要处理的文件夹路径，脚本会使用<code>os.walk</code>来遍历这个文件路径下的所有文件，并交付给<code>traverse_and_rename</code>函数进行md文件的处理。在<code>traverse_and_rename</code>函数中，使用了正则来匹配我的原有文件命名方式，再根据原有的序号进行排序，最终按排序的结果重新命名文档。</p><p>这里的<code>new_index:02d</code>就是添加前导0的写法，<code>02d</code>代表数字不足两位会添加一个前导0。比如01和02。</p><p>运行脚本，会打印出原有名字和命名后的结果，个人感觉效果还是非常不错的。不过还是得提醒一下大家：<strong>使用任何脚本操作你的笔记之前，都一定要对先有的数据备份一次</strong>！</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">PS E:\GIT\rename_py&gt; python test.py</span><br><span class="line">Renamed &#x27;0.设置py环境.md&#x27; to &#x27;01.设置py环境.md&#x27;</span><br><span class="line">Renamed &#x27;1.git自动上传脚本.md&#x27; to &#x27;02.git自动上传脚本.md&#x27;</span><br><span class="line">Renamed &#x27;3.request的ssl报错.md&#x27; to &#x27;03.request的ssl报错.md&#x27;</span><br><span class="line">Renamed &#x27;4.request session的cookie如何导入到aiohttp.md&#x27; to &#x27;04.request session的cookie如何导入到aiohttp.md&#x27;</span><br><span class="line">Renamed &#x27;5.生成requeirments.txt文件.md&#x27; to &#x27;05.生成requeirments.txt文件.md&#x27;</span><br><span class="line">Renamed &#x27;7.ValueError Sample larger than population or is negative.md&#x27; to &#x27;06.ValueError Sample larger than population or is negative.md&#x27;</span><br><span class="line">Renamed &#x27;8.python自动化下载md文件中图片.md&#x27; to &#x27;07.python自动化下载md文件中图片.md&#x27;</span><br><span class="line">Renamed &#x27;10.ssl报错证书错误的解决方法.md&#x27; to &#x27;08.ssl报错证书错误的解决方法.md&#x27;</span><br><span class="line">Renamed &#x27;11.pip安装使用镜像源.md&#x27; to &#x27;09.pip安装使用镜像源.md&#x27;</span><br><span class="line">Renamed &#x27;12.logging设置时间的时区.md&#x27; to &#x27;10.logging设置时间的时区.md&#x27;</span><br><span class="line">Renamed &#x27;13.Centos安装python3.10.md&#x27; to &#x27;11.Centos安装python3.10.md&#x27;</span><br><span class="line">Renamed &#x27;18.python的异步同步.md&#x27; to &#x27;12.python的异步同步.md&#x27;</span><br><span class="line">Renamed &#x27;20.pycharm设置中文字体.md&#x27; to &#x27;13.pycharm设置中文字体.md&#x27;</span><br><span class="line">Renamed &#x27;21.pymysql链接错误.md&#x27; to &#x27;14.pymysql链接错误.md&#x27;</span><br><span class="line">Renamed &#x27;22.pip安装包时找不到Python.h.md&#x27; to &#x27;15.pip安装包时找不到Python.h.md&#x27;</span><br><span class="line">Renamed &#x27;23.调用飞书api获取excel表格中数据.md&#x27; to &#x27;16.调用飞书api获取excel表格中数据.md&#x27;</span><br><span class="line">Renamed &#x27;24.元组列表集和的区别.md&#x27; to &#x27;17.元组列表集和的区别.md&#x27;</span><br><span class="line">Renamed &#x27;25.API的分类.md&#x27; to &#x27;18.API的分类.md&#x27;</span><br><span class="line">Renamed &#x27;26.python分片计算文件md5.md&#x27; to &#x27;19.python分片计算文件md5.md&#x27;</span><br><span class="line">Renamed &#x27;27.python文件分片加密和上传.md&#x27; to &#x27;20.python文件分片加密和上传.md&#x27;</span><br><span class="line">Renamed &#x27;28.valorant国服和港服文件差距.md&#x27; to &#x27;21.valorant国服和港服文件差距.md&#x27;</span><br><span class="line">Renamed &#x27;6.关于阿狸vip画图bug的复盘.md&#x27; to &#x27;01.关于阿狸vip画图bug的复盘.md&#x27;</span><br><span class="line">Renamed &#x27;9.白嫖replit部署ticket机器人.md&#x27; to &#x27;02.白嫖replit部署ticket机器人.md&#x27;</span><br><span class="line">Renamed &#x27;14.阿狸机器人使用文档.md&#x27; to &#x27;03.阿狸机器人使用文档.md&#x27;</span><br><span class="line">Renamed &#x27;15.如何给kook机器人加上翻译功能.md&#x27; to &#x27;04.如何给kook机器人加上翻译功能.md&#x27;</span><br><span class="line">Renamed &#x27;16.多文件kook机器人.md&#x27; to &#x27;05.多文件kook机器人.md&#x27;</span><br><span class="line">Renamed &#x27;17.kook机器人与爱发电对接.md&#x27; to &#x27;06.kook机器人与爱发电对接.md&#x27;</span><br><span class="line">Renamed &#x27;19.linkguard机器人配置个性化撤回消息.md&#x27; to &#x27;07.linkguard机器人配置个性化撤回消息.md&#x27;</span><br><span class="line">Renamed &#x27;01.关于阿狸vip画图bug的复盘.md&#x27; to &#x27;01.关于阿狸vip画图bug的复盘.md&#x27;</span><br><span class="line">Renamed &#x27;02.白嫖replit部署ticket机器人.md&#x27; to &#x27;02.白嫖replit部署ticket机器人.md&#x27;</span><br><span class="line">Renamed &#x27;03.阿狸机器人使用文档.md&#x27; to &#x27;03.阿狸机器人使用文档.md&#x27;</span><br><span class="line">Renamed &#x27;04.如何给kook机器人加上翻译功能.md&#x27; to &#x27;04.如何给kook机器人加上翻译功能.md&#x27;</span><br><span class="line">Renamed &#x27;05.多文件kook机器人.md&#x27; to &#x27;05.多文件kook机器人.md&#x27;</span><br><span class="line">Renamed &#x27;06.kook机器人与爱发电对接.md&#x27; to &#x27;06.kook机器人与爱发电对接.md&#x27;</span><br><span class="line">Renamed &#x27;07.linkguard机器人配置个性化撤回消息.md&#x27; to &#x27;07.linkguard机器人配置个性化撤回消息.md&#x27;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">使用python脚本按序号重命名md文档</summary>
    
    
    
    <category term="编程学习" scheme="https://blog.musnow.top/categories/%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="Python" scheme="https://blog.musnow.top/categories/%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0/Python/"/>
    
    
    <category term="Python" scheme="https://blog.musnow.top/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>【win】如何在微软官网下载windows10的iso镜像</title>
    <link href="https://blog.musnow.top/posts/2052482894/"/>
    <id>https://blog.musnow.top/posts/2052482894/</id>
    <published>2024-06-19T01:59:54.000Z</published>
    <updated>2024-06-19T12:14:52.000Z</updated>
    
    <content type="html"><![CDATA[<p>如何在微软官网下载windows10的iso镜像？</p><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><blockquote><p>win10官网：<a href="https://www.microsoft.com/zh-cn/software-download/windows10/">https://www.microsoft.com/zh-cn/software-download/windows10/</a></p></blockquote><p>如果你现在打开windows10的官网，会发现压根没有iso镜像的下载选择，这里让你下载的是MediaCreationTool，是用于制作系统安装盘或者直接在当前电脑上安装win10的，用它来下iso可慢的很。</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/06/61ae3e1723b1990be912ba971b646482.png" alt="image.png"></p><h2 id="如何直接下载ISO"><a href="#如何直接下载ISO" class="headerlink" title="如何直接下载ISO"></a>如何直接下载ISO</h2><p>但实际上官网是有iso的下载页面的，只不过在电脑上直接给你藏住了。参考知乎老哥<a href="https://zhuanlan.zhihu.com/p/653156950">pewper</a>的回答，我们需要把电脑的浏览器改成<strong>手机的UA</strong>，然后再访问这个官网，就能看到下载连接了。</p><p>在刚刚的官网页面，按F12打开edge浏览器的开发者选项，然后点击有一个手机和ipad一样图标的选项，这个选项是将浏览器模拟成手机的浏览器。</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/06/f710913be974001cebfb53c7647a352a.png" alt="image.png"></p><p>点了之后，会发现好像没有什么变化，只是官网屏幕变小了，别急，我们刷新一下这个界面</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/06/c18e09d3fe52e0827f78d819d5ac19f8.png" alt="image.png"></p><p>这时候就出现下载ISO的选项了，选择你想下载的版本</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/06/3f5b6e6a68cdc2ba3f0259a21433608a.png" alt="image.png"></p><p>这里我直接选了国内的win10家庭版</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/06/e38dcf1ba0fb529dbac756c3324efbda.png" alt="image.png"></p><p>然后点击确认，下面就会弹出选择语言的选项，选了简体中文（只有这个选项）之后，再点击一次确认。</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/06/e953c0a42bf9fae4d1da4229f11610fa.png" alt="image.png"></p><p>此时就会弹出下32位还是64位iso的页面了，直接下64位的iso就OK了</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/06/b736fa714978eccb436adc6623a1bdc9.png" alt="image.png"></p><h2 id="搞定"><a href="#搞定" class="headerlink" title="搞定"></a>搞定</h2><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/06/e306888c9d32d1cf2e421d78a9e42b47.png" alt="image.png"></p><p>实话实说，不知道微软为什么要藏住明明有的iso下载页面，非引导着用户下MediaCreationTool。</p>]]></content>
    
    
    <summary type="html">如何在微软官网下载windows10的iso镜像</summary>
    
    
    
    <category term="差生文具多" scheme="https://blog.musnow.top/categories/%E5%B7%AE%E7%94%9F%E6%96%87%E5%85%B7%E5%A4%9A/"/>
    
    <category term="电脑使用小贴士" scheme="https://blog.musnow.top/categories/%E5%B7%AE%E7%94%9F%E6%96%87%E5%85%B7%E5%A4%9A/%E7%94%B5%E8%84%91%E4%BD%BF%E7%94%A8%E5%B0%8F%E8%B4%B4%E5%A3%AB/"/>
    
    
    <category term="虚拟机" scheme="https://blog.musnow.top/tags/%E8%99%9A%E6%8B%9F%E6%9C%BA/"/>
    
    <category term="windows" scheme="https://blog.musnow.top/tags/windows/"/>
    
  </entry>
  
  <entry>
    <title>【leetcode】115.不同的子序列</title>
    <link href="https://blog.musnow.top/posts/3193784003/"/>
    <id>https://blog.musnow.top/posts/3193784003/</id>
    <published>2024-06-12T08:48:17.000Z</published>
    <updated>2024-07-07T11:30:31.000Z</updated>
    
    <content type="html"><![CDATA[<p>leetcode刷题笔记-115.不同的子序列</p><h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>给你两个字符串 s 和 t ，统计并返回在 s 的 子序列 中 t 出现的个数，结果需要对 <code>10^9 + 7</code> 取模。</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/06/8d31b52d38ede01b577227b1bf213b64.png" alt="image.png"></p><h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p>先注意审题，本题需要<strong>求s的子序列中t出现的次数</strong>，即t多少次完整的出现在了s的某个子序列中。如果不考虑时间复杂度，其实我们可以用<strong>回溯</strong>把s的所有长度等于t的子序列都列出来，然后再判断是否有和t相同的子序列。</p><p>但很明显，这样写时间复杂度报表了，所以还是用<strong>动态规划</strong>的思路解题。</p><p>第一步是确定dp数组，类似的题目已经写过很多遍了，dp数组的定义都大差不差。</p><ul><li><code>dp[i][j]</code>含义：以i-1为结尾的s子序列中出现以j-1为结尾的t的个数为<code>dp[i][j]</code>。</li></ul><p>然后是确定递推的公式，对于这种子序列匹配的题目，都是分为两种情况</p><ul><li><code>s[i-1] == t[j-1]</code>：此时代表s的子序列可以被扩张，也可以选择不扩张，<code>dp[i][j] = dp[i-1][j-1] + dp[i-1][j]</code>;</li><li><code>s[i-1] != t[j-1]</code>：此时代表s的子序列不能扩张，只能沿用“上一次”的结果，因为是在s的子序列中找t，我们不能从t中删除元素，所以“上一次”的结果只有<code>dp[i-1][j]</code>;</li></ul><p>这里对第一种<code>s[i-1] == t[j-1]</code>二者相同的情况做说明，为什么会出现“可以扩张，也可以不扩张”呢？</p><ul><li><strong>扩张的情况</strong>：二者相等，说明当前可能出现t的子序列数量和<code>dp[i-1][j-1]</code>是一致的，因为<code>s[i-1]</code>和<code>t[j-1]</code>这两个字母不需要考虑（这两个字母是相等的，相当于我们从匹配结果中忽略这两个字符，最终得到的子序列的个数也是一样的）。</li><li><strong>不扩张的情况</strong>：二者相等，我们不一定需要用<code>s[i-1]</code>来扩张子序列。<ul><li>比如s是bagg，t是bag的情况，<code>s[3]==t[2]</code>，如果我们使用<code>s[3]</code>，最终的子序列是<code>s[0][1][3]</code>；如果不使用<code>s[3]</code>，最终的子序列是<code>s[0][1][2]</code>，这两个子序列都等于t，都是可行的结果。此时使用<code>dp[i-1][j]</code>，相当于我们不用<code>s[3]</code>去构造子序列，而是沿用了s字符串中前一位的结果，说不定不用这个<code>s[i-1]</code>，之前的结果中也能和当前的<code>t[j-1]</code>完整匹配出一个子序列呢？</li><li>如果不加上不扩张情况的这个值，相当于漏掉了这种可能性，最终得到的答案肯定是错误的。注意dp的递推一直都是有一个依赖关系的，假设<code>s[0][1][2]</code>这个匹配项不存在，那么<code>dp[i-1][j]</code>会是0，也就不会影响当前的结果。</li></ul></li></ul><p>把这两种情况都考虑上，才是正确的推导公式。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (s[i - <span class="number">1</span>] == t[j - <span class="number">1</span>]) &#123;</span><br><span class="line">dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>] + dp[i - <span class="number">1</span>][j];</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">dp[i][j] = dp[i - <span class="number">1</span>][j];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>根据推导公式，遍历自然是从小到大遍历，且i和j都依赖于<code>i-1/j-1</code>，所以遍历的时候需要从下标1开始遍历。</p><p>我们还需要对下标0的位置进行初始化，分别是i&#x3D;0和j&#x3D;0的情况</p><ul><li>i为0：代表s字符串为空，此时没有任何办法匹配出t字符串，所以i为0的位置需要初始化为0；</li><li>j为0：代表t字符串为空，此时s字符串可以删除所有元素形成一个空的子序列和t进行匹配，即j为0的位置都须初始化为1；</li><li>特殊情况：i和j都为0，此时就是空来匹配空，所以也是初始化为1；</li></ul><p>初始化也搞定了，直接遍历使用递推公式就OK啦！</p><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><p>完整代码如下，注意数组中元素需要使用无符号的64位整型，不然会出现计算溢出的情况。最后返回结果的时候需要按题目的要求进行取模。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">numDistinct</span><span class="params">(string s, string t)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (s.<span class="built_in">size</span>() &lt; t.<span class="built_in">size</span>()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// dp[i][j]：以i-1为结尾的s子序列中出现以j-1为结尾的t的个数为dp[i][j]。</span></span><br><span class="line">        vector&lt;vector&lt;<span class="type">uint64_t</span>&gt;&gt; <span class="built_in">dp</span>(s.<span class="built_in">size</span>() + <span class="number">1</span>,</span><br><span class="line">                                     <span class="built_in">vector</span>&lt;<span class="type">uint64_t</span>&gt;(t.<span class="built_in">size</span>() + <span class="number">1</span>, <span class="number">0</span>));</span><br><span class="line">        <span class="comment">// 初始化，分为j=0还有i=0的情况，我们只需要手动处理j=0的情况；</span></span><br><span class="line">        <span class="comment">// 此时s不管多长都可以删除所有元素构成一个空字符串，所以结果应该是1</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; dp.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            dp[i][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 开始遍历</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; dp.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt; dp[i].<span class="built_in">size</span>(); j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (s[i - <span class="number">1</span>] == t[j - <span class="number">1</span>]) &#123;</span><br><span class="line">                    dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>] + dp[i - <span class="number">1</span>][j];</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    dp[i][j] = dp[i - <span class="number">1</span>][j];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 最终dp数组右下角的就是结果，完整的t和完整的s</span></span><br><span class="line">        <span class="keyword">return</span> dp[s.<span class="built_in">size</span>()][t.<span class="built_in">size</span>()] % <span class="number">1000000007</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/06/bb97eda7703e8a2b73bad2d58f1296e3.png" alt="image.png"></p>]]></content>
    
    
    <summary type="html">leetcode刷题笔记-115.不同的子序列</summary>
    
    
    
    <category term="编程学习" scheme="https://blog.musnow.top/categories/%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="把题目都给刷干净" scheme="https://blog.musnow.top/categories/%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0/%E6%8A%8A%E9%A2%98%E7%9B%AE%E9%83%BD%E7%BB%99%E5%88%B7%E5%B9%B2%E5%87%80/"/>
    
    
    <category term="OJ刷题" scheme="https://blog.musnow.top/tags/OJ%E5%88%B7%E9%A2%98/"/>
    
    <category term="leetcode" scheme="https://blog.musnow.top/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>【leetcode】392.判断子序列</title>
    <link href="https://blog.musnow.top/posts/3529841087/"/>
    <id>https://blog.musnow.top/posts/3529841087/</id>
    <published>2024-06-09T01:44:27.000Z</published>
    <updated>2024-06-10T07:56:57.000Z</updated>
    
    <content type="html"><![CDATA[<p>leetcode刷题笔记-392.判断子序列</p><h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><blockquote><p><a href="https://leetcode.cn/problems/is-subsequence/description/">https://leetcode.cn/problems/is-subsequence/description/</a></p></blockquote><p>给定字符串 s 和 t ，判断 s 是否为 t 的子序列。</p><p>字符串的一个子序列是原始字符串删除一些（也可以不删除）字符而不改变剩余字符相对位置形成的新字符串。（例如，”ace”是”abcde”的一个子序列，而”aec”不是）。</p><p>进阶：</p><p>如果有大量输入的 S，称作 S1, S2, … , Sk 其中 k &gt;&#x3D; 10亿，你需要依次检查它们是否为 T 的子序列。在这种情况下，你会怎样改变代码？</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">示例 1：</span><br><span class="line">输入：s = &quot;abc&quot;, t = &quot;ahbgdc&quot;</span><br><span class="line">输出：true</span><br><span class="line"></span><br><span class="line">示例 2：</span><br><span class="line">输入：s = &quot;axc&quot;, t = &quot;ahbgdc&quot;</span><br><span class="line">输出：false</span><br></pre></td></tr></table></figure><p>提示</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">0 &lt;= s.length &lt;= 100</span><br><span class="line">0 &lt;= t.length &lt;= 10^4</span><br><span class="line">两个字符串都只由小写字符组成。</span><br></pre></td></tr></table></figure><h1 id="思路一：动态规划"><a href="#思路一：动态规划" class="headerlink" title="思路一：动态规划"></a>思路一：动态规划</h1><h2 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h2><p>还是用动态规划的思路，本题其实可以借鉴1143.最长公共子序列的思路，我们需要判断s是否为t的子序列，本质上就是判断s和t是否有公共子序列，且s本身就是s和t的<strong>最长公共子序列</strong>。</p><p>首先是定义dp数组，用一个二维数组来表示：<code>dp[i][j]</code>代表s字符串i-1和t字符串中j-1的公共子序列长度为<code>dp[i][j]</code>。因为是i-1和j-1，所以初始化的时候需要将长度加一。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dp</span>(s.<span class="built_in">size</span>() + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(t.<span class="built_in">size</span>() + <span class="number">1</span>, <span class="number">0</span>));</span><br></pre></td></tr></table></figure><p>最终我们得到的<code>dp[s.size()][t.size()]</code>，就是s和t的公共子序列长度，这个长度应该等于s的长度，否则代表s不是t的子序列。</p><p>然后是定义递推公式，分为两种情况</p><ol><li><code>s[i-1]==t[j-1]</code>，代表子序列可以扩张，即<code>dp[i][j] = dp[i-1][j-1]+1</code>，含义是两个字符串中各上一位的公共子序列长度加一；</li><li><code>s[i-1]!=t[j-1]</code>，代表子序列不能扩张，此时应该沿用“上一次的结果”，注意这里和1143题目就有区别了，我们需要判断s是否为t的子序列，则只能从t中删除元素来匹配s，所以只能是 <code>dp[i][j] = dp[i][j-1]</code>；</li></ol><p>确定了递推公式，根据递推公式可知当前的<code>dp[i][j]</code>依赖于i-1和j-1，所以必须从小到大遍历进行推导。因为我们dp数组的含义使用了i-1和j-1，所以并不需要对dp数组的第0列和第0行进行单独初始化操作，构造函数里面统一初始化为全0就可以了。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>完整代码如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isSubsequence</span><span class="params">(string s, string t)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// s更长肯定不会是t的子序列</span></span><br><span class="line">        <span class="keyword">if</span> (s.<span class="built_in">size</span>() &gt; t.<span class="built_in">size</span>()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// dp[i][j]表示以下标i-1为结尾的字符串s，和以下标j-1为结尾的字符串t，相同子序列的长度为dp[i][j]</span></span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dp</span>(s.<span class="built_in">size</span>() + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(t.<span class="built_in">size</span>() + <span class="number">1</span>, <span class="number">0</span>));</span><br><span class="line">        <span class="comment">// 两种递推的情况</span></span><br><span class="line">        <span class="comment">//  1.当前s和t相等，代表相同子序列长度可以扩张 dp[i][j] = dp[i-1][j-1]+1;</span></span><br><span class="line">        <span class="comment">//  2.当前s和t不相等，相同子序列长度不可扩张，过渡于上一个</span></span><br><span class="line">        <span class="comment">//          如果是普通题目，“上一个”分为两种情况 dp[i-1][j] 和</span></span><br><span class="line">        <span class="comment">//          dp[i][j-1]</span></span><br><span class="line">        <span class="comment">//          但是本题判断s是否为t的子序列，所以我们不能从s中删除元素，只能从t中删除元素</span></span><br><span class="line">        <span class="comment">//          所以只能使用 dp[i][j-1]</span></span><br><span class="line">        <span class="comment">//          代表从t中删除一个元素（删除的其实就是当前元素j-1）</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= s.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= t.<span class="built_in">size</span>(); j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (s[i<span class="number">-1</span>] == t[j<span class="number">-1</span>]) &#123;</span><br><span class="line">                    dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    dp[i][j] = dp[i][j - <span class="number">1</span>];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果t中包含s，那么最终得到的相同子序列长度应该是s.size()</span></span><br><span class="line">        <span class="keyword">return</span> dp[s.<span class="built_in">size</span>()][t.<span class="built_in">size</span>()] == s.<span class="built_in">size</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>空间复杂度和时间复杂度是<code>O(N^2)</code></p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/06/2ea2b927a49e150aa35d6332369980ed.png" alt="image.png"></p><h1 id="思路二：直接遍历"><a href="#思路二：直接遍历" class="headerlink" title="思路二：直接遍历"></a>思路二：直接遍历</h1><p>这道题限制的条件很简单，s是否为t的子序列本质上是s中的每个字符是否能按顺序的在t中出现。</p><p>那么我们只需要从头开始遍历t字符串，匹配上一个s中的字符后，就开始匹配下一个s中的字符，直到t字符串遍历完毕。</p><p>此时如果s字符串中已遍历的部分是s字符串的长度，那么就代表s是t的子序列。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isSubsequence</span><span class="params">(string s, string t)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// s必须长度小于等于t才有可能是t的子序列</span></span><br><span class="line">        <span class="keyword">if</span> (s.<span class="built_in">size</span>() &gt; t.<span class="built_in">size</span>()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 直接遍历t字符串，判断s中的字符是否在t中按顺序出现了</span></span><br><span class="line">        <span class="type">int</span> index = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; c : t) &#123;</span><br><span class="line">            <span class="keyword">if</span> (c == s[index]) &#123;</span><br><span class="line">                index++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果最终index是s的长度，代表s被完整遍历了，即s是t的子序列</span></span><br><span class="line">        <span class="keyword">return</span> index == s.<span class="built_in">size</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>空间复杂度是<code>O(1)</code>，时间复杂度是<code>O(N)</code>。</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/06/945a691e0af70ee4b1fc56e2026a5ee7.png" alt="image.png"></p>]]></content>
    
    
    <summary type="html">leetcode刷题笔记-392.判断子序列</summary>
    
    
    
    <category term="编程学习" scheme="https://blog.musnow.top/categories/%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="把题目都给刷干净" scheme="https://blog.musnow.top/categories/%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0/%E6%8A%8A%E9%A2%98%E7%9B%AE%E9%83%BD%E7%BB%99%E5%88%B7%E5%B9%B2%E5%87%80/"/>
    
    
    <category term="OJ刷题" scheme="https://blog.musnow.top/tags/OJ%E5%88%B7%E9%A2%98/"/>
    
    <category term="leetcode" scheme="https://blog.musnow.top/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>【leetcode】买卖股票的最佳时机（汇总篇）</title>
    <link href="https://blog.musnow.top/posts/3174951422/"/>
    <id>https://blog.musnow.top/posts/3174951422/</id>
    <published>2024-06-07T11:39:46.000Z</published>
    <updated>2024-06-07T11:39:46.000Z</updated>
    
    <content type="html"><![CDATA[<p>leetcode刷题笔记，买卖股票的最佳时机，问题汇总。</p><h1 id="121-买卖股票的最佳时机1"><a href="#121-买卖股票的最佳时机1" class="headerlink" title="121.买卖股票的最佳时机1"></a>121.买卖股票的最佳时机1</h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><blockquote><p><a href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock/description/">https://leetcode.cn/problems/best-time-to-buy-and-sell-stock/description/</a></p></blockquote><p>给定一个数组 prices ，它的第 i 个元素 prices[i] 表示一支给定股票第 i 天的价格。</p><p>你只能选择 某一天 买入这只股票，并选择在 未来的某一个不同的日子 卖出该股票。设计一个算法来计算你所能获取的最大利润。</p><p>返回你可以从这笔交易中获取的最大利润。如果你不能获取任何利润，返回 0 。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">示例 1：</span><br><span class="line">输入：[7,1,5,3,6,4]</span><br><span class="line">输出：5</span><br><span class="line">解释：在第 2 天（股票价格 = 1）的时候买入，在第 5 天（股票价格 = 6）的时候卖出，最大利润 = 6-1 = 5 。</span><br><span class="line">     注意利润不能是 7-1 = 6, 因为卖出价格需要大于买入价格；同时，你不能在买入前卖出股票。</span><br><span class="line">     </span><br><span class="line">示例 2：</span><br><span class="line">输入：prices = [7,6,4,3,1]</span><br><span class="line">输出：0</span><br><span class="line">解释：在这种情况下, 没有交易完成, 所以最大利润为 0。</span><br></pre></td></tr></table></figure><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><h3 id="暴力"><a href="#暴力" class="headerlink" title="暴力"></a>暴力</h3><p>暴力思路就是两层for循环，计算最大的差值，就是得到的最大利润</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxProfit</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> maxProfit = <span class="number">0</span>; <span class="comment">// 最大收益</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; prices.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = i + <span class="number">1</span>; j &lt; prices.<span class="built_in">size</span>(); j++) &#123;</span><br><span class="line">                maxProfit = <span class="built_in">max</span>(maxProfit, prices[j] - prices[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxProfit;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>时间复杂度是<code>O(N^2)</code>，会超时</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/05/234748c82c574033336617a9303c6960.png" alt="image.png"></p><h3 id="贪心"><a href="#贪心" class="headerlink" title="贪心"></a>贪心</h3><p>贪心算法，思路是枚举当前数之前的最小值，计算当前数得到的利润的最大值。</p><ul><li>用一个元素来记录最小值，每一次遍历都更新这个最小值（最小的买入价格）</li><li>用一个元素来记录得到的最大利润，每一次遍历都更新最大利润（当前价格减去最小买入价格）</li></ul><p>首先更新的是最大利润，再更新最小买入价格，这样能保证最小买入价格的值一定是当前元素之前的某一个值，计算出来的最大利润才有效。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxProfit</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> maxProfit = <span class="number">-1</span>;       <span class="comment">// 最大收益</span></span><br><span class="line">        <span class="type">int</span> minPrice = prices[<span class="number">0</span>]; <span class="comment">// 当前的最小价格</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; i : prices) &#123;</span><br><span class="line">            <span class="comment">// 当前值减去最小价格得到最大收益</span></span><br><span class="line">            maxProfit = <span class="built_in">max</span>(maxProfit, i - minPrice);</span><br><span class="line">            <span class="comment">// 需要更新最小价格，保证最小价格是在当前值之前的某一个数</span></span><br><span class="line">            minPrice = <span class="built_in">min</span>(minPrice, i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxProfit;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/05/cbde462eff228fcd0de5c1d883b59048.png" alt="image.png"></p><h3 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h3><p>动态规划就要记住解题的几个步骤。</p><ul><li>确定动归数组每个下标的含义</li><li>确定迭代方程</li><li>确定初始值</li><li>确定遍历顺序</li><li>举例推导</li></ul><p>对于这道题而言，每天都有两种状态：今天持有股票和今天卖出股票。</p><p>我们可以设定<code>dp[i][0]</code>是第i天持有股票时的得到的最多钱，<code>dp[i][1]</code>是第i天不持有股票时得到的最多钱。很容易发现每天不持有股票得到的钱是更多的，所以最终的答案就是<code>dp[prices.size()-1][1]</code>，即这个二维数组的右下角。</p><p>这里就需要两个递推公式了，先看第i天持有股票的钱</p><ul><li>上一天就持有股票，即保持<code>dp[i-1][0]</code>不变；</li><li>今天才持有股票（买入），即<code>-price[i]</code>，本题股票只能买入一次，所以选择今天买入，那么剩下的钱就是0减去股票的价格；</li></ul><p>可得 <code>dp[i][0] = max(dp[i-1][0],-price[i])</code>，上两种情况的最大值。</p><p>第i天不持有股票的钱也分为两种情况</p><ul><li>上一天就没有持有股票，即保持<code>dp[i-1][1]</code>不变；</li><li>今天才卖出股票，即保持<code>price[i]+dp[i-1][0]</code>（因为今天卖出，所以上一天肯定是持有股票的）</li></ul><p>可得递推公式 <code>dp[i][1] = max(dp[i-1][1],price[i]+dp[i-1][0])</code>；</p><p>初始化dp数组时，第0天肯定只能持有股票，不能卖出，所以初始化如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span>-price[<span class="number">0</span>];</span><br><span class="line">dp[<span class="number">0</span>][<span class="number">1</span>] = <span class="number">0</span>;</span><br></pre></td></tr></table></figure><p>这里还有另外一个优化方向，从递推公式中可以看出，每一天的值只和上一天有关系，那么并不需要一个完整的二维数组，只需要一个<code>2*2</code>的数组就可以了，我们把今天的值写入上一天就OK了，这样可以把空间复杂度降为<code>O(1)</code>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxProfit</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dp</span>(<span class="number">2</span>, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(<span class="number">2</span>, <span class="number">0</span>));</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span>-prices[<span class="number">0</span>];</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; prices.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            dp[<span class="number">1</span>][<span class="number">0</span>] = <span class="built_in">max</span>(<span class="number">0</span>-prices[i], dp[<span class="number">0</span>][<span class="number">0</span>]);</span><br><span class="line">            dp[<span class="number">1</span>][<span class="number">1</span>] = <span class="built_in">max</span>(prices[i] + dp[<span class="number">0</span>][<span class="number">0</span>], dp[<span class="number">0</span>][<span class="number">1</span>]);</span><br><span class="line">            <span class="comment">// 把当前值挪过去，作为上一行的结果</span></span><br><span class="line">            dp[<span class="number">0</span>][<span class="number">0</span>] = dp[<span class="number">1</span>][<span class="number">0</span>];</span><br><span class="line">            dp[<span class="number">0</span>][<span class="number">1</span>] = dp[<span class="number">1</span>][<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">1</span>][<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/05/d7cce93225d5d8f2ea36a3a2379fce97.png" alt="image.png"></p><p>不过个人感觉这道题用动态规划来写实在是想不出来思路，而且还感觉很麻烦，还不如用贪心来处理一下。</p><h1 id="122-买卖股票的最佳时机2"><a href="#122-买卖股票的最佳时机2" class="headerlink" title="122.买卖股票的最佳时机2"></a>122.买卖股票的最佳时机2</h1><h2 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h2><blockquote><p><a href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-ii">https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-ii</a></p></blockquote><p>给你一个整数数组 prices ，其中 prices[i] 表示某支股票第 i 天的价格。</p><p>在每一天，你可以决定是否购买和&#x2F;或出售股票。你在任何时候 最多 只能持有 一股 股票。你也可以先购买，然后在 同一天 出售。</p><p>返回 你能获得的 最大 利润 。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">示例 1：</span><br><span class="line">输入：prices = [7,1,5,3,6,4]</span><br><span class="line">输出：7</span><br><span class="line">解释：在第 2 天（股票价格 = 1）的时候买入，在第 3 天（股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5 - 1 = 4 。</span><br><span class="line">     随后，在第 4 天（股票价格 = 3）的时候买入，在第 5 天（股票价格 = 6）的时候卖出, 这笔交易所能获得利润 = 6 - 3 = 3 。</span><br><span class="line">     总利润为 4 + 3 = 7 。</span><br><span class="line">     </span><br><span class="line">示例 2：</span><br><span class="line">输入：prices = [1,2,3,4,5]</span><br><span class="line">输出：4</span><br><span class="line">解释：在第 1 天（股票价格 = 1）的时候买入，在第 5 天 （股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5 - 1 = 4 。</span><br><span class="line">     总利润为 4 。</span><br><span class="line">     </span><br><span class="line">示例 3：</span><br><span class="line">输入：prices = [7,6,4,3,1]</span><br><span class="line">输出：0</span><br><span class="line">解释：在这种情况下, 交易无法获得正利润，所以不参与交易可以获得最大利润，最大利润为 0 。</span><br></pre></td></tr></table></figure><p>提示</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1 &lt;= prices.length &lt;= 3 * 104</span><br><span class="line">0 &lt;= prices[i] &lt;= 104</span><br></pre></td></tr></table></figure><h2 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h2><h3 id="动态规划-1"><a href="#动态规划-1" class="headerlink" title="动态规划"></a>动态规划</h3><p>122题和121在<strong>动态规划</strong>上唯一的区别就是当天买入股票的时候，需要计算上一天卖出股票后能剩下的最多钱（因为同一天只能持有一张股票）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-ii</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxProfit</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dp</span>(<span class="number">2</span>, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(<span class="number">2</span>, <span class="number">0</span>));</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = -prices[<span class="number">0</span>];</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; prices.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="comment">// 1.今天买入股票的剩余钱需要计算上一天卖出后剩下的最多钱</span></span><br><span class="line">            <span class="comment">// 2.今天不买入，沿用上一天的结果</span></span><br><span class="line">            dp[<span class="number">1</span>][<span class="number">0</span>] = <span class="built_in">max</span>(dp[<span class="number">0</span>][<span class="number">1</span>] - prices[i], dp[<span class="number">0</span>][<span class="number">0</span>]);</span><br><span class="line">            <span class="comment">// 1.今天卖出股票，得到的钱是上一天买入股票剩余价值+今天卖出的价格</span></span><br><span class="line">            <span class="comment">// 2.今天不卖出股票，沿用上一天的结果</span></span><br><span class="line">            dp[<span class="number">1</span>][<span class="number">1</span>] = <span class="built_in">max</span>(prices[i] + dp[<span class="number">0</span>][<span class="number">0</span>], dp[<span class="number">0</span>][<span class="number">1</span>]);</span><br><span class="line">            <span class="comment">// 把当前值挪过去，作为上一行的结果</span></span><br><span class="line">            dp[<span class="number">0</span>][<span class="number">0</span>] = dp[<span class="number">1</span>][<span class="number">0</span>];</span><br><span class="line">            dp[<span class="number">0</span>][<span class="number">1</span>] = dp[<span class="number">1</span>][<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">1</span>][<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="贪心-1"><a href="#贪心-1" class="headerlink" title="贪心"></a>贪心</h3><p>122题在121的基础上新增了一个可以多次卖出+买入的操作。而121题只能买入一次+未来卖出一次。</p><p>因为每一天都可以买入+卖出，所以我们可以把利润拆分成每一天。只要某一天买入+明天卖出的利润是正数，那么就把他加入到最终结果中。这样就相当于排除亏钱的情况，只要能赚钱就买，即可计算出最大利润。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 122. 买卖股票的最佳时机 II</span></span><br><span class="line"><span class="comment">// https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-ii/</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxProfit</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 第0天买，第3天卖的利润是prices[3]-prices[0]</span></span><br><span class="line">        <span class="comment">// 也等于 p[3]-p[2] + p[2]-p[1] + p[1]-p[0]</span></span><br><span class="line">        <span class="comment">// 所以最大利润其实就是每天利润之和（前提是利润都是正的）</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; prices.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="comment">// 计算昨天买今天卖能获得多少利润</span></span><br><span class="line">            <span class="comment">// 如果大于0就加入进去</span></span><br><span class="line">            count += <span class="built_in">max</span>(prices[i] - prices[i - <span class="number">1</span>], <span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="123-买卖股票的最佳时机3"><a href="#123-买卖股票的最佳时机3" class="headerlink" title="123.买卖股票的最佳时机3"></a>123.买卖股票的最佳时机3</h1><h2 id="题目-2"><a href="#题目-2" class="headerlink" title="题目"></a>题目</h2><blockquote><p><a href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-iii/description/">https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-iii/description/</a></p></blockquote><p>给定一个数组，它的第 i 个元素是一支给定的股票在第 i 天的价格。</p><p>设计一个算法来计算你所能获取的最大利润。你最多可以完成 两笔 交易。</p><p>注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">示例 1:</span><br><span class="line">输入：prices = [3,3,5,0,0,3,1,4]</span><br><span class="line">输出：6</span><br><span class="line">解释：在第 4 天（股票价格 = 0）的时候买入，在第 6 天（股票价格 = 3）的时候卖出，这笔交易所能获得利润 = 3-0 = 3 。</span><br><span class="line">     随后，在第 7 天（股票价格 = 1）的时候买入，在第 8 天 （股票价格 = 4）的时候卖出，这笔交易所能获得利润 = 4-1 = 3 。</span><br><span class="line">     </span><br><span class="line">示例 2：</span><br><span class="line">输入：prices = [1,2,3,4,5]</span><br><span class="line">输出：4</span><br><span class="line">解释：在第 1 天（股票价格 = 1）的时候买入，在第 5 天 （股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。   </span><br><span class="line">     注意你不能在第 1 天和第 2 天接连购买股票，之后再将它们卖出。   </span><br><span class="line">     因为这样属于同时参与了多笔交易，你必须在再次购买前出售掉之前的股票。</span><br><span class="line">     </span><br><span class="line">示例 3：</span><br><span class="line">输入：prices = [7,6,4,3,1] </span><br><span class="line">输出：0 </span><br><span class="line">解释：在这个情况下, 没有交易完成, 所以最大利润为 0。</span><br><span class="line"></span><br><span class="line">示例 4：</span><br><span class="line">输入：prices = [1]</span><br><span class="line">输出：0</span><br></pre></td></tr></table></figure><p>提示</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1 &lt;= prices.length &lt;= 105</span><br><span class="line">0 &lt;= prices[i] &lt;= 105</span><br></pre></td></tr></table></figure><h2 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h2><p>主要是需要列出可以购入两次一共会有多少种状态：</p><ol><li>当天不做操作；</li><li>当天继续持有股票（可以是新买股票，也可能是昨天就买入股票了）；</li><li>当天不继续持有股票；</li><li>当天第二次持有股票；</li><li>当天不持有第二次的股票；</li></ol><p>这五个状态已经包含了所有的情况，使用一个<code>dp[prices.size()][5]</code>的二维数组分别存放这五种情况的剩余钱的数量，我们要做的就是列出每一种状态的转移方程就可以了。</p><p>对于当天不做操作而言，啥事都不用干，所以<code>dp[i][0] = dp[i-1][0]</code>。</p><p>对于当天第一次持有股票，分为两种情况：</p><ul><li>这个股票是昨天留下来的（昨天就买了），对应的是<code>dp[i-1][1]</code>；</li><li>这个股票是今天刚买的，对应的是<code>dp[i-1][0] - prices[i]</code>，含义是昨天啥事没干的剩余余额减去当天股票的价格（买入）；</li></ul><p>因为我们最终需要的是最多能赚的钱，所以要用max来取二者最大值。</p><p>对于当天第一次不持有股票，也分为两种情况：</p><ul><li>昨天就不持有了，对应的是<code>dp[i-1][2]</code>；</li><li>昨天持有，今天卖出，对应的是<code>dp[i-1][0] + prices[i]</code>，含义是昨天买入股票的剩余余额加上当前股票的价格（今天卖出）；</li></ul><p>同样是用max来取二者的最大值。</p><p>对于第二次持有和不持有，都是用同样的方式分析的，得到的递推公式如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 今天第二次购入股票（可能是本来就持有了第二次的股票，也可能是今天再买一次股票）</span></span><br><span class="line"><span class="comment">// 今天再买一次依赖于昨天卖出过了，所以是dp[i - 1][2]</span></span><br><span class="line">dp[i][<span class="number">3</span>] = <span class="built_in">max</span>(dp[i - <span class="number">1</span>][<span class="number">3</span>], dp[i - <span class="number">1</span>][<span class="number">2</span>] - prices[i]);</span><br><span class="line"><span class="comment">// 今天不持有第二次的股票（可能是本来就不持有，也可能是把第二次购买的股票在今天卖掉）</span></span><br><span class="line"><span class="comment">// 1.这里使用dp[i-1][4]其实也可以理解为是当前买入后又卖出了（余额没有变化）</span></span><br><span class="line"><span class="comment">// 2.今天卖出依赖于昨天买入过第二次，所以是dp[i - 1][3]</span></span><br><span class="line">dp[i][<span class="number">4</span>] = <span class="built_in">max</span>(dp[i - <span class="number">1</span>][<span class="number">4</span>], dp[i - <span class="number">1</span>][<span class="number">3</span>] + prices[i]);</span><br></pre></td></tr></table></figure><p>有了状态转移方程，可以看到每一次都是依赖于<code>dp[i-1]</code>的情况，所以我们需要先对<code>dp[0]</code>进行初始化，再从下标1开始遍历整个数组。</p><p>对于第0天而言，我们只有两种选择，即当天买入一次股票，和当天买入第二次股票（我们买了第一次，卖掉，再买入第二次）</p><p>分别对应的是下面两个值，需要初始化为第0天股票的价格。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">dp[<span class="number">0</span>][<span class="number">1</span>] = <span class="number">0</span> - prices[<span class="number">0</span>]; <span class="comment">// 当天第一次买入</span></span><br><span class="line">dp[<span class="number">0</span>][<span class="number">3</span>] = <span class="number">0</span> - prices[<span class="number">0</span>]; <span class="comment">// 当天第二次买入</span></span><br></pre></td></tr></table></figure><p>因为第0天我们手头上是没钱的，所以买了股票之后余额就是负数了。</p><p>最终返回的最大值是最后一天第二次卖出的余额。因为只有第二次卖出，才</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>以下是完整的代码</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxProfit</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (prices.<span class="built_in">size</span>() == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dp</span>(prices.<span class="built_in">size</span>(), <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(<span class="number">5</span>, <span class="number">0</span>));</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">1</span>] = <span class="number">0</span> - prices[<span class="number">0</span>]; <span class="comment">// 当天第一次买入</span></span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">3</span>] = <span class="number">0</span> - prices[<span class="number">0</span>]; <span class="comment">// 当天第二次买入</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; prices.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="comment">// 今天啥事不干</span></span><br><span class="line">            dp[i][<span class="number">0</span>] = dp[i - <span class="number">1</span>][<span class="number">0</span>];</span><br><span class="line">            <span class="comment">// 今天继续持有股票（可能是新买入，也可能是沿用之前啥事不干+买入股票的状态）</span></span><br><span class="line">            dp[i][<span class="number">1</span>] = <span class="built_in">max</span>(dp[i - <span class="number">1</span>][<span class="number">1</span>], dp[i - <span class="number">1</span>][<span class="number">0</span>] - prices[i]);</span><br><span class="line">            <span class="comment">// 今天不持有股票（可能是本来就没有持有，也可以能是卖出了昨天买的股票）</span></span><br><span class="line">            <span class="comment">// 今天不持有前提是昨天买入过，所以是dp[i - 1][1]</span></span><br><span class="line">            dp[i][<span class="number">2</span>] = <span class="built_in">max</span>(dp[i - <span class="number">1</span>][<span class="number">2</span>], dp[i - <span class="number">1</span>][<span class="number">1</span>] + prices[i]);</span><br><span class="line">            <span class="comment">// 今天第二次购入股票（可能是本来就持有了第二次的股票，也可能是今天再买一次股票）</span></span><br><span class="line">            <span class="comment">// 今天再买一次依赖于昨天卖出过了，所以是dp[i - 1][2]</span></span><br><span class="line">            dp[i][<span class="number">3</span>] = <span class="built_in">max</span>(dp[i - <span class="number">1</span>][<span class="number">3</span>], dp[i - <span class="number">1</span>][<span class="number">2</span>] - prices[i]);</span><br><span class="line">            <span class="comment">// 今天不持有第二次的股票（可能是本来就不持有，也可能是把第二次购买的股票在今天卖掉）</span></span><br><span class="line">            <span class="comment">// 1.这里使用dp[i-1][4]其实也可以理解为是当前买入后又卖出了（余额没有变化）</span></span><br><span class="line">            <span class="comment">// 2.今天卖出依赖于昨天买入过第二次，所以是dp[i - 1][3]</span></span><br><span class="line">            dp[i][<span class="number">4</span>] = <span class="built_in">max</span>(dp[i - <span class="number">1</span>][<span class="number">4</span>], dp[i - <span class="number">1</span>][<span class="number">3</span>] + prices[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 最终得到的获利值，一定是最后一天的第二次不持有是最多的</span></span><br><span class="line">        <span class="comment">// 因为买卖两次赚的钱肯定会比买卖一次多（亏钱还买啊？）</span></span><br><span class="line">        <span class="keyword">return</span> dp[prices.<span class="built_in">size</span>() - <span class="number">1</span>][<span class="number">4</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>时间复杂度是<code>O(N)</code>，空间复杂度是<code>O(N)</code>。注意空间复杂度是<code>O(5*N)</code>，我们二维数组的每一行长度是固定的，所以空间复杂度并不是<code>N^2</code>！</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/06/3202d8583ed32312ca76e94123c1e3ca.png" alt="image.png"></p><h2 id="空间复杂度优化"><a href="#空间复杂度优化" class="headerlink" title="空间复杂度优化"></a>空间复杂度优化</h2><p>因为每一次遍历其实只和<code>i-1</code>有关系，其实我们可以把这个二维数组给压缩成<code>dp[2][5]</code>，只不过每次操作之后都须需要把当前的结果<code>dp[1]</code>给复制到<code>dp[0]</code>去作为下一次的操作依赖。</p><p>这样做能将空间复杂度降到<code>O(1)</code>，因为我们的数组长度是固定值。代码如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxProfit</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (prices.<span class="built_in">size</span>() == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dp</span>(<span class="number">2</span>, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(<span class="number">5</span>, <span class="number">0</span>));</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">1</span>] = <span class="number">0</span> - prices[<span class="number">0</span>]; <span class="comment">// 当天第一次买入</span></span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">3</span>] = <span class="number">0</span> - prices[<span class="number">0</span>]; <span class="comment">// 当天第二次买入</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; prices.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="comment">// 今天啥事不干</span></span><br><span class="line">            dp[<span class="number">1</span>][<span class="number">0</span>] = dp[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">            <span class="comment">// 今天继续持有股票（可能是新买入，也可能是沿用之前啥事不干+买入股票的状态）</span></span><br><span class="line">            dp[<span class="number">1</span>][<span class="number">1</span>] = <span class="built_in">max</span>(dp[<span class="number">0</span>][<span class="number">1</span>], dp[<span class="number">0</span>][<span class="number">0</span>] - prices[i]);</span><br><span class="line">            <span class="comment">// 今天不持有股票（可能是本来就没有持有，也可以能是卖出了昨天买的股票）</span></span><br><span class="line">            <span class="comment">// 今天不持有前提是昨天买入过，所以是dp[0][1]</span></span><br><span class="line">            dp[<span class="number">1</span>][<span class="number">2</span>] = <span class="built_in">max</span>(dp[<span class="number">0</span>][<span class="number">2</span>], dp[<span class="number">0</span>][<span class="number">1</span>] + prices[i]);</span><br><span class="line">            <span class="comment">// 今天第二次购入股票（可能是本来就持有了第二次的股票，也可能是今天再买一次股票）</span></span><br><span class="line">            <span class="comment">// 今天再买一次依赖于昨天卖出过了，所以是dp[0][2]</span></span><br><span class="line">            dp[<span class="number">1</span>][<span class="number">3</span>] = <span class="built_in">max</span>(dp[<span class="number">0</span>][<span class="number">3</span>], dp[<span class="number">0</span>][<span class="number">2</span>] - prices[i]);</span><br><span class="line">            <span class="comment">// 今天不持有第二次的股票（可能是本来就不持有，也可能是把第二次购买的股票在今天卖掉）</span></span><br><span class="line">            <span class="comment">// 1.这里使用dp[i-1][4]其实也可以理解为是当前买入后又卖出了（余额没有变化）</span></span><br><span class="line">            <span class="comment">// 2.今天卖出依赖于昨天买入过第二次，所以是dp[0][3]</span></span><br><span class="line">            dp[<span class="number">1</span>][<span class="number">4</span>] = <span class="built_in">max</span>(dp[<span class="number">0</span>][<span class="number">4</span>], dp[<span class="number">0</span>][<span class="number">3</span>] + prices[i]);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 将今天的情况赋值给昨天，留给下一次循环用</span></span><br><span class="line">            dp[<span class="number">0</span>][<span class="number">0</span>] = dp[<span class="number">1</span>][<span class="number">0</span>];</span><br><span class="line">            dp[<span class="number">0</span>][<span class="number">1</span>] = dp[<span class="number">1</span>][<span class="number">1</span>];</span><br><span class="line">            dp[<span class="number">0</span>][<span class="number">2</span>] = dp[<span class="number">1</span>][<span class="number">2</span>];</span><br><span class="line">            dp[<span class="number">0</span>][<span class="number">3</span>] = dp[<span class="number">1</span>][<span class="number">3</span>];</span><br><span class="line">            dp[<span class="number">0</span>][<span class="number">4</span>] = dp[<span class="number">1</span>][<span class="number">4</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 最终得到的获利值，一定是最后一天的第二次不持有是最多的</span></span><br><span class="line">        <span class="comment">// 因为买卖两次赚的钱肯定会比买卖一次多（亏钱还买啊？）</span></span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">1</span>][<span class="number">4</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/06/55b06e5ee9ea90e3cfc967a28ecf73d6.png" alt="image.png"></p><p>leetcode官方题解给的是一个将二维数组压成一维的空间压缩方式，但是那个方式非常不好理解，我个人感觉学会第一种思路就够了。</p><h1 id="188-买卖股票的最佳时机4"><a href="#188-买卖股票的最佳时机4" class="headerlink" title="188.买卖股票的最佳时机4"></a>188.买卖股票的最佳时机4</h1><h2 id="题目-3"><a href="#题目-3" class="headerlink" title="题目"></a>题目</h2><blockquote><p><a href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-iv/description/">https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-iv/description/</a></p></blockquote><p>给你一个整数数组 prices 和一个整数 k ，其中 prices[i] 是某支给定的股票在第 i 天的价格。</p><p>设计一个算法来计算你所能获取的最大利润。你最多可以完成 k 笔交易。也就是说，你最多可以买 k 次，卖 k 次。</p><p>注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">示例 1：</span><br><span class="line">输入：k = 2, prices = [2,4,1]</span><br><span class="line">输出：2</span><br><span class="line">解释：在第 1 天 (股票价格 = 2) 的时候买入，在第 2 天 (股票价格 = 4) 的时候卖出，这笔交易所能获得利润 = 4-2 = 2 。</span><br><span class="line"></span><br><span class="line">示例 2：</span><br><span class="line">输入：k = 2, prices = [3,2,6,5,0,3]</span><br><span class="line">输出：7</span><br><span class="line">解释：在第 2 天 (股票价格 = 2) 的时候买入，在第 3 天 (股票价格 = 6) 的时候卖出, 这笔交易所能获得利润 = 6-2 = 4 。</span><br><span class="line">     随后，在第 5 天 (股票价格 = 0) 的时候买入，在第 6 天 (股票价格 = 3) 的时候卖出, 这笔交易所能获得利润 = 3-0 = 3 。</span><br></pre></td></tr></table></figure><p>提示</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1 &lt;= k &lt;= 100</span><br><span class="line">1 &lt;= prices.length &lt;= 1000</span><br><span class="line">0 &lt;= prices[i] &lt;= 1000</span><br></pre></td></tr></table></figure><h2 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h2><p>这道题其实就是123题目的变体，在123题目中我们是可以交易两次，本题就是将这个2改成了k。所以我们只需要将123题目中的思路改成k个就可以了。</p><p>当k为2的时候，一共有5个情况；当k为3的时候，一共有7种情况，多出来的是第三次持有和第三次不持有；同理，当k为未知数的时候，可得情况总数是<code>2*k+1</code>；</p><ul><li>当i为奇数的时候，代表第<code>i/2+1</code>次持有；</li><li>当i为偶数的时候，代表第<code>i/2</code>次不持有；</li></ul><p>观察123题目的状态转移方程，能很明显的发现每一层其实都依赖于前一种情况，也就是二维数组中的前一列。根据此，只需要上一个内层的循环去遍历情况，就能递推出最终最大的利润值。</p><h2 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h2><p>完整代码如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxProfit</span><span class="params">(<span class="type">int</span> k, vector&lt;<span class="type">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (prices.<span class="built_in">size</span>() == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 当k==2的时候一共有五种状态，状态总数是2k+1</span></span><br><span class="line">        <span class="comment">// 除了第一个状态（下标0）的时候是啥事不干</span></span><br><span class="line">        <span class="comment">// 其余的状态奇数是当前第n次持有，偶数是当前第n次持有</span></span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dp</span>(prices.<span class="built_in">size</span>(), <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(k * <span class="number">2</span> + <span class="number">1</span>, <span class="number">0</span>));</span><br><span class="line">        <span class="comment">// 遍历，将奇数都初始化为当前买入的初始值</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt; dp[<span class="number">0</span>].<span class="built_in">size</span>(); j += <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="comment">// 当前的第n次买入</span></span><br><span class="line">            dp[<span class="number">0</span>][j] = <span class="number">0</span> - prices[<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 开始完整遍历</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; prices.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="comment">// 当天啥事不干</span></span><br><span class="line">            dp[i][<span class="number">0</span>] = dp[i - <span class="number">1</span>][<span class="number">0</span>];</span><br><span class="line">            <span class="comment">// 开始遍历k</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt; dp[i].<span class="built_in">size</span>(); j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (j % <span class="number">2</span> == <span class="number">1</span>) &#123;</span><br><span class="line">                    <span class="comment">// 奇数，买入</span></span><br><span class="line">                    dp[i][j] = <span class="built_in">max</span>(dp[i - <span class="number">1</span>][j], dp[i - <span class="number">1</span>][j - <span class="number">1</span>] - prices[i]);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// 偶数，卖出</span></span><br><span class="line">                    dp[i][j] = <span class="built_in">max</span>(dp[i - <span class="number">1</span>][j], dp[i - <span class="number">1</span>][j - <span class="number">1</span>] + prices[i]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 最后一个肯定是最大钱的时候</span></span><br><span class="line">        <span class="keyword">return</span> dp[prices.<span class="built_in">size</span>() - <span class="number">1</span>][<span class="number">2</span> * k];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/06/492f26bea3eddc063ec05d7b6219b294.png" alt="image.png"></p><h1 id="309-买卖股票的最佳时机含冷冻期"><a href="#309-买卖股票的最佳时机含冷冻期" class="headerlink" title="309.买卖股票的最佳时机含冷冻期"></a>309.买卖股票的最佳时机含冷冻期</h1><h2 id="题目-4"><a href="#题目-4" class="headerlink" title="题目"></a>题目</h2><blockquote><p><a href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-with-cooldown/description/">https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-with-cooldown/description/</a></p></blockquote><p>给定一个整数数组prices，其中第  prices[i] 表示第 i 天的股票价格 。​</p><p>设计一个算法计算出最大利润。在满足以下约束条件下，你可以尽可能地完成更多的交易（多次买卖一支股票）:</p><p>卖出股票后，你无法在第二天买入股票 (即冷冻期为 1 天)。</p><p>注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">示例 1:</span><br><span class="line">输入: prices = [1,2,3,0,2]</span><br><span class="line">输出: 3 </span><br><span class="line">解释: 对应的交易状态为: [买入, 卖出, 冷冻期, 买入, 卖出]</span><br><span class="line"></span><br><span class="line">示例 2:</span><br><span class="line">输入: prices = [1]</span><br><span class="line">输出: 0</span><br></pre></td></tr></table></figure><p>提示</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1 &lt;= prices.length &lt;= 5000</span><br><span class="line">0 &lt;= prices[i] &lt;= 1000</span><br></pre></td></tr></table></figure><h2 id="思路-4"><a href="#思路-4" class="headerlink" title="思路"></a>思路</h2><p>这道题还是需要把所有状态给列出来，然后再列出每个状态对应的相关状态。</p><p>首先要明确冷冻期的概念：卖出股票的第二天不能买入股票。但没有说买入股票的第二天不能卖出。即冷冻期只对卖出股票有效。</p><p>那么每一天的状态就会有四种情况，同样是用二维dp数组来对应每一种情况：</p><ol start="0"><li>今天持有股票（今天买入或者保持持有状态）；</li><li>今天不持有股票（今天卖出股票）；</li><li>今天不持有股票（昨天甚至前天就已经卖了）；</li><li>今天是冷冻期，啥事干不了；</li></ol><p>这里相比188题目省略了“当天啥事不干”的状态，因为这个状态没有必要记录，一直都是0。</p><p>下面要做的就是分析出这四种状态的转移方程。</p><p>今天持有股票的情况，分为<strong>今天买入</strong>和<strong>保持持有</strong>的状态，转移方程如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 今天持有股票，要么是昨天就买了，要么是今天才买</span></span><br><span class="line"><span class="comment">// 昨天就已经持有的情况是沿用过去的状态dp[i-1][0]</span></span><br><span class="line"><span class="comment">// 今天才买的情况一是昨天保持卖出股票的情况</span></span><br><span class="line"><span class="comment">// 还有一种情况是昨天是冷冻期，那么我们今天买股票要用的是冷冻期状态的钱</span></span><br><span class="line">dp[i][<span class="number">0</span>] = <span class="built_in">max</span>(dp[i<span class="number">-1</span>][<span class="number">0</span>],</span><br><span class="line"><span class="built_in">max</span>(dp[i<span class="number">-1</span>][<span class="number">2</span>]-prices[i],dp[i<span class="number">-1</span>][<span class="number">3</span>] - prices[i]));</span><br></pre></td></tr></table></figure><p>今天卖出股票的情况，只有一种，那就是昨天持有+今天卖出股票的价格</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dp[i][<span class="number">1</span>] = dp[i<span class="number">-1</span>][<span class="number">0</span>] + prices[i];</span><br></pre></td></tr></table></figure><p>昨天甚至前几天就不持有股票了，就有很多种情况；比如昨天是冷冻期，或前天就卖出了。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 昨天是冷冻期</span></span><br><span class="line"><span class="comment">// 前天就卖出了，还没有买入，维持不持有的状态</span></span><br><span class="line">dp[i][<span class="number">2</span>] = <span class="built_in">max</span>(dp[i<span class="number">-1</span>][<span class="number">3</span>],dp[i<span class="number">-1</span>][<span class="number">2</span>]);</span><br></pre></td></tr></table></figure><p>今天是冷冻期，说明昨天肯定是卖出股票了，不会有其他情况</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dp[i][<span class="number">3</span>] = dp[i<span class="number">-1</span>][<span class="number">1</span>]</span><br></pre></td></tr></table></figure><p>状态转移方程确定了，下面要处理的就是如何进行初始化了。因为我们状态转移方程是依赖于<code>i-1</code>的，所以肯定是从左往右遍历，且需要提前初始化下标0的数据。</p><p>还是比较好想的，第一天其实只有当前买入的情况，其他买入+卖出，还是冷冻期的情况都是0（第一天不可能是冷冻期），所以只需要初试化<code>dp[i][0] = 0 - prices[0]</code>就可以了。</p><h2 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h2><p>完整代码如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxProfit</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (prices.<span class="built_in">size</span>() == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 一共有4种状态</span></span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dp</span>(prices.<span class="built_in">size</span>(), <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(<span class="number">4</span>, <span class="number">0</span>));</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span> - prices[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; prices.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="comment">// 今天持有股票，要么是昨天就买了，要么是今天才买</span></span><br><span class="line">            <span class="comment">// 昨天就已经持有的情况是沿用过去的状态dp[i-1][0]</span></span><br><span class="line">            <span class="comment">// 今天才买的情况一是昨天保持卖出股票的情况</span></span><br><span class="line">            <span class="comment">// 还有一种情况是昨天是冷冻期，那么我们今天买股票要用的是冷冻期状态的钱</span></span><br><span class="line">            dp[i][<span class="number">0</span>] = <span class="built_in">max</span>(dp[i - <span class="number">1</span>][<span class="number">0</span>], <span class="built_in">max</span>(dp[i - <span class="number">1</span>][<span class="number">2</span>] - prices[i],</span><br><span class="line">                                             dp[i - <span class="number">1</span>][<span class="number">3</span>] - prices[i]));</span><br><span class="line">            <span class="comment">// 今天卖出，代表昨天是持有股票的情况</span></span><br><span class="line">            dp[i][<span class="number">1</span>] = dp[i - <span class="number">1</span>][<span class="number">0</span>] + prices[i];</span><br><span class="line">            <span class="comment">// 昨天是冷冻期</span></span><br><span class="line">            <span class="comment">// 前天就卖出了，还没有买入，维持不持有的状态</span></span><br><span class="line">            dp[i][<span class="number">2</span>] = <span class="built_in">max</span>(dp[i - <span class="number">1</span>][<span class="number">3</span>], dp[i - <span class="number">1</span>][<span class="number">2</span>]);</span><br><span class="line">            <span class="comment">// 冷冻期只可能是昨天卖出股票了</span></span><br><span class="line">            dp[i][<span class="number">3</span>] = dp[i - <span class="number">1</span>][<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 最大值只会出现后三种情况中</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(dp[prices.<span class="built_in">size</span>() - <span class="number">1</span>][<span class="number">1</span>],</span><br><span class="line">                   <span class="built_in">max</span>(dp[prices.<span class="built_in">size</span>() - <span class="number">1</span>][<span class="number">2</span>], dp[prices.<span class="built_in">size</span>() - <span class="number">1</span>][<span class="number">3</span>]));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/06/cdb7253b64e2ff9376d6caf3d26a5b6b.png" alt="image.png"></p><h1 id="714-买卖股票的最佳时机含手续费"><a href="#714-买卖股票的最佳时机含手续费" class="headerlink" title="714.买卖股票的最佳时机含手续费"></a>714.买卖股票的最佳时机含手续费</h1><h2 id="题目-5"><a href="#题目-5" class="headerlink" title="题目"></a>题目</h2><blockquote><p><a href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-with-transaction-fee/description/">https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-with-transaction-fee/description/</a></p></blockquote><p>给定一个整数数组 prices，其中 prices[i]表示第 i 天的股票价格 ；整数 fee 代表了交易股票的手续费用。</p><p>你可以无限次地完成交易，但是你每笔交易都需要付手续费。如果你已经购买了一个股票，在卖出它之前你就不能再继续购买股票了。</p><p>返回获得利润的最大值。</p><p>注意：这里的一笔交易指买入持有并卖出股票的整个过程，每笔交易你只需要为支付一次手续费。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">示例 1：</span><br><span class="line">输入：prices = [1, 3, 2, 8, 4, 9], fee = 2</span><br><span class="line">输出：8</span><br><span class="line">解释：能够达到的最大利润:  </span><br><span class="line">在此处买入 prices[0] = 1</span><br><span class="line">在此处卖出 prices[3] = 8</span><br><span class="line">在此处买入 prices[4] = 4</span><br><span class="line">在此处卖出 prices[5] = 9</span><br><span class="line">总利润: ((8 - 1) - 2) + ((9 - 4) - 2) = 8</span><br><span class="line"></span><br><span class="line">示例 2：</span><br><span class="line">输入：prices = [1,3,7,5,10,3], fee = 3</span><br><span class="line">输出：6</span><br></pre></td></tr></table></figure><p>提示</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1 &lt;= prices.length &lt;= 5 * 104</span><br><span class="line">1 &lt;= prices[i] &lt; 5 * 104</span><br><span class="line">0 &lt;= fee &lt; 5 * 104</span><br></pre></td></tr></table></figure><h2 id="思路和代码"><a href="#思路和代码" class="headerlink" title="思路和代码"></a>思路和代码</h2><p>这道题其实是122的翻版，交易的时候多加一个手续费就行了。一次交易（买入+卖出）只需要交一次手续费，我们统一在卖股票的时候交手续费就ok了。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxProfit</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; prices, <span class="type">int</span> fee)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (prices.<span class="built_in">size</span>() == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dp</span>(<span class="number">2</span>, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(<span class="number">2</span>, <span class="number">0</span>));</span><br><span class="line">        <span class="comment">// 第一天持有</span></span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span> - prices[<span class="number">0</span>];</span><br><span class="line">        <span class="comment">// 开始遍历</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; prices.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="comment">// 1.今天买入</span></span><br><span class="line">            <span class="comment">// 2.昨天开始就持有了</span></span><br><span class="line">            dp[<span class="number">1</span>][<span class="number">0</span>] = <span class="built_in">max</span>(dp[<span class="number">0</span>][<span class="number">0</span>], dp[<span class="number">0</span>][<span class="number">1</span>] - prices[i]);</span><br><span class="line">            <span class="comment">// 1.今天卖出（需要交手续费）</span></span><br><span class="line">            <span class="comment">// 2.昨天开始就不持有了</span></span><br><span class="line">            dp[<span class="number">1</span>][<span class="number">1</span>] = <span class="built_in">max</span>(dp[<span class="number">0</span>][<span class="number">1</span>], dp[<span class="number">0</span>][<span class="number">0</span>] + prices[i] - fee);</span><br><span class="line">            <span class="comment">// 把今天的数值挪过昨天去</span></span><br><span class="line">            dp[<span class="number">0</span>][<span class="number">0</span>] = dp[<span class="number">1</span>][<span class="number">0</span>];</span><br><span class="line">            dp[<span class="number">0</span>][<span class="number">1</span>] = dp[<span class="number">1</span>][<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">1</span>][<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/06/0106306417bd055562a62818aa51d846.png" alt="image.png"></p><h1 id="The-end"><a href="#The-end" class="headerlink" title="The end"></a>The end</h1><p>你学废了吗？</p>]]></content>
    
    
    <summary type="html">leetcode刷题笔记，买卖股票的最佳时机，问题汇总</summary>
    
    
    
    <category term="编程学习" scheme="https://blog.musnow.top/categories/%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="把题目都给刷干净" scheme="https://blog.musnow.top/categories/%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0/%E6%8A%8A%E9%A2%98%E7%9B%AE%E9%83%BD%E7%BB%99%E5%88%B7%E5%B9%B2%E5%87%80/"/>
    
    
    <category term="OJ刷题" scheme="https://blog.musnow.top/tags/OJ%E5%88%B7%E9%A2%98/"/>
    
    <category term="leetcode" scheme="https://blog.musnow.top/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>【leetcode】1035.不相交的线</title>
    <link href="https://blog.musnow.top/posts/842071863/"/>
    <id>https://blog.musnow.top/posts/842071863/</id>
    <published>2024-06-06T09:20:18.000Z</published>
    <updated>2024-06-06T10:14:52.000Z</updated>
    
    <content type="html"><![CDATA[<p>leetcode刷题笔记-1035.不相交的线</p><h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>在两条独立的水平线上按给定的顺序写下 nums1 和 nums2 中的整数。</p><p>现在，可以绘制一些连接两个数字 <code>nums1[i]</code> 和 <code>nums2[j]</code> 的直线，这些直线需要同时满足：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">nums1[i] == nums2[j]</span><br><span class="line">且绘制的直线不与任何其他连线（非水平线）相交。</span><br></pre></td></tr></table></figure><p>请注意，连线即使在端点也不能相交：每个数字只能属于一条连线。</p><p>以这种方法绘制线条，并返回可以绘制的最大连线数。</p><p><strong>示例</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">示例 1：</span><br><span class="line">输入：nums1 = [1,4,2], nums2 = [1,2,4]</span><br><span class="line">输出：2</span><br><span class="line">解释：可以画出两条不交叉的线，如上图所示。 </span><br><span class="line">但无法画出第三条不相交的直线，因为从 nums1[1]=4 到 nums2[2]=4 的直线将与从 nums1[2]=2 到 nums2[1]=2 的直线相交。</span><br><span class="line"></span><br><span class="line">示例 2：</span><br><span class="line">输入：nums1 = [2,5,1,2,5], nums2 = [10,5,2,1,5,2]</span><br><span class="line">输出：3</span><br><span class="line"></span><br><span class="line">示例 3：</span><br><span class="line">输入：nums1 = [1,3,7,1,7,5], nums2 = [1,9,2,5,1]</span><br><span class="line">输出：2</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/06/5ef7bc2f78a834585ebf4fe54086b37f.png" alt="image.png"></p><p><strong>提示</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1 &lt;= nums1.length, nums2.length &lt;= 500</span><br><span class="line">1 &lt;= nums1[i], nums2[j] &lt;= 2000</span><br></pre></td></tr></table></figure><h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p>这道题乍一看好像没有什么好的办法，但是多举几个例子，就能发现它本质上问的是这两个数组的<a href="https://blog.musnow.top/posts/1438517746">最长公共子序列</a>。因为只要我们不修改画线的元素在原始数组中的相对位置，那么画出来的线就不会出现交叉，最长公共子序列就符合这个特性，这也是这道题真正询问的点！</p><p>来复盘一下最长公共子序列的思路吧，最长公共子序列这个题目非常重要，会被其他很多相似的题目引用。最好是能理解并记忆下来。</p><p>首先是dp数组的含义，我们定义了二维dp数组，含义是<code>a[i]</code>和<code>b[j]</code>这两个元素（包括他们自己）之前的最长公共子序列的长度。</p><p>递推的情况则是<code>a[i]</code>和<code>b[j]</code>相等的时候，<code>dp[i][j] = dp[i-1][j-1] + 1</code>；其他情况代表最长公共子序列没有被扩张，则需要采用“前一位”的最大值，分别是i-1（j不变）和j-1（i不变）的两种情况。</p><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><p>完整代码如下，另外的办法可以参考最长公共子序列的题解。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxUncrossedLines</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums1, vector&lt;<span class="type">int</span>&gt;&amp; nums2)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> result = <span class="number">0</span>;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dp</span>(nums1.<span class="built_in">size</span>(), <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(nums2.<span class="built_in">size</span>(), <span class="number">0</span>));</span><br><span class="line">        <span class="comment">// 初始化，第一行和第一列</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums1.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums1[i] == nums2[<span class="number">0</span>]) &#123;</span><br><span class="line">                dp[i][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">                result = <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (i &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                dp[i][<span class="number">0</span>] = dp[i - <span class="number">1</span>][<span class="number">0</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; nums2.<span class="built_in">size</span>(); j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums2[j] == nums1[<span class="number">0</span>]) &#123;</span><br><span class="line">                dp[<span class="number">0</span>][j] = <span class="number">1</span>;</span><br><span class="line">                result = <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (j &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                dp[<span class="number">0</span>][j] = dp[<span class="number">0</span>][j - <span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 开始遍历</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; nums1.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt; nums2.<span class="built_in">size</span>(); j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (nums1[i] == nums2[j]) &#123;</span><br><span class="line">                    dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    dp[i][j] = <span class="built_in">max</span>(dp[i - <span class="number">1</span>][j], dp[i][j - <span class="number">1</span>]);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (dp[i][j] &gt; result) &#123;</span><br><span class="line">                    result = dp[i][j];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/06/1492d042fac783c1128fafe7b24c03ce.png" alt="image.png"></p>]]></content>
    
    
    <summary type="html">leetcode刷题笔记-1035.不相交的线</summary>
    
    
    
    <category term="编程学习" scheme="https://blog.musnow.top/categories/%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="把题目都给刷干净" scheme="https://blog.musnow.top/categories/%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0/%E6%8A%8A%E9%A2%98%E7%9B%AE%E9%83%BD%E7%BB%99%E5%88%B7%E5%B9%B2%E5%87%80/"/>
    
    
    <category term="OJ刷题" scheme="https://blog.musnow.top/tags/OJ%E5%88%B7%E9%A2%98/"/>
    
    <category term="leetcode" scheme="https://blog.musnow.top/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>【leetcode】516.最长回文子序列</title>
    <link href="https://blog.musnow.top/posts/2092587888/"/>
    <id>https://blog.musnow.top/posts/2092587888/</id>
    <published>2024-06-04T02:34:54.000Z</published>
    <updated>2024-06-04T04:00:17.000Z</updated>
    
    <content type="html"><![CDATA[<p>leetcode刷题笔记-516.最长回文子序列</p><h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><blockquote><p><a href="https://leetcode.cn/problems/longest-palindromic-subsequence/">https://leetcode.cn/problems/longest-palindromic-subsequence/</a></p></blockquote><p>给你一个字符串 s ，找出其中最长的回文子序列，并返回该序列的长度。</p><p>子序列定义为：不改变剩余字符顺序的情况下，删除某些字符或者不删除任何字符形成的一个序列。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">示例 1：</span><br><span class="line">输入：s = &quot;bbbab&quot;</span><br><span class="line">输出：4</span><br><span class="line">解释：一个可能的最长回文子序列为 &quot;bbbb&quot; 。</span><br><span class="line"></span><br><span class="line">示例 2：</span><br><span class="line">输入：s = &quot;cbbd&quot;</span><br><span class="line">输出：2</span><br><span class="line">解释：一个可能的最长回文子序列为 &quot;bb&quot; 。</span><br></pre></td></tr></table></figure><p>提示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1 &lt;= s.length &lt;= 1000</span><br><span class="line">s 仅由小写英文字母组成</span><br></pre></td></tr></table></figure><h1 id="思路1：最长公共子序列"><a href="#思路1：最长公共子序列" class="headerlink" title="思路1：最长公共子序列"></a>思路1：最长公共子序列</h1><p>这道题可以直接使用<a href="https://leetcode.cn/problems/longest-common-subsequence/description/">1143.最长公共子序列</a>的代码，只要把原始字符串反转一下，就变成了两个字符串中求最长公共子序列的问题了。</p><p>对于回文子序列来说，<strong>字符串翻转过后也一定和原有的回文子序列相同</strong>，所以将原始字符串翻转后就能通过最长公共子序列找到最长的回文子序列。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">longestCommonSubsequence</span><span class="params">(string a, string b)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> result = <span class="number">0</span>; <span class="comment">// 结果集初始化</span></span><br><span class="line">        <span class="comment">// dp[i][j] 代表a中i和b中j下标和下标之前的最长公共子序列的长度</span></span><br><span class="line">        <span class="comment">// i为0和j为0的情况下，长度为0的字符串是不会有公共子序列的，所以可以全部初始化为0</span></span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dp</span>(a.<span class="built_in">size</span>() + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(b.<span class="built_in">size</span>() + <span class="number">1</span>, <span class="number">0</span>));</span><br><span class="line">        <span class="comment">// 判断 a[i-1] == b[j-1] 代表公共子序列可以扩展</span></span><br><span class="line">        <span class="comment">// dp[i][j] = dp[i-1][j-1] + 1</span></span><br><span class="line">        <span class="comment">// 其他情况，代表公共子序列不能扩展，那么当前的最长公共子序列和前一位的相同</span></span><br><span class="line">        <span class="comment">// 因为是二维数组，所以“前一位”其实有两种情况，分别是i-1和j-1，用max取最大值</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= a.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= b.<span class="built_in">size</span>(); j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (a[i - <span class="number">1</span>] == b[j - <span class="number">1</span>]) &#123;</span><br><span class="line">                    dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    dp[i][j] = <span class="built_in">max</span>(dp[i - <span class="number">1</span>][j], dp[i][j - <span class="number">1</span>]);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (dp[i][j] &gt; result) &#123;</span><br><span class="line">                    result = dp[i][j];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">longestPalindromeSubseq</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        string b = s;</span><br><span class="line">        <span class="built_in">reverse</span>(b.<span class="built_in">begin</span>(), b.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">longestCommonSubsequence</span>(s, b);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>整体的时间复杂度和空间复杂度都是<code>O(N^2)</code>。</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/06/b45b953cefb2b16cca25cc24ef99c8c9.png" alt="image.png"></p><h1 id="思路2：动态规划"><a href="#思路2：动态规划" class="headerlink" title="思路2：动态规划"></a>思路2：动态规划</h1><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>有了用之前写过的题目的思路，下面还是得想一个直接写这道题的思路。总不能回避问题嘛。</p><p>因为回文的结构一般都是要从字符串中心开始向两次扩张来判断的，本题中只有一个字符串，所以不要和之前写的其他题目搞混了。</p><ul><li><code>dp[i][j]</code>代表字符串s中<code>[i,j]</code>范围内的最长回文子序列的长度。</li></ul><p>因为单个字符也可以认为是回文子序列，<strong>所以当i等于j的时候，初始化为1</strong>。对于这个dp数组，我们只需要关注<code>i&lt;j</code>的情况，所以<code>i&gt;j</code>的位置都需要初始化为0。</p><p>这里可以沿用<a href="https://blog.musnow.top/posts/1161861455">5.最长回文子串</a>的思路，当i和j相等，回文子序列扩张的时候，最长的回文子序列的长度只能比<code>[i+1,j-1]</code>的范围多一对字符（即多两个字符）。</p><p>其他情况，因为本题求的是子序列，i和j不相等代表子序列不能被扩展，但dp数组的含义是<code>[i,j]</code>范围内的最长回文子序列的长度，所以当前的值依旧需要更新为“上一个结果”的值，对应本题也是在<code>dp[i+1][j]</code>和<code>dp[i][j-1]</code>中用max选最大值。</p><p>所以，递推代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(s[i] == s[j])&#123;</span><br><span class="line">dp[i][j] = dp[i+<span class="number">1</span>][j<span class="number">-1</span>]+<span class="number">2</span>;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">dp[i][j] = <span class="built_in">max</span>(dp[i+<span class="number">1</span>][j],dp[i][j<span class="number">-1</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>根据这个递推方程，<code>dp[i][j]</code>的依赖项是<code>dp[i+1][j-1]</code>、<code>dp[i+1][j]</code>、<code>dp[i][j-1]</code>，对于一个矩阵而言，是它的左下角的部分，如下图所示。</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/06/aec771ab871e6d1863313ce24aa511c8.png" alt="image.png"></p><p>根据依赖关系，我们遍历的时候，需要从i开始<strong>倒序遍历</strong>；因为依赖项中有<code>j-1</code>，所以j是<strong>正序遍历</strong>。</p><p>遍历顺序确定了，维护一个最大值，或者直接返回<code>dp[0][s.size()-1]</code>即为本题所求结果。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>完整代码如下。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">longestPalindromeSubseq</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = s.<span class="built_in">size</span>();</span><br><span class="line">        <span class="comment">// dp[i][j]代表s中[i,j]范围内最长公共子序列的长度</span></span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dp</span>(n, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(n, <span class="number">0</span>));</span><br><span class="line">        <span class="comment">// i和j相等的情况初始化为1</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            dp[i][i] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 开始递推</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="comment">// j 必须大于i</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = i + <span class="number">1</span>; j &lt; n; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (s[i] == s[j]) &#123;</span><br><span class="line">                    dp[i][j] = dp[i + <span class="number">1</span>][j - <span class="number">1</span>] + <span class="number">2</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    dp[i][j] = <span class="built_in">max</span>(dp[i + <span class="number">1</span>][j], dp[i][j - <span class="number">1</span>]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">0</span>][n - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/06/7f13895038a74d9db8a418a82698f5c0.png" alt="image.png"></p>]]></content>
    
    
    <summary type="html">leetcode刷题笔记-516.最长回文子序列</summary>
    
    
    
    <category term="编程学习" scheme="https://blog.musnow.top/categories/%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="把题目都给刷干净" scheme="https://blog.musnow.top/categories/%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0/%E6%8A%8A%E9%A2%98%E7%9B%AE%E9%83%BD%E7%BB%99%E5%88%B7%E5%B9%B2%E5%87%80/"/>
    
    
    <category term="OJ刷题" scheme="https://blog.musnow.top/tags/OJ%E5%88%B7%E9%A2%98/"/>
    
    <category term="leetcode" scheme="https://blog.musnow.top/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>【leetcode】1143.最长公共子序列</title>
    <link href="https://blog.musnow.top/posts/1438517746/"/>
    <id>https://blog.musnow.top/posts/1438517746/</id>
    <published>2024-06-01T07:46:40.000Z</published>
    <updated>2024-06-06T10:13:18.000Z</updated>
    
    <content type="html"><![CDATA[<p>leetcode刷题笔记-1143.最长公共子序列</p><h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><blockquote><p><a href="https://leetcode.cn/problems/longest-common-subsequence/description/">https://leetcode.cn/problems/longest-common-subsequence/description/</a></p></blockquote><p>给定两个字符串 text1 和 text2，返回这两个字符串的最长 公共子序列 的长度。如果不存在 公共子序列 ，返回 0 。</p><p>一个字符串的 子序列 是指这样一个新的字符串：它是由原字符串在不改变字符的相对顺序的情况下删除某些字符（也可以不删除任何字符）后组成的新字符串。</p><p>例如，”ace” 是 “abcde” 的子序列，但 “aec” 不是 “abcde” 的子序列。</p><p>两个字符串的 公共子序列 是这两个字符串所共同拥有的子序列。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">示例 1：</span><br><span class="line">输入：text1 = &quot;abcde&quot;, text2 = &quot;ace&quot; </span><br><span class="line">输出：3  </span><br><span class="line">解释：最长公共子序列是 &quot;ace&quot; ，它的长度为 3 。</span><br><span class="line"></span><br><span class="line">示例 2：</span><br><span class="line">输入：text1 = &quot;abc&quot;, text2 = &quot;abc&quot;</span><br><span class="line">输出：3</span><br><span class="line">解释：最长公共子序列是 &quot;abc&quot; ，它的长度为 3 。</span><br><span class="line"></span><br><span class="line">示例 3：</span><br><span class="line">输入：text1 = &quot;abc&quot;, text2 = &quot;def&quot;</span><br><span class="line">输出：0</span><br><span class="line">解释：两个字符串没有公共子序列，返回 0 。</span><br></pre></td></tr></table></figure><p>提示</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1 &lt;= text1.length, text2.length &lt;= 1000</span><br><span class="line">text1 和 text2 仅由小写英文字符组成。</span><br></pre></td></tr></table></figure><h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p>这道题和<a href="https://leetcode.cn/problems/maximum-length-of-repeated-subarray/description/">718. 最长重复子数组</a>的区别在于，718要求的是连续的子序列，而本题不要求子序列连续，就不是让你算子数组了。</p><p>虽然题目给出的是字符串，但本质上我们可以把它当作数组来处理，没有区别。</p><ul><li><code>dp[i][j]</code>代表字符串a中<code>i-1</code>和字符串b中<code>j-1</code>下标<strong>之前</strong>的最长公共子序列的长度。</li></ul><p>这样做就可以不对数组提前进行初始化了，因为<code>dp[0][x]</code>和<code>dp[x][0]</code>都是没有意义的。因为不会存在以下标<code>-1</code>为结尾的字符串，也自然没有公共子序列。换句话说，<strong>长度为0</strong>的字符串是不会有公共子序列的。</p><p>依照dp数组，可以想出递推的公式，当<code>a[i-1]</code>和<code>b[j-1]</code>相同的时候，就说明子序列可以被扩展，<code>dp[i][j] == dp[i-1][j-1]+1</code>。</p><p>如果不相同，则代表子序列断了，但注意我们dp数组的含义，它代表的是i-1和j-1之前的最长公共子序列的长度，即便i-1和j-1不相等，这个最长公共子序列依旧是有一个取值的，即选用“前一位”的公共子序列长度最大值。</p><p>但由于dp是一个二维数组，这里的“前一位”就有两个情况了，分别是<code>dp[i-1][j]</code>和<code>dp[i][j-1]</code>，对应含义是字符串a中前一位（根据dp数组，下标是i-1，公共子序列的含义是i-2）和<code>b[j-1]</code>能构成的最长公共子序列，以及字符串b中前一位和<code>a[i-1]</code>能构成的最长公共子序列的长度。<strong>需要用max来选取二者的最大值</strong>。</p><p>递推的代码如下。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (a[i - <span class="number">1</span>] == b[j - <span class="number">1</span>]) &#123;</span><br><span class="line">dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">dp[i][j] = <span class="built_in">max</span>(dp[i - <span class="number">1</span>][j], dp[i][j - <span class="number">1</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>根据递推公式，<code>dp[i][j]</code>的值可以从dp数组中的三个方向推导出来，如下图所示。</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/06/4796284855ff7814090f5f198e5eaedd.png" alt="image.png"></p><p>剩下的代码就很简单了，因为我们不需要对dp数组进行提前初始化，直接用vector构造函数统一初始化为0就可以了，然后从1开始遍历直到字符串末尾，维护一个最大值，返回即可。</p><p>其实不维护最大值也是可以的，因为根据dp数组的定义，<code>dp[a.size()][b.size()]</code>就是我们需要的最大值。</p><h1 id="代码1"><a href="#代码1" class="headerlink" title="代码1"></a>代码1</h1><p>完整的代码如下，具体参考注释中的说明。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">longestCommonSubsequence</span><span class="params">(string a, string b)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> result = <span class="number">0</span>; <span class="comment">// 结果集初始化</span></span><br><span class="line">        <span class="comment">// dp[i][j] 代表a中i和b中j下标和下标之前的最长公共子序列的长度</span></span><br><span class="line">        <span class="comment">// i为0和j为0的情况下，长度为0的字符串是不会有公共子序列的，所以可以全部初始化为0</span></span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dp</span>(a.<span class="built_in">size</span>() + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(b.<span class="built_in">size</span>() + <span class="number">1</span>, <span class="number">0</span>));</span><br><span class="line">        <span class="comment">// 判断 a[i-1] == b[j-1] 代表公共子序列可以扩展</span></span><br><span class="line">        <span class="comment">// dp[i][j] = dp[i-1][j-1] + 1</span></span><br><span class="line">        <span class="comment">// 其他情况，代表公共子序列不能扩展，那么当前的最长公共子序列和前一位的相同</span></span><br><span class="line">        <span class="comment">// 因为是二维数组，所以“前一位”其实有两种情况，分别是i-1和j-1，用max取最大值</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= a.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= b.<span class="built_in">size</span>(); j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (a[i - <span class="number">1</span>] == b[j - <span class="number">1</span>]) &#123;</span><br><span class="line">                    dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    dp[i][j] = <span class="built_in">max</span>(dp[i - <span class="number">1</span>][j], dp[i][j - <span class="number">1</span>]);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (dp[i][j] &gt; result) &#123;</span><br><span class="line">                    result = dp[i][j];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/06/fc86ae51ad0f984572360fc94f373acf.png"></p><h1 id="代码2：提前初始化"><a href="#代码2：提前初始化" class="headerlink" title="代码2：提前初始化"></a>代码2：提前初始化</h1><p>依照718题的思路，我们也可以写出一个提前初始化dp数组的代码，完整代码如下。</p><p>注意初始化的情况也有所不同，因为本题要求的是子序列，可以出现不连续的情况，即便<code>a[i] != b[0]</code>，我们也需要沿用之前<code>dp[i - 1][0]</code>的结果，来保证初始化是正确的。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">longestCommonSubsequence</span><span class="params">(string a, string b)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> result = <span class="number">0</span>; <span class="comment">// 结果集初始化</span></span><br><span class="line">        <span class="comment">// dp[i][j] 代表a中i和b中j下标和下标之前的最长公共子序列的长度</span></span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dp</span>(a.<span class="built_in">size</span>(), <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(b.<span class="built_in">size</span>(), <span class="number">0</span>));</span><br><span class="line">        <span class="comment">// 初始化，判断第一个字符是否有相同的位置</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; a.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (a[i] == b[<span class="number">0</span>]) &#123;</span><br><span class="line">                dp[i][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">                result = <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (i &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                dp[i][<span class="number">0</span>] = dp[i - <span class="number">1</span>][<span class="number">0</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; b.<span class="built_in">size</span>(); j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (b[j] == a[<span class="number">0</span>]) &#123;</span><br><span class="line">                dp[<span class="number">0</span>][j] = <span class="number">1</span>;</span><br><span class="line">                result = <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (j &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                dp[<span class="number">0</span>][j] = dp[<span class="number">0</span>][j - <span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 判断 a[i] == b[j] 代表公共子序列可以扩展</span></span><br><span class="line">        <span class="comment">// dp[i][j] = dp[i-1][j-1] + 1</span></span><br><span class="line">        <span class="comment">// 其他情况，代表公共子序列不能扩展，那么当前的最长公共子序列和前一位的相同</span></span><br><span class="line">        <span class="comment">// 因为是二维数组，所以“前一位”其实有两种情况，分别是i-1和j-1，用max取最大值</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; a.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt; b.<span class="built_in">size</span>(); j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (a[i] == b[j]) &#123;</span><br><span class="line">                    dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    dp[i][j] = <span class="built_in">max</span>(dp[i - <span class="number">1</span>][j], dp[i][j - <span class="number">1</span>]);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (dp[i][j] &gt; result) &#123;</span><br><span class="line">                    result = dp[i][j];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/06/59e2de13c184a74ed1a3f938e5875d64.png" alt="image.png"></p>]]></content>
    
    
    <summary type="html">leetcode刷题笔记-1143.最长公共子序列</summary>
    
    
    
    <category term="编程学习" scheme="https://blog.musnow.top/categories/%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="把题目都给刷干净" scheme="https://blog.musnow.top/categories/%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0/%E6%8A%8A%E9%A2%98%E7%9B%AE%E9%83%BD%E7%BB%99%E5%88%B7%E5%B9%B2%E5%87%80/"/>
    
    
    <category term="OJ刷题" scheme="https://blog.musnow.top/tags/OJ%E5%88%B7%E9%A2%98/"/>
    
    <category term="leetcode" scheme="https://blog.musnow.top/tags/leetcode/"/>
    
  </entry>
  
</feed>
