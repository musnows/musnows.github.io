<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>慕雪的寒舍</title>
  
  <subtitle>雪下了一夜</subtitle>
  <link href="https://blog.musnow.top/atom.xml" rel="self"/>
  
  <link href="https://blog.musnow.top/"/>
  <updated>2024-04-07T03:45:13.000Z</updated>
  <id>https://blog.musnow.top/</id>
  
  <author>
    <name>慕雪年华</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>【算法】贪心算法</title>
    <link href="https://blog.musnow.top/posts/3488338229/"/>
    <id>https://blog.musnow.top/posts/3488338229/</id>
    <published>2024-04-07T02:33:18.000Z</published>
    <updated>2024-04-07T03:45:13.000Z</updated>
    
    <content type="html"><![CDATA[<p>贪心算法学习</p><h1 id="基本理论"><a href="#基本理论" class="headerlink" title="基本理论"></a>基本理论</h1><p>贪心算法的基本理论是“从局部最优推出全局最优”。</p><p>每一次小操作都是在选择局部最优，最终得到的结果就是一个全局最优。</p><p>当一个题目能满足这个思路的时候，就可以尝试使用贪心了。</p><h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><h2 id="455-分发饼干"><a href="#455-分发饼干" class="headerlink" title="455 分发饼干"></a>455 分发饼干</h2><blockquote><p><a href="https://leetcode.cn/problems/assign-cookies/">https://leetcode.cn/problems/assign-cookies/</a></p></blockquote><h3 id="题目和思路"><a href="#题目和思路" class="headerlink" title="题目和思路"></a>题目和思路</h3><p>假设你是一位很棒的家长，想要给你的孩子们一些小饼干。但是，每个孩子最多只能给一块饼干。</p><p>对每个孩子 i，都有一个胃口值 <code>g[i]</code>，这是能让孩子们满足胃口的饼干的最小尺寸；并且每块饼干 j，都有一个尺寸 <code>s[j]</code> 。如果 <code>s[j] &gt;= g[i]</code>，我们可以将这个饼干 j 分配给孩子 i ，这个孩子会得到满足。你的目标是尽可能满足越多数量的孩子，并输出这个最大数值。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">示例 1:</span><br><span class="line">输入: g = [1,2,3], s = [1,1]</span><br><span class="line">输出: 1</span><br><span class="line">解释: </span><br><span class="line">你有三个孩子和两块小饼干，3个孩子的胃口值分别是：1,2,3。</span><br><span class="line">虽然你有两块小饼干，由于他们的尺寸都是1，你只能让胃口值是1的孩子满足。</span><br><span class="line">所以你应该输出1。</span><br><span class="line"></span><br><span class="line">示例 2:</span><br><span class="line">输入: g = [1,2], s = [1,2,3]</span><br><span class="line">输出: 2</span><br><span class="line">解释: </span><br><span class="line">你有两个孩子和三块小饼干，2个孩子的胃口值分别是1,2。</span><br><span class="line">你拥有的饼干数量和尺寸都足以让所有孩子满足。</span><br><span class="line">所以你应该输出2.</span><br></pre></td></tr></table></figure><p>这道题的思路其实很简单，即我们每次都应该选择大饼干满足大胃口的人，这样才能让最终可以吃到饼干的小孩最多。</p><p>直接排序两个数组，从右往左遍历，判断当前饼干是否能满足当前胃口的人，如果可以，则消耗一个饼干，并让计数器加一。不可以，则继续往左遍历胃口。</p><p>在这个例子中，局部最优是用大饼干满足大胃口的，全局最优是最终能吃上饼干的孩子最多。</p><h3 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h3><p>代码中需要注意对index的越界检查，特别是s为空的情况。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">findContentChildren</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; g, vector&lt;<span class="type">int</span>&gt;&amp; s)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">sort</span>(g.<span class="built_in">begin</span>(), g.<span class="built_in">end</span>());</span><br><span class="line">        <span class="built_in">sort</span>(s.<span class="built_in">begin</span>(), s.<span class="built_in">end</span>());</span><br><span class="line">        <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> index = s.<span class="built_in">size</span>() - <span class="number">1</span>; <span class="comment">// 饼干最后一个</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = g.<span class="built_in">size</span>() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="keyword">if</span> (index &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (s[index] &gt;= g[i]) &#123;</span><br><span class="line">                index--;</span><br><span class="line">                count++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">学习贪心算法</summary>
    
    
    
    <category term="编程学习" scheme="https://blog.musnow.top/categories/%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="默认分组" scheme="https://blog.musnow.top/categories/%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0/%E9%BB%98%E8%AE%A4%E5%88%86%E7%BB%84/"/>
    
    
    <category term="算法" scheme="https://blog.musnow.top/tags/%E7%AE%97%E6%B3%95/"/>
    
    <category term="leetcode" scheme="https://blog.musnow.top/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>【win】windows11让蓝牙耳机不进入通话模式</title>
    <link href="https://blog.musnow.top/posts/137069193/"/>
    <id>https://blog.musnow.top/posts/137069193/</id>
    <published>2024-04-06T01:07:34.000Z</published>
    <updated>2024-04-06T01:16:18.000Z</updated>
    
    <content type="html"><![CDATA[<p>在windows上让蓝牙耳机不进入通话模式。</p><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>如果你在windows上使用过蓝牙耳机打游戏，你会发现在部分游戏中（比如战地2042），耳机会进入<strong>通话模式</strong>，音质巨差无比。</p><p>这是因为该游戏将麦克风设置为了蓝牙耳机，让耳机进入了通话模式。</p><blockquote><p>PS：作为娱乐玩家，蓝牙耳机的延迟对于我来说是无感的。</p></blockquote><p>实际上，win对蓝牙的支持本来就是一坨，即便用耳机麦克风也什么都听不清，还不如用笔记本电脑自己的麦克风。要知道，现在的笔记本（基本上）都有2到4个阵列麦克风，在正常使用场景下，笔记本麦大概率优于windows下使用蓝牙耳机的麦。</p><blockquote><p>如果你是台式，个人建议买带耳麦的有线&#x2F;2.4G游戏耳机或另购麦克风</p></blockquote><p>所以现在要解决的就是，如何让游戏无法使用蓝牙耳机的麦克风，避免蓝牙耳机进入通话模式。</p><h2 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h2><p>解决方法很粗暴：让windows不能将蓝牙耳机识别成音频输入设备，只能作为音频输出设备。</p><p>windows11进入系统<strong>设置-声音</strong>模块，在<code>输入</code>中找到你的蓝牙耳机，点击它，会进入属性页面，勾选不允许windows将设备用于音频（这只会关掉蓝牙耳机的麦克风）</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/04/0b8fcad25c745125217b5927502da036.png" alt="image.png"></p><p>勾选完毕后，回到<code>设置-声音</code>页面，你应该会发现输入设备中已经没有蓝牙耳机了</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/04/81e1f76aecdd6bf9ed90cb9c383af1d7.png" alt="image.png"></p><p>这样就OK了，你的蓝牙耳机再也不会进入通话模式了。</p>]]></content>
    
    
    <summary type="html">windows11让蓝牙耳机不进入通话模式</summary>
    
    
    
    <category term="差生文具多" scheme="https://blog.musnow.top/categories/%E5%B7%AE%E7%94%9F%E6%96%87%E5%85%B7%E5%A4%9A/"/>
    
    <category term="电脑使用小贴士" scheme="https://blog.musnow.top/categories/%E5%B7%AE%E7%94%9F%E6%96%87%E5%85%B7%E5%A4%9A/%E7%94%B5%E8%84%91%E4%BD%BF%E7%94%A8%E5%B0%8F%E8%B4%B4%E5%A3%AB/"/>
    
    
    <category term="windows" scheme="https://blog.musnow.top/tags/windows/"/>
    
  </entry>
  
  <entry>
    <title>【leetcode】295.数据流的中位数</title>
    <link href="https://blog.musnow.top/posts/196461022/"/>
    <id>https://blog.musnow.top/posts/196461022/</id>
    <published>2024-03-30T07:05:54.000Z</published>
    <updated>2024-03-30T07:05:54.000Z</updated>
    
    <content type="html"><![CDATA[<p> leetcode题295.数据流的中位数</p><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><blockquote><p><a href="https://leetcode.cn/problems/find-median-from-data-stream/">295. 数据流的中位数</a></p></blockquote><p><strong>中位数</strong>是有序整数列表中的中间值。如果列表的大小是偶数，则没有中间值，中位数是两个中间值的平均值。</p><ul><li>例如 <code>arr = [2,3,4]</code> 的中位数是 <code>3</code> 。</li><li>例如 <code>arr = [2,3]</code> 的中位数是 <code>(2 + 3) / 2 = 2.5</code> 。</li></ul><p>实现 MedianFinder 类:</p><ul><li><code>MedianFinder() </code>初始化 <code>MedianFinder</code> 对象。</li><li><code>void addNum(int num)</code> 将数据流中的整数 <code>num</code> 添加到数据结构中。</li><li><code>double findMedian()</code> 返回到目前为止所有元素的中位数。与实际答案相差 <code>10^-5</code> 以内的答案将被接受。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">示例 1：</span><br><span class="line">输入</span><br><span class="line">[&quot;MedianFinder&quot;, &quot;addNum&quot;, &quot;addNum&quot;, &quot;findMedian&quot;, &quot;addNum&quot;, &quot;findMedian&quot;]</span><br><span class="line">[[], [1], [2], [], [3], []]</span><br><span class="line">输出</span><br><span class="line">[null, null, null, 1.5, null, 2.0]</span><br><span class="line"></span><br><span class="line">解释</span><br><span class="line">MedianFinder medianFinder = new MedianFinder();</span><br><span class="line">medianFinder.addNum(1);    // arr = [1]</span><br><span class="line">medianFinder.addNum(2);    // arr = [1, 2]</span><br><span class="line">medianFinder.findMedian(); // 返回 1.5 ((1 + 2) / 2)</span><br><span class="line">medianFinder.addNum(3);    // arr[1, 2, 3]</span><br><span class="line">medianFinder.findMedian(); // return 2.0</span><br></pre></td></tr></table></figure><p><strong>提示:</strong></p><ul><li><code>-10^5 &lt;= num &lt;= 10^5</code>;</li><li>在调用 <code>findMedian</code> 之前，数据结构中至少有一个元素;</li><li>最多 <code>5 * 104</code> 次调用 <code>addNum</code> 和 <code>findMedian</code>;</li></ul><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>来自k神的题解 <a href="https://leetcode.cn/problems/find-median-from-data-stream/solutions/2361972/295-shu-ju-liu-de-zhong-wei-shu-dui-qing-gmdo/">https://leetcode.cn/problems/find-median-from-data-stream/solutions/2361972/295-shu-ju-liu-de-zhong-wei-shu-dui-qing-gmdo/</a> ，用两个堆来解决这个问题。</p><p>首要的思想是，我们需要将数组流存入一个有序的数组，再确定中位数。不用堆的情况下，我们可以利用插入排序的思想，将新数据插入到数组中的正确位置。这涉及到<code>O(N)</code>的数组中元素的移动，以及利用二分查找数组的插入位置<code>O(LogN)</code>。总的时间复杂度是<code>O(logN+N)</code></p><p>使用两个堆，就可以将整体的时间复杂度控制在<code>O(logN)</code>上，一定程度上能提高效率。</p><ul><li>小堆A用来存放数组大的那一部分数据（你可以理解为堆内元素是倒序，堆顶是最小的数）</li><li>大堆B用来存放数组小的那一部分的数据（堆内元素是正序，堆顶是最大的数）</li><li>A中的所有数据都必须大于B</li></ul><p>此时小堆A对着大堆B，就构成了一个完整的“有序数组”。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">小堆A [6,5,4]   [3,2,1] 大堆B</span><br><span class="line">   小堆堆顶4    大堆堆顶3</span><br></pre></td></tr></table></figure><p>插入的时候，约定小堆A的元素数量应该大于大堆B，分为奇数和偶数的情况</p><ul><li>A和B的大小相等，说明当前数据流数量是偶数，往A中插入元素<ul><li>需要先将待插入元素num和B的堆顶元素比较（确保A中是数组大的那一部分的数据）</li><li>如果num大于B的堆顶元素，则直接插入A；</li><li>如果num小于B的堆顶元素，则插入B后，往A内插入B的堆顶元素，再弹出B的堆顶元素；</li></ul></li><li>A的元素个数大于B，说明当前数据流数量是奇数，往B中插入元素<ul><li>将插入元素和A的堆顶元素比较</li><li>如果num大于A的堆顶元素，则将A的堆顶元素插入B，弹出A的堆顶元素，再将num插入A；</li><li>如果num小于A的堆顶元素，则将num直接插入B</li></ul></li></ul><p>查询中位数的时候，也分为奇数和偶数的情况，注意题目要求的返回值是double</p><ul><li>A和B的元素个数相等，说明是偶数，中位数为<code>(A堆顶元素+B堆顶元素)/2.0</code>；</li><li>A和B的元素个数不相等（肯定是A的元素多），说明是奇数，中位数为<code>A的堆顶元素*1.0</code>。</li></ul><p>思路会了，写代码就不难了。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>注意cpp中优先级队列默认是大堆，且std库中提供了less和greater作为堆的比较函数</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MedianFinder</span> &#123;</span><br><span class="line">    <span class="comment">// 注意优先级队列C++中默认的比较函数是less，存放的是大堆</span></span><br><span class="line">    priority_queue&lt;<span class="type">int</span>&gt; _queBig; <span class="comment">// 大堆，存放小半边数据</span></span><br><span class="line">    priority_queue&lt;<span class="type">int</span>, vector&lt;<span class="type">int</span>&gt;, std::greater&lt;<span class="type">int</span>&gt;&gt;</span><br><span class="line">        _queSm; <span class="comment">// 小堆，存放大半边数据</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MedianFinder</span>() &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 保证较大的一半数据更多</span></span><br><span class="line">    <span class="comment">// 奇数的时候较大的一半堆顶就是中位数</span></span><br><span class="line">    <span class="comment">// 偶数的时候，较小+较大堆顶/2就是中位数</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">addNum</span><span class="params">(<span class="type">int</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (_queBig.<span class="built_in">size</span>() == _queSm.<span class="built_in">size</span>()) &#123;</span><br><span class="line">            <span class="comment">// 注意sm存放的是大的那一半</span></span><br><span class="line">            <span class="comment">// _queSm.push(num);</span></span><br><span class="line">            <span class="comment">// error！不能直接插入!</span></span><br><span class="line">            <span class="comment">// 先把num插入到big里面，再把big里面最大的那个数插入到sm里面！</span></span><br><span class="line">            <span class="comment">// 因为需要保证有序，如果直接插入，此时num的值可能比big里面的堆顶元素小！</span></span><br><span class="line">            _queBig.<span class="built_in">push</span>(num);</span><br><span class="line">            _queSm.<span class="built_in">push</span>(_queBig.<span class="built_in">top</span>());</span><br><span class="line">            _queBig.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 大的那一半数据更多</span></span><br><span class="line">        <span class="comment">// 注意sm存放的是大的那一半</span></span><br><span class="line">        <span class="keyword">if</span> (_queBig.<span class="built_in">size</span>() &lt; _queSm.<span class="built_in">size</span>()) &#123;</span><br><span class="line">            <span class="comment">// 如果当前数比大堆堆顶的更大，则需要放到大的那一半中</span></span><br><span class="line">            <span class="keyword">if</span> (num &gt; _queSm.<span class="built_in">top</span>()) &#123;</span><br><span class="line">                _queBig.<span class="built_in">push</span>(_queSm.<span class="built_in">top</span>());</span><br><span class="line">                _queSm.<span class="built_in">pop</span>();</span><br><span class="line">                _queSm.<span class="built_in">push</span>(num);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 其他情况都往小的那一半里面插</span></span><br><span class="line">            _queBig.<span class="built_in">push</span>(num);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">double</span> <span class="title">findMedian</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (_queBig.<span class="built_in">size</span>() == _queSm.<span class="built_in">size</span>()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">double</span>((_queBig.<span class="built_in">top</span>() + _queSm.<span class="built_in">top</span>()) / <span class="number">2.0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// sm才是大的那一半</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">double</span>(_queSm.<span class="built_in">top</span>() * <span class="number">1.0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your MedianFinder object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * MedianFinder* obj = new MedianFinder();</span></span><br><span class="line"><span class="comment"> * obj-&gt;addNum(num);</span></span><br><span class="line"><span class="comment"> * double param_2 = obj-&gt;findMedian();</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/03/ab2c48575f9575470fc55b39f21268dc.png" alt="image-20240330163821849"></p>]]></content>
    
    
    <summary type="html">leetcode题295.数据流的中位数</summary>
    
    
    
    <category term="编程学习" scheme="https://blog.musnow.top/categories/%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="把题目都给刷干净" scheme="https://blog.musnow.top/categories/%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0/%E6%8A%8A%E9%A2%98%E7%9B%AE%E9%83%BD%E7%BB%99%E5%88%B7%E5%B9%B2%E5%87%80/"/>
    
    
    <category term="堆" scheme="https://blog.musnow.top/tags/%E5%A0%86/"/>
    
    <category term="leetcode" scheme="https://blog.musnow.top/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>【C++】布隆过滤器（海量数据处理）</title>
    <link href="https://blog.musnow.top/posts/3245288951/"/>
    <id>https://blog.musnow.top/posts/3245288951/</id>
    <published>2024-03-30T01:26:11.000Z</published>
    <updated>2024-04-03T07:03:06.000Z</updated>
    
    <content type="html"><![CDATA[<p>面试的时候可能会考到这种大数据处理的问题，如果不记得布隆过滤器是干嘛的，那就G喽！</p><blockquote><p>本文参考：<a href="https://blog.csdn.net/weixin_58450087/article/details/123512052">https://blog.csdn.net/weixin_58450087/article/details/123512052</a> 编写</p></blockquote><h1 id="1-什么是布隆过滤器？"><a href="#1-什么是布隆过滤器？" class="headerlink" title="1.什么是布隆过滤器？"></a>1.什么是布隆过滤器？</h1><p>布隆过滤器（Bloom Filter）是1970年由布隆提出的。它实际上是一个很长的二进制向量和一系列随机映射函数。它通过多个哈希函数将一个数据映射到位图的结构中（也就是一个数据映射位图的多个位置，这样就可以减少冲突的概率）。布隆过滤器可以用于检索一个元素是否在一个集合中。它的优点是空间效率和查询时间都比一般的算法要好的多，缺点是有一定的误识别率和删除困难。</p><h2 id="1-1-引入"><a href="#1-1-引入" class="headerlink" title="1.1 引入"></a>1.1 引入</h2><p>在认识布隆过滤器之前，我们先要认识一下哈希和位图的思想。</p><ul><li>哈希：通过哈希函数将value映射到数组中的某个key值下标的位置进行存储，方便查询；但对于海量数据来说占用空间大。</li><li>位图：通过比特0和1来代表某一位的状态，极致节省空间；但无法处理哈希冲突问题。</li></ul><p>布隆过滤器就是这两个思想的结合，可以帮助我们处理海量数据！</p><h2 id="1-2-思想"><a href="#1-2-思想" class="headerlink" title="1.2 思想"></a>1.2 思想</h2><p>在哈希中，我们一般只使用一个哈希函数来进行value和key的映射，哈希可以通过拉链法或者线性探测法来解决哈希冲突问题。</p><p>但在布隆过滤器中，因为需要使用<strong>位图</strong>来做底层的数据结构，此时一个哈希函数就不够了，我们需要多个哈希函数，同时针对一个value进行计算，并将计算出来的多个结果位都置1，以此来减少冲突的概率，同时节省空间。</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/03/60313e1ecb3c9654d752958cd39d83d5.png" alt="img"></p><p>比如我有字符串A、B、C和三个哈希函数</p><ul><li>A计算出来是10、29、39；</li><li>B计算出来是29、30、54；</li><li>C计算出来是30、34、44；</li></ul><p>那么就需要将位图中对应的比特置1，当查询B字符串的时候，判断29、30、54位是否为1，有一个不为1则可以确定B不在过滤器中，全为1的时候可以确定B<strong>可能</strong>在布隆过滤器中。</p><h3 id="“可能在”问题"><a href="#“可能在”问题" class="headerlink" title="“可能在”问题"></a>“可能在”问题</h3><p>为什么是<strong>可能在</strong>呢？看看下面的情况</p><ul><li>A计算出来1、2、3；</li><li>B计算出来4、5、6；</li></ul><p>将A和B放入布隆过滤器，假设来了一个C字符串，计算出来2、3、6。这时候问题就出现了，C字符串并不在布隆过滤器中，但它计算出来的对应位都被A和B置为1了，此时我们就只能得出一个<strong>C可能在布隆过滤器</strong>中的结论，没有办法确定C到底在不在。</p><p>如果C计算出来是2、6、9，可以确定C<strong>绝对不在</strong>布隆过滤器中！</p><p>这也是布隆过滤器的得名所在，它只是一个过滤器！并非100%能确定结果的！布隆过滤器只可以确定<strong>绝对不在</strong>和<strong>可能在</strong>。</p><h3 id="无法删除元素"><a href="#无法删除元素" class="headerlink" title="无法删除元素"></a>无法删除元素</h3><p>因为布隆过滤器是用位图记录1和0的，如果我们将一个元素的哈希函数对应的值全都从1置0来删除的话，可能会影响到其他元素。</p><p>比如A是1、2、6，B是5、6、8，删除A的时候将1、2、6置0，这就影响了B（因为B也需要第6位来判断他是否在）</p><p>解决方法是采用计数方式来代替删除：位图的每一位进行一定扩展，比如扩展到3个bit来表示，这样就有了一个最大值为7的计数器，遇到一位映射就加一，删除就减一。</p><p>但这会引出两个问题：</p><ol><li>位图的大小会成倍增加，可能会导致布隆过滤器的内存优势削弱；</li><li>如果计数器溢出了，会出现<strong>计数回绕</strong>问题；</li></ol><p>计数回绕问题：当实际出现次数超过计数器位数后，会导致溢出回归到初始值，无法确定计数器是否正确。比如上文说的用3个bit来计数，假设这一位的出现次数已经是8了，得到的二进制结果是1000，此时低三位变成了全0，下一次判断的时候会发现这一位压根没有值，造成了错误判断。</p><p>所以实际场景中，我们又需要判断到底用几位来做这个计数器，以达到一定的平衡性。不过鉴于布隆过滤器的使用场景大多都是个过滤，避免删除元素反而成了更好的措施。</p><h3 id="如何精确确认？"><a href="#如何精确确认？" class="headerlink" title="如何精确确认？"></a>如何精确确认？</h3><p>前文提到了，布隆过滤器无法100%确认某个元素一定存在。那如果某一个场景一定需要100%确认，咋办？</p><p>举个实际的例子，假设一个游戏，用户注册的时候给自己起个玩家昵称，此时游戏需要保证玩家昵称不能重复，这时候可以怎么做？</p><ul><li>玩家键入一个名字后，客户端发起API请求，向数据服务器申请检查该名字是否已经被使用。</li></ul><p>这是一个很简单的数据库查询（暂时不考虑数据库缓存的问题），但如果一个游戏刚刚开服或者做活动，大量新玩家涌入，一个玩家每输入一个名字的时候就需要发送一个API请求，数据库服务器还能接受的了这么海量的查询请求吗？</p><ul><li>在查询数据库之前设立一个布隆过滤器，将全服玩家昵称映射进去。</li><li>当新玩家注册的时候，访问布隆过滤器，判断玩家昵称是否存在</li><li>如果布隆过滤器判断不存在（百分百可靠），API直接返回结果，允许玩家用该昵称注册；</li><li>如果布隆过滤器判断存在，则回数据库查询到底是否存在，如果存在则要求玩家改昵称，如果不存在（误判）则允许玩家用该昵称注册。</li></ul><p>这时候，布隆过滤器的“过滤”功能就很明显的体现了。而且因为查询的时候都是读操作，这时候就可以用多线程并发的<code>读写锁</code>来对布隆过滤器进行加锁，一定程度上提高查询的并发效率。</p><p>当然，玩家昵称注册的这个功能还有其他的解决办法，比如拳头的瓦洛兰特和暴雪的游戏，玩家昵称后还会带有一个<code>#</code>以及四位数字标识，可以让这四位数字标识由服务端生成，来避免两个玩家完全重名。除非四位标识都用完了（0000到9999），才提示玩家该昵称不可用。这样也一定程度上进行了过滤，减少了对数据库的查询次数。</p><h2 id="1-3-优缺点"><a href="#1-3-优缺点" class="headerlink" title="1.3 优缺点"></a>1.3 优缺点</h2><p>优点</p><ul><li>增加和查询的时间复杂度都为<code>O(K)</code>，K为哈希函数的个数</li><li>多个哈希函数之间没有关系，方便进行并行计算（多线程）</li><li>布隆过滤器并不存储元素本身，所以占用空间小，特别是海量数据处理时</li><li>如果多个布隆过滤器使用的是相同的哈希函数，则可以进行并集\交集\差集的计算</li></ul><p>缺点</p><ul><li>没有办法百分百确定value一定在，只能确定<strong>一定不在</strong>；</li><li>无法从布隆过滤器中直接获得value；</li><li>不能从布隆过滤器中删除元素（用计数方式删除会有<strong>计数回绕</strong>问题）</li></ul><h2 id="1-4-布隆过滤器的位图长度选择"><a href="#1-4-布隆过滤器的位图长度选择" class="headerlink" title="1.4 布隆过滤器的位图长度选择"></a>1.4 布隆过滤器的位图长度选择</h2><p>对于布隆过滤器来说，M（位图长度）和K（哈希函数个数）越多的时候，冲突的概率就越少。可以根据具体场景的需求，选用更大的M和K来解决冲突，让冲突的概率变小，具体需要多小的冲突概率，是由业务需要来确定的。</p><p>布隆过滤器的哈希函数与位图长度的选择关系公式如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">m = - n * ln(p) / (ln(2)^2) </span><br><span class="line">k = m/n * ln(2)</span><br><span class="line"></span><br><span class="line">// k 为哈希函数个数</span><br><span class="line">// m 为布隆过滤器长度</span><br><span class="line">// n 为插入的元素个数</span><br><span class="line">// p 为可接受该容器的误报率（0-1）</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/03/d8dee57696510408455bf30cd55d8c1d.png" alt="img"></p><p>PS：GPT说最终位图的长度还需要<code>K*M</code>，感觉是在瞎说，查了不少资料，应该是不需要进行这一步的。</p><h1 id="2-代码"><a href="#2-代码" class="headerlink" title="2.代码"></a>2.代码</h1><h2 id="2-1-位图"><a href="#2-1-位图" class="headerlink" title="2.1 位图"></a>2.1 位图</h2><p>布隆过滤器的代码基于位图。位图就不单开博客记录了，本质就是一个整形数组，把每一个比特当作位图中的每一位进行处理，对应按位与和按位或操作就OK了，不是很难理解。</p><p>位图的底层可以用vector，也可以用原生的new&#x2F;delete的数组来处理。用原生的可以节省一定的空间消耗。</p><p>位图的优点是可以节省空间，查找和设置的耗时极低，都是<code>O(1)</code>的时间复杂度。缺点是没有办法处理冲突情况，且只支持整数数据。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">BitMaps</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="type">size_t</span> _bitCount; <span class="comment">// 位图中比特的个数</span></span><br><span class="line"><span class="comment">//std::vector&lt;uint32_t&gt; _bitMap; // 使用int32_t来确保长度</span></span><br><span class="line"><span class="type">uint32_t</span>* _bitMap; <span class="comment">// 用动态内存管理来节省一定空间，vector会有额外内存消耗</span></span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="type">uint8_t</span> _weight = <span class="number">32</span>; <span class="comment">// 用的int32，设置为32方便后序修改</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">size_t</span> <span class="title">GetIndex</span><span class="params">(<span class="type">size_t</span> bit)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> bit / _weight;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">size_t</span> <span class="title">GetOffset</span><span class="params">(<span class="type">size_t</span> bit)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> bit % _weight;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="comment">// 需要多少比特的空间</span></span><br><span class="line"><span class="built_in">BitMaps</span>(<span class="type">size_t</span> bitCount):_bitCount(bitCount),_bitMap(<span class="literal">nullptr</span>) &#123;</span><br><span class="line"><span class="comment">// 需要多少个int来存放空间</span></span><br><span class="line"><span class="type">size_t</span> arraySize = bitCount / _weight + <span class="number">1</span>;</span><br><span class="line"><span class="comment">// 用原生数组一定程度上节省空间</span></span><br><span class="line"><span class="comment">// _bitMap.resize(arraySize);</span></span><br><span class="line">_bitMap = <span class="keyword">new</span> <span class="type">uint32_t</span>[arraySize];</span><br><span class="line"><span class="comment">// 遍历初始化为全0</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; arraySize; i++)</span><br><span class="line">&#123;</span><br><span class="line">_bitMap[i] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用动态内存管理，需要delete</span></span><br><span class="line">~<span class="built_in">BitMaps</span>()</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (_bitMap != <span class="literal">nullptr</span>) &#123;</span><br><span class="line"><span class="keyword">delete</span>[] _bitMap;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将第几位的比特设置为1</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Set</span><span class="params">(<span class="type">size_t</span> bit)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// 超出范围的时候报错</span></span><br><span class="line"><span class="built_in">assert</span>(bit &lt;= _bitCount); </span><br><span class="line"></span><br><span class="line"><span class="comment">// 计算下标位置</span></span><br><span class="line"><span class="type">size_t</span> index = <span class="built_in">GetIndex</span>(bit);</span><br><span class="line"><span class="comment">// 计算是这个下标的第几位</span></span><br><span class="line"><span class="type">size_t</span> offset = <span class="built_in">GetOffset</span>(bit); <span class="comment">// 0 到 31</span></span><br><span class="line"><span class="comment">// 设置进位图，按位或（有1为1）</span></span><br><span class="line">_bitMap[index] |= (<span class="number">1</span> &lt;&lt; offset);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 将对应位设置为0</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Reset</span><span class="params">(<span class="type">size_t</span> bit)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// 超出范围的时候报错</span></span><br><span class="line"><span class="built_in">assert</span>(bit &lt;= _bitCount);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 计算下标位置</span></span><br><span class="line"><span class="type">size_t</span> index = <span class="built_in">GetIndex</span>(bit);</span><br><span class="line"><span class="comment">// 计算是这个下标的第几位</span></span><br><span class="line"><span class="type">size_t</span> offset = <span class="built_in">GetOffset</span>(bit); <span class="comment">// 0 到 31</span></span><br><span class="line"><span class="comment">// 设置进位图，按位与，此时对应位为0，与之后肯定是0</span></span><br><span class="line">_bitMap[index] &amp;= ~(<span class="number">1</span> &lt;&lt; offset);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断第几位是否存在</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">Test</span><span class="params">(<span class="type">size_t</span> bit)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// 超出范围，肯定不存在</span></span><br><span class="line"><span class="keyword">if</span> (bit &gt; _bitCount) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 计算下标位置</span></span><br><span class="line"><span class="type">size_t</span> index = <span class="built_in">GetIndex</span>(bit);</span><br><span class="line"><span class="comment">// 计算是这个下标的第几位</span></span><br><span class="line"><span class="type">size_t</span> offset = <span class="built_in">GetOffset</span>(bit); <span class="comment">// 0 到 31</span></span><br><span class="line"><span class="comment">// 判断是否为1，按位与</span></span><br><span class="line"><span class="type">uint32_t</span> num = (<span class="number">1</span> &lt;&lt; offset);</span><br><span class="line"><span class="comment">// 与位图中的值按位与，只有两个都是1，才是1</span></span><br><span class="line">num &amp;= _bitMap[index];</span><br><span class="line"><span class="comment">// 为0代表不存在</span></span><br><span class="line"><span class="keyword">return</span> num != <span class="number">0</span>; </span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="2-2-布隆过滤器"><a href="#2-2-布隆过滤器" class="headerlink" title="2.2 布隆过滤器"></a>2.2 布隆过滤器</h2><h3 id="基本框架"><a href="#基本框架" class="headerlink" title="基本框架"></a>基本框架</h3><p>布隆过滤器需要指定哈希函数，有两种实现方式</p><ul><li>通过模板参数来指定哈希函数（但是只能固定个数）</li><li>通过函数来添加哈希函数（内部可以用一个function的vector来遍历调用）</li></ul><p>这里为了实现方便且以思路实现为主，采用第一种方式来处理。</p><h3 id="常用字符串哈希函数"><a href="#常用字符串哈希函数" class="headerlink" title="常用字符串哈希函数"></a>常用字符串哈希函数</h3><p>下面是三个比较常用的字符串哈希函数，由它们帮我们计算一个子串对应的三个位图下标。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">BKDRHash</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="function"><span class="type">size_t</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">const</span> std::string&amp; str)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">register</span> <span class="type">size_t</span> hash = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; str.<span class="built_in">size</span>(); ++i)</span><br><span class="line">&#123;</span><br><span class="line">hash = hash * <span class="number">131</span> + str[i];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> hash;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">SDBHash</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="function"><span class="type">size_t</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">const</span> std::string&amp; str)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">register</span> <span class="type">size_t</span> hash = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; str.<span class="built_in">size</span>(); ++i)</span><br><span class="line">&#123;</span><br><span class="line">hash = <span class="number">65599</span> * hash + str[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> hash;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">RSHash</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="function"><span class="type">size_t</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">const</span> std::string&amp; str)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">register</span> <span class="type">size_t</span> hash = <span class="number">0</span>;</span><br><span class="line"><span class="type">size_t</span> magic = <span class="number">63689</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; str.<span class="built_in">size</span>(); ++i)</span><br><span class="line">&#123;</span><br><span class="line">hash = hash * magic + str[i];</span><br><span class="line">magic *= <span class="number">378551</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> hash;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="类构造"><a href="#类构造" class="headerlink" title="类构造"></a>类构造</h3><p>布隆过滤器直接复用位图的实现即可，模板参数用缺省值来指定为字符串。如果需要存放其他类型的成员，不仅需要修改T参数，还需要修改三个哈希函数来适配该参数。</p><p>这里为了方便，直接用乘6来替代布隆过滤器的长度计算公式。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>= std::string, <span class="keyword">class</span> Hash1 = BKDRHash, <span class="keyword">class</span> Hash2 = SDBHash, <span class="keyword">class</span> Hash3 = RSHash&gt;</span><br><span class="line"><span class="keyword">class</span> BloomFilter</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="comment">// 长度计算公式 m = - n * ln(p) / (ln(2)^2) </span></span><br><span class="line"><span class="comment">// 为了实现方便，暂时用6来替代</span></span><br><span class="line"><span class="built_in">BloomFilter</span>(<span class="type">size_t</span> size)</span><br><span class="line">:_bs(<span class="number">6</span> * size)</span><br><span class="line">, _bitSize(<span class="number">6</span> * size)</span><br><span class="line">&#123;&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">BitMaps _bs; <span class="comment">// 位图</span></span><br><span class="line"><span class="type">size_t</span> _bitSize;<span class="comment">// 能够映射bit个数 </span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="设置元素"><a href="#设置元素" class="headerlink" title="设置元素"></a>设置元素</h3><p>设置元素的时候，通过三个哈希函数计算不同的下标值，设置进位图里面就行了。注意这里哈希函数的返回结果需要模一下位图的长度，避免越界。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 设置</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Set</span><span class="params">(<span class="type">const</span> T&amp; t)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">size_t</span> hash1 = <span class="built_in">Hash1</span>()(t) % _bitSize;</span><br><span class="line"><span class="type">size_t</span> hash2 = <span class="built_in">Hash2</span>()(t) % _bitSize;</span><br><span class="line"><span class="type">size_t</span> hash3 = <span class="built_in">Hash3</span>()(t) % _bitSize;</span><br><span class="line"></span><br><span class="line">_bs.<span class="built_in">Set</span>(hash1);</span><br><span class="line">_bs.<span class="built_in">Set</span>(hash2);</span><br><span class="line">_bs.<span class="built_in">Set</span>(hash3);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="查找元素"><a href="#查找元素" class="headerlink" title="查找元素"></a>查找元素</h3><p>同样是调用位图的test函数，只有三个都在的时候，才是元素可能在布隆过滤器中。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 判断</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">Test</span><span class="params">(<span class="type">const</span> T&amp; t)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">size_t</span> hash1 = <span class="built_in">Hash1</span>()(t) % _bitSize;</span><br><span class="line"><span class="type">size_t</span> hash2 = <span class="built_in">Hash2</span>()(t) % _bitSize;</span><br><span class="line"><span class="type">size_t</span> hash3 = <span class="built_in">Hash3</span>()(t) % _bitSize;</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> ret1 = _bs.<span class="built_in">Test</span>(hash1);</span><br><span class="line"><span class="type">bool</span> ret2 = _bs.<span class="built_in">Test</span>(hash2);</span><br><span class="line"><span class="type">bool</span> ret2 = _bs.<span class="built_in">Test</span>(hash3);</span><br><span class="line"><span class="comment">// 只有三个都为true才是可能在</span></span><br><span class="line"><span class="keyword">return</span> ret1 &amp;&amp; ret2 &amp;&amp; ret3;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="删除元素"><a href="#删除元素" class="headerlink" title="删除元素"></a>删除元素</h3><p>前文提到了，布隆过滤器的删除可以用计数器的方式来实现，但是会有计数回绕问题。所以这里布隆过滤器的实现先不管删除啦。</p><h2 id="2-3-测试布隆过滤器"><a href="#2-3-测试布隆过滤器" class="headerlink" title="2.3 测试布隆过滤器"></a>2.3 测试布隆过滤器</h2><p>测试一下set和test有么有什么问题。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">TestBloomFilter</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">BloomFilter&lt;&gt; <span class="built_in">bf</span>(<span class="number">100</span>);</span><br><span class="line"></span><br><span class="line">bf.<span class="built_in">Set</span>(<span class="string">&quot;test1&quot;</span>);</span><br><span class="line">bf.<span class="built_in">Set</span>(<span class="string">&quot;test2&quot;</span>);</span><br><span class="line">bf.<span class="built_in">Set</span>(<span class="string">&quot;test3&quot;</span>);</span><br><span class="line">bf.<span class="built_in">Set</span>(<span class="string">&quot;test4&quot;</span>);</span><br><span class="line"></span><br><span class="line">std::cout &lt;&lt; bf.<span class="built_in">Test</span>(<span class="string">&quot;test1&quot;</span>) &lt;&lt; std::endl;</span><br><span class="line">std::cout &lt;&lt; bf.<span class="built_in">Test</span>(<span class="string">&quot;test2&quot;</span>) &lt;&lt; std::endl;</span><br><span class="line">std::cout &lt;&lt; bf.<span class="built_in">Test</span>(<span class="string">&quot;test3&quot;</span>) &lt;&lt; std::endl;</span><br><span class="line">std::cout &lt;&lt; bf.<span class="built_in">Test</span>(<span class="string">&quot;test4&quot;</span>) &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">std::cout &lt;&lt; bf.<span class="built_in">Test</span>(<span class="string">&quot;test6&quot;</span>) &lt;&lt; std::endl;</span><br><span class="line">std::cout &lt;&lt; bf.<span class="built_in">Test</span>(<span class="string">&quot;tsdfaba&quot;</span>) &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出如下，符合预期</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">0</span></span><br><span class="line"><span class="number">0</span></span><br></pre></td></tr></table></figure><p>这里还可以构造一部分海量数据来测试这个布隆过滤器的准确度如何。但是构造海量的字符串用例感觉很是麻烦，暂时不弄了。</p><h1 id="3-实际场景问题"><a href="#3-实际场景问题" class="headerlink" title="3.实际场景问题"></a>3.实际场景问题</h1><h2 id="3-1-给一个巨大的logFile，内部存放IP地址，设计算法找到TOPK的IP或出现频率最多的IP？"><a href="#3-1-给一个巨大的logFile，内部存放IP地址，设计算法找到TOPK的IP或出现频率最多的IP？" class="headerlink" title="3.1 给一个巨大的logFile，内部存放IP地址，设计算法找到TOPK的IP或出现频率最多的IP？"></a>3.1 给一个巨大的logFile，内部存放IP地址，设计算法找到TOPK的IP或出现频率最多的IP？</h2><p>先创建1000个小文件，然后通过一个哈希函数<code>i = hash(IP) % 1000</code>计算出IP地址存放的位置（这样相同的IP地址会存入一个文件），随后依次读取这些小文件，使用一个<code>uordered_map&lt;string,long long&gt;</code>来计算每一个IP地址出现的次数。</p><p>因为相同的IP地址肯定在同一个小文件内，所以每次<code>unordered_map</code>得到的IP计数肯定是准确的。</p><blockquote><p>这里注意内存的消耗，如果1000个小文件后内存还是会爆，则将文件数量进一步扩大到10000个，以此类推。</p></blockquote><p>再用一个<strong>小根堆</strong>来存放整体TopK的IP地址：因为我们需要出现频率最高的IP地址，所以用小堆可以将<strong>堆内</strong>出现频率<strong>最低的放在堆顶</strong>。这样只要得到一个比堆顶出现次数更多的IP地址，就弹出堆顶将其插入。</p><ul><li>使用哈希函数将logFile中的IP地址映射到不同的小文件中（一行一个IP，直接在文件尾部写入即可）；</li><li>遍历小文件，使用<code>uordered_map&lt;string,long long&gt;</code>来计算IP地址出现频次；</li><li>每次遍历一个小文件后，遍历<code>unordered_map</code>，将IP地址出现频次高于堆顶元素的IP插入小根堆（弹出堆顶后插入）；</li><li>遍历完毕一个小文件，清空<code>unordered_map</code>（避免爆内存）；</li></ul><p>遍历完毕所有小文件后，得到的就是TopK出现频率最多的IP地址。此时堆顶元素就是出现频率<strong>从高到低</strong>在第K个的IP地址，堆内元素是出现频次在前K个的IP地址。</p><h2 id="3-2-给出两个50亿行的文件，一行是一个128字节的字符串，如何找到这两个文件中同时出现过的字符串？"><a href="#3-2-给出两个50亿行的文件，一行是一个128字节的字符串，如何找到这两个文件中同时出现过的字符串？" class="headerlink" title="3.2 给出两个50亿行的文件，一行是一个128字节的字符串，如何找到这两个文件中同时出现过的字符串？"></a>3.2 给出两个50亿行的文件，一行是一个128字节的字符串，如何找到这两个文件中同时出现过的字符串？</h2><blockquote><p>面大厂的时候遇到了这个问题，当时忘记布隆过滤器了，没有答出来，哭死。</p></blockquote><h3 id="布隆过滤器"><a href="#布隆过滤器" class="headerlink" title="布隆过滤器"></a>布隆过滤器</h3><p><strong>使用一个布隆过滤器来实现</strong>：</p><ul><li>创建一个布隆过滤器</li><li>按行读取文件A，计算字符串哈希，映射进布隆过滤器中</li><li>按行读取文件B，计算字符处哈希，判断是否在布隆过滤器中，在则存放至交集内。</li></ul><p>注意，因为布隆过滤器不能保证100%的准确性，所以需要根据准确度的要求扩大布隆过滤器的位图长度或增加哈希函数。</p><p>这里可以来计算一下这样做的内存消耗。用下面的python函数来计算位图的长度</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> math</span><br><span class="line"></span><br><span class="line">n = <span class="number">50</span> * <span class="number">10</span>**<span class="number">8</span>  <span class="comment"># 预期的元素数量</span></span><br><span class="line">p = <span class="number">0.005</span>       <span class="comment"># 期望的误判率</span></span><br><span class="line">k = <span class="number">4</span>           <span class="comment"># 哈希函数数量</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># math.log默认的底就是e</span></span><br><span class="line">m = -n * math.log(p) / (math.log(<span class="number">2</span>)**<span class="number">2</span>)  <span class="comment"># 计算位图长度</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;位图长度m：&quot;</span>, m)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;占用内存GB：&quot;</span>,m/(<span class="number">8</span>*<span class="number">1024</span>*<span class="number">1024</span>*<span class="number">1024</span>))</span><br></pre></td></tr></table></figure><p>输出结果如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">位图长度m： 55138767091.28201</span><br><span class="line">占用内存GB： 6.418997316071998</span><br></pre></td></tr></table></figure><p>还可以用这个网站来在线计算，<a href="https://hur.st/bloomfilter/?n=5000M&p=0.0005&m=&k=4%EF%BC%88%E8%BF%99%E4%B8%AA%E7%BD%91%E7%AB%99%E4%BD%BF%E7%94%A8%E7%9A%84%E5%85%AC%E5%BC%8F%E5%92%8C%E4%B8%8A%E6%96%87%E4%B8%8D%E5%90%8C%EF%BC%89">https://hur.st/bloomfilter/?n=5000M&amp;p=0.0005&amp;m=&amp;k=4（这个网站使用的公式和上文不同）</a></p><p>由图可知，当n为50亿的，哈希函数4个，误报率0.005（千分之5）的时候，需要7.5GB的空间来存放布隆过滤器。</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/03/c7d2deebb836931d50da4fc64fa7fb36.png" alt="image-20240330111317153"></p><p>虽然<code>6.41GB</code>和<code>7.53GB</code>看上去还是一个很大的内存占用，但是对于服务器动则128GB起步的物理内存大小而言，这已经是相对来说可以接受的占用了。哪怕如今一台16GB内存的家用电脑，理论上也能完成这样的工作。</p><p>如果直接将50亿个128字节的字符串加载到内存里面，要多少空间呢？</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(5 * 10^9 * 128) / (8*1024*1024*1024)</span><br><span class="line">结果是 74.506GB</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/03/9fde90ad5414b9f39b5ce62f112689e0.png" alt="image-20240330103449933"></p><p>74.5GB和7.5GB是将近10倍的内存占用差距，更别提这里只是计算了加载字符串的内存占用，还没有计算如果使用哈希或者红黑树来保存这些字符串的额外内存占用呢，如果算上至少奔着80GB+去了。</p><h3 id="精确算法"><a href="#精确算法" class="headerlink" title="精确算法"></a>精确算法</h3><p>精确算法就还是需要使用<strong>哈希切分</strong>加<strong>set对比</strong>的思路了，设定一万个或者十万个小文件，遍历原始文件，通过哈希<code>i = hash(IP) % 小文件数量</code>映射字符串到第i个小文件中，对A和B都做如此操作，得到A1到Ai个和B1到Bi个小文件。</p><p>因为求的是字符串交集，使用相同哈希函数的情况下，A和B的相同字符串肯定会在<strong>同一个i的小文件</strong>中，此时就可以通过对A1小文件建立一个<code>unordered_set</code>，遍历B1小文件判断是否在set中，再处理A2和B2，以此类推，得到最终的交集。</p><p>注意，如果题目给出了内存限制，我们还需要进一步计算切割出来的小文件的大小是否大于了内存的限制。如果大于了，则采用上述思路对这个小文件再进行一次切分，直到切出来的小文件可以完整的在<strong>内存限制之内</strong>即可。</p><h2 id="3-3-给定10亿个int整数，如何设计算法找到只出现了一次的数（不重复的整数）"><a href="#3-3-给定10亿个int整数，如何设计算法找到只出现了一次的数（不重复的整数）" class="headerlink" title="3.3 给定10亿个int整数，如何设计算法找到只出现了一次的数（不重复的整数）"></a>3.3 给定10亿个int整数，如何设计算法找到只出现了一次的数（不重复的整数）</h2><p>10亿个整数肯定没有办法都load到内存里面，这里需要用到位图来实现。</p><p>方法一：扩展位图，使用2个比特来记录一个数，00代表没出现，01代表出现一次，10代表出现2次及以上。最终位图操作完毕后，重新遍历位图即可得到结果。</p><p>方法二：用两个位图同时操作，数字第一次出现的时候，在第一个位图置1，第二次出现的时候，在第二个位图置1。最终只有一个位图中置1的数就是只出现了一次的数。思路同上。</p><p>这两种方法的消耗空间 <code>(2*4*(10^9))/(8*1024*1024*1024) ≈ 0.931GB</code>，足够在内存中处理了。</p><blockquote><p>1个文件有10亿个int，限定1G内存，设计算法找到出现<strong>次数不超过2次</strong>的所有整数。这个问题也能用上述方法来处理。</p></blockquote><h2 id="3-4-给两个文件，分别有100亿个整数，我们只有1G内存，如何找到两个文件交集？"><a href="#3-4-给两个文件，分别有100亿个整数，我们只有1G内存，如何找到两个文件交集？" class="headerlink" title="3.4 给两个文件，分别有100亿个整数，我们只有1G内存，如何找到两个文件交集？"></a>3.4 给两个文件，分别有100亿个整数，我们只有1G内存，如何找到两个文件交集？</h2><p>方案一： 将文件1的整数映射到一个位图中，然后读取文件2中的数据，判断是否在位图中，在就是交集。（位图的长度取决于这些整数的数据范围）</p><p>方案二： 将文件1的整数映射到一个位图中， 将文件2的整数映射到另一个位图中，然后将两个位图进行按位与（遍历按位与），与之后位图中为1的位就是两个文件的交集。</p><h2 id="3-5-已知某个文件内包含一些电话号码，每个号码为-8-位数字，统计不同号码的个数"><a href="#3-5-已知某个文件内包含一些电话号码，每个号码为-8-位数字，统计不同号码的个数" class="headerlink" title="3.5 已知某个文件内包含一些电话号码，每个号码为 8 位数字，统计不同号码的个数"></a>3.5 已知某个文件内包含一些电话号码，每个号码为 8 位数字，统计不同号码的个数</h2><p>每个号码八位数，不考虑电话号码的实际情况，8位最多<code>99,999,999</code>，一共有<code>10^8</code>种情况。也就是需要<code>10^8</code>位bit，大概12.5M内存即可。</p><p>申请一个数组，遍历所有号码，将号码对应的bit置为1，最后统计bit位1的数量即为不同的号码数。</p><h2 id="3-6-5亿个int整数找它们的中位数"><a href="#3-6-5亿个int整数找它们的中位数" class="headerlink" title="3.6 5亿个int整数找它们的中位数"></a>3.6 5亿个int整数找它们的中位数</h2><blockquote><p>参考：<a href="https://www.nowcoder.com/discuss/384700130958602240">https://www.nowcoder.com/discuss/384700130958602240</a></p></blockquote><p><strong>解法一：</strong>当内存不足以存放5亿个int整数时，我们依然使用分而治之的方法，但hash映射分成小文件的时候需要注意，我们要保证把数据分散到不同文件中时仍然保持着顺序，即按数值大小进行分流，这样才能找到正确的中位数。 </p><ul><li>我们遍历这5亿个int整数时，考虑其二进制的最高位，按照最高位（符号位，0表示正数，1表示负数）进行二分，即最高位为1存入文件a，最高位为0存入文件b，这样文件a中的数是一定比文件b中的数小。    </li><li>统计文件a和文件b中的整数个数，如果文件a和文件b中的整数个数相同，那么中位数则是文件a中的最小值和文件b中的最大值的平均值。如果文件a中的整数个数小于文件b，那么中位数肯定在文件b中，反之亦然。    </li><li>如果文件a或文件b中的整数还是无法直接读取进内存中，那么继续使用上个步骤的方法进行分流，并判断中位数所处的位置，直到中位数所在的那部分数据大小可以直接放到内存中，然后对这部分排序，计算出中位数的值。</li></ul><p>解法二：用堆来解决这个问题，前提是整数能被全部加载到内存中。</p><p>思路可以参考leetcode题目 <a href="https://leetcode.cn/problems/find-median-from-data-stream/">295. 数据流的中位数</a>，为了方便后序归档和复习，对这到题单独开一篇题解。思路还是K神的【<a href="https://leetcode.cn/problems/find-median-from-data-stream/solutions/2361972/295-shu-ju-liu-de-zhong-wei-shu-dui-qing-gmdo/">点我看思路</a>】。</p><h1 id="The-end"><a href="#The-end" class="headerlink" title="The end"></a>The end</h1><p>布隆过滤器和位图，以及哈希分而治之的思想在大数据梳理中非常有用，一定要记住！</p>]]></content>
    
    
    <summary type="html">学习如何使用布隆过滤器来处理海量数据</summary>
    
    
    
    <category term="编程学习" scheme="https://blog.musnow.top/categories/%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="C++" scheme="https://blog.musnow.top/categories/%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0/C/"/>
    
    
    <category term="数据结构" scheme="https://blog.musnow.top/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    <category term="Cpp" scheme="https://blog.musnow.top/tags/Cpp/"/>
    
    <category term="哈希" scheme="https://blog.musnow.top/tags/%E5%93%88%E5%B8%8C/"/>
    
  </entry>
  
  <entry>
    <title>【leetcode】233.数字1的个数</title>
    <link href="https://blog.musnow.top/posts/2123053741/"/>
    <id>https://blog.musnow.top/posts/2123053741/</id>
    <published>2024-03-29T11:06:22.000Z</published>
    <updated>2024-03-30T01:26:06.000Z</updated>
    
    <content type="html"><![CDATA[<p>面tx的时候上来就是这道题，我只想出来暴力的思路，肯定不得分了，赶快学习一下正确的解法。</p><h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><blockquote><p><a href="https://leetcode.cn/problems/number-of-digit-one/description/">https://leetcode.cn/problems/number-of-digit-one/description/</a></p></blockquote><p>给定一个整数 n，计算所有小于等于 n 的非负整数中数字 1 出现的个数。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">示例 1：</span><br><span class="line"></span><br><span class="line">输入：n = 13</span><br><span class="line">输出：6</span><br><span class="line"></span><br><span class="line">示例 2：</span><br><span class="line">输入：n = 0</span><br><span class="line">输出：0</span><br><span class="line"></span><br><span class="line">提示：</span><br><span class="line">0 &lt;= n &lt;= 10^9</span><br></pre></td></tr></table></figure><p>注意题目的意思，比如给定的数字n是13，那么1到13中，1一共出现了6次，分别是1、10、11（两个1）、12、13。</p><p>暴力的办法就是直接两层循环计算每一位是不是1，是1就count++，最终返回count就行；</p><h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><h2 id="基本说明"><a href="#基本说明" class="headerlink" title="基本说明"></a>基本说明</h2><blockquote><p>这里学习一下Krahets大佬的思路：<a href="https://leetcode.cn/problems/number-of-digit-one/solutions/2362053/233-shu-zi-1-de-ge-shu-qing-xi-tu-jie-by-pgb1/">https://leetcode.cn/problems/number-of-digit-one/solutions/2362053/233-shu-zi-1-de-ge-shu-qing-xi-tu-jie-by-pgb1/</a></p></blockquote><p>思路是将每一位置1后，其他的位会有多少种组合，加起来就是总的1的数量。</p><p>比如三位数中，1的个数是：个位数为1时组合的个数+十位数为1时其他数的个数+百位数为1时其他位的组合个数。更多位的数也是这个思路，以此类推。</p><p>假设n&#x3D;22时，1的个数是<code>[1,22]</code>中<code>X1</code>的个数（1、11、21）+<code>[1,22]</code>中<code>1X</code>的个数（10-19，注意这里的11只关注十位数的1）</p><h2 id="实例图"><a href="#实例图" class="headerlink" title="实例图"></a>实例图</h2><p>提供的数是n，一共有k位，我们可以把n当作<code>Nk N(k-1) ... N1 N0</code>（Nk代表每一位的数）；</p><ul><li>cur是当前遍历到的第i个数，<code>Ni</code>（下标）;</li><li>high是当前数高位的数，<code>Nk N(k-1) N(k-2) ... N(i+1)</code>;</li><li>low是当前数低位的数，<code>N(i-1) N(i-2) ... N1 N0</code>;</li><li>dights是当前的权值，为<code>10^i</code>；</li></ul><p>这个权值是<strong>当前位为1时</strong>，<strong>往后</strong>会出现多少个组合，比如cur为<strong>十位</strong>的时候，其他位和这一位能构成的1的组合是10到19，即10个1（注意这里不关注11的个位数的1），和<code>10^1</code>的结果一致。<strong>百位</strong>也是如此，能构成1的组合是100到199，一共100个1，也是<code>10^2</code>的值。</p><p>具体的分为下面三个情况</p><ol><li>cur为0；</li><li>cur为1；</li><li>cur大于1，即2到9；</li></ol><h3 id="1-cur为0"><a href="#1-cur为0" class="headerlink" title="1.cur为0"></a>1.cur为0</h3><p>假设<strong>n&#x3D;3404</strong>，cur为第1位（从右往左数第二个），hight为34，low为4，dights为10^1&#x3D;10；此时1出现的次数只和high和dights有关。公式如下<br>$$<br>high * dights<br>$$<br>你可以把3404想象成一个4位的拨动密码锁，当cur位固定为1了之后，我们需要想办法将这个密码锁拨动到不大于n的最大位置3319。对应high的变动位置是<strong>0到33</strong>（一共有34个），low的变动位置是<strong>0到9</strong>（一共10个）。</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/03/9ba40985cc005b5818b0989cbdac2ffe.png" alt="image-20240330090831427"></p><p>可得，0到33中，每一次high的变化都会出现10个1（<code>xx10~xx19</code>）。所以得出公式 <code>high * dights</code>，本例子中即为<code>34*10 = 340</code>个1。</p><ul><li>cur为0，<strong>所以1的个数只与high有关</strong>，与low位无关，为什么？</li></ul><p>因为十位的cur为0的时候，密码锁不可能拨动到341x的位置（超出范围了），此时不管low位是多少，都不会有更多1的组合，组合被锁定在了低于3404的<code>0010~3319</code>之中。和下文cur为1的情况对照能更好的理解这个情况。</p><h3 id="2-cur为1"><a href="#2-cur为1" class="headerlink" title="2.cur为1"></a>2.cur为1</h3><p>假设n&#x3D;3414。十位的cur为1的时候，密码锁就可以拨动到341x的位置了，此时1的个数和high&#x2F;low都有关系。</p><p>high包括<code>00~33</code>的34个<code>10~19</code>（340个1，和上文一致），low包括<code>3410~341x</code>的1的个数，例子中low为4，低位可决定的1的范围是3410到3414，一共有5个数，对应<code>low+1</code>。</p><p>此时可以得到公式如下<br>$$<br>higt * dights + (low + 1)<br>$$<br>下为这种情况的示意图</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/03/23c25b69ea783cc79f130cc83c650630.png" alt="image-20240330090913430"></p><h3 id="3-cur大于1"><a href="#3-cur大于1" class="headerlink" title="3.cur大于1"></a>3.cur大于1</h3><p>假设n&#x3D;3434，十位的cur大于1了，可选值已经超过了3419。此时密码锁的拨动还是只和high有关系，可以拨动的范围已经包揽了<code>00~34</code>，一共是35个<code>10~19</code>，公式如下<br>$$<br>(high + 1) * dights<br>$$</p><p>下为这种情况的示意图</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/03/cffd5e76633b7fc2873c5f6cac542577.png" alt="image-20240330091149401"></p><p>最终我们只需要遍历每一位的数，将值给加起来，就是题目的和。</p><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><p>有了每一种情况的公式，代码就很容易写出来了。这里需要注意的就是high&#x2F;low&#x2F;cur是如何移动到下一位的，以及什么时候需要跳出循环。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">countDigitOne</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> count = <span class="number">0</span>; <span class="comment">// 结果</span></span><br><span class="line">        <span class="comment">// 不大于10的时候只会有一个</span></span><br><span class="line">        <span class="keyword">if</span> (n &lt; <span class="number">10</span> &amp;&amp; n &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 个位数 dights = 10^0 = 1</span></span><br><span class="line">        <span class="type">long</span> dights = <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// high/cur/low 初始化为个位时的取值</span></span><br><span class="line">        <span class="type">long</span> high = n / <span class="number">10</span>; <span class="comment">// 除去个位的其他值</span></span><br><span class="line">        <span class="type">long</span> cur = n % <span class="number">10</span>;  <span class="comment">// 当前位是个位</span></span><br><span class="line">        <span class="type">long</span> low = <span class="number">0</span>;       <span class="comment">// 个位没有low</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// high和cur同时为0代表遍历结束</span></span><br><span class="line">        <span class="keyword">while</span> (high != <span class="number">0</span> || cur != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (cur == <span class="number">0</span>) &#123;</span><br><span class="line">                count += high * dights;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (cur == <span class="number">1</span>) &#123;</span><br><span class="line">                count += high * dights + low + <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (cur &gt; <span class="number">1</span>) &#123;</span><br><span class="line">                count += (high + <span class="number">1</span>) * dights;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 倍增，dights = 10^i</span></span><br><span class="line">            dights *= <span class="number">10</span>;</span><br><span class="line">            <span class="comment">// 移动到下一位</span></span><br><span class="line">            <span class="comment">// 当cur为十位的时候，high是n/100</span></span><br><span class="line">            <span class="comment">// 当cur为百位的时候，high是n/1000</span></span><br><span class="line">            high = n / (dights * <span class="number">10</span>);</span><br><span class="line">            <span class="comment">// 当cur为十位的时候，cur是(n/10)%10计算出来的</span></span><br><span class="line">            <span class="comment">// 当cur为百位的时候，cur是(n/100)%10计算出来的</span></span><br><span class="line">            cur = (n / dights) % <span class="number">10</span>;</span><br><span class="line">            <span class="comment">// 当cur为十位的时候，low是%10计算出来的</span></span><br><span class="line">            <span class="comment">// 当cur为百位的时候，low是%100计算出来的</span></span><br><span class="line">            low = n % dights;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/03/26e321e14e47ab27b3c3951a1556a98c.png" alt="image-20240330092321043"></p><h1 id="The-end"><a href="#The-end" class="headerlink" title="The end"></a>The end</h1><p>这道题还有数位DP的解法，但是我还没有学习到DP，此时只学一道题还不如不学。所以后续再补充其他思路吧！</p>]]></content>
    
    
    <summary type="html">leetcode刷题笔记-233.数字1的个数</summary>
    
    
    
    <category term="编程学习" scheme="https://blog.musnow.top/categories/%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="把题目都给刷干净" scheme="https://blog.musnow.top/categories/%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0/%E6%8A%8A%E9%A2%98%E7%9B%AE%E9%83%BD%E7%BB%99%E5%88%B7%E5%B9%B2%E5%87%80/"/>
    
    
    <category term="OJ刷题" scheme="https://blog.musnow.top/tags/OJ%E5%88%B7%E9%A2%98/"/>
    
    <category term="leetcode" scheme="https://blog.musnow.top/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>【leetcode】53.最大子数组和</title>
    <link href="https://blog.musnow.top/posts/4261184242/"/>
    <id>https://blog.musnow.top/posts/4261184242/</id>
    <published>2024-03-26T10:15:05.000Z</published>
    <updated>2024-04-07T07:28:31.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><blockquote><p><a href="https://leetcode.cn/problems/maximum-subarray/description/">53. 最大子数组和</a></p></blockquote><p>给你一个整数数组 nums ，请你找出一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。</p><p>子数组 是数组中的一个连续部分。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">示例 1：</span><br><span class="line">输入：nums = [-2,1,-3,4,-1,2,1,-5,4]</span><br><span class="line">输出：6</span><br><span class="line">解释：连续子数组 [4,-1,2,1] 的和最大，为 6 。</span><br><span class="line"></span><br><span class="line">示例 2：</span><br><span class="line">输入：nums = [1]</span><br><span class="line">输出：1</span><br><span class="line"></span><br><span class="line">示例 3：</span><br><span class="line">输入：nums = [5,4,-1,7,8]</span><br><span class="line">输出：23</span><br></pre></td></tr></table></figure><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>最简单的方式可以用一个三层的嵌套遍历找到这个最大值，时间复杂度是<code>O(N^3)</code>。但这样写肯定是不好的。</p><p>题目要求的是一个连续子数组的和，我们可以认为遍历到某一个数的时候，这个子数组的和就是<code>到前一位的子数组和+当前值</code>，这时候就会出现两种情况</p><ul><li><code>前一位的数组和+当前值 &lt; 当前值</code>，这说明前一位的子数组和是一个负数，那还不如当前值自己大，所以直接选用当前值作为新一轮子数组的开始。</li><li><code>前一位的数组和+当前值 &gt;= 当前值</code>，可以将当前值算到前一位的这个子数组中，继续扩张。</li></ul><p>每一次操作之后都需要更新最大和。</p><p>我们可以另外开辟一个数组来存放每一位的最大子数组和，再通过下标访问前一位的数组和。但实际上每一次遍历<strong>只和前一位的子数组和有关</strong>系，所以直接用int来存放前一位的子数组和就够了，不需要额外开辟数组的空间复杂度消耗了。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><h3 id="代码1"><a href="#代码1" class="headerlink" title="代码1"></a>代码1</h3><p>代码比较简单，理解了思路就能写出来</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxSubArray</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> prev = <span class="number">0</span>;         <span class="comment">// 之前的最大子数组和，初始值0</span></span><br><span class="line">        <span class="type">int</span> maxNum = nums[<span class="number">0</span>]; <span class="comment">// 从数组中选一个值</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; i : nums) &#123;</span><br><span class="line">            <span class="comment">// 如果之前的最大子数组和还没有我自己大，则从我自己开始新列一个子数组</span></span><br><span class="line">            prev = <span class="built_in">max</span>(prev + i, i);</span><br><span class="line">            <span class="comment">// 更新最大值</span></span><br><span class="line">            maxNum = <span class="built_in">max</span>(maxNum, prev);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxNum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/03/3e465f2252d1a16767bf00bab2ab4644.png" alt="image.png"></p><p>时间复杂度<code>O(N)</code>，空间复杂度<code>O(1)</code>；</p><h3 id="代码2"><a href="#代码2" class="headerlink" title="代码2"></a>代码2</h3><p>上面这个代码乍一看可能不好理解，我们可以按下面的方式写</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxSubArray</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> ret = INT32_MIN;</span><br><span class="line">        <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; i : nums) &#123;</span><br><span class="line">            sum += i;</span><br><span class="line">            <span class="comment">// 更新最大值</span></span><br><span class="line">            <span class="keyword">if</span> (sum &gt; ret) &#123;</span><br><span class="line">                ret = sum;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 如果当前sum为负数，那么需要重新开子数组了</span></span><br><span class="line">            <span class="comment">// 因为当前的sum加上下一位后，肯定没有下一位本身大！</span></span><br><span class="line">            <span class="keyword">if</span> (sum &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                sum = <span class="number">0</span>; <span class="comment">// 重置为0</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这个思路也是一样，只不过将判断换到了当前位之后就处理了</p><ul><li>维护一个sum，作为当前子数组的和；</li><li>每一次都让<code>sum+=i</code>，并更新最大值；</li><li>如果当前sum小于等于0了，当前<strong>子数组的和+下一位</strong>肯定会<strong>小于下一位本身</strong>，此时置为0，从下一位开始重新计算一个新的子数组和；</li><li>直到遍历完毕返回维护的最大值。</li></ul><p>两个写法都能过，重点还是理解思路啦！</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/04/041b930158ef5066677b199f9b715449.png" alt="image.png"></p><h2 id="The-end"><a href="#The-end" class="headerlink" title="The end"></a>The end</h2><p>这道题还有很多不同的解法，可以参考这个博客：<a href="https://blog.csdn.net/Supreme7/article/details/117398880">https://blog.csdn.net/Supreme7/article/details/117398880</a></p>]]></content>
    
    
    <summary type="html">leetcode刷题笔记-53.最大子数组和</summary>
    
    
    
    <category term="编程学习" scheme="https://blog.musnow.top/categories/%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="把题目都给刷干净" scheme="https://blog.musnow.top/categories/%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0/%E6%8A%8A%E9%A2%98%E7%9B%AE%E9%83%BD%E7%BB%99%E5%88%B7%E5%B9%B2%E5%87%80/"/>
    
    
    <category term="OJ刷题" scheme="https://blog.musnow.top/tags/OJ%E5%88%B7%E9%A2%98/"/>
    
    <category term="leetcode" scheme="https://blog.musnow.top/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>【面试】浏览器输入URL到出现网页的全过程</title>
    <link href="https://blog.musnow.top/posts/2270595544/"/>
    <id>https://blog.musnow.top/posts/2270595544/</id>
    <published>2024-03-26T02:09:43.000Z</published>
    <updated>2024-03-27T09:01:03.000Z</updated>
    
    <content type="html"><![CDATA[<p>面试总是考这个，虽然我能说出个大概，但总是卡壳，还是重新记录一下。</p><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><p>首先要知道这里面会涉及到什么协议，以HTTP的网页为例，会涉及到下面这些协议</p><ul><li>HTTP&#x2F;HTTPS</li><li>TCP</li><li>IP</li><li>ARP</li><li>DNS</li><li>NAT</li></ul><p>当然，更底层的还有路由选择协议OSPF等，但这些一般情况下不会考察到（除非你面试的是网络工程师相关岗位），所以能把上面的这些协议的步骤说清楚就基本够了。</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/03/200e1efb4783410ed6d8dc834e0cc459.png" alt="image.png"></p><h2 id="步骤一：URL解析"><a href="#步骤一：URL解析" class="headerlink" title="步骤一：URL解析"></a>步骤一：URL解析</h2><p>浏览器首先是需要解析你访问的URL，从里面提取当前使用的网络协议（以HTTP协议为例），目标的域名，以及域名后的请求路径与参数。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http(s)://&lt;host&gt;:&lt;port&gt;/&lt;path&gt;?&lt;query&gt;#&lt;frag&gt;</span><br></pre></td></tr></table></figure><p>随后浏览器会将这里面的信息封装成一个HTTP请求报文。因为是在浏览器中输入的URL，所以是GET请求。假设你访问的是某个网页的主页，那么浏览器就会构造一个GET请求报文，去请求根路径下的<code>index.html</code>文件。</p><h2 id="步骤二：DNS解析"><a href="#步骤二：DNS解析" class="headerlink" title="步骤二：DNS解析"></a>步骤二：DNS解析</h2><p>知道了域名，还需要知道这个域名对应的IP地址，才能发起网络请求。<strong>浏览器</strong>会进行DNS查询（基于UDP），来找到域名的IP地址。</p><ul><li>查询浏览器本地缓存；</li><li>查询PC主机本地缓存；</li><li>查询主机HOSTS文件；</li><li>本地缓存找不到，向默认DNS服务器（通常是ISP的DNS服务器）发起<strong>递归</strong>查询；</li><li>ISP的DNS服务器使用<strong>迭代</strong>的方式依次从根域名服务器、顶级域名服务器……直到找到该域名映射的IP地址。</li><li>ISP的DNS服务器向客户端返回IP地址（服务器一般有<strong>负载均衡</strong>，同一个域名每一次查询到的IP地址可能不一样）</li></ul><p>DNS是基于UDP的，底层依旧是IP协议，当前的主机一般是<strong>知道DNS服务器的IP地址的</strong>（可以手动配置公共DNS服务器，或者自动选择时默认ISP的DNS服务器），所以不存在还需要查询DNS服务器的IP地址的情况。</p><ul><li>如果找不到，会返回失败，此时浏览器会显示 <code>DNS_PROBE_FINISHED_NXDOMAIN</code>，提示用户该域名找不到IP地址（没有成功解析）</li><li>如果找到了，浏览器会将这个域名和IP的对应关系放入自己的缓存，方便下一次请求。</li></ul><p>本地的DNS缓存也会有一个过期计时器，避免目标域名和IP的映射关系发生变化。</p><h2 id="步骤三：TCP握手"><a href="#步骤三：TCP握手" class="headerlink" title="步骤三：TCP握手"></a>步骤三：TCP握手</h2><p>现在我们知道目标主机的IP地址了，也知道端口号（HTTP协议是80端口，HTTPS是443端口），现在浏览器会调用系统接口，发起TCP三次握手的请求。下面的工作就是操作系统的网络协议栈来处理的了啦！</p><blockquote><p>这里可能会追问为什么TCP握手是三次：三次握手是<strong>保证双方通信能力的最小握手次数</strong>，同时也一定程度上避免了一次和二次握手中客户端只需要发送一次SYN就能攻击服务器的情况。</p></blockquote><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/03/87c2006ec4c2d6e3394f0e90b99493d0.png" alt="image.png"></p><p>TCP的握手报文向下层IP层交付，IP层封装源IP和目的服务器IP（刚刚通过DNS获得的），并将TCP报文封装到IP报文的数据部分，向下层数据链路层交付。</p><p>数据链路层通过ARP协议查询IP地址对应的MAC地址</p><ul><li>如果是家庭局域网，查询不到目的IP地址，主机会用默认的下一跳（一般是路由器）发送这个报文（后序还涉及到NAT协议）</li><li>如果两个主机都在公网，发送端进行路由查找，查询目标IP地址的目的网络，并转发到下一跳。</li></ul><p>注意，如果面试官没有要求，可以先忽略IP层的处理，这部分是最容易说岔的！</p><h2 id="步骤四：服务器接收请求"><a href="#步骤四：服务器接收请求" class="headerlink" title="步骤四：服务器接收请求"></a>步骤四：服务器接收请求</h2><p>服务器收到客户端发送的报文，从下往上交付，得到HTTP的GET请求，并根据请求中的路径和参数，将客户端需要的资源（html&#x2F;js&#x2F;css）封装并封装在HTTP响应报文中，传回客户端。</p><h2 id="步骤五：客户端接收响应"><a href="#步骤五：客户端接收响应" class="headerlink" title="步骤五：客户端接收响应"></a>步骤五：客户端接收响应</h2><p>客户端收到响应，解析HTTP响应中的数据，并交付<strong>浏览器进行页面渲染</strong>。</p><p>此时根据双方的约定，决定保持链接还是终止TCP链接（终止需要进行四次挥手）</p><h2 id="额外步骤：HTTPS的SSL握手"><a href="#额外步骤：HTTPS的SSL握手" class="headerlink" title="额外步骤：HTTPS的SSL握手"></a>额外步骤：HTTPS的SSL握手</h2><p>如果是HTTPS协议，在正式发送请求之前，还需要进行SSL证书的握手。</p><blockquote><p> 引用：<a href="https://zhuanlan.zhihu.com/p/58955297">https://zhuanlan.zhihu.com/p/58955297</a></p></blockquote><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/03/d2a2828867b502a52ec189aea35994d9.png" alt="image.png"></p><p>需要通过证书握手，确定双方使用的对称加密密钥，再加密进行HTTP请求&#x2F;响应的传输。</p>]]></content>
    
    
    <summary type="html">面试常考-浏览器输入URL到出现网页的全过程</summary>
    
    
    
    <category term="编程学习" scheme="https://blog.musnow.top/categories/%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="默认分组" scheme="https://blog.musnow.top/categories/%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0/%E9%BB%98%E8%AE%A4%E5%88%86%E7%BB%84/"/>
    
    
    <category term="计算机网络" scheme="https://blog.musnow.top/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    <category term="http" scheme="https://blog.musnow.top/tags/http/"/>
    
    <category term="tcp" scheme="https://blog.musnow.top/tags/tcp/"/>
    
  </entry>
  
  <entry>
    <title>【leetcode】221最大正方形</title>
    <link href="https://blog.musnow.top/posts/2287991438/"/>
    <id>https://blog.musnow.top/posts/2287991438/</id>
    <published>2024-03-25T10:13:29.000Z</published>
    <updated>2024-03-25T11:47:40.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><blockquote><p><a href="https://leetcode.cn/problems/maximal-square/description/">221. 最大正方形</a></p></blockquote><p>在一个由 ‘0’ 和 ‘1’ 组成的二维矩阵内，找到只包含 ‘1’ 的最大正方形，并返回其面积。</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/03/8d21cc06d7ecb1b257bc127a35cf0277.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">m == matrix.length</span><br><span class="line">n == matrix[i].length</span><br><span class="line">1 &lt;= m, n &lt;= 300</span><br><span class="line">matrix[i][j] 为 &#x27;0&#x27; 或 &#x27;1&#x27;</span><br></pre></td></tr></table></figure><h2 id="思路1-前缀和"><a href="#思路1-前缀和" class="headerlink" title="思路1-前缀和"></a>思路1-前缀和</h2><h3 id="思路1说明"><a href="#思路1说明" class="headerlink" title="思路1说明"></a>思路1说明</h3><p>面试的时候遇到了这道题，当时只想得出来遍历的办法，后来面试官提示了一下想出来了另外一个思路，不过没时间写了。</p><p>思路是这样的，开另外一个和题目所给矩阵一样的二维数组<code>vector&lt;vector&lt;pair&lt;int, int&gt;&gt;&gt;</code>，用于存放每一位的往前1的个数和往上1的个数（不包括该数自己）。</p><p>以题目给的矩阵为例</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">[&quot;1&quot;,&quot;0&quot;,&quot;1&quot;,&quot;0&quot;,&quot;0&quot;],</span><br><span class="line">[&quot;1&quot;,&quot;0&quot;,&quot;1&quot;,&quot;1&quot;,&quot;1&quot;],</span><br><span class="line">[&quot;1&quot;,&quot;1&quot;,&quot;1&quot;,&quot;1&quot;,&quot;1&quot;],</span><br><span class="line">[&quot;1&quot;,&quot;0&quot;,&quot;0&quot;,&quot;1&quot;,&quot;0&quot;]</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>可以得到下面的前缀和矩阵，每一位的左侧代表该位置行之前的1的个数，右侧代表该位置列往上1的个数（不包括该数自己）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;0,0&#125; &#123;1,0&#125; &#123;1,0&#125; &#123;2,0&#125; &#123;2,0&#125;</span><br><span class="line">&#123;0,1&#125; &#123;1,0&#125; &#123;1,1&#125; &#123;2,0&#125; &#123;3,0&#125;</span><br><span class="line">&#123;0,2&#125; &#123;1,0&#125; &#123;2,2&#125; &#123;3,1&#125; &#123;4,1&#125;</span><br><span class="line">&#123;0,3&#125; &#123;0,1&#125; &#123;1,3&#125; &#123;1,2&#125; &#123;2,2&#125;</span><br></pre></td></tr></table></figure><p>此时要确定一个正方形，以示例图中下标<code>(1,2)</code>到<code>(2,3)</code>的这个2x2的正方形为例，我们只需要判断正方形对角线上的数的前缀和是否符合条件即可。一个符合条件的正方形，假设下标从<code>(0,0)</code>开始，它的对角线上的前缀和应该是这样的，分别代表该位置之前和之上1的数量。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">0,0 </span><br><span class="line">1,1</span><br><span class="line">2,2</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>但我们需要找的下标<code>(1,2)</code>到<code>(2,3)</code>的正方形并不是从<code>(0,0)</code>开始的，所以还需要对这个前缀和矩阵中的值进行一定处理来得到结果。过程如下</p><ul><li>下标<code>(1,2)</code>是1，开始处理；</li><li>正方形边长初始化为1（因为起始下标位置为1，就是一个1x1的正方形）；</li><li>判断<code>(1+1,2+1)</code>下标处的值是否为1；为1继续判断前缀和，值是<code>&#123;3,1&#125;</code>；</li><li>这里前缀和的3代表这一行前面还有3个1，1代表这一列上面还有1个1；</li><li>行需要和下标<code>(2,2)</code>处的前缀和<code>&#123;2.2&#125;</code>第一位相减；列需要和下标<code>(1,2)</code>处的前缀和<code>&#123;2,0&#125;</code>第二位相减。即<code>&#123;3-2,1-0&#125;</code>，最终得到的结果是<code>1,1</code>，符合正方形对角线上的条件，边长加一为2。</li><li>继续判断<code>(2+1,3+1)</code>下标处的值是否为1，此时发现已不为1，停止匹配；</li><li>得到最大正方形边长2，面积为4；</li></ul><p>如果是下面这样的矩阵（相比上面的矩阵只修改了左下角的两个0为1）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">[&quot;1&quot;,&quot;0&quot;,&quot;1&quot;,&quot;0&quot;,&quot;0&quot;],</span><br><span class="line">[&quot;1&quot;,&quot;0&quot;,&quot;1&quot;,&quot;1&quot;,&quot;1&quot;],</span><br><span class="line">[&quot;1&quot;,&quot;1&quot;,&quot;1&quot;,&quot;1&quot;,&quot;1&quot;],</span><br><span class="line">[&quot;1&quot;,&quot;0&quot;,&quot;1&quot;,&quot;1&quot;,&quot;1&quot;]</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>对应前缀和矩阵如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;0,0&#125; &#123;1,0&#125; &#123;1,0&#125; &#123;2,0&#125; &#123;2,0&#125;</span><br><span class="line">&#123;0,1&#125; &#123;1,0&#125; &#123;1,1&#125; &#123;2,0&#125; &#123;3,0&#125;</span><br><span class="line">&#123;0,2&#125; &#123;1,0&#125; &#123;2,2&#125; &#123;3,1&#125; &#123;4,1&#125;</span><br><span class="line">&#123;0,3&#125; &#123;0,1&#125; &#123;1,3&#125; &#123;2,2&#125; &#123;3,2&#125;</span><br></pre></td></tr></table></figure><p>此时<code>(2+1,3+1)</code>下标处的值为1，继续判断前缀和<code>&#123;3,2&#125;</code>，这时候已经是一个3x3的正方形了，这个对角线的值应为<code>&#123;2,2&#125;</code>才符合条件。所以需要计算当前前缀和与<strong>行的前2个</strong>和<strong>列的前2个</strong>的差值：</p><ul><li>行需要和下标<code>(3,2)</code>处的前缀和<code>&#123;1,3&#125;</code>第一位相减；</li><li>列需要和下标<code>(1,4)</code>处的前缀和<code>&#123;3,0&#125;</code>第二位相减；</li><li>即<code>&#123;3-1,2-0&#125;</code>，最终能得到<code>&#123;2,2&#125;</code>，符合正方形条件；</li><li>边长加一为3，最大正方形面积为9。</li></ul><p>以此类推，直到遍历的下标越界为止，即完成了对矩阵中一个位置的正方形查找。</p><p>这里涉及到两次叠加循环和一个扩张循环，时间复杂度可以认为是<code>O(N^3)</code>或<code>O(M^3)</code>；</p><h3 id="思路1代码"><a href="#思路1代码" class="headerlink" title="思路1代码"></a>思路1代码</h3><p>代码如下，关键部分添加了注释</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maximalSquare</span><span class="params">(vector&lt;vector&lt;<span class="type">char</span>&gt;&gt;&amp; matrix)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (matrix.<span class="built_in">size</span>() == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 用于记录前缀和，下标代表这个数的行之前以及列以上的1的个数（不包括该数本身）</span></span><br><span class="line">        <span class="type">int</span> n = matrix.<span class="built_in">size</span>(), m = matrix[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        vector&lt;vector&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt;&gt; <span class="built_in">oneCount</span>(</span><br><span class="line">            n, vector&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt;(m, &#123;<span class="number">0</span>, <span class="number">0</span>&#125;));</span><br><span class="line">        oneCount[<span class="number">0</span>][<span class="number">0</span>] = &#123;<span class="number">0</span>, <span class="number">0</span>&#125;;</span><br><span class="line">        <span class="comment">// O(M*N)</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; matrix.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="type">int</span> count = <span class="number">0</span>; <span class="comment">// 每一行的1计数器</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; matrix[i].<span class="built_in">size</span>(); j++) &#123;</span><br><span class="line">                <span class="comment">// 第i行，j之前的1的个数（不包括当前值）</span></span><br><span class="line">                oneCount[i][j].first = count; <span class="comment">// 先赋值，因为不包括自己</span></span><br><span class="line">                <span class="comment">// 第i行，第j列往上1的个数（不包括当前值）</span></span><br><span class="line">                <span class="keyword">if</span> (i == <span class="number">0</span>) &#123;</span><br><span class="line">                    oneCount[i][j].second = <span class="number">0</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// 直接拿上一层的值为初值，再判断上一层是否为1</span></span><br><span class="line">                    oneCount[i][j].second = oneCount[i - <span class="number">1</span>][j].second;</span><br><span class="line">                    <span class="keyword">if</span> (matrix[i - <span class="number">1</span>][j] == <span class="string">&#x27;1&#x27;</span>) &#123;</span><br><span class="line">                        oneCount[i][j].second++;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 每一行的1的个数加一</span></span><br><span class="line">                <span class="keyword">if</span> (matrix[i][j] == <span class="string">&#x27;1&#x27;</span>) &#123;</span><br><span class="line">                    count++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 此时可以得到一个矩阵，这样判断是否为正方形只需要判断对角线的数</span></span><br><span class="line">        <span class="type">int</span> maxSquare = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; matrix.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; matrix[i].<span class="built_in">size</span>(); j++) &#123;</span><br><span class="line">                <span class="comment">// 一个位置等于1的时候就是一个1x1的正方形了</span></span><br><span class="line">                <span class="keyword">if</span> (matrix[i][j] == <span class="string">&#x27;1&#x27;</span>) &#123;</span><br><span class="line">                    <span class="comment">// 从2x2的位置开始判断</span></span><br><span class="line">                    <span class="type">int</span> a = i + <span class="number">1</span>, b = j + <span class="number">1</span>;</span><br><span class="line">                    <span class="type">int</span> length = <span class="number">1</span>;      <span class="comment">// 当前正方形边长</span></span><br><span class="line">                    <span class="type">int</span> lengthCheck = <span class="number">1</span>; <span class="comment">// 正方形条件判断计数器</span></span><br><span class="line">                    <span class="comment">// 出现越界的时候停止扩张</span></span><br><span class="line">                    <span class="keyword">while</span> (a &lt; matrix.<span class="built_in">size</span>() &amp;&amp; b &lt; matrix[i].<span class="built_in">size</span>()) &#123;</span><br><span class="line">                    <span class="comment">// 这里不能用引用，避免修改数组里面的原始值</span></span><br><span class="line">                        pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; p = oneCount[a][b];</span><br><span class="line">                        <span class="comment">// 注意这里扩张的时候需要用lengthCheck来相减计算，而不是简单的减一</span></span><br><span class="line">                        <span class="comment">// 因为边长每扩大一次需要减的位置也会扩大一次</span></span><br><span class="line">                        p.first -=</span><br><span class="line">                            oneCount[a][b - lengthCheck].first; <span class="comment">// 行的前一个</span></span><br><span class="line">                        p.second -=</span><br><span class="line">                            oneCount[a - lengthCheck][b].second; <span class="comment">// 列的上一个</span></span><br><span class="line"></span><br><span class="line">                        <span class="comment">// 符合正方形要求</span></span><br><span class="line">                        <span class="keyword">if</span> (matrix[a][b] == <span class="string">&#x27;1&#x27;</span> &amp;&amp; (p.first == lengthCheck &amp;&amp;</span><br><span class="line">                                                    p.second == lengthCheck)) &#123;</span><br><span class="line">                            lengthCheck++;</span><br><span class="line">                            length++;</span><br><span class="line">                        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                            <span class="keyword">break</span>; <span class="comment">// 不符合就跳出</span></span><br><span class="line">                        &#125;</span><br><span class="line">                        a++;</span><br><span class="line">                        b++;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// 计算面积，更新最大值</span></span><br><span class="line">                    <span class="type">int</span> square = length * length;</span><br><span class="line">                    maxSquare = square &gt; maxSquare ? square : maxSquare;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxSquare;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/03/afa2032b4f1a3b38774d638dab2109fb.png"></p><h2 id="思路2-动态递归"><a href="#思路2-动态递归" class="headerlink" title="思路2-动态递归"></a>思路2-动态递归</h2><p>因为我还没有开始学动归的算法，只学一道题其他的还是不会，不如留着到时候一起回顾。</p>]]></content>
    
    
    <summary type="html">leetcode刷题笔记-221最大正方形</summary>
    
    
    
    <category term="编程学习" scheme="https://blog.musnow.top/categories/%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="把题目都给刷干净" scheme="https://blog.musnow.top/categories/%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0/%E6%8A%8A%E9%A2%98%E7%9B%AE%E9%83%BD%E7%BB%99%E5%88%B7%E5%B9%B2%E5%87%80/"/>
    
    
    <category term="OJ刷题" scheme="https://blog.musnow.top/tags/OJ%E5%88%B7%E9%A2%98/"/>
    
    <category term="leetcode" scheme="https://blog.musnow.top/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>【leetcode】33.搜索旋转排序数组</title>
    <link href="https://blog.musnow.top/posts/2415384769/"/>
    <id>https://blog.musnow.top/posts/2415384769/</id>
    <published>2024-03-25T01:34:27.000Z</published>
    <updated>2024-03-25T02:05:18.000Z</updated>
    
    <content type="html"><![CDATA[<p>这道题是快手面经中提到的，在此记录：<a href="https://www.nowcoder.com/feed/main/detail/b17a674ca2ba4327b3105ffacd1f60b4">https://www.nowcoder.com/feed/main/detail/b17a674ca2ba4327b3105ffacd1f60b4</a></p><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><blockquote><p><a href="https://leetcode.cn/problems/search-in-rotated-sorted-array/description/">33. 搜索旋转排序数组</a></p></blockquote><p>整数数组 nums 按升序排列，数组中的值 互不相同 。</p><p>在传递给函数之前，nums 在预先未知的某个下标 k（0 &lt;&#x3D; k &lt; nums.length）上进行了 旋转，使数组变为 <code>[nums[k], nums[k+1], ..., nums[n-1], nums[0], nums[1], ..., nums[k-1]]</code>（下标 从 0 开始 计数）。例如， <code>[0,1,2,4,5,6,7]</code> 在下标 3 处经旋转后可能变为 <code>[4,5,6,7,0,1,2]</code> 。</p><p>给你 旋转后 的数组 nums 和一个整数 target ，如果 nums 中存在这个目标值 target ，则返回它的下标，否则返回 -1 。</p><p>你必须设计一个时间复杂度为 <code>O(log n)</code> 的算法解决此问题。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">示例 1：</span><br><span class="line">输入：nums = [4,5,6,7,0,1,2], target = 0</span><br><span class="line">输出：4</span><br><span class="line"></span><br><span class="line">示例 2：</span><br><span class="line">输入：nums = [4,5,6,7,0,1,2], target = 3</span><br><span class="line">输出：-1</span><br><span class="line"></span><br><span class="line">示例 3：</span><br><span class="line">输入：nums = [1], target = 0</span><br><span class="line">输出：-1</span><br></pre></td></tr></table></figure><p>提示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1 &lt;= nums.length &lt;= 5000</span><br><span class="line">-104 &lt;= nums[i] &lt;= 104</span><br><span class="line">nums 中的每个值都 独一无二</span><br><span class="line">题目数据保证 nums 在预先未知的某个下标上进行了旋转</span><br><span class="line">-104 &lt;= target &lt;= 104</span><br></pre></td></tr></table></figure><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>本题要求用<code>O(log n)</code>的算法解决这个问题，自然没有办法通过暴力遍历来解决了（不然就太简单了）。</p><p>看到log就要想到二分法，同时要想到二分法的前提是遍历的序列已经有序，但这道题并非是一个严格有序的数组，它会进行一定的旋转。</p><p>仔细观察旋转的方式，当选用下标k的时候，会将k和k以后的元素全部移动到数组开头，之前的元素移动到数组末尾。</p><p>可以拿纸笔多试试几次，就能得出来一个结论，不管数组的长度是奇数还是偶数，也不管k选择那一个地方，被旋转的部分（k和k以后）和没有被旋转的部分（k以前）的序列长度肯定<strong>相等</strong>或有一个<strong>更长</strong>！</p><p>这里假设二分法计算mid的公式是<code>left+(right-left)/2</code>，其中left初始值为0，right初始值是<code>nums.size()-1</code>，二者都是闭区间。因为上文提到的特性（被旋转的部分和没有被旋转的部分长度相等或有一个更长），使用这个公式计算出来的第一个mid值肯定是在某个有序序列之中！</p><p>这里举几个具体的例子：</p><ul><li>数组长度7（奇数），k&#x3D;3，即在下标3处旋转，此时k之前还有下标<code>0,1,2</code>三个数字，k和k以后还有<code>3,4,5,6</code>四个数字；k&#x3D;4时同理，k之前有四个数字，k以后有三个数字。<ul><li>此时计算<code>mid=0+(6-0)/2=3</code>，不管k选择什么，下标3肯定是在某个有序序列之中的，这个有序序列要么在下标3之前，要么在下标3之后。</li></ul></li><li>数组长度8（偶数），k&#x3D;4，此时k之前有<code>0,1,2,3</code>四个数字，k和k之后有下标<code>4,5,6,7</code>四个数字，被旋转和没有被旋转的部分一样长；k&#x3D;5时没有被旋转的部分更长，k&#x3D;3时被旋转的部分更长。<ul><li>此时计算<code>mid=0+(7-0)/2=3</code>，不管k选择哪一个，下标3还是肯定在某个有序序列之中！</li></ul></li></ul><p>现在我们能确认这个特性了，也就能用二分法解决这个问题了！思路就是通过判断mid左侧还是右侧有序，来确认left&#x2F;right边界，让下一轮的mid计算在有序序列中进行。</p><ul><li>如果nums[left]小于等于nums[mid]，则说明左侧有序（这里的等于判断是避免mid&#x3D;left的情况）</li><li>其他情况都可以归于右侧有序</li></ul><p>在循环体内，每一次都需要判断mid左侧还是右侧有序的，确认有序序列的位置之后，找target的操作就是在有序数组中通过二分法查找的思想了，时间复杂度是<code>O(log(N))</code>。</p><ul><li>为什么每一次都需要判断？</li></ul><p>因为target可能不在第一次找到的有序序列中，如下示例，第一次计算出来的mid&#x3D;3，虽然能确认mid的左侧是有序的，但target&#x3D;1的时候，我们需要找的目标数是在mid的右侧。此时右侧的序列是<code>[7,0,1,2]</code>，这还不是一个有序序列，我们还是需要通过计算mid判断左侧还是右侧有序，来再次确认第二个有序的子序列位置。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[3,4,5,6,7,0,1,2]</span><br></pre></td></tr></table></figure><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>思路理清楚了，代码就不难写了</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">search</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 旋转后的数组肯定是一部分有序的</span></span><br><span class="line">        <span class="comment">// 这个有序的部分肯定是在mid左侧或者右侧！</span></span><br><span class="line">        <span class="comment">// 题目中的旋转是从k开始（包括k）往后的数字移动到数组的开头</span></span><br><span class="line">        <span class="comment">// 不管k选择哪里都肯定符合上面的这个条件，永远会有一边的数字更多</span></span><br><span class="line">        <span class="comment">// [4,5,6,7,0,1,2] 以mid=3分割</span></span><br><span class="line">        <span class="comment">// [4,5,6,7]       有序</span></span><br><span class="line">        <span class="comment">//       [7,0,1,2] 无序</span></span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> left = <span class="number">0</span>, right = nums.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 如果要使用小于等于，那么left和right应该都是闭区间</span></span><br><span class="line">        <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">            <span class="type">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">            <span class="comment">// 中间能找到</span></span><br><span class="line">            <span class="keyword">if</span> (nums[mid] == target) &#123;</span><br><span class="line">                <span class="keyword">return</span> mid;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 找不到，判断左侧或者右侧是否有序</span></span><br><span class="line">            <span class="keyword">if</span> (nums[left] &lt;= nums[mid]) <span class="comment">// 左侧有序</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// 判断值是否在左侧</span></span><br><span class="line">                <span class="keyword">if</span> (nums[left] &lt;= target &amp;&amp; target &lt; nums[mid]) &#123;</span><br><span class="line">                    right = mid - <span class="number">1</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="comment">// 左侧虽然有序，但是值在右侧</span></span><br><span class="line">                &#123;</span><br><span class="line">                    left = mid + <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 左半部分不是有序，说明右半部分是有序的</span></span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 值在右侧</span></span><br><span class="line">                <span class="keyword">if</span> (nums[right] &gt;= target &amp;&amp; target &gt; nums[mid]) &#123;</span><br><span class="line">                    left = mid + <span class="number">1</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    right = mid - <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/03/aebfd954000d9b32c58a81cfa094adf3.png" alt="image.png"></p>]]></content>
    
    
    <summary type="html">leetcode的33搜索旋转排序数组</summary>
    
    
    
    <category term="编程学习" scheme="https://blog.musnow.top/categories/%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="把题目都给刷干净" scheme="https://blog.musnow.top/categories/%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0/%E6%8A%8A%E9%A2%98%E7%9B%AE%E9%83%BD%E7%BB%99%E5%88%B7%E5%B9%B2%E5%87%80/"/>
    
    
    <category term="OJ刷题" scheme="https://blog.musnow.top/tags/OJ%E5%88%B7%E9%A2%98/"/>
    
    <category term="leetcode" scheme="https://blog.musnow.top/tags/leetcode/"/>
    
    <category term="二分法" scheme="https://blog.musnow.top/tags/%E4%BA%8C%E5%88%86%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>【leetcode】895最大频率栈</title>
    <link href="https://blog.musnow.top/posts/1873646973/"/>
    <id>https://blog.musnow.top/posts/1873646973/</id>
    <published>2024-03-24T03:27:51.000Z</published>
    <updated>2024-03-25T01:33:59.000Z</updated>
    
    <content type="html"><![CDATA[<p>leetcode的895最大频率栈题解，题目来自快手面经：<a href="https://www.nowcoder.com/discuss/493925109460135936">https://www.nowcoder.com/discuss/493925109460135936</a></p><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><blockquote><p><a href="https://leetcode.cn/problems/maximum-frequency-stack/description/">895. 最大频率栈</a></p></blockquote><p>设计一个类似堆栈的数据结构，将元素推入堆栈，并从堆栈中弹出出现频率最高的元素。</p><p>实现 FreqStack 类:</p><ul><li>FreqStack() 构造一个空的堆栈。</li><li>void push(int val) 将一个整数 val 压入栈顶。</li><li>int pop() 删除并返回堆栈中出现频率最高的元素。</li></ul><p>如果出现频率最高的元素不只一个，则移除并返回最接近栈顶的元素。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">示例 1：</span><br><span class="line">输入：</span><br><span class="line">[&quot;FreqStack&quot;,&quot;push&quot;,&quot;push&quot;,&quot;push&quot;,&quot;push&quot;,&quot;push&quot;,&quot;push&quot;,&quot;pop&quot;,&quot;pop&quot;,&quot;pop&quot;,&quot;pop&quot;],</span><br><span class="line">[[],[5],[7],[5],[7],[4],[5],[],[],[],[]]</span><br><span class="line">输出：[null,null,null,null,null,null,null,5,7,5,4]</span><br><span class="line"></span><br><span class="line">解释：</span><br><span class="line">FreqStack = new FreqStack();</span><br><span class="line">freqStack.push (5);//堆栈为 [5]</span><br><span class="line">freqStack.push (7);//堆栈是 [5,7]</span><br><span class="line">freqStack.push (5);//堆栈是 [5,7,5]</span><br><span class="line">freqStack.push (7);//堆栈是 [5,7,5,7]</span><br><span class="line">freqStack.push (4);//堆栈是 [5,7,5,7,4]</span><br><span class="line">freqStack.push (5);//堆栈是 [5,7,5,7,4,5]</span><br><span class="line">freqStack.pop ();//返回 5 ，因为 5 出现频率最高。堆栈变成 [5,7,5,7,4]。</span><br><span class="line">freqStack.pop ();//返回 7 ，因为 5 和 7 出现频率最高，但7最接近顶部。堆栈变成 [5,7,5,4]。</span><br><span class="line">freqStack.pop ();//返回 5 ，因为 5 出现频率最高。堆栈变成 [5,7,4]。</span><br><span class="line">freqStack.pop ();//返回 4 ，因为 4, 5 和 7 出现频率最高，但 4 是最接近顶部的。堆栈变成 [5,7]。</span><br></pre></td></tr></table></figure><p>提示：</p><ul><li><code>0 &lt;= val &lt;= 109</code>;</li><li>push 和 pop 的操作数不大于 <code>2 * 104</code>。</li><li>输入保证在调用 pop 之前堆栈中至少有一个元素。</li></ul><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>看到hard直接害怕，题解一看发现好像没有那么难……就是让我自己想恐怕是想不出来的。</p><p>用哈希表加栈就能解决这个问题，另外还需一个int变量维护当前最高频率是多少。</p><ul><li>一个哈希表用于元素和频率的计数</li><li>一个哈希表用于频率和对应的栈</li></ul><p>当插入元素的时候</p><ul><li>元素出现频率加一</li><li>在对应频率的栈中插入元素（并不需要在之前的栈中删除元素）</li><li>更新当前最高频率</li></ul><p>当弹出元素的时候</p><ul><li>从最高频率的栈中弹出一个元素</li><li>该元素出现频率减一</li><li>如果最高频率的栈为空，则最高频率减一（因为每次都是以1的间隔增加的，所以减一的栈里面肯定会有元素）</li></ul><p>这样就能很巧妙的实现题目需要的栈。</p><ul><li>哈希表中频率从低到高能理解为是一层栈，因为后入的频率高的数在栈顶；</li><li>相同频率中又是一层栈；</li></ul><p>即可以体现每一个数字的频率，又能保证栈的先入先出的特性！</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>思路并不难，代码实现也很简单</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">FreqStack</span> &#123;</span><br><span class="line">    unordered_map&lt;<span class="type">int</span>,stack&lt;<span class="type">int</span>&gt;&gt; stMap; <span class="comment">// 每个频率都有一个栈</span></span><br><span class="line">    unordered_map&lt;<span class="type">int</span>,<span class="type">int</span>&gt; countMap; <span class="comment">// 频率计数</span></span><br><span class="line">    <span class="type">int</span> maxFreq = <span class="number">0</span>; <span class="comment">// 最高频率</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">FreqStack</span>() &#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(<span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 将某个数字的频率加一</span></span><br><span class="line">        countMap[val]++;</span><br><span class="line">        stMap[countMap[val]].<span class="built_in">push</span>(val);</span><br><span class="line">        maxFreq = <span class="built_in">max</span>(maxFreq,countMap[val]);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 从最高频率的栈中pop一个元素即可</span></span><br><span class="line">        <span class="type">int</span> val = stMap[maxFreq].<span class="built_in">top</span>();</span><br><span class="line">        stMap[maxFreq].<span class="built_in">pop</span>();</span><br><span class="line">        <span class="comment">// 频率减一</span></span><br><span class="line">        countMap[val]--;</span><br><span class="line">        <span class="comment">// 如果最大频率栈没有内容，则减一</span></span><br><span class="line">        <span class="keyword">if</span>(stMap[maxFreq].<span class="built_in">empty</span>())&#123;</span><br><span class="line">            maxFreq--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> val;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your FreqStack object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * FreqStack* obj = new FreqStack();</span></span><br><span class="line"><span class="comment"> * obj-&gt;push(val);</span></span><br><span class="line"><span class="comment"> * int param_2 = obj-&gt;pop();</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/03/4ad7ed2196fbbbced588884ca9441c12.png" alt="image.png"></p>]]></content>
    
    
    <summary type="html">leetcode的895最大频率栈题解</summary>
    
    
    
    <category term="编程学习" scheme="https://blog.musnow.top/categories/%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="把题目都给刷干净" scheme="https://blog.musnow.top/categories/%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0/%E6%8A%8A%E9%A2%98%E7%9B%AE%E9%83%BD%E7%BB%99%E5%88%B7%E5%B9%B2%E5%87%80/"/>
    
    
    <category term="OJ刷题" scheme="https://blog.musnow.top/tags/OJ%E5%88%B7%E9%A2%98/"/>
    
    <category term="栈" scheme="https://blog.musnow.top/tags/%E6%A0%88/"/>
    
    <category term="哈希" scheme="https://blog.musnow.top/tags/%E5%93%88%E5%B8%8C/"/>
    
    <category term="leetcode" scheme="https://blog.musnow.top/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>【leetcode】540.有序数组中的单一元素</title>
    <link href="https://blog.musnow.top/posts/3000154357/"/>
    <id>https://blog.musnow.top/posts/3000154357/</id>
    <published>2024-03-24T02:47:49.000Z</published>
    <updated>2024-03-25T02:05:18.000Z</updated>
    
    <content type="html"><![CDATA[<p>这道题是很久以前的快手CPP面经中出现的，在此记录一下咋写</p><blockquote><p><a href="https://www.nowcoder.com/discuss/353156663853129728?sourceSSR=users">https://www.nowcoder.com/discuss/353156663853129728?sourceSSR=users</a></p></blockquote><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><blockquote><p><a href="https://leetcode.cn/problems/single-element-in-a-sorted-array/">540. 有序数组中的单一元素</a></p></blockquote><p>给你一个仅由整数组成的有序数组，其中每个元素都会出现两次，唯有一个数只会出现一次。</p><p>请你找出并返回只出现一次的那个数。</p><p>你设计的解决方案必须满足 <code>O(log n)</code> 时间复杂度和 <code>O(1)</code> 空间复杂度。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">示例 1:</span><br><span class="line">输入: nums = [1,1,2,3,3,4,4,8,8]</span><br><span class="line">输出: 2</span><br><span class="line"></span><br><span class="line">示例 2:</span><br><span class="line">输入: nums =  [3,3,7,7,10,11,11]</span><br><span class="line">输出: 10</span><br></pre></td></tr></table></figure><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>这道题如果用暴力遍历的话，<code>O(N)</code>的时间复杂度很容易搞定，比如遍历一遍用map记录一下每个元素出现的次数，再遍历一遍map就能得到结果。</p><p>但是题目要求是用<code>O(log N)</code>的时间复杂度，这就没有办法直接遍历了。但题目中给出的数组是有序的，再加上<code>O(log N)</code>的时间复杂度，这就需要我们能想到用二分法来解决这道题。</p><p>现在确定是用二分法了，具体怎么二分呢？这又不是比大小找元素！</p><p>先观察一下给出的数组，以示例一为例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[1,1,2,3,3,4,4,8,8]</span><br></pre></td></tr></table></figure><p>将这个数组中的2补全，即所有元素都出现两次</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[1,1,2,2,3,3,4,4,8,8]</span><br><span class="line"> 0 1 2 3 4 5 6 7 8 9</span><br></pre></td></tr></table></figure><p>能发现一个规律：奇数下标上的数和前一个数相同，偶数下标上的数和后一个数相同。</p><p>那么对于不符合条件的数组，我们只需要判断mid（数组中间）的元素</p><ul><li>如果mid是奇数，判断它是否和<strong>前一个数</strong>相同，如果相同，则能确定<strong>只出现一次的数</strong>是在mid的后边，不同则在mid之前；</li><li>如果mid是偶数，判断它是否和<strong>后一个数</strong>相同，如果相同，则能确定<strong>只出现一次的数</strong>是在mid的后边，不同则在mid之前；</li></ul><p>思路确定了，就可以写代码了</p><h2 id="代码1-if-x2F-else"><a href="#代码1-if-x2F-else" class="headerlink" title="代码1-if&#x2F;else"></a>代码1-if&#x2F;else</h2><p>这里用if&#x2F;else实现上述思路比较好理解</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">singleNonDuplicate</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> left = <span class="number">0</span>, right = nums.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">            <span class="type">int</span> mid = (left + right) / <span class="number">2</span>;</span><br><span class="line">            <span class="comment">// cout &lt;&lt; left &lt;&lt; &quot; - &quot; &lt;&lt; right &lt;&lt; &quot; - &quot; &lt;&lt; mid &lt;&lt; &quot;\n&quot;;</span></span><br><span class="line">            <span class="comment">// 偶数</span></span><br><span class="line">            <span class="keyword">if</span> (mid % <span class="number">2</span> == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// 判断下一位是否和当前位相同</span></span><br><span class="line">                <span class="keyword">if</span> (nums[mid] == nums[mid + <span class="number">1</span>]) &#123;</span><br><span class="line">                    left = mid + <span class="number">1</span>; <span class="comment">// 相同，在右边</span></span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;            <span class="comment">// 不相同，在左边</span></span><br><span class="line">                    right = mid;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="comment">// 奇数</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// 判断上一位是否和当前位相同</span></span><br><span class="line">                <span class="keyword">if</span> (nums[mid] == nums[mid - <span class="number">1</span>]) &#123;</span><br><span class="line">                    left = mid + <span class="number">1</span>; <span class="comment">// 相同，在右边</span></span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;            <span class="comment">// 不相同，在左边</span></span><br><span class="line">                    right = mid;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 最终left所在位置就是题目需要的位置</span></span><br><span class="line">        <span class="keyword">return</span> nums[left];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/03/6378e71101d5d91c31187030f33a78ac.png" alt="image-20240324111139325"></p><h2 id="代码2-位运算"><a href="#代码2-位运算" class="headerlink" title="代码2-位运算"></a>代码2-位运算</h2><p>使用位运算可以统一的处理奇数和偶数，代码能更加简洁。使用异或运算（相异为一相同为零）：</p><ul><li>奇数异或1等于奇数减一（奇数末尾为1，异或1后末尾为0，相当于减一）</li><li>偶数异或1等于偶数加一（偶数末尾为0，异或1后末尾为1，相当于加一）</li></ul><p>这样能写出如下代码，直接确定mid应该和谁进行比较</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">singleNonDuplicate</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> left = <span class="number">0</span>, right = nums.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">            <span class="type">int</span> mid = (left + right) / <span class="number">2</span>;</span><br><span class="line">            <span class="comment">// 奇数异或1等于奇数减一，偶数异或1等于偶数加一</span></span><br><span class="line">            <span class="keyword">if</span> (nums[mid] == nums[mid ^ <span class="number">1</span>]) &#123;</span><br><span class="line">                left = mid + <span class="number">1</span>; <span class="comment">// 在右边</span></span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="comment">// 在左边</span></span><br><span class="line">            &#123;</span><br><span class="line">                right = mid;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nums[left];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/03/b9b05e7fefe9f03540a7d457a468192d.png" alt="image-20240324111454584"></p>]]></content>
    
    
    <summary type="html">leetcode 540.有序数组中的单一元素</summary>
    
    
    
    <category term="编程学习" scheme="https://blog.musnow.top/categories/%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="把题目都给刷干净" scheme="https://blog.musnow.top/categories/%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0/%E6%8A%8A%E9%A2%98%E7%9B%AE%E9%83%BD%E7%BB%99%E5%88%B7%E5%B9%B2%E5%87%80/"/>
    
    
    <category term="OJ刷题" scheme="https://blog.musnow.top/tags/OJ%E5%88%B7%E9%A2%98/"/>
    
    <category term="Cpp" scheme="https://blog.musnow.top/tags/Cpp/"/>
    
    <category term="leetcode" scheme="https://blog.musnow.top/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>【算法】回溯算法</title>
    <link href="https://blog.musnow.top/posts/1548282049/"/>
    <id>https://blog.musnow.top/posts/1548282049/</id>
    <published>2024-03-22T02:44:51.000Z</published>
    <updated>2024-04-06T08:38:29.000Z</updated>
    
    <content type="html"><![CDATA[<p>参考《代码随想录》。</p><h1 id="1-什么是回溯？"><a href="#1-什么是回溯？" class="headerlink" title="1.什么是回溯？"></a>1.什么是回溯？</h1><h2 id="1-1-引言"><a href="#1-1-引言" class="headerlink" title="1.1 引言"></a>1.1 引言</h2><p>回溯算法简单说来是通过递归进行遍历，他并不是一个高效的算法，因为整个遍历的过程是在穷举所有可能的结果。</p><p>在二叉树的OJ刷题博客中，就已经遇到了使用了回溯思路的题目。比如<a href="https://leetcode.cn/problems/path-sum/description/">Leetcode 112 路径总和</a>这道题，递归参数中的curSum就是利用回溯的的思路，从上层往下传的。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">traversal</span><span class="params">(TreeNode* cur, <span class="type">int</span> count)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!cur-&gt;left &amp;&amp; !cur-&gt;right &amp;&amp; count == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">true</span>; <span class="comment">// 遇到叶子节点，并且计数为0</span></span><br><span class="line">        <span class="keyword">if</span> (!cur-&gt;left &amp;&amp; !cur-&gt;right) <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">// 遇到叶子节点直接返回</span></span><br><span class="line">   <span class="comment">// 这里体现回溯的思想，先将要遍历的下一层的值添加进去，然后再撤销操作。这样能让下一层先判断自己是否为叶子节点来正确停止递归。</span></span><br><span class="line">        <span class="keyword">if</span> (cur-&gt;left) &#123; <span class="comment">// 左</span></span><br><span class="line">            count -= cur-&gt;left-&gt;val; <span class="comment">// 递归，处理节点;</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">traversal</span>(cur-&gt;left, count)) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            count += cur-&gt;left-&gt;val; <span class="comment">// 回溯，撤销处理结果</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (cur-&gt;right) &#123; <span class="comment">// 右</span></span><br><span class="line">            count -= cur-&gt;right-&gt;val; <span class="comment">// 递归，处理节点;</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">traversal</span>(cur-&gt;right, count)) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            count += cur-&gt;right-&gt;val; <span class="comment">// 回溯，撤销处理结果</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">hasPathSum</span><span class="params">(TreeNode* root, <span class="type">int</span> sum)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">traversal</span>(root, sum - root-&gt;val);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="1-2-什么问题用回溯能解决？"><a href="#1-2-什么问题用回溯能解决？" class="headerlink" title="1.2 什么问题用回溯能解决？"></a>1.2 什么问题用回溯能解决？</h2><p>回溯法，一般可以解决如下几种问题：</p><ul><li>组合问题：N个数里面按一定规则找出k个数的集合</li><li>切割问题：一个字符串按一定规则有几种切割方式</li><li>子集问题：一个N个数的集合里有多少符合条件的子集</li><li>排列问题：N个数按一定规则全排列，有几种排列方式</li><li>棋盘问题：N皇后，解数独等等</li></ul><p>这些问题一般都涉及到了切割和组合，可以把一个大的集合通过一定的选择（当前层）再往下一层切割（缩小范围）来解决。通过这个思路整体看来，回溯法就很类似树形结构，与二叉树的递归遍历类似。</p><h2 id="1-3-回溯法模板"><a href="#1-3-回溯法模板" class="headerlink" title="1.3 回溯法模板"></a>1.3 回溯法模板</h2><p>在代码随想录中Carl大佬总结了一个回溯法的模板，这里引用如下。</p><p>既然回溯法用的大多都是递归，那么就需要明确递归的三部曲</p><ul><li>递归的参数</li><li>递归的末端返回情况（终止条件）</li><li>递归的单层操作逻辑</li></ul><p>对于回溯法也是一样的</p><ul><li>回溯函数（递归函数）的参数</li><li>回溯函数的末端返回情况（终止条件）</li><li>回溯函数单层的选择（通常是遍历）</li></ul><p>所以回溯法的代码模板如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">void fallback(参数)</span><br><span class="line">&#123;</span><br><span class="line">if(终止条件)&#123;</span><br><span class="line">// 一般是存放结果到返回值数组中</span><br><span class="line">        return;</span><br><span class="line">&#125;</span><br><span class="line">// 单层逻辑</span><br><span class="line">for(循环逻辑，一般是树中节点孩子的数量就是当前层的处理数量)</span><br><span class="line">&#123;</span><br><span class="line">// 处理节点</span><br><span class="line">fallback(参数) // 递归下一层</span><br><span class="line">// 撤销操作</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="2-组合问题"><a href="#2-组合问题" class="headerlink" title="2.组合问题"></a>2.组合问题</h1><p>下面的编号都是leetcode的题目号</p><h2 id="77-组合问题"><a href="#77-组合问题" class="headerlink" title="77 组合问题"></a>77 组合问题</h2><h3 id="题目和思路"><a href="#题目和思路" class="headerlink" title="题目和思路"></a>题目和思路</h3><blockquote><p><a href="https://leetcode.cn/problems/combinations/">77. 组合</a></p></blockquote><p>给定两个整数 <code>n</code> 和 <code>k</code>，返回范围 <code>[1, n]</code> 中所有可能的 <code>k</code> 个数的组合。</p><p>你可以按 <strong>任何顺序</strong> 返回答案。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">示例 1：</span><br><span class="line">输入：n = 4, k = 2</span><br><span class="line">输出：</span><br><span class="line">[</span><br><span class="line">  [2,4],</span><br><span class="line">  [3,4],</span><br><span class="line">  [2,3],</span><br><span class="line">  [1,2],</span><br><span class="line">  [1,3],</span><br><span class="line">  [1,4],</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">示例 2：</span><br><span class="line">输入：n = 1, k = 1</span><br><span class="line">输出：[[1]]</span><br></pre></td></tr></table></figure><p>这道题用循环暴力也不是不能写，但是一层K就需要多写一层循环，很难实现一个通用的暴力算法。所以需要用到递归的回溯算法来解决这道题。</p><p>这里直接借用一下代码随想录的图，每一层遍历就选择一个数字，再往下一层从这个值往后选择，直到长度为K或循环超出边界。</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/03/e2aecbc992ef998255f12b7dc1deab95.png" alt="image-20240322105026000"></p><p>根据这个思路，递归函数的参数如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// n 和 k 是题目的参数</span></span><br><span class="line"><span class="comment">// start 是本层循环中开始循环的值（左边界）</span></span><br><span class="line"><span class="comment">// curV 保存当前递归的集合，这里不能采用引用传参，因为上一层会进行回溯撤销</span></span><br><span class="line"><span class="comment">// retV 保存最终的结果，使用引用传参；</span></span><br><span class="line"><span class="type">void</span> _combine(<span class="type">int</span> n,<span class="type">int</span> k,<span class="type">int</span> start,<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt; curV,<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;&gt;&amp; retV)</span><br></pre></td></tr></table></figure><p>递归的终止条件是curV中的元素个数等于K了（找到了一个符合条件的集合），就将curV插入到retV中。因为这里的curV传的不是引用，所以也不存在需要清空curV的操作。</p><blockquote><p>因为我们是通过递归来进行curV的插入操作的，所以同一个元素不会在一个集合中被多次插入，不需要考虑去重的问题。</p></blockquote><p>另外，还有一个隐含的终止条件是start大于n了，这在for循环的条件中就能体现出来，不需要单独处理。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = start;i&lt;=n;i++)</span><br></pre></td></tr></table></figure><p>每一层要做的事情就是从这个数字序列中选一个数出来插入当前数组curV，然后递归遍历下一层。调用完毕递归函数后，需要撤销当前选择的数，避免影响下一轮循环。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将当前值插入，然后递归进行下一次处理</span></span><br><span class="line">curV.push_back(i);</span><br><span class="line"><span class="comment">// 这里应该从当前遍历值的下一个开始继续操作</span></span><br><span class="line">_combine(n,k,i+<span class="number">1</span>,curV,retV);</span><br><span class="line">curV.pop_back(); <span class="comment">// 回溯，撤销这一次操作</span></span><br></pre></td></tr></table></figure><h3 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h3><p>代码如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// curV不需要加引用，因为是回溯算法</span></span><br><span class="line">    <span class="type">void</span> _combine(<span class="type">int</span> n,<span class="type">int</span> k,<span class="type">int</span> start,vector&lt;<span class="type">int</span>&gt; curV,vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; retV)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 数量足够，插入结果集</span></span><br><span class="line">        <span class="keyword">if</span>(curV.<span class="built_in">size</span>() == k)&#123;</span><br><span class="line">            retV.<span class="built_in">push_back</span>(curV);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 遍历进行回溯</span></span><br><span class="line">        <span class="comment">// for(int i = start;i&lt;=n;i++) // 正常遍历</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 剪枝操作，如果下一层剩下的都不足k个了，那就不需要继续了</span></span><br><span class="line">        <span class="comment">// 比如这一层是1 2 3 4，选择了3后只剩4，但k=4，此时完全不够长度，这次遍历是没有意义的</span></span><br><span class="line">        <span class="comment">// 计算n减去k还需要多少个，就能削减掉下一层不够用的情况</span></span><br><span class="line">        <span class="comment">// https://www.programmercarl.com/0077.%E7%BB%84%E5%90%88.html#%E6%80%9D%E8%B7%AF</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = start;i&lt;=n -(k-curV.<span class="built_in">size</span>()<span class="number">-1</span>);i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 将当前值插入，然后递归进行下一次处理</span></span><br><span class="line">            curV.<span class="built_in">push_back</span>(i);</span><br><span class="line">            <span class="comment">// 这里应该从当前遍历值的下一个开始继续操作</span></span><br><span class="line">            _combine(n,k,i+<span class="number">1</span>,curV,retV);</span><br><span class="line">            curV.<span class="built_in">pop_back</span>(); <span class="comment">// 回溯，撤销这一次操作</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">combine</span>(<span class="type">int</span> n, <span class="type">int</span> k) &#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; retV;</span><br><span class="line">        <span class="comment">// 注意，题目给的范围是1到n</span></span><br><span class="line">        _combine(n,k,<span class="number">1</span>,<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(),retV);</span><br><span class="line">        <span class="keyword">return</span> retV;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/03/c5811aab6d8e76c042df2c650c64a57a.png" alt="image-20240322112408032"></p><h3 id="剪枝操作"><a href="#剪枝操作" class="headerlink" title="剪枝操作"></a>剪枝操作</h3><p>这里对如下for循环的<strong>剪枝操作</strong>做说明</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = start;i &lt;= n-(k-curV.size()<span class="number">-1</span>);i++)</span><br></pre></td></tr></table></figure><p>题目要求的是k个数的组合，当前还需要的数字的个数是<code>k-curV.size()</code>，<strong>除去当前层以外</strong>（这里确定的是循环边界，进循环后就会处理当前层），还需要<code>k-curV.size()-1</code>个数字。</p><p>也就是说，我们需要保证递归处理的<strong>下一层</strong>还能有<code>k-curV.size()-1</code>个数字供处理，如果没有，那么<strong>下一层就不需要进去了</strong>，因为下一层是没有意义的递归，会浪费时间和压栈消耗。</p><p>这个思路可以参考下图，当<code>N=4, K=3</code>的时候，选择3时下一层只剩一个数字4了，肯定找不到符合条件的K&#x3D;3长度的集合，所以在第一层遍历的时候，就可以直接跳过3和3之后的数字，不进行遍历回溯。</p><p>这个计算也比较简单，下一层还需要2个，那就N-2就行了；下一层还需要3个就是N-3（留了最后三个不用）。题目给的N是一个闭区间，不需要额外处理。</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/03/75a031ea3bd57221f044a733a474815c.png" alt="image-20240322103240017"></p><p>反应到代码上，for循环的边界值就成了<code>n-(k-curV.size()-1)</code>，这样就能保证无论如何往下的递归一定能找到至少一个符合长度为K的集合。</p><p>在代码随想录网站上，描述的是用<code> n - (k - path.size()) + 1</code>这个边界进行剪枝，这个公式和上面我提供的公式是一致的，个人感觉我的那个公式的思路更好理解一些。</p><h2 id="216-组合总和3"><a href="#216-组合总和3" class="headerlink" title="216 组合总和3"></a>216 组合总和3</h2><h3 id="题目和思路-1"><a href="#题目和思路-1" class="headerlink" title="题目和思路"></a>题目和思路</h3><blockquote><p><a href="https://leetcode.cn/problems/combination-sum-iii/">216. 组合总和 III</a></p></blockquote><p>找出所有相加之和为 <code>n</code> 的 <code>k</code> 个数的组合，且满足下列条件：</p><ul><li>只使用数字1到9</li><li>每个数字 <strong>最多使用一次</strong></li></ul><p>返回 <em>所有可能的有效组合的列表</em> 。该列表不能包含相同的组合两次，组合可以以任何顺序返回。</p><hr><p>这道题和上一题基本一致，上一题给出的n是1到n的边界，这道题锁定了边界是1到9，额外多了一个要求是k个数的和要为n。</p><p>题目中还有个要求是每个数组最多使用一次，这也和我们回溯算法的思路一致，因为是从上层往下每次选用一个数进行递归的，并不会出现同一个数使用多次的情况。</p><h3 id="代码模板"><a href="#代码模板" class="headerlink" title="代码模板"></a>代码模板</h3><p>递归函数的参数和上一道题目一致，多了一个sum用于保存当前数组内元素的和</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// n 和 k 是题目的参数</span></span><br><span class="line"><span class="comment">// start 是本层循环中开始循环的值（左边界）</span></span><br><span class="line"><span class="comment">// sum  当前curV数组内元素的和</span></span><br><span class="line"><span class="comment">// curV 保存当前递归的集合，这里不能采用引用传参，因为上一层会进行回溯撤销</span></span><br><span class="line"><span class="comment">// retV 保存最终的结果，使用引用传参；</span></span><br><span class="line"><span class="type">void</span> _combinationSum3(<span class="type">int</span> k, <span class="type">int</span> n,<span class="type">int</span> start,<span class="type">int</span> sum, vector&lt;<span class="type">int</span>&gt; curV,vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; retV )</span><br></pre></td></tr></table></figure><p>递归的终止条件是curV中的元素大小等于k，然后判断成员的和是否为n，如果为n才插入返回值数组retV。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(curV.<span class="built_in">size</span>() == k)&#123;</span><br><span class="line">    <span class="keyword">if</span>(sum == n)&#123;</span><br><span class="line">        retV.<span class="built_in">push_back</span>(curV);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一行的遍历也是一样的，将当前值插入数组，然后递归道下一层，并将当前层的操作撤销</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = start;i&lt;=<span class="number">9</span>;i++)</span><br><span class="line">      &#123;</span><br><span class="line">          <span class="comment">// 单层操作</span></span><br><span class="line">          curV.<span class="built_in">push_back</span>(i);</span><br><span class="line">          sum += i; </span><br><span class="line">          <span class="comment">// 递归下一层</span></span><br><span class="line">          _combinationSum3(k,n,i+<span class="number">1</span>,sum,curV,retV);</span><br><span class="line">          <span class="comment">// 撤销</span></span><br><span class="line">          curV.<span class="built_in">pop_back</span>();</span><br><span class="line">          sum -= i;</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure><p>上述代码可以进行简化，对sum的操作改为直接在传值的时候加一下i；</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = start;i&lt;=<span class="number">9</span>;i++)</span><br><span class="line">&#123;</span><br><span class="line">    curV.<span class="built_in">push_back</span>(i);</span><br><span class="line">    _combinationSum3(k,n,i+<span class="number">1</span>,sum+i,curV,retV);</span><br><span class="line">    curV.<span class="built_in">pop_back</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="完整代码-1"><a href="#完整代码-1" class="headerlink" title="完整代码"></a>完整代码</h3><p>完整代码如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="type">void</span> _combinationSum3(<span class="type">int</span> k, <span class="type">int</span> n,<span class="type">int</span> start,<span class="type">int</span> sum, vector&lt;<span class="type">int</span>&gt; curV,vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; retV ) &#123; </span><br><span class="line">        <span class="keyword">if</span>(curV.<span class="built_in">size</span>() == k)&#123;</span><br><span class="line">            <span class="keyword">if</span>(sum == n)&#123;</span><br><span class="line">                retV.<span class="built_in">push_back</span>(curV);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 一次遍历</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = start;i&lt;=<span class="number">9</span>;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            curV.<span class="built_in">push_back</span>(i);</span><br><span class="line">            _combinationSum3(k,n,i+<span class="number">1</span>,sum+i,curV,retV);</span><br><span class="line">            curV.<span class="built_in">pop_back</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">combinationSum3</span>(<span class="type">int</span> k, <span class="type">int</span> n) &#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; retV;</span><br><span class="line">        _combinationSum3(k,n,<span class="number">1</span>,<span class="number">0</span>,<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(),retV);</span><br><span class="line">        <span class="keyword">return</span> retV;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/03/5647647f20a4d1f98bbdec6206e98f4d.png" alt="image-20240322145222332"></p><h3 id="剪枝操作-1"><a href="#剪枝操作-1" class="headerlink" title="剪枝操作"></a>剪枝操作</h3><p>和77题一样，上述的代码也能进行剪枝操作。分别针对的是k个数字和n的值</p><ul><li>下一层不够<code>k-curV.size()</code>个数字的时候就不需要递归下一层了。</li><li>当前加上i之后已经超过sum了就不需要递归下一层了。</li></ul><p>优化后的代码如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="type">void</span> _combinationSum3(<span class="type">int</span> k, <span class="type">int</span> n,<span class="type">int</span> start,<span class="type">int</span> sum, vector&lt;<span class="type">int</span>&gt; curV,vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; retV ) &#123; </span><br><span class="line">        <span class="keyword">if</span>(curV.<span class="built_in">size</span>() == k)&#123;</span><br><span class="line">            <span class="keyword">if</span>(sum == n)&#123;</span><br><span class="line">                retV.<span class="built_in">push_back</span>(curV);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 已经不符合条件，不进入循环</span></span><br><span class="line">        <span class="keyword">if</span>(sum &gt; n)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 一次遍历</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = start;i&lt;=<span class="number">9</span> -(k-curV.<span class="built_in">size</span>()<span class="number">-1</span>);i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 已经不符合条件，进入下一层</span></span><br><span class="line">            <span class="keyword">if</span>(sum + i &gt; n)&#123;</span><br><span class="line">                <span class="keyword">return</span>; <span class="comment">// 加i都已经超过n了，下一个数也没有必要遍历了</span></span><br><span class="line">            &#125;</span><br><span class="line">         </span><br><span class="line">            curV.<span class="built_in">push_back</span>(i);</span><br><span class="line">            _combinationSum3(k,n,i+<span class="number">1</span>,sum+i,curV,retV);</span><br><span class="line">            curV.<span class="built_in">pop_back</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">combinationSum3</span>(<span class="type">int</span> k, <span class="type">int</span> n) &#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; retV;</span><br><span class="line">        _combinationSum3(k,n,<span class="number">1</span>,<span class="number">0</span>,<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(),retV);</span><br><span class="line">        <span class="keyword">return</span> retV;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="17-电话号码的数字组合"><a href="#17-电话号码的数字组合" class="headerlink" title="17 电话号码的数字组合"></a>17 电话号码的数字组合</h2><h3 id="题目和思路-2"><a href="#题目和思路-2" class="headerlink" title="题目和思路"></a>题目和思路</h3><blockquote><p><a href="https://leetcode.cn/problems/letter-combinations-of-a-phone-number/">17. 电话号码的字母组合</a></p></blockquote><p>给定一个仅包含数字 <code>2-9</code> 的字符串，返回所有它能表示的字母组合。答案可以按 <strong>任意顺序</strong> 返回。</p><p>给出数字到字母的映射如下（与电话按键相同）。注意 1 不对应任何字母。</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/03/908402445c0fbd05c009b3852bcb0e18.png" alt="image-20240322145712851"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">示例 1：</span><br><span class="line">输入：digits = &quot;23&quot;</span><br><span class="line">输出：[&quot;ad&quot;,&quot;ae&quot;,&quot;af&quot;,&quot;bd&quot;,&quot;be&quot;,&quot;bf&quot;,&quot;cd&quot;,&quot;ce&quot;,&quot;cf&quot;]</span><br><span class="line"></span><br><span class="line">示例 2：</span><br><span class="line">输入：digits = &quot;&quot;</span><br><span class="line">输出：[]</span><br><span class="line"></span><br><span class="line">示例 3：</span><br><span class="line">输入：digits = &quot;2&quot;</span><br><span class="line">输出：[&quot;a&quot;,&quot;b&quot;,&quot;c&quot;]</span><br></pre></td></tr></table></figure><ul><li><code>0 &lt;= digits.length &lt;= 4</code></li><li><code>digits[i]</code> 是范围 <code>[&#39;2&#39;, &#39;9&#39;]</code> 的一个数字。</li></ul><hr><p>在早些年没有只能手机的时候，功能机一般都是九键的键盘（如上图所示），当时如果想在上面打字发短信，就需要按一个键来代表它下面的英文字母。比如你想打出字母h，就需要按4号键两次（第一次选中的是g，第二次是h）才能打出来。现在智能手机的九键键盘也是从这个设计思路衍生出来的，主要目的是增大屏幕上每个按键的大小，减少误触。</p><blockquote><p>题外话：作为00后还算是用过这种东西，在我高中之前用的都是功能机，当时父母为了不让我玩游戏没给我买智能手机。不过这不影响我在功能机上玩贪吃蛇和五子棋，哈哈。</p></blockquote><p>这道题就是让你算出来按下某个数字按键，他能打出什么字母组合的。</p><p>还是用回溯的思想，首先需要一个字符串数组来记录每一个按键对应的字母值。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;string&gt; num2str = &#123;</span><br><span class="line">        <span class="string">&quot;&quot;</span>, <span class="comment">/* 0 */</span></span><br><span class="line">        <span class="string">&quot;&quot;</span>, <span class="comment">/* 1 */</span></span><br><span class="line">        <span class="string">&quot;abc&quot;</span>,</span><br><span class="line">        <span class="string">&quot;def&quot;</span>,</span><br><span class="line">        <span class="string">&quot;ghi&quot;</span>,</span><br><span class="line">        <span class="string">&quot;jkl&quot;</span>,</span><br><span class="line">        <span class="string">&quot;mno&quot;</span>,</span><br><span class="line">        <span class="string">&quot;pqrs&quot;</span>,</span><br><span class="line">        <span class="string">&quot;tuv&quot;</span>,</span><br><span class="line">        <span class="string">&quot;wxyz&quot;</span></span><br><span class="line">    &#125;;</span><br></pre></td></tr></table></figure><p>对于这道题而言，每一次需要遍历的数组是对应数字的字符串，在这个字符串中选择一个字符后，往下一层遍历就行了。</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/03/03f0b9f54b359f787fa65db16b1aad7b.png" alt="image-20240322150726967"></p><h3 id="代码模板-1"><a href="#代码模板-1" class="headerlink" title="代码模板"></a>代码模板</h3><p>首先是递归函数的参数，包括题目传入的字符串（理解为char的数组就行），当前遍历的下标（题目给出的字符串内的下标），当前的字符串（不能用引用传参），以及最终的返回值数组</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> _letterCombinations(<span class="type">const</span> string&amp; digits,<span class="type">int</span> index,string str,vector&lt;string&gt;&amp; retV)</span><br></pre></td></tr></table></figure><p>因为leetcode的c++题解都是有一个solution类的，所以retV这类返回值完全可以用一个类的成员变量来替代，可以节省一个递归的参数（虽然没有太大区别）</p><p>递归函数的终止条件是index大于digits的长度（下标越界）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(index &gt;= digits.<span class="built_in">size</span>())&#123;</span><br><span class="line">    retV.<span class="built_in">push_back</span>(str);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一层遍历中的处理如下，这里我单独判断处理了1（但题目给出的用例中其实不包含0和1），注意每一层遍历的字符串并不是digits，而是当前数字在键盘中对应的字母字符串。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 通过ascii的计算得出当前数字，并找到curStr中映射的字符串</span></span><br><span class="line"><span class="type">int</span> num = digits[index] - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line"><span class="keyword">if</span>(num &lt; <span class="number">2</span>) <span class="comment">// 没有对应的</span></span><br><span class="line">&#123;</span><br><span class="line">    retV.<span class="built_in">push_back</span>(str);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 一层的遍历</span></span><br><span class="line">string&amp; curStr = num2str[num];</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i&lt;curStr.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">    str.<span class="built_in">push_back</span>(curStr[i]);</span><br><span class="line">    _letterCombinations(digits,index+<span class="number">1</span>,str,retV);</span><br><span class="line">    str.<span class="built_in">pop_back</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="完整代码-2"><a href="#完整代码-2" class="headerlink" title="完整代码"></a>完整代码</h3><p>完整代码如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    vector&lt;string&gt; num2str = &#123;</span><br><span class="line">        <span class="string">&quot;&quot;</span>, <span class="comment">/* 0 */</span></span><br><span class="line">        <span class="string">&quot;&quot;</span>, <span class="comment">/* 1 */</span></span><br><span class="line">        <span class="string">&quot;abc&quot;</span>,</span><br><span class="line">        <span class="string">&quot;def&quot;</span>,</span><br><span class="line">        <span class="string">&quot;ghi&quot;</span>,</span><br><span class="line">        <span class="string">&quot;jkl&quot;</span>,</span><br><span class="line">        <span class="string">&quot;mno&quot;</span>,</span><br><span class="line">        <span class="string">&quot;pqrs&quot;</span>,</span><br><span class="line">        <span class="string">&quot;tuv&quot;</span>,</span><br><span class="line">        <span class="string">&quot;wxyz&quot;</span></span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="type">void</span> _letterCombinations(<span class="type">const</span> string&amp; digits,<span class="type">int</span> index,string str,vector&lt;string&gt;&amp; retV) &#123;</span><br><span class="line">        <span class="keyword">if</span>(index &gt;= digits.<span class="built_in">size</span>())&#123;</span><br><span class="line">            retV.<span class="built_in">push_back</span>(str);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 通过ascii的计算得出当前数字，并找到curStr中映射的字符串</span></span><br><span class="line">        <span class="type">int</span> num = digits[index] - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">        <span class="keyword">if</span>(num &lt; <span class="number">2</span>) <span class="comment">// 没有对应的</span></span><br><span class="line">        &#123;</span><br><span class="line">            retV.<span class="built_in">push_back</span>(str);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 一层的遍历</span></span><br><span class="line">        string&amp; curStr = num2str[num];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i&lt;curStr.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            str.<span class="built_in">push_back</span>(curStr[i]);</span><br><span class="line">            _letterCombinations(digits,index+<span class="number">1</span>,str,retV);</span><br><span class="line">            str.<span class="built_in">pop_back</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;string&gt; <span class="title">letterCombinations</span><span class="params">(string digits)</span> </span>&#123;</span><br><span class="line">        vector&lt;string&gt; retV;</span><br><span class="line">        <span class="comment">// 单独判断一下空字符串</span></span><br><span class="line">        <span class="keyword">if</span>(digits == <span class="string">&quot;&quot;</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> retV;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        _letterCombinations(digits,<span class="number">0</span>,<span class="string">&quot;&quot;</span>,retV);</span><br><span class="line">        <span class="keyword">return</span> retV;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/03/c92703d3a59494e906d3abb632f557bf.png" alt="image-20240322151941756"></p><p>因为这道题每一次遍历的都不一定是同一个字符串，所以不存在剪枝操作，只能通过递归遍历完毕整个digits字符串。</p><h2 id="39-组合总和"><a href="#39-组合总和" class="headerlink" title="39 组合总和"></a>39 组合总和</h2><h3 id="题目和思路-3"><a href="#题目和思路-3" class="headerlink" title="题目和思路"></a>题目和思路</h3><blockquote><p><a href="https://leetcode.cn/problems/combination-sum/">39. 组合总和</a></p></blockquote><p>给你一个 <strong>无重复元素</strong> 的整数数组 <code>candidates</code> 和一个目标整数 <code>target</code> ，找出 <code>candidates</code> 中可以使数字和为目标数 <code>target</code> 的 所有 <strong>不同组合</strong> ，并以列表形式返回。你可以按 <strong>任意顺序</strong> 返回这些组合。</p><p><code>candidates</code> 中的 <strong>同一个</strong> 数字可以 <strong>无限制重复被选取</strong> 。如果至少一个数字的被选数量不同，则两种组合是不同的。 </p><p>对于给定的输入，保证和为 <code>target</code> 的不同组合数少于 <code>150</code> 个。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">示例 1：</span><br><span class="line">输入：candidates = [2,3,6,7], target = 7</span><br><span class="line">输出：[[2,2,3],[7]]</span><br><span class="line">解释：</span><br><span class="line">2 和 3 可以形成一组候选，2 + 2 + 3 = 7 。注意 2 可以使用多次。</span><br><span class="line">7 也是一个候选， 7 = 7 。</span><br><span class="line">仅有这两种组合。</span><br><span class="line"></span><br><span class="line">示例 2：</span><br><span class="line">输入: candidates = [2,3,5], target = 8</span><br><span class="line">输出: [[2,2,2,2],[2,3,3],[3,5]]</span><br><span class="line"></span><br><span class="line">示例 3：</span><br><span class="line">输入: candidates = [2], target = 1</span><br><span class="line">输出: []</span><br></pre></td></tr></table></figure><h3 id="错误代码"><a href="#错误代码" class="headerlink" title="错误代码"></a>错误代码</h3><p>这道题还是用回溯，和上面的组合问题的代码基本一致。</p><ul><li>和等于target的时候终止递归</li><li>每一层都遍历数组，而且可以选择上一层已经选过的数。</li><li>注意本题需要加的是<strong>数组元素</strong>的值，不是for循环里面的<code>i</code>；</li></ul><p>刚开始我写出来了一个错误的代码，主要是看循环部分，我这里选用了每一层都直接重新遍历整个数组，这是不对的！</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="type">void</span> _combinationSum(vector&lt;<span class="type">int</span>&gt;&amp; candidates, <span class="type">int</span> target, <span class="type">int</span> sum,</span><br><span class="line">                         vector&lt;<span class="type">int</span>&gt; curV, vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; retV) &#123;</span><br><span class="line">        <span class="comment">// 值相等，插入</span></span><br><span class="line">        <span class="keyword">if</span> (sum == target) &#123;</span><br><span class="line">            retV.<span class="built_in">push_back</span>(curV);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 值已经大于了，不进入</span></span><br><span class="line">        <span class="keyword">if</span> (sum &gt; target) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 每一层都是直接重新遍历整个数组</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; candidates.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="comment">// 值已经大于了，不进入</span></span><br><span class="line">            <span class="keyword">if</span> (sum + candidates[i] &gt; target) &#123;</span><br><span class="line">                <span class="keyword">continue</span>; <span class="comment">// 数组不一定是升序排列的，所以还需要往后走</span></span><br><span class="line">            &#125;</span><br><span class="line">            curV.<span class="built_in">push_back</span>(candidates[i]);</span><br><span class="line">            _combinationSum(candidates, target, sum + candidates[i], curV, retV);</span><br><span class="line">            curV.<span class="built_in">pop_back</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">combinationSum</span>(vector&lt;<span class="type">int</span>&gt;&amp; candidates, <span class="type">int</span> target) &#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; retV;</span><br><span class="line">        <span class="keyword">if</span> (candidates.<span class="built_in">size</span>() == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> retV;</span><br><span class="line">        &#125;</span><br><span class="line">        _combinationSum(candidates, target, <span class="number">0</span>, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(), retV);</span><br><span class="line">        <span class="keyword">return</span> retV;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>哪怕是最简单的用例都错误了，肯定是有问题。</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/03/95abe26e517ae6b3f08db67377046257.png" alt="image-20240322153818632"></p><p>问题出在哪儿呢？先不说会有很多无效的递归。以上图用例举例，如果这一层选择了3，下一层还是从最开始选取，那么就会出现<code>3,2,...</code>这种选取方式，但这个选取如果有结果的话，那么这个结果在当时选择从2开始时<strong>就已经得到过一次</strong>了。</p><p>注意题目要求如果一个结果集中数字出现的次数相同则视为一个，即<code>[3,2,3]</code>和<code>[3,3,2]</code>是同一个结果，这两个结果在返回值数组中只能出现一次。上图的输出中就出现了这种重复的结果集，<strong>不符合题目的条件</strong>。</p><h3 id="正确代码"><a href="#正确代码" class="headerlink" title="正确代码"></a>正确代码</h3><p>这就要求我们修改思路了，上面的代码最大的问题是没有进行切分，每一层都还是一个完整的数组。只需要按之前的思路对每一层进行切分，就能解决。</p><p>首先是递归函数的参数中需要多一个starti，用来记录上一层是从哪一个数开始的</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> _combinationSum(vector&lt;<span class="type">int</span>&gt;&amp; candidates, <span class="type">int</span> target, <span class="type">int</span> sum,</span><br><span class="line">                     <span class="type">int</span> starti,vector&lt;<span class="type">int</span>&gt; curV, </span><br><span class="line">                     vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; retV)</span><br></pre></td></tr></table></figure><p>for循环中也需要修改，因为题目允许同一个数被选用多次，这里我们直接从starti开始选则，并且传参给下一层的时候，也不需要对i进行加一操作（这样下一层可以选择和上层相同的数字，也不会往前选择），就是正确的思路了！</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 每一层都是直接重新遍历整个数组</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = starti; i &lt; candidates.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">    <span class="comment">// 值已经大于了，不进入</span></span><br><span class="line">    <span class="keyword">if</span> (sum + candidates[i] &gt; target) &#123;</span><br><span class="line">        <span class="keyword">continue</span>; <span class="comment">// 数组不一定是升序排列的，所以还需要往后走</span></span><br><span class="line">    &#125;</span><br><span class="line">    curV.<span class="built_in">push_back</span>(candidates[i]);</span><br><span class="line">    _combinationSum(candidates, target, sum + candidates[i], i, curV,</span><br><span class="line">                    retV);</span><br><span class="line">    curV.<span class="built_in">pop_back</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最终完整的代码如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="type">void</span> _combinationSum(vector&lt;<span class="type">int</span>&gt;&amp; candidates, <span class="type">int</span> target, <span class="type">int</span> sum,</span><br><span class="line">                         <span class="type">int</span> starti, vector&lt;<span class="type">int</span>&gt; curV,</span><br><span class="line">                         vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; retV) &#123;</span><br><span class="line">        <span class="comment">// 值相等，插入</span></span><br><span class="line">        <span class="keyword">if</span> (sum == target) &#123;</span><br><span class="line">            retV.<span class="built_in">push_back</span>(curV);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 值已经大于了，不进入</span></span><br><span class="line">        <span class="keyword">if</span> (sum &gt; target) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 每一层都是直接重新遍历整个数组</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = starti; i &lt; candidates.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="comment">// 值已经大于了，不进入</span></span><br><span class="line">            <span class="keyword">if</span> (sum + candidates[i] &gt; target) &#123;</span><br><span class="line">                <span class="keyword">continue</span>; <span class="comment">// 数组不一定是升序排列的，所以还需要往后走</span></span><br><span class="line">            &#125;</span><br><span class="line">            curV.<span class="built_in">push_back</span>(candidates[i]);</span><br><span class="line">            _combinationSum(candidates, target, sum + candidates[i], i, curV,</span><br><span class="line">                            retV);</span><br><span class="line">            curV.<span class="built_in">pop_back</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">combinationSum</span>(vector&lt;<span class="type">int</span>&gt;&amp; candidates, <span class="type">int</span> target) &#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; retV;</span><br><span class="line">        <span class="keyword">if</span> (candidates.<span class="built_in">size</span>() == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> retV;</span><br><span class="line">        &#125;</span><br><span class="line">        _combinationSum(candidates, target, <span class="number">0</span>, <span class="number">0</span>, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(), retV);</span><br><span class="line">        <span class="keyword">return</span> retV;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/03/e3c8e0fd8756bbe9b90963fb7c27ba8e.png" alt="image-20240322154233646"></p><p>这道题的剪枝思路在上述代码中已经体现了，即当前值已经大于target了，就不需要进入下一次递归了。注意这里要用continue而不是直接return，因为题目给定的数组不一定是升序排列的，如果直接return可能会错过结果集。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 值已经大于了，不进入</span></span><br><span class="line"><span class="keyword">if</span> (sum + candidates[i] &gt; target) &#123;</span><br><span class="line"><span class="keyword">continue</span>; <span class="comment">// 数组不一定是升序排列的，所以还需要往后走</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="40-组合总和2"><a href="#40-组合总和2" class="headerlink" title="40 组合总和2"></a>40 组合总和2</h2><h3 id="题目和思路-4"><a href="#题目和思路-4" class="headerlink" title="题目和思路"></a>题目和思路</h3><blockquote><p><a href="https://leetcode.cn/problems/combination-sum-ii/">40. 组合总和 II</a></p></blockquote><p>给定一个候选人编号的集合 <code>candidates</code> 和一个目标数 <code>target</code> ，找出 <code>candidates</code> 中所有可以使数字和为 <code>target</code> 的组合。</p><p><code>candidates</code> 中的每个数字在每个组合中只能使用 <strong>一次</strong> 。</p><p><strong>注意：</strong>解集不能包含重复的组合。 </p><hr><p>这道题并不能简单的从上道39题目修改而来，因为题目给出的candidates数组有不同，在39题中，candidates数组是没有重复元素的，但这道题中有重复元素，组合内也允许出现重复元素，但最终返回值内的<strong>组合不能重复</strong>，这就在<strong>去重</strong>方面给了我们更多的要求。</p><ul><li>candidates数组中可能会有重复的元素；</li><li>下一层不能再选取相同的元素（对应代码中的i需要加一后传入下一层）；</li><li>返回值中的每个组合中可以出现重复元素；</li><li>返回值中<strong>相同的组合</strong>不能出现多次；</li></ul><p>一个比较简单的思路是用map或者set对最终的组合进行一次去重。在用例简单的时候，这样做不会超时，但用例多一点，再多来一次单独的去重操作就很容易超时了，所以最好是在遍历的时候就解决这个问题。</p><p>下图是代码随想录中的图（我自己画了老半天感觉画的很烂，还是借用一下老哥的图吧），主要的去重思路是，<strong>每一层选用的数需要进行去重</strong>，但下一层和上一层之间不需要去重。</p><p>比如第一层选用了第一个1后，第二层需要在<code>[1,2]</code>中选用，此时第二层依旧可以选用1；但是第一层往后的遍历中，数组的第二个1就不能选用了，应跳过。</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/03/47894f830f881ab3283894df07ba1ad0.png" alt="image-20240324100837881"></p><p>代码随想录中讲述到的思路是使用一个bool类型的used数组来实现这个功能，我觉得实在是麻烦且不是很好理解。</p><p>当然代码随想录后面还有一个比较简单的思路，也是我能想到的，即在for循环中直接判断<strong>当前数和上一个数是否相等</strong>来去重（跳过相等的情况）。对于回溯算法而言，每一次的for循环就是每一层了，符合题目需要的去重条件。</p><p>注意，使用这个办法需要将题目给出的数组进行<strong>排序</strong>（题目并没有保证给出的数组是有序的）。</p><h3 id="完整代码-3"><a href="#完整代码-3" class="headerlink" title="完整代码"></a>完整代码</h3><p>回溯递归的代码如下，在for循环中判断一下当前选用的元素和上一个是否相等就可以了。注意这里需要判断的是<code>i&gt;starti</code>而不是<code>i&gt;0</code>，因为<code>i&gt;starti</code>才能保证去重是在同一层上，<code>i&gt;0</code>虽然能保证不越界，但是下一层就无法选择和上一层的前一个相同的元素，不符合题目条件。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="type">void</span> _combinationSum2(vector&lt;<span class="type">int</span>&gt;&amp; candidates, <span class="type">int</span> target, <span class="type">int</span> sum,</span><br><span class="line">                          <span class="type">int</span> starti, vector&lt;<span class="type">int</span>&gt; curV,</span><br><span class="line">                          vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; retV) &#123;</span><br><span class="line">        <span class="comment">// 值相等，插入</span></span><br><span class="line">        <span class="keyword">if</span> (sum == target) &#123;</span><br><span class="line">            retV.<span class="built_in">push_back</span>(curV);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 值已经大于了，不进入</span></span><br><span class="line">        <span class="keyword">if</span> (sum &gt; target) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 每一层都是直接重新遍历整个数组</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = starti; i &lt; candidates.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="comment">// 当前值和上一次相同，跳过</span></span><br><span class="line">            <span class="comment">// i &gt; starti 保证是同一层的去重</span></span><br><span class="line">            <span class="keyword">if</span>(i &gt; starti &amp;&amp; candidates[i] == candidates[i<span class="number">-1</span>])&#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 值已经大于了，不进入</span></span><br><span class="line">            <span class="keyword">if</span> (sum + candidates[i] &gt; target) &#123;</span><br><span class="line">                <span class="keyword">return</span>; <span class="comment">// 已经对数组进行排序了，可以直接返回</span></span><br><span class="line">            &#125;</span><br><span class="line">            curV.<span class="built_in">push_back</span>(candidates[i]);</span><br><span class="line">            <span class="comment">// 这道题就需要对i加一了，因为下一层不能选择下标相同的数字；</span></span><br><span class="line">            _combinationSum2(candidates, target, sum + candidates[i], i + <span class="number">1</span>,</span><br><span class="line">                             curV, retV);</span><br><span class="line">            curV.<span class="built_in">pop_back</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">combinationSum2</span>(vector&lt;<span class="type">int</span>&gt;&amp; candidates, <span class="type">int</span> target) &#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; retV;</span><br><span class="line">        <span class="keyword">if</span> (candidates.<span class="built_in">size</span>() == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> retV;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">sort</span>(candidates.<span class="built_in">begin</span>(),candidates.<span class="built_in">end</span>());</span><br><span class="line">        _combinationSum2(candidates, target, <span class="number">0</span>, <span class="number">0</span>, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(), retV);</span><br><span class="line">        <span class="keyword">return</span> retV;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/03/2be650c1805cb352d63a7abf5c2bad89.png" alt="image-20240324101552367"></p><h1 id="3-切割问题"><a href="#3-切割问题" class="headerlink" title="3.切割问题"></a>3.切割问题</h1><p>切割问题的基本思路</p><ul><li>编写切割区间是否符合条件的判断函数</li><li>确定切割区间终止条件（递归终止条件）</li><li>确定单层循环如何指定切割区间。</li></ul><h2 id="131-分割回文串"><a href="#131-分割回文串" class="headerlink" title="131 分割回文串"></a>131 分割回文串</h2><h3 id="题目和思路-5"><a href="#题目和思路-5" class="headerlink" title="题目和思路"></a>题目和思路</h3><p>给你一个字符串 s，请你将 s 分割成一些子串，使每个子串都是 <strong>回文串</strong>。返回 s 所有可能的分割方案。</p><p>回文串是从从左往右读和从右往左读都完全一致的字符串。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">示例 1：</span><br><span class="line">输入：s = &quot;aab&quot;</span><br><span class="line">输出：[[&quot;a&quot;,&quot;a&quot;,&quot;b&quot;],[&quot;aa&quot;,&quot;b&quot;]]</span><br><span class="line"></span><br><span class="line">示例 2：</span><br><span class="line">输入：s = &quot;a&quot;</span><br><span class="line">输出：[[&quot;a&quot;]]</span><br></pre></td></tr></table></figure><p>提示</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1 &lt;= s.length &lt;= 16</span><br><span class="line">s 仅由小写英文字母组成</span><br></pre></td></tr></table></figure><p>思路依旧是用回溯，这是第一次遇到切割问题，我们主要是想办法通过下标区间“模拟”出来一个切割线。根据代码随想录提供的回溯模板，我们知道每一层都是一个for循环，此时就需要通过for循环的变量i来模拟一个切割线。</p><ul><li>当遍历到i时，认为<code>s[i]</code>和<code>s[i+1]</code>之间有一个切割线。</li></ul><p>和前文的组合问题一样，我们也需要一个startIndex来标识每一层for的起点。本题需要跳过之前已经选过的子串。</p><ul><li>可以认为<code>s[startIndex]</code>和上一位字符之间有另外一个切割线</li><li>这是上一层选中的切割线；</li><li>刚开始的时候，startIndex为0，<strong>切割线在字符串开头</strong>；</li></ul><p>for循环中什么时候需要递归到下一层呢？</p><ul><li>只有本层<code>[startIndex,i]</code>区域的字符串是一个回文串的时候，才需要递归下一层；</li><li>否则本层已经不满足条件，递归到下一层也是没有意义的！</li><li>本层区间已经是回文串，递归传入<code>startIndex+1</code>，从下一位开始选择新的回文子串；</li></ul><p>递归的终止条件是什么？</p><ul><li>前文提到，“当遍历到i时，认为<code>s[i]</code>和<code>s[i+1]</code>之间有一个切割线。”</li></ul><p>所以，当传入的startIndex为字符串size的时候，认为上一层的i已经走到了字符串末尾了，已经在字符串末尾处添加了一个切割线了，这时候就可以将结果插入数组了。</p><p>这里不需要做任何额外的判断，因为之前做的递归的判断条件已经决定了，能走到这里就说明所有子串已经满足回文条件。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (startIndex &gt;= s.<span class="built_in">size</span>()) &#123;</span><br><span class="line">    retV.<span class="built_in">push_back</span>(curV);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面是一个切割的示意图，方便理解。</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/04/306d6e19ed779dbd689f8e6c772c85ad.png" alt="image.png"></p><h3 id="完整代码-4"><a href="#完整代码-4" class="headerlink" title="完整代码"></a>完整代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    vector&lt;vector&lt;string&gt;&gt; retV; <span class="comment">// 返回值数组</span></span><br><span class="line">    vector&lt;string&gt; curV;         <span class="comment">// 当前的回文子串</span></span><br><span class="line"></span><br><span class="line">    <span class="type">void</span> _partition(string s, <span class="type">int</span> startIndex) &#123;</span><br><span class="line">        <span class="comment">// 越界，说明上一层i已经是s.size()-1，此时分割线是在字符串末尾；</span></span><br><span class="line">        <span class="comment">// 已经是最后一个分割线了，说明找到了符合条件的切割（没找到是走不到这里来的）</span></span><br><span class="line">        <span class="keyword">if</span> (startIndex &gt;= s.<span class="built_in">size</span>()) &#123;</span><br><span class="line">            retV.<span class="built_in">push_back</span>(curV);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 遍历，将下标当作子串</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = startIndex; i &lt; s.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="comment">// 如果是，将这里作为一个子串切割，递归到下一层找其他子串</span></span><br><span class="line">            <span class="comment">// 子串区间一直都是闭区间 [startIndex,i]</span></span><br><span class="line">            <span class="comment">// 此时i和i+1之间可以想象成有一个分割线</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">isReverseString</span>(s, startIndex, i)) &#123;</span><br><span class="line">            <span class="comment">// 插入当前选择的子串</span></span><br><span class="line">                string temp = s.<span class="built_in">substr</span>(startIndex, i - startIndex + <span class="number">1</span>);</span><br><span class="line">                curV.<span class="built_in">push_back</span>(temp);</span><br><span class="line">                <span class="comment">// 递归下一层</span></span><br><span class="line">                <span class="comment">// _partition(s, startIndex + 1); // 错误，i才是分割线位置</span></span><br><span class="line">                _partition(s, i + <span class="number">1</span>);</span><br><span class="line">                </span><br><span class="line">                <span class="comment">// 弹出当前选择的子串</span></span><br><span class="line">                curV.<span class="built_in">pop_back</span>(); <span class="comment">// 回溯</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 如果不是，这一次的切割已经无效了，直接跳过</span></span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 注意不能break，因为后序可能还会有回文的情况</span></span><br><span class="line">                <span class="comment">// 比如ab和aba</span></span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 判断是否为回文子串，双指针法</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isReverseString</span><span class="params">(<span class="type">const</span> string&amp; str, <span class="type">int</span> begin, <span class="type">int</span> end)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = begin, j = end; i &lt; j; i++, j--) &#123;</span><br><span class="line">            <span class="keyword">if</span> (str[i] != str[j]) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;string&gt;&gt; <span class="built_in">partition</span>(string s) &#123;</span><br><span class="line">        _partition(s, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> retV;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/04/8ecd5435bbc64b90bf69a31229a408b1.png" alt="image.png"></p><h2 id="93-复原IP地址"><a href="#93-复原IP地址" class="headerlink" title="93 复原IP地址"></a>93 复原IP地址</h2><blockquote><p><a href="https://leetcode.cn/problems/restore-ip-addresses/">https://leetcode.cn/problems/restore-ip-addresses/</a></p></blockquote><h3 id="题目和思路-6"><a href="#题目和思路-6" class="headerlink" title="题目和思路"></a>题目和思路</h3><p>有效 IP 地址 正好由四个整数（每个整数位于 0 到 255 之间组成，且不能含有前导 0），整数之间用 <code>&#39;.&#39;</code> 分隔。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">例如：&quot;0.1.2.201&quot; 和 &quot;192.168.1.1&quot; 是 有效 IP 地址，但是 &quot;0.011.255.245&quot;、&quot;192.168.1.312&quot; 和 &quot;192.168@1.1&quot; 是 无效 IP 地址。</span><br></pre></td></tr></table></figure><p>给定一个只包含数字的字符串 s ，用以表示一个 IP 地址，返回所有可能的有效 IP 地址，这些地址可以通过在 s 中插入 <code>&#39;.&#39;</code> 来形成。你 <strong>不能</strong> 重新排序或删除 s 中的任何数字。你可以按 任何 顺序返回答案。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">示例 1：</span><br><span class="line">输入：s = &quot;25525511135&quot;</span><br><span class="line">输出：[&quot;255.255.11.135&quot;,&quot;255.255.111.35&quot;]</span><br><span class="line"></span><br><span class="line">示例 2：</span><br><span class="line">输入：s = &quot;0000&quot;</span><br><span class="line">输出：[&quot;0.0.0.0&quot;]</span><br><span class="line"></span><br><span class="line">示例 3：</span><br><span class="line">输入：s = &quot;101023&quot;</span><br><span class="line">输出：[&quot;1.0.10.23&quot;,&quot;1.0.102.3&quot;,&quot;10.1.0.23&quot;,&quot;10.10.2.3&quot;,&quot;101.0.2.3&quot;</span><br></pre></td></tr></table></figure><p>提示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1 &lt;= s.length &lt;= 20</span><br><span class="line">s 仅由数字组成</span><br></pre></td></tr></table></figure><p>这道题和上一题131的切割基本一致，只不过我们需要在虚拟的切割线的基础上做额外的处理，即把<code>&#39;.&#39;</code>字符当作切割线，插入到字符串中。因为题目最终返回的的字符串需要是带IP地址的<code>&#39;.&#39;</code>的，我们这样做就相当于提前处理了最终IP地址的字符串。</p><p>先来确定最终的递归终止条件吧，这里不再用startIndex大于size的判断方式，因为IP地址大概率是走不到这里就已经找到符合条件的子串了。我们应该利用IP地址中有3个<code>&#39;.&#39;</code>的特性来做递归的终止条件，即加了点的数量为3的时候，就已经不能继续执行本层了，需要退出了。</p><p>插入返回值之前，还需要判断最后一个点到字符串末尾的区间是否符合IP地址的条件。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (pointNum == <span class="number">3</span>) &#123;</span><br><span class="line">    <span class="comment">// 判断最后一部分是否符合ip的条件</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">checkIpStr</span>(s, startIndex, s.<span class="built_in">size</span>() - <span class="number">1</span>)) &#123;</span><br><span class="line">        retV.<span class="built_in">push_back</span>(s);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>IP地址的判断函数如下，保证区间的字符串对应的数字是0到255，且不能有前导0；</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 判断这个区间是否是合法的ip地址</span></span><br><span class="line">   <span class="function"><span class="type">bool</span> <span class="title">checkIpStr</span><span class="params">(<span class="type">const</span> string&amp; s, <span class="type">int</span> start, <span class="type">int</span> end)</span> </span>&#123;</span><br><span class="line">       <span class="comment">// 区间合法（不能等于，start==end时是一个数字的情况）</span></span><br><span class="line">       <span class="keyword">if</span> (start &gt; end) &#123;</span><br><span class="line">           <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">// 以0开始的不合法（除非只有一个0）</span></span><br><span class="line">       <span class="keyword">if</span> (s[start] == <span class="string">&#x27;0&#x27;</span> &amp;&amp; start != end) &#123;</span><br><span class="line">           <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">       <span class="keyword">for</span> (<span class="type">int</span> i = start; i &lt;= end; i++) &#123;</span><br><span class="line">           <span class="comment">// 不是数字，不符合</span></span><br><span class="line">           <span class="keyword">if</span> (s[i] &lt; <span class="string">&#x27;0&#x27;</span> || s[i] &gt; <span class="string">&#x27;9&#x27;</span>) &#123;</span><br><span class="line">               <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="comment">// 加到sum里面</span></span><br><span class="line">           sum = sum * <span class="number">10</span> + (s[i] - <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">           <span class="comment">// 如果超过255，不符合</span></span><br><span class="line">           <span class="keyword">if</span> (sum &gt; <span class="number">255</span>) &#123;</span><br><span class="line">               <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>最终回溯函数的步骤如下：</p><ul><li>当遍历到i的时候，假设<code>s[i]</code>和<code>s[i+1]</code>之间有一个点；</li><li>判断<code>[startIndex,i]</code>区间是否符合IP地址的规定（0到255）；</li><li>符合条件，在i和i+1之间插入一个点；</li><li>点的数量加一；</li><li>递归下一层，其中startIndex应该传入<code>i+2</code>（跳过刚刚插入的点）；</li><li>回溯，点的数量减一，删除刚刚添加的点；</li></ul><h3 id="完整代码-5"><a href="#完整代码-5" class="headerlink" title="完整代码"></a>完整代码</h3><p>完整代码如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    vector&lt;string&gt; retV;</span><br><span class="line"></span><br><span class="line">    <span class="type">void</span> _restoreIpAddresses(string s, <span class="type">int</span> startIndex, <span class="type">int</span> pointNum) &#123;</span><br><span class="line">        <span class="comment">// IP地址需要打三个点，有三个点了之后就不需要继续for了</span></span><br><span class="line">        <span class="keyword">if</span> (pointNum == <span class="number">3</span>) &#123;</span><br><span class="line">            <span class="comment">// 判断最后一部分是否符合ip的条件</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">checkIpStr</span>(s, startIndex, s.<span class="built_in">size</span>() - <span class="number">1</span>)) &#123;</span><br><span class="line">                retV.<span class="built_in">push_back</span>(s);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = startIndex; i &lt; s.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="comment">// 判断[start,i]区间是否是合法的ip地址组成</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">checkIpStr</span>(s, startIndex, i)) &#123;</span><br><span class="line">                <span class="comment">// 是，加点（注意insert是在选中位置之前插入）</span></span><br><span class="line">                <span class="comment">// 加点是为了方便最后直接插入返回值</span></span><br><span class="line">                s.<span class="built_in">insert</span>(s.<span class="built_in">begin</span>() + i + <span class="number">1</span>, <span class="string">&#x27;.&#x27;</span>);</span><br><span class="line">                pointNum++;</span><br><span class="line">                <span class="comment">// 这里加2是为了跳过插入的点，走到下一位</span></span><br><span class="line">                _restoreIpAddresses(s, i + <span class="number">2</span>, pointNum);</span><br><span class="line">                <span class="comment">// 回溯本层操作</span></span><br><span class="line">                pointNum--;</span><br><span class="line">                s.<span class="built_in">erase</span>(s.<span class="built_in">begin</span>() + i + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 如果已经不符合条件了，说明这一层都不符合条件了</span></span><br><span class="line">            <span class="comment">// 比如515已经不符合条件了，再往后走更不符合（这一层符合条件的组合已经在之前走过了）</span></span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">break</span>; <span class="comment">// 跳出本层</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断这个区间是否是合法的ip地址</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">checkIpStr</span><span class="params">(<span class="type">const</span> string&amp; s, <span class="type">int</span> start, <span class="type">int</span> end)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 区间合法（不能等于，start==end时是一个数字的情况）</span></span><br><span class="line">        <span class="keyword">if</span> (start &gt; end) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 以0开始的不合法（除非只有一个0）</span></span><br><span class="line">        <span class="keyword">if</span> (s[start] == <span class="string">&#x27;0&#x27;</span> &amp;&amp; start != end) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = start; i &lt;= end; i++) &#123;</span><br><span class="line">            <span class="comment">// 不是数字，不符合</span></span><br><span class="line">            <span class="keyword">if</span> (s[i] &lt; <span class="string">&#x27;0&#x27;</span> || s[i] &gt; <span class="string">&#x27;9&#x27;</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 加到sum里面</span></span><br><span class="line">            sum = sum * <span class="number">10</span> + (s[i] - <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">            <span class="comment">// 如果超过255，不符合</span></span><br><span class="line">            <span class="keyword">if</span> (sum &gt; <span class="number">255</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;string&gt; <span class="title">restoreIpAddresses</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        _restoreIpAddresses(s, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> retV;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/04/05ea0b8be513ac4fdb8848948a5d301c.png" alt="image.png"></p><h1 id="4-子集问题"><a href="#4-子集问题" class="headerlink" title="4.子集问题"></a>4.子集问题</h1><h2 id="78-子集"><a href="#78-子集" class="headerlink" title="78 子集"></a>78 子集</h2><blockquote><p><a href="https://leetcode.cn/problems/subsets/description/">https://leetcode.cn/problems/subsets/description/</a></p></blockquote><h3 id="题目和思路-7"><a href="#题目和思路-7" class="headerlink" title="题目和思路"></a>题目和思路</h3><p>给你一个整数数组 nums ，数组中的元素 <strong>互不相同</strong> 。返回该数组所有可能的子集（幂集）。</p><p>解集 不能 包含重复的子集。你可以按 任意顺序 返回解集。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">示例 1：</span><br><span class="line">输入：nums = [1,2,3]</span><br><span class="line">输出：[[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]]</span><br><span class="line"></span><br><span class="line">示例 2：</span><br><span class="line">输入：nums = [0]</span><br><span class="line">输出：[[],[0]]</span><br></pre></td></tr></table></figure><p>这道题的思路就不是很难了，属于是回溯算法的一个最基础的思路。</p><p>首先要根据题目需要的子集来确定什么时候插入返回值数组和递归的终止条件，最开始我的想法是单独处理每个元素构成的数组（比如<code>[1],[2],[3]</code>）和空数组<code>[]</code>；在递归终止条件中插入其他数组到返回值。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(startIndex&gt;=nums.<span class="built_in">size</span>())&#123;</span><br><span class="line"> retV.<span class="built_in">push_back</span>(curV);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是这样会多出额外的一次遍历，虽然整体的时间复杂度没有变化，但多了一个遍历总归会浪费一些时间。</p><p>实际上也不需要这么麻烦，根据回溯算法的思路，其实第二层递归的时候，curV就是<code>[1],[2],[3]</code>这些由单个元素构成的数组了，也就是说，我们只要每一次递归调用函数的时候就把curV插入返回值，就能满足条件了！同时，第一次调用递归函数时，也正好会把空的curV给插入，空集也不需要额外处理了！</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 因为子集包括每一个数单独组成的数组和空数组，所以可以先直接把数组插入</span></span><br><span class="line"><span class="comment">// 第一次进入函数是插入空数组，第二层递归是插入每个数单独组成的数组</span></span><br><span class="line">retV.<span class="built_in">push_back</span>(curV);</span><br><span class="line"><span class="keyword">if</span>(startIndex&gt;=nums.<span class="built_in">size</span>())&#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>剩余的部分其实就是单层回溯了，题目要求不能有重复的子集（数组每个元素都不相同），所以下一层递归的时候，传给startIndex的是<code>i+1</code>，从下一位开始选择数插入数组就OK了。</p><h3 id="完整代码-6"><a href="#完整代码-6" class="headerlink" title="完整代码"></a>完整代码</h3><p>学过了前几题的回溯思路，这道题相对来说没有那么困难了。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; retV;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; curV;</span><br><span class="line">    <span class="comment">// 求子集的回溯函数</span></span><br><span class="line">    <span class="type">void</span> _subsets(vector&lt;<span class="type">int</span>&gt;&amp; nums,<span class="type">int</span> startIndex)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 因为子集包括每一个数单独组成的数组和空数组，所以可以先直接把数组插入</span></span><br><span class="line">        <span class="comment">// 第一次进入函数是插入空数组，第二层递归是插入每个数单独组成的数组</span></span><br><span class="line">        retV.<span class="built_in">push_back</span>(curV);</span><br><span class="line">        <span class="keyword">if</span>(startIndex&gt;=nums.<span class="built_in">size</span>())&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 回溯的循环</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = startIndex;i&lt;nums.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            <span class="comment">// 插入当前数</span></span><br><span class="line">            curV.<span class="built_in">push_back</span>(nums[i]);</span><br><span class="line">            <span class="comment">// 递归下一层，不能选择相同下标的数</span></span><br><span class="line">            _subsets(nums,i+<span class="number">1</span>);</span><br><span class="line">            <span class="comment">// 回溯当前操作</span></span><br><span class="line">            curV.<span class="built_in">pop_back</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">subsets</span>(vector&lt;<span class="type">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        _subsets(nums,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> retV;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/04/489dc2b8a3021e05a4564c670c11bd0a.png" alt="image.png"></p><h2 id="90-子集2"><a href="#90-子集2" class="headerlink" title="90 子集2"></a>90 子集2</h2><blockquote><p><a href="https://leetcode.cn/problems/subsets-ii/description/">https://leetcode.cn/problems/subsets-ii/description/</a></p></blockquote><h3 id="题目和思路-8"><a href="#题目和思路-8" class="headerlink" title="题目和思路"></a>题目和思路</h3><p>给你一个整数数组 nums ，<strong>其中可能包含重复元素</strong>，请你返回该数组所有可能的 子集（幂集）。</p><p>解集 不能 包含重复的子集。返回的解集中，子集可以按 任意顺序 排列。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">示例 1：</span><br><span class="line">输入：nums = [1,2,2]</span><br><span class="line">输出：[[],[1],[1,2],[1,2,2],[2],[2,2]]</span><br><span class="line"></span><br><span class="line">示例 2：</span><br><span class="line">输入：nums = [0]</span><br><span class="line">输出：[[],[0]]</span><br></pre></td></tr></table></figure><p>这道题和78题的关系好比39和40题的关系一样，由78题的数组中不包括重复元素，变成了数组中有重复元素，且结果集不能有重复的子集。</p><p>如果还按照78题的思路来写，此时就会出现两个<code>[1,2]</code>子集的情况（一个是1和第一个2匹配的子集，另外一个是1和第二个2匹配的子集）。</p><p>实际上，每一层的处理都不能处理相同的数，包括进入下一层的递归也是。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[1,2,2,3]</span><br><span class="line">当前 i = 1，选中第一个2</span><br><span class="line">往下递归，可得到集合[2,2]、[2,3]、[2,2,3]</span><br><span class="line"></span><br><span class="line">如果for循环不做去重，i = 2选中第二个2</span><br><span class="line">往下递归，会重复得到集合[2,3]</span><br></pre></td></tr></table></figure><p>这里的去重思路并不难实现，和40题的去重基本一致：在<strong>单层</strong>for中，如果上一位和当前位相等，则跳过当前位（重复了）。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (i &gt; startIndex &amp;&amp; nums[i] == nums[i - <span class="number">1</span>]) &#123;</span><br><span class="line"><span class="keyword">continue</span>; <span class="comment">// 跳过相同数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样不仅解决了多个数的子集的重复问题，还解决了单个数的子集的重复问题，<code>[1,2,2]</code>在第一层for中，只会有1和第一个2进入下一层，<strong>最后一个2会被去重跳过</strong>，也就不会重复插入子集<code>[2]</code>。</p><h3 id="完整代码-7"><a href="#完整代码-7" class="headerlink" title="完整代码"></a>完整代码</h3><p>注意，这个判断上一位的去重思路是基于数组有序的，但题目并没有保证输入数组有序，所以调用递归函数之前，需要对数组排序。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; retV;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; curV;</span><br><span class="line">    <span class="comment">// 求子集的回溯函数</span></span><br><span class="line">    <span class="type">void</span> _subsetsWithDup(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> startIndex) &#123;</span><br><span class="line">        <span class="comment">// 因为子集包括每一个数单独组成的数组和空数组，所以可以先直接把数组插入</span></span><br><span class="line">        <span class="comment">// 第一次进入函数是插入空数组，第二层递归是插入每个数单独组成的数组</span></span><br><span class="line">        retV.<span class="built_in">push_back</span>(curV);</span><br><span class="line">        <span class="keyword">if</span> (startIndex &gt;= nums.<span class="built_in">size</span>()) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 回溯的循环</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = startIndex; i &lt; nums.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="comment">// 单层的去重</span></span><br><span class="line">            <span class="keyword">if</span> (i &gt; startIndex &amp;&amp; nums[i] == nums[i - <span class="number">1</span>]) &#123;</span><br><span class="line">                <span class="keyword">continue</span>; <span class="comment">// 跳过相同数</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 插入当前数</span></span><br><span class="line">            curV.<span class="built_in">push_back</span>(nums[i]);</span><br><span class="line">            <span class="comment">// 递归下一层</span></span><br><span class="line">            _subsetsWithDup(nums, i + <span class="number">1</span>);</span><br><span class="line">            <span class="comment">// 回溯当前操作</span></span><br><span class="line">            curV.<span class="built_in">pop_back</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">subsetsWithDup</span>(vector&lt;<span class="type">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        <span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>()); <span class="comment">// 排序</span></span><br><span class="line">        _subsetsWithDup(nums, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> retV;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/04/abc05725c7808521ecda379be843cea7.png" alt="image.png"></p><h2 id="491-非递减子序列"><a href="#491-非递减子序列" class="headerlink" title="491 非递减子序列"></a>491 非递减子序列</h2><blockquote><p><a href="https://leetcode.cn/problems/non-decreasing-subsequences/description/">https://leetcode.cn/problems/non-decreasing-subsequences/description/</a></p></blockquote><h3 id="题目和思路-9"><a href="#题目和思路-9" class="headerlink" title="题目和思路"></a>题目和思路</h3><p>给你一个整数数组 nums ，找出并返回所有该数组中不同的递增子序列，递增子序列中 至少有两个元素 。你可以按 任意顺序 返回答案。</p><p>数组中可能含有重复元素，<strong>如出现两个整数相等，也可以视作递增序列的一种特殊情况</strong>。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">示例 1：</span><br><span class="line">输入：nums = [4,6,7,7]</span><br><span class="line">输出：[[4,6],[4,6,7],[4,6,7,7],[4,7],[4,7,7],[6,7],[6,7,7],[7,7]]</span><br><span class="line"></span><br><span class="line">示例 2：</span><br><span class="line">输入：nums = [4,4,3,2,1]</span><br><span class="line">输出：[[4,4]]</span><br></pre></td></tr></table></figure><p>提示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1 &lt;= nums.length &lt;= 15</span><br><span class="line">-100 &lt;= nums[i] &lt;= 100</span><br></pre></td></tr></table></figure><p>首先注意这道题的要求，需要我们找到所有的递增子序列。这里包含了一个隐含的要求，即我们<strong>不可以对原数组进行重排序</strong>（否则找到的递增子序列不一定符合条件）。</p><ul><li>怎么判断当前找到的子序列是递增的？</li></ul><p>通过startIndex来判断，我们需要保证当前层添加的数比上一层的数更大或相等，就是一个递增的子序列。第一层curV为空，不需要判断。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 因为在for中每次都只会往curV插入一个数，所以可以直接判断</span></span><br><span class="line"><span class="comment">// 如果当前位小于startIndex-1，跳过</span></span><br><span class="line"><span class="keyword">if</span> (startIndex - <span class="number">1</span> &gt;= <span class="number">0</span> &amp;&amp; i &gt; startIndex - <span class="number">1</span> &amp;&amp;</span><br><span class="line">nums[i] &lt; nums[startIndex - <span class="number">1</span>]) &#123;</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>什么时候插入返回值？</li></ul><p>题目需要的是<strong>所有递增的子序列</strong>。</p><p>此时既不能在越界终止条件中插入返回值，也不能直接在函数开始插入返回值。前者会导致结果集<strong>只包含叶子节点的子集</strong>（中途节点符合条件的子集未被加入），后者会导致<strong>只包含单个元素的子集被错误插入</strong>（题目要求子集必须至少有2个元素）。</p><p>正确的插入情况是curV的长度大于1的时候插入，这时候每一次递归都会把符合条件的子集插入其中。配合for循环内的去重逻辑避免重复子集被插入。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (curV.<span class="built_in">size</span>() &gt; <span class="number">1</span>) &#123;</span><br><span class="line">          retV.<span class="built_in">push_back</span>(curV);</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure><p>递归的终止条件依旧是startIndex大于数组长度</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 越界终止</span></span><br><span class="line"><span class="keyword">if</span> (startIndex &gt;= nums.<span class="built_in">size</span>()) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>需要去重吗？</li></ul><p>注意，本题也是需要去重的</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[4,6,7,7]</span><br><span class="line">第一层选择4，进入第二层，在[6,7,7]中选</span><br><span class="line">如果不去重，就会出现两个[4,7]子集</span><br><span class="line"></span><br><span class="line">第二层选择6，进入第三层，在[7,7]中选</span><br><span class="line">如果不去重，就会出现两个[4,6,7]子集</span><br></pre></td></tr></table></figure><ul><li>单层怎么去重？</li></ul><p>之前的函数中，我们直接判断i不等于i-1来去重，但那是基于数组已经有序的情况下使用的了。</p><p>现在因为<strong>不能对原始数组做重排序</strong>，我们应该使用一个哈希表来对数组中元素去重。单层被选用过的元素不能再被使用。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// for循环之前定义去重集合</span></span><br><span class="line">unordered_set&lt;<span class="type">int</span>&gt; used; </span><br><span class="line"></span><br><span class="line"><span class="comment">// for循环中，判断某个数是否已被使用过</span></span><br><span class="line"><span class="keyword">if</span> (used.<span class="built_in">count</span>(nums[i]) != <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line">used.<span class="built_in">insert</span>(nums[i]);<span class="comment">// 没有使用过则插入</span></span><br></pre></td></tr></table></figure><p>此时的代码已经可以通过了。但针对本题，去重还有可优化之处：注意题目给的提示，数组中元素的大小区间是<code>[-100,100]</code>，这并不是一个很大的区间，我们完全可以使用一个201个元素的数组来替代<code>unordered_set</code>做去重的操作。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// for循环之前定义</span></span><br><span class="line"><span class="function">vector&lt;<span class="type">bool</span>&gt; <span class="title">usedArray</span><span class="params">(<span class="number">201</span>, <span class="literal">false</span>)</span></span>; <span class="comment">// num[i] + 100 作为下标</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// for循环内直接判断对应下标位置即可</span></span><br><span class="line"><span class="keyword">if</span> (usedArray[nums[i] + <span class="number">100</span>] != <span class="literal">false</span>) &#123;</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line">usedArray[nums[i] + <span class="number">100</span>] = <span class="literal">true</span>; <span class="comment">// 标记已经使用过了</span></span><br></pre></td></tr></table></figure><p>虽然<code>unordered_set</code>能提供<code>O(1)</code>级别的查找，但它并非严格的<code>O(1)</code>，同时插入的操作也会有更多的耗时。使用数组能保证不管是查询还是插入都只需要做1个操作。</p><p>针对这种哈希的情形，如果能确定数值的范围不大（比如本题或映射仅小写英文字母的情况），那么使用一个定长数组会优于使用哈希表。</p><h3 id="完整代码-8"><a href="#完整代码-8" class="headerlink" title="完整代码"></a>完整代码</h3><p>代码如下，本题主要是去重思路和其他题目不一样。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; retV;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; curV;</span><br><span class="line">    <span class="type">void</span> _findSubsequences(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> startIndex) &#123;</span><br><span class="line">        <span class="comment">// 题目要求子序列必须有两个元素</span></span><br><span class="line">        <span class="keyword">if</span> (curV.<span class="built_in">size</span>() &gt; <span class="number">1</span>) &#123;</span><br><span class="line">            retV.<span class="built_in">push_back</span>(curV);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 越界终止</span></span><br><span class="line">        <span class="keyword">if</span> (startIndex &gt;= nums.<span class="built_in">size</span>()) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 单层for中不能选择已经选过的数</span></span><br><span class="line">        <span class="comment">// unordered_set&lt;int&gt; used; // 去重集合</span></span><br><span class="line">        <span class="comment">// 因为题目给出了数字的区间是-100到100，可以直接用一个201长度的数组做哈希，提高效率</span></span><br><span class="line">        <span class="function">vector&lt;<span class="type">bool</span>&gt; <span class="title">usedArray</span><span class="params">(<span class="number">201</span>, <span class="literal">false</span>)</span></span>; <span class="comment">// num[i] + 100 作为下标</span></span><br><span class="line">        <span class="comment">// 单层for</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = startIndex; i &lt; nums.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="comment">// 因为在for中每次都只会往curV插入一个数，所以可以直接判断</span></span><br><span class="line">            <span class="comment">// 如果当前位小于startIndex-1，跳过</span></span><br><span class="line">            <span class="keyword">if</span> (startIndex - <span class="number">1</span> &gt;= <span class="number">0</span> &amp;&amp; i &gt; startIndex - <span class="number">1</span> &amp;&amp;</span><br><span class="line">                nums[i] &lt; nums[startIndex - <span class="number">1</span>]) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 单层for中不能选择已经选过的数</span></span><br><span class="line">            <span class="comment">// if (used.count(nums[i]) != 0)</span></span><br><span class="line">            <span class="keyword">if</span> (usedArray[nums[i] + <span class="number">100</span>] != <span class="literal">false</span>) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 插入本层</span></span><br><span class="line">            <span class="comment">// used.insert(nums[i]);</span></span><br><span class="line">            usedArray[nums[i] + <span class="number">100</span>] = <span class="literal">true</span>; <span class="comment">// 标记已经使用过了</span></span><br><span class="line">            curV.<span class="built_in">push_back</span>(nums[i]);</span><br><span class="line">            <span class="comment">// 递归下一层</span></span><br><span class="line">            _findSubsequences(nums, i + <span class="number">1</span>);</span><br><span class="line">            <span class="comment">// 回溯</span></span><br><span class="line">            curV.<span class="built_in">pop_back</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">findSubsequences</span>(vector&lt;<span class="type">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        _findSubsequences(nums, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> retV;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/04/787201c7664cacc5753ef66e8fbfbf57.png" alt="image.png"></p><h1 id="5-排列问题"><a href="#5-排列问题" class="headerlink" title="5.排列问题"></a>5.排列问题</h1><h2 id="46-全排列"><a href="#46-全排列" class="headerlink" title="46 全排列"></a>46 全排列</h2><blockquote><p><a href="https://leetcode.cn/problems/permutations/">https://leetcode.cn/problems/permutations/</a></p></blockquote><h3 id="题目和思路-10"><a href="#题目和思路-10" class="headerlink" title="题目和思路"></a>题目和思路</h3><p>给定一个<strong>不含重复数字</strong>的数组 nums ，返回其 所有可能的全排列 。你可以 按任意顺序 返回答案。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">示例 1：</span><br><span class="line">输入：nums = [1,2,3]</span><br><span class="line">输出：[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]</span><br><span class="line"></span><br><span class="line">示例 2：</span><br><span class="line">输入：nums = [0,1]</span><br><span class="line">输出：[[0,1],[1,0]]</span><br><span class="line"></span><br><span class="line">示例 3：</span><br><span class="line">输入：nums = [1]</span><br><span class="line">输出：[[1]]</span><br></pre></td></tr></table></figure><p>这道题和前文的子集问题都不同，这道题是希望我们将数组随便重新排列，并把所有可能重新排列的情况返回。</p><p>此时for循环就不需要使用startIndex了，因为每一次都需要从0开始遍历。比如当前选中了<code>[1,2,3]</code>中的2，还是需要从0开始遍历，加上1，再加上3；为此需要一个used数组来标记数组中哪一个元素已经被使用过了，跳过已经被使用的元素。</p><p>递归的终止条件也很简单，只要当前的curV和nums长度一致，就说明我们找到了一个全排列。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 长度相等代表找到了一个全排列</span></span><br><span class="line"><span class="keyword">if</span> (curV.<span class="built_in">size</span>() == nums.<span class="built_in">size</span>()) &#123;</span><br><span class="line">    retV.<span class="built_in">push_back</span>(curV);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>本质上这道题就是一个暴力破解的过程，用回溯的思路模拟了一层循环。</p><h3 id="完整代码-9"><a href="#完整代码-9" class="headerlink" title="完整代码"></a>完整代码</h3><p>注意，我在主函数中使用resize初始化了used数组，因为需要保证刚开始的时候，所有下标都是false（未被使用）。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; retV;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; curV;</span><br><span class="line">    vector&lt;<span class="type">bool</span>&gt; used;</span><br><span class="line">    <span class="comment">// 因为全排列每次都需要从0开始，所以不需要startIndex</span></span><br><span class="line">    <span class="type">void</span> _permute(vector&lt;<span class="type">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        <span class="comment">// 长度相等代表找到了一个全排列</span></span><br><span class="line">        <span class="keyword">if</span> (curV.<span class="built_in">size</span>() == nums.<span class="built_in">size</span>()) &#123;</span><br><span class="line">            retV.<span class="built_in">push_back</span>(curV);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (used[i] == <span class="literal">true</span>) &#123;</span><br><span class="line">                <span class="keyword">continue</span>; <span class="comment">// 跳过已经被选择了的</span></span><br><span class="line">            &#125;</span><br><span class="line">            curV.<span class="built_in">push_back</span>(nums[i]);</span><br><span class="line">            used[i] = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">            _permute(nums);</span><br><span class="line"></span><br><span class="line">            used[i] = <span class="literal">false</span>;</span><br><span class="line">            curV.<span class="built_in">pop_back</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">permute</span>(vector&lt;<span class="type">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        used.<span class="built_in">resize</span>(nums.<span class="built_in">size</span>(), <span class="literal">false</span>); <span class="comment">// 注意初始化</span></span><br><span class="line">        _permute(nums);</span><br><span class="line">        <span class="keyword">return</span> retV;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/04/7999ae3a336b9c34f97ce1f6dd684b5e.png" alt="image.png"></p><h2 id="47-全排列2"><a href="#47-全排列2" class="headerlink" title="47 全排列2"></a>47 全排列2</h2><blockquote><p><a href="https://leetcode.cn/problems/permutations-ii/">https://leetcode.cn/problems/permutations-ii/</a></p></blockquote><h3 id="题目和思路-11"><a href="#题目和思路-11" class="headerlink" title="题目和思路"></a>题目和思路</h3><p>给定一个<strong>可包含重复数字</strong>的序列 nums ，按任意顺序 返回所有不重复的全排列。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">示例 1：</span><br><span class="line">输入：nums = [1,1,2]</span><br><span class="line">输出：</span><br><span class="line">[[1,1,2],</span><br><span class="line"> [1,2,1],</span><br><span class="line"> [2,1,1]]</span><br><span class="line"> </span><br><span class="line">示例 2：</span><br><span class="line">输入：nums = [1,2,3]</span><br><span class="line">输出：[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]</span><br></pre></td></tr></table></figure><p>这道题和46题的区别在于给定数组内部元素可能重复，不过也不是第一次遇到这样的情况了。</p><blockquote><p>以<code>[1,1,2]</code>为例，从第一个1开始回溯的时候，就可以得到<code>[1,1,2]</code>和<code>[1,2,1]</code>这两个排列。如果不去重，直接走到第二个1时，它还是会得到<code>[1,1,2]</code>和<code>[1,2,1]</code>这两个排列，此时<strong>排列重复</strong>！</p></blockquote><p>因为本题并不在乎子集的顺序，所以我们直接通过<strong>排序</strong>，再加上if判断相邻节点的方式来去重，就可以了。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (i &gt; <span class="number">0</span> &amp;&amp; nums[i] == nums[i - <span class="number">1</span>]) &#123;</span><br><span class="line">    <span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>加了这个代码发现，完全通过不了，输出结果为空，这是为什么呢？</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/04/c16565842d52f6e880e24e67680ceccc.png" alt="image.png"></p><p>以图中的用例<code>[1,1,2]</code>为例，<strong>这里无论什么情况都跳过了第二个1</strong>，第二层的时候也不会使用第二个1（这并不是我们预期的结果），这会导致curV永远无法达到nums的长度，也就没有结果被插入retV数组中。</p><p>正确的去重逻辑应该是：如果上一位被选用过且上一位的值和当前相同，那么就跳过当前位。在if判断中新增一个条件就可以了。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 跳过相同的（前提是上一位已经被选择过了）</span></span><br><span class="line"><span class="keyword">if</span> (i &gt; <span class="number">0</span> &amp;&amp; nums[i] == nums[i - <span class="number">1</span>] &amp;&amp; used[i - <span class="number">1</span>] == <span class="literal">false</span>) &#123;</span><br><span class="line">    <span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意，这里需要判断的是<code>used[i - 1] == false</code>而不是为true的情况，因为在回溯过程中，我们会先把<code>used[i]</code>设置为true，然后又重置为false。在同一层里面，其实不会出现<code>used[i-1]==true</code>的情况（已经被回溯undo了）</p><p>既然不会出现<code>used[i-1]==true</code>的情况，为什么还需添加这个判断条件呢？原因前文已经提到过，如果删除这个判断，那么就会导致去重变成了<strong>多层之间都不会选择相同的数</strong>，这是不符合题目逻辑的！</p><blockquote><p>在代码随想录上有关于这个去重逻辑更详细的解释：<a href="https://www.programmercarl.com/0047.%E5%85%A8%E6%8E%92%E5%88%97II.html#%E6%8B%93%E5%B1%95">点我查看</a></p></blockquote><p>当然，因为去重是基于同一层的，那么完全可以使用<code>unordered_set</code>来去重，效果也是一样的。不过使用set也不能去掉used数组，那还不如直接通过used数组来去重，效率更高。</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/04/0d2a0de90ba7a27ed5797404fac82a53.png" alt="image.png"></p><p>注意，每一层递归都额外定义一个<code>unordered_set</code>会让整体空间复杂度由<code>O(N)</code>变成<code>O(N^2)</code>，所以除非必须的时候，不额外定义set才是更好的做法。</p><h3 id="完整代码-10"><a href="#完整代码-10" class="headerlink" title="完整代码"></a>完整代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; retV;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; curV;</span><br><span class="line">    vector&lt;<span class="type">bool</span>&gt; used;</span><br><span class="line">    <span class="comment">// 同样每一次都是从0开始，但是需要跳过单层已经被选择过的元素</span></span><br><span class="line">    <span class="type">void</span> _permuteUnique(vector&lt;<span class="type">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        <span class="comment">// 长度相等代表找到了一个全排列</span></span><br><span class="line">        <span class="keyword">if</span> (curV.<span class="built_in">size</span>() == nums.<span class="built_in">size</span>()) &#123;</span><br><span class="line">            retV.<span class="built_in">push_back</span>(curV);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="comment">// 跳过相同的（前提是同层上一位已经被选择过了）</span></span><br><span class="line">            <span class="keyword">if</span> (i &gt; <span class="number">0</span> &amp;&amp; nums[i] == nums[i - <span class="number">1</span>] &amp;&amp; used[i - <span class="number">1</span>] == <span class="literal">false</span>) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 正常情况下也需要跳过被选用了的</span></span><br><span class="line">            <span class="keyword">if</span> (used[i] == <span class="literal">true</span>) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            curV.<span class="built_in">push_back</span>(nums[i]);</span><br><span class="line">            used[i] = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">            _permuteUnique(nums);</span><br><span class="line"></span><br><span class="line">            used[i] = <span class="literal">false</span>;</span><br><span class="line">            curV.<span class="built_in">pop_back</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">permuteUnique</span>(vector&lt;<span class="type">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        used.<span class="built_in">resize</span>(nums.<span class="built_in">size</span>(), <span class="literal">false</span>);</span><br><span class="line">        <span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>());</span><br><span class="line"></span><br><span class="line">        _permuteUnique(nums);</span><br><span class="line">        <span class="keyword">return</span> retV;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/04/159a19cdeb90bc479b14da8d8d0d4142.png" alt="image.png"></p><h1 id="6-其他问题"><a href="#6-其他问题" class="headerlink" title="6.其他问题"></a>6.其他问题</h1><h2 id="332-重新安排行程"><a href="#332-重新安排行程" class="headerlink" title="332 重新安排行程"></a>332 重新安排行程</h2><blockquote><p><a href="https://leetcode.cn/problems/reconstruct-itinerary/description/">https://leetcode.cn/problems/reconstruct-itinerary/description/</a></p></blockquote><h3 id="题目和思路-12"><a href="#题目和思路-12" class="headerlink" title="题目和思路"></a>题目和思路</h3><p>给你一份航线列表 tickets ，其中 <code>tickets[i] = [fromi, toi]</code> 表示飞机出发和降落的机场地点。请你对该行程进行重新规划排序。</p><ul><li>所有这些机票都属于一个从 JFK（肯尼迪国际机场）出发的先生，所以该行程必须从 JFK 开始。如果存在多种有效的行程，请你按<strong>字典排序</strong>返回最小的行程组合。</li></ul><p>例如，行程 <code>[&quot;JFK&quot;, &quot;LGA&quot;]</code> 与 <code>[&quot;JFK&quot;, &quot;LGB&quot;]</code> 相比就更小，排序更靠前。</p><p>假定所有机票至少存在一种合理的行程。且所有的机票 必须都用一次 且 只能用一次。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">示例1：</span><br><span class="line">输入：tickets = [[&quot;MUC&quot;,&quot;LHR&quot;],[&quot;JFK&quot;,&quot;MUC&quot;],[&quot;SFO&quot;,&quot;SJC&quot;],[&quot;LHR&quot;,&quot;SFO&quot;]]</span><br><span class="line">输出：[&quot;JFK&quot;,&quot;MUC&quot;,&quot;LHR&quot;,&quot;SFO&quot;,&quot;SJC&quot;]</span><br><span class="line"></span><br><span class="line">示例2：</span><br><span class="line">输入：tickets = [[&quot;JFK&quot;,&quot;SFO&quot;],[&quot;JFK&quot;,&quot;ATL&quot;],[&quot;SFO&quot;,&quot;ATL&quot;],[&quot;ATL&quot;,&quot;JFK&quot;],[&quot;ATL&quot;,&quot;SFO&quot;]]</span><br><span class="line">输出：[&quot;JFK&quot;,&quot;ATL&quot;,&quot;JFK&quot;,&quot;SFO&quot;,&quot;ATL&quot;,&quot;SFO&quot;]</span><br><span class="line">解释：另一种有效的行程是 [&quot;JFK&quot;,&quot;SFO&quot;,&quot;ATL&quot;,&quot;JFK&quot;,&quot;ATL&quot;,&quot;SFO&quot;] ，但是它字典排序更大更靠后。</span><br></pre></td></tr></table></figure><p>提示</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1 &lt;= tickets.length &lt;= 300</span><br><span class="line">tickets[i].length == 2</span><br><span class="line">fromi.length == 3</span><br><span class="line">toi.length == 3</span><br><span class="line">fromi 和 toi 由大写英文字母组成</span><br><span class="line">fromi != toi</span><br></pre></td></tr></table></figure><p>这道题其实更偏向于图论的深搜（还没学），但是它也可以通过回溯的思想来解决。</p><p>首先需要确定如何记录机票，最好的办法自然是用一个unordered_map来记录起始机场和目的机场的关系，且目的机场使用multiset而不是unordered_set，可以自然实现字典排序（set&#x2F;map基于红黑树，是有序的）。使用multiset是为了避免<strong>有多张从A到B</strong>的机票的情况，此时目的地会重复出现。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 起始机场,目的机场集合</span></span><br><span class="line">unordered_map&lt;string,multiset&lt;string&gt;&gt; ticketsMap;</span><br></pre></td></tr></table></figure><p>记录了之后，就可以实现回溯的单层遍历了。这里还需要一个计数器来整体记录当前选了多少个机票，机票数量够了就可以return了。</p><ul><li>参数startAp记录起始机场；</li><li>遍历起始机场的目的地集合<code>ticketsMap[startAp]</code>，每次选择一个，继续往下递归；<ul><li>递归之前需要将选择的目的机场从set中删除，并插入retV返回值数组；</li><li>递归结束之后将选择的目的机场重新插入set，并从retV返回值数组中删除；</li></ul></li><li>当遍历到某个机场的目的地集合为空的时候，说明走到了叶子节点，返回；</li><li>当当前已经选择机票达到上限（注意每个机票必须且只能使用一次），返回；</li></ul><p>这里就出现了一个问题：因为我们需要从set中删除数据，但删除的同时我们又需要继续遍历set，这便是一个经典的<code>迭代器失效</code>问题。因为set是基于红黑树的，当前节点被删除后，它就和其他节点没有链接关系了，迭代器无法继续往下走。不过我们可以先获取下一个迭代器的值，再删除，但那样对于for循环而言就有些麻烦了。</p><p>所以，我们可以将multiset改成另外一个map，用计数器来替代删除。当计数器为0的时候，可以认为这个机票已经不可用了（等价于被删除）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// &lt;起始机场,&lt;目的机场,票数&gt;&gt;</span></span><br><span class="line">unordered_map&lt;string,map&lt;string,<span class="type">int</span>&gt;&gt; ticketsMap;</span><br></pre></td></tr></table></figure><p>用下面的循环对这个map进行初始化</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span>&amp; v : tickets) &#123;</span><br><span class="line">ticketsMap[v[<span class="number">0</span>]][v[<span class="number">1</span>]]++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样，每一层for的时候，直接将对应票数减一即可。循环的时候跳过票数为0的机场即可。当一个机场的所有目的地机票都为0，则说明这个机场不能继续往下飞了。</p><h3 id="错误代码-1"><a href="#错误代码-1" class="headerlink" title="错误代码"></a>错误代码</h3><p>根据上面的思路，可以写出这样的第一版代码。注意代码中<strong>范围循环</strong>中auto一定要写引用<code>auto&amp;</code>，因为我们需要通过<code>p.second</code>直接修改ticket的计数器。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    vector&lt;string&gt; retV;</span><br><span class="line">    <span class="comment">// 判断是否所有机票都用完了</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">checkTicketsEmpty</span><span class="params">(map&lt;string, <span class="type">int</span>&gt;&amp; tickets)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; p : tickets) &#123;</span><br><span class="line">            <span class="keyword">if</span> (p.second != <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 回溯法，每一次都找一个机场走，注意起点机场是JFK</span></span><br><span class="line">    <span class="comment">// ticketSum是总共的机票数量，ticketNum是当前已经被使用过的机票数量</span></span><br><span class="line">    <span class="type">void</span> _findItinerary(unordered_map&lt;string, map&lt;string, <span class="type">int</span>&gt;&gt;&amp; ticketsMap,</span><br><span class="line">                        <span class="type">const</span> <span class="type">int</span> ticketsSum, <span class="type">int</span> ticketsNum,</span><br><span class="line">                        <span class="type">const</span> string&amp; startAp) &#123;</span><br><span class="line">        <span class="comment">// 如果ticket被用完了，也可以返回</span></span><br><span class="line">        <span class="keyword">if</span> (ticketsNum == ticketsSum) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果map里面对应的目的机场机票都用完了，这一层没有办法往下走了</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">checkTicketsEmpty</span>(ticketsMap[startAp])) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果不是，随机选择一个机场往下走</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; p : ticketsMap[startAp]) &#123;</span><br><span class="line">            <span class="comment">// 跳过已经选择了的机场</span></span><br><span class="line">            <span class="keyword">if</span> (p.second == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 没有选择过，可以走</span></span><br><span class="line">            retV.<span class="built_in">push_back</span>(p.first);</span><br><span class="line">            p.second--;   <span class="comment">// 机票数量减一</span></span><br><span class="line">            ticketsNum++; <span class="comment">// 已选机票数量加一</span></span><br><span class="line">            cout &lt;&lt; startAp &lt;&lt; <span class="string">&quot;-&gt;&quot;</span> &lt;&lt; p.first &lt;&lt; <span class="string">&quot;:&quot;</span> &lt;&lt; p.second</span><br><span class="line">                 &lt;&lt; <span class="string">&quot; num:&quot;</span> &lt;&lt; ticketsNum &lt;&lt; endl;</span><br><span class="line">            _findItinerary(ticketsMap, ticketsSum, ticketsNum, p.first);</span><br><span class="line">            <span class="comment">// 回溯操作</span></span><br><span class="line">            p.second++;</span><br><span class="line">            ticketsNum--;</span><br><span class="line">            retV.<span class="built_in">pop_back</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;string&gt; <span class="title">findItinerary</span><span class="params">(vector&lt;vector&lt;string&gt;&gt;&amp; tickets)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 存放&lt;起点机场,&lt;目的机场,票数&gt;&gt;</span></span><br><span class="line">        <span class="comment">// 两个机场之间单向只会有一个票，所以不需要用multimap</span></span><br><span class="line">        unordered_map&lt;string, map&lt;string, <span class="type">int</span>&gt;&gt; ticketsMap;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; v : tickets) &#123;</span><br><span class="line">            ticketsMap[v[<span class="number">0</span>]][v[<span class="number">1</span>]]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 因为是从JFK开始的，所以需要先把第一个值插入</span></span><br><span class="line">        retV.<span class="built_in">push_back</span>(<span class="string">&quot;JFK&quot;</span>);</span><br><span class="line">        _findItinerary(ticketsMap, tickets.<span class="built_in">size</span>(), <span class="number">0</span>, <span class="string">&quot;JFK&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> retV;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>但是这一版代码有问题，会发现结果集里面只有JFK被插入了</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/04/da1d1929064a8726263cbe4a56fad97e.png" alt="image.png"></p><p>这是因为当前用例中，for循环内并没有进行条件判断，这就导致retV一直在被<code>插入-&gt;递归-&gt;删除</code>，最终retV里面的值还是空的。</p><p>添加一个cout打印，可以看到如下输出，其中ticketsNum已经打印到4了，说明我们期待的结果起始已经出现了，但因为回溯的<code>pop_back</code>又被删除了。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">JFK-&gt;MUC:0 num:1</span><br><span class="line">MUC-&gt;LHR:0 num:2</span><br><span class="line">LHR-&gt;SFO:0 num:3</span><br><span class="line">SFO-&gt;SJC:0 num:4</span><br></pre></td></tr></table></figure><p>所以，我们需要在for循环中添加一个判断，当当前递归的返回值retV已经符合条件的时候，直接跳过pop_back回溯步骤，提前返回。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">_findItinerary(ticketsMap, ticketsSum, ticketsNum, p.first);</span><br><span class="line">         <span class="comment">// 符合条件了，直接跳出</span></span><br><span class="line">         <span class="keyword">if</span> (retV.<span class="built_in">size</span>() == ticketsSum) &#123;</span><br><span class="line">             <span class="keyword">return</span>;</span><br><span class="line">         &#125;</span><br></pre></td></tr></table></figure><p>这里的判断是错误的，因为传入的ticketsSum是机票的总数量，而retV中的结果集是存放路途中经过地点的，经过的地点应该比机票数量多一张！</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 符合条件了，直接跳出，地点比机票数量多一个</span></span><br><span class="line"><span class="keyword">if</span> (retV.<span class="built_in">size</span>() == ticketsSum+<span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="完整代码-11"><a href="#完整代码-11" class="headerlink" title="完整代码"></a>完整代码</h3><p>下面是正确的代码</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    vector&lt;string&gt; retV;</span><br><span class="line">    <span class="comment">// 判断是否所有机票都用完了</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">checkTicketsEmpty</span><span class="params">(map&lt;string, <span class="type">int</span>&gt;&amp; tickets)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; p : tickets) &#123;</span><br><span class="line">            <span class="keyword">if</span> (p.second != <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 回溯法，每一次都找一个机场走，注意起点机场是JFK</span></span><br><span class="line">    <span class="comment">// ticketSum是总共的机票数量，ticketNum是当前已经被使用过的机票数量</span></span><br><span class="line">    <span class="type">void</span> _findItinerary(unordered_map&lt;string, map&lt;string, <span class="type">int</span>&gt;&gt;&amp; ticketsMap,</span><br><span class="line">                        <span class="type">const</span> <span class="type">int</span> ticketsSum, <span class="type">int</span> ticketsNum,</span><br><span class="line">                        <span class="type">const</span> string&amp; startAp) &#123;</span><br><span class="line">        <span class="comment">// 如果ticket被用完了，也可以返回</span></span><br><span class="line">        <span class="keyword">if</span> (ticketsNum == ticketsSum) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果map里面对应的目的机场机票都用完了，这一层没有办法往下走了</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">checkTicketsEmpty</span>(ticketsMap[startAp])) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果不是，随机选择一个机场往下走</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; p : ticketsMap[startAp]) &#123;</span><br><span class="line">            <span class="comment">// 跳过已经选择了的机场</span></span><br><span class="line">            <span class="keyword">if</span> (p.second == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 没有选择过，可以走</span></span><br><span class="line">            retV.<span class="built_in">push_back</span>(p.first);</span><br><span class="line">            p.second--;   <span class="comment">// 机票数量减一</span></span><br><span class="line">            ticketsNum++; <span class="comment">// 已选机票数量加一</span></span><br><span class="line">            <span class="comment">// cout &lt;&lt; startAp &lt;&lt; &quot;-&gt;&quot; &lt;&lt; p.first &lt;&lt; &quot;:&quot; &lt;&lt; p.second</span></span><br><span class="line">            <span class="comment">//      &lt;&lt; &quot; num:&quot; &lt;&lt; ticketsNum &lt;&lt; endl;</span></span><br><span class="line">            _findItinerary(ticketsMap, ticketsSum, ticketsNum, p.first);</span><br><span class="line">            <span class="comment">// 符合条件了，直接跳出，地点比机票数量多一个</span></span><br><span class="line">            <span class="keyword">if</span> (retV.<span class="built_in">size</span>() == ticketsSum + <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 回溯操作</span></span><br><span class="line">            p.second++;</span><br><span class="line">            ticketsNum--;</span><br><span class="line">            retV.<span class="built_in">pop_back</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;string&gt; <span class="title">findItinerary</span><span class="params">(vector&lt;vector&lt;string&gt;&gt;&amp; tickets)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 存放&lt;起点机场,&lt;目的机场,票数&gt;&gt;</span></span><br><span class="line">        <span class="comment">// 两个机场之间单向只会有一个票，所以不需要用multimap</span></span><br><span class="line">        unordered_map&lt;string, map&lt;string, <span class="type">int</span>&gt;&gt; ticketsMap;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; v : tickets) &#123;</span><br><span class="line">            ticketsMap[v[<span class="number">0</span>]][v[<span class="number">1</span>]]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 因为是从JFK开始的，所以需要先把第一个值插入</span></span><br><span class="line">        retV.<span class="built_in">push_back</span>(<span class="string">&quot;JFK&quot;</span>);</span><br><span class="line">        _findItinerary(ticketsMap, tickets.<span class="built_in">size</span>(), <span class="number">0</span>, <span class="string">&quot;JFK&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> retV;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/04/ddda44cea08f7d0f079120b8fa5efe7f.png" alt="image.png"></p><p>这个代码还有可优化之处，比如<code>checkTicketsEmpty</code>函数中做的判断就没有意义了，因为for循环中本来也会判断票数是否为0。加上这个函数会让每一层递归的时间复杂度多一个<code>O(N)</code>。把它删除，代码也能通过。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    vector&lt;string&gt; retV;</span><br><span class="line">    <span class="comment">// 回溯法，每一次都找一个机场走，注意起点机场是JFK</span></span><br><span class="line">    <span class="comment">// ticketSum是总共的机票数量，ticketNum是当前已经被使用过的机票数量</span></span><br><span class="line">    <span class="type">void</span> _findItinerary(unordered_map&lt;string, map&lt;string, <span class="type">int</span>&gt;&gt;&amp; ticketsMap,</span><br><span class="line">                        <span class="type">const</span> <span class="type">int</span> ticketsSum, <span class="type">int</span> ticketsNum,</span><br><span class="line">                        <span class="type">const</span> string&amp; startAp) &#123;</span><br><span class="line">        <span class="comment">// 如果ticket被用完了，也可以返回</span></span><br><span class="line">        <span class="keyword">if</span> (ticketsNum == ticketsSum) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果不是，随机选择一个机场往下走</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; p : ticketsMap[startAp]) &#123;</span><br><span class="line">            <span class="comment">// 跳过已经选择了的机场</span></span><br><span class="line">            <span class="keyword">if</span> (p.second == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 没有选择过，可以走</span></span><br><span class="line">            retV.<span class="built_in">push_back</span>(p.first);</span><br><span class="line">            p.second--;   <span class="comment">// 机票数量减一</span></span><br><span class="line">            ticketsNum++; <span class="comment">// 已选机票数量加一</span></span><br><span class="line"><span class="comment">// 递归下一层</span></span><br><span class="line">            _findItinerary(ticketsMap, ticketsSum, ticketsNum, p.first);</span><br><span class="line">            <span class="comment">// 符合条件了，直接跳出，地点数量比机票数量多一个</span></span><br><span class="line">            <span class="keyword">if</span> (retV.<span class="built_in">size</span>() == ticketsSum + <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 回溯操作</span></span><br><span class="line">            p.second++;</span><br><span class="line">            ticketsNum--;</span><br><span class="line">            retV.<span class="built_in">pop_back</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;string&gt; <span class="title">findItinerary</span><span class="params">(vector&lt;vector&lt;string&gt;&gt;&amp; tickets)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 存放&lt;起点机场,&lt;目的机场,票数&gt;&gt;</span></span><br><span class="line">        <span class="comment">// 两个机场之间单向只会有一个票，所以不需要用multimap</span></span><br><span class="line">        unordered_map&lt;string, map&lt;string, <span class="type">int</span>&gt;&gt; ticketsMap;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; v : tickets) &#123;</span><br><span class="line">            ticketsMap[v[<span class="number">0</span>]][v[<span class="number">1</span>]]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 因为是从JFK开始的，所以需要先把第一个值插入</span></span><br><span class="line">        retV.<span class="built_in">push_back</span>(<span class="string">&quot;JFK&quot;</span>);</span><br><span class="line">        _findItinerary(ticketsMap, tickets.<span class="built_in">size</span>(), <span class="number">0</span>, <span class="string">&quot;JFK&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> retV;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>耗时也变短了（虽然这个耗时没有参考价值）。</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/04/9532e24a5566b8086b9d11f7d70c9b70.png" alt="image.png"></p><h3 id="代码随想录版本"><a href="#代码随想录版本" class="headerlink" title="代码随想录版本"></a>代码随想录版本</h3><p>下面的代码是《代码随想录》上的版本，大佬将递归函数的返回值改成了bool，以此来标识是否符合条件，true代表可以提前退出。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="comment">// unordered_map&lt;出发机场, map&lt;到达机场, 航班次数&gt;&gt; targets</span></span><br><span class="line">unordered_map&lt;string, map&lt;string, <span class="type">int</span>&gt;&gt; targets;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">backtracking</span><span class="params">(<span class="type">int</span> ticketNum, vector&lt;string&gt;&amp; result)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (result.<span class="built_in">size</span>() == ticketNum + <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (pair&lt;<span class="type">const</span> string, <span class="type">int</span>&gt;&amp; target : targets[result[result.<span class="built_in">size</span>() - <span class="number">1</span>]]) &#123;</span><br><span class="line">        <span class="keyword">if</span> (target.second &gt; <span class="number">0</span> ) &#123; <span class="comment">// 记录到达机场是否飞过了</span></span><br><span class="line">            result.<span class="built_in">push_back</span>(target.first);</span><br><span class="line">            target.second--;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">backtracking</span>(ticketNum, result)) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            result.<span class="built_in">pop_back</span>();</span><br><span class="line">            target.second++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;string&gt; <span class="title">findItinerary</span><span class="params">(vector&lt;vector&lt;string&gt;&gt;&amp; tickets)</span> </span>&#123;</span><br><span class="line">        targets.<span class="built_in">clear</span>();</span><br><span class="line">        vector&lt;string&gt; result;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">const</span> vector&lt;string&gt;&amp; vec : tickets) &#123;</span><br><span class="line">            targets[vec[<span class="number">0</span>]][vec[<span class="number">1</span>]]++; <span class="comment">// 记录映射关系</span></span><br><span class="line">        &#125;</span><br><span class="line">        result.<span class="built_in">push_back</span>(<span class="string">&quot;JFK&quot;</span>); <span class="comment">// 起始机场</span></span><br><span class="line">        <span class="built_in">backtracking</span>(tickets.<span class="built_in">size</span>(), result);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="51-N皇后"><a href="#51-N皇后" class="headerlink" title="51 N皇后"></a>51 N皇后</h2><blockquote><p><a href="https://leetcode.cn/problems/n-queens/description/">https://leetcode.cn/problems/n-queens/description/</a></p></blockquote><h3 id="题目和思路-13"><a href="#题目和思路-13" class="headerlink" title="题目和思路"></a>题目和思路</h3><p>按照国际象棋的规则，皇后可以攻击与之处在同一行或同一列或同一斜线上的棋子。</p><p>n 皇后问题 研究的是如何将 n 个皇后放置在 n×n 的棋盘上，并且使皇后彼此之间不能相互攻击。</p><p>给你一个整数 n ，返回所有不同的 n 皇后问题 的解决方案。</p><p>每一种解法包含一个不同的 n 皇后问题 的棋子放置方案，该方案中 ‘Q’ 和 ‘.’ 分别代表了皇后和空位。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">示例 1：</span><br><span class="line">输入：n = 4</span><br><span class="line">输出：[[&quot;.Q..&quot;,&quot;...Q&quot;,&quot;Q...&quot;,&quot;..Q.&quot;],[&quot;..Q.&quot;,&quot;Q...&quot;,&quot;...Q&quot;,&quot;.Q..&quot;]]</span><br><span class="line">解释：如上图所示，4 皇后问题存在两个不同的解法。</span><br><span class="line"></span><br><span class="line">示例 2：</span><br><span class="line">输入：n = 1</span><br><span class="line">输出：[[&quot;Q&quot;]]</span><br></pre></td></tr></table></figure><p>这道题是回溯的经典题目：</p><ul><li>回溯每一层模拟每一列的遍历（横向）</li><li>多层递归模拟每一行行的遍历（纵向）</li></ul><p>整体的思路如下：</p><ul><li>每一层的for在当前行选择一个位置设置为Q</li><li>判断该位置是否符合N皇后的条件</li><li>符合，递归下一层，行号加一</li><li>当行号等于N时，代表越界，插入结果集并终止递归。</li></ul><p>主要是写出判断每一层是否符合皇后占位的代码，回溯的思路不难。</p><ul><li>皇后所在的行和列，斜线上都不能有其他皇后。</li></ul><p>对于我们的回溯而言，因为每一层都是for在当前行选择一个作为皇后，所以同行不会有多个皇后，不需要判断当前行。</p><p>而回溯的每一层是模拟从上往下的纵向遍历，所以纵向上也只需要判断<strong>当前列</strong>在当前行之前是否有其他皇后（当前行之后都还没有被操作）。</p><p>其次就是斜线上的判断了，这里主要涉及到行和列下标如何操作，注意我们是从当前位置沿着斜线往上遍历</p><ul><li>135°斜线（右上到左下）：行号和列号每次都减一；</li><li>45°斜线（左下到右上）：行号减一，列号加一；</li></ul><p>如下就是判断当前位置是否可以放皇后的代码。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">checkQueen</span><span class="params">(<span class="type">const</span> vector&lt;string&gt;&amp; curV, <span class="type">int</span> n, <span class="type">int</span> row, <span class="type">int</span> col)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 因为在回溯每一层的时候都只会选择一行进行处理，一行只会有一个Q，不需要遍历</span></span><br><span class="line">    <span class="comment">// 遍历列（这里小于row就行了，因为回溯才走到这里，更大的行是没有数据的）</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; row; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (curV[i][col] == <span class="string">&#x27;Q&#x27;</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 遍历右边斜线（从右上到左下的斜线,135°）</span></span><br><span class="line">    <span class="comment">// 减一开始往回遍历</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = row - <span class="number">1</span>, j = col - <span class="number">1</span>; i &gt;= <span class="number">0</span> &amp;&amp; j &gt;= <span class="number">0</span>; i--, j--) &#123;</span><br><span class="line">        <span class="keyword">if</span> (curV[i][j] == <span class="string">&#x27;Q&#x27;</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 遍历左边斜线，45°</span></span><br><span class="line">    <span class="comment">// 这里应该是列加一行减一，然后每一次都是行减一列加一</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = row - <span class="number">1</span>, j = col + <span class="number">1</span>; i &gt;= <span class="number">0</span> &amp;&amp; j &lt; n; i--, j++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (curV[i][j] == <span class="string">&#x27;Q&#x27;</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="错误代码-2"><a href="#错误代码-2" class="headerlink" title="错误代码"></a>错误代码</h3><p>刚开始我写出了这样的代码</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> col = <span class="number">0</span>; col &lt; n; col++) &#123;</span><br><span class="line">          <span class="comment">// 判断是否符合条件，不符合直接返回</span></span><br><span class="line">          <span class="keyword">if</span> (<span class="built_in">checkQueen</span>(curV, n, row, col) == <span class="literal">false</span>) &#123;</span><br><span class="line">              <span class="keyword">continue</span>; <span class="comment">// 后面可能有符合条件的，不能return</span></span><br><span class="line">          &#125;</span><br><span class="line">          curV[row][col] = <span class="string">&#x27;Q&#x27;</span>; <span class="comment">// 假设为皇后</span></span><br><span class="line">          row++;                <span class="comment">// 下一行</span></span><br><span class="line">          <span class="comment">// 递归</span></span><br><span class="line">          _solveNQueens(n, row, curV);</span><br><span class="line">          <span class="comment">// 回溯</span></span><br><span class="line">          curV[row][col] = <span class="string">&#x27;.&#x27;</span>; <span class="comment">// 重置</span></span><br><span class="line">          row--; </span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure><p>但是提交发现retV始终为空，想不明白为什么。最终加了一堆打印之后，发现了问题所在。如下所示，这是正确的一个结果集内的回溯过程，选中了<code>(0,1)</code>和<code>(1,3)</code>后，理论上<code>(2,0)</code>应该要被选中，但是<code>(2,0)</code>在判断中却因为<code>(0,0)</code>处是Q而退出了。打印出第0行的字符串，发现这里就有两个Q，很明显是第一波的操作没有被成功回溯。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">good: 0 1</span><br><span class="line">1 0</span><br><span class="line">1 1</span><br><span class="line">1 2</span><br><span class="line">1 3</span><br><span class="line">good: 1 3</span><br><span class="line">2 0</span><br><span class="line">2,0 exit here1： 0 0</span><br><span class="line">string: QQ..</span><br></pre></td></tr></table></figure><p>检查回溯部分的代码，会发现这两行有问题</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 回溯</span></span><br><span class="line">curV[row][col] = <span class="string">&#x27;.&#x27;</span>; <span class="comment">// 重置</span></span><br><span class="line">row--; </span><br></pre></td></tr></table></figure><p>在调用递归函数之前，将row++了，此时回溯却先重置点再row–，问题就出现了：被重置的是下一行的col位置，和当前应该回溯的不是同一个位置！<strong>正确代码是先修复row再重置数组中的值</strong>！</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 回溯</span></span><br><span class="line">row--; </span><br><span class="line">curV[row][col] = <span class="string">&#x27;.&#x27;</span>; <span class="comment">// 重置</span></span><br><span class="line"><span class="comment">// row--; // error，应该先减减再重置数组中的值</span></span><br></pre></td></tr></table></figure><h3 id="完整代码-12"><a href="#完整代码-12" class="headerlink" title="完整代码"></a>完整代码</h3><p>正确的代码如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    vector&lt;vector&lt;string&gt;&gt; retV;</span><br><span class="line">    <span class="comment">// n是皇后数量（同时也是棋盘的边长），row是行号</span></span><br><span class="line">    <span class="type">void</span> _solveNQueens(<span class="type">int</span> n, <span class="type">int</span> row, vector&lt;string&gt;&amp; curV) &#123;</span><br><span class="line">        <span class="comment">// 行号是下标，当下标row等于n的时候代表越界，找到了一个解</span></span><br><span class="line">        <span class="keyword">if</span> (n == row) &#123;</span><br><span class="line">            retV.<span class="built_in">push_back</span>(curV);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 列号，每一位都尝试使用</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> col = <span class="number">0</span>; col &lt; n; col++) &#123;</span><br><span class="line">            <span class="comment">// 判断是否符合条件，不符合直接返回</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">checkQueen</span>(curV, n, row, col) == <span class="literal">false</span>) &#123;</span><br><span class="line">                <span class="keyword">continue</span>; <span class="comment">// 后面可能有符合条件的，不能return</span></span><br><span class="line">            &#125;</span><br><span class="line">            curV[row][col] = <span class="string">&#x27;Q&#x27;</span>; <span class="comment">// 假设为皇后</span></span><br><span class="line">            row++;                <span class="comment">// 下一行</span></span><br><span class="line">            <span class="comment">// 递归</span></span><br><span class="line">            _solveNQueens(n, row, curV);</span><br><span class="line">            <span class="comment">// 回溯</span></span><br><span class="line">            row--;</span><br><span class="line">            curV[row][col] = <span class="string">&#x27;.&#x27;</span>; <span class="comment">// 重置</span></span><br><span class="line">            <span class="comment">// row--; // error，应该先减减再重置数组中的值</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 注意，每一次选择都需要做检查，判断同一行，同一列，斜线上是否有其他皇后</span></span><br><span class="line">    <span class="comment">// 入参是当前插入皇后的位置</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">checkQueen</span><span class="params">(<span class="type">const</span> vector&lt;string&gt;&amp; curV, <span class="type">int</span> n, <span class="type">int</span> row, <span class="type">int</span> col)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 因为在回溯每一层的时候都只会选择一行进行处理，一行只会有一个Q，不需要遍历</span></span><br><span class="line">        <span class="comment">// 遍历列（这里小于row就行了，因为回溯才走到这里，更大的行是没有数据的）</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; row; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (curV[i][col] == <span class="string">&#x27;Q&#x27;</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 遍历右边斜线（从右上到左下的斜线,135°）</span></span><br><span class="line">        <span class="comment">// 减一开始往回遍历</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = row - <span class="number">1</span>, j = col - <span class="number">1</span>; i &gt;= <span class="number">0</span> &amp;&amp; j &gt;= <span class="number">0</span>; i--, j--) &#123;</span><br><span class="line">            <span class="keyword">if</span> (curV[i][j] == <span class="string">&#x27;Q&#x27;</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 遍历左边斜线，45°</span></span><br><span class="line">        <span class="comment">// 这里应该是列加一行减一，然后每一次都是行减一列加一</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = row - <span class="number">1</span>, j = col + <span class="number">1</span>; i &gt;= <span class="number">0</span> &amp;&amp; j &lt; n; i--, j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (curV[i][j] == <span class="string">&#x27;Q&#x27;</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;string&gt;&gt; <span class="built_in">solveNQueens</span>(<span class="type">int</span> n) &#123;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">1</span>) &#123;</span><br><span class="line">            retV.<span class="built_in">push_back</span>(vector&lt;string&gt;&#123;<span class="string">&quot;Q&quot;</span>&#125;);</span><br><span class="line">            <span class="keyword">return</span> retV;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 注意vector需要初始化，不然没有办法直接下标操作</span></span><br><span class="line">        <span class="function">vector&lt;string&gt; <span class="title">curV</span><span class="params">(n, string(n, <span class="string">&#x27;.&#x27;</span>))</span></span>;</span><br><span class="line">        _solveNQueens(n, <span class="number">0</span>, curV);</span><br><span class="line">        <span class="keyword">return</span> retV;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/04/8ce3959a7b61554f8450dfbe341bb492.png" alt="image.png"></p>]]></content>
    
    
    <summary type="html">学习回溯算法并练习</summary>
    
    
    
    <category term="编程学习" scheme="https://blog.musnow.top/categories/%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="把题目都给刷干净" scheme="https://blog.musnow.top/categories/%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0/%E6%8A%8A%E9%A2%98%E7%9B%AE%E9%83%BD%E7%BB%99%E5%88%B7%E5%B9%B2%E5%87%80/"/>
    
    
    <category term="算法" scheme="https://blog.musnow.top/tags/%E7%AE%97%E6%B3%95/"/>
    
    <category term="Cpp" scheme="https://blog.musnow.top/tags/Cpp/"/>
    
    <category term="回溯" scheme="https://blog.musnow.top/tags/%E5%9B%9E%E6%BA%AF/"/>
    
  </entry>
  
  <entry>
    <title>【leetcode】哈希OJ题，383赎金信/202快乐数/242有效的字母异位词</title>
    <link href="https://blog.musnow.top/posts/4214339491/"/>
    <id>https://blog.musnow.top/posts/4214339491/</id>
    <published>2024-03-18T08:18:13.000Z</published>
    <updated>2024-03-19T04:47:49.000Z</updated>
    
    <content type="html"><![CDATA[<p>这几道哈希的题目，其用到的思想适用于很多可以用哈希来解决的题目。</p><h1 id="383-赎金信"><a href="#383-赎金信" class="headerlink" title="383. 赎金信"></a>383. 赎金信</h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><blockquote><p><a href="https://leetcode.cn/problems/ransom-note/">383. 赎金信</a></p></blockquote><p>给你两个字符串：<code>ransomNote</code> 和 <code>magazine</code> ，判断 <code>ransomNote</code> 能不能由 <code>magazine</code> 里面的字符构成。</p><p>如果可以，返回 <code>true</code> ；否则返回 <code>false</code> 。</p><p><code>magazine</code> 中的每个字符只能在 <code>ransomNote</code> 中使用一次。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">示例 1：</span><br><span class="line">输入：ransomNote = &quot;a&quot;, magazine = &quot;b&quot;</span><br><span class="line">输出：false</span><br><span class="line"></span><br><span class="line">示例 2：</span><br><span class="line">输入：ransomNote = &quot;aa&quot;, magazine = &quot;ab&quot;</span><br><span class="line">输出：false</span><br><span class="line"></span><br><span class="line">示例 3：</span><br><span class="line">输入：ransomNote = &quot;aa&quot;, magazine = &quot;aab&quot;</span><br><span class="line">输出：true</span><br></pre></td></tr></table></figure><ul><li><code>1 &lt;= ransomNote.length, magazine.length &lt;= 105</code></li><li><code>ransomNote</code> 和 <code>magazine</code> 由小写英文字母组成</li></ul><h2 id="思路和代码"><a href="#思路和代码" class="headerlink" title="思路和代码"></a>思路和代码</h2><p>因为给出的两个字符串里面都只包含小写的英文字母，所以我们用不上<code>unordered_map</code>，只需要用一个26长度的int数组就可以了。</p><ul><li>26长度的int数组，全部初始化为0；</li><li>遍历，记录magazine中每一个字符出现的次数；</li><li>遍历ransomNote字符串，将magazine中对应字符计数器减一；</li><li>如果某个计数器减至负数，则说明magazine中的字符不够用，返回false；</li><li>如果遍历完毕没有出现问题，则返回true；</li></ul><p>代码如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">canConstruct</span><span class="params">(string ransomNote, string magazine)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(ransomNote.<span class="built_in">size</span>() &gt; magazine.<span class="built_in">size</span>())&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">// 因为已经超过了字符大小，所以肯定不符合条件</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> arr[<span class="number">26</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i&lt;magazine.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            arr[magazine[i] -<span class="string">&#x27;a&#x27;</span>] ++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i&lt;ransomNote.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            arr[ransomNote[i] -<span class="string">&#x27;a&#x27;</span>] --;</span><br><span class="line">            <span class="keyword">if</span>(arr[ransomNote[i] -<span class="string">&#x27;a&#x27;</span>] &lt; <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/03/8a3bc3b098bf98a6b3b28842d6ef6436.png" alt="image-20240318180705925"></p><h1 id="202-快乐数"><a href="#202-快乐数" class="headerlink" title="202. 快乐数"></a>202. 快乐数</h1><h2 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h2><blockquote><p><a href="https://leetcode.cn/problems/happy-number/">202. 快乐数</a></p></blockquote><p>编写一个算法来判断一个数 <code>n</code> 是不是快乐数。</p><p><strong>「快乐数」</strong> 定义为：</p><ul><li>对于一个正整数，每一次将该数替换为它每个位置上的数字的平方和。</li><li>然后重复这个过程直到这个数变为 1，也可能是 <strong>无限循环</strong> 但始终变不到 1。</li><li>如果这个过程 <strong>结果为</strong> 1，那么这个数就是快乐数。</li></ul><p>如果 <code>n</code> 是 <em>快乐数</em> 就返回 <code>true</code> ；不是，则返回 <code>false</code> 。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">示例 1：</span><br><span class="line">输入：n = 19</span><br><span class="line">输出：true</span><br><span class="line">解释：</span><br><span class="line">12 + 92 = 82</span><br><span class="line">82 + 22 = 68</span><br><span class="line">62 + 82 = 100</span><br><span class="line">12 + 02 + 02 = 1</span><br><span class="line"></span><br><span class="line">示例 2：</span><br><span class="line">输入：n = 2</span><br><span class="line">输出：false</span><br></pre></td></tr></table></figure><ul><li><code>1 &lt;= n &lt;= 231 - 1</code></li></ul><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>这道题其实是个数学题，用到哈希的地方是判断之前出现的结果是否已经出现过了。题目中提到“然后重复这个过程直到这个数变为 1，也可能是 <strong>无限循环</strong> 但始终变不到 1”，即可能会有用例，到最后计算的结果出现无限循环。</p><p>此时就需要用哈希来判断某一个结果是否已经出现过，如果出现过，第二次出现的时候就说明重复了，返回false退出循环计算即可。</p><p>代码如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="comment">// 每一次的计算</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getSum</span><span class="params">(<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="type">int</span> sum = <span class="number">0</span>; <span class="comment">// 这里必须赋值为0</span></span><br><span class="line">        <span class="keyword">while</span>(n &gt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            sum += (n%<span class="number">10</span>)*(n%<span class="number">10</span>);</span><br><span class="line">            n/=<span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isHappy</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        unordered_set&lt;<span class="type">int</span>&gt; sets;</span><br><span class="line">        <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            sum = <span class="built_in">getSum</span>(n);</span><br><span class="line">            cout &lt;&lt; sum &lt;&lt; endl;</span><br><span class="line">            <span class="keyword">if</span>(sum == <span class="number">1</span>)&#123; <span class="comment">// 符合题目条件</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(sets.<span class="built_in">count</span>(sum) != <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">// 出现重复了</span></span><br><span class="line">            &#125;</span><br><span class="line">            sets.<span class="built_in">insert</span>(sum);</span><br><span class="line">            n = sum;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/03/839bd09fa76c380a299c5e0c319ad1b9.png" alt="image-20240318181637436"></p><h1 id="242-有效的字母异位词"><a href="#242-有效的字母异位词" class="headerlink" title="242. 有效的字母异位词"></a>242. 有效的字母异位词</h1><h2 id="题目-2"><a href="#题目-2" class="headerlink" title="题目"></a>题目</h2><blockquote><p><a href="https://leetcode.cn/problems/valid-anagram/">242. 有效的字母异位词</a></p></blockquote><p>给定两个字符串 <code>*s*</code> 和 <code>*t*</code> ，编写一个函数来判断 <code>*t*</code> 是否是 <code>*s*</code> 的字母异位词。</p><p><strong>注意：</strong>若 <code>*s*</code> 和 <code>*t*</code> 中每个字符出现的次数都相同，则称 <code>*s*</code> 和 <code>*t*</code> 互为字母异位词。</p><p><strong>示例 1:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: s = &quot;anagram&quot;, t = &quot;nagaram&quot;</span><br><span class="line">输出: true</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: s = &quot;rat&quot;, t = &quot;car&quot;</span><br><span class="line">输出: false</span><br></pre></td></tr></table></figure><p><strong>提示:</strong></p><ul><li><code>1 &lt;= s.length, t.length &lt;= 5 * 104</code></li><li><code>s</code> 和 <code>t</code> 仅包含小写字母</li></ul><h2 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h2><p>字母异位词就是两个字符串中所有字符出现的次数都相同，如果有不同的就不是字母异位词。</p><p>可以用两种思路来解决</p><ul><li>对字符串排序，字母异位词排序后的结果肯定相同</li><li>使用哈希计算每个字符出现的次数，比较两个字符串中每个字符出现的次数是否相同，不相同则出现错误</li></ul><p>这里采用哈希的思路，代码如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isAnagram</span><span class="params">(string s, string t)</span> </span>&#123;</span><br><span class="line">        unordered_map&lt;<span class="type">char</span>,<span class="type">int</span>&gt; maps;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span>&amp;e:s)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(!maps.<span class="built_in">count</span>(e))</span><br><span class="line">            &#123;</span><br><span class="line">                maps[e] = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                maps[e]++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span>&amp;e:t)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(!maps.<span class="built_in">count</span>(e))&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            maps[e]--;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span>&amp;e:maps)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(e.second != <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/03/092cbf9c367cf0a04561d745cb40624d.png" alt="image-20240318181945788"></p>]]></content>
    
    
    <summary type="html">哈希OJ题，383赎金信/202快乐数/242有效的字母异位词</summary>
    
    
    
    <category term="编程学习" scheme="https://blog.musnow.top/categories/%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="把题目都给刷干净" scheme="https://blog.musnow.top/categories/%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0/%E6%8A%8A%E9%A2%98%E7%9B%AE%E9%83%BD%E7%BB%99%E5%88%B7%E5%B9%B2%E5%87%80/"/>
    
    
    <category term="OJ刷题" scheme="https://blog.musnow.top/tags/OJ%E5%88%B7%E9%A2%98/"/>
    
    <category term="Cpp" scheme="https://blog.musnow.top/tags/Cpp/"/>
    
    <category term="leetcode" scheme="https://blog.musnow.top/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>【C语言】带你用偷懒的方式刷爆二叉树OJ题</title>
    <link href="https://blog.musnow.top/posts/4165981723/"/>
    <id>https://blog.musnow.top/posts/4165981723/</id>
    <published>2024-03-15T08:25:30.000Z</published>
    <updated>2024-03-22T11:59:41.000Z</updated>
    
    <content type="html"><![CDATA[<p>本文首发于<code>2022-04-20</code>，2024年重新刷题，对本文做了较大更新，所以重新发布。</p><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>上篇博客我带大家领略了一番链式二叉树的操作，现在让我们来看看二叉树的相关题目，一起来巩固一下知识点吧！</p><p>点我复习上一篇博客的内容！👉 <a href="https://blog.csdn.net/muxuen/article/details/124212851?spm=1001.2014.3001.5501">传送门</a>；</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2023/02/202204161641683.gif" alt="QQ图片20220416140203"></p><h1 id="1-一些选择题"><a href="#1-一些选择题" class="headerlink" title="1.一些选择题"></a>1.一些选择题</h1><h2 id="1-1"><a href="#1-1" class="headerlink" title="1.1"></a>1.1</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">设一棵二叉树中有3个叶子结点，有8个度为1的结点，则该二叉树中总的结点数为（ ）个</span><br><span class="line">A.11</span><br><span class="line">B.12</span><br><span class="line">C.13  √</span><br><span class="line">D.14</span><br></pre></td></tr></table></figure><blockquote><p>设Ni表示度为i的节点个数，则节点总数 N &#x3D; N0 + N1 + N2</p><p>节点个数于节点边的关系： <strong>N个节点的树有N-1个边</strong></p><p>边与度的关系：N - 1 &#x3D; N1 + 2 * N2</p><p>故：N0 + N1 + N2 - 1 &#x3D; N1 + 2 * N2</p><p>因此，得：N0 &#x3D; N2 + 1</p><p>回到原题，N0 &#x3D; 3，N1 &#x3D; 8，可得N2 &#x3D; 2</p><p>因此答案是 3 + 8 + 2 &#x3D; 13</p></blockquote><h2 id="1-2"><a href="#1-2" class="headerlink" title="1.2"></a>1.2</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">有N个元素的完全二叉树的深度是()</span><br><span class="line">答案：logN+1</span><br></pre></td></tr></table></figure><p>高度为h的完全二叉树，节点个数在： <code>2^(h - 1) - 1 &lt; n &lt;= 2^h - 1</code></p><p>即<code>log(n + 1) &lt;= h &lt; log(n + 1) + 1</code></p><p>这里需要注意的是n左右区间的开闭问题</p><p>完全二叉树最少的节点个数是<code>2^(h - 1)-1+1</code>个，所以是<code>n&gt;2^(h - 1) - 1</code></p><hr><h2 id="1-3-由已知遍历序列画出原本树的结构"><a href="#1-3-由已知遍历序列画出原本树的结构" class="headerlink" title="1.3 由已知遍历序列画出原本树的结构"></a>1.3 由已知遍历序列画出原本树的结构</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">已知某二叉树的中序遍历序列为JGDHKBAELIMCF，后序遍历序列为JGKHDBLMIEFCA，则其前序遍历序列为（ ）</span><br><span class="line">A.ABDGHJKCEFILM</span><br><span class="line">B.ABDGJHKCEILMF   √</span><br><span class="line">C.ABDHKGJCEILMF</span><br><span class="line">D.ABDGJHKCEIMLF</span><br></pre></td></tr></table></figure><p>这道题我刚开始的思路是错的，因为我把它当作完全二叉树来看待，但题目并没有说它是完全二叉树</p><blockquote><p>主要思路：可以从后续遍历确定根节点为A，中序遍历可以确定A的左右子树。再继续从后序遍历中确定A左右子树的根节点，依次往下判断</p></blockquote><p>所以我画了一个分析图，如下👇</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2023/02/202204161628643.jpg" alt="IMG_20220415_103954"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">已知某二叉树的前序遍历序列为ABDEC，中序遍历序列为BDEAC，则该二叉树（ ）</span><br><span class="line">A.是满二叉树</span><br><span class="line">B.是完全二叉树，不是满二叉树</span><br><span class="line">C.不是完全二叉树   √</span><br><span class="line">D.是所有的结点都没有右子树的二叉树</span><br></pre></td></tr></table></figure><p>这道题的思路和上一道题是一样的</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2023/02/202204161631511.png" alt="image-20220416163152483"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">已知某二叉树的前序遍历序列为5 7 4 9 6 2 1，中序遍历序列为4 7 5 6 9 1 2，则其后序遍历序列为（ ）</span><br><span class="line">A.4 2 5 7 6 9 1</span><br><span class="line">B.4 2 7 5 6 9 1</span><br><span class="line">C.4 7 6 1 2 9 5  √</span><br><span class="line">D.4 7 2 9 5 6 1</span><br></pre></td></tr></table></figure><p>本题依旧和上面两道题思路相同！</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2023/02/202204161632859.jpg" alt="IMG_20220415_105012"></p><h2 id="1-4-单边树"><a href="#1-4-单边树" class="headerlink" title="1.4 单边树"></a>1.4 单边树</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">一棵非空的二叉树的先序遍历序列与后序遍历序列正好相反，则该二叉树一定满足（ ）</span><br><span class="line">A.所有的结点均无左孩子</span><br><span class="line">B.所有的结点均无右孩子</span><br><span class="line">C.只有一个叶子结点</span><br><span class="line">D.至多只有一个结点</span><br></pre></td></tr></table></figure><p>如果前序遍历和后序遍历序列正好相反，说明它是一个单边树，比如下面这前序和中序序列所构成的树的结构:</p><p>12345（纵向）</p><p>54321</p><p>对于单边树，只有一个叶子节点</p><hr><h2 id="1-5"><a href="#1-5" class="headerlink" title="1.5"></a>1.5</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">20.如果一颗二叉树的前序遍历的结果是ABCD，则满足条件的不同的二叉树有（ ）种</span><br><span class="line"></span><br><span class="line">A.13</span><br><span class="line">B.14 √</span><br><span class="line">C.15</span><br><span class="line">D.16</span><br></pre></td></tr></table></figure><blockquote><p>首先这棵二叉树的高度一定在3~4层之间:</p><p>三层：</p><p>A(B(C,D),()), A((),B(C,D)), A(B(C,()),D), A(B((),C),D),</p><p>A(B,C(D,())), A(B,C((),D))</p><p>四层：</p><p>如果为四层，就是单边树，每一层只有一个节点，除过根节点，其他节点都有两种选择，在上层节点的左边还是右边，所以<code>2*2*2</code>共8种</p><p>总共为14种。</p></blockquote><hr><h1 id="2-OJ题刷起来！"><a href="#2-OJ题刷起来！" class="headerlink" title="2.OJ题刷起来！"></a>2.OJ题刷起来！</h1><h2 id="KY11-二叉树遍历"><a href="#KY11-二叉树遍历" class="headerlink" title="KY11 二叉树遍历"></a>KY11 二叉树遍历</h2><blockquote><p>牛客网 KY11 二叉树遍历 👉<a href="https://www.nowcoder.com/practice/4b91205483694f449f94c179883c1fef?tpId=60&&tqId=29483&rp=1&ru=/activity/oj&qru=/ta/tsing-kaoyan/question-ranking">传送门</a></p></blockquote><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2023/02/202204161645079.png" alt="image-20220416164513012"></p><p>这道题要求我们用先序遍历的操作从<strong>一个数组中读出一个树</strong>，并构建出树的基本结构，再用中序遍历的方式打印出这颗树</p><p>之前我们学习了前序遍历的操作，这里只需要把前序遍历中的printf操作改成构建新树即可</p><ul><li>因为涉及道i的多次调用，所以函数中的i需要取地址，必须保证多次调用的i会同步++</li><li>构建完树的节点，并赋值后，需要递归构建左右子树，最后返回节点的地址</li><li>题目中的#代表NULL，直接return空即可</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdbool.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">char</span> BTDataType;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">BTreeNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">BTDataType data;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">BTreeNode</span>* <span class="title">left</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">BTreeNode</span>* <span class="title">right</span>;</span></span><br><span class="line">&#125;BTNode;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 二叉树中序遍历 </span></span><br><span class="line"><span class="type">void</span> <span class="title function_">BTreeInOrder</span><span class="params">(BTNode* root)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (root == <span class="literal">NULL</span>)&#123;</span><br><span class="line"><span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">BTreeInOrder(root-&gt;left);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%c &quot;</span>, root-&gt;data);</span><br><span class="line">BTreeInOrder(root-&gt;right);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">BTNode* <span class="title function_">CreatTree</span><span class="params">(<span class="type">char</span> *arr,<span class="type">int</span>*i)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (arr[*i] == <span class="string">&#x27;#&#x27;</span>)&#123;</span><br><span class="line">        (*i)++;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">    BTNode* newnode=(BTNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(BTNode));</span><br><span class="line">    </span><br><span class="line">    newnode-&gt;data=arr[(*i)++];<span class="comment">//i必须取地址</span></span><br><span class="line">    newnode-&gt;left=CreatTree(arr,i);<span class="comment">//递归构建左子树</span></span><br><span class="line">    newnode-&gt;right=CreatTree(arr,i);<span class="comment">//递归构建右子树</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> newnode;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> arr[<span class="number">100</span>];</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,arr);</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> i=<span class="number">0</span>;</span><br><span class="line">    BTNode* root=CreatTree(arr,&amp;i);</span><br><span class="line">    BTreeInOrder(root);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="100-相同的树"><a href="#100-相同的树" class="headerlink" title="100 相同的树"></a>100 相同的树</h2><blockquote><p>leetcode：<a href="https://leetcode-cn.com/problems/same-tree/">100. 相同的树</a></p></blockquote><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2023/02/202204161652255.png" alt="image-20220416165211195"></p><p>题目要求很简单，给定两颗树的根节点，要求我们判断这两棵树是否相同</p><ul><li>如果两棵树都为空，树相同</li><li>如果其中一个为空，另外一个不为空，树不同</li><li>如果两个都不为空，但是节点值不相同，树不同</li><li>然后再递归判断左子树和右子树，将它们的结果与<code>&amp;&amp;</code>在一起，其中一个为假，返回假</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="title function_">isSameTree</span><span class="params">(<span class="keyword">struct</span> TreeNode* p, <span class="keyword">struct</span> TreeNode* q)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(p==<span class="literal">NULL</span>&amp;&amp;q==<span class="literal">NULL</span>)<span class="comment">//比较是否两个节点都为空，都为空是真</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(p==<span class="literal">NULL</span>||q==<span class="literal">NULL</span>)<span class="comment">//如果有一个为空，另外一个非空，即为假</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(p-&gt;val!=q-&gt;val)<span class="comment">//都不是空，判断val的值是否相等</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//递归判断左子树和右子树是否相等</span></span><br><span class="line">    <span class="keyword">return</span> isSameTree(p-&gt;left,q-&gt;left)</span><br><span class="line">        &amp;&amp; isSameTree(p-&gt;right,q-&gt;right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2023/02/202204161706054.png" alt="image-20220416170618951"></p><p>学会这道题后，后面一些题目其实只需要把它的代码改一改就能用了😂</p><p>什么？你不信？那就看看下面这道题！</p><hr><h2 id="101-对称二叉树"><a href="#101-对称二叉树" class="headerlink" title="101 对称二叉树"></a>101 对称二叉树</h2><blockquote><p>leetcode：<a href="https://leetcode-cn.com/problems/symmetric-tree/">101. 对称二叉树</a></p></blockquote><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2023/02/202204161657137.png" alt="image-20220416165729067"></p><p>题目要求很简单哈，判断是不是两边对称的树。这和判断树相等有什么区别呢？不就是把左右子树的判断改一下就行了嘛？</p><ul><li>根节点的<strong>左子树的左侧</strong>和根节点的<strong>右子树的右侧</strong>相同，即为对称。</li></ul><p>直接调用上一题的代码！注意最后的return值，是<strong>p的左和q的右</strong>进行判断</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> _isSameTree(<span class="keyword">struct</span> TreeNode* p, <span class="keyword">struct</span> TreeNode* q)&#123;</span><br><span class="line">    <span class="keyword">if</span>(p==<span class="literal">NULL</span>&amp;&amp;q==<span class="literal">NULL</span>)<span class="comment">//比较是否两个节点都为空，都为空是真</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(p==<span class="literal">NULL</span>||q==<span class="literal">NULL</span>)<span class="comment">//如果有一个为空，另外一个非空，即为假</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(p-&gt;val!=q-&gt;val)<span class="comment">//都不是空，判断val的值是否相等</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 递归判断左子树和右子树是否对称相等</span></span><br><span class="line">    <span class="keyword">return</span> _isSameTree(p-&gt;left,q-&gt;right)</span><br><span class="line">        &amp;&amp; _isSameTree(p-&gt;right,q-&gt;left);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> <span class="title function_">isSymmetric</span><span class="params">(<span class="keyword">struct</span> TreeNode* root)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> _isSameTree(root-&gt;left,root-&gt;right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2023/02/202204161706197.png" alt="image-20220416170605085"></p><p>使用迭代法也能解决这道题目。迭代法的思路有点类似层序遍历，但是并不同！</p><ul><li>使用队列存放节点，将根节点的左子树和右子树入队列</li><li>开始循环</li><li>取出队列的两个节点（根节点的左子树和右子树），将左子树的左侧和右子树的右侧入队列，将左子树的右侧和右子树的左侧入队列；</li><li>此时队列中的四个数值就是依照对称需要判断的节点值来排列的，在下一层循环的时候，只需要判断取出队列的头部两个节点的值是否相等就行了。</li><li>当取出的两个节点有一个为空，或者都不为空但节点值不同时，即不符合对称的条件。</li><li>注意，两个节点都为空是符合条件的。</li></ul><p>C++代码如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isSymmetric</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">nullptr</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        queue&lt;TreeNode*&gt; que;</span><br><span class="line">        que.<span class="built_in">push</span>(root-&gt;left);</span><br><span class="line">        que.<span class="built_in">push</span>(root-&gt;right);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(!que.<span class="built_in">empty</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 这里左右的顺序要和上面根节点插入左右的顺序一致</span></span><br><span class="line">            TreeNode* left = que.<span class="built_in">front</span>();</span><br><span class="line">            que.<span class="built_in">pop</span>();</span><br><span class="line">            TreeNode* right = que.<span class="built_in">front</span>();</span><br><span class="line">            que.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="keyword">if</span>(left == <span class="literal">nullptr</span> &amp;&amp; right == <span class="literal">nullptr</span>)&#123;</span><br><span class="line">                <span class="keyword">continue</span>; <span class="comment">// 两个都是空，符合条件，跳过</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 有一个不为空，或者值不同，都是错误的</span></span><br><span class="line">            <span class="keyword">if</span>((left == <span class="literal">nullptr</span> || right == <span class="literal">nullptr</span>) || (left-&gt;val != right-&gt;val))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 对称插入队列</span></span><br><span class="line">            que.<span class="built_in">push</span>(left-&gt;left);</span><br><span class="line">            que.<span class="built_in">push</span>(right-&gt;right);</span><br><span class="line">            que.<span class="built_in">push</span>(left-&gt;right);</span><br><span class="line">            que.<span class="built_in">push</span>(right-&gt;left);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;   </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="572-另外一棵树的子树"><a href="#572-另外一棵树的子树" class="headerlink" title="572 另外一棵树的子树"></a>572 另外一棵树的子树</h2><blockquote><p>leetcode：<a href="https://leetcode-cn.com/problems/subtree-of-another-tree/">572. 另一棵树的子树</a></p></blockquote><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2023/02/202204161700348.png" alt="image-20220416170019257"></p><p>这道题我们要判断<strong>一颗树是否为另外一棵树的子树</strong>，和判断一个字符串是不是另外一个字符串的子串很相似</p><p>其实只需要递归判断每一个节点的左右子树是否和<code>subRoot</code>相同就可以了！</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> _isSameTree(<span class="keyword">struct</span> TreeNode* p, <span class="keyword">struct</span> TreeNode* q)&#123;</span><br><span class="line">    <span class="keyword">if</span>(p==<span class="literal">NULL</span>&amp;&amp;q==<span class="literal">NULL</span>)<span class="comment">//比较是否两个节点都为空，都为空是真</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(p==<span class="literal">NULL</span>||q==<span class="literal">NULL</span>)<span class="comment">//如果有一个为空，另外一个非空，即为假</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(p-&gt;val!=q-&gt;val)<span class="comment">//都不是空，判断val的值是否相等</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//递归判断左子树和右子树是否相等</span></span><br><span class="line">    <span class="keyword">return</span> _isSameTree(p-&gt;left,q-&gt;left)</span><br><span class="line">        &amp;&amp; _isSameTree(p-&gt;right,q-&gt;right);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> <span class="title function_">isSubtree</span><span class="params">(<span class="keyword">struct</span> TreeNode* root, <span class="keyword">struct</span> TreeNode* subRoot)</span>&#123;</span><br><span class="line">    <span class="comment">// if(root==NULL&amp;&amp;subRoot==NULL)</span></span><br><span class="line">    <span class="comment">//     return true;</span></span><br><span class="line">    <span class="comment">// if(root!=NULL&amp;&amp;subRoot==NULL)</span></span><br><span class="line">    <span class="comment">//     return true;</span></span><br><span class="line">    <span class="comment">// 让isSametree函数来比较这俩个</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(root==<span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(_isSameTree(root,subRoot))</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//只要左右有一个是返回真，那就是子树</span></span><br><span class="line">    <span class="keyword">return</span> isSubtree(root-&gt;left,subRoot)</span><br><span class="line">        || isSubtree(root-&gt;right,subRoot);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2023/02/202204161705445.png" alt="image-20220416170549320"></p><p>是不是爽起来了？再来一道！</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2023/02/202204161703532.png" alt="image-20220416170310498"></p><h2 id="102-层序遍历"><a href="#102-层序遍历" class="headerlink" title="102 层序遍历"></a>102 层序遍历</h2><blockquote><p><a href="https://leetcode.cn/problems/binary-tree-level-order-traversal/">https://leetcode.cn/problems/binary-tree-level-order-traversal/</a></p></blockquote><p>这道题在之前的博客中已经讲解过，为了方便后序写层序遍历的类型题目，将层序遍历最基本的代码贴在这里。</p><ul><li>根节点入队列</li><li>队列不为空，开始遍历；</li><li>记录当前队列长度（本层节点数量），出对头节点，将值插入数组，并将该节点的左右子树入队列；</li><li>一层节点遍历完毕后，将这一层的数组插入返回值二维数组中；</li><li>依照以上步骤，直到最后一层（队列为空）；</li></ul><p>代码如下。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">levelOrder</span>(TreeNode* root) &#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; retV;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">nullptr</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> retV;</span><br><span class="line">        &#125;</span><br><span class="line">        queue&lt;TreeNode*&gt; que;</span><br><span class="line">        que.<span class="built_in">push</span>(root);</span><br><span class="line">        <span class="keyword">while</span>(!que.<span class="built_in">empty</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> size = que.<span class="built_in">size</span>();</span><br><span class="line">            vector&lt;<span class="type">int</span>&gt; tempV;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; size;i++)</span><br><span class="line">            &#123;</span><br><span class="line">                TreeNode* front = que.<span class="built_in">front</span>();</span><br><span class="line">                que.<span class="built_in">pop</span>();</span><br><span class="line">                tempV.<span class="built_in">push_back</span>(front-&gt;val);</span><br><span class="line">                <span class="keyword">if</span>(front-&gt;left != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">                    que.<span class="built_in">push</span>(front-&gt;left);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(front-&gt;right != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">                    que.<span class="built_in">push</span>(front-&gt;right);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            retV.<span class="built_in">push_back</span>(tempV); <span class="comment">// 一层结束</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> retV;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="107-层序遍历Ⅱ"><a href="#107-层序遍历Ⅱ" class="headerlink" title="107 层序遍历Ⅱ"></a>107 层序遍历Ⅱ</h2><blockquote><p><a href="https://leetcode.cn/problems/binary-tree-level-order-traversal-ii/">https://leetcode.cn/problems/binary-tree-level-order-traversal-ii/</a></p></blockquote><p>这道题是上一道题的逆置，要求我们从最底层往上返回节点的数组。只需要将上题的返回数组逆置一下就OK了。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">levelOrderBottom</span>(TreeNode* root) &#123;</span><br><span class="line">         vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; retV;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">nullptr</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> retV;</span><br><span class="line">        &#125;</span><br><span class="line">        queue&lt;TreeNode*&gt; que;</span><br><span class="line">        que.<span class="built_in">push</span>(root);</span><br><span class="line">        <span class="keyword">while</span>(!que.<span class="built_in">empty</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> size = que.<span class="built_in">size</span>();</span><br><span class="line">            vector&lt;<span class="type">int</span>&gt; tempV;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; size;i++)</span><br><span class="line">            &#123;</span><br><span class="line">                TreeNode* front = que.<span class="built_in">front</span>();</span><br><span class="line">                que.<span class="built_in">pop</span>();</span><br><span class="line">                tempV.<span class="built_in">push_back</span>(front-&gt;val);</span><br><span class="line">                <span class="keyword">if</span>(front-&gt;left != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">                    que.<span class="built_in">push</span>(front-&gt;left);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(front-&gt;right != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">                    que.<span class="built_in">push</span>(front-&gt;right);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            retV.<span class="built_in">push_back</span>(tempV); <span class="comment">// 一层结束</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 逆置返回值数组即可</span></span><br><span class="line">        <span class="built_in">reverse</span>(retV.<span class="built_in">begin</span>(),retV.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">return</span> retV;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/03/a317dc68b0b4f9b98f31859e359165b2.png" alt="image.png"></p><h2 id="199-二叉树的右视图"><a href="#199-二叉树的右视图" class="headerlink" title="199 二叉树的右视图"></a>199 二叉树的右视图</h2><blockquote><p><a href="https://leetcode.cn/problems/binary-tree-right-side-view/description/">https://leetcode.cn/problems/binary-tree-right-side-view/description/</a></p></blockquote><p>题目要求我们假设自己是从右侧观察一颗二叉树，返回能从右侧观察到的节点。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">    5</span><br><span class="line">  4   6</span><br><span class="line">1   2</span><br></pre></td></tr></table></figure><p>比如这棵树，从右侧可以观察到的节点是<code>[5,6,2]</code>，题目要求返回的就是这个节点组成的数组。</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/03/b0c2e5474f671f282fac457fe734ef2c.png" alt="image.png"></p><p>思路还是层序遍历，这一次不需要把每个节点都入数组了，只需要遍历到<strong>每个层的末尾</strong>（循环到<code>size-1</code>的位置），将这个节点插入数组就行了。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">rightSideView</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; retV;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">nullptr</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> retV;</span><br><span class="line">        &#125;</span><br><span class="line">        queue&lt;TreeNode*&gt; que;</span><br><span class="line">        que.<span class="built_in">push</span>(root);</span><br><span class="line">        <span class="keyword">while</span>(!que.<span class="built_in">empty</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> size = que.<span class="built_in">size</span>();</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; size;i++)</span><br><span class="line">            &#123;</span><br><span class="line">                TreeNode* front = que.<span class="built_in">front</span>();</span><br><span class="line">                que.<span class="built_in">pop</span>();</span><br><span class="line">                <span class="comment">// 每一层的末尾才插入数组</span></span><br><span class="line">                <span class="keyword">if</span>(i == size<span class="number">-1</span>)&#123;</span><br><span class="line">                    retV.<span class="built_in">push_back</span>(front-&gt;val);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span>(front-&gt;left != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">                    que.<span class="built_in">push</span>(front-&gt;left);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(front-&gt;right != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">                    que.<span class="built_in">push</span>(front-&gt;right);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> retV;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/03/85b671427128bdd9adc04f79909a630b.png" alt="image.png"></p><h2 id="637-二叉树的层平均值"><a href="#637-二叉树的层平均值" class="headerlink" title="637 二叉树的层平均值"></a>637 二叉树的层平均值</h2><blockquote><p><a href="https://leetcode.cn/problems/average-of-levels-in-binary-tree/description/">https://leetcode.cn/problems/average-of-levels-in-binary-tree/description/</a></p></blockquote><p>给定一个非空二叉树的根节点 root , 以数组的形式返回每一层节点的平均值。与实际答案相差 <code>10^(-5)</code> 以内的答案可以被接受。</p><p>这道题简单，把每一层的节点都加起来，然后除以节点数量求平均就可以了。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">double</span>&gt; <span class="title">averageOfLevels</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="type">double</span>&gt; retV;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">nullptr</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> retV;</span><br><span class="line">        &#125;</span><br><span class="line">        queue&lt;TreeNode*&gt; que;</span><br><span class="line">        que.<span class="built_in">push</span>(root);</span><br><span class="line">        <span class="keyword">while</span>(!que.<span class="built_in">empty</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> size = que.<span class="built_in">size</span>();</span><br><span class="line">            <span class="type">double</span> sum = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; size;i++)</span><br><span class="line">            &#123;</span><br><span class="line">                TreeNode* front = que.<span class="built_in">front</span>();</span><br><span class="line">                que.<span class="built_in">pop</span>();</span><br><span class="line">                <span class="comment">// 求和</span></span><br><span class="line">                sum += front-&gt;val;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span>(front-&gt;left != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">                    que.<span class="built_in">push</span>(front-&gt;left);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(front-&gt;right != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">                    que.<span class="built_in">push</span>(front-&gt;right);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 一层结束。计算平均</span></span><br><span class="line">            retV.<span class="built_in">push_back</span>(sum/<span class="built_in">static_cast</span>&lt;<span class="type">double</span>&gt;(size*<span class="number">1.0</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> retV;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/03/67b4d7b9120a9184555c39f76908034f.png" alt="image.png"></p><h2 id="226-翻转二叉树"><a href="#226-翻转二叉树" class="headerlink" title="226 翻转二叉树"></a>226 翻转二叉树</h2><blockquote><p>leetcode：<a href="https://leetcode-cn.com/problems/invert-binary-tree/">226. 翻转二叉树</a></p></blockquote><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2023/02/202204161703706.png" alt="image-20220416170322647"></p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>这道题的思路如下哈！</p><ul><li>如果是空树，不需要翻转，直接return；</li><li>如果非空，就把该节点的左右子树交换（这里不需要担心交换后找不到子树的问题，因为并没有把子树删除或者丢掉）</li><li>不需要单独判断空的子树，一并交换就可以；</li><li>当根节点为空的时候，return；</li></ul><h3 id="前序遍历实现"><a href="#前序遍历实现" class="headerlink" title="前序遍历实现"></a>前序遍历实现</h3><p>啪的一下很快哈，代码就写出来了！</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> _invertTree(<span class="keyword">struct</span> TreeNode* root)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(root==<span class="literal">NULL</span>)<span class="comment">//设置退出条件，如果根节点为空就返回</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//让另外两个值来接收原本的左右节点</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span>* <span class="title">left</span>=</span>root-&gt;left;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span>* <span class="title">right</span>=</span>root-&gt;right;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//更改左右节点</span></span><br><span class="line">    root-&gt;right=left;</span><br><span class="line">    root-&gt;left=right;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//递归子树</span></span><br><span class="line">    _invertTree(root-&gt;left);</span><br><span class="line">    _invertTree(root-&gt;right);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> TreeNode* <span class="title function_">invertTree</span><span class="params">(<span class="keyword">struct</span> TreeNode* root)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root==<span class="literal">NULL</span>)<span class="comment">//判断空树</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    _invertTree(root);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2023/02/202204161705971.png" alt="image-20220416170530844"></p><p>使用迭代（循环）的方式进行前序遍历，也可以完成本题</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">invertTree</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">        stack&lt;TreeNode*&gt; st;</span><br><span class="line">        st.<span class="built_in">push</span>(root);</span><br><span class="line">        <span class="keyword">while</span>(!st.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            TreeNode* node = st.<span class="built_in">top</span>();              <span class="comment">// 中</span></span><br><span class="line">            st.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="built_in">swap</span>(node-&gt;left, node-&gt;right); <span class="comment">// 交换</span></span><br><span class="line">            <span class="keyword">if</span>(node-&gt;right) st.<span class="built_in">push</span>(node-&gt;right);   <span class="comment">// 右</span></span><br><span class="line">            <span class="keyword">if</span>(node-&gt;left) st.<span class="built_in">push</span>(node-&gt;left);     <span class="comment">// 左</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="层序遍历实现"><a href="#层序遍历实现" class="headerlink" title="层序遍历实现"></a>层序遍历实现</h3><p>使用层序遍历，思路还是一样的，层序遍历在出队列头部节点的时候，会将左右子树插入队列。只需要在插入之前，将队列头部节点的左右子树指针交换位置，即可。</p><p>注意：不能通过交换左右子树入队列的顺序实现，这样虽然遍历下一层的顺序改变了，但是上一层的节点左右子树的指针并没有被交换，还是原来的顺序，不符合题目要求。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">invertTree</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">nullptr</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        &#125;</span><br><span class="line">        queue&lt;TreeNode*&gt; que;</span><br><span class="line">        que.<span class="built_in">push</span>(root);</span><br><span class="line">        <span class="keyword">while</span>(!que.<span class="built_in">empty</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            TreeNode* front = que.<span class="built_in">front</span>();</span><br><span class="line">            que.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="built_in">swap</span>(front-&gt;left,front-&gt;right);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 虽然这里可以不用写不等于空，但是写上可读性更好。</span></span><br><span class="line">            <span class="keyword">if</span>(front-&gt;left != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">                que.<span class="built_in">push</span>(front-&gt;left);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(front-&gt;right != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">                que.<span class="built_in">push</span>(front-&gt;right);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="429-N叉树层序遍历"><a href="#429-N叉树层序遍历" class="headerlink" title="429 N叉树层序遍历"></a>429 N叉树层序遍历</h2><blockquote><p><a href="https://leetcode.cn/problems/n-ary-tree-level-order-traversal/">https://leetcode.cn/problems/n-ary-tree-level-order-traversal/</a></p></blockquote><p>基于二叉树层序遍历的代码，修改一下就是多叉树了。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">// Definition for a Node.</span></span><br><span class="line"><span class="comment">class Node &#123;</span></span><br><span class="line"><span class="comment">public:</span></span><br><span class="line"><span class="comment">    int val;</span></span><br><span class="line"><span class="comment">    vector&lt;Node*&gt; children;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    Node() &#123;&#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    Node(int _val) &#123;</span></span><br><span class="line"><span class="comment">        val = _val;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    Node(int _val, vector&lt;Node*&gt; _children) &#123;</span></span><br><span class="line"><span class="comment">        val = _val;</span></span><br><span class="line"><span class="comment">        children = _children;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">levelOrder</span>(Node* root) &#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; retV;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">nullptr</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> retV;</span><br><span class="line">        &#125;</span><br><span class="line">        queue&lt;Node*&gt; que;</span><br><span class="line">        que.<span class="built_in">push</span>(root);</span><br><span class="line">        <span class="keyword">while</span>(!que.<span class="built_in">empty</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> size = que.<span class="built_in">size</span>();</span><br><span class="line">            vector&lt;<span class="type">int</span>&gt; tempV;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; size ; j++)&#123;</span><br><span class="line">                Node* temp = que.<span class="built_in">front</span>();</span><br><span class="line">                que.<span class="built_in">pop</span>();</span><br><span class="line">                tempV.<span class="built_in">push_back</span>(temp-&gt;val);</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> i =<span class="number">0</span>;i&lt;temp-&gt;children.<span class="built_in">size</span>();i++)</span><br><span class="line">                &#123;</span><br><span class="line">                    que.<span class="built_in">push</span>(temp-&gt;children[i]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            retV.<span class="built_in">push_back</span>(tempV);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> retV;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/03/d5a314057186dc0fc8880444838d2381.png" alt="image.png"></p><h2 id="515-在每层中找最大值"><a href="#515-在每层中找最大值" class="headerlink" title="515 在每层中找最大值"></a>515 在每层中找最大值</h2><blockquote><p><a href="https://leetcode.cn/problems/find-largest-value-in-each-tree-row/">https://leetcode.cn/problems/find-largest-value-in-each-tree-row/</a></p></blockquote><p>还是层序遍历思路的题目，遍历一层的时候维护一个最大值就可以了。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">largestValues</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; retV;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">nullptr</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> retV;</span><br><span class="line">        &#125;</span><br><span class="line">        queue&lt;TreeNode*&gt; que;</span><br><span class="line">        que.<span class="built_in">push</span>(root);</span><br><span class="line">        <span class="keyword">while</span>(!que.<span class="built_in">empty</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> size = que.<span class="built_in">size</span>();</span><br><span class="line">            <span class="type">int</span> maxNum = INT32_MIN;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i =<span class="number">0</span>;i&lt; size;i++)</span><br><span class="line">            &#123;</span><br><span class="line">                TreeNode* temp = que.<span class="built_in">front</span>();</span><br><span class="line">                que.<span class="built_in">pop</span>();</span><br><span class="line">                maxNum = <span class="built_in">max</span>(maxNum,temp-&gt;val);</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">if</span>(temp-&gt;left != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">                    que.<span class="built_in">push</span>(temp-&gt;left);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(temp-&gt;right != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">                    que.<span class="built_in">push</span>(temp-&gt;right);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            retV.<span class="built_in">push_back</span>(maxNum);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> retV;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/03/42ebd64adefee9120536bd6968a50561.png" alt="image.png"></p><h2 id="116-填充每个节点的下一个右侧节点指针"><a href="#116-填充每个节点的下一个右侧节点指针" class="headerlink" title="116 填充每个节点的下一个右侧节点指针"></a>116 填充每个节点的下一个右侧节点指针</h2><blockquote><p><a href="https://leetcode.cn/problems/populating-next-right-pointers-in-each-node/description/">https://leetcode.cn/problems/populating-next-right-pointers-in-each-node/description/</a></p></blockquote><p>给定一个 完美二叉树 ，其所有叶子节点都在同一层，每个父节点都有两个子节点。二叉树定义如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">  <span class="type">int</span> val;</span><br><span class="line">  Node *left;</span><br><span class="line">  Node *right;</span><br><span class="line">  Node *next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>填充它的每个 next 指针，让这个指针指向其下一个右侧节点。如果找不到下一个右侧节点，则将 next 指针设置为 NULL。</p><p>初始状态下，所有 next 指针都被设置为 NULL。</p><hr><p>还是层序遍历的思路，遍历每一层的时候，将<strong>前一个节点的right</strong>设置为当前节点。</p><p>因为题目提到了node节点的next指针<strong>初始化都为nullptr</strong>，所以不需要我们手动操作每层最后一个节点的nullptr。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">Node* <span class="title">connect</span><span class="params">(Node* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">nullptr</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        &#125;</span><br><span class="line">        queue&lt;Node*&gt; que;</span><br><span class="line">        que.<span class="built_in">push</span>(root);</span><br><span class="line">        <span class="keyword">while</span>(!que.<span class="built_in">empty</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> size = que.<span class="built_in">size</span>();</span><br><span class="line">            Node* prevNode = <span class="literal">nullptr</span>;</span><br><span class="line">            Node* node = <span class="literal">nullptr</span>; <span class="comment">// 始终指向当前节点</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i =<span class="number">0</span>; i&lt; size;i++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// 每层第一个节点，设置前一个节点的值</span></span><br><span class="line">                <span class="keyword">if</span>(i == <span class="number">0</span>)&#123;</span><br><span class="line">                    prevNode = que.<span class="built_in">front</span>(); <span class="comment">// 前一个节点</span></span><br><span class="line">                    que.<span class="built_in">pop</span>();</span><br><span class="line">                    node = prevNode; <span class="comment">// 当前节点</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="comment">// 非第一个</span></span><br><span class="line">                &#123;</span><br><span class="line">                    node = que.<span class="built_in">front</span>(); <span class="comment">// 当前节点</span></span><br><span class="line">                    que.<span class="built_in">pop</span>();</span><br><span class="line">                    prevNode-&gt;next = node;</span><br><span class="line">                    prevNode = prevNode-&gt;next; <span class="comment">// 更新前一个节点为当前节点</span></span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 插入后续节点</span></span><br><span class="line">                <span class="keyword">if</span>(node-&gt;left != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">                    que.<span class="built_in">push</span>(node-&gt;left);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(node-&gt;right != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">                    que.<span class="built_in">push</span>(node-&gt;right);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/03/9316e276ec127d1e7ee096367a4c6e51.png" alt="image.png"></p><h2 id="117-填充每个节点的下一个右侧节点指针Ⅱ"><a href="#117-填充每个节点的下一个右侧节点指针Ⅱ" class="headerlink" title="117 填充每个节点的下一个右侧节点指针Ⅱ"></a>117 填充每个节点的下一个右侧节点指针Ⅱ</h2><blockquote><p><a href="https://leetcode.cn/problems/populating-next-right-pointers-in-each-node-ii/description/">https://leetcode.cn/problems/populating-next-right-pointers-in-each-node-ii/description/</a></p></blockquote><p>上题说的是完全二叉树，这道题是普通二叉树。不过我们写的层序遍历代码本来就是通用的，所以直接复制代码过来就行了，什么都不需要改。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">Node* <span class="title">connect</span><span class="params">(Node* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">nullptr</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        &#125;</span><br><span class="line">        queue&lt;Node*&gt; que;</span><br><span class="line">        que.<span class="built_in">push</span>(root);</span><br><span class="line">        <span class="keyword">while</span>(!que.<span class="built_in">empty</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> size = que.<span class="built_in">size</span>();</span><br><span class="line">            Node* prevNode = <span class="literal">nullptr</span>;</span><br><span class="line">            Node* node = <span class="literal">nullptr</span>; <span class="comment">// 始终指向当前节点</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i =<span class="number">0</span>; i&lt; size;i++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// 每层第一个节点，设置前一个节点的值</span></span><br><span class="line">                <span class="keyword">if</span>(i == <span class="number">0</span>)&#123;</span><br><span class="line">                    prevNode = que.<span class="built_in">front</span>(); <span class="comment">// 前一个节点</span></span><br><span class="line">                    que.<span class="built_in">pop</span>();</span><br><span class="line">                    node = prevNode; <span class="comment">// 当前节点</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="comment">// 非第一个</span></span><br><span class="line">                &#123;</span><br><span class="line">                    node = que.<span class="built_in">front</span>(); <span class="comment">// 当前节点</span></span><br><span class="line">                    que.<span class="built_in">pop</span>();</span><br><span class="line">                    prevNode-&gt;next = node;</span><br><span class="line">                    prevNode = prevNode-&gt;next; <span class="comment">// 更新前一个节点为当前节点</span></span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 插入后续节点</span></span><br><span class="line">                <span class="keyword">if</span>(node-&gt;left != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">                    que.<span class="built_in">push</span>(node-&gt;left);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(node-&gt;right != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">                    que.<span class="built_in">push</span>(node-&gt;right);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/03/0ea9cb0afb401d955754c2f85a50c9f1.png" alt="image.png"></p><h2 id="104-二叉树最大深度"><a href="#104-二叉树最大深度" class="headerlink" title="104 二叉树最大深度"></a>104 二叉树最大深度</h2><blockquote><p><a href="https://leetcode.cn/problems/maximum-depth-of-binary-tree/description/">https://leetcode.cn/problems/maximum-depth-of-binary-tree/description/</a></p></blockquote><p>这道题在链式二叉树的博客中讲解过递归版本。注意二叉树深度的定义：二叉树的 <strong>最大深度</strong> 是指从根节点到最远<strong>叶子节点</strong>的<strong>最长路径</strong>上的节点数。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 二叉树深度，即一共有几层</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">BTreeDepth</span><span class="params">(BTNode* root)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (root == <span class="literal">NULL</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 递归遍历左右子树</span></span><br><span class="line"><span class="type">int</span> left = <span class="built_in">BTreeDepth</span>(root-&gt;left);</span><br><span class="line"><span class="type">int</span> right = <span class="built_in">BTreeDepth</span>(root-&gt;right);</span><br><span class="line"><span class="comment">// 返回左右子树层数高的那一个，加一代表当前层，因为空指针是0</span></span><br><span class="line"><span class="keyword">return</span> left &gt; right ? left + <span class="number">1</span> : right + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用层序遍历也能解决这个问题，遍历到每一层都让深度计数器加一就行了。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxDepth</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> retDepth = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">nullptr</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> retDepth;</span><br><span class="line">        &#125;</span><br><span class="line">        queue&lt;TreeNode*&gt; que;</span><br><span class="line">        que.<span class="built_in">push</span>(root);</span><br><span class="line">        <span class="keyword">while</span>(!que.<span class="built_in">empty</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> size = que.<span class="built_in">size</span>();</span><br><span class="line">            retDepth++; <span class="comment">// 层数加一</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i =<span class="number">0</span>;i&lt; size;i++)</span><br><span class="line">            &#123;</span><br><span class="line">                TreeNode* temp = que.<span class="built_in">front</span>();</span><br><span class="line">                que.<span class="built_in">pop</span>();</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">if</span>(temp-&gt;left != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">                    que.<span class="built_in">push</span>(temp-&gt;left);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(temp-&gt;right != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">                    que.<span class="built_in">push</span>(temp-&gt;right);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> retDepth;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/03/9db4df1d7c69a02f1e809f2fac733fb8.png" alt="image.png"></p><p>下面是代码随想录上的递归思路。使用“回溯”的思想，将每一层的depth送给下一层，然后在每一层开始的时候判断当前深度是否大于存放的深度，并进行更新。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> result;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">getdepth</span><span class="params">(TreeNode* node, <span class="type">int</span> depth)</span> </span>&#123;</span><br><span class="line">        result = depth &gt; result ? depth : result; <span class="comment">// 中</span></span><br><span class="line">        <span class="keyword">if</span> (node-&gt;left == <span class="literal">NULL</span> &amp;&amp; node-&gt;right == <span class="literal">NULL</span>) <span class="keyword">return</span> ;</span><br><span class="line">        <span class="keyword">if</span> (node-&gt;left) &#123; <span class="comment">// 左</span></span><br><span class="line">            <span class="built_in">getdepth</span>(node-&gt;left, depth + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (node-&gt;right) &#123; <span class="comment">// 右</span></span><br><span class="line">            <span class="built_in">getdepth</span>(node-&gt;right, depth + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxDepth</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        result = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="number">0</span>) <span class="keyword">return</span> result;</span><br><span class="line">        <span class="built_in">getdepth</span>(root, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="114-二叉树的最小深度"><a href="#114-二叉树的最小深度" class="headerlink" title="114 二叉树的最小深度"></a>114 二叉树的最小深度</h2><blockquote><p> <a href="https://leetcode.cn/problems/minimum-depth-of-binary-tree/description/">https://leetcode.cn/problems/minimum-depth-of-binary-tree/description/</a></p></blockquote><p>二叉树的最小深度：最小深度是从根节点到最近叶子节点的最短路径上的节点数量。</p><p>以下面的二叉树为例，它的最小深度是从1到节点3，因为3才是第一个叶子节点，而1并不是叶子节点（没有左右子树的节点才是叶子节点）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1</span><br><span class="line">   2</span><br><span class="line">  3  4</span><br><span class="line">   5</span><br></pre></td></tr></table></figure><p>代码如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">minDepth</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> retDepth = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">nullptr</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> retDepth;</span><br><span class="line">        &#125;</span><br><span class="line">        queue&lt;TreeNode*&gt; que;</span><br><span class="line">        que.<span class="built_in">push</span>(root);</span><br><span class="line">        <span class="keyword">while</span>(!que.<span class="built_in">empty</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> size = que.<span class="built_in">size</span>();</span><br><span class="line">            retDepth++; <span class="comment">// 层数加一</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i =<span class="number">0</span>;i&lt; size;i++)</span><br><span class="line">            &#123;</span><br><span class="line">                TreeNode* temp = que.<span class="built_in">front</span>();</span><br><span class="line">                que.<span class="built_in">pop</span>();</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">if</span>(temp-&gt;left != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">                    que.<span class="built_in">push</span>(temp-&gt;left);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(temp-&gt;right != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">                    que.<span class="built_in">push</span>(temp-&gt;right);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 遇到叶子节点，说明就是最小深度，直接返回</span></span><br><span class="line">                <span class="keyword">if</span>(temp-&gt;left == <span class="literal">nullptr</span> &amp;&amp; temp-&gt;right == <span class="literal">nullptr</span>)&#123;</span><br><span class="line">                    <span class="keyword">return</span> retDepth;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> retDepth;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/03/fdeee76497ce1ee5fce7622e2d5c839b.png" alt="image.png"></p><p>如果使用递归的方式，代码如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getDepth</span><span class="params">(TreeNode* node)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> leftDepth = <span class="built_in">getDepth</span>(node-&gt;left);           <span class="comment">// 左</span></span><br><span class="line">        <span class="type">int</span> rightDepth = <span class="built_in">getDepth</span>(node-&gt;right);         <span class="comment">// 右</span></span><br><span class="line">                                                        <span class="comment">// 中</span></span><br><span class="line">        <span class="comment">// 当一个左子树为空，右不为空，这时并不是最低点</span></span><br><span class="line">        <span class="keyword">if</span> (node-&gt;left == <span class="literal">NULL</span> &amp;&amp; node-&gt;right != <span class="literal">NULL</span>) &#123; </span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span> + rightDepth;</span><br><span class="line">        &#125;   </span><br><span class="line">        <span class="comment">// 当一个右子树为空，左不为空，这时并不是最低点</span></span><br><span class="line">        <span class="keyword">if</span> (node-&gt;left != <span class="literal">NULL</span> &amp;&amp; node-&gt;right == <span class="literal">NULL</span>) &#123; </span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span> + leftDepth;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 此时是叶子节点，返回当前的最小高度（即深度）</span></span><br><span class="line">        <span class="type">int</span> result = <span class="number">1</span> + <span class="built_in">min</span>(leftDepth, rightDepth);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">minDepth</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">getDepth</span>(root);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="222-完全二叉树的节点数量"><a href="#222-完全二叉树的节点数量" class="headerlink" title="222 完全二叉树的节点数量"></a>222 完全二叉树的节点数量</h2><blockquote><p><a href="https://leetcode.cn/problems/count-complete-tree-nodes/description/">https://leetcode.cn/problems/count-complete-tree-nodes/description/</a></p></blockquote><p>给你一棵 <strong>完全二叉树</strong> 的根节点 <code>root</code> ，求出该树的节点个数。</p><p><a href="https://baike.baidu.com/item/%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%A0%91/7773232?fr=aladdin">完全二叉树</a> 的定义如下：在完全二叉树中，除了最底层节点可能没填满外，其余每层节点数都达到最大值，并且最下面一层的节点都集中在该层最左边的若干位置。若最底层为第 <code>h</code> 层，则该层包含 <code>1 ~ (2^h)</code> 个节点。</p><hr><p>先按普通二叉树来计算节点的数量，使用层序遍历的思路</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">countNodes</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">nullptr</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        queue&lt;TreeNode*&gt; que;</span><br><span class="line">        que.<span class="built_in">push</span>(root);</span><br><span class="line">        <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(!que.<span class="built_in">empty</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> size = que.<span class="built_in">size</span>();</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i =<span class="number">0</span>;i&lt;size;i++)</span><br><span class="line">            &#123;</span><br><span class="line">                TreeNode* front = que.<span class="built_in">front</span>();</span><br><span class="line">                que.<span class="built_in">pop</span>();</span><br><span class="line">                count++; </span><br><span class="line">                <span class="keyword">if</span>(front-&gt;left != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">                    que.<span class="built_in">push</span>(front-&gt;left);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(front-&gt;right != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">                    que.<span class="built_in">push</span>(front-&gt;right);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>使用递归遍历也能计算节点数量</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> _countNodes(TreeNode* root)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">nullptr</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> left = _countNodes(root-&gt;left);</span><br><span class="line">        <span class="type">int</span> right = _countNodes(root-&gt;right);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span> + left + right;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">countNodes</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> _countNodes(root);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/03/23e323a933739d577ae14b06b12ebb8a.png" alt="image-20240316092433289"></p><hr><p>但是上面这两个思路都是对任何二叉树都适用的，但本题直接说明了是<strong>完全二叉树</strong>。如果用通用的思路来解题，在面试的时候可能会扣分。我们需要用上完全二叉树的特性。</p><p>首先要知道<strong>满二叉树</strong>的节点数量为<code>2^k - 1</code>，k是二叉树的层数。在完全二叉树中，会有多个满二叉树。所以可以将思路转变为，正常计算非满二叉树的节点数量，但如果是满二叉树，获取层数后直接用公式计算节点数量，再二者相加。</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/03/9949b47e3423bf14897b688add450847.png" alt="image-20240316093135112"></p><p>计算满二叉树的层数比较简单，只需要从根节点往左侧、往右侧遍历，计算两侧的节点数量。最后对比左侧右侧节点数量，不同则不是满二叉树。</p><blockquote><p>因为题目已经说明了这棵树是<strong>完全二叉树</strong>，所以<strong>不会出现</strong>下面这种两侧节点数量一致，但中间缺少节点不符合完全二叉树&#x2F;满二叉树条件的情况。</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/03/449114798f3824b2d21fe98eae39ea67.png" alt="image-20240316093752286"></p></blockquote><p>C++代码如下，来自代码随想录。这里层数被初始化为0，这样在后续使用<code>(2 &lt;&lt; leftDepth)</code>的时候，其实就相当于计算2的<code>leftDepth+1</code>次方。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">countNodes</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 开始根据左深度和右深度是否相同来判断该子树是不是满二叉树</span></span><br><span class="line">        TreeNode* left = root-&gt;left;</span><br><span class="line">        TreeNode* right = root-&gt;right;</span><br><span class="line">        <span class="type">int</span> leftDepth = <span class="number">0</span>, rightDepth = <span class="number">0</span>; <span class="comment">// 这里初始为0是有目的的，为了下面求指数方便</span></span><br><span class="line">        <span class="keyword">while</span> (left) &#123;  <span class="comment">// 求左子树深度</span></span><br><span class="line">            left = left-&gt;left;</span><br><span class="line">            leftDepth++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (right) &#123; <span class="comment">// 求右子树深度</span></span><br><span class="line">            right = right-&gt;right;</span><br><span class="line">            rightDepth++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (leftDepth == rightDepth) &#123;</span><br><span class="line">            <span class="keyword">return</span> (<span class="number">2</span> &lt;&lt; leftDepth) - <span class="number">1</span>; <span class="comment">// 注意(2&lt;&lt;1) 相当于2^2，返回满足满二叉树的子树节点数量</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 后序遍历</span></span><br><span class="line">        <span class="type">int</span> leftTreeNum = <span class="built_in">countNodes</span>(root-&gt;left);       <span class="comment">// 左</span></span><br><span class="line">        <span class="type">int</span> rightTreeNum = <span class="built_in">countNodes</span>(root-&gt;right);     <span class="comment">// 右</span></span><br><span class="line">        <span class="type">int</span> result = leftTreeNum + rightTreeNum + <span class="number">1</span>;    <span class="comment">// 中</span></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="110-平衡二叉树"><a href="#110-平衡二叉树" class="headerlink" title="110 平衡二叉树"></a>110 平衡二叉树</h2><blockquote><p><a href="https://leetcode.cn/problems/balanced-binary-tree/">https://leetcode.cn/problems/balanced-binary-tree/</a></p></blockquote><p>这里涉及到高阶数据结构中平衡二叉树的概念，如果你没有了解过，可以移步<a href="https://blog.musnow.top/posts/1396203902">这篇博客</a>；</p><p>简而言之，<strong>平衡二叉树是节点的左右子树高度相差不超过1的树</strong>。这样能保证树的左右两侧节点层数基本一致，方便实现搜索二叉树。</p><p>对于本题而言，我们可以将思路改为计算每个节点左右两侧的树的高度。当高度相差超过1的时候，直接返回错误。这里可以用int来作为递归函数的返回值，用<code>-1</code>代表不符合平衡二叉树的条件。</p><p>题目给出树的节点数量 <code>[0, 5000]</code> ，最大的层数也就5000，用int是足够存放的。</p><p>C++代码如下，使用后序遍历的思想来递归处理。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> _isBalanced(TreeNode* root)&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">nullptr</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 使用后续遍历，如果有一个不符合预期就提前返回</span></span><br><span class="line">        <span class="type">int</span> left = _isBalanced(root-&gt;left);</span><br><span class="line">        <span class="keyword">if</span>(left == <span class="number">-1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> right = _isBalanced(root-&gt;right);</span><br><span class="line">        <span class="keyword">if</span>(right == <span class="number">-1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 都不是负一，计算节点高度插值</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">abs</span>(right -left)&gt;<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;<span class="comment">// 超过1了不符合</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span> + <span class="built_in">max</span>(right,left); <span class="comment">// 返回高的那一个作为当前树的高度</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isBalanced</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> _isBalanced(root) == <span class="number">-1</span> ? <span class="literal">false</span> : <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/03/f2d8a5287cd80e7f2aa5099de585d651.png" alt="image-20240316095740190"></p><h2 id="257-二叉树的所有路径"><a href="#257-二叉树的所有路径" class="headerlink" title="257 二叉树的所有路径"></a>257 二叉树的所有路径</h2><blockquote><p><a href="https://leetcode.cn/problems/binary-tree-paths/">https://leetcode.cn/problems/binary-tree-paths/</a></p></blockquote><p>思路是使用前序遍历，将当前节点的值转为字符串插入到数组中，并插入一个<code>-&gt;</code>字符串；递归的末尾条件分两个</p><ul><li>叶子节点，将当前节点的值插入，不需要额外插入<code>-&gt;</code>字符串；</li><li>空节点，直接返回</li></ul><p>递归函数的传参如下，其中string变量不能传引用，因为这样的话，下一层的修改就会影响上层，上层还需要做删除下一层的元素的操作，很麻烦。<code>vector&lt;string&gt;&amp; retV</code>变量需要传引用，因为它包含了所有路径字符串，作为返回值。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">binaryTreePaths</span><span class="params">(TreeNode* root,string curStr,vector&lt;string&gt;&amp; retV)</span></span></span><br></pre></td></tr></table></figure><hr><p>下面的代码中有一个错误的思路，如果遇到空节点就将字符串插入到数组，对于有一个子树的非叶子节点（此时它的左侧或者右侧是空的），就会多插入一个无效的路径，因为此时这个节点并非叶子节点。</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/03/25aa7223e84bc8baeb4dc74da7e3b5ca.png" alt="image-20240316101831139"></p><p>正确的处理办法是到叶子节点了再插入数组，遇到空节点直接返回，不需要做任何处理。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 字符串不能传引用，不然下层的更改会影响上层</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">binaryTreePaths</span><span class="params">(TreeNode* root,string curStr,vector&lt;string&gt;&amp; retV)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// // 到空节点了就插入到数组中</span></span><br><span class="line">        <span class="comment">// if(root == nullptr)&#123;</span></span><br><span class="line">        <span class="comment">//     // 删除多余的-&gt;</span></span><br><span class="line">        <span class="comment">//     retV.push_back(curStr.substr(0,curStr.size()-2));</span></span><br><span class="line">        <span class="comment">//     return;</span></span><br><span class="line">        <span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 上面的思路错误，如果某个节点有左子树或右子树，此时就会多插入一个无效的路径</span></span><br><span class="line">        <span class="comment">// 正确思路是空节点不处理</span></span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">nullptr</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 到叶子节点了就直接插入到数组中</span></span><br><span class="line">        <span class="keyword">if</span>(root-&gt;left == <span class="literal">nullptr</span> &amp;&amp; root-&gt;right == <span class="literal">nullptr</span>)&#123;</span><br><span class="line">            curStr +=  <span class="built_in">to_string</span>(root-&gt;val);</span><br><span class="line">            retV.<span class="built_in">push_back</span>(curStr); <span class="comment">// 不需要删除多余的-&gt;</span></span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 前序遍历</span></span><br><span class="line">        curStr += <span class="built_in">to_string</span>(root-&gt;val);</span><br><span class="line">        curStr += <span class="string">&quot;-&gt;&quot;</span>;</span><br><span class="line">        <span class="built_in">binaryTreePaths</span>(root-&gt;left,curStr,retV);</span><br><span class="line">        <span class="built_in">binaryTreePaths</span>(root-&gt;right,curStr,retV);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function">vector&lt;string&gt; <span class="title">binaryTreePaths</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        vector&lt;string&gt; retV;</span><br><span class="line">        <span class="built_in">binaryTreePaths</span>(root,<span class="string">&quot;&quot;</span>,retV);</span><br><span class="line">        <span class="keyword">return</span> retV;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/03/f1c77d652f76b84075ebb60c656bc98c.png" alt="image-20240316102109684"></p><p>也可以使用迭代法，就是利用<strong>前序遍历的迭代思路</strong>将代码从递归改成迭代。</p><p>这里需要用到第二个栈，一个栈用来存放遍历的节点，另外一个栈用来存放当前遍历到的节点的上一层的字符串。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;string&gt; <span class="title">binaryTreePaths</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        vector&lt;string&gt; retV;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">nullptr</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> retV;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        stack&lt;TreeNode*&gt; stNode; <span class="comment">// 存放节点</span></span><br><span class="line">        stack&lt;string&gt; stStr; <span class="comment">// 存放上一层的字符串</span></span><br><span class="line">        stNode.<span class="built_in">push</span>(root);</span><br><span class="line">        <span class="comment">// stStr.push(to_string(root-&gt;val));</span></span><br><span class="line">        stStr.<span class="built_in">push</span>(<span class="string">&quot;&quot;</span>); <span class="comment">// 这里一定要插入空字符串而不是根节点的值</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(!stNode.<span class="built_in">empty</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 前序遍历</span></span><br><span class="line">            TreeNode* curNode = stNode.<span class="built_in">top</span>(); <span class="comment">// 中</span></span><br><span class="line">            <span class="comment">// cout &lt;&lt; curNode-&gt;val &lt;&lt; endl;</span></span><br><span class="line">            stNode.<span class="built_in">pop</span>();</span><br><span class="line">            string curStr = stStr.<span class="built_in">top</span>();</span><br><span class="line">            stStr.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="comment">// 遇到叶子节点，插入值然后返回</span></span><br><span class="line">            <span class="keyword">if</span>(curNode-&gt;left == <span class="literal">nullptr</span> &amp;&amp; curNode-&gt;right == <span class="literal">nullptr</span>)&#123;</span><br><span class="line">                <span class="comment">// curStr += &quot;-&gt;&quot;;</span></span><br><span class="line">                curStr += <span class="built_in">to_string</span>(curNode-&gt;val);</span><br><span class="line">                retV.<span class="built_in">push_back</span>(curStr);</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 左</span></span><br><span class="line">            <span class="keyword">if</span>(curNode-&gt;left != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">                stNode.<span class="built_in">push</span>(curNode-&gt;left);</span><br><span class="line">                stStr.<span class="built_in">push</span>(curStr  + <span class="built_in">to_string</span>(curNode-&gt;val)+ <span class="string">&quot;-&gt;&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 右</span></span><br><span class="line">            <span class="keyword">if</span>(curNode-&gt;right != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">                stNode.<span class="built_in">push</span>(curNode-&gt;right);</span><br><span class="line">                stStr.<span class="built_in">push</span>(curStr  + <span class="built_in">to_string</span>(curNode-&gt;val)+ <span class="string">&quot;-&gt;&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> retV;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/03/00bec4e34eef1c6765743903454e323b.png" alt="image-20240316104632107"></p><h2 id="404-左叶子之和"><a href="#404-左叶子之和" class="headerlink" title="404 左叶子之和"></a>404 左叶子之和</h2><blockquote><p><a href="https://leetcode.cn/problems/sum-of-left-leaves/description/">https://leetcode.cn/problems/sum-of-left-leaves/description/</a></p></blockquote><p>给定二叉树的根节点 <code>root</code> ，返回所有左叶子之和。</p><p>这道题我本来的思路是使用层序遍历，除去根节点外，<strong>每一层的第一个就是左叶子的可能节点</strong>。注意是可能，还需要判断这个节点到底是不是叶子节点。如果是就将其加入sum中。</p><p>但是这个思路是<strong>错的</strong>，因为每一层不一定有左侧叶子节点，第一个节点可能是右子树，不符合题目条件。</p><p>正确的办法是用递归，顺序算是中序遍历，当遇到叶子节点和空节点的时候，返回0，当遇到当前节点的左侧节点是叶子节点的时候，返回这个节点的值。</p><p>因为左侧节点不能通过当前节点来判断出来，必须要用父亲节点才能判断，所以“中序”就是在通过父亲节点判断左侧节点是不是叶子节点。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> _sumOfLeftLeaves(TreeNode* root)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 根节点为空，跳过</span></span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">nullptr</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 叶子节点，跳过（因为左侧叶子节点不存在，值视作为0）</span></span><br><span class="line">        <span class="keyword">if</span>(root-&gt;left == <span class="literal">nullptr</span> &amp;&amp; root-&gt;right == <span class="literal">nullptr</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 遍历左侧</span></span><br><span class="line">        <span class="type">int</span> left = _sumOfLeftLeaves(root-&gt;left);</span><br><span class="line">        <span class="comment">// 判断左侧是否为叶子节点，如果是需要进行修正（上一行的递归会跳过叶子节点的情况）</span></span><br><span class="line">        <span class="keyword">if</span>(root-&gt;left &amp;&amp; root-&gt;left-&gt;left == <span class="literal">nullptr</span> &amp;&amp; root-&gt;left-&gt;right==<span class="literal">nullptr</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            left = root-&gt;left-&gt;val; <span class="comment">// 左侧叶子节点的值</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 遍历右侧</span></span><br><span class="line">        <span class="type">int</span> right = _sumOfLeftLeaves(root-&gt;right);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> right + left;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">sumOfLeftLeaves</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> _sumOfLeftLeaves(root);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/03/4b6bc8846a4683698401c3b0057e5c91.png" alt="image-20240316111425986"></p><p>你也可以把代码按下面的方式写，会更好理解一些。当判断出当前左子树是叶子节点，就直接赋值，不是叶子节点才去遍历。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> _sumOfLeftLeaves(TreeNode* root)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 根节点为空，跳过</span></span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">nullptr</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 叶子节点，跳过（因为左侧叶子节点不存在，值视作为0）</span></span><br><span class="line">        <span class="keyword">if</span>(root-&gt;left == <span class="literal">nullptr</span> &amp;&amp; root-&gt;right == <span class="literal">nullptr</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 判断左侧是否为叶子节点</span></span><br><span class="line">        <span class="keyword">if</span>(root-&gt;left &amp;&amp; root-&gt;left-&gt;left == <span class="literal">nullptr</span> &amp;&amp; root-&gt;left-&gt;right==<span class="literal">nullptr</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            left = root-&gt;left-&gt;val; <span class="comment">// 左侧叶子节点的值</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            left = _sumOfLeftLeaves(root-&gt;left);<span class="comment">// 遍历左侧</span></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 遍历右侧</span></span><br><span class="line">        <span class="type">int</span> right = _sumOfLeftLeaves(root-&gt;right);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> right + left;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">sumOfLeftLeaves</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> _sumOfLeftLeaves(root);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/03/4ae5fbd2fe03e19ee457f91c4716c20d.png" alt="image-20240316111635285"></p><p>使用迭代也是借用遍历的思路，都是在父节点判断左子树是否为叶子节点。下面的代码来自代码随想录。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">sumOfLeftLeaves</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        stack&lt;TreeNode*&gt; st;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        st.<span class="built_in">push</span>(root);</span><br><span class="line">        <span class="type">int</span> result = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (!st.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            TreeNode* node = st.<span class="built_in">top</span>();</span><br><span class="line">            st.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="keyword">if</span> (node-&gt;left != <span class="literal">NULL</span> &amp;&amp; node-&gt;left-&gt;left == <span class="literal">NULL</span> &amp;&amp; node-&gt;left-&gt;right == <span class="literal">NULL</span>) &#123;</span><br><span class="line">                result += node-&gt;left-&gt;val;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (node-&gt;right) st.<span class="built_in">push</span>(node-&gt;right);</span><br><span class="line">            <span class="keyword">if</span> (node-&gt;left) st.<span class="built_in">push</span>(node-&gt;left);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="513-找树左下角的值"><a href="#513-找树左下角的值" class="headerlink" title="513 找树左下角的值"></a>513 找树左下角的值</h2><blockquote><p><a href="https://leetcode.cn/problems/find-bottom-left-tree-value/">https://leetcode.cn/problems/find-bottom-left-tree-value/</a></p></blockquote><p>给定一个二叉树的 <strong>根节点</strong> <code>root</code>，请找出该二叉树的 <strong>最底层 最左边</strong> 节点的值。</p><p>假设二叉树中至少有一个节点。</p><hr><p>这道题用上题层序遍历的思路才是对的，利用层序遍历走到最底层，将这一层最左侧的节点返回。但是这里会涉及到一个问题，<strong>我们怎么知道自己走到最后一层了呢</strong>？</p><p>实际上，并不需要去特殊判断，只需要将层序遍历每一层的第一个节点的值设置为返回值，这样层序遍历结束后，最后被设置的值就是题目需要求的节点。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">findBottomLeftValue</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">nullptr</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        queue&lt;TreeNode*&gt; que;</span><br><span class="line">        que.<span class="built_in">push</span>(root);</span><br><span class="line">        <span class="type">int</span> ret = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(!que.<span class="built_in">empty</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> size = que.<span class="built_in">size</span>();</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i =<span class="number">0</span>;i&lt;size;i++)</span><br><span class="line">            &#123;</span><br><span class="line">                TreeNode* front = que.<span class="built_in">front</span>();</span><br><span class="line">                que.<span class="built_in">pop</span>();</span><br><span class="line">                <span class="keyword">if</span>(i == <span class="number">0</span>)&#123;</span><br><span class="line">                    ret = front-&gt;val;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(front-&gt;left != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">                    que.<span class="built_in">push</span>(front-&gt;left);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(front-&gt;right != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">                    que.<span class="built_in">push</span>(front-&gt;right);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;   </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/03/6f7b9f6babc8fcbb50d64eb37a926fd0.png" alt="image-20240317161855120"></p><p>递归法使用前序遍历的思想，使用一个变量来记录当前深度，另外一个变量记录最深处左侧节点的值。这里的代码和上文<code>104二叉树的最大深度</code>题目中的思路相似。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> maxDepth = <span class="number">-1</span>; <span class="comment">// 最大深度</span></span><br><span class="line">    <span class="type">int</span> result = <span class="number">0</span>; <span class="comment">// 左侧节点值</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">getMaxDepthLeftNode</span><span class="params">(TreeNode* root,<span class="type">int</span> depth)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// 叶子节点</span></span><br><span class="line">        <span class="keyword">if</span>(root-&gt;right == <span class="literal">nullptr</span> &amp;&amp; root-&gt;left == <span class="literal">nullptr</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(depth &gt; maxDepth)&#123;</span><br><span class="line">                maxDepth = <span class="built_in">max</span>(maxDepth,depth);</span><br><span class="line">                result = root-&gt;val; <span class="comment">// 存放叶子节点的值</span></span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果左侧不为空，往左侧递归</span></span><br><span class="line">        <span class="keyword">if</span>(root-&gt;left != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">            <span class="built_in">getMaxDepthLeftNode</span>(root-&gt;left,depth+<span class="number">1</span>); <span class="comment">// 这里深度加一就相当于加上当前节点</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 往右侧递归</span></span><br><span class="line">        <span class="keyword">if</span>(root-&gt;right != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">            <span class="built_in">getMaxDepthLeftNode</span>(root-&gt;right,depth+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">findBottomLeftValue</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">nullptr</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">getMaxDepthLeftNode</span>(root,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/03/f23bdbc09fdab06e7b0f7542aebeb9a5.png" alt="image-20240317162934828"></p><h2 id="112-路径总和"><a href="#112-路径总和" class="headerlink" title="112 路径总和"></a>112 路径总和</h2><blockquote><p><a href="https://leetcode.cn/problems/path-sum/description/">https://leetcode.cn/problems/path-sum/description/</a></p></blockquote><p>给你二叉树的根节点 <code>root</code> 和一个表示目标和的整数 <code>targetSum</code> 。判断该树中是否存在 <strong>根节点到叶子节点</strong> 的路径，这条路径上所有节点值相加等于目标和 <code>targetSum</code> 。如果存在，返回 <code>true</code> ；否则，返回 <code>false</code> 。</p><p><strong>叶子节点</strong> 是指没有子节点的节点。</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/03/9924f255828e9bf5d223554c29c23c31.png" alt="image-20240317163532398"></p><p>这道题和<code>257 二叉树的所有路径</code>有些类似，不过那道题是需要将路径写入数组，这道题是需要判断有没有路径中节点值的和为指定数的情况。</p><p>递归函数中，传入目标值targetSum，当前值curSum（这里的当前值也是用了“回溯”的思想），为了避免错误修改目标值targetSum，将其设置为const变量。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">frontTravelTree</span><span class="params">(TreeNode* root,<span class="type">const</span> <span class="type">int</span> targetSum, <span class="type">int</span> curSum)</span></span></span><br></pre></td></tr></table></figure><p>递归的思路如下</p><ul><li>如果当前节点为空，直接返回false，不需要处理</li><li>如果当前节点非空，将当前节点的值加入curSum；</li><li>如果当前节点是叶子节点，判断当前的curSum是否等于targetSum，等于返回true；</li><li>往左侧和右侧递归，返回这两个递归结果的<strong>或</strong>；</li></ul><p>注意，判断targetSum的时候一定要判断是不是叶子节点，我刚开始写的时候就忘记判断了，因为路径可能还没到叶子节点就已经等于targetSum了，但是这种情况不符合题目条件。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">frontTravelTree</span><span class="params">(TreeNode* root,<span class="type">const</span> <span class="type">int</span> targetSum, <span class="type">int</span> curSum)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">nullptr</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        curSum += root-&gt;val;</span><br><span class="line">        <span class="comment">// 当前已经相等，且是叶子节点，返回</span></span><br><span class="line">        <span class="keyword">if</span>(targetSum == curSum &amp;&amp; root-&gt;left == <span class="literal">nullptr</span> &amp;&amp; root-&gt;right == <span class="literal">nullptr</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="type">bool</span> retLeft = <span class="built_in">frontTravelTree</span>(root-&gt;left,targetSum,curSum);</span><br><span class="line">        <span class="type">bool</span> retRight = <span class="built_in">frontTravelTree</span>(root-&gt;right,targetSum,curSum);</span><br><span class="line">        <span class="keyword">return</span> retLeft || retRight;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">hasPathSum</span><span class="params">(TreeNode* root, <span class="type">int</span> targetSum)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">frontTravelTree</span>(root,targetSum,<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/03/15e968da70f14f4a995298e2cef928e4.png" alt="image-20240317163820934"></p><p>使用迭代，也是用前序遍历的思路，用栈来实现。这里的思路和<code>257 二叉树的所有路径</code>中也是一样的，需要用到两个栈，一个用来遍历节点，另外一个保存上一层遍历到的节点curSum。</p><p>注意，因为是前序遍历，且每一次都会让curSum加上当前节点的值，所以stSum这个栈在初始化的时候一定要插入0，而不是根节点的值（不然会二次加根节点的值，会出错）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">hasPathSum</span><span class="params">(TreeNode* root, <span class="type">int</span> targetSum)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">nullptr</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        stack&lt;TreeNode*&gt; stNode; <span class="comment">// 遍历节点</span></span><br><span class="line">        stack&lt;<span class="type">int</span>&gt; stSum; <span class="comment">// 上一层遍历的求和结果</span></span><br><span class="line">        </span><br><span class="line">        stNode.<span class="built_in">push</span>(root);</span><br><span class="line">        stSum.<span class="built_in">push</span>(<span class="number">0</span>); <span class="comment">// 这里一定要插入0而不是根节点的值</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(!stNode.<span class="built_in">empty</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            TreeNode* curNode = stNode.<span class="built_in">top</span>();</span><br><span class="line">            stNode.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="type">int</span> curSum = stSum.<span class="built_in">top</span>();</span><br><span class="line">            stSum.<span class="built_in">pop</span>();</span><br><span class="line">            </span><br><span class="line">            curSum += curNode-&gt;val;</span><br><span class="line">            <span class="comment">// 如果是叶子节点，判断是否相等</span></span><br><span class="line">            <span class="keyword">if</span>(curNode-&gt;left == <span class="literal">nullptr</span> &amp;&amp; curNode-&gt;right == <span class="literal">nullptr</span> &amp;&amp; curSum == targetSum)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 继续向下</span></span><br><span class="line">            <span class="keyword">if</span>(curNode-&gt;left != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">                stNode.<span class="built_in">push</span>(curNode-&gt;left);</span><br><span class="line">                stSum.<span class="built_in">push</span>(curSum);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(curNode-&gt;right != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">                stNode.<span class="built_in">push</span>(curNode-&gt;right);</span><br><span class="line">                stSum.<span class="built_in">push</span>(curSum);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/03/c2f0411797bfce72243ae97448cbd33b.png" alt="image-20240317165115333"></p><h2 id="113-路径总和Ⅱ"><a href="#113-路径总和Ⅱ" class="headerlink" title="113 路径总和Ⅱ"></a>113 路径总和Ⅱ</h2><blockquote><p><a href="https://leetcode.cn/problems/path-sum-ii/">113. 路径总和 II</a></p></blockquote><p>上一题是让我们判断是否存在某一条路径，这题是需要返回所有符合条件的路径。</p><p>思路是使用前序遍历，用一个curSum记录当前遍历到的和，将当前值加入到这个和中并将当前值插入curV数组；</p><p>如果<strong>是叶子节点</strong>，则与targetSum对比，符合条件则将curV数组插入到返回值数组retV中。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="type">void</span> _pathSum(TreeNode* root, <span class="type">const</span> <span class="type">int</span> targetSum,<span class="type">int</span> curSum, vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; retV,vector&lt;<span class="type">int</span>&gt; curV) &#123;</span><br><span class="line">        <span class="comment">// 空节点跳过</span></span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">nullptr</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 前序遍历</span></span><br><span class="line">        curSum += root-&gt;val;</span><br><span class="line">        curV.<span class="built_in">push_back</span>(root-&gt;val);</span><br><span class="line">        <span class="comment">// 叶子节点，且值相等，插入</span></span><br><span class="line">        <span class="keyword">if</span>(root-&gt;left == <span class="literal">nullptr</span> &amp;&amp; root-&gt;right == <span class="literal">nullptr</span> &amp;&amp; curSum == targetSum)&#123;</span><br><span class="line">            retV.<span class="built_in">push_back</span>(curV);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 左右递归</span></span><br><span class="line">        _pathSum(root-&gt;left,targetSum,curSum,retV,curV);</span><br><span class="line">        _pathSum(root-&gt;right,targetSum,curSum,retV,curV);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">pathSum</span>(TreeNode* root, <span class="type">int</span> targetSum) &#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; retV;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">nullptr</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> retV;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        _pathSum(root,targetSum,<span class="number">0</span>,retV,<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;());</span><br><span class="line">        <span class="keyword">return</span> retV;</span><br><span class="line">    &#125;   </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/03/d1bbdfc5f2846feb568ce10501ef2400.png" alt="image-20240318103424964"></p><h2 id="106-从中序与后序遍历序列构造二叉树"><a href="#106-从中序与后序遍历序列构造二叉树" class="headerlink" title="106 从中序与后序遍历序列构造二叉树"></a>106 从中序与后序遍历序列构造二叉树</h2><blockquote><p><a href="https://leetcode.cn/problems/construct-binary-tree-from-inorder-and-postorder-traversal/">106 从中序与后序遍历序列构造二叉树</a></p></blockquote><p>给定两个整数数组 <code>inorder</code> 和 <code>postorder</code> ，其中 <code>inorder</code> 是二叉树的中序遍历， <code>postorder</code> 是同一棵树的后序遍历，请你构造并返回这颗 <em>二叉树</em> 。</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/03/cd173d709ec7bad3687083e5340a185e.png" alt="image-20240317171026511"></p><p>首先，要通过中序和后序遍历的概念知道如何从这两个数组中构造一棵树来。</p><ul><li>后序的最后一个节点是根节点</li><li>确定根节点后，中序遍历中根节点左侧的是左子树，右侧的是右子树；</li><li>继续依照这个概念拆分后序遍历的数组，找到左右子树的根节点…</li></ul><p>对于代码而言，重点就是将左右子树从中序和后序的数组中拆分开来，直到拆分到空节点。</p><ol><li>数组大小为空，说明是空节点</li><li>数组大小不为空，从后序遍历中取出最后一个值作为根节点的值；</li><li>从中序遍历的数组中找到根节点所在位置，作为拆分的中位线；</li><li>将中序遍历的数组依照根节点所在位置拆分成左子数组和右子数组；</li><li>切割后序遍历的数组，依照左侧数组和右侧数组的长度和中序遍历拆分后的长度一致来处理（如果中序拆出来的左子树数组有3个元素，那么后序遍历中左子树的数组就是从前往后数的前3个元素）；</li><li>递归处理左侧和右侧的子树；</li></ol><p>代码如下，主要需要注意的是拆分中序和后序数组时候迭代器的位置，这里的下标拆分范围如果搞不清楚可以打印出来多试试，记住思路是最重要的。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    TreeNode* _buildTree(vector&lt;<span class="type">int</span>&gt;&amp; inorder, vector&lt;<span class="type">int</span>&gt;&amp; postorder) &#123;</span><br><span class="line">        <span class="comment">// 递归分治条件</span></span><br><span class="line">        <span class="keyword">if</span>(inorder.<span class="built_in">size</span>() == <span class="number">0</span> || postorder.<span class="built_in">size</span>() == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 后序遍历的最后一个节点是根节点</span></span><br><span class="line">        <span class="type">int</span> val = postorder[postorder.<span class="built_in">size</span>()<span class="number">-1</span>];</span><br><span class="line">        TreeNode* root = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(val);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 在中序遍历数组中找到这个值，注意题目保证节点值不重复，所以能这么做。</span></span><br><span class="line">        <span class="type">int</span> i = <span class="number">0</span>; <span class="comment">// 提前定义，后面要用</span></span><br><span class="line">        <span class="keyword">for</span>(i = <span class="number">0</span>;i&lt;inorder.<span class="built_in">size</span>();i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(inorder[i] == val)&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 拆中序数组，使用[0,i)区间</span></span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">inorderLeft</span><span class="params">(inorder.begin(),inorder.begin()+i)</span></span>;</span><br><span class="line">        <span class="comment">// 下面这里是[i+1,end)区间，必须额外加一，否则不符合条件</span></span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">inorderRight</span><span class="params">(inorder.begin()+i+<span class="number">1</span>,inorder.end())</span></span>; </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 拆后续数组，因为后续数组的大小肯定和中序一致，从前往后拆就分别对应中序的左数组和右数组了</span></span><br><span class="line">        <span class="comment">// 将后续遍历数组中的的最后一个值删掉，因为当前已经使用了</span></span><br><span class="line">        postorder.<span class="built_in">resize</span>(postorder.<span class="built_in">size</span>()<span class="number">-1</span>); </span><br><span class="line">        <span class="comment">// 这里inorderLeft.size()理论上和i是相同的，所以用i也没问题</span></span><br><span class="line">        <span class="comment">// [0,inorderLeft.size())</span></span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">postorderLeft</span><span class="params">(postorder.begin(),postorder.begin()+inorderLeft.size())</span></span>;</span><br><span class="line">        <span class="comment">// [inorderLeft.size(),end())</span></span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">postorderRight</span><span class="params">(postorder.begin()+inorderLeft.size(),postorder.end())</span></span>;</span><br><span class="line"></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 递归遍历</span></span><br><span class="line">        TreeNode* left = _buildTree(inorderLeft,postorderLeft);</span><br><span class="line">        TreeNode* right = _buildTree(inorderRight,postorderRight);</span><br><span class="line">        <span class="comment">// 链接</span></span><br><span class="line">        root-&gt;left = left;</span><br><span class="line">        root-&gt;right = right;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">buildTree</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; inorder, vector&lt;<span class="type">int</span>&gt;&amp; postorder)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(inorder.<span class="built_in">size</span>() == <span class="number">0</span> || postorder.<span class="built_in">size</span>() == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> _buildTree(inorder,postorder);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/03/77678c2d171a81344112bf3d3f177ef2.png" alt="image-20240317173609279"></p><p>当然，上面的代码性能并不好，因为会有额外的空间复杂度消耗（每次递归都需要构建4个vector数组），我们可以将构建数组的操作改成用下标来标定区间。</p><p>代码如下，同样需要注意下标的区间，详见注释。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    TreeNode* _buildTree(<span class="type">const</span> vector&lt;<span class="type">int</span>&gt;&amp; inorder,<span class="type">int</span> inorderBegin,<span class="type">int</span> inorderEnd,<span class="type">const</span> vector&lt;<span class="type">int</span>&gt;&amp; postorder,<span class="type">int</span> postorderBegin,<span class="type">int</span> postorderEnd) &#123;        </span><br><span class="line">        <span class="keyword">if</span>(inorderBegin&gt;=inorderEnd || postorderBegin &gt;= postorderEnd)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 后序遍历的最后一个节点是根节点</span></span><br><span class="line">        <span class="comment">// int val = postorder[postorder.size()-1];</span></span><br><span class="line">        <span class="type">int</span> val = postorder[postorderEnd<span class="number">-1</span>];</span><br><span class="line">        TreeNode* root = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(val);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 在中序遍历数组中找到这个值，注意题目保证节点值不重复，所以能这么做。</span></span><br><span class="line">        <span class="type">int</span> i = <span class="number">0</span>; <span class="comment">// 提前定义，后面要用</span></span><br><span class="line">        <span class="comment">// for(i = 0;i&lt;inorder.size();i++)</span></span><br><span class="line">        <span class="keyword">for</span>(i = inorderBegin;i&lt;inorderEnd;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(inorder[i] == val)&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 拆中序数组，使用[0,i)区间</span></span><br><span class="line">        <span class="type">int</span> inorderBeginLeft = inorderBegin;</span><br><span class="line">        <span class="type">int</span> inorderEndLeft = inorderBegin+(i-inorderBegin); <span class="comment">// 如果直接加i是错误的，i已经是下标了，再加会超出范围</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 下面这里是[i+1,end)区间，必须额外加一，否则不符合条件</span></span><br><span class="line">        <span class="type">int</span> inorderBeginRight = inorderBegin+(i-inorderBegin)+<span class="number">1</span>; <span class="comment">// 这里需要加一，是跳过被选中的中间节点</span></span><br><span class="line">        <span class="type">int</span> inorderEndRight = inorderEnd;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 拆后续数组，因为后续数组的大小肯定和中序一致，从前往后拆就分别对应中序的左数组和右数组了</span></span><br><span class="line">        <span class="comment">// [0,inorderLeft.size())</span></span><br><span class="line">        <span class="type">int</span> postorderBeginLeft = postorderBegin;</span><br><span class="line">        <span class="type">int</span> postorderEndLeft = postorderBegin + (i - inorderBegin);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// [inorderLeft.size(),end())</span></span><br><span class="line">        <span class="type">int</span> postorderBeginRight = postorderBegin + (i - inorderBegin); <span class="comment">// 这里不需要加一，因为中间没有多出来一个数</span></span><br><span class="line">        <span class="type">int</span> postorderEndRight = postorderEnd <span class="number">-1</span>; <span class="comment">// 排除最后一个节点</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 递归遍历</span></span><br><span class="line">        TreeNode* left = _buildTree(inorder,inorderBeginLeft,inorderEndLeft,postorder,postorderBeginLeft,postorderEndLeft);</span><br><span class="line">        TreeNode* right = _buildTree(inorder,inorderBeginRight,inorderEndRight,postorder,postorderBeginRight,postorderEndRight);</span><br><span class="line">        <span class="comment">// 链接</span></span><br><span class="line">        root-&gt;left = left;</span><br><span class="line">        root-&gt;right = right;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">buildTree</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; inorder, vector&lt;<span class="type">int</span>&gt;&amp; postorder)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(inorder.<span class="built_in">size</span>() == <span class="number">0</span> || postorder.<span class="built_in">size</span>() == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> _buildTree(inorder,<span class="number">0</span>,inorder.<span class="built_in">size</span>(),postorder,<span class="number">0</span>,postorder.<span class="built_in">size</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/03/c20668f2784839f073d00b700bc039d1.png" alt="image-20240317182254991"></p><h2 id="105-从前序和中序遍历构造二叉树"><a href="#105-从前序和中序遍历构造二叉树" class="headerlink" title="105 从前序和中序遍历构造二叉树"></a>105 从前序和中序遍历构造二叉树</h2><blockquote><p><a href="https://leetcode.cn/problems/construct-binary-tree-from-preorder-and-inorder-traversal/">105. 从前序与中序遍历序列构造二叉树</a></p></blockquote><p>给定两个整数数组 <code>preorder</code> 和 <code>inorder</code> ，其中 <code>preorder</code> 是二叉树的<strong>先序遍历</strong>， <code>inorder</code> 是同一棵树的<strong>中序遍历</strong>，请构造二叉树并返回其根节点。</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/03/3b2acc3f4d092a12194f29d9c922f159.png" alt="image-20240317182505486"></p><p>这道题和上一道题的思路基本一致，这里就不用构造vector的思路了，直接用下标的方式来处理。</p><ul><li>前序遍历的第一个值是根节点</li><li>在中序遍历的数组中找到根节点的位置，根据该位置左右拆分数组</li><li>在前序遍历数组中，从第二位开始，根据中序遍历拆出来的两个数组的长度，拆分前序遍历的数组。</li><li>递归处理</li></ul><p>在后序遍历的数组中，需要排除的是最后一位。在前序遍历的数组中，需要排除的是第一位。在拆分数组下标的地方体现出来。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    TreeNode* _buildTree(<span class="type">const</span> vector&lt;<span class="type">int</span>&gt;&amp; preorder,<span class="type">int</span> preorderBegin,<span class="type">int</span> preorderEnd,<span class="type">const</span>  vector&lt;<span class="type">int</span>&gt;&amp; inorder, <span class="type">int</span> inorderBegin,<span class="type">int</span> inorderEnd)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 递归返回条件</span></span><br><span class="line">        <span class="keyword">if</span>(inorderBegin &gt;= inorderEnd || preorderBegin &gt;= preorderEnd)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 前序遍历的第一个</span></span><br><span class="line">        <span class="type">int</span> val = preorder[preorderBegin];</span><br><span class="line">        TreeNode* root = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(val);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 在中序遍历数组中找</span></span><br><span class="line">        <span class="type">int</span> i =<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(i = inorderBegin;i&lt;inorderEnd;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(inorder[i] == val)&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 拆分中序遍历数组</span></span><br><span class="line">        <span class="type">int</span> offset = i-inorderBegin;</span><br><span class="line">        <span class="comment">// 左侧数组[inorderBegin,inorderBegin+offset)</span></span><br><span class="line">        <span class="type">int</span> inorderBeginLeft = inorderBegin;</span><br><span class="line">        <span class="type">int</span> inorderEndLeft = inorderBegin + offset;  <span class="comment">// 这里不能直接加i，应该加i和开头的偏移量</span></span><br><span class="line">        <span class="comment">// 右侧数组[inorderBegin+offset+1,inorderEnd)</span></span><br><span class="line">        <span class="type">int</span> inorderBeginRight = inorderBegin + offset+<span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> inorderEndRight = inorderEnd;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 拆分前序遍历数组</span></span><br><span class="line">        <span class="comment">// 左侧数组[preorderBegin+1,preorderBegin+1+offset)，开头需要加一跳过第一个值</span></span><br><span class="line">        <span class="type">int</span> preorderBeginLeft = preorderBegin+<span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> preorderEndLeft = preorderBegin+<span class="number">1</span>+offset;</span><br><span class="line">        <span class="comment">// 右侧数组[preorderBegin+1+offset,preorderEnd)</span></span><br><span class="line">        <span class="type">int</span> preorderBeginRight = preorderBegin+<span class="number">1</span>+offset;</span><br><span class="line">        <span class="type">int</span> preorderEndRight = preorderEnd;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 递归遍历</span></span><br><span class="line">        TreeNode* left = _buildTree(preorder,preorderBeginLeft,preorderEndLeft,inorder,inorderBeginLeft,inorderEndLeft);</span><br><span class="line">        TreeNode* right = _buildTree(preorder,preorderBeginRight,preorderEndRight,inorder,inorderBeginRight,inorderEndRight);</span><br><span class="line">        <span class="comment">// 链接</span></span><br><span class="line">        root-&gt;left = left;</span><br><span class="line">        root-&gt;right = right;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">buildTree</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; preorder, vector&lt;<span class="type">int</span>&gt;&amp; inorder)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(preorder.<span class="built_in">size</span>() == <span class="number">0</span> || inorder.<span class="built_in">size</span>() == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> _buildTree(preorder,<span class="number">0</span>,preorder.<span class="built_in">size</span>(),inorder,<span class="number">0</span>,inorder.<span class="built_in">size</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/03/61d66d0b4bbef588ec323178e26c13fa.png" alt="image-20240317184256405"></p><h2 id="654-最大二叉树"><a href="#654-最大二叉树" class="headerlink" title="654 最大二叉树"></a>654 最大二叉树</h2><blockquote><p><a href="https://leetcode.cn/problems/maximum-binary-tree/">654. 最大二叉树</a></p></blockquote><p>给定一个不重复的整数数组 <code>nums</code> 。 <strong>最大二叉树</strong> 可以用下面的算法从 <code>nums</code> 递归地构建:</p><ol><li>创建一个根节点，其值为 <code>nums</code> 中的最大值。</li><li>递归地在最大值 <strong>左边</strong> 的 <strong>子数组前缀上</strong> 构建左子树。</li><li>递归地在最大值 <strong>右边</strong> 的 <strong>子数组后缀上</strong> 构建右子树。</li></ol><p>返回 <code>nums</code> 构建的<strong>最大二叉树</strong> 。</p><hr><p>这道题和前面105&#x2F;106这两道题的思路几乎完全一致，用前序遍历递归的思想，先找到最大值作为根节点，然后拆分左右区间（类似与105&#x2F;106题目中拆分中序遍历数组的左右区间）。拆分区间后进行遍历构建左右子树就行了。</p><p>这里要注意递归的退出条件，因为begin&#x2F;end选用的是左闭右开的选择，所以<code>begin==end</code>的情况也是无效的，所以<code>begin&gt;=end</code>作为递归的退出条件。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="comment">// 查找最大值，返回最大值的下标</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">searchMaxIndex</span><span class="params">(<span class="type">const</span> vector&lt;<span class="type">int</span>&gt;&amp; nums,<span class="type">int</span> begin,<span class="type">int</span> end)</span></span>&#123;</span><br><span class="line">        <span class="type">int</span> maxNum = nums[begin];</span><br><span class="line">        <span class="type">int</span> maxNumIndex = begin;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = begin;i&lt;end;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i] &gt; maxNum)&#123;</span><br><span class="line">                maxNum = nums[i];</span><br><span class="line">                maxNumIndex = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxNumIndex;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    TreeNode* _constructMaximumBinaryTree(<span class="type">const</span> vector&lt;<span class="type">int</span>&gt;&amp; nums,<span class="type">int</span> begin,<span class="type">int</span> end)&#123;</span><br><span class="line">        <span class="comment">// 本题采用左闭右开，所以begin==end是无效区间</span></span><br><span class="line">        <span class="keyword">if</span>(nums.<span class="built_in">size</span>() == <span class="number">0</span> || begin&gt;=end)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 找到最大值的下标</span></span><br><span class="line">        <span class="type">int</span> maxNumIndex = <span class="built_in">searchMaxIndex</span>(nums,begin,end);</span><br><span class="line">        TreeNode* root = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(nums[maxNumIndex]);</span><br><span class="line">        <span class="comment">// 左右拆分</span></span><br><span class="line">        <span class="type">int</span> leftBegin = begin;</span><br><span class="line">        <span class="type">int</span> leftEnd = maxNumIndex; </span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> rightBegin = maxNumIndex+<span class="number">1</span>; <span class="comment">// 加一跳过当前选中节点</span></span><br><span class="line">        <span class="type">int</span> rightEnd = end;</span><br><span class="line"></span><br><span class="line">        root-&gt;left = _constructMaximumBinaryTree(nums,leftBegin,leftEnd);</span><br><span class="line">        root-&gt;right = _constructMaximumBinaryTree(nums,rightBegin,rightEnd);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">constructMaximumBinaryTree</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums.<span class="built_in">size</span>() == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> _constructMaximumBinaryTree(nums,<span class="number">0</span>,nums.<span class="built_in">size</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/03/da6a3c1927b4d27c72da012d018f3cbc.png" alt="image-20240317193842851"></p><h2 id="617-合并二叉树"><a href="#617-合并二叉树" class="headerlink" title="617 合并二叉树"></a>617 合并二叉树</h2><blockquote><p><a href="https://leetcode.cn/problems/merge-two-binary-trees/">617. 合并二叉树</a></p></blockquote><p>想象一下，当你将其中一棵覆盖到另一棵之上时，两棵树上的一些节点将会重叠（而另一些不会）。你需要将这两棵树合并成一棵新二叉树。合并的规则是：如果两个节点重叠，那么将这两个节点的值相加作为合并后节点的新值；否则，<strong>不为</strong> null 的节点将直接作为新二叉树的节点。</p><p>返回合并后的二叉树。</p><p><strong>注意:</strong> 合并过程必须从两个树的根节点开始。</p><hr><p>这道题其实就是遍历二叉树多了第二棵树而已，不需要想的太复杂</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    TreeNode* _mergeTrees(TreeNode* root1, TreeNode* root2) &#123;</span><br><span class="line">        <span class="comment">// 如果一棵树为空了，就直接返回另外一棵树来拼接</span></span><br><span class="line">        <span class="keyword">if</span>(root1 == <span class="literal">nullptr</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> root2;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(root2 == <span class="literal">nullptr</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> root1;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 借用root1加上值</span></span><br><span class="line">        root1-&gt;val += root2-&gt;val;</span><br><span class="line">        <span class="comment">// 这里因为root1和root2的遍历顺序都是一样的，所以肯定能匹配上</span></span><br><span class="line">        root1-&gt;left = _mergeTrees(root1-&gt;left,root2-&gt;left);</span><br><span class="line">        root1-&gt;right = _mergeTrees(root1-&gt;right,root2-&gt;right);</span><br><span class="line">        <span class="keyword">return</span> root1;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">mergeTrees</span><span class="params">(TreeNode* root1, TreeNode* root2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> _mergeTrees(root1,root2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/03/6d041cf7b2d1792eeb72179653d0d30d.png" alt="image-20240317205658359"></p><p>使用迭代法的层序遍历思想也能解决这道题，需要将两棵树的根都插入队列中。在开始遍历之前，需要确定我们是用root1还是root2来构造最终的二叉树。</p><ul><li>取出节点，值相加</li><li>如果两个节点的左侧都不为空，入队列（注意顺序要一致）</li><li>如果两个节点的右侧都不为空，入队列</li><li>如果r1的左侧节点为空，r2不为空，将r1的左侧链接为r2</li><li>如果r1的右侧节点为空，r2不为空，将r1的右侧链接为r2</li></ul><p>代码如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">mergeTrees</span><span class="params">(TreeNode* root1, TreeNode* root2)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 如果一棵树为空了，就直接返回另外一棵树来拼接</span></span><br><span class="line">        <span class="keyword">if</span>(root1 == <span class="literal">nullptr</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> root2;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(root2 == <span class="literal">nullptr</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> root1;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 到这里root1和2都不为空</span></span><br><span class="line">        queue&lt;TreeNode*&gt; que;</span><br><span class="line">        que.<span class="built_in">push</span>(root1);</span><br><span class="line">        que.<span class="built_in">push</span>(root2);</span><br><span class="line">        <span class="comment">// 确定用root1来链接树</span></span><br><span class="line">        <span class="keyword">while</span>(!que.<span class="built_in">empty</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 这里不需要多层序遍历的循环，因为root1和root2每一层节点个数不相同</span></span><br><span class="line">            </span><br><span class="line">            TreeNode* r1 = que.<span class="built_in">front</span>();</span><br><span class="line">            que.<span class="built_in">pop</span>();</span><br><span class="line">            TreeNode* r2 = que.<span class="built_in">front</span>();</span><br><span class="line">            que.<span class="built_in">pop</span>();</span><br><span class="line">            r1-&gt;val += r2-&gt;val;</span><br><span class="line">            <span class="comment">// 如果两个节点的左右子树都不空，则都插入数组</span></span><br><span class="line">            <span class="keyword">if</span>(r1-&gt;left != <span class="literal">nullptr</span> &amp;&amp; r2-&gt;left != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">                que.<span class="built_in">push</span>(r1-&gt;left);</span><br><span class="line">                que.<span class="built_in">push</span>(r2-&gt;left);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(r1-&gt;right != <span class="literal">nullptr</span> &amp;&amp; r2-&gt;right != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">                que.<span class="built_in">push</span>(r1-&gt;right);</span><br><span class="line">                que.<span class="built_in">push</span>(r2-&gt;right);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 如果r1的左侧为空，r2不为空，赋值</span></span><br><span class="line">            <span class="keyword">if</span>(r1-&gt;left == <span class="literal">nullptr</span> &amp;&amp; r2-&gt;left != <span class="literal">nullptr</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                r1-&gt;left = r2-&gt;left;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(r1-&gt;right == <span class="literal">nullptr</span> &amp;&amp; r2-&gt;right != <span class="literal">nullptr</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                r1-&gt;right = r2-&gt;right;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/03/5cd92f8447a1213e28984aa6693eeecf.png" alt="image-20240317210547382"></p><h2 id="700-二叉搜索树中的搜索"><a href="#700-二叉搜索树中的搜索" class="headerlink" title="700 二叉搜索树中的搜索"></a>700 二叉搜索树中的搜索</h2><blockquote><p><a href="https://leetcode.cn/problems/search-in-a-binary-search-tree/">700. 二叉搜索树中的搜索</a></p></blockquote><p>给定二叉搜索树（BST）的根节点 <code>root</code> 和一个整数值 <code>val</code>。</p><p>你需要在 BST 中找到节点值等于 <code>val</code> 的节点。 返回以该节点为根的子树。 如果节点不存在，则返回 <code>null</code> 。</p><p> 代码如下，其实就是最最基本的搜索二叉树的查找方式。搜索二叉树的左子树的值小于当前节点的值，右子树的值大于当前节点的值。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    TreeNode* _searchBST(TreeNode* root,<span class="type">const</span> <span class="type">int</span> val) &#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">nullptr</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(root-&gt;val == val)&#123;</span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(root-&gt;val &gt; val)&#123;</span><br><span class="line">            <span class="keyword">return</span> _searchBST(root-&gt;left,val); <span class="comment">// 左侧更小</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> _searchBST(root-&gt;right,val); <span class="comment">// 右侧更小</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">searchBST</span><span class="params">(TreeNode* root, <span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">nullptr</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> _searchBST(root,val);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/03/27109369c080398669b2833e19d5f102.png" alt="image-20240317211001013"></p><p>用循环也能实现，因为这里不涉及到前中后序遍历什么的，只是单纯找一个值，所以用不上队列或者栈</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">searchBST</span><span class="params">(TreeNode* root, <span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 用循环也可以</span></span><br><span class="line">        <span class="keyword">while</span>(root != <span class="literal">nullptr</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(root-&gt;val == val)&#123;</span><br><span class="line">                <span class="keyword">return</span> root;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span>(root-&gt;val &gt; val)</span><br><span class="line">            &#123;</span><br><span class="line">                root = root-&gt;left;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                root = root-&gt;right;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="98-验证二层搜索树"><a href="#98-验证二层搜索树" class="headerlink" title="98 验证二层搜索树"></a>98 验证二层搜索树</h2><blockquote><p><a href="https://leetcode.cn/problems/validate-binary-search-tree/">98. 验证二叉搜索树</a></p></blockquote><p>给你一个二叉树的根节点 <code>root</code> ，判断其是否是一个有效的二叉搜索树。</p><p><strong>有效</strong> 二叉搜索树定义如下：</p><ul><li>节点的左子树只包含 <strong>小于</strong> 当前节点的数。</li><li>节点的右子树只包含 <strong>大于</strong> 当前节点的数。</li><li>所有左子树和右子树自身必须也是二叉搜索树。</li></ul><p>注意：二叉搜索树中不能有重复节点，因为无法判断两个相同节点的区别。</p><hr><p>这道题可以采用中序遍历的方式，构建一个二叉树的数组，并遍历判断这个数组是否有序（搜索二叉树的中序遍历肯定是有序的），代码如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="type">void</span> _inorderTravel(TreeNode* root,vector&lt;<span class="type">int</span>&gt;&amp; v)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">nullptr</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        _inorderTravel(root-&gt;left,v);</span><br><span class="line">        v.<span class="built_in">push_back</span>(root-&gt;val);</span><br><span class="line">        _inorderTravel(root-&gt;right,v);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isValidBST</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 本题保证root非空</span></span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; v;</span><br><span class="line">        _inorderTravel(root,v);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i =<span class="number">0</span>;i&lt;v.<span class="built_in">size</span>()<span class="number">-1</span>;i++)&#123;</span><br><span class="line">            <span class="comment">// 不能有重复节点，这里是大于等于</span></span><br><span class="line">            <span class="keyword">if</span>(v[i] &gt;= v[i+<span class="number">1</span>])&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/03/e947106623f118df8d3af395f66560e9.png" alt="image-20240318104631391"></p><p>当然，不用额外的数组也能写出这道题。思路是用中序遍历，维护一个当前最大值（初始化为<code>LONG_MIN</code>），在中序部分判断当前节点是否小于这个最大值，如果小于等于，则说明当前节点之前有比当前节点更大或等于当前值的节点，这是不符合条件的，返回假。</p><p>其他情况返回真。</p><p>因为本题目保证了root是非空的，所以第一个root的判断返回false&#x2F;true可以根据算法自行选择。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">long</span> maxNum = LONG_MIN;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isValidBST</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">nullptr</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">bool</span> retLeft = <span class="built_in">isValidBST</span>(root-&gt;left);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(root-&gt;val &lt;= maxNum)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            maxNum = root-&gt;val;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="type">bool</span> retRight = <span class="built_in">isValidBST</span>(root-&gt;right);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> retLeft &amp;&amp; retRight;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/03/7def55fee335595ab04630b5e4be6416.png" alt="image-20240318105739796"></p><p>这个算法还是会有一个问题，即二层搜索树中可能会存在本来就等于<code>LONG_MIN</code>的节点，此时会直接返回false，不符合预期。所以应该把maxNum初始化为二叉树中左下角的那个节点的值，来保证无论如何都可以遍历成功，避免我们选用的初始值对算法结果的影响。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    TreeNode* prev = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isValidBST</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">nullptr</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">bool</span> retLeft = <span class="built_in">isValidBST</span>(root-&gt;left);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(prev != <span class="literal">nullptr</span> &amp;&amp; root-&gt;val &lt;= prev-&gt;val)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            prev = root;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="type">bool</span> retRight = <span class="built_in">isValidBST</span>(root-&gt;right);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> retLeft &amp;&amp; retRight;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/03/55533a22daa18eeb746d2d6cf3d913a8.png" alt="image-20240318110020250"></p><h2 id="530-二叉搜索树的最小绝对差"><a href="#530-二叉搜索树的最小绝对差" class="headerlink" title="530 二叉搜索树的最小绝对差"></a>530 二叉搜索树的最小绝对差</h2><blockquote><p><a href="https://leetcode.cn/problems/minimum-absolute-difference-in-bst/">530. 二叉搜索树的最小绝对差</a></p></blockquote><p>给你一个二叉搜索树的根节点 <code>root</code> ，返回 <strong>树中任意两不同节点值之间的最小差值</strong> 。</p><p>差值是一个正数，其数值等于两值之差的绝对值。</p><hr><p>因为题目给的是搜索二叉树，还是和前两题类似，利用中序遍历的有序序列，计算两个相邻节点之间的差值，<strong>差值的最小值只可能是在两个相邻节点之间</strong>。这就好比给你一个有序的<strong>单调递增的数组</strong>，让你返回这个数组中任意两个数的最小差值一样。</p><p>同样，可以用中序遍历将搜索二叉树转为数组再进行处理，具体代码参考上题（一模一样的转化再遍历），这里给出直接用中序遍历递归实现的的算法，思路是维护一个当前节点的<strong>前一个节点的指针</strong>，并依次计算两个相邻节点之间的差值。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> minDiff = INT_MAX;</span><br><span class="line">    TreeNode* prev = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="type">void</span> _getMinimumDifference(TreeNode* root)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">nullptr</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 遍历左侧</span></span><br><span class="line">        _getMinimumDifference(root-&gt;left);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 计算差值</span></span><br><span class="line">        <span class="keyword">if</span>(prev != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">            minDiff = <span class="built_in">min</span>(minDiff,root-&gt;val - prev-&gt;val);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 所有情况都需要更新prev</span></span><br><span class="line">        prev = root;</span><br><span class="line">      </span><br><span class="line">        <span class="comment">// 遍历右侧</span></span><br><span class="line">        _getMinimumDifference(root-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getMinimumDifference</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        _getMinimumDifference(root);</span><br><span class="line">        <span class="keyword">return</span> minDiff;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/03/a214d88159622e177076e223f43e6e95.png" alt="image-20240318143728984"></p><p>使用迭代，利用中序遍历的迭代思路也能解决这道题，这里主要是要记住怎么使用栈进行中序遍历。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getMinimumDifference</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">nullptr</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        stack&lt;TreeNode*&gt; st;</span><br><span class="line"></span><br><span class="line">        TreeNode* prev = <span class="literal">nullptr</span>;</span><br><span class="line">        TreeNode* cur = root;</span><br><span class="line">        <span class="type">int</span> ret = INT_MAX; <span class="comment">// 最小差值</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 两个条件符合都不符合才停止循环</span></span><br><span class="line">        <span class="keyword">while</span>(cur != <span class="literal">nullptr</span> || !st.<span class="built_in">empty</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(cur != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">                st.<span class="built_in">push</span>(cur);</span><br><span class="line">                cur = cur-&gt;left; <span class="comment">// 左</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123; <span class="comment">// 往左一直走到空了</span></span><br><span class="line">                cur = st.<span class="built_in">top</span>(); <span class="comment">// 父亲节点</span></span><br><span class="line">                st.<span class="built_in">pop</span>();</span><br><span class="line">                <span class="comment">// 中序处理，计算最小值</span></span><br><span class="line">                <span class="keyword">if</span>(prev != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">                    ret = <span class="built_in">min</span>(ret,cur-&gt;val - prev-&gt;val);</span><br><span class="line">                &#125;</span><br><span class="line">                prev = cur;</span><br><span class="line">                <span class="comment">// 右</span></span><br><span class="line">                cur = cur-&gt;right;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/03/eb41ec52f3f08a6acd2f547b9604ae29.png" alt="image-20240318144644478"></p><h2 id="501-二叉搜索树中的众数"><a href="#501-二叉搜索树中的众数" class="headerlink" title="501 二叉搜索树中的众数"></a>501 二叉搜索树中的众数</h2><blockquote><p><a href="https://leetcode.cn/problems/find-mode-in-binary-search-tree/">501. 二叉搜索树中的众数</a></p></blockquote><p>给你一个含重复值的二叉搜索树（BST）的根节点 <code>root</code> ，找出并返回 BST 中的所有 <a href="https://baike.baidu.com/item/%E4%BC%97%E6%95%B0/44796">众数</a>（即，出现频率最高的元素）。</p><p>如果树中有不止一个众数，可以按 <strong>任意顺序</strong> 返回。</p><p>假定 BST 满足如下定义：</p><ul><li>结点左子树中所含节点的值 <strong>小于等于</strong> 当前节点的值</li><li>结点右子树中所含节点的值 <strong>大于等于</strong> 当前节点的值</li><li>左子树和右子树都是二叉搜索树</li></ul><hr><p>这道题首先可以按任何二叉树来操作，即遍历整棵树，用map记录某个节点出现的频率，最终将出现频率最高的几个数取出来。</p><p>注意，这里不能一上来就直接用优先级队列，因为优先级队列是没有办法修改某个值的。可以用map统计完后再用优先级队列来排序。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="comment">// 因为只是遍历统计，所以用什么顺序遍历都没有区别</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">inorderTravel</span><span class="params">(TreeNode* root,unordered_map&lt;<span class="type">int</span>,<span class="type">int</span>&gt;&amp; countMap)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">nullptr</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">inorderTravel</span>(root-&gt;left,countMap);</span><br><span class="line">        countMap[root-&gt;val]++;</span><br><span class="line">        <span class="built_in">inorderTravel</span>(root-&gt;right,countMap);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">MyCmp</span>&#123;</span><br><span class="line">    <span class="keyword">public</span>: <span class="comment">// 别忘了设置为公有</span></span><br><span class="line">        <span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">const</span> pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt;&amp; p1, <span class="type">const</span> pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt;&amp; p2)</span></span>&#123;</span><br><span class="line">            <span class="keyword">return</span> p1.second &lt; p2.second; <span class="comment">// 使用小于建立大堆</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">findMode</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; retV;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">nullptr</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> retV;</span><br><span class="line">        &#125;</span><br><span class="line">        unordered_map&lt;<span class="type">int</span>,<span class="type">int</span>&gt; countMap;</span><br><span class="line">        <span class="built_in">inorderTravel</span>(root,countMap);</span><br><span class="line">        <span class="comment">// 使用优先级队列来初始化值</span></span><br><span class="line">        priority_queue&lt;pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt;,vector&lt;pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt;&gt;,MyCmp&gt; <span class="built_in">que</span>(countMap.<span class="built_in">begin</span>(),countMap.<span class="built_in">end</span>());</span><br><span class="line">        <span class="comment">// 取出头部计数器相同的，插入数组</span></span><br><span class="line">        <span class="keyword">auto</span> curPair = que.<span class="built_in">top</span>();</span><br><span class="line">        que.<span class="built_in">pop</span>();</span><br><span class="line">        retV.<span class="built_in">push_back</span>(curPair.first);</span><br><span class="line">        <span class="comment">// 只要队列不为空就继续操作</span></span><br><span class="line">        <span class="keyword">while</span>(!que.<span class="built_in">empty</span>())&#123;</span><br><span class="line">            <span class="comment">// 当当前计数和刚刚插入的一致，则继续插入</span></span><br><span class="line">            <span class="keyword">if</span>(curPair.second == que.<span class="built_in">top</span>().second)&#123;</span><br><span class="line">                curPair = que.<span class="built_in">top</span>();</span><br><span class="line">                que.<span class="built_in">pop</span>();</span><br><span class="line">                retV.<span class="built_in">push_back</span>(curPair.first);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">break</span>; <span class="comment">// 不符合条件，跳出</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> retV;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/03/7add75ede3a5bb148a880b6f8b545578.png" alt="image-20240318150300783"></p><p>不过本题是一个搜索二叉树，解题方法肯定不同。还是那个性质，搜索二叉树的中序遍历结果是有序的，那么我们就可以通过这个有序来遍历计算当前数字出现的频率。同样是维护一个prev指针指向上一个节点，并对连续相同的数进行计数。</p><p>当遇到第一个不相同的节点时，清空计数器，将上一个节点插入返回值数组，重新开始计数。如果新的这个数字的数量大于上一个数字，那么就将返回值数组清空（因为此时返回值数组中的元素是无效的），重新按这个新的count计算众数。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="type">int</span> maxCount = <span class="number">-1</span>; <span class="comment">// 计数器肯定是正的，初始化为负数即可</span></span><br><span class="line">    <span class="type">int</span> count = <span class="number">0</span>; <span class="comment">// 这里不能用count作为参数，因为每一层的修改对全局都是有效的</span></span><br><span class="line">    TreeNode* prev = <span class="literal">nullptr</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">inordereTravelCount</span><span class="params">(TreeNode* root,vector&lt;<span class="type">int</span>&gt;&amp; retV)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">nullptr</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 左</span></span><br><span class="line">        <span class="built_in">inordereTravelCount</span>(root-&gt;left,retV);</span><br><span class="line">        <span class="comment">// 中，计数</span></span><br><span class="line">        <span class="keyword">if</span>(prev == <span class="literal">nullptr</span>)<span class="comment">// 第一个节点</span></span><br><span class="line">        &#123;</span><br><span class="line">            count = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(prev-&gt;val == root-&gt;val) <span class="comment">// 相同</span></span><br><span class="line">        &#123;</span><br><span class="line">            count++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="comment">// 不相同，新的节点</span></span><br><span class="line">        &#123;</span><br><span class="line">            count = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        prev = root;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 和当前记录最大值相同，插入        </span></span><br><span class="line">        <span class="keyword">if</span>(count == maxCount)</span><br><span class="line">        &#123;</span><br><span class="line">            retV.<span class="built_in">push_back</span>(root-&gt;val);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 超过了最大记录，需要清空返回值数组</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(count &gt; maxCount)&#123;</span><br><span class="line">            maxCount = count;</span><br><span class="line">            retV.<span class="built_in">clear</span>();</span><br><span class="line">            retV.<span class="built_in">push_back</span>(root-&gt;val);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">inordereTravelCount</span>(root-&gt;right,retV);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">findMode</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; retV;</span><br><span class="line">        <span class="built_in">inordereTravelCount</span>(root,retV);</span><br><span class="line">        <span class="keyword">return</span> retV;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/03/493f11bd2c3022a88ee7307d30d5932b.png" alt="image-20240318151918601"></p><h2 id="236-二叉树的最近公共祖先"><a href="#236-二叉树的最近公共祖先" class="headerlink" title="236 二叉树的最近公共祖先"></a>236 二叉树的最近公共祖先</h2><blockquote><p><a href="https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-tree/">236. 二叉树的最近公共祖先</a></p></blockquote><p>给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。</p><p><a href="https://baike.baidu.com/item/%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88/8918834?fr=aladdin">百度百科</a>中最近公共祖先的定义为：“对于有根树 T 的两个节点 p、q，最近公共祖先表示为一个节点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（<strong>一个节点也可以是它自己的祖先</strong>）。”</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">示例 1：</span><br><span class="line">输入：root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 1</span><br><span class="line">输出：3</span><br><span class="line">解释：节点 5 和节点 1 的最近公共祖先是节点 3 。</span><br><span class="line"></span><br><span class="line">示例 2：</span><br><span class="line">输入：root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 4</span><br><span class="line">输出：5</span><br><span class="line">解释：节点 5 和节点 4 的最近公共祖先是节点 5 。因为根据定义最近公共祖先节点可以为节点本身。</span><br><span class="line"></span><br><span class="line">示例 3：</span><br><span class="line">输入：root = [1,2], p = 1, q = 2</span><br><span class="line">输出：1</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li>树中节点数目在范围 <code>[2, 105]</code> 内。</li><li><code>-109 &lt;= Node.val &lt;= 109</code></li><li>所有 <code>Node.val</code> <code>互不相同</code> 。</li><li><code>p != q</code></li><li><code>p</code> 和 <code>q</code> 均存在于给定的二叉树中。</li></ul><hr><p>首先要明确，root也可以是自己的公共祖先，所以root等于p或者等于q的情况也是符合条件的。本题需要我们从左右子树中找到p和q，然后再往上返回它的最近公共祖先，即从树的底部往上遍历。<strong>后序遍历</strong>（左右中）就是符合这个条件的。</p><p>下图中，带序号的线代表后序遍历的顺序，长虚线代表每一次的返回值。</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/03/11cc4daf0b5ecc01017d3515b944eb39.png" alt="image-20240318190309074"></p><p>整体思路如下：</p><ul><li>判断root是否等于q&#x2F;p，或者root为空，此时返回root；</li><li>递归判断左侧和右侧，记录返回值</li><li>如果左侧和右侧返回值都不为空，则代表当前节点就是最近的公共祖先节点，返回root节点（当前节点）；</li><li>如果左侧和右侧有一个为空，则返回不为空的那一个；</li><li>如果左侧和右侧都为空，则返回空（代表当前节点的子树中没有找到q和p）；</li></ul><p>代码如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">lowestCommonAncestor</span><span class="params">(TreeNode* root, TreeNode* p, TreeNode* q)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// root也可以是它自己的祖先</span></span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">nullptr</span> || root == p || root == q)&#123;</span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 用后序遍历的思路来处理，这样能找到当前节点的孩子里面有么有q或者p</span></span><br><span class="line">        TreeNode* left = <span class="built_in">lowestCommonAncestor</span>(root-&gt;left, p,  q);</span><br><span class="line">        TreeNode* right = <span class="built_in">lowestCommonAncestor</span>(root-&gt;right, p,  q);</span><br><span class="line">        <span class="comment">// 如果左右都不为空，则代表root就是最近的公共祖先</span></span><br><span class="line">        <span class="keyword">if</span>(left != <span class="literal">nullptr</span> &amp;&amp; right != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// // // 如果两个都为空，代表没有找到，返回空</span></span><br><span class="line">        <span class="comment">// if(left == nullptr &amp;&amp; right == nullptr)&#123;</span></span><br><span class="line">        <span class="comment">//     return nullptr;</span></span><br><span class="line">        <span class="comment">// &#125;</span></span><br><span class="line">        <span class="comment">// // 如果有一个为空，则返回另外一个</span></span><br><span class="line">        <span class="comment">// if(left != nullptr &amp;&amp; right == nullptr)&#123;</span></span><br><span class="line">        <span class="comment">//     return left;</span></span><br><span class="line">        <span class="comment">// &#125;</span></span><br><span class="line">        <span class="comment">// if(left == nullptr &amp;&amp; right != nullptr)&#123;</span></span><br><span class="line">        <span class="comment">//     return right;</span></span><br><span class="line">        <span class="comment">// &#125;</span></span><br><span class="line">        <span class="comment">// return nullptr; // 这里的返回没有意义，因为不会走到这里来</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 上面的三个判断可以精简成下面这个</span></span><br><span class="line">        <span class="comment">// 如果left为空且right也为空的时候，本来就需要返回nullptr，此时返回right也是一样的</span></span><br><span class="line">        <span class="keyword">return</span> left != <span class="literal">nullptr</span> ? left : right;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/03/3fbff287842a54bdb60b89c6ded43521.png" alt="image-20240318184443461"></p><h2 id="235-二叉搜索树的最近公共祖先"><a href="#235-二叉搜索树的最近公共祖先" class="headerlink" title="235 二叉搜索树的最近公共祖先"></a>235 二叉搜索树的最近公共祖先</h2><blockquote><p><a href="https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-search-tree/">235. 二叉搜索树的最近公共祖先</a></p></blockquote><p>给定一个二叉搜索树, 找到该树中两个指定节点的最近公共祖先。</p><p><a href="https://baike.baidu.com/item/%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88/8918834?fr=aladdin">百度百科</a>中最近公共祖先的定义为：“对于有根树 T 的两个结点 p、q，最近公共祖先表示为一个结点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（<strong>一个节点也可以是它自己的祖先</strong>）。”</p><hr><p>本题和上一题要求一致，但树是搜索二叉树。利用这个特性，给定q和p的公共祖先的值肯定在<code>[q, p]</code>范围区间之间（注意q和p没有说明谁更大，所以要判断<code>q&lt;cur&lt; p</code>和<code>p&lt;cur&lt;q</code>的两种情况），找公共祖先，只需要从上往下，找到第一个值符合这个区间范围的节点就可以了。</p><ul><li>搜索二叉树的左侧小于当前节点，右侧大于当前节点；</li><li>从上往下遍历（用前序遍历），此时先处理的是中间节点，那么第一个找到的符合<code>[q,p]</code>区间的节点就是最近的公共祖先，此时往左还是往右都会错过；</li></ul><p>如下所示，找1和8节点的公共祖先（即5），此时如果往左走到3，就会错过8的祖先，往右走到9，就会错过1的公共祖先</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/03/ed75ee6553efc114dccd290d96603fc2.png" alt="image-20240318192043482"></p><p>理解思路了，代码就不难写了，前序遍历的二叉搜索代码就可以了。因为这是搜索二叉树，不需要递归也能实现。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">lowestCommonAncestor</span><span class="params">(TreeNode* root, TreeNode* p, TreeNode* q)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">nullptr</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        TreeNode* cur = root;</span><br><span class="line">        <span class="comment">// 找到q和p中的最小值</span></span><br><span class="line">        <span class="type">int</span> min = q-&gt;val,max = p-&gt;val;</span><br><span class="line">        <span class="keyword">if</span>(min &gt; max)&#123;</span><br><span class="line">            min = max;</span><br><span class="line">            max = q-&gt;val;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(cur != <span class="literal">nullptr</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 符合条件</span></span><br><span class="line">            <span class="keyword">if</span>(cur-&gt;val &gt;= min &amp;&amp; cur-&gt;val &lt;= max)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> cur;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 如果大了，就往左走</span></span><br><span class="line">            <span class="keyword">if</span>(cur-&gt;val &gt; max)&#123;</span><br><span class="line">                cur = cur-&gt;left;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 小了就往右边走</span></span><br><span class="line">            <span class="keyword">if</span>(cur-&gt;val &lt; min)&#123;</span><br><span class="line">                cur = cur-&gt;right;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/03/38160fcf06b8e269687f27e24468d03d.png" alt="image-20240318192653511"></p><h2 id="701-二叉搜索树中的插入操作"><a href="#701-二叉搜索树中的插入操作" class="headerlink" title="701 二叉搜索树中的插入操作"></a>701 二叉搜索树中的插入操作</h2><blockquote><p><a href="https://leetcode.cn/problems/insert-into-a-binary-search-tree/">701. 二叉搜索树中的插入操作</a></p></blockquote><p>给定二叉搜索树（BST）的根节点 <code>root</code> 和要插入树中的值 <code>value</code> ，将值插入二叉搜索树。 返回插入后二叉搜索树的根节点。 输入数据 <strong>保证</strong> ，新值和原始二叉搜索树中的任意节点值都不同。</p><p><strong>注意</strong>，可能存在多种有效的插入方式，只要树在插入后仍保持为二叉搜索树即可。 你可以返回 <strong>任意有效的结果</strong> 。</p><hr><p>这道题没有那么难，因为题目要求的是二叉搜索树，并不是平衡二叉搜索树，所以不存在需要翻转的情况。我们只需要找到这个新节点应该存放的位置，将其链接进去就行了。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">insertIntoBST</span><span class="params">(TreeNode* root, <span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">        TreeNode* newNode = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(val);</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">nullptr</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> newNode;</span><br><span class="line">        &#125;</span><br><span class="line">        TreeNode* cur = root;</span><br><span class="line">        TreeNode* prev = root;</span><br><span class="line">        <span class="keyword">while</span>(cur != <span class="literal">nullptr</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(cur-&gt;val &gt; val)&#123;</span><br><span class="line">                prev = cur;</span><br><span class="line">                cur = cur-&gt;left;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(cur-&gt;val &lt; val)&#123;</span><br><span class="line">                prev = cur;</span><br><span class="line">                cur = cur-&gt;right;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 走到对应位置了</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 上一个节点肯定是叶子节点</span></span><br><span class="line">        <span class="comment">// 当前节点值更大，是左侧</span></span><br><span class="line">        <span class="keyword">if</span>(prev-&gt;val &gt; val)&#123;</span><br><span class="line">            prev-&gt;left = newNode;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 当前节点值更小，所以是右侧</span></span><br><span class="line">        <span class="keyword">if</span>(prev-&gt;val &lt; val)&#123;</span><br><span class="line">            prev-&gt;right = newNode;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/03/535f71322ea3e7dc4ffbab1b94c9d509.png" alt="image-20240318193613367"></p><h2 id="450-删除二叉搜索树中的节点"><a href="#450-删除二叉搜索树中的节点" class="headerlink" title="450 删除二叉搜索树中的节点"></a>450 删除二叉搜索树中的节点</h2><blockquote><p><a href="https://leetcode.cn/problems/delete-node-in-a-bst/">450. 删除二叉搜索树中的节点</a></p></blockquote><p>给定一个二叉搜索树的根节点 <strong>root</strong> 和一个值 <strong>key</strong>，删除二叉搜索树中的 <strong>key</strong> 对应的节点，并保证二叉搜索树的性质不变。返回二叉搜索树（有可能被更新）的根节点的引用。</p><p>一般来说，删除节点可分为两个步骤：</p><ol><li>首先找到需要删除的节点；</li><li>如果找到了，删除它。</li></ol><p><strong>提示:</strong></p><ul><li>节点数的范围 <code>[0, 104]</code></li><li><code>-105 &lt;= Node.val &lt;= 105</code></li><li>节点值唯一</li><li><code>root</code> 是合法的二叉搜索树</li><li><code>-105 &lt;= key &lt;= 105</code></li></ul><hr><p>删除搜索二叉树中的节点需要判断当前的情况</p><ul><li>没找到需要删除的节点，直接返回；</li><li>当前节点是叶子节点，将父节点的指针改成nullptr，delete该节点即可；</li><li>当前节点左侧节点为空，右侧不为空，将右侧节点记录，父节点的指针改成右侧节点，删除当前节点；</li><li>当前节点右侧节点为空，左侧不为空，将左侧节点记录，父节点的指针改成左侧节点，删除当前节点；</li><li>当前节点左侧右侧都不为空，将当前节点的<strong>左侧</strong>移动至<strong>右侧的最左节点</strong>，</li></ul><p>这里最难处理的是最后一种情况，见下图，红色是要被删除的节点5，绿色是该节点的左子树，蓝色是该节点的右子树。我们需要将5节点的左子树3移动到它的右子树的最左侧节点（即移动到6的位置）链接上。</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/03/692196a8807952e769421990232060e8.png" alt="image-20240318200430007"></p><p>因为是二叉搜索树，所以不需要用递归，循环找节点就行了。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"></span><br><span class="line">    <span class="function">TreeNode* <span class="title">deleteOneNode</span><span class="params">(TreeNode* target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (target == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> target;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 右侧为空，无论如何都返回左侧</span></span><br><span class="line">        <span class="keyword">if</span> (target-&gt;right == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> target-&gt;left;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 右侧不为空，统一处理，找到右子树的最左侧节点，进行链接</span></span><br><span class="line">        TreeNode* cur = target-&gt;right;</span><br><span class="line">        <span class="keyword">while</span> (cur-&gt;left != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            cur = cur-&gt;left;</span><br><span class="line">        &#125;</span><br><span class="line">        cur-&gt;left = target-&gt;left;</span><br><span class="line">        <span class="keyword">return</span> target-&gt;right;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">deleteNode</span><span class="params">(TreeNode* root, <span class="type">int</span> key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        &#125;</span><br><span class="line">        TreeNode* cur = root;</span><br><span class="line">        TreeNode* pre = <span class="literal">nullptr</span>; <span class="comment">// 记录cur的父节点，用来删除cur</span></span><br><span class="line">        <span class="keyword">while</span> (cur != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (cur-&gt;val == key) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            pre = cur;</span><br><span class="line">            <span class="keyword">if</span> (cur-&gt;val &gt; key) &#123;</span><br><span class="line">                cur = cur-&gt;left;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                cur = cur-&gt;right;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (pre == <span class="literal">nullptr</span>) &#123; <span class="comment">// 如果搜索树只有头结点</span></span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">deleteOneNode</span>(cur);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 判断删左孩子还是右孩子</span></span><br><span class="line">        <span class="keyword">if</span> (pre-&gt;left != <span class="literal">nullptr</span> &amp;&amp; pre-&gt;left == cur) &#123;</span><br><span class="line">            pre-&gt;left = <span class="built_in">deleteOneNode</span>(cur);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (pre-&gt;right != <span class="literal">nullptr</span> &amp;&amp; pre-&gt;right == cur) &#123;</span><br><span class="line">            pre-&gt;right = <span class="built_in">deleteOneNode</span>(cur);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/03/c59158ebd922e21fcd72d0df02c3d4d0.png" alt="image-20240319105711618"></p><h2 id="669-修建二叉搜索树"><a href="#669-修建二叉搜索树" class="headerlink" title="669 修建二叉搜索树"></a>669 修建二叉搜索树</h2><blockquote><p><a href="https://leetcode.cn/problems/trim-a-binary-search-tree/">669. 修剪二叉搜索树</a></p></blockquote><p>给你二叉搜索树的根节点 <code>root</code> ，同时给定最小边界<code>low</code> 和最大边界 <code>high</code>。通过修剪二叉搜索树，使得所有节点的值在<code>[low, high]</code>中。修剪树 <strong>不应该</strong> 改变保留在树中的元素的相对结构 (即，如果没有被移除，原有的父代子代关系都应当保留)。 可以证明，存在 <strong>唯一的答案</strong> 。</p><p>所以结果应当返回修剪好的二叉搜索树的新的根节点。注意，根节点可能会根据给定的边界发生改变。</p><hr><p>这里使用递归的方式来处理节点，通过返回值来将需要删除的节点排除掉。</p><ul><li>空节点，返回（递归末端条件）；</li><li>如果当前节点小于目标区间，则往右侧找并返回（这就相当于删除了当前节点）；</li><li>如果当前节点大于目标区间，则往左侧找并返回（这就相当于删除了当前节点）；</li><li>如果当前节点符合目标区间，则递归遍历左子树和右子树，并重新赋值新的左子树和右子树；</li></ul><p>其中最后一步是比较重要的，当前节点符合条件后，它的左侧和右侧可能会有不在区间内的节点，所以在递归遍历的同时，需要更新当前节点的左右子树指针，来接受递归后<strong>剔除了不符合条件节点</strong>的树。</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/03/9915c8d233479e5891444fd29a9d1898.png" alt="image-20240319122027435"></p><p>主要是理解如何通过递归的返回值来巧妙的“删除”不符合条件的节点。以上图的树为例，给定区间<code>[2,4]</code>，需要删除的节点是0和1。过程如下</p><ul><li>3符合条件，递归遍历左子树和右子树</li><li>右子树的4符合条件，递归遍历左子树和右子树（都为空，直接返回，相当于对4的节点没有做修改），最终返回4节点，赋值给3节点的right（也相当于没有修改）</li><li>左子树的0不符合条件（小于边界最小值），递归遍历右子树；</li><li>右子树的2符合条件，递归遍历左子树和右子树（2的右子树是空，直接返回）；</li><li>2的左子树1不符合条件（小于边界最小值），递归遍历右子树，此时1的右子树为空，相当于遍历1的这一次也是返回nullptr，并赋值给了2节点的right，相当于删除了节点1；</li><li>此时递归返回，2号节点往上返回（即遍历到0的那一次会返回2号节点），赋值给了3号节点的right，相当于删除了节点0。</li></ul><p>代码如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    TreeNode* _trimBST(TreeNode* root, <span class="type">const</span> <span class="type">int</span> low,<span class="type">const</span> <span class="type">int</span> high) &#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">nullptr</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 注意题目给出的是闭区间，所以这里超出的情况不包括=的情况</span></span><br><span class="line">        <span class="comment">// 如果当前节点值不在区间内，则往右边/左边找是否有符合条件的</span></span><br><span class="line">        <span class="comment">// 如果有则会正常返回符合条件的节点（也相当于通过返回值把当前节点删掉了）</span></span><br><span class="line">        <span class="keyword">if</span>(root-&gt;val &lt; low)&#123;</span><br><span class="line">            <span class="keyword">return</span> _trimBST(root-&gt;right,low,high);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;val &gt; high)&#123;</span><br><span class="line">            <span class="keyword">return</span> _trimBST(root-&gt;left,low,high);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 当前root的值符合范围，递归左子树和右子树，剔除不符合条件的节点</span></span><br><span class="line">        root-&gt;left = _trimBST(root-&gt;left,low,high);</span><br><span class="line">        root-&gt;right = _trimBST(root-&gt;right,low,high);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">trimBST</span><span class="params">(TreeNode* root, <span class="type">int</span> low, <span class="type">int</span> high)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">nullptr</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> _trimBST(root,low,high);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/03/d182dfe0db490518d670dbdb30fea46f.png" alt="image-20240319121234419"></p><h2 id="108-将有序数组转为二叉搜索树"><a href="#108-将有序数组转为二叉搜索树" class="headerlink" title="108 将有序数组转为二叉搜索树"></a>108 将有序数组转为二叉搜索树</h2><blockquote><p><a href="https://leetcode.cn/problems/convert-sorted-array-to-binary-search-tree/">108. 将有序数组转换为二叉搜索树</a></p></blockquote><p>给你一个整数数组 <code>nums</code> ，其中元素已经按 <strong>升序</strong> 排列，请你将其转换为一棵 平衡 二叉搜索树。</p><hr><p>这道题其实没有想象中的那么难，因为题目给的数组是有序的，我们只需要通过<strong>前序遍历</strong>加上拆分数组，最终构建出来的树肯定会是一个平衡的二叉搜索树。</p><p>在上文中的<code>654 最大二叉树</code>中已经使用了拆分数组构建树的方式，那道题是需要找到数组中的最大点。本题的平衡二叉搜索树需要找到<strong>有序数组的中间节点</strong>（即当前的众位树）作为根。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    TreeNode* _sortedArrayToBST(<span class="type">const</span> vector&lt;<span class="type">int</span>&gt;&amp; nums,<span class="type">int</span> left,<span class="type">int</span> right) &#123;</span><br><span class="line">        <span class="keyword">if</span>(left &gt;= right)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> mid = left + ((right - left)/<span class="number">2</span>); </span><br><span class="line">        </span><br><span class="line">        <span class="comment">// int mid = (right - left)/2; // 这样计算的结果是错误的，值可能会小于left，导致陷入死循环</span></span><br><span class="line"></span><br><span class="line">        TreeNode* root = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(nums[mid]);</span><br><span class="line">        root-&gt;left = _sortedArrayToBST(nums,left,mid);</span><br><span class="line">        root-&gt;right = _sortedArrayToBST(nums,mid+<span class="number">1</span>,right);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">sortedArrayToBST</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums.<span class="built_in">size</span>() == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> _sortedArrayToBST(nums,<span class="number">0</span>,nums.<span class="built_in">size</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/03/ad9482d397c93fc97210bb4b8bba543a.png" alt="image-20240319124522237"></p><p>如果使用迭代法，需要三个队列，一个存放节点，一个存放左区间，一个存放右区间。以下代码来自<a href="https://www.programmercarl.com/0108.%E5%B0%86%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E8%BD%AC%E6%8D%A2%E4%B8%BA%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91.html#%E6%80%9D%E8%B7%AF">代码随想录</a>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">sortedArrayToBST</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (nums.<span class="built_in">size</span>() == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">        TreeNode* root = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(<span class="number">0</span>);   <span class="comment">// 初始根节点</span></span><br><span class="line">        queue&lt;TreeNode*&gt; nodeQue;           <span class="comment">// 放遍历的节点</span></span><br><span class="line">        queue&lt;<span class="type">int</span>&gt; leftQue;                 <span class="comment">// 保存左区间下标</span></span><br><span class="line">        queue&lt;<span class="type">int</span>&gt; rightQue;                <span class="comment">// 保存右区间下标</span></span><br><span class="line">        nodeQue.<span class="built_in">push</span>(root);                 <span class="comment">// 根节点入队列</span></span><br><span class="line">        leftQue.<span class="built_in">push</span>(<span class="number">0</span>);                    <span class="comment">// 0为左区间下标初始位置</span></span><br><span class="line">        rightQue.<span class="built_in">push</span>(nums.<span class="built_in">size</span>() - <span class="number">1</span>);     <span class="comment">// nums.size() - 1为右区间下标初始位置</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (!nodeQue.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            TreeNode* curNode = nodeQue.<span class="built_in">front</span>();</span><br><span class="line">            nodeQue.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="type">int</span> left = leftQue.<span class="built_in">front</span>(); leftQue.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="type">int</span> right = rightQue.<span class="built_in">front</span>(); rightQue.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="type">int</span> mid = left + ((right - left) / <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">            curNode-&gt;val = nums[mid];       <span class="comment">// 将mid对应的元素给中间节点</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (left &lt;= mid - <span class="number">1</span>) &#123;          <span class="comment">// 处理左区间</span></span><br><span class="line">                curNode-&gt;left = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(<span class="number">0</span>);</span><br><span class="line">                nodeQue.<span class="built_in">push</span>(curNode-&gt;left);</span><br><span class="line">                leftQue.<span class="built_in">push</span>(left);</span><br><span class="line">                rightQue.<span class="built_in">push</span>(mid - <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (right &gt;= mid + <span class="number">1</span>) &#123;         <span class="comment">// 处理右区间</span></span><br><span class="line">                curNode-&gt;right = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(<span class="number">0</span>);</span><br><span class="line">                nodeQue.<span class="built_in">push</span>(curNode-&gt;right);</span><br><span class="line">                leftQue.<span class="built_in">push</span>(mid + <span class="number">1</span>);</span><br><span class="line">                rightQue.<span class="built_in">push</span>(right);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="538-把二叉搜索树转为累加树"><a href="#538-把二叉搜索树转为累加树" class="headerlink" title="538 把二叉搜索树转为累加树"></a>538 把二叉搜索树转为累加树</h2><blockquote><p><a href="https://leetcode.cn/problems/convert-bst-to-greater-tree/">538. 把二叉搜索树转换为累加树</a></p></blockquote><p>给出二叉 <strong>搜索</strong> 树的根节点，该树的节点值各不相同，请你将其转换为累加树（Greater Sum Tree），使每个节点 <code>node</code> 的新值等于原树中大于或等于 <code>node.val</code> 的值之和。</p><p>提醒一下，二叉搜索树满足下列约束条件：</p><ul><li>节点的左子树仅包含键 <strong>小于</strong> 节点键的节点。</li><li>节点的右子树仅包含键 <strong>大于</strong> 节点键的节点。</li><li>左右子树也必须是二叉搜索树。</li></ul><p><strong>注意：</strong>本题和 1038: <a href="https://leetcode-cn.com/problems/binary-search-tree-to-greater-sum-tree/">https://leetcode-cn.com/problems/binary-search-tree-to-greater-sum-tree/</a> 相同</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/03/7ef89c321b9f619dfccde873ccd90f9c.png" alt="image-20240319124844008"></p><p>题目要求的是将每个节点的值转为它和它右侧的节点的和。用数组可能更好理解一些，即将当前数组下标位置的<strong>值改为它和它右侧的节点的和</strong>。</p><p>所以可以从右侧往左侧遍历这个数组，记录一个求和值，并将当前数组的值加上这个求和值就行了。比如数组<code>[15,24,30]</code>的结果是<code>[68,54,30]</code>；</p><p>对于二叉树也是一样的，从右侧往左侧遍历，顺序是<code>右中左</code>，把中序遍历的代码改一下顺序就行了。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="type">int</span> sum  = <span class="number">0</span>;</span><br><span class="line">    TreeNode* _convertBST(TreeNode* root) &#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">nullptr</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        &#125;</span><br><span class="line">        _convertBST(root-&gt;right);</span><br><span class="line">        sum += root-&gt;val;</span><br><span class="line">        root-&gt;val = sum;</span><br><span class="line">        _convertBST(root-&gt;left);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">convertBST</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">nullptr</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> _convertBST(root);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/03/60fa23c99471735c788fe0f350bac25d.png" alt="image-20240319183019626"></p><p>如果要用迭代法，同样是中序遍历的迭代模板，将左右子树遍历的顺序修改一下就可以了。以下代码来自代码随想录</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> pre; <span class="comment">// 记录前一个节点的数值</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">traversal</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        stack&lt;TreeNode*&gt; st;</span><br><span class="line">        TreeNode* cur = root;</span><br><span class="line">        <span class="keyword">while</span> (cur != <span class="literal">NULL</span> || !st.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (cur != <span class="literal">NULL</span>) &#123;</span><br><span class="line">                st.<span class="built_in">push</span>(cur);</span><br><span class="line">                cur = cur-&gt;right;   <span class="comment">// 右</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                cur = st.<span class="built_in">top</span>();     <span class="comment">// 中</span></span><br><span class="line">                st.<span class="built_in">pop</span>();</span><br><span class="line">                cur-&gt;val += pre;</span><br><span class="line">                pre = cur-&gt;val;</span><br><span class="line">                cur = cur-&gt;left;    <span class="comment">// 左</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">convertBST</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        pre = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">traversal</span>(root);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="3-递归函数什么时候需要返回值？"><a href="#3-递归函数什么时候需要返回值？" class="headerlink" title="3.递归函数什么时候需要返回值？"></a>3.递归函数什么时候需要返回值？</h1><blockquote><p>以下总结来自代码随想录</p></blockquote><p>递归函数什么时候需要返回值？什么时候不需要返回值？这里总结如下三点：</p><ul><li>如果需要搜索整棵二叉树且不用处理递归返回值，递归函数就不要返回值。（题目113路径总和2）</li><li>如果需要搜索整棵二叉树且需要处理递归返回值，递归函数就需要返回值。 （题目236二叉树的最近公共祖先）</li><li>如果要搜索其中一条符合条件的路径，那么递归一定需要返回值，因为遇到符合条件的路径了就要及时返回。（题目112路径总和）</li></ul><h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>本篇刷题笔记到这里就结束啦，如果对涉及到的题目有什么不懂的地方，可以在评论区提出哦！</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2023/02/202204161703532.png" alt="image-20220416170310498"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;本文首发于&lt;code&gt;2022-04-20&lt;/code&gt;，2024年重新刷题，对本文做了较大更新，所以重新发布。&lt;/p&gt;
&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;上篇博客我带</summary>
      
    
    
    
    <category term="编程学习" scheme="https://blog.musnow.top/categories/%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="数据结构" scheme="https://blog.musnow.top/categories/%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
    <category term="C语言" scheme="https://blog.musnow.top/tags/C%E8%AF%AD%E8%A8%80/"/>
    
    <category term="数据结构" scheme="https://blog.musnow.top/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    <category term="OJ刷题" scheme="https://blog.musnow.top/tags/OJ%E5%88%B7%E9%A2%98/"/>
    
    <category term="树" scheme="https://blog.musnow.top/tags/%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>【leetcode】239滑动窗口最大值</title>
    <link href="https://blog.musnow.top/posts/2402466745/"/>
    <id>https://blog.musnow.top/posts/2402466745/</id>
    <published>2024-03-14T01:05:54.000Z</published>
    <updated>2024-03-14T11:09:01.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p><a href="https://leetcode.cn/problems/sliding-window-maximum/description/">239. 滑动窗口最大值 - 力扣（LeetCode）</a></p><p>给你一个整数数组 nums，有一个大小为 k 的滑动窗口从数组的最左侧移动到数组的最右侧。你只可以看到在滑动窗口内的 k 个数字。滑动窗口每次只向右移动一位。</p><p>返回 滑动窗口中的最大值 。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">示例 1：</span><br><span class="line">输入：nums = [1,3,-1,-3,5,3,6,7], k = 3</span><br><span class="line">输出：[3,3,5,5,6,7]</span><br><span class="line">解释：</span><br><span class="line">滑动窗口的位置                最大值</span><br><span class="line">---------------               -----</span><br><span class="line">[1  3  -1] -3  5  3  6  7       3</span><br><span class="line"> 1 [3  -1  -3] 5  3  6  7       3</span><br><span class="line"> 1  3 [-1  -3  5] 3  6  7       5</span><br><span class="line"> 1  3  -1 [-3  5  3] 6  7       5</span><br><span class="line"> 1  3  -1  -3 [5  3  6] 7       6</span><br><span class="line"> 1  3  -1  -3  5 [3  6  7]      7</span><br><span class="line"></span><br><span class="line">示例 2：</span><br><span class="line">输入：nums = [1], k = 1</span><br><span class="line">输出：[1]</span><br></pre></td></tr></table></figure><p>提示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1 &lt;= nums.length &lt;= 105</span><br><span class="line">-104 &lt;= nums[i] &lt;= 104</span><br><span class="line">1 &lt;= k &lt;= nums.length</span><br></pre></td></tr></table></figure><h1 id="思路一"><a href="#思路一" class="headerlink" title="思路一"></a>思路一</h1><h2 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h2><p>我最初自己想的思路是，用一个队列来维护滑动窗口，并用一个当前最大值来记录滑动窗口内的最大值。每次滑动窗口满了（为k），都将这个最大值写入返回值数组中。</p><p>当滑动窗口左侧缩限的时候，判断被出队列的是否为最大值</p><ul><li>不是最大值，不用更新当前最大值；</li><li>是最大值，从队列剩余数据中选出一个新的当前最大值；</li></ul><p>这样就能维护出一个题目需要的数组。代码如下</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">maxSlidingWindow</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> curMax = INT32_MIN; <span class="comment">// 当前最大值</span></span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; retV; <span class="comment">//最大值返回数组</span></span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> size = <span class="number">0</span>;<span class="comment">// 当前队列长度</span></span><br><span class="line">        queue&lt;<span class="type">int</span>&gt; que;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span>&amp;e:nums)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 长度已经等于3了，需要出一个数字</span></span><br><span class="line">            <span class="keyword">if</span>(size == k)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="type">int</span> popNum = que.<span class="built_in">front</span>();</span><br><span class="line">                que.<span class="built_in">pop</span>();</span><br><span class="line">                size--;</span><br><span class="line">                <span class="comment">// 出队列的就是最大值，那需要从队列里面剩下的选出一个最大值</span></span><br><span class="line">                <span class="keyword">if</span>(popNum == curMax)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="type">int</span> count = size;</span><br><span class="line">                    curMax = que.<span class="built_in">front</span>(); <span class="comment">// 重置为队列开头值，避免无法匹配</span></span><br><span class="line">                    <span class="keyword">while</span>(count --)</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="comment">// 选最大值</span></span><br><span class="line">                        <span class="type">int</span> temp = que.<span class="built_in">front</span>();</span><br><span class="line">                        curMax = <span class="built_in">max</span>(curMax,temp);</span><br><span class="line">                        que.<span class="built_in">pop</span>();</span><br><span class="line">                        que.<span class="built_in">push</span>(temp); <span class="comment">// 再插回去</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 出队列的不是最大值，不用处理</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 长度小于3，需要入数字</span></span><br><span class="line">            <span class="keyword">if</span>(size &lt; k)</span><br><span class="line">            &#123;</span><br><span class="line">                curMax = <span class="built_in">max</span>(curMax,e);</span><br><span class="line">                que.<span class="built_in">push</span>(e);</span><br><span class="line">                size++;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 每次size等于3的时候都将最大值写入数组</span></span><br><span class="line">            <span class="keyword">if</span>(size == k)</span><br><span class="line">            &#123;</span><br><span class="line">                retV.<span class="built_in">push_back</span>(curMax);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 数量不足k个，最大值需要插入数组</span></span><br><span class="line">        <span class="keyword">if</span>(nums.<span class="built_in">size</span>() &lt; k)</span><br><span class="line">        &#123;</span><br><span class="line">            retV.<span class="built_in">push_back</span>(curMax);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> retV;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这个代码的时间复杂度是<code>O(N*K)</code>，因为最差情况视作每次都需要重新遍历队列，时间复杂度就很高了。但思路应该是没有问题的，通过了大部分测试用例，只不过在大测试用例中超时了，因为此时K很大，如果需要重新遍历对列找出第二个最大值，耗时会很高。</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/03/dbc1d566677a56a511bb37f3e9823663.png" alt="image.png"></p><p>当然，我想出了另外一个优化方案，就是对于这种大k的情况，维护一个队列中第二大的数据，就不需要遍历对列了。但这样很麻烦，且这个思路本身就已经不适合解这道题了，于是没有尝试。</p><h1 id="思路二"><a href="#思路二" class="headerlink" title="思路二"></a>思路二</h1><h2 id="说明-1"><a href="#说明-1" class="headerlink" title="说明"></a>说明</h2><p>思路二是<a href="https://www.programmercarl.com/0239.%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E6%9C%80%E5%A4%A7%E5%80%BC.html">代码随想录</a>上面的，使用一个单调递增&#x2F;递减对列来维护这个最大值。对于本题而言，使用单调递减序列更适合。</p><p>这个对列需要实现push&#x2F;pop&#x2F;front三个功能，其中front就是当前滑动窗口中的最大值：</p><ul><li>push：当<strong>当前值</strong>小于对列尾部值时，直接插入；大于时，出队列尾部数值，直到当前值小于队列尾部数值，插入；</li><li>pop：如果滑动窗口删除的数据和队头数据一致，出队头数据（因为这是一个需要被删除的最大值）；不一致则不做任何操作；</li><li>front：获取队头数据；</li></ul><p>注意，这个单调对列只是针对本体的需求来写的。本体只是需要滑动窗口中的最大值，对于对列而言并不需要维护滑动窗口中的所有元素，只需要维护几个递减的最大值就行了。</p><blockquote><p>本题也不能用堆来实现，因为堆只能删除堆顶元素，堆顶元素不一定是滑动窗口需要移除的元素。这会导致堆内元素和当前滑动窗口内的元素不对应，会出现问题。</p></blockquote><p>使用C++的deque数据结构就可以实现一个这样的对列。deque是stack&#x2F;queue默认的底层容器，stack&#x2F;queue在C++中是<strong>容器适配器</strong>（因为它们并不是直接实现的，而是借助其他容器实现的）。deque的特性让它支持队头队尾的插入删除操作。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 单调队列（从大到小）</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyQueue</span> </span><br><span class="line">&#123; </span><br><span class="line">deque&lt;<span class="type">int</span>&gt; que; <span class="comment">// 使用deque来实现单调队列</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 每次弹出的时候，比较当前要弹出的数值是否等于队列出口元素的数值，如果相等则弹出。</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">pop</span><span class="params">(<span class="type">int</span> value)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">    <span class="comment">// 先判断是否为空再判断是否相等</span></span><br><span class="line">        <span class="keyword">if</span> (!que.<span class="built_in">empty</span>() &amp;&amp; value == que.<span class="built_in">front</span>()) </span><br><span class="line">        &#123;</span><br><span class="line">            que.<span class="built_in">pop_front</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果push的数值大于入口元素的数值，那么就将队列后端的数值弹出，直到push的数值小于等于队列入口元素的数值为止。</span></span><br><span class="line">    <span class="comment">// 这样就保持了队列里的数值是单调从大到小的了。</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(<span class="type">int</span> value)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (!que.<span class="built_in">empty</span>() &amp;&amp; value &gt; que.<span class="built_in">back</span>()) </span><br><span class="line">        &#123;</span><br><span class="line">            que.<span class="built_in">pop_back</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        que.<span class="built_in">push_back</span>(value);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 查询当前队列里的最大值，直接返回队列前端就可以了。</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">front</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> que.<span class="built_in">front</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h2><p>有了这个单调递减的对列后，我们现在只需要将vector中的元素按K滑动窗口大小往对列输入就可以了。注意，删除元素的时候要删除当前滑动窗口第一个元素，再加入新元素。</p><p>第一次遍历后需要插入一次最大值是因为<strong>第二个循环可能不会进去</strong>，而且第二个循环中会先移动窗口再插入新的最大值，如果不提前插入第一个最大值，可能会漏掉。</p><p>另外，本体限定K不会大于数组的长度，所以第一个循环用K做边界是不会数组越界的。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="comment">// 单调队列（从大到小）</span></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">MyQueue</span> </span><br><span class="line">    &#123; </span><br><span class="line">        deque&lt;<span class="type">int</span>&gt; que; <span class="comment">// 使用deque来实现单调队列</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="comment">// 每次弹出的时候，比较当前要弹出的数值是否等于队列出口元素的数值，如果相等则弹出。</span></span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">pop</span><span class="params">(<span class="type">int</span> value)</span> </span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            <span class="comment">// 先判断是否为空再判断是否相等</span></span><br><span class="line">            <span class="keyword">if</span> (!que.<span class="built_in">empty</span>() &amp;&amp; value == que.<span class="built_in">front</span>()) </span><br><span class="line">            &#123;</span><br><span class="line">                que.<span class="built_in">pop_front</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果push的数值大于入口元素的数值，那么就将队列后端的数值弹出，直到push的数值小于等于队列入口元素的数值为止。</span></span><br><span class="line">        <span class="comment">// 这样就保持了队列里的数值是单调从大到小的了。</span></span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(<span class="type">int</span> value)</span> </span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            <span class="keyword">while</span> (!que.<span class="built_in">empty</span>() &amp;&amp; value &gt; que.<span class="built_in">back</span>()) </span><br><span class="line">            &#123;</span><br><span class="line">                que.<span class="built_in">pop_back</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            que.<span class="built_in">push_back</span>(value);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 查询当前队列里的最大值，直接返回队列前端就可以了。</span></span><br><span class="line">        <span class="function"><span class="type">int</span> <span class="title">front</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> que.<span class="built_in">front</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">maxSlidingWindow</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        MyQueue que;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; retV;</span><br><span class="line">        <span class="comment">// 先把数组前k个元素送入对列</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i =<span class="number">0</span>;i&lt;k;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            que.<span class="built_in">push</span>(nums[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 先把第一个最大值插入</span></span><br><span class="line">        retV.<span class="built_in">push_back</span>(que.<span class="built_in">front</span>());</span><br><span class="line">        <span class="comment">// 然后开始移动滑动窗口</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = k;i&lt;nums.<span class="built_in">size</span>();i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 当i == k 的时候删除0，符合题目条件，不需要修改其他地方的代码</span></span><br><span class="line">            que.<span class="built_in">pop</span>(nums[i - k]); <span class="comment">// 删除滑动窗口第一个元素</span></span><br><span class="line">            que.<span class="built_in">push</span>(nums[i]); <span class="comment">// 插入新元素</span></span><br><span class="line">            <span class="comment">// 插入最大值</span></span><br><span class="line">            retV.<span class="built_in">push_back</span>(que.<span class="built_in">front</span>());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> retV;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/03/30471dcac1c94c4b6abb659af91d11f7.png" alt="image.png"></p><h1 id="The-end"><a href="#The-end" class="headerlink" title="The end"></a>The end</h1><p>单调递增&#x2F;单调递减的对列思想还是第一次遇到，学到了。</p>]]></content>
    
    
    <summary type="html">leetcode239题，滑动窗口最大值</summary>
    
    
    
    <category term="编程学习" scheme="https://blog.musnow.top/categories/%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="把题目都给刷干净" scheme="https://blog.musnow.top/categories/%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0/%E6%8A%8A%E9%A2%98%E7%9B%AE%E9%83%BD%E7%BB%99%E5%88%B7%E5%B9%B2%E5%87%80/"/>
    
    
    <category term="队列" scheme="https://blog.musnow.top/tags/%E9%98%9F%E5%88%97/"/>
    
    <category term="leetcode" scheme="https://blog.musnow.top/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>【leetcode】150.逆波兰表达式求值，以及前缀中缀后缀的相互转换</title>
    <link href="https://blog.musnow.top/posts/3211822811/"/>
    <id>https://blog.musnow.top/posts/3211822811/</id>
    <published>2024-03-13T08:33:43.000Z</published>
    <updated>2024-03-31T04:09:02.000Z</updated>
    
    <content type="html"><![CDATA[<p>本文最初写作于2022-07-18，于近日大量更新，故重新发布。</p><h1 id="1-什么是前缀-x2F-中缀-x2F-后缀表达式？"><a href="#1-什么是前缀-x2F-中缀-x2F-后缀表达式？" class="headerlink" title="1. 什么是前缀&#x2F;中缀&#x2F;后缀表达式？"></a>1. 什么是前缀&#x2F;中缀&#x2F;后缀表达式？</h1><p>我们日常学习数学，使用的表达式就是中缀表达式</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1 + 2 * 3 / 2 - 5</span><br></pre></td></tr></table></figure><p><strong>前缀表达式就是将操作符放在操作数之前的表达式</strong>；中缀转前缀的方式是，先将中缀表达式按运算顺序加上括号，再将操作符移动到对应括号的前面，最后删除括号，就是前缀表达式</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">((1 + ((2 * 3) / 2)) - 5)</span><br><span class="line">- (+(1 / (*(2 3) 2))  5)</span><br><span class="line">- + 1 / * 2 3 2 5</span><br></pre></td></tr></table></figure><p><strong>后缀表达式就是将操作符放在操作数之前的表达式</strong>；同样是加括号，再将运算符移动到括号后，再去括号</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">((1 + ((2 * 3) / 2)) - 5)</span><br><span class="line">((1 ((2 3)* 2)/) + 5) - </span><br><span class="line">1 2 3 * 2 / + 5 - </span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/03/051e1603775a69a8cb8f557b8050812d.png" alt="img"></p><p>前缀表达式又称“波兰表达式”，后缀表达式为“逆波兰表达式”。</p><h1 id="2-表达式转换"><a href="#2-表达式转换" class="headerlink" title="2. 表达式转换"></a>2. 表达式转换</h1><h2 id="2-1-中缀转后缀"><a href="#2-1-中缀转后缀" class="headerlink" title="2.1. 中缀转后缀"></a>2.1. 中缀转后缀</h2><p>中缀表达式转换为后缀表达式的手工做法为：</p><p>按照运算符的优先级对所有的运算单位加括号。例： <code>((a/b) + (((c*d) - (e*f))/g))</code><br>把运算符号移动到对应括号的后面，然后去掉括号。例：<code>((ab)/ (((cd)*(ef)*)-g)/+</code>，去掉括号<code>ab/cd*ef*-g/+</code>；</p><p>以这个中缀表达式为例</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1 + 2 * 3 / 2 - 5</span><br></pre></td></tr></table></figure><p>我们都知道，运算顺序应该是先计算<code>2*3</code>然后在计算<code>6/2</code>，最后计算<code>1+3-5</code>得出结果<code>-1</code>；</p><p>因为<code>* /</code>操作符的优先级高于加减，这里就需要注意这种情况。我们需要用一个栈来存放操作符：</p><ul><li>遇到操作数的时候 <strong>先输出</strong> 到结果表达式中;</li><li>遇到操作符，和<strong>栈顶</strong>进行比较<ul><li>如果栈为空&#x2F;操作符优先级高于栈顶，入栈；</li><li>操作符优先级低于栈顶或和栈顶相同，出栈顶操作符；</li></ul></li><li>最后将栈中的操作符全部出栈，就可以获得后缀表达式；</li></ul><p>用上面这个思路走一遍，即为下面的情况（不知道这样写的大家能不能看明白）</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2023/02/202207181221808.jpg" alt="qq_pic_merged_1658118047047"></p><p>最终得到的结果如下，即需要的后缀表达式。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1 2 3 * 2 / + 5 -</span><br></pre></td></tr></table></figure><p>我们可以用下文提到的<strong>后缀表达式计算</strong>代码测试一下这个用例，得出的结果也是<code>-1</code>，正确！</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2023/02/202207181223795.png" alt="image-20220718122342759"></p><p>如果中缀表达式中带括号咋办？</p><ul><li>遇到操作数的时候 <strong>先输出</strong> 到结果表达式中;</li><li>遇到操作符，和<strong>栈顶</strong>进行比较<ul><li>如果栈为空&#x2F;操作符优先级高于栈顶，入栈；</li><li>操作符优先级低于栈顶或和栈顶相同，出栈顶操作符；</li></ul></li><li>如果是左括号<code>(</code>，正常入栈；</li><li>遇到右括号<code>)</code>，出栈内所有操作符，直到遇到对应左括号，注意，最终的输出后缀表达式中不需要添加左括号；</li><li>最后将栈中的操作符全部出栈，就可以获得后缀表达式；</li></ul><p>简单理解，左括号的优先级低于其他运算符，右括号的优先级高于其他运算符，就可以用前文提到的基本办法来处理带括号的中缀表达式了。</p><h2 id="2-2-中缀转前缀"><a href="#2-2-中缀转前缀" class="headerlink" title="2.2. 中缀转前缀"></a>2.2. 中缀转前缀</h2><p>首先设定一个操作符栈，<strong>从右到左</strong>顺序扫描整个中缀表达式</p><ul><li>如果是操作数，则直接归入<strong>最终表达式</strong>；</li><li>如果是操作符，则检测器是否是右括号，如果是右括号，则直接将其入栈；</li><li>如果是左括号，则将栈中的操作符依次弹栈，归入<strong>最终表达式</strong>，直至遇到右括号，将右括号弹栈，处理结束；</li><li>如果是其他操作符，则检测栈顶操作符的优先级与当前操作符的优先级关系，如果栈顶操作符优先级<strong>大于</strong>当前操作符的优先级，则弹栈，并归入<strong>最终表达式</strong>，直至栈顶操作符优先级小于等于当前操作符优先级，这时将当前操作符压栈。</li><li>当扫描完毕整个中缀表达式后，检测操作符栈是否为空，如果不为空，则依次将栈中操作符弹栈，归入<strong>最终表达式</strong>。</li><li>最后，将得出的<strong>最终表达式</strong>进行<strong>逆置</strong>，就得到中缀表达式对应的前缀表达式。</li></ul><p>以下面这个中缀表达式为例</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1 + 2 * 3 / 2 - 5</span><br></pre></td></tr></table></figure><p>使用上述步骤的栈操作示意图如下</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/03/01826c0b1143896defbabb4294308a3d.png" alt="image-20240313145529611"></p><p>得到的前缀表达式如下，符合前文使用加括号法得到的结果！</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- + 1 / * 2 3 2 5</span><br></pre></td></tr></table></figure><h2 id="2-3-后缀转中缀"><a href="#2-3-后缀转中缀" class="headerlink" title="2.3. 后缀转中缀"></a>2.3. 后缀转中缀</h2><p>后缀转中缀会简单一些，因为不需要考虑括号优先级的问题。参考 <a href="https://segmentfault.com/q/1010000004546083">知否</a>;</p><p>从左往右遍历后缀表达式：</p><ul><li>如果是操作数，入栈；</li><li>如果是运算符（设符号为#），从栈顶取两个元素a和b，注意<strong>先取出来的是右操作数</strong>，将<code>&quot;( b # a )&quot;</code>这个字符串入栈。这里加括号是保证运算顺序。</li></ul><p>最终栈顶的字符串就是我们需要的前缀表达式</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1 2 3 * 2 / + 5 - </span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/03/dfd35b63103a70940878c8534ecc05a0.png" alt="image-20240313154453407"></p><p>得到的中缀表达式符合预期！虽然会有多余的括号，但运算顺序是没有问题的。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1 + 2 * 3 / 2 - 5</span><br></pre></td></tr></table></figure><p>C++代码如下，设输入的后缀表达式是有效的。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function">string <span class="title">postfix_to_infix</span><span class="params">(vector&lt;string&gt; expr)</span> </span>&#123;</span><br><span class="line">    stack&lt;string&gt; s;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; expr.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">        <span class="comment">// a number</span></span><br><span class="line">        <span class="keyword">if</span> (!expr[i].<span class="built_in">empty</span>() &amp;&amp; expr[i][<span class="number">0</span>] &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; expr[i][<span class="number">0</span>] &lt;= <span class="string">&#x27;9&#x27;</span>) &#123;</span><br><span class="line">            s.<span class="built_in">push</span>(expr[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// an operator</span></span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            string second = s.<span class="built_in">top</span>(); s.<span class="built_in">pop</span>();</span><br><span class="line">            string first = s.<span class="built_in">top</span>(); s.<span class="built_in">pop</span>();</span><br><span class="line">            s.<span class="built_in">push</span>(<span class="string">&quot;(&quot;</span> + first + expr[i] + second + <span class="string">&quot;)&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> s.<span class="built_in">top</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    vector&lt;string&gt; expr = &#123;<span class="string">&quot;3&quot;</span>, <span class="string">&quot;2&quot;</span>, <span class="string">&quot;5&quot;</span>, <span class="string">&quot;-&quot;</span>, <span class="string">&quot;6&quot;</span>, <span class="string">&quot;*&quot;</span>, <span class="string">&quot;3&quot;</span>, <span class="string">&quot;/&quot;</span>, <span class="string">&quot;+&quot;</span>&#125;;</span><br><span class="line">    <span class="comment">// output: (3+(((2-5)*6)/3))</span></span><br><span class="line">    cout &lt;&lt; <span class="built_in">postfix_to_infix</span>(expr) &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-4-前缀转后缀"><a href="#2-4-前缀转后缀" class="headerlink" title="2.4. 前缀转后缀"></a>2.4. 前缀转后缀</h2><p>依照上述后缀转前缀的思路，前缀转后缀的操作如下</p><p>从<strong>右往左</strong>遍历后缀表达式：</p><ul><li>如果是操作数，入栈；</li><li>如果是运算符（设符号为#），从栈顶取两个元素a和b，注意先取出来的是左操作数，将<code>&quot;( a # b )&quot;</code>这个字符串入栈。这里加括号是保证运算顺序。</li></ul><p>这样运算就能得到中缀表达式。这里就不做演示了。</p><h2 id="2-5-前缀-x2F-后缀转换？"><a href="#2-5-前缀-x2F-后缀转换？" class="headerlink" title="2.5. 前缀&#x2F;后缀转换？"></a>2.5. 前缀&#x2F;后缀转换？</h2><p>因为已经学会了前缀转中缀，后缀转中缀的思路，前后缀的转换用中缀做个跳板就行了。面试的时候能说出思路来就够。</p><h1 id="3-逆波兰表达式求值"><a href="#3-逆波兰表达式求值" class="headerlink" title="3. 逆波兰表达式求值"></a>3. 逆波兰表达式求值</h1><h2 id="3-1-题目来源"><a href="#3-1-题目来源" class="headerlink" title="3.1. 题目来源"></a>3.1. 题目来源</h2><p>leetcode：<a href="https://leetcode.cn/problems/evaluate-reverse-polish-notation/">150. 逆波兰表达式求值</a></p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2023/02/202207181200929.png" alt="image-20220718120022828"></p><h2 id="3-2-思路"><a href="#3-2-思路" class="headerlink" title="3.2. 思路"></a>3.2. 思路</h2><p>逆波兰表达式又称为后缀表达式</p><ul><li>中缀 <code>1 + 2 * 3</code>；</li><li>后缀 <code>1 2 3 + *</code>；</li></ul><p>题目所给的参数是后缀表达式，其操作的思路如下：</p><ul><li>从左往右遍历，遇到操作数，入栈</li><li>遇到运算符，取栈顶两个连续数据进行计算（第二个取出来的是左操作数），再将计算结果入栈</li></ul><p>看起来不难，是因为这道题已经是简化后的版本，<del>其所给后缀表达式中没有出现括号这种特殊优先级的操作</del>。新注：这里理解有误，后缀&#x2F;前缀表达式本来就是从中缀按优先级转换过来的，它们是不会包含括号的！</p><h2 id="3-3-完整代码"><a href="#3-3-完整代码" class="headerlink" title="3.3. 完整代码"></a>3.3. 完整代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//https://leetcode.cn/problems/evaluate-reverse-polish-notation/submissions/</span></span><br><span class="line"><span class="comment">//150逆波兰表达式</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">evalRPN</span><span class="params">(vector&lt;string&gt;&amp; tokens)</span> </span>&#123;</span><br><span class="line">        stack&lt;<span class="type">int</span>&gt; s;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; ch : tokens)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(ch==<span class="string">&quot;+&quot;</span>||ch==<span class="string">&quot;-&quot;</span>||ch==<span class="string">&quot;*&quot;</span>||ch==<span class="string">&quot;/&quot;</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="type">int</span> right=s.<span class="built_in">top</span>();</span><br><span class="line">                s.<span class="built_in">pop</span>();</span><br><span class="line">                <span class="type">int</span> left=s.<span class="built_in">top</span>();</span><br><span class="line">                s.<span class="built_in">pop</span>();</span><br><span class="line">                <span class="keyword">switch</span>(ch[<span class="number">0</span>])</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">case</span> <span class="string">&#x27;+&#x27;</span>:</span><br><span class="line">                        s.<span class="built_in">push</span>(left+right);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">case</span> <span class="string">&#x27;-&#x27;</span>:</span><br><span class="line">                        s.<span class="built_in">push</span>(left-right);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">case</span> <span class="string">&#x27;*&#x27;</span>:</span><br><span class="line">                        s.<span class="built_in">push</span>(left*right);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">case</span> <span class="string">&#x27;/&#x27;</span>:</span><br><span class="line">                        s.<span class="built_in">push</span>(left/right);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">default</span>:</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="comment">// 注意，题目给的vector中是字符串，需要转数字</span></span><br><span class="line">                s.<span class="built_in">push</span>(<span class="built_in">stoi</span>(ch));</span><br><span class="line">            &#125;   </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s.<span class="built_in">top</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2023/02/202207181208425.png" alt="Snipaste_2022-07-18_11-20-17"></p><p>可以使用lambda表达式来改造这个oj的代码</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">evalRPN</span><span class="params">(vector&lt;string&gt;&amp; tokens)</span> </span>&#123;</span><br><span class="line">        stack&lt;<span class="type">int</span>&gt; s;</span><br><span class="line">        map&lt;string,function&lt;<span class="type">int</span>(<span class="type">int</span>,<span class="type">int</span>)&gt;&gt; FuncMap = &#123;</span><br><span class="line">            &#123;<span class="string">&quot;+&quot;</span>,[](<span class="type">int</span> x,<span class="type">int</span> y)&#123;<span class="keyword">return</span> x+y;&#125;&#125;,</span><br><span class="line">            &#123;<span class="string">&quot;-&quot;</span>,[](<span class="type">int</span> x,<span class="type">int</span> y)&#123;<span class="keyword">return</span> x-y;&#125;&#125;,</span><br><span class="line">            &#123;<span class="string">&quot;*&quot;</span>,[](<span class="type">int</span> x,<span class="type">int</span> y)&#123;<span class="keyword">return</span> x*y;&#125;&#125;,</span><br><span class="line">            &#123;<span class="string">&quot;/&quot;</span>,[](<span class="type">int</span> x,<span class="type">int</span> y)&#123;<span class="keyword">return</span> x/y;&#125;&#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; ch : tokens)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(ch==<span class="string">&quot;+&quot;</span>||ch==<span class="string">&quot;-&quot;</span>||ch==<span class="string">&quot;*&quot;</span>||ch==<span class="string">&quot;/&quot;</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="type">int</span> right=s.<span class="built_in">top</span>();</span><br><span class="line">                s.<span class="built_in">pop</span>();</span><br><span class="line">                <span class="type">int</span> left=s.<span class="built_in">top</span>();</span><br><span class="line">                s.<span class="built_in">pop</span>();</span><br><span class="line">                <span class="type">int</span> ret = FuncMap[ch](left,right);</span><br><span class="line">                s.<span class="built_in">push</span>(ret);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                s.<span class="built_in">push</span>(<span class="built_in">stoi</span>(ch));</span><br><span class="line">            &#125;   </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s.<span class="built_in">top</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="4-前缀表达式求值"><a href="#4-前缀表达式求值" class="headerlink" title="4. 前缀表达式求值"></a>4. 前缀表达式求值</h1><p>前缀表达式的计算方法和后缀基本一致。</p><ul><li>从右往左遍历，遇到操作数，入栈；</li><li>遇到操作符，从栈顶取出两个数字进行计算，第一个取出来的数字是左操作数。计算后重新入栈。</li></ul><p>还是以下面的前缀表达式为例</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- + 1 / * 2 3 2 5</span><br></pre></td></tr></table></figure><p>从右往左遍历入栈</p><ul><li>第一波操作后，栈中包括<code>2,3,2,5</code>；</li><li>随后遇到第一个操作符<code>*</code>，从栈取出2和3进行计算，得到6，重新入栈<code>6,2,5</code>；</li><li>遇到第二个操作符<code>/</code>，从栈取出6和2进行计算，得到3，重新入栈<code>3,5</code>；</li><li>操作数1入栈，<code>1,3,5</code>；</li><li>操作符<code>+</code>，从栈中取出1和3进行计算，得到4，入栈<code>4,5</code>；</li><li>操作符<code>-</code>，从栈中取出4和5进行计算，得到最终结果<code>-1</code>；</li></ul><p>这个前缀表达式对应的中缀如下，它的计算结果也是<code>-1</code>，处理正确！</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1 + 2 * 3 / 2 - 5 = -1</span><br></pre></td></tr></table></figure><p>和后缀表达式相比，前缀表达式只有遍历顺序不同，以及从栈取数据时左右操作数位置不同，所以只需要将遍历vector的操作改成<strong>反向迭代器</strong>就可以了。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 计算前缀表达式</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">evalPN</span><span class="params">(vector&lt;string&gt;&amp; tokens)</span> </span>&#123;</span><br><span class="line">    stack&lt;<span class="type">int</span>&gt; s;</span><br><span class="line">    map&lt;string,function&lt;<span class="type">int</span>(<span class="type">int</span>,<span class="type">int</span>)&gt;&gt; FuncMap = &#123;</span><br><span class="line">        &#123;<span class="string">&quot;+&quot;</span>,[](<span class="type">int</span> x,<span class="type">int</span> y)&#123;<span class="keyword">return</span> x+y;&#125;&#125;,</span><br><span class="line">        &#123;<span class="string">&quot;-&quot;</span>,[](<span class="type">int</span> x,<span class="type">int</span> y)&#123;<span class="keyword">return</span> x-y;&#125;&#125;,</span><br><span class="line">        &#123;<span class="string">&quot;*&quot;</span>,[](<span class="type">int</span> x,<span class="type">int</span> y)&#123;<span class="keyword">return</span> x*y;&#125;&#125;,</span><br><span class="line">        &#123;<span class="string">&quot;/&quot;</span>,[](<span class="type">int</span> x,<span class="type">int</span> y)&#123;<span class="keyword">return</span> x/y;&#125;&#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">auto</span> riter = tokens.<span class="built_in">rbegin</span>();</span><br><span class="line">    <span class="keyword">for</span>(;riter != tokens.<span class="built_in">rend</span>();riter++)</span><br><span class="line">    &#123;</span><br><span class="line">        string ch = *riter;</span><br><span class="line">        <span class="keyword">if</span>(ch==<span class="string">&quot;+&quot;</span>||ch==<span class="string">&quot;-&quot;</span>||ch==<span class="string">&quot;*&quot;</span>||ch==<span class="string">&quot;/&quot;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 前缀表达式第一个取出来的是左操作数</span></span><br><span class="line">            <span class="type">int</span> left=s.<span class="built_in">top</span>();</span><br><span class="line">            s.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="type">int</span> right=s.<span class="built_in">top</span>();</span><br><span class="line">            s.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="type">int</span> ret = FuncMap[ch](left,right);</span><br><span class="line">            s.<span class="built_in">push</span>(ret);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            s.<span class="built_in">push</span>(<span class="built_in">stoi</span>(ch));</span><br><span class="line">        &#125;   </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> s.<span class="built_in">top</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用表达式进行测试，得到正确输出</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vector&lt;string&gt; v = &#123;<span class="string">&quot;-&quot;</span>,<span class="string">&quot;+&quot;</span>,<span class="string">&quot;1&quot;</span>,<span class="string">&quot;/&quot;</span>,<span class="string">&quot;*&quot;</span>,<span class="string">&quot;2&quot;</span>,<span class="string">&quot;3&quot;</span>,<span class="string">&quot;2&quot;</span> ,<span class="string">&quot;5&quot;</span>&#125;;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">evalPN</span>(v) &lt;&lt; <span class="string">&quot;\n&quot;</span>; <span class="comment">// 输出 -1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="5-The-end"><a href="#5-The-end" class="headerlink" title="5. The end"></a>5. The end</h1><p>网易雷火的面试考到了前缀表达式求值，故此更新本文</p>]]></content>
    
    
    <summary type="html">leetcode150题逆波兰表达式求值，以及前缀中缀后缀的解释和相互转换</summary>
    
    
    
    <category term="编程学习" scheme="https://blog.musnow.top/categories/%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="把题目都给刷干净" scheme="https://blog.musnow.top/categories/%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0/%E6%8A%8A%E9%A2%98%E7%9B%AE%E9%83%BD%E7%BB%99%E5%88%B7%E5%B9%B2%E5%87%80/"/>
    
    
    <category term="OJ刷题" scheme="https://blog.musnow.top/tags/OJ%E5%88%B7%E9%A2%98/"/>
    
    <category term="Cpp" scheme="https://blog.musnow.top/tags/Cpp/"/>
    
    <category term="leetcode" scheme="https://blog.musnow.top/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>【算法】滑动窗口思想解决数组OJ题目</title>
    <link href="https://blog.musnow.top/posts/19524588/"/>
    <id>https://blog.musnow.top/posts/19524588/</id>
    <published>2024-03-12T04:29:19.000Z</published>
    <updated>2024-03-27T00:59:45.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="基本思路"><a href="#基本思路" class="headerlink" title="基本思路"></a>基本思路</h1><p>滑动窗口在很多地方都有实际使用，比如TCP的发送缓冲区就使用了这个思想来维护。</p><p>对于数组相关的算法OJ题来说，滑动窗口思路主要是基于双指针来实现的，一个作为窗口的左边界，一个作为窗口的右边界，并根据题目的条件来移动左右边界。</p><h1 id="题目1-209-长度最小的子数组"><a href="#题目1-209-长度最小的子数组" class="headerlink" title="题目1-209-长度最小的子数组"></a>题目1-209-长度最小的子数组</h1><p>第一题是leetcode的209，<a href="https://leetcode.cn/problems/minimum-size-subarray-sum/description/">209. 长度最小的子数组 - 力扣（LeetCode）</a>，这也是滑动窗口的一个基础且经典的题目。</p><h2 id="题干"><a href="#题干" class="headerlink" title="题干"></a>题干</h2><p>给定一个含有 n 个正整数的数组和一个正整数 target 。</p><p>找出该数组中满足其总和大于等于 target 的长度最小的 <strong>连续</strong><br>子数组 <code>[numsl, numsl+1, ..., numsr-1, numsr]</code> ，并返回其长度。如果不存在符合条件的子数组，返回 0 。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">示例 1：</span><br><span class="line">输入：target = 7, nums = [2,3,1,2,4,3]</span><br><span class="line">输出：2</span><br><span class="line">解释：子数组 [4,3] 是该条件下的长度最小的子数组。</span><br><span class="line"></span><br><span class="line">示例 2：</span><br><span class="line">输入：target = 4, nums = [1,4,4]</span><br><span class="line">输出：1</span><br><span class="line"></span><br><span class="line">示例 3：</span><br><span class="line">输入：target = 11, nums = [1,1,1,1,1,1,1,1]</span><br><span class="line">输出：0</span><br></pre></td></tr></table></figure><p>进阶：如果你已经实现 <code>O(n)</code> 时间复杂度的解法, 请尝试设计一个 <code>O(n * log(n))</code> 时间复杂度的解法。</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>这道题要求的是数组中加起来大于等于target的最小连续子数组。最简单的办法是暴力两次遍历来计算每一个子数组组合的和，再与目标target对比，但这样的时间复杂度是<code>O(N^2)</code>。</p><p>使用滑动窗口来解决这道题才是对的，思路如下。</p><ol><li>left和right作为滑动窗口的左右边界，以right作为for循环的自增；</li><li>right++遍历一个数（滑动窗口扩张），加入到sum中；</li><li>如果sum大于等于target，记录<code>right-left+1</code>为当前子数组长度，开始操作left；</li><li>left++遍历一个数（滑动窗口缩限），将其从sum中删除；</li><li>再次判断sum是否大于等于target，如果大于，继续执行第三部和第四步；</li><li>sum不大于target了，停止操作left，继续for循环操作right，移动右边边界；</li><li>right大于等于下标，循环结束。</li></ol><p>最终得到的len就是最短的子数组。</p><p>注意，操作left的时候要用while循环，而不是用if来操作，因为最终可能会遇到，right固定在数组的最后一位，<strong>但left还能继续往前走的情况</strong>。如果使用if，那么每个循环中left都最多只能走一次，会漏掉这种情况。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>对于这类问题，可以用打印下标的方式进行调试。最终测试的时候记得把打印注释掉，因为它们很耗时，可能会导致你的答案超时。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">minSubArrayLen</span><span class="params">(<span class="type">int</span> target, vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> left = <span class="number">0</span>,right=<span class="number">0</span>; <span class="comment">// 滑动窗口</span></span><br><span class="line">        <span class="type">int</span> minRange = INT32_MAX; <span class="comment">// 因为需要获取最小值，所以要用一个最大值来比较</span></span><br><span class="line">        <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(right =<span class="number">0</span>;right&lt;nums.<span class="built_in">size</span>();right++)</span><br><span class="line">        &#123;</span><br><span class="line">            sum += nums[right];</span><br><span class="line">            <span class="keyword">while</span>(sum &gt;= target) <span class="comment">// 这里必须要用while，需要考虑right是最后一个但left还可以继续走的情况</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//cout &lt;&lt; &quot;fix: &quot; &lt;&lt; left &lt;&lt; &quot; - &quot; &lt;&lt; right &lt;&lt; &quot; sum:&quot; &lt;&lt; sum &lt;&lt; &quot;\n&quot;;</span></span><br><span class="line">                <span class="type">int</span> curDiff = right - left + <span class="number">1</span>; <span class="comment">// 当前长度</span></span><br><span class="line">                minRange = <span class="built_in">min</span>(minRange,curDiff);</span><br><span class="line">                sum -= nums[left];</span><br><span class="line">                left ++;<span class="comment">// 左侧缩限</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//cout &lt;&lt; &quot;all: &quot; &lt;&lt; left &lt;&lt; &quot; - &quot; &lt;&lt; right &lt;&lt; &quot; sum:&quot; &lt;&lt; sum &lt;&lt; &quot;\n&quot;;</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果还是最大值，则返回0</span></span><br><span class="line">        <span class="keyword">return</span> minRange == INT32_MAX ? <span class="number">0</span> : minRange;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>说明一下，leetcode&#x2F;牛客网上的代码击败人数是没有参考意义的，这个时间和你的网络状况也有关系。我的题解博客中贴出代码通过截图，是想告诉未来的读者，这个代码在我测试的时候是通过的，以免未来leetcode测试用例变化无法通过时产生误解。</p><blockquote><p>好不容易搜到一个题解，结果它贴了无法通过的代码，谁看了不气？🤣</p></blockquote><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/03/434871f83a804f052d952c3a2e5f9c89.png" alt="image.png"></p><h1 id="题目2-904-水果成篮"><a href="#题目2-904-水果成篮" class="headerlink" title="题目2-904-水果成篮"></a>题目2-904-水果成篮</h1><p><a href="https://leetcode.cn/problems/fruit-into-baskets/submissions/510977160/">904.水果成篮 - 力扣（LeetCode）</a></p><h2 id="题干-1"><a href="#题干-1" class="headerlink" title="题干"></a>题干</h2><p>你正在探访一家农场，农场从左到右种植了一排果树。这些树用一个整数数组 fruits 表示，其中 <code>fruits[i]</code> 是第 i 棵树上的水果 <strong>种类</strong> 。</p><p>你想要尽可能多地收集水果。然而，农场的主人设定了一些严格的规矩，你必须按照要求采摘水果：</p><ol><li>你只有 <strong>两个</strong> 篮子，并且每个篮子只能装 <strong>单一类型</strong> 的水果。每个篮子能够装的水果总量没有限制。</li><li>你可以选择任意一棵树开始采摘，你必须从 <strong>每棵</strong> 树（包括开始采摘的树）上 <strong>恰好摘一个水果</strong> 。采摘的水果应当符合篮子中的水果类型。每采摘一次，你将会向右移动到下一棵树，并继续采摘。</li><li>一旦你走到某棵树前，但水果不符合篮子的水果类型，那么就必须停止采摘。</li></ol><p>给你一个整数数组 fruits ，返回你可以收集的水果的 <strong>最大</strong> 数目。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">示例 1：</span><br><span class="line">输入：fruits = [1,2,1]</span><br><span class="line">输出：3</span><br><span class="line">解释：可以采摘全部 3 棵树。</span><br><span class="line"></span><br><span class="line">示例 2：</span><br><span class="line">输入：fruits = [0,1,2,2]</span><br><span class="line">输出：3</span><br><span class="line">解释：可以采摘 [1,2,2] 这三棵树。</span><br><span class="line">如果从第一棵树开始采摘，则只能采摘 [0,1] 这两棵树。</span><br><span class="line"></span><br><span class="line">示例 3：</span><br><span class="line">输入：fruits = [1,2,3,2,2]</span><br><span class="line">输出：4</span><br><span class="line">解释：可以采摘 [2,3,2,2] 这四棵树。</span><br><span class="line">如果从第一棵树开始采摘，则只能采摘 [1,2] 这两棵树。</span><br><span class="line"></span><br><span class="line">示例 4：</span><br><span class="line">输入：fruits = [3,3,3,1,2,1,1,2,3,3,4]</span><br><span class="line">输出：5</span><br><span class="line">解释：可以采摘 [1,2,1,1,2] 这五棵树。</span><br></pre></td></tr></table></figure><h2 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h2><p>刚开始我都没有读懂这个题目，注意，输入参数中的数组并非每棵树上有几个种类的水果，而是每棵树上的水果是<strong>第几类</strong>。比如<code>fruits[0] = 1</code>代表第0棵树上的水果是<strong>种类1</strong>，<code>fruits[1] = 2</code>代表第1棵树上的水果是<strong>种类2</strong>。</p><blockquote><p>我刚开始错误的理解为元素2代表这棵树上有两种不同的水果，如果这样理解这道题就没法写了……</p></blockquote><p>你的篮子里面一次只能装<strong>两个种类</strong>的水果，这样这道题就转变成了，给出的数组中只包含两个相同数字的最长子数组。</p><p>比如数组 <code>[3,3,3,1,2,1,1,2,3,3,4]</code>，最长只包含两个数字的子数组是 <code>[1,2,1,1,2]</code>；数组<code>[1,2,3,2,2]</code>最长只包含两个数字的子数组是<code>[3,2,2]</code>；</p><p>同样是用滑动窗口来解题，使用left&#x2F;right左右边界，right作为while循环条件，并设置一个数字种类计数器fruitsCount、数字个数计数器sizeCount和一个set来保存当前的两个数字。另外还需要一个maxSizeCount来保存最长的数字个数，作为题目返回值。</p><ol><li>right遍历，当 当前数字 不存在set中，且count小于2时，将其加入到set中，并将fruitsCount++，长度sizeCount++，使用sizeCount对比更新maxSizeCount；</li><li>当 当前数字 存在于set中，长度sizeCount++，使用sizeCount对比更新maxSizeCount；</li><li>当 当前数字 不存在于set中，且fruitsCount已经为2，说明当前走到了第三个数字的位置，重置set和fruitsCount，使用sizeCount对比更新maxSizeCount后，将sizeCount重置为0；</li><li>left++（滑动窗口左侧缩限），一直加加到和<strong>当前数字不同</strong>的位置（比如left当前处于<code>3,3,3,1,2</code>的3的位置，那么就需要移动到1的位置，过滤重复数据）；</li><li>right重置到left的位置，继续执行上述步骤，直到right走完数组。</li></ol><p>注意，每次sizeCount++之后，都需要和maxSizeCount对比并更新。否则如果给出的数组本来就只有两种数字（比如<code>[1,2,1]</code>这整个数组本身就是答案）的情况，maxSizeCount会没有正常更新。</p><h2 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h2><p>因为本题目的set并不需要排序，所以使用哈希set会优于红黑树的set。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">totalFruit</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; fruits)</span> </span>&#123;</span><br><span class="line">        unordered_set&lt;<span class="type">int</span>&gt; fruitsSet;</span><br><span class="line">        <span class="type">int</span> fruitsCount = <span class="number">0</span>; <span class="comment">// 种类数量</span></span><br><span class="line">        <span class="type">int</span> curCount = <span class="number">0</span>; <span class="comment">// 当前水果计数</span></span><br><span class="line">        <span class="type">int</span> retCount = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> left = <span class="number">0</span>,right = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(right &lt; fruits.<span class="built_in">size</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 水果不在里面，且还没有2个</span></span><br><span class="line">            <span class="keyword">if</span>(fruitsCount &lt; <span class="number">2</span> &amp;&amp; fruitsSet.<span class="built_in">count</span>(fruits[right]) == <span class="number">0</span>)&#123;</span><br><span class="line">                fruitsCount++; <span class="comment">// 种类数量加一</span></span><br><span class="line">                fruitsSet.<span class="built_in">insert</span>(fruits[right]);</span><br><span class="line">                curCount++; <span class="comment">// 水果个数加一</span></span><br><span class="line">                right++;</span><br><span class="line">                retCount = <span class="built_in">max</span>(curCount,retCount);</span><br><span class="line">                <span class="comment">// cout &lt;&lt; right &lt;&lt; &quot; - &quot; &lt;&lt; fruits[right] &lt;&lt; &quot;\n&quot;;</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 水果在里面</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(fruitsCount &lt;= <span class="number">2</span> &amp;&amp; fruitsSet.<span class="built_in">count</span>(fruits[right]) != <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                right++;</span><br><span class="line">                curCount++;</span><br><span class="line">                retCount = <span class="built_in">max</span>(curCount,retCount);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 水果不在里面，且已经有两个了</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(fruitsCount &gt;= <span class="number">2</span> &amp;&amp; fruitsSet.<span class="built_in">count</span>(fruits[right]) == <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                retCount = <span class="built_in">max</span>(curCount,retCount);</span><br><span class="line">                fruitsSet.<span class="built_in">clear</span>(); <span class="comment">// 清空</span></span><br><span class="line">                curCount = <span class="number">0</span>;</span><br><span class="line">                fruitsCount = <span class="number">0</span>;</span><br><span class="line">                <span class="comment">// 找下一个和left当前不同的水果</span></span><br><span class="line">                <span class="keyword">while</span>(left &lt; fruits.<span class="built_in">size</span>() &amp;&amp; fruits[left+<span class="number">1</span>] == fruits[left])&#123;</span><br><span class="line">                    left++;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 还需要再走一步，才是和刚刚不一样的水果</span></span><br><span class="line">                left++;</span><br><span class="line">                right = left; <span class="comment">// 重新开始新一轮计数</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> retCount;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/03/e71c0534a185be79be2606779f304890.png" alt="image.png"></p><h1 id="题目3-76-最小覆盖子串"><a href="#题目3-76-最小覆盖子串" class="headerlink" title="题目3-76-最小覆盖子串"></a>题目3-76-最小覆盖子串</h1><p><a href="https://leetcode.cn/problems/minimum-window-substring/description/">76. 最小覆盖子串 - 力扣（LeetCode）</a></p><h2 id="题干-2"><a href="#题干-2" class="headerlink" title="题干"></a>题干</h2><p>给你一个字符串 s 、一个字符串 t 。返回 s 中涵盖 t 所有字符的最小子串。如果 s 中不存在涵盖 t 所有字符的子串，则返回空字符串 <code>&quot;&quot;</code> 。 </p><p>注意：</p><ul><li>对于 t 中重复字符，我们寻找的子字符串中该字符数量必须不少于 t 中该字符数量。</li><li>如果 s 中存在这样的子串，我们保证它是唯一的答案。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">示例 1：</span><br><span class="line">输入：s = &quot;ADOBECODEBANC&quot;, t = &quot;ABC&quot;</span><br><span class="line">输出：&quot;BANC&quot;</span><br><span class="line">解释：最小覆盖子串 &quot;BANC&quot; 包含来自字符串 t 的 &#x27;A&#x27;、&#x27;B&#x27; 和 &#x27;C&#x27;。</span><br><span class="line"></span><br><span class="line">示例 2：</span><br><span class="line">输入：s = &quot;a&quot;, t = &quot;a&quot;</span><br><span class="line">输出：&quot;a&quot;</span><br><span class="line">解释：整个字符串 s 是最小覆盖子串。</span><br><span class="line"></span><br><span class="line">示例 3:</span><br><span class="line">输入: s = &quot;a&quot;, t = &quot;aa&quot;</span><br><span class="line">输出: &quot;&quot;</span><br><span class="line">解释: t 中两个字符 &#x27;a&#x27; 均应包含在 s 的子串中，</span><br><span class="line">因此没有符合条件的子字符串，返回空字符串。</span><br></pre></td></tr></table></figure><p>s 和 t 由英文字母组成，且可能会重复（未规定大小写）</p><h2 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h2><p>同样是使用滑动窗口，但这一次的缩限需要进行判断。</p><p>首先要明白题目给出的条件</p><ul><li>当t字符串长度大于s字符串的时候，直接返回空，因为s的子串无法包含t；</li><li>t中的字母可能是大写也可能是小写，而且t中的某个字母可能会重复，所以需要一个map来保存t字符串的字符及其个数；</li><li>题目要求返回的是子串，所以需要记录子串在s内的<strong>起始下标及其长度</strong>（使用substr函数来处理）；</li></ul><p>这里需要用到两个哈希map，一个tMaps用于存放t字符串中的所有字符和个数，另外一个curMaps用来存放当前<strong>滑动窗口内</strong>包含的t字符串内字符的个数。</p><ol><li>right++，当遇到t字符串内的字符，则将curMaps中对应字符数量加一；</li><li>检查curMaps中的字符个数是否都已经大于等于tMaps中的字符数量，且没有缺少字符；</li><li>如果符合条件，记录当前的left（作为子串起始位置）和长度len，随后left++开始缩限，并将curMaps中对应字符减一，直到curMaps不符合条件为止；</li><li>right继续加加，重复上述步骤，直到right越界。</li></ol><p>注意，这里建议将用于更新的子串起始地址begin初始化为非法下标<code>-1</code>，并在return的时候进行判断，这样能知道s字符串中是否存在符合条件的子串。如果begin在循环结束后还是<code>-1</code>，则代表s内没有符合条件的子串，此时返回空字符串。</p><h2 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 判断当前map中是否已经包含目标map中需要的所有字符</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">statusCheck</span><span class="params">(<span class="type">const</span> unordered_map&lt;<span class="type">char</span>,<span class="type">int</span>&gt;&amp; tMaps,unordered_map&lt;<span class="type">char</span>,<span class="type">int</span>&gt;&amp; curMaps)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span>&amp;e:tMaps)&#123;</span><br><span class="line">            <span class="comment">// 这里不能用不等于判断，因为curMaps中的计数器大于的时候也是符合条件的</span></span><br><span class="line">            <span class="keyword">if</span>(curMaps.<span class="built_in">count</span>(e.first)!=<span class="number">0</span> &amp;&amp; curMaps[e.first] &lt; e.second)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (curMaps.<span class="built_in">count</span>(e.first)==<span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">string <span class="title">minWindow</span><span class="params">(string s, string t)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(t.<span class="built_in">size</span>() &gt; s.<span class="built_in">size</span>())&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> left = <span class="number">0</span>,right = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> begin = <span class="number">-1</span>, end = <span class="number">-1</span>, len = INT32_MAX; <span class="comment">// 最终用于返回结果的下标区间</span></span><br><span class="line">        <span class="comment">// 记录t中每个字符出现的次数</span></span><br><span class="line">        unordered_map&lt;<span class="type">char</span>,<span class="type">int</span>&gt; tMaps;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span>&amp;e:t)&#123;</span><br><span class="line">            tMaps[e]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 当前出现的tmap中的字符的数量</span></span><br><span class="line">        unordered_map&lt;<span class="type">char</span>,<span class="type">int</span>&gt; curMaps;</span><br><span class="line">        <span class="keyword">while</span>(right &lt; s.<span class="built_in">size</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 如果目标map里面有，则在当前map里面将数量加一</span></span><br><span class="line">            <span class="keyword">if</span>(tMaps.<span class="built_in">count</span>(s[right]) !=<span class="number">0</span>)&#123;</span><br><span class="line">                curMaps[s[right]]++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 如果符合条件，则缩限到不能缩限为止</span></span><br><span class="line">            <span class="keyword">while</span>(<span class="built_in">statusCheck</span>(tMaps,curMaps) &amp;&amp; left &lt;=right)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// 如果长度小于当前记录的长度，则更新</span></span><br><span class="line">                <span class="keyword">if</span>(right - left + <span class="number">1</span> &lt; len)</span><br><span class="line">                &#123;</span><br><span class="line">                    len = right - left + <span class="number">1</span>;</span><br><span class="line">                    begin = left;</span><br><span class="line">                    end = right;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 在目标map里面看是否有这个字符，有则在当前map中将数量减一</span></span><br><span class="line">                <span class="keyword">if</span>(tMaps.<span class="built_in">count</span>(s[left]) !=<span class="number">0</span>)&#123;</span><br><span class="line">                    curMaps[s[left]]--;</span><br><span class="line">                &#125;</span><br><span class="line">                left++;</span><br><span class="line">            &#125;</span><br><span class="line">            right++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果begin没有被更新，则说明不存在</span></span><br><span class="line">        <span class="keyword">return</span> begin == <span class="number">-1</span> ? <span class="string">&quot;&quot;</span> : s.<span class="built_in">substr</span>(begin,len);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/03/f0da87219c6ebd2175cfdba9633791c5.png" alt="image.png"></p><h1 id="题目4-3-无重复字符的最长子串"><a href="#题目4-3-无重复字符的最长子串" class="headerlink" title="题目4-3-无重复字符的最长子串"></a>题目4-3-无重复字符的最长子串</h1><h2 id="题干-3"><a href="#题干-3" class="headerlink" title="题干"></a>题干</h2><blockquote><p><a href="https://leetcode.cn/problems/longest-substring-without-repeating-characters/description/">3. 无重复字符的最长子串</a></p></blockquote><p>给定一个字符串 s ，请你找出其中不含有重复字符的 最长子串 的长度。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">示例 1:</span><br><span class="line">输入: s = &quot;abcabcbb&quot;</span><br><span class="line">输出: 3 </span><br><span class="line">解释: 因为无重复字符的最长子串是 &quot;abc&quot;，所以其长度为 3。</span><br><span class="line"></span><br><span class="line">示例 2:</span><br><span class="line">输入: s = &quot;bbbbb&quot;</span><br><span class="line">输出: 1</span><br><span class="line">解释: 因为无重复字符的最长子串是 &quot;b&quot;，所以其长度为 1。</span><br><span class="line"></span><br><span class="line">示例 3:</span><br><span class="line">输入: s = &quot;pwwkew&quot;</span><br><span class="line">输出: 3</span><br><span class="line">解释: 因为无重复字符的最长子串是 &quot;wke&quot;，所以其长度为 3。</span><br><span class="line">     请注意，你的答案必须是 子串 的长度，&quot;pwke&quot; 是一个子序列，不是子串。</span><br></pre></td></tr></table></figure><p>提示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">0 &lt;= s.length &lt;= 5 * 104</span><br><span class="line">s 由英文字母、数字、符号和空格组成</span><br></pre></td></tr></table></figure><h2 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h2><p>同样是用滑动窗口，还需要用一个<code>unordered_set</code>来记录某个字符是否已经存在于窗口内了。用for循环来扩张right右边界，left左边界在情况不符合的时候再缩限：</p><ul><li>sets不存在<code>s[right]</code>字符，当前子串长度加一，并更新最大子串长度；</li><li>sets存在<code>s[right]</code>字符，left开始缩限：<ul><li>因为sets中存在这个字符，所以right之前肯定还有一个<code>s[right]</code>字符；</li><li>将<code>s[left]</code>的元素从sets中移除，直到left++走到上一个和<code>s[right]</code>相等的字符处；</li><li>循环终止时left走到上一个<code>s[right]</code>的位置，left再加一走到下一位，更新当前子串长度为<code>right-left+1</code>（这个长度肯定小于已有的最大子串长度，所以无需更新最大子串长度）;</li></ul></li><li>right继续加加，重复上述步骤。</li></ul><p>这里我还想到了可以用map代替set，这样就能直接找到上一个<code>s[right]</code>字符的位置，不需要用left++遍历找。但仔细想了想，这个思路是错误的，因为每一次left++还需要将当前从滑动窗口中移除的数自set中删除，如果用map直接跳到上一个left的地方，最终还是需要遍历来删除left原始值和新值之间的数，并不能提高效率。</p><h2 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s.<span class="built_in">size</span>() == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> maxLength = <span class="number">-1</span>;</span><br><span class="line">        <span class="type">int</span> curLength = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> left = <span class="number">0</span>,right = <span class="number">0</span>;</span><br><span class="line">        unordered_set&lt;<span class="type">char</span>&gt; sets;</span><br><span class="line">        <span class="keyword">for</span>(right = <span class="number">0</span>;right&lt;s.<span class="built_in">size</span>();right++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 找不到插入</span></span><br><span class="line">            <span class="keyword">if</span>(sets.<span class="built_in">count</span>(s[right]) == <span class="number">0</span>)&#123;</span><br><span class="line">                sets.<span class="built_in">insert</span>(s[right]);</span><br><span class="line">                curLength++;</span><br><span class="line">                maxLength = <span class="built_in">max</span>(maxLength,curLength);</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 找到了，左侧缩限到上一个s[right]的位置</span></span><br><span class="line">            <span class="keyword">while</span>(s[left] != s[right])</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// 每一次缩限都需要把字符从set删除</span></span><br><span class="line">                sets.<span class="built_in">erase</span>(s[left]);</span><br><span class="line">                left++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 走到了上一个s[right]，需要再走一次</span></span><br><span class="line">            left++;</span><br><span class="line">            curLength = right-left+<span class="number">1</span>;</span><br><span class="line">            <span class="comment">// 这里不需要修改sets，把原有的s[right]当作新插入的</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> maxLength;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/03/927e510a161fee254b574b0366281ac8.png" alt="image.png"></p><h1 id="The-end"><a href="#The-end" class="headerlink" title="The end"></a>The end</h1><p>滑动窗口方法同时也是双指针法的一个运用，这三道题目都囊括了这个方法，平时记得加以复习。</p>]]></content>
    
    
    <summary type="html">使用“滑动窗口”思想来解决一些数组的OJ题目</summary>
    
    
    
    <category term="编程学习" scheme="https://blog.musnow.top/categories/%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="把题目都给刷干净" scheme="https://blog.musnow.top/categories/%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0/%E6%8A%8A%E9%A2%98%E7%9B%AE%E9%83%BD%E7%BB%99%E5%88%B7%E5%B9%B2%E5%87%80/"/>
    
    
    <category term="数组" scheme="https://blog.musnow.top/tags/%E6%95%B0%E7%BB%84/"/>
    
    <category term="算法" scheme="https://blog.musnow.top/tags/%E7%AE%97%E6%B3%95/"/>
    
    <category term="leetcode" scheme="https://blog.musnow.top/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>【leetcode】16.最接近的三数之和</title>
    <link href="https://blog.musnow.top/posts/4003189051/"/>
    <id>https://blog.musnow.top/posts/4003189051/</id>
    <published>2024-03-10T08:27:23.000Z</published>
    <updated>2024-03-13T01:28:18.000Z</updated>
    
    <content type="html"><![CDATA[<p>这下真的得好好重头开始学算法了，基于《代码随想录》，今天周日的目标是完成<strong>哈希章节</strong>，并复习字符串章节和KMP算法。争取在四月中旬之前学完《代码随想录》里面的算法，欢迎大家监督我！</p><p><a href="https://gitee.com/musnows/LetsOJ">LetsOJ_多人刷题打卡: 这是一个多人OJ打卡仓库</a></p><p>新建了一个leetcode的进度，OJ刷题打卡仓库中的代码也重新归档。</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/03/2eadb6db523d970c34710e334ed2af18.png" alt="image.png"></p><p>注意：在手机上代码块中的下标位置会因为字体原因偏离，请使用电脑查看本博客。</p><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p><a href="https://leetcode.cn/problems/3sum-closest/">16. 最接近的三数之和 - 力扣（LeetCode）</a></p><p>给你一个长度为 n 的整数数组 nums 和 一个目标值 target。请你从 nums 中选出三个整数，使它们的和与 target 最接近。</p><p>返回这三个数的和。</p><p>假定每组输入只存在恰好一个解。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">示例 1：</span><br><span class="line">输入：nums = [-1,2,1,-4], target = 1</span><br><span class="line">输出：2</span><br><span class="line">解释：与 target 最接近的和是 2 (-1 + 2 + 1 = 2) 。</span><br><span class="line"></span><br><span class="line">示例 2：</span><br><span class="line">输入：nums = [0,0,0], target = 1</span><br><span class="line">输出：0</span><br></pre></td></tr></table></figure><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>这道题和15三数之和的思路很相似，15题中要求是三数和为0，这道题要求是和target越接近越好。其实就是在把目标值从0改成target，并将三数和为target改成接近target，中间会多一个记录差距数的操作。</p><p>使用排序+双指针来实现。排序后的数组已经有序，使用双指针的时候方便控制指针移动</p><ul><li>如果和大于target，则右侧指针–；</li><li>如果和小于target，则左侧指针++；</li></ul><p>这里还会涉及到一些优化，虽然题目中没有15题去重的要求，但跳过重复元素也能提高运行效率。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><h3 id="最简单的方法"><a href="#最简单的方法" class="headerlink" title="最简单的方法"></a>最简单的方法</h3><p>最简单的方式即<strong>不做任何去重</strong>，按照思路写代码就行。sum大于或者等于target的时候就让右侧指针减一，小于target的时候让左侧指针加一。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">threeSumClosest</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> retNum = INT_MAX; <span class="comment">// 差距值</span></span><br><span class="line">        <span class="type">int</span> retSum = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(),nums.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i&lt;nums.<span class="built_in">size</span>();i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> left = i+<span class="number">1</span>,right = nums.<span class="built_in">size</span>()<span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">while</span>(left &lt; right)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="type">int</span> sum = nums[i] + nums[left] + nums[right];</span><br><span class="line"><span class="comment">// 更新结果值</span></span><br><span class="line">                <span class="type">int</span> diff = <span class="built_in">abs</span>(target-sum);</span><br><span class="line">                <span class="keyword">if</span>(diff &lt; retNum)</span><br><span class="line">                &#123;</span><br><span class="line">                    retNum = diff;</span><br><span class="line">                    retSum = sum;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span>(sum &gt;= target)&#123;</span><br><span class="line">                    right --;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(sum &lt; target)&#123;</span><br><span class="line">                    left++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> retSum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这样也能通过</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/03/8cdda259da83a2ac2bdc1d2b5cdc8a84.png" alt="image.png"></p><h3 id="下标i去重"><a href="#下标i去重" class="headerlink" title="下标i去重"></a>下标i去重</h3><p>下标i去重的目的是让i不处理刚刚已经处理过的值。注意，和15题18题中的去重都是相同的思路，要先处理完毕某个值再去重。</p><p>如下所示，假设我们需要对<code>-1</code>这个元素去重（不重复处理），应该先正常对第一个<code>-1</code>进行操作，再让i跳过第二个<code>-1</code>走到2的位置进行下一步操作</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-3 -1 -1 2 3 4</span><br><span class="line">    i</span><br></pre></td></tr></table></figure><p>如果先去重，在三数之和中，假设target&#x3D;0，下面的情况就会被忽略。这里i已经走到了第二个<code>-1</code>的位置了，但<code>(-1) + (-1) +2 = 0</code> ，这种符合题意的结果就直接被跳过了。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 先去重的代码，错误！</span></span><br><span class="line"><span class="keyword">if</span>(nums[i] == nums[i+<span class="number">1</span>])</span><br><span class="line"><span class="keyword">continue</span>;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-3 -1 -1 2 3 4</span><br><span class="line">   i l   r</span><br></pre></td></tr></table></figure><p>如果我们不先执行去重，下标分布如下所示，右侧指针不断减，就能匹配上<code>-1 -1 2</code>这个三元组。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-3 -1 -1 2 3 4</span><br><span class="line">    i  l     r</span><br></pre></td></tr></table></figure><p>匹配上了之后再让i跳过第二个<code>-1</code>才是正确的。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 正确的去重代码</span></span><br><span class="line"><span class="keyword">if</span>(i&gt;<span class="number">0</span> &amp;&amp; nums[i] == nums[i<span class="number">-1</span>])<span class="comment">// 跳过刚刚已经处理过的相同值</span></span><br><span class="line"><span class="keyword">continue</span>;</span><br></pre></td></tr></table></figure><p>对于这道题，加上对i的去重后代码如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">threeSumClosest</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> retNum = INT_MAX; <span class="comment">// 差距值</span></span><br><span class="line">        <span class="type">int</span> retSum = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(),nums.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i&lt;nums.<span class="built_in">size</span>();i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 先匹配再去重</span></span><br><span class="line">            <span class="keyword">if</span>(i&gt;<span class="number">0</span> &amp;&amp; nums[i] == nums[i<span class="number">-1</span>])&#123;</span><br><span class="line">                <span class="keyword">continue</span>; </span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="type">int</span> left = i+<span class="number">1</span>,right = nums.<span class="built_in">size</span>()<span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">while</span>(left &lt; right)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="type">int</span> sum = nums[i] + nums[left] + nums[right];</span><br><span class="line">                <span class="comment">// 更新结果值</span></span><br><span class="line">                <span class="type">int</span> diff = <span class="built_in">abs</span>(target-sum);</span><br><span class="line">                <span class="keyword">if</span>(diff &lt; retNum)</span><br><span class="line">                &#123;</span><br><span class="line">                    retNum = diff;</span><br><span class="line">                    retSum = sum;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span>(sum &gt;= target)&#123;</span><br><span class="line">                    right --;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(sum &lt; target)&#123;</span><br><span class="line">                    left++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> retSum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/03/79d0779bb11dc8a284135570167f8402.png" alt="image.png"></p><h3 id="left-x2F-right去重"><a href="#left-x2F-right去重" class="headerlink" title="left&#x2F;right去重"></a>left&#x2F;right去重</h3><p>在15题三数之和的题解中会对left和right进行去重，同样是遵循先匹配再去重的操作。</p><p>假设当前指针位置如下，当前和为<code>5</code>，假设小于target，此时需要移动left指针</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-3 -1 -1 2 2 2 3 4</span><br><span class="line">    i    l       r</span><br></pre></td></tr></table></figure><p>那么left指针移动的时候，可以直接移动到最后一个2的位置，因为对于求和而言它们没有任何区别。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-3 -1 -1 2 2 2 3 4</span><br><span class="line">    i          l r</span><br></pre></td></tr></table></figure><p>代码如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">threeSumClosest</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> retNum = INT_MAX; <span class="comment">// 差距值</span></span><br><span class="line">        <span class="type">int</span> retSum = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(),nums.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i&lt;nums.<span class="built_in">size</span>();i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 先匹配再去重</span></span><br><span class="line">            <span class="keyword">if</span>(i&gt;<span class="number">0</span> &amp;&amp; nums[i] == nums[i<span class="number">-1</span>])&#123;</span><br><span class="line">                <span class="keyword">continue</span>; </span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="type">int</span> left = i+<span class="number">1</span>,right = nums.<span class="built_in">size</span>()<span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">while</span>(left &lt; right)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="type">int</span> sum = nums[i] + nums[left] + nums[right];</span><br><span class="line">                <span class="keyword">if</span>(sum == target)&#123;</span><br><span class="line">                    <span class="keyword">return</span> target;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 更新结果值</span></span><br><span class="line">                <span class="type">int</span> diff = <span class="built_in">abs</span>(target-sum);</span><br><span class="line">                <span class="keyword">if</span>(diff &lt; retNum)</span><br><span class="line">                &#123;</span><br><span class="line">                    retNum = diff;</span><br><span class="line">                    retSum = sum;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span>(sum &gt;= target)&#123;</span><br><span class="line">                    <span class="keyword">while</span>(left&lt;right &amp;&amp; nums[right] == nums[right<span class="number">-1</span>])&#123;</span><br><span class="line">                        right--;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// 必须要再操作一次才是下一个</span></span><br><span class="line">                    right--;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(sum &lt; target)&#123;</span><br><span class="line">                    <span class="keyword">while</span>(left&lt;right &amp;&amp; nums[left] == nums[left+<span class="number">1</span>])&#123;</span><br><span class="line">                        left++;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// 必须要再操作一次才是下一个</span></span><br><span class="line">                    left++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> retSum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/03/9ce082f0e755255f5e368fd805290888.png" alt="image.png"></p><h3 id="遇到target直接返回"><a href="#遇到target直接返回" class="headerlink" title="遇到target直接返回"></a>遇到target直接返回</h3><p>如果三数和已经等于target，可以直接返回，不需要继续执行。</p><h1 id="The-end"><a href="#The-end" class="headerlink" title="The end"></a>The end</h1><p>leetcode和16题类似的有15题&#x2F;18题&#x2F;454题，具体可以参考代码随想录和我的刷题仓库。</p>]]></content>
    
    
    <summary type="html">leetcode 16.最接近的三数之和</summary>
    
    
    
    <category term="编程学习" scheme="https://blog.musnow.top/categories/%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="把题目都给刷干净" scheme="https://blog.musnow.top/categories/%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0/%E6%8A%8A%E9%A2%98%E7%9B%AE%E9%83%BD%E7%BB%99%E5%88%B7%E5%B9%B2%E5%87%80/"/>
    
    
    <category term="算法" scheme="https://blog.musnow.top/tags/%E7%AE%97%E6%B3%95/"/>
    
    <category term="leetcode" scheme="https://blog.musnow.top/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>【leetcode】11.盛水最多的容器</title>
    <link href="https://blog.musnow.top/posts/62868007/"/>
    <id>https://blog.musnow.top/posts/62868007/</id>
    <published>2024-03-09T07:15:46.000Z</published>
    <updated>2024-03-10T08:29:14.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><a href="https://leetcode.cn/problems/container-with-most-water/description/?envType=study-plan-v2&envId=top-100-liked">11. 盛最多水的容器 - 力扣（LeetCode）</a></p><p>给定一个长度为 n 的整数数组 height 。有 n 条垂线，第 i 条线的两个端点是 <code>(i, 0)</code> 和 <code>(i, height[i])</code> 。</p><p>找出其中的两条线，使得它们与 x 轴共同构成的容器可以容纳最多的水。</p><p>返回容器可以储存的最大水量。</p><p>说明：你不能倾斜容器。</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/03/68a275f35ddd873d91e563b3aa409b40.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：[1,8,6,2,5,4,8,3,7]</span><br><span class="line">输出：49 </span><br><span class="line">解释：图中垂直线代表输入数组 [1,8,6,2,5,4,8,3,7]。在此情况下，容器能够容纳水（表示为蓝色部分）的最大值为 49。</span><br></pre></td></tr></table></figure><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>最开始想的是暴力破解，两个for就能遍历出来。但很明显这个思路是会超时的，两个for的时间复杂度是<code>O(N^2)</code>；</p><p>这道题在leetcode的top100中是双指针法里面的，所以要想使用前后两个指针来遍历，可以让时间复杂度降低为<code>O(N)</code>；这也是官方题解中提到的方式。</p><p>首先是前后指针应该移动谁的问题，先列出这个面积的计算公式，两个下标的插值是x轴的长度，然后是两个数组中元素的较小值，作为柱子的长度。假设index1和index2为两个下标，默认情况一个数组头一个数组尾部。</p><p>$$<br> range &#x3D; abs(index1-index2) * min(arr[index1],arr[index2])<br>$$</p><p>假设index1的数组元素（高度）小于index2，那么这个公式就变成了</p><p>$$<br> range &#x3D; abs(index1-index2) * arr[index1]<br>$$</p><p>注意，此时移动index2下标，这个容器的面积还是不会大于这个值，x轴长度减少了，但高度无论怎么变较小者还是<code>arr[index1]</code>；所以需要移动的下标是<strong>二者高度小的那一个</strong>。</p><p>官方题解中有更详细的演示：<a href="https://leetcode.cn/problems/container-with-most-water/solutions/207215/sheng-zui-duo-shui-de-rong-qi-by-leetcode-solution/?envType=study-plan-v2&envId=top-100-liked">盛最多水的容器. - 力扣（LeetCode）</a></p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxArea</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; height)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> maxRet = <span class="number">0</span> ;</span><br><span class="line">        <span class="type">int</span> left = <span class="number">0</span>,right = height.<span class="built_in">size</span>() <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span>(left &lt; right)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> curMin = <span class="built_in">min</span>(height[right],height[left]);</span><br><span class="line">            maxRet = <span class="built_in">max</span>((right-left)*curMin,maxRet);</span><br><span class="line">            <span class="keyword">if</span>(curMin == height[right])&#123;</span><br><span class="line">                right--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                left++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxRet;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/03/620573c4c3b8234fbcc5dcac2eb0ca81.png" alt="image.png"></p>]]></content>
    
    
    <summary type="html">leetcode11题，盛水最多的容器</summary>
    
    
    
    <category term="编程学习" scheme="https://blog.musnow.top/categories/%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="把题目都给刷干净" scheme="https://blog.musnow.top/categories/%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0/%E6%8A%8A%E9%A2%98%E7%9B%AE%E9%83%BD%E7%BB%99%E5%88%B7%E5%B9%B2%E5%87%80/"/>
    
    
    <category term="默认标签" scheme="https://blog.musnow.top/tags/%E9%BB%98%E8%AE%A4%E6%A0%87%E7%AD%BE/"/>
    
  </entry>
  
  <entry>
    <title>【面试】C++三个线程交替打印1到100</title>
    <link href="https://blog.musnow.top/posts/235113945/"/>
    <id>https://blog.musnow.top/posts/235113945/</id>
    <published>2024-03-09T01:31:10.000Z</published>
    <updated>2024-03-09T01:53:30.000Z</updated>
    
    <content type="html"><![CDATA[<p>昨天面了个大厂，自己太傻逼了，<strong>这么简单的一道题目没写出来</strong>。因为我不太熟悉条件变量，拖了很长时间，面试官估计有点失望，后续的八股也没问什么，意料之中的挂了😭。</p><p>还有个题目是LRU，这个倒是临时抱佛脚复习到了，写出来了。</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/03/7421b5d3ff29ccbb72dfb3efd12d70fd.png"></p><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>问题：线程1打印1，线程2打印2，线程3打印3，线程1打印4，线程2打印5，线程3打印6……一直打印到100。</p><p>其实一点都不难，就是我自己平时压根没做过多少线程同步的练习，对于条件变量之类的玩意基本停留在理论和学习时的简单demo层面，一上战场加上紧张就毛都不会了。</p><h2 id="思路1-直接用线程序号做判断"><a href="#思路1-直接用线程序号做判断" class="headerlink" title="思路1-直接用线程序号做判断"></a>思路1-直接用线程序号做判断</h2><p>最简单的一个思路，因为只有三个线程，每个线程打印的数字是有规律的</p><ul><li>线程一打印的数字%3都等于1</li><li>线程二打印的数字%3都等于2</li><li>线程三打印的数字%3都等于0</li></ul><p>所以我们可以直接写一个函数，提供一个线程编号，通过计算判断当前是否是自己需要打印的数字，不是就睡觉。这个方法是最简单的，只需要一个全局变量加一个锁就能实现。</p><p>两个atomic变量，一个用于主线程通知所有线程当前已经初始化完毕，另外一个用于线程通知主线程当前已经执行完毕。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;atomic&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 线程1打印1，线程2打印2，线程3打印3，线程1打印4，线程2打印5.... 打印到100</span></span><br><span class="line">std::atomic&lt;<span class="type">bool</span>&gt; isRun = <span class="literal">false</span>;</span><br><span class="line">std::atomic&lt;<span class="type">bool</span>&gt; isFinished = <span class="literal">false</span>;</span><br><span class="line">std::mutex gMtx;</span><br><span class="line"><span class="type">int</span> count = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">PrintCountFun</span><span class="params">(<span class="type">int</span> no)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(!isRun)</span><br><span class="line">    &#123;</span><br><span class="line">        std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">microseconds</span>(<span class="number">10</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(!isFinished)</span><br><span class="line">    &#123;</span><br><span class="line">        gMtx.<span class="built_in">lock</span>();</span><br><span class="line">        <span class="keyword">if</span>(count &gt; <span class="number">100</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            isFinished = <span class="literal">true</span>;</span><br><span class="line">            gMtx.<span class="built_in">unlock</span>();</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 1号2号线程</span></span><br><span class="line">        <span class="keyword">if</span>(no!=<span class="number">3</span> &amp;&amp; count % <span class="number">3</span> == no)</span><br><span class="line">        &#123;</span><br><span class="line">            std::cout &lt;&lt; no &lt;&lt; <span class="string">&quot; - &quot;</span> &lt;&lt; std::this_thread::<span class="built_in">get_id</span>() &lt;&lt; <span class="string">&quot; - c: &quot;</span> &lt;&lt; count &lt;&lt; std::endl;</span><br><span class="line">            count ++;</span><br><span class="line">            gMtx.<span class="built_in">unlock</span>();</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 3号线程</span></span><br><span class="line">        <span class="keyword">if</span>(no == <span class="number">3</span> &amp;&amp; count % <span class="number">3</span> == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            std::cout &lt;&lt; no &lt;&lt; <span class="string">&quot; - &quot;</span> &lt;&lt; std::this_thread::<span class="built_in">get_id</span>() &lt;&lt; <span class="string">&quot; - c: &quot;</span> &lt;&lt; count &lt;&lt; std::endl;</span><br><span class="line">            count ++;</span><br><span class="line">            gMtx.<span class="built_in">unlock</span>();</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        gMtx.<span class="built_in">unlock</span>();</span><br><span class="line">        std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">microseconds</span>(<span class="number">10</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">std::thread <span class="title">t1</span><span class="params">(PrintCountFun,<span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="function">std::thread <span class="title">t2</span><span class="params">(PrintCountFun,<span class="number">2</span>)</span></span>;</span><br><span class="line">    <span class="function">std::thread <span class="title">t3</span><span class="params">(PrintCountFun,<span class="number">3</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    t1.<span class="built_in">detach</span>();</span><br><span class="line">    t2.<span class="built_in">detach</span>();</span><br><span class="line">    t3.<span class="built_in">detach</span>();</span><br><span class="line"></span><br><span class="line">    isRun = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">while</span>(!isFinished)</span><br><span class="line">    &#123;</span><br><span class="line">        std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">microseconds</span>(<span class="number">100</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;finished\n&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><details><summary>方法1代码运行结果</summary><p>反正是通过编号判断的，肯定不会错，只不过这样效率其实很低。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td><td class="code"><pre><span class="line">1 - 140173660395072 - c: 1</span><br><span class="line">2 - 140173652002368 - c: 2</span><br><span class="line">3 - 140173643609664 - c: 3</span><br><span class="line">1 - 140173660395072 - c: 4</span><br><span class="line">2 - 140173652002368 - c: 5</span><br><span class="line">3 - 140173643609664 - c: 6</span><br><span class="line">1 - 140173660395072 - c: 7</span><br><span class="line">2 - 140173652002368 - c: 8</span><br><span class="line">3 - 140173643609664 - c: 9</span><br><span class="line">1 - 140173660395072 - c: 10</span><br><span class="line">2 - 140173652002368 - c: 11</span><br><span class="line">3 - 140173643609664 - c: 12</span><br><span class="line">1 - 140173660395072 - c: 13</span><br><span class="line">2 - 140173652002368 - c: 14</span><br><span class="line">3 - 140173643609664 - c: 15</span><br><span class="line">1 - 140173660395072 - c: 16</span><br><span class="line">2 - 140173652002368 - c: 17</span><br><span class="line">3 - 140173643609664 - c: 18</span><br><span class="line">1 - 140173660395072 - c: 19</span><br><span class="line">2 - 140173652002368 - c: 20</span><br><span class="line">3 - 140173643609664 - c: 21</span><br><span class="line">1 - 140173660395072 - c: 22</span><br><span class="line">2 - 140173652002368 - c: 23</span><br><span class="line">3 - 140173643609664 - c: 24</span><br><span class="line">1 - 140173660395072 - c: 25</span><br><span class="line">2 - 140173652002368 - c: 26</span><br><span class="line">3 - 140173643609664 - c: 27</span><br><span class="line">1 - 140173660395072 - c: 28</span><br><span class="line">2 - 140173652002368 - c: 29</span><br><span class="line">3 - 140173643609664 - c: 30</span><br><span class="line">1 - 140173660395072 - c: 31</span><br><span class="line">2 - 140173652002368 - c: 32</span><br><span class="line">3 - 140173643609664 - c: 33</span><br><span class="line">1 - 140173660395072 - c: 34</span><br><span class="line">2 - 140173652002368 - c: 35</span><br><span class="line">3 - 140173643609664 - c: 36</span><br><span class="line">1 - 140173660395072 - c: 37</span><br><span class="line">2 - 140173652002368 - c: 38</span><br><span class="line">3 - 140173643609664 - c: 39</span><br><span class="line">1 - 140173660395072 - c: 40</span><br><span class="line">2 - 140173652002368 - c: 41</span><br><span class="line">3 - 140173643609664 - c: 42</span><br><span class="line">1 - 140173660395072 - c: 43</span><br><span class="line">2 - 140173652002368 - c: 44</span><br><span class="line">3 - 140173643609664 - c: 45</span><br><span class="line">1 - 140173660395072 - c: 46</span><br><span class="line">2 - 140173652002368 - c: 47</span><br><span class="line">3 - 140173643609664 - c: 48</span><br><span class="line">1 - 140173660395072 - c: 49</span><br><span class="line">2 - 140173652002368 - c: 50</span><br><span class="line">3 - 140173643609664 - c: 51</span><br><span class="line">1 - 140173660395072 - c: 52</span><br><span class="line">2 - 140173652002368 - c: 53</span><br><span class="line">3 - 140173643609664 - c: 54</span><br><span class="line">1 - 140173660395072 - c: 55</span><br><span class="line">2 - 140173652002368 - c: 56</span><br><span class="line">3 - 140173643609664 - c: 57</span><br><span class="line">1 - 140173660395072 - c: 58</span><br><span class="line">2 - 140173652002368 - c: 59</span><br><span class="line">3 - 140173643609664 - c: 60</span><br><span class="line">1 - 140173660395072 - c: 61</span><br><span class="line">2 - 140173652002368 - c: 62</span><br><span class="line">3 - 140173643609664 - c: 63</span><br><span class="line">1 - 140173660395072 - c: 64</span><br><span class="line">2 - 140173652002368 - c: 65</span><br><span class="line">3 - 140173643609664 - c: 66</span><br><span class="line">1 - 140173660395072 - c: 67</span><br><span class="line">2 - 140173652002368 - c: 68</span><br><span class="line">3 - 140173643609664 - c: 69</span><br><span class="line">1 - 140173660395072 - c: 70</span><br><span class="line">2 - 140173652002368 - c: 71</span><br><span class="line">3 - 140173643609664 - c: 72</span><br><span class="line">1 - 140173660395072 - c: 73</span><br><span class="line">2 - 140173652002368 - c: 74</span><br><span class="line">3 - 140173643609664 - c: 75</span><br><span class="line">1 - 140173660395072 - c: 76</span><br><span class="line">2 - 140173652002368 - c: 77</span><br><span class="line">3 - 140173643609664 - c: 78</span><br><span class="line">1 - 140173660395072 - c: 79</span><br><span class="line">2 - 140173652002368 - c: 80</span><br><span class="line">3 - 140173643609664 - c: 81</span><br><span class="line">1 - 140173660395072 - c: 82</span><br><span class="line">2 - 140173652002368 - c: 83</span><br><span class="line">3 - 140173643609664 - c: 84</span><br><span class="line">1 - 140173660395072 - c: 85</span><br><span class="line">2 - 140173652002368 - c: 86</span><br><span class="line">3 - 140173643609664 - c: 87</span><br><span class="line">1 - 140173660395072 - c: 88</span><br><span class="line">2 - 140173652002368 - c: 89</span><br><span class="line">3 - 140173643609664 - c: 90</span><br><span class="line">1 - 140173660395072 - c: 91</span><br><span class="line">2 - 140173652002368 - c: 92</span><br><span class="line">3 - 140173643609664 - c: 93</span><br><span class="line">1 - 140173660395072 - c: 94</span><br><span class="line">2 - 140173652002368 - c: 95</span><br><span class="line">3 - 140173643609664 - c: 96</span><br><span class="line">1 - 140173660395072 - c: 97</span><br><span class="line">2 - 140173652002368 - c: 98</span><br><span class="line">3 - 140173643609664 - c: 99</span><br><span class="line">1 - 140173660395072 - c: 100</span><br><span class="line">finished</span><br></pre></td></tr></table></figure></details><p>我刚开始的时候就是想着用条件变量，比如三个条件变量分别用于通知……但这个实在是复杂且没有必要，没做过条件变量练习一时半会完全是写不出来的。后来就换了这个思路，但时间已经来不及了。</p><p>说来惭愧，我写完上面代码的基本框架后编译错误，显示<code>atomic&lt;bool&gt;</code>初始化失败，我找了好久都没有发现是自己<strong>没有引用</strong><code>&lt;atomic&gt;</code>这个头文件导致的，一直在看自己的语法是不是写错了……</p><p>还是自己练习不够，不然也不会怀疑自己语法是否写错😣</p><h1 id="思路2-条件变量"><a href="#思路2-条件变量" class="headerlink" title="思路2-条件变量"></a>思路2-条件变量</h1><p>上述的这个单锁加遍历的思路其实并不是一个好的答案（<strong>但总比没写出来的好</strong>），因为它完全没有涉及到线程同步的机制，<strong>三个线程其实毫无关系</strong>，只是在通过锁竞争和判断来确定自己是否需要打印。面试官想要的答案肯定得包含条件变量。</p><p>下面这个解决方案的思路同样是通过线程编号判断（只不过拆分成了三个不同的函数），每个线程打印完毕自己的，就把另外两个线程唤醒，然后被唤醒的两个线程会通过锁竞争先后进入自己的函数打印区域，判断是否是自己需要打印的部分，如果不是就继续在条件变量里面等待。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;condition_variable&gt;</span></span></span><br><span class="line"></span><br><span class="line">std::mutex gMtx;</span><br><span class="line">std::condition_variable cv;</span><br><span class="line"><span class="type">int</span> count = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func1</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lc</span><span class="params">(gMtx)</span></span>;</span><br><span class="line"><span class="keyword">while</span>(count &lt;= <span class="number">100</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">while</span> (count % <span class="number">3</span> == <span class="number">0</span> &amp;&amp; count &lt;= <span class="number">100</span>)</span><br><span class="line">&#123;</span><br><span class="line">std::cout &lt;&lt; std::this_thread::<span class="built_in">get_id</span>() &lt;&lt; <span class="string">&quot; - c: &quot;</span> &lt;&lt; count &lt;&lt; std::endl;</span><br><span class="line">count++;</span><br><span class="line">cv.<span class="built_in">notify_all</span>();</span><br><span class="line">&#125;</span><br><span class="line">cv.<span class="built_in">wait</span>(lc);</span><br><span class="line">&#125;</span><br><span class="line">cv.<span class="built_in">notify_all</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func2</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lc</span><span class="params">(gMtx)</span></span>;</span><br><span class="line"><span class="keyword">while</span> (count &lt;= <span class="number">100</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">while</span> (count % <span class="number">3</span> == <span class="number">1</span> &amp;&amp; count &lt;= <span class="number">100</span>)</span><br><span class="line">&#123;</span><br><span class="line">std::cout &lt;&lt; std::this_thread::<span class="built_in">get_id</span>() &lt;&lt; <span class="string">&quot; - c: &quot;</span> &lt;&lt; count &lt;&lt; std::endl;</span><br><span class="line">count++; </span><br><span class="line">cv.<span class="built_in">notify_all</span>();</span><br><span class="line">&#125;</span><br><span class="line">cv.<span class="built_in">wait</span>(lc);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func3</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lc</span><span class="params">(gMtx)</span></span>;</span><br><span class="line"><span class="keyword">while</span> (count &lt;= <span class="number">100</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">while</span> (count % <span class="number">3</span> == <span class="number">2</span> &amp;&amp; count &lt;= <span class="number">100</span>)</span><br><span class="line">&#123;</span><br><span class="line">std::cout &lt;&lt; std::this_thread::<span class="built_in">get_id</span>() &lt;&lt; <span class="string">&quot; - c: &quot;</span> &lt;&lt; count &lt;&lt; std::endl;</span><br><span class="line">count++; </span><br><span class="line">cv.<span class="built_in">notify_all</span>();</span><br><span class="line">&#125;</span><br><span class="line">cv.<span class="built_in">wait</span>(lc);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="function">std::thread <span class="title">s1</span><span class="params">(func1)</span></span>;</span><br><span class="line"><span class="function">std::thread <span class="title">s2</span><span class="params">(func2)</span></span>;</span><br><span class="line"><span class="function">std::thread <span class="title">s3</span><span class="params">(func3)</span></span>;</span><br><span class="line"></span><br><span class="line">s1.<span class="built_in">join</span>();</span><br><span class="line">s2.<span class="built_in">join</span>();</span><br><span class="line">s3.<span class="built_in">join</span>();</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;finished\n&quot;</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><details><summary>方法2代码运行结果</summary><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td><td class="code"><pre><span class="line">140713900033600 - c: 1</span><br><span class="line">140713891640896 - c: 2</span><br><span class="line">140713908426304 - c: 3</span><br><span class="line">140713900033600 - c: 4</span><br><span class="line">140713891640896 - c: 5</span><br><span class="line">140713908426304 - c: 6</span><br><span class="line">140713900033600 - c: 7</span><br><span class="line">140713891640896 - c: 8</span><br><span class="line">140713908426304 - c: 9</span><br><span class="line">140713900033600 - c: 10</span><br><span class="line">140713891640896 - c: 11</span><br><span class="line">140713908426304 - c: 12</span><br><span class="line">140713900033600 - c: 13</span><br><span class="line">140713891640896 - c: 14</span><br><span class="line">140713908426304 - c: 15</span><br><span class="line">140713900033600 - c: 16</span><br><span class="line">140713891640896 - c: 17</span><br><span class="line">140713908426304 - c: 18</span><br><span class="line">140713900033600 - c: 19</span><br><span class="line">140713891640896 - c: 20</span><br><span class="line">140713908426304 - c: 21</span><br><span class="line">140713900033600 - c: 22</span><br><span class="line">140713891640896 - c: 23</span><br><span class="line">140713908426304 - c: 24</span><br><span class="line">140713900033600 - c: 25</span><br><span class="line">140713891640896 - c: 26</span><br><span class="line">140713908426304 - c: 27</span><br><span class="line">140713900033600 - c: 28</span><br><span class="line">140713891640896 - c: 29</span><br><span class="line">140713908426304 - c: 30</span><br><span class="line">140713900033600 - c: 31</span><br><span class="line">140713891640896 - c: 32</span><br><span class="line">140713908426304 - c: 33</span><br><span class="line">140713900033600 - c: 34</span><br><span class="line">140713891640896 - c: 35</span><br><span class="line">140713908426304 - c: 36</span><br><span class="line">140713900033600 - c: 37</span><br><span class="line">140713891640896 - c: 38</span><br><span class="line">140713908426304 - c: 39</span><br><span class="line">140713900033600 - c: 40</span><br><span class="line">140713891640896 - c: 41</span><br><span class="line">140713908426304 - c: 42</span><br><span class="line">140713900033600 - c: 43</span><br><span class="line">140713891640896 - c: 44</span><br><span class="line">140713908426304 - c: 45</span><br><span class="line">140713900033600 - c: 46</span><br><span class="line">140713891640896 - c: 47</span><br><span class="line">140713908426304 - c: 48</span><br><span class="line">140713900033600 - c: 49</span><br><span class="line">140713891640896 - c: 50</span><br><span class="line">140713908426304 - c: 51</span><br><span class="line">140713900033600 - c: 52</span><br><span class="line">140713891640896 - c: 53</span><br><span class="line">140713908426304 - c: 54</span><br><span class="line">140713900033600 - c: 55</span><br><span class="line">140713891640896 - c: 56</span><br><span class="line">140713908426304 - c: 57</span><br><span class="line">140713900033600 - c: 58</span><br><span class="line">140713891640896 - c: 59</span><br><span class="line">140713908426304 - c: 60</span><br><span class="line">140713900033600 - c: 61</span><br><span class="line">140713891640896 - c: 62</span><br><span class="line">140713908426304 - c: 63</span><br><span class="line">140713900033600 - c: 64</span><br><span class="line">140713891640896 - c: 65</span><br><span class="line">140713908426304 - c: 66</span><br><span class="line">140713900033600 - c: 67</span><br><span class="line">140713891640896 - c: 68</span><br><span class="line">140713908426304 - c: 69</span><br><span class="line">140713900033600 - c: 70</span><br><span class="line">140713891640896 - c: 71</span><br><span class="line">140713908426304 - c: 72</span><br><span class="line">140713900033600 - c: 73</span><br><span class="line">140713891640896 - c: 74</span><br><span class="line">140713908426304 - c: 75</span><br><span class="line">140713900033600 - c: 76</span><br><span class="line">140713891640896 - c: 77</span><br><span class="line">140713908426304 - c: 78</span><br><span class="line">140713900033600 - c: 79</span><br><span class="line">140713891640896 - c: 80</span><br><span class="line">140713908426304 - c: 81</span><br><span class="line">140713900033600 - c: 82</span><br><span class="line">140713891640896 - c: 83</span><br><span class="line">140713908426304 - c: 84</span><br><span class="line">140713900033600 - c: 85</span><br><span class="line">140713891640896 - c: 86</span><br><span class="line">140713908426304 - c: 87</span><br><span class="line">140713900033600 - c: 88</span><br><span class="line">140713891640896 - c: 89</span><br><span class="line">140713908426304 - c: 90</span><br><span class="line">140713900033600 - c: 91</span><br><span class="line">140713891640896 - c: 92</span><br><span class="line">140713908426304 - c: 93</span><br><span class="line">140713900033600 - c: 94</span><br><span class="line">140713891640896 - c: 95</span><br><span class="line">140713908426304 - c: 96</span><br><span class="line">140713900033600 - c: 97</span><br><span class="line">140713891640896 - c: 98</span><br><span class="line">140713908426304 - c: 99</span><br><span class="line">140713900033600 - c: 100</span><br><span class="line">finished</span><br></pre></td></tr></table></figure></details><h1 id="The-end"><a href="#The-end" class="headerlink" title="The end"></a>The end</h1><p>自己平时不多练习，只能大意失荆州了……</p>]]></content>
    
    
    <summary type="html">使用C++实现三个线程交替打印1到100</summary>
    
    
    
    <category term="求职路上一去不复返" scheme="https://blog.musnow.top/categories/%E6%B1%82%E8%81%8C%E8%B7%AF%E4%B8%8A%E4%B8%80%E5%8E%BB%E4%B8%8D%E5%A4%8D%E8%BF%94/"/>
    
    
    <category term="线程" scheme="https://blog.musnow.top/tags/%E7%BA%BF%E7%A8%8B/"/>
    
    <category term="Cpp" scheme="https://blog.musnow.top/tags/Cpp/"/>
    
  </entry>
  
</feed>
