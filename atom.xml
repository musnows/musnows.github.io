<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>慕雪的寒舍</title>
  
  <subtitle>雪下了一夜</subtitle>
  <link href="https://blog.musnow.top/atom.xml" rel="self"/>
  
  <link href="https://blog.musnow.top/"/>
  <updated>2023-10-16T17:49:13.000Z</updated>
  <id>https://blog.musnow.top/</id>
  
  <author>
    <name>慕雪年华</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>【微机】DOSBox在windows上的安装和masm的配置</title>
    <link href="https://blog.musnow.top/posts/2839269095/"/>
    <id>https://blog.musnow.top/posts/2839269095/</id>
    <published>2023-10-16T17:49:13.000Z</published>
    <updated>2023-10-16T17:49:13.000Z</updated>
    
    <content type="html"><![CDATA[<p>最近学校学习微型计算机原理与接口技术，需要用到DOSBox来模拟DOS环境进行汇编编程的学习。</p><p>本文记录了如何在windows11&#x2F;10上安装<code>DOSBox0.74</code>并配置<code>masm5</code></p><h1 id="1-安装"><a href="#1-安装" class="headerlink" title="1.安装"></a>1.安装</h1><p>这两个软件我打包上传到了百度云盘。放心，加起来也就2mb，下载应该不会很久</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">链接: https://pan.baidu.com/s/1vjbSL7iwP8WpMVA9K505ZA</span><br><span class="line">提取码: kr4x</span><br></pre></td></tr></table></figure><h2 id="1-1-DOSBox"><a href="#1-1-DOSBox" class="headerlink" title="1.1 DOSBox"></a>1.1 DOSBox</h2><p>点击<code>DOSBox0.74</code>的安装包，无脑下一步安装即可</p><p><img src="https://img.musnow.top/i/2023/10/4ef1475a8016a019d58a90bd6845e70d.png" alt="image-20231017015458406"></p><p>安装出来的图标如下</p><p><img src="https://img.musnow.top/i/2023/10/cc5f29112bed916bb978c49a9a23636d.png" alt="image-20231017015529621"></p><h2 id="1-2-masm5"><a href="#1-2-masm5" class="headerlink" title="1.2 masm5"></a>1.2 masm5</h2><p>找一个空的文件夹，文件路径中不能包含空格、特殊字符和中文，将<code>masm5.zip</code>中的文件全部解压到这个文件夹中，如下图</p><p><img src="https://img.musnow.top/i/2023/10/21d3adc3a7e767d3aa3d0eba69df75e9.png" alt="image-20231017015700958"></p><p>随后修改DOSBox软件的配置文件，右键桌面上Dosbox软件的快捷图标，选择<code>打开文件所在位置</code>找到DOSBox软件的安装路径，点击<code>DOSBox 0.74 Options.bat</code>文件，稍等片刻，会以记事本的方式打开配置文件。</p><p><img src="https://img.musnow.top/i/2023/10/06f84cbaea8c2c0380807a61e01f1a7d.png" alt="image-20231017015801923"></p><p>拉到配置文件最底下，新增如下配置。你只需要修改<code>D:\GAME\masm</code>为你的masm5文件的解压目录就行了。这个文件路径中不能有空格，也不能有特殊字符和中文！</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">MOUNT C D:\GAME\masm</span><br><span class="line">path=%path%; \masm</span><br><span class="line">C: </span><br><span class="line">cd \asm</span><br></pre></td></tr></table></figure><p>配置完成后，启动DOSbox，查看masm命令是否能正常使用。如图所示，没有报错masm命令不存在，那么就是配置好了。</p><p><img src="https://img.musnow.top/i/2023/10/62cba64fa60c2fd957b5968d4387109b.png" alt="image-20231017020002774"></p><h1 id="2-修改DOSBox窗口大小"><a href="#2-修改DOSBox窗口大小" class="headerlink" title="2.修改DOSBox窗口大小"></a>2.修改DOSBox窗口大小</h1><p>默认情况下DOSBox的命令行窗口是非常非常非常小的，我们需要将其改大。同样是修改DOSBox的配置文件，如何打开配置文件参考上文。</p><p>按下图所示修改</p><p><img src="https://img.musnow.top/i/2023/10/2b5bab3f2fc1dbb0a766659d1eb51130.png" alt="image-20231017020347782"></p><p>请注意，这里的1280和1080中间的是大写的X，并不是乘号</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">windowresolution=1280X1080</span><br><span class="line">output=opengl</span><br></pre></td></tr></table></figure><p>修改了之后保存，再重新打开DOSBox，界面就应该会变大了。如果你觉得还是小了，可以修改这里的分辨率，继续让他变大一点。</p><h1 id="3-编译一个汇编程序"><a href="#3-编译一个汇编程序" class="headerlink" title="3.编译一个汇编程序"></a>3.编译一个汇编程序</h1><p>用下面最简单的汇编程序做测试，将如下内容写入到<code>test.asm</code>中，并放入和masm的同一目录下（必须要是同一目录）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">CODE SEGMENT ;USE16</span><br><span class="line">     ASSUME CS:CODE</span><br><span class="line">BEG: MOV DL,&#x27;H&#x27;</span><br><span class="line">     MOV AH, 2 ; 调用2号DOS系统调用输出字符到屏幕上</span><br><span class="line">     INT 21H</span><br><span class="line">     MOV AH, 4CH</span><br><span class="line">     INT 21H</span><br><span class="line">CODE  ENDS</span><br><span class="line">        END BEG</span><br></pre></td></tr></table></figure><p>打开DOSBox，输入如下命令</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">masm test.asm</span><br><span class="line">link test.obj</span><br></pre></td></tr></table></figure><p>输出如下图所示，第一个命令的作用是编译源文件（注意看有没有编译报错）；第二个命令的作用是链接obj文件，最终会弹出来一个警告，不用管他。</p><p><img src="https://img.musnow.top/i/2023/10/60d8190bb6bda5b544018ce777909c0f.png" alt="image-20231017020903839"></p><p>最终执行test，成功输出字符H到终端上。</p><p><img src="https://img.musnow.top/i/2023/10/8cace87b33fc71a4387afa5d7765e8a4.png" alt="image-20231017020946832"></p><p>能走到这一步，就代表你的masm基本环境已经配置好了。可以用来编译运行汇编代码了</p>]]></content>
    
    
    <summary type="html">DOSBox在windows上的安装和masm的配置</summary>
    
    
    
    <category term="差生文具多" scheme="https://blog.musnow.top/categories/%E5%B7%AE%E7%94%9F%E6%96%87%E5%85%B7%E5%A4%9A/"/>
    
    
    <category term="win" scheme="https://blog.musnow.top/tags/win/"/>
    
  </entry>
  
  <entry>
    <title>【Linux】ubuntu/centos8安装zsh终端</title>
    <link href="https://blog.musnow.top/posts/2565866661/"/>
    <id>https://blog.musnow.top/posts/2565866661/</id>
    <published>2023-10-15T09:12:55.000Z</published>
    <updated>2023-10-15T09:12:55.000Z</updated>
    
    <content type="html"><![CDATA[<p>根据这篇知乎文章进行 <a href="https://zhuanlan.zhihu.com/p/514636147">https://zhuanlan.zhihu.com/p/514636147</a></p><h1 id="1-安装zsh"><a href="#1-安装zsh" class="headerlink" title="1.安装zsh"></a>1.安装zsh</h1><p>先安装zsh并设置为默认的终端</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># ubuntu</span></span><br><span class="line">sudo apt install zsh</span><br><span class="line"><span class="comment"># centos </span></span><br><span class="line">sudo yum install zsh util-linux-user</span><br><span class="line"><span class="comment"># 通用</span></span><br><span class="line">chsh -s /bin/zsh</span><br></pre></td></tr></table></figure><blockquote><p>如果centos下找不到chsh命令，参考此博客：<a href="https://blog.csdn.net/FungLeo/article/details/99448425">https://blog.csdn.net/FungLeo/article/details/99448425</a></p></blockquote><p>然后安装oh-my-zsh，这是一个大佬在github上开源的一个zsh配置项，相对方便点</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget --no-check-certificate https://github.com/robbyrussell/oh-my-zsh/raw/master/tools/install.sh -O - | sh </span><br></pre></td></tr></table></figure><p>如果github连不上就用gitee，如果你用的是子用户，那么<strong>这个命令不要用sudo权限执行</strong>！否则后续子用户会因为权限问题没办法使用。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sh -c <span class="string">&quot;<span class="subst">$(curl -fsSL https://gitee.com/shmhlsy/oh-my-zsh-install.sh/raw/master/install.sh)</span>&quot;</span></span><br></pre></td></tr></table></figure><p>最终出现如图所示的界面就是安装成功了。</p><p><img src="https://img.musnow.top/i/2023/10/5ebc935468a46d95ac77e65dc879c66d.png" alt="image-20231015205326739"></p><h1 id="2-安装zsh插件"><a href="#2-安装zsh插件" class="headerlink" title="2.安装zsh插件"></a>2.安装zsh插件</h1><p>安装这两个最常用的插件就可以了</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># zsh-autosuggestions 命令行命令键入时的历史命令建议</span></span><br><span class="line">git <span class="built_in">clone</span> https://github.com/zsh-users/zsh-autosuggestions <span class="variable">$&#123;ZSH_CUSTOM:-~/.oh-my-zsh/custom&#125;</span>/plugins/zsh-autosuggestions</span><br><span class="line"><span class="comment"># zsh-syntax-highlighting 命令行语法高亮插件</span></span><br><span class="line">git <span class="built_in">clone</span> https://gitee.com/Annihilater/zsh-syntax-highlighting.git <span class="variable">$&#123;ZSH_CUSTOM:-~/.oh-my-zsh/custom&#125;</span>/plugins/zsh-syntax-highlighting</span><br></pre></td></tr></table></figure><p>这个历史命令建议的插件是用方向键👉来进行补全的，不要和我一样傻乎乎按tab。</p><h1 id="3-配置文件和主题"><a href="#3-配置文件和主题" class="headerlink" title="3.配置文件和主题"></a>3.配置文件和主题</h1><p>原文中的配置文件有很多地方都不对劲，需要我们修改；</p><p>首先是<code>oh-my-zsh</code>的安装路径，需要改成你的用户家目录下，然后需要先安装一下<code>powerlevel10k</code>主题，这个主题很好用！</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> --depth=1 https://gitee.com/romkatv/powerlevel10k.git <span class="variable">$&#123;ZSH_CUSTOM:-<span class="variable">$HOME</span>/.oh-my-zsh/custom&#125;</span>/themes/powerlevel10k</span><br></pre></td></tr></table></figure><p>配置文件<code>~/.zshrc</code>改成如下内容（建议将原本的配置文件cp备份一下）其中的zsh安装路径一定要修改，否则无法正常配置！</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 防止中文乱码</span></span><br><span class="line"><span class="built_in">export</span> LC_ALL=en_US.UTF-8</span><br><span class="line"><span class="built_in">export</span> LANG=en_US.UTF-8</span><br><span class="line"><span class="comment"># oh-my-zsh的安装路径（zsh的配置路径）</span></span><br><span class="line">ZSH=<span class="string">&quot;/home/你的用户名/.oh-my-zsh&quot;</span></span><br><span class="line"><span class="comment"># ZSH_THEME=&quot;robbyrussell&quot;</span></span><br><span class="line"><span class="comment"># 设置字体模式以及配置命令行的主题</span></span><br><span class="line">POWERLEVEL9K_MODE=<span class="string">&#x27;nerdfont-complete&#x27;</span></span><br><span class="line"><span class="comment"># ZSH_THEME=&quot;agnoster&quot;</span></span><br><span class="line">ZSH_THEME=<span class="string">&quot;powerlevel10k/powerlevel10k&quot;</span> <span class="comment"># 主题推荐这个，需要进行安装</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 启动错误命令自动更正</span></span><br><span class="line">ENABLE_CORRECTION=<span class="string">&quot;true&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 在命令执行的过程中，使用小红点进行提示</span></span><br><span class="line">COMPLETION_WAITING_DOTS=<span class="string">&quot;true&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 配置要使用的插件</span></span><br><span class="line">plugins=(</span><br><span class="line">        git</span><br><span class="line">        extract</span><br><span class="line">        zsh-autosuggestions</span><br><span class="line">        zsh-syntax-highlighting</span><br><span class="line">)</span><br><span class="line"><span class="built_in">source</span> <span class="variable">$ZSH</span>/oh-my-zsh.sh</span><br><span class="line"><span class="built_in">source</span> <span class="variable">$ZSH_CUSTOM</span>/plugins/zsh-autosuggestions/zsh-autosuggestions.zsh</span><br><span class="line"><span class="comment"># python虚拟环境相关设置</span></span><br><span class="line"><span class="keyword">if</span> [ -f /usr/local/bin/virtualenvwrapper.sh ];</span><br><span class="line"><span class="keyword">then</span></span><br><span class="line">    <span class="built_in">export</span> WORKON_HOME=<span class="variable">$HOME</span>/.virtualenvs</span><br><span class="line">    <span class="built_in">export</span> VIRTUALENVWRAPPER_PYTHON=/usr/bin/python3</span><br><span class="line">    <span class="built_in">source</span> /usr/local/bin/virtualenvwrapper.sh</span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure><p>改好了之后，启用他，然后就可以了；执行下方命令后，就会自动弹出<code>powerlevel10k</code>主题的配置引导过程。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">source ~/.zshrc</span><br></pre></td></tr></table></figure><p><img src="https://img.musnow.top/i/2023/10/684bc428ce3e1369d8d60997845180a8.png" alt="image-20231015205703586"></p><p>如果设置完毕后，你对<code>powerlevel10k/powerlevel10k</code>的配置又不满意了，可以执行如下命令重新配置</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">p10k configure</span><br></pre></td></tr></table></figure><p>你可能也会遇到如下报错，原因未知，但似乎不影响使用</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">❯ ls</span><br><span class="line">_p9k_worker_stop:zle:4: No handler installed for fd 12</span><br><span class="line">_p9k_worker_stop:5: failed to close file descriptor 12: bad file descriptor</span><br></pre></td></tr></table></figure><p>如上报错解决办法参考github的issue内的说明</p><p><a href="https://github.com/romkatv/powerlevel10k/issues/1554">https://github.com/romkatv/powerlevel10k/issues/1554</a></p><p>在配置文件<code>.zshrc</code>的末尾加上下面这一行，然后source让其生效就可以了</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">unset ZSH_AUTOSUGGEST_USE_ASYNC</span><br></pre></td></tr></table></figure><h1 id="4-使用小技巧"><a href="#4-使用小技巧" class="headerlink" title="4.使用小技巧"></a>4.使用小技巧</h1><p>输入命令的时候键入tab，会弹出一些命令的提示</p><p><img src="https://img.musnow.top/i/2023/10/486730657def543552dc7a82163410e9.png" alt="image-20231015210623737"></p><p>输入之前写过的命令的时候，会出现历史命令提示，使用方向键右👉就可以补全这个命令</p><p><img src="https://img.musnow.top/i/2023/10/eb1e448943c27dd0bdeb29267b26d252.png" alt="image-20231015210708230"></p><p>zsh主要就是这一点非常的方便，至于会不会和默认的<code>/bin/bash</code>有性能差异，那就不知道了。</p>]]></content>
    
    
    <summary type="html">ubuntu/centos8虚拟机安装zsh终端</summary>
    
    
    
    <category term="玩上Linux" scheme="https://blog.musnow.top/categories/%E7%8E%A9%E4%B8%8ALinux/"/>
    
    
    <category term="Linux" scheme="https://blog.musnow.top/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>【虚拟机】WIN11的WSL安装CentOS8Stream虚拟机</title>
    <link href="https://blog.musnow.top/posts/4065446782/"/>
    <id>https://blog.musnow.top/posts/4065446782/</id>
    <published>2023-10-15T03:30:55.000Z</published>
    <updated>2023-10-15T03:30:55.000Z</updated>
    
    <content type="html"><![CDATA[<p>本人所使用的系统是 <code>win11 22H2 家庭版</code>，如果你不是非CentOS不可，强烈建议直接去微软应用商店里面下载Ubuntu，全自动安装到WSL，啥都不用管。(就是好像没办法选择安装路径)</p><h1 id="1-启用WSL"><a href="#1-启用WSL" class="headerlink" title="1.启用WSL"></a>1.启用WSL</h1><p>刚开始安装WSL的时候，参考的是<a href="https://blog.csdn.net/qq_38442140/article/details/120724215">这个博客</a>。说实话，我个人并不喜欢这篇博客。因为里面遗漏了很多东西，并且在不恰当的位置贴出了命令，导致读者会误以为是需要执行这些命令。</p><p>比如我就理解错误，先执行了设置wsl版本为2的命令，<strong>这个命令先不要执行</strong>！后文会告诉你为什么。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wsl --set-default-version 2</span><br></pre></td></tr></table></figure><p>这篇博客中对开启wsl的设置的位置描述也不完全，看上去像从网上哪里抄过来的win10的设置逻辑（win11的位置完全不一样）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">该博客原文：在windows设置中打开【启用或关闭Windwos功能】，勾选【适用于Linux的Windwos子系统】，点击确定后会系统会提示重启，选择确认即可</span><br></pre></td></tr></table></figure><p>实际上在win11中，需要多点好几个地方才能找到这个设置的位置</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">右键桌面 - 个性化 - 进入win11设置界面 - 应用 - 可选功能 - (往下滑)更多windows功能</span><br></pre></td></tr></table></figure><p><img src="https://img.musnow.top/i/2023/10/542d2e77f4272f4598629626e44ee2a7.png" alt="image-20231015104701566"></p><p>在选项框中，勾选上<code>适用于Linux的Windows子系统</code>，点击确定，就成功启用了WSL。系统会弹出一个进度条，下载一些东西。</p><p><img src="https://img.musnow.top/i/2023/10/61b796407e655ae94c7ff535edaeae69.png" alt="image-20231015104951463"></p><blockquote><p>这都是我对一个<strong>不完善博客</strong>的吐槽，但并没有贬低这个教程的意思啊！至少他告诉我基本步骤应该做哪些。</p><p>为什么我要吐槽呢？因为这种写的不全的博客经常会让读者得去重新搜索某些设置的位置，而作者明明是已经走过这个流程的，多花30秒写清楚位置并带上截图，不知道能节省读者多少时间……如果你体会过查资料的时候阅读这些「断头短尾」的博客，应该也能体会到我的心情。</p></blockquote><h1 id="2-安装Centos8"><a href="#2-安装Centos8" class="headerlink" title="2.安装Centos8"></a>2.安装Centos8</h1><h2 id="2-1-下载系统zip"><a href="#2-1-下载系统zip" class="headerlink" title="2.1 下载系统zip"></a>2.1 下载系统zip</h2><p>去 <a href="https://github.com/wsldl-pg/CentWSL/releases/tag/8.1.1911.1">github&#x2F;wsldl-pg&#x2F;CentWSL</a> 上下载适用于wsl的<code>CentOS8</code>系统的zip</p><blockquote><p>这个也可以：<a href="https://github.com/mishamosher/CentOS-WSL">https://github.com/mishamosher/CentOS-WSL</a></p></blockquote><p><img src="https://img.musnow.top/i/2023/10/c42449d2875a2e60a296953f2bfcfae8.png" alt="image-20231015104110576"></p><p>把zip解压到你想安装虚拟机的位置（一定要是一个空文件夹），然后右键<code>CentOS8.exe</code>，以管理员身份运行。</p><p><img src="https://img.musnow.top/i/2023/10/a13a0b3e0db1dab54e499c9c7bf5ddc6.png" alt="image-20231015104455537"></p><h2 id="2-2-报错HRESULT-0x80370102解决"><a href="#2-2-报错HRESULT-0x80370102解决" class="headerlink" title="2.2 报错HRESULT:0x80370102解决"></a>2.2 报错HRESULT:0x80370102解决</h2><p>安装CentOS8的时候，就遇到了这个<strong>issue</strong>中的问题👇</p><p><a href="https://github.com/wsldl-pg/CentWSL/issues/36">github.com&#x2F;wsldl-pg&#x2F;CentWSL&#x2F;issues&#x2F;36</a></p><p>用管理员身份运行<code>CentOS8.exe</code>之后，弹出的终端会输出如下内容</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ERROR:Installation Failed!</span><br><span class="line">HRESULT:0x80370102</span><br></pre></td></tr></table></figure><p>根据<a href="https://github.com/wsldl-pg/CentWSL/issues/36">该issue</a> 中最后一个回复的解决办法，我先将wsl版本设置回了1（这就是为什么前文说不要先设置为默认wsl2）</p><p><img src="https://img.musnow.top/i/2023/10/d19e82cbafe8e5eba20d8c6eef64687a.png" alt="image-20231015112649042"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wsl --set-default-version 1</span><br></pre></td></tr></table></figure><p>重复如上安装步骤（以管理员身份运行<code>CentOS8.exe</code>），就成功安装了虚拟机。在win11的文件管理器左侧会多出来一个Linux图标，里面有CentOS8的系统里面的文件。</p><p><img src="https://img.musnow.top/i/2023/10/721c72e099c746ab5f618282dc205e27.png" alt="image-20231015105247440"></p><p>在windows的powershell或者cmd中，输入<code>wsl</code>，就可以进入CentOS8的bash；见下图，我们已经成功安装好了一个CentOS8的虚拟机。内部的文件就是CentOS8系统的默认文件。</p><p>在内部执行<code>exit</code>命令，就可以退出wsl虚拟机，回到windows的终端下。</p><p><img src="https://img.musnow.top/i/2023/10/fa9eb9786e59758af270ae93f120ed51.png" alt="image-20231015105338512"></p><p>而且WSL有个最大的好处，就是它能自动挂载windows下的文件到<code>/mnt</code>目录下，这个目录里面可以看到我的win11宿主机的3个硬盘分区；windows的文件资源管理器里面也可以看到Linux中的文件，<strong>方便我们在windows和linux下互传文件</strong>（就不需要用sftp工具了）</p><p>特别是如果你需要写带Doxygen文档的项目，在生成Doxygen的html后，就能直接从这里在windows的浏览器中打开网页，而不需要用sftp或者其他工具传到windows下再打开了！</p><blockquote><p>当然，你也可以用带GUI的Linux系统来解决这个问题。</p></blockquote><h2 id="2-3-更新为WSL2"><a href="#2-3-更新为WSL2" class="headerlink" title="2.3 更新为WSL2"></a>2.3 更新为WSL2</h2><p>使用<code>wsl -l -v</code>命令，可以看到当前运行的wsl虚拟机，版本是1</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">PS C:\Users\S2522\Desktop&gt; wsl -l -v</span><br><span class="line">  NAME       STATE           VERSION</span><br><span class="line">* CentOS8    Running         1</span><br></pre></td></tr></table></figure><p>我们可以将其升级为WSL2版本，但是这里会告诉你需要更新内核组件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">PS C:\Users\S2522\Desktop&gt; wsl --set-version CentOS8 2</span><br><span class="line">正在进行转换，这可能需要几分钟时间...</span><br><span class="line">有关与 WSL 2 的主要区别的信息，请访问 https://aka.ms/wsl2</span><br><span class="line">WSL 2 需要更新其内核组件。有关信息，请访问 https://aka.ms/wsl2kernel</span><br></pre></td></tr></table></figure><p>那就更新呗！<a href="https://aka.ms/wsl2kernel">微软官方文档</a> 中会告诉你需要 <code>wsl.exe --install</code> 或 <code>wsl.exe --update</code>命令。</p><p>这里我执行了<code>wsl --update</code>命令，执行后会弹窗要你提供管理权限，并出现一个进度条，等他跑完就行。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">PS C:\Users\S2522\Desktop&gt; wsl --update</span><br><span class="line">正在安装: 适用于 Linux 的 Windows 子系统</span><br><span class="line">已安装 适用于 Linux 的 Windows 子系统。</span><br></pre></td></tr></table></figure><p>更新好了，再重新执行<code>wsl --set-version CentOS8 2</code>升级命令，会提示你正在执行转换，需要等待一会。</p><p><img src="https://img.musnow.top/i/2023/10/a870772fe8f185d55935bb2eb1d720d3.png" alt="image-20231015105730332"></p><p>最终成功转换了，使用命令<code>wsl -l -v</code>里面显示的版本也是2了。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">PS C:\Users\S2522\Desktop&gt; wsl --set-version CentOS8 2</span><br><span class="line">有关与 WSL 2 关键区别的信息，请访问 https://aka.ms/wsl2</span><br><span class="line"></span><br><span class="line">正在进行转换，这可能需要几分钟时间。</span><br><span class="line">操作成功完成。</span><br><span class="line">PS C:\Users\S2522\Desktop&gt; wsl -l -v</span><br><span class="line">  NAME       STATE           VERSION</span><br><span class="line">* CentOS8    Stopped         2</span><br></pre></td></tr></table></figure><p>搞定！现在我们就有一个方便的CentOS8的WSL环境啦！</p><p>可以用如下命令，将当前的CentOS8设置为默认的wsl虚拟机。这样在windows命令行中执行wsl或者bash命令，就能直接进入CentOS8中。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wslconfig /setdefault CentOS8</span><br></pre></td></tr></table></figure><p>重启电脑后，在powershell的下拉栏中会自动出现CentOS8的选项，点击它也能进入wsl虚拟机环境中。</p><p><img src="https://img.musnow.top/i/2023/10/e40e68ef976f8ef57c9f73d03a8dc892.png" alt="image-20231015134927313"></p><h1 id="3-解决yum报错问题"><a href="#3-解决yum报错问题" class="headerlink" title="3.解决yum报错问题"></a>3.解决yum报错问题</h1><p>因为这个CentOS的镜像是最小安装版本（类似于Docker安装的CentOS），所以内部的yum源都是坏掉的。执行<code>yum update</code>会出现如下报错。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@7945R9P ~]# yum -y update</span><br><span class="line">Failed to set locale, defaulting to C.UTF-8</span><br><span class="line">CentOS-8 - AppStream                                                                     68  B/s |  38  B     00:00</span><br><span class="line">Failed to download metadata for repo &#x27;AppStream&#x27;</span><br><span class="line">Error: Failed to download metadata for repo &#x27;AppStream&#x27;</span><br></pre></td></tr></table></figure><p>这时候需要进行yum源的重新设置，参考本站博客解决这个问题就行</p><p> <a href="https://blog.musnow.top/posts/1296728696/">【Docker】配置CentOS容器时出现 Error Failed to download metadata for repo ‘appstream’ Cannot prepare internal mirrorlist | 转载</a></p><p>搞定yum之后，就可以正常安装你想要的开发软件了。这个系统很轻量，sudo和passwd等很多完整系统会自带的命令都没有，需要自行安装一些。</p><p>另外，我写过一个CentOS8的初始化脚本，可以自动化安装一些软件，这里安装的软件并不一定是你想要的，请酌情参考：<a href="https://gitee.com/musnows/centos8-init">https://gitee.com/musnows/centos8-init</a></p><hr><p>而且，默认情况下的ls命令也没有颜色输出，需要修改bash配置来设置命令别名</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">alias</span> <span class="built_in">ls</span>=<span class="string">&#x27;ls --color=auto&#x27;</span></span><br></pre></td></tr></table></figure><p>你也可以根据自己的喜好，改成zsh或者其他终端。</p><h1 id="4-vscode连接"><a href="#4-vscode连接" class="headerlink" title="4.vscode连接"></a>4.vscode连接</h1><p>普通的虚拟机我们需要用vscode的remote ssh插件来连接，但是WSL主机我们直接用vsc的<strong>WSL插件</strong>来连接就行了，使用的效果和remote ssh插件是相同的</p><p><img src="https://img.musnow.top/i/2023/10/4211aec9f60b6984a3a680c1a900b5c8.png" alt="image-20231015111412100"></p><p>在左侧这个远程连接控制器中（和Remote ssh是同一个位置），找到上方的下拉条，改成WSL目标，就能看到我们的CentOS8虚拟机。点击连接它就可以了。</p><p><img src="https://img.musnow.top/i/2023/10/344e4ab417ab6246fa14351b211f016c.png" alt="image-20231015111429863"></p><h1 id="5-修改wsl资源限制"><a href="#5-修改wsl资源限制" class="headerlink" title="5.修改wsl资源限制"></a>5.修改wsl资源限制</h1><p>默认情况下，wsl2的虚拟机能访问到完整的系统资源，包括所有CPU核心和内存。</p><p>这就会导致如果Linux下对一些东西进行了缓存而没有及时清理，Windows是没办法回收这部分内存的。<strong>最终就导致我们Windows宿主机没有足够的内存可用了</strong>，这怎么行？</p><p>为了解决这个问题，我们需要设置wsl的虚拟机内存&#x2F;CPU限制。在Linux下可以用这两个命令来查看cpu和内存的配置信息，刚开始的时候应该是和你的宿主机一样。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cat</span> /proc/cpuinfo | grep processor <span class="comment"># 查看cpu核心数量</span></span><br><span class="line"><span class="built_in">cat</span> /proc/meminfo | grep Total <span class="comment"># 查看内存信息</span></span><br></pre></td></tr></table></figure><p>在C盘的用户文件夹下，创建一个<code>.wslconfig</code>文件，并在内部写入限制</p><ul><li>processors是cpu核数限制</li><li>memory和swap都是内存限制</li></ul><p>顶多设置为宿主机内存的一半，避免宿主机卡顿。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[wsl2]</span><br><span class="line">processors=8</span><br><span class="line">memory=8GB</span><br><span class="line">swap=8GB</span><br></pre></td></tr></table></figure><p>这个配置文件的路径是（windows下）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">C:\Users\你的用户名\.wslconfig</span><br></pre></td></tr></table></figure><p>随后在windows的终端中使用如下命令，终止这个wsl虚拟机</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">PS C:\Users\S2522\Desktop&gt; wsl --shutdown CentOS8</span><br><span class="line">PS C:\Users\S2522\Desktop&gt; wsl -l -v</span><br><span class="line">  NAME       STATE           VERSION</span><br><span class="line">* CentOS8    Stopped         2</span><br></pre></td></tr></table></figure><p>wsl命令中并没有<code>--start</code>选项，我们直接用wsl命令，就会自动重启并进入这个虚拟机。</p><p>这时候再在虚拟机内部看看CPU和内存信息，就可以看到你刚刚配置的性能限制结果了。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">[root@7945R9P ~]# cat /proc/cpuinfo | grep processor</span><br><span class="line">processor       : 0</span><br><span class="line">processor       : 1</span><br><span class="line">processor       : 2</span><br><span class="line">processor       : 3</span><br><span class="line">processor       : 4</span><br><span class="line">processor       : 5</span><br><span class="line">processor       : 6</span><br><span class="line">processor       : 7</span><br><span class="line">[root@7945R9P ~]# cat /proc/meminfo | grep Total</span><br><span class="line">MemTotal:        8136640 kB</span><br><span class="line">SwapTotal:       8388608 kB</span><br><span class="line">VmallocTotal:   34359738367 kB</span><br><span class="line">HugePages_Total:       0</span><br></pre></td></tr></table></figure><h2 id="删除wsl主机"><a href="#删除wsl主机" class="headerlink" title="删除wsl主机"></a>删除wsl主机</h2><p>删除虚拟机的命令如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wsl --unregister &lt;DistributionName&gt;</span><br></pre></td></tr></table></figure><p>更多命令参考微软官网 <a href="https://learn.microsoft.com/zh-cn/windows/wsl/basic-commands">https://learn.microsoft.com/zh-cn/windows/wsl/basic-commands</a></p><h1 id="6-启用systemctl"><a href="#6-启用systemctl" class="headerlink" title="6.启用systemctl"></a>6.启用systemctl</h1><p>我们的系统里面有systemctl命令，但是没有办法使用。网上有些教程说用service命令来替代，但CentOS中是没有service命令的。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@7945R9P bison-3.8]# systemctl</span><br><span class="line">System has not been booted with systemd as init system (PID 1). Can&#x27;t operate.</span><br><span class="line">Failed to connect to bus: Host is down</span><br></pre></td></tr></table></figure><h2 id="6-1-distrod-第三方工具"><a href="#6-1-distrod-第三方工具" class="headerlink" title="6.1 distrod 第三方工具"></a>6.1 distrod 第三方工具</h2><p>我们需要用distrod来安装systemctl的组件，才能成功启用它。具体教程参考github仓库的README中的介绍。不是很难</p><blockquote><p><a href="https://github.com/nullpo-head/wsl-distrod">https://github.com/nullpo-head/wsl-distrod</a></p></blockquote><p>先下载一个自动安装的脚本（连不上github会报ssl或者timeout错误，请使用其他办法下载这个脚本再丢到虚拟机里面去就行）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">curl -L -O &quot;https://raw.githubusercontent.com/nullpo-head/wsl-distrod/main/install.sh&quot;</span><br><span class="line">chmod +x install.sh</span><br><span class="line">sudo ./install.sh install</span><br></pre></td></tr></table></figure><p>然后用下面两个命令之一来启动（第一个命令是会在windows开机自动启动的）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">/opt/distrod/bin/distrod enable --start-on-windows-boot</span><br><span class="line">/opt/distrod/bin/distrod enable</span><br></pre></td></tr></table></figure><p>更多内容相见<a href="https://github.com/nullpo-head/wsl-distrod">该仓库README</a>；</p><p>请注意，执行第一个自启动命令的时候需要windows的管理员权限，此时需要输入的是系统登录的微软账户的密码（不是你的PIN），看下面，我第一次输入密码输入的就是PIN，显示错误，第二次输入了微软账户的密码才成功。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">[root@7945R9P pkg]# /opt/distrod/bin/distrod enable --start-on-windows-boot</span><br><span class="line">[Distrod] Distrod has been enabled. Now your shell will start under systemd.</span><br><span class="line">[Distrod] Enabling atuomatic startup of Distrod. UAC dialog will appear because scheduling</span><br><span class="line">a task requires the admin privilege. Please hit enter to proceed.</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Error</span><br><span class="line">It seems the task has not been scheduled successfully. You may have typed a wrong password, or you may not have the</span><br><span class="line">necessary administrative privileges. Do you want to retry?</span><br><span class="line">[Y] Yes  [N] No  [?] 帮助 (默认值为“Y”): y</span><br><span class="line">Enabling autostart has succeeded.</span><br><span class="line">[Distrod] Distrod will now start automatically on Windows startup.</span><br></pre></td></tr></table></figure><p>操作完成后，需要重启虚拟机。用如下命令将对应的wsl虚拟机关闭就行了，再次执行wsl就会重启这个虚拟机。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wsl --terminate CentOS8</span><br></pre></td></tr></table></figure><p>如图，我的systemctl命令已经生效。</p><p><img src="https://img.musnow.top/i/2023/10/9340e7964572037fbd3b58f1b379b177.png" alt="image-20231015150251531"></p><p>也能正常通过systemctl命令启动mariadb数据库</p><p><img src="https://img.musnow.top/i/2023/10/6edf311cf4a5dd1749328456a0008255.png" alt="image-20231015150404823"></p><h2 id="6-2-微软官方（推荐）"><a href="#6-2-微软官方（推荐）" class="headerlink" title="6.2 微软官方（推荐）"></a>6.2 微软官方（推荐）</h2><blockquote><p>参考 <a href="https://zhuanlan.zhihu.com/p/569883693">https://zhuanlan.zhihu.com/p/569883693</a></p></blockquote><p>查看wsl版本号命令为： <code>wsl --version</code>，如果此命令未正常回显版本号，或版本号低于<code>0.67.6</code>，那么你安装的wsl还不支持systemd</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">PS C:\Users\S2522\Desktop&gt; wsl --version</span><br><span class="line">WSL 版本： 1.2.5.0</span><br><span class="line">内核版本： 5.15.90.1</span><br><span class="line">WSLg 版本： 1.0.51</span><br><span class="line">MSRDC 版本： 1.2.3770</span><br><span class="line">Direct3D 版本： 1.608.2-61064218</span><br><span class="line">DXCore 版本： 10.0.25131.1002-220531-1700.rs-onecore-base2-hyp</span><br><span class="line">Windows 版本： 10.0.22621.2134</span><br></pre></td></tr></table></figure><p>进入wsl的CentOS虚拟机，执行如下命令</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo -e &quot;[boot]\nsystemd=true&quot; | sudo tee -a /etc/wsl.conf</span><br></pre></td></tr></table></figure><p>随后exit退出虚拟机，回到windows终端命令行，重启wsl</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wsl --shutdown</span><br></pre></td></tr></table></figure><p>随后再次在windows命令行下执行wsl命令，重启这个虚拟机；在虚拟机内部执行如下命令</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ps --no-headers -o comm 1</span><br></pre></td></tr></table></figure><ul><li>如果这个命令返回结果是<strong>systemd</strong>，则代表我们的<code>systemctl</code>命令已经可以使用。</li><li>如果返回的是<code>init</code>，则设置失败</li></ul><p>如下图，我已经设置成功了！</p><p><img src="https://img.musnow.top/i/2023/10/a072fdd5b53abc04cf444c1ab0ac9ad2.png" alt="image-20231015204810685"></p><blockquote><p>官方支持的systemd还是有一点是优于distrod的，那就是启用了官方systemd的wsl2实例，在用户停止操作后，会自动关闭，和未启用 systemd 时的特性一样，这有利于节约电脑的计算资源。</p></blockquote><h1 id="7-系统不支持POSIX消息队列"><a href="#7-系统不支持POSIX消息队列" class="headerlink" title="7.系统不支持POSIX消息队列"></a>7.系统不支持POSIX消息队列</h1><p>如题，需要将wsl版本1改成版本2，否则无完整内核支持，无法使用POSIX消息队列。下面是一个POSIX消息队列的demo </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mqueue.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">mqd_t</span> mqID;</span><br><span class="line">    mqID = <span class="built_in">mq_open</span>(<span class="string">&quot;/testmQueue&quot;</span>, O_RDWR | O_CREAT, <span class="number">0666</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (mqID &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;open message queue error...&quot;</span>&lt;&lt;<span class="built_in">strerror</span>(errno)&lt;&lt;endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mq_attr mqAttr;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">mq_getattr</span>(mqID, &amp;mqAttr) &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;get the message queue attribute error&quot;</span>&lt;&lt;endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;mq_flags:&quot;</span>&lt;&lt;mqAttr.mq_flags&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;mq_maxmsg:&quot;</span>&lt;&lt;mqAttr.mq_maxmsg&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;mq_msgsize:&quot;</span>&lt;&lt;mqAttr.mq_msgsize&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;mq_curmsgs:&quot;</span>&lt;&lt;mqAttr.mq_curmsgs&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果编译后运行出现了下面的报错，代表当前系统不支持POSIX消息队列。当前系统下有mqueue头文件，但并没有函数的实现体</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">root@DESKTOP-5SQO6N0:~# ./test</span><br><span class="line">open message queue error...No such file or directory</span><br><span class="line">open message queue error...Function not implemented</span><br></pre></td></tr></table></figure><p>用如下命令将当前虚拟机改成wsl2版本，就可以使用了。这部分命令上文也有介绍</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">wsl -l -v # 用这个命令查看当前version是不是1</span><br><span class="line">wsl --update # 更新wsl</span><br><span class="line">wsl --set-version 虚拟机名 2  # 把指定虚拟机改成版本2</span><br></pre></td></tr></table></figure><p>正常情况下，上面的代码应该输出如下内容</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">root@DESKTOP-5SQO6N0:~# ./test</span><br><span class="line">mq_flags:0</span><br><span class="line">mq_maxmsg:10</span><br><span class="line">mq_msgsize:8192</span><br><span class="line">mq_curmsgs:0</span><br></pre></td></tr></table></figure><p>除了上面这个问题，在使用消息队列之前还可以monut一下路径，参考man手册中的教程（似乎不是必须要做的）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mkdir /dev/mqueue</span><br><span class="line">mount -t mqueue none /dev/mqueue</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">win11安装wsl和CentOS8Stream虚拟机</summary>
    
    
    
    <category term="玩上Linux" scheme="https://blog.musnow.top/categories/%E7%8E%A9%E4%B8%8ALinux/"/>
    
    
    <category term="Linux" scheme="https://blog.musnow.top/tags/Linux/"/>
    
    <category term="虚拟机" scheme="https://blog.musnow.top/tags/%E8%99%9A%E6%8B%9F%E6%9C%BA/"/>
    
  </entry>
  
  <entry>
    <title>【七牛云】artalk表情遇到跨域访问问题</title>
    <link href="https://blog.musnow.top/posts/489538601/"/>
    <id>https://blog.musnow.top/posts/489538601/</id>
    <published>2023-10-02T04:35:28.000Z</published>
    <updated>2023-10-02T04:35:28.000Z</updated>
    
    <content type="html"><![CDATA[<p>如题，当我在我自己编写的文档站点 <a href="https://khl-py.eu.org/">https://khl-py.eu.org/</a> 访问我的artalk服务时，其中包含一个artalk表情的请求，被浏览器的跨域策略给挡住了。这会导致artalk评论中无法发送表情（虽然无伤大雅）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Access to fetch at &#x27;https://img.musnow.top/i/artalk-emoji.json&#x27; from origin &#x27;https://khl-py.eu.org&#x27; has been blocked by CORS policy: No &#x27;Access-Control-Allow-Origin&#x27; header is present on the requested resource. If an opaque response serves your needs, set the request&#x27;s mode to &#x27;no-cors&#x27; to fetch the resource with CORS disabled.</span><br></pre></td></tr></table></figure><p>百度了一下，我们需要在七牛云的CDN策略中进行配置（我的七牛云KODO是绑定到CDN上，通过CDN进行访问的）</p><p>找到CDN界面中的<strong>HTTP响应头配置</strong></p><p><img src="https://img.musnow.top/i/2023/10/6e1119859945ce9b07928a2bff2643d8.png" alt="image-20231002222846450"></p><p>点击修改配置，添加如下两点</p><p><img src="https://img.musnow.top/i/2023/10/6b3b5f2bc783ef6bf7cc614d5bc2a1e7.png" alt="image-20231002222920540"></p><p>保存后过一会，就不会出现这个跨域访问问题了。至于这部分设置会不会导致有人盗刷你的CDN流量，仍待更多的观察。</p><p>另外，如果你的CDN还开启了防盗链，还需要把对应域名填入防盗链的白名单中！</p>]]></content>
    
    
    <summary type="html">七牛云存放的artalk表情遇到跨域访问问题</summary>
    
    
    
    <category term="差生文具多" scheme="https://blog.musnow.top/categories/%E5%B7%AE%E7%94%9F%E6%96%87%E5%85%B7%E5%A4%9A/"/>
    
    
    <category term="图床" scheme="https://blog.musnow.top/tags/%E5%9B%BE%E5%BA%8A/"/>
    
  </entry>
  
  <entry>
    <title>【Linux】valgrind检测程序内存泄漏</title>
    <link href="https://blog.musnow.top/posts/565285228/"/>
    <id>https://blog.musnow.top/posts/565285228/</id>
    <published>2023-09-26T10:12:55.000Z</published>
    <updated>2023-09-26T10:12:55.000Z</updated>
    
    <content type="html"><![CDATA[<p>valgrind是一个用于检测debug内存泄漏的命令行工具</p><h1 id="安装遵循如下命令"><a href="#安装遵循如下命令" class="headerlink" title="安装遵循如下命令"></a>安装遵循如下命令</h1><h2 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget https://sourceware.org/pub/valgrind/valgrind-3.21.0.tar.bz2</span><br></pre></td></tr></table></figure><h2 id="解压"><a href="#解压" class="headerlink" title="解压"></a>解压</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">tar -xf valgrind-3.21.0.tar.bz2</span><br><span class="line">cd valgrind-3.21.0</span><br></pre></td></tr></table></figure><h2 id="配置-x2F-安装，需要有root权限"><a href="#配置-x2F-安装，需要有root权限" class="headerlink" title="配置&#x2F;安装，需要有root权限"></a>配置&#x2F;安装，需要有root权限</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo ./configure</span><br><span class="line">sudo make</span><br><span class="line">sudo make install</span><br></pre></td></tr></table></figure><h1 id="使用mencheck"><a href="#使用mencheck" class="headerlink" title="使用mencheck"></a>使用mencheck</h1><p>mencheck是valgrind的一个模块，其还拥有其他功能，但是我们在这里不做使用<br> –tool&#x3D;memcheck  选择memcheck工具<br> –log-file&#x3D;log.txt  指定日志输出文件到 log.txt <br> –leak-check&#x3D;no|summary|full  指定输出日志的详细程度</p><p>基本使用命令的一个示例，最后的 <code>./test</code> 是一个可执行文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">valgrind --tool=memcheck --log-file=log.txt --leak-check=full ./test</span><br></pre></td></tr></table></figure><h2 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h2><p>memcheck模块检测的范围包括 </p><ul><li>使用未初始化的内存</li><li>使用已经被释放的内存</li><li>使用超出malloc分配空间的内存</li><li>对堆栈的非法访问</li><li>是否有释放申请的空间</li><li>memcpy中src和dst的重叠（参数的内存空间有重合部分）</li></ul><p>注意，对于某些new和malloc出来的常驻对象（比如全局的某个对象，单例模式中就会遇到）并不能算作内存泄漏，因为它是需要被使用的。</p><h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><p>整了个最简单的代码 </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstddef&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line">​</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test_leak</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> *p = (<span class="type">int</span> *)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">    *p = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">​</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> *p1 = (<span class="type">int</span> *)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">    *p1 = <span class="number">2</span>;</span><br><span class="line">​</span><br><span class="line">    <span class="type">int</span> *p2 = (<span class="type">int</span> *)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">    *p2 = <span class="number">3</span>;</span><br><span class="line">    <span class="comment">// 只析构一个，看看能不能检查出报错</span></span><br><span class="line">    <span class="built_in">free</span>(p2);</span><br><span class="line">    <span class="built_in">test_leak</span>();<span class="comment">// 只有调用的模块出现内存泄漏才能被检测到</span></span><br><span class="line">    <span class="comment">// 如果不调用这个函数，则不会检测到这里的问题</span></span><br><span class="line">    <span class="comment">// 因为valgrind是操作监看可执行文件的，并不是来扫描代码的</span></span><br><span class="line">​</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里面有3个malloc，其中有两个是没有free的，那么用valgrind可以检测出来吗？</p><p>答案是肯定的:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">==24089== Memcheck, a memory error detector</span><br><span class="line">==24089== Copyright (C) 2002-2022, and GNU GPL&#x27;d, by Julian Seward et al.</span><br><span class="line">==24089== Using Valgrind-3.21.0 and LibVEX; rerun with -h for copyright info</span><br><span class="line">==24089== Command: ./test</span><br><span class="line">==24089== Parent PID: 24056</span><br><span class="line">==24089== </span><br><span class="line">==24089== </span><br><span class="line">==24089== HEAP SUMMARY:</span><br><span class="line">==24089==     in use at exit: 8 bytes in 2 blocks</span><br><span class="line">==24089==   total heap usage: 4 allocs, 2 frees, 72,716 bytes allocated</span><br><span class="line">==24089== </span><br><span class="line">==24089== 4 bytes in 1 blocks are definitely lost in loss record 1 of 2</span><br><span class="line">==24089==    at 0x484880F: malloc (vg_replace_malloc.c:431)</span><br><span class="line">==24089==    by 0x1091F8: main (in /home/lyk/ub-vm/test)</span><br><span class="line">==24089== </span><br><span class="line">==24089== 4 bytes in 1 blocks are definitely lost in loss record 2 of 2</span><br><span class="line">==24089==    at 0x484880F: malloc (vg_replace_malloc.c:431)</span><br><span class="line">==24089==    by 0x1091C1: test_leak() (in /home/lyk/ub-vm/test)</span><br><span class="line">==24089==    by 0x10922C: main (in /home/lyk/ub-vm/test)</span><br><span class="line">==24089== </span><br><span class="line">==24089== LEAK SUMMARY:</span><br><span class="line">==24089==    definitely lost: 8 bytes in 2 blocks</span><br><span class="line">==24089==    indirectly lost: 0 bytes in 0 blocks</span><br><span class="line">==24089==      possibly lost: 0 bytes in 0 blocks</span><br><span class="line">==24089==    still reachable: 0 bytes in 0 blocks</span><br><span class="line">==24089==         suppressed: 0 bytes in 0 blocks</span><br><span class="line">==24089== </span><br><span class="line">==24089== For lists of detected and suppressed errors, rerun with: -s</span><br><span class="line">==24089== ERROR SUMMARY: 2 errors from 2 contexts (suppressed: 0 from 0)</span><br></pre></td></tr></table></figure><p>在最后的summry里面可以看到，这里提示 <code>definitely lost</code> 了8个字节，而且是在两个不同的区块中丢失的。和我们的代码吻合。</p><p>如果你不调用  <code>test_leak()</code>  函数，那么就不会出现第二次的内存泄漏，报告会变成只有  <code>4 bytes in 1 blocks</code> ，因为valgrind是通过可执行文件来检测是否有内存泄漏的，他不会扫描你的代码（那样的成本太高了而且不一定准确！）</p>]]></content>
    
    
    <summary type="html">valgrind是一个用于检测debug内存泄漏的命令行工具</summary>
    
    
    
    <category term="玩上Linux" scheme="https://blog.musnow.top/categories/%E7%8E%A9%E4%B8%8ALinux/"/>
    
    
    <category term="Linux" scheme="https://blog.musnow.top/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>【C++】C++17的那些新特性</title>
    <link href="https://blog.musnow.top/posts/3858168547/"/>
    <id>https://blog.musnow.top/posts/3858168547/</id>
    <published>2023-09-26T04:40:46.000Z</published>
    <updated>2023-09-26T04:40:46.000Z</updated>
    
    <content type="html"><![CDATA[<p>学习C++17的新特性</p><h1 id="1-构造函数模板推导"><a href="#1-构造函数模板推导" class="headerlink" title="1.构造函数模板推导"></a>1.构造函数模板推导</h1><p>在之前，我们如果想用stl容器，都需要用<code>&lt;&gt;</code> 来手动指定参数类型。但在C++17中，我们不需要这么做了。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::vector v1 = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125;;</span><br><span class="line">    std::pair p1  = &#123;<span class="number">1</span>,<span class="number">2.4234</span>&#125;;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">typeid</span>(v1).<span class="built_in">name</span>() &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">typeid</span>(p1).<span class="built_in">name</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用C++11编译，这个代码会报错。报错的意思是让我们指定参数的模板类型。</p><p>比如 <code>std::pair p1  = &#123;1,2.4234&#125;;</code> 在C++11中应该写成 <code>std::pair&lt;int,double&gt; p1  = &#123;1,2.4234&#125;;</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">test.cpp:16:10: error: use of class template &#x27;std::pair&#x27; requires template arguments</span><br><span class="line">    std::pair p1  = &#123;1,2.4234&#125;;</span><br><span class="line">         ^</span><br><span class="line">/usr/bin/../lib/gcc/x86_64-linux-gnu/11/../../../../include/c++/11/bits/stl_pair.h:211:12: note: template is declared here</span><br><span class="line">    struct pair</span><br><span class="line">           ^</span><br><span class="line">3 errors generated.</span><br><span class="line">make: *** [makefile:3: test] Error 1</span><br></pre></td></tr></table></figure><p>在C++17中，这样的写法就是可以被通过的了，也能正常推断出参数的类型，分别是一个int的vector，和一个int+double的pair；</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ make</span><br><span class="line">clang++ test.cpp -o test -std=c++17</span><br><span class="line">$ ./test</span><br><span class="line">St6vectorIiSaIiEE</span><br><span class="line">St4pairIidE</span><br></pre></td></tr></table></figure><h1 id="2-结构化绑定"><a href="#2-结构化绑定" class="headerlink" title="2.结构化绑定"></a>2.结构化绑定</h1><p>我们可以用 <code>auto[变量1,变量2]</code>的方式来接受一个tuple或者pair的返回值，将其绑定到两个不同的变量上。</p><p>tuple是C++11新增的一个数据结构，它和pair的用法类似，不同的是元组支持无数个参数。而pair仅支持两个。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::tuple&lt;<span class="type">int</span>, <span class="type">double</span>&gt; <span class="title">func_tuple</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> std::<span class="built_in">tuple</span>&lt;<span class="type">int</span>,<span class="type">double</span>&gt;(<span class="number">1</span>, <span class="number">2.2</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">std::pair&lt;<span class="type">int</span>, <span class="type">double</span>&gt; <span class="title">func_pair</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;<span class="number">1</span>,<span class="number">2</span>&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> [i, d] = <span class="built_in">func_tuple</span>(); </span><br><span class="line">    cout &lt;&lt; <span class="built_in">typeid</span>(i).<span class="built_in">name</span>() &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">typeid</span>(d).<span class="built_in">name</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> [x,y] = <span class="built_in">func_pair</span>();</span><br><span class="line">    cout &lt;&lt; <span class="built_in">typeid</span>(x).<span class="built_in">name</span>() &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">typeid</span>(y).<span class="built_in">name</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用C++11来编译，编译器会报错，但编译依旧能成功。这是因为我们的编译器是支持C++17的，但又被指定了<code>-std=c++11</code>，所以给用户报了个警告，但没有报错（因为这个语法在C++17里面是正确的）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">clang++ test.cpp -o test -std=c++11</span><br><span class="line">test.cpp:34:10: warning: decomposition declarations are a C++17 extension [-Wc++17-extensions]</span><br><span class="line">    auto [i, d] = func_tuple(); </span><br><span class="line">         ^~~~~~</span><br><span class="line">test.cpp:40:10: warning: decomposition declarations are a C++17 extension [-Wc++17-extensions]</span><br><span class="line">    auto [x,y] = func_pair();</span><br><span class="line">         ^~~~~</span><br><span class="line">2 warnings generated.</span><br></pre></td></tr></table></figure><p>运行输出结果如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ ./test</span><br><span class="line">i</span><br><span class="line">d</span><br><span class="line"></span><br><span class="line">i</span><br><span class="line">d</span><br></pre></td></tr></table></figure><p>注意：结构化绑定不能应用于constexpr！</p><p>结构化绑定不止可以绑定pair和tuple，还可以绑定数组和结构体等。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 注意这里的struct的成员一定要是public的，不然外部无法访问，还怎么绑定？</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Point</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line">    <span class="type">int</span> y;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回值是point的函数</span></span><br><span class="line"><span class="function">Point <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;<span class="number">1</span>, <span class="number">2</span>&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> array[<span class="number">3</span>] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line">    <span class="keyword">auto</span> [a, b, c] = array;</span><br><span class="line">    cout &lt;&lt; a &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; b &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; c &lt;&lt; endl;</span><br><span class="line">    <span class="comment">// 直接推导出两个成员变量并赋值给变量x和y</span></span><br><span class="line">    <span class="type">const</span> <span class="keyword">auto</span> [x, y] = <span class="built_in">func</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>成功编译并输出结果</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ make</span><br><span class="line">clang++ test.cpp -o test -std=c++17</span><br><span class="line">$ ./test</span><br><span class="line">1 2 3</span><br><span class="line">1 2</span><br></pre></td></tr></table></figure><p>自定义类型也能实现结构化绑定，这里从网上扒了一个代码下来，就不自己做测试了</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 需要实现相关的tuple_size和tuple_element和get&lt;N&gt;方法。</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Entry</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        name_ = <span class="string">&quot;name&quot;</span>;</span><br><span class="line">        age_ = <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">std::string <span class="title">GetName</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> name_; &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">GetAge</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> age_; &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::string name_;</span><br><span class="line">    <span class="type">int</span> age_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="type">size_t</span> I&gt;</span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">get</span><span class="params">(<span class="type">const</span> Entry&amp; e)</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">if</span> <span class="title">constexpr</span> <span class="params">(I == <span class="number">0</span>)</span> <span class="keyword">return</span> e.<span class="title">GetName</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> <span class="built_in">constexpr</span> (I == <span class="number">1</span>) <span class="keyword">return</span> e.<span class="built_in">GetAge</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> std &#123;</span><br><span class="line">    <span class="keyword">template</span>&lt;&gt; <span class="keyword">struct</span> <span class="title class_">tuple_size</span>&lt;Entry&gt; : integral_constant&lt;<span class="type">size_t</span>, <span class="number">2</span>&gt; &#123;&#125;;</span><br><span class="line">    <span class="keyword">template</span>&lt;&gt; <span class="keyword">struct</span> <span class="title class_">tuple_element</span>&lt;<span class="number">0</span>, Entry&gt; &#123; <span class="keyword">using</span> type = std::string; &#125;;</span><br><span class="line">    <span class="keyword">template</span>&lt;&gt; <span class="keyword">struct</span> <span class="title class_">tuple_element</span>&lt;<span class="number">1</span>, Entry&gt; &#123; <span class="keyword">using</span> type = <span class="type">int</span>; &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Entry e;</span><br><span class="line">    e.<span class="built_in">Init</span>();</span><br><span class="line">    <span class="keyword">auto</span> [name, age] = e;</span><br><span class="line">    cout &lt;&lt; name &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; age &lt;&lt; endl; <span class="comment">// name 10</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="3-if语句新增初始条件"><a href="#3-if语句新增初始条件" class="headerlink" title="3.if语句新增初始条件"></a>3.if语句新增初始条件</h1><p>在之前我们都是用 <code>if(判断条件)</code> 来使用if语句的，C++17中给if新增了一个类似for循环中第一个参数的相同参数</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">if(初始化条件,判断条件)</span><br></pre></td></tr></table></figure><p>比如</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(<span class="type">int</span> i=<span class="number">20</span>;i&lt;<span class="number">39</span>)&#123;</span><br><span class="line">    cout &lt;&lt;<span class="string">&quot;i&lt;39!&quot;</span>&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行效果如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ ./test</span><br><span class="line">i&lt;39!</span><br></pre></td></tr></table></figure><h1 id="4-内联变量"><a href="#4-内联变量" class="headerlink" title="4.内联变量"></a>4.内联变量</h1><p>在之前我们想初始化一个类中的static变量，需要在类中定义，类外初始化。但如果是const的static变量，就能直接在类中通过缺省值的方式来初始化。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在头文件里面这样是能通过编译的，但是不建议在头文件中初始化static变量，会产生ODR冲突:</span></span><br><span class="line"><span class="comment">// Variable &#x27;value&#x27; defined in a header file; variable definitions in header files can lead to ODR violations</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">A</span> &#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> value;  </span><br><span class="line">    <span class="type">static</span> <span class="type">const</span> <span class="type">int</span> value_c=<span class="number">10</span>;  <span class="comment">// const可以直接初始化</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">int</span> A::value = <span class="number">10</span>;</span><br></pre></td></tr></table></figure><p>在C++17中内联变量引入后，我们就可以直接实现在头文件中初始化static非const变量，或者直接用缺省值来初始化了</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">A</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> value;</span><br><span class="line">    <span class="type">static</span> <span class="type">const</span> <span class="type">int</span> value_c = <span class="number">10</span>;</span><br><span class="line">    <span class="comment">// static int value = 10;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">inline</span> <span class="type">int</span> A::value = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ========= 或者 ========</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">B</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">inline</span> <span class="type">static</span> <span class="type">int</span> value = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">inline</span> <span class="type">static</span> <span class="type">const</span> <span class="type">int</span> value_c = <span class="number">10</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>相比于原本static变量初始化需要放到另外一个cpp源文件中，这种直接在头文件里面声明+初始化的方式能更好的确定变量的初始值。</p><h1 id="5-折叠表达式"><a href="#5-折叠表达式" class="headerlink" title="5.折叠表达式"></a>5.折叠表达式</h1><p>C++17引入了折叠表达式使可变参数模板编程更方便：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> ... Ts&gt;</span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">sum</span><span class="params">(Ts ... ts)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (ts + ...);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> a &#123;<span class="built_in">sum</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>)&#125;; <span class="comment">// 15</span></span><br><span class="line">std::string a&#123;<span class="string">&quot;hello &quot;</span>&#125;;</span><br><span class="line">std::string b&#123;<span class="string">&quot;world&quot;</span>&#125;;</span><br><span class="line">cout &lt;&lt; <span class="built_in">sum</span>(a, b) &lt;&lt; endl; <span class="comment">// hello world</span></span><br></pre></td></tr></table></figure><p>实话说，可变模板参数这部分就没有弄明白过，实际上也没有用过，直接跳过！</p><h1 id="6-constexpr-lambda表达式"><a href="#6-constexpr-lambda表达式" class="headerlink" title="6.constexpr+lambda表达式"></a>6.constexpr+lambda表达式</h1><p>C++17前lambda表达式只能在运行时使用，C++17引入了constexpr lambda表达式，可以用于在编译期进行计算。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">int main() &#123; // c++17可编译</span><br><span class="line">    constexpr auto lamb = [] (int n) &#123; return n * n; &#125;;</span><br><span class="line">    static_assert(lamb(3) == 9, &quot;a&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>规则和普通的constexpr函数相同，参考我的C++11和14的文章。这里做简单说明：</p><p>constexpr修饰的函数体不能包含汇编语句、goto语句、label、try块、静态变量、线程局部存储、没有初始化的普通变量，不能动态分配内存，不能有new delete等，不能虚函数。</p><h1 id="7-嵌套命名空间"><a href="#7-嵌套命名空间" class="headerlink" title="7.嵌套命名空间"></a>7.嵌套命名空间</h1><p>在之前如果需要嵌套命名空间，需要这样写</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> A &#123;</span><br><span class="line">    <span class="keyword">namespace</span> B &#123;</span><br><span class="line">        <span class="keyword">namespace</span> C &#123;</span><br><span class="line">            <span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span></span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>C++17中可以直接用类似访问限定符的方式，前面加一个namespace来标明嵌套的命名空间。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// c++17，方便了，可读性也更好</span></span><br><span class="line"><span class="keyword">namespace</span> A::B::C &#123;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="8-has-include预处理表达式"><a href="#8-has-include预处理表达式" class="headerlink" title="8.__has_include预处理表达式"></a>8.__has_include预处理表达式</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">if</span> defined __has_include <span class="comment">// 判断是否支持这个表达式</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> __has_include(<span class="string">&lt;charconv&gt;</span>) <span class="comment">// 支持，判断是否存在该头文件</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> has_charconv 1 <span class="comment">// 头文件存在，定义一个宏</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;charconv&gt;</span> <span class="comment">// 引用这个头文件</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>如果一个代码会在多个不同的平台下跑，这个功能就很重要。比如我之前写项目的时候需要使用到jsoncpp，在centos和deepin下，安装jsoncpp的include路径是不同的</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//centos</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;json/json.h&gt;</span></span></span><br><span class="line"><span class="comment">//deepin</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;jsoncpp/json/json.h&gt;</span></span></span><br></pre></td></tr></table></figure><p>这种场景下就可以使用上面提到的这个预处理表达式进行判断，来确认你的jsoncpp路径到底在哪里。注意，这只能解决从yum和apt安装的jsoncpp，如果是自己手动安装的，那鬼知道你安装到哪里去了？🤣</p><p>所以很多大型项目如果需要使用jsoncpp这种第三方依赖项目，一般都会采用<code>git submodule</code>的方式，直接将第三方库下载到当前项目路径下，以避免不同平台的依赖项<code>include</code>路径不对而导致无法编译程序的问题。</p><h1 id="9-this指针捕获（lambda）"><a href="#9-this指针捕获（lambda）" class="headerlink" title="9.this指针捕获（lambda）"></a>9.this指针捕获（lambda）</h1><p>在lambda表达式中，采用<code>[this]</code>方式捕获的this指针是<strong>值传递</strong>捕获的，但在一些情况下，会出现访问已经被释放了的空间的行为；比如如下代码</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Foo</span></span><br><span class="line">&#123;</span><br><span class="line">    std::unique_ptr&lt;<span class="type">int</span>&gt; p;</span><br><span class="line"></span><br><span class="line">    <span class="function">std::function&lt;<span class="title">void</span><span class="params">()</span>&gt; <span class="title">f</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        p.<span class="built_in">reset</span>(<span class="keyword">new</span> <span class="built_in">int</span>(<span class="number">10</span>));</span><br><span class="line">        <span class="keyword">return</span> [&amp;]</span><br><span class="line">        &#123;</span><br><span class="line">            cout &lt;&lt; <span class="number">5</span> &lt;&lt; endl;</span><br><span class="line">            cout &lt;&lt; *p &lt;&lt; endl; <span class="comment">// 实际上是这一步报错的</span></span><br><span class="line">            <span class="comment">// 这里对*p的访问可以解析为 *(this-&gt;p)，但实际上this指针已经被销毁了</span></span><br><span class="line">            <span class="comment">// 注意，这里采用了智能指针，不存在内存泄漏，p指针指向的空间也被销毁了</span></span><br><span class="line">            <span class="comment">// 但我们的报错其实是对this指针解引用的时候就抛出了</span></span><br><span class="line">            cout &lt;&lt; <span class="number">6</span> &lt;&lt; endl;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> foo = <span class="keyword">new</span> <span class="built_in">Foo</span>();</span><br><span class="line">    cout &lt;&lt; <span class="number">1</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">auto</span> f = foo-&gt;<span class="built_in">f</span>();  <span class="comment">// 获取了一个类内成员函数</span></span><br><span class="line">    cout &lt;&lt; <span class="number">2</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">delete</span> foo;  <span class="comment">// 销毁这个对象</span></span><br><span class="line">    cout &lt;&lt; <span class="number">3</span> &lt;&lt; endl;</span><br><span class="line">    <span class="comment">// 尝试在销毁后继续使用这个对象，我们是通过lambda中=捕获的this指针来访问对象的</span></span><br><span class="line">    <span class="built_in">f</span>();  <span class="comment">// 这里直接报错了 Segmentation fault (core dumped)</span></span><br><span class="line">    cout &lt;&lt; <span class="number">4</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行这个程序，可以看到是在<code>*p</code>的位置报错退出的；具体的原因参考代码中的注释。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ ./test</span><br><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">5</span><br><span class="line">Segmentation fault (core dumped)</span><br></pre></td></tr></table></figure><p>需要注意，lambda表达式中，使用&#x3D;和&amp;都会默认采用<strong>传值捕获this指针</strong>，因为this指针是存在于函数作用域中的一个隐藏参数，并不是独立在成员函数外的变量，所以是可以被捕捉到的；另外，this指针是不能被传引用捕获的，<code>[&amp;this]</code> 的写法是不允许的；</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">clang++ test.cpp -o test -std=c++17</span><br><span class="line">test.cpp:84:18: error: &#x27;this&#x27; cannot be captured by reference</span><br><span class="line">        return [&amp;this]</span><br><span class="line">                 ^</span><br><span class="line">1 error generated.</span><br></pre></td></tr></table></figure><p>C++17中提供了一个特殊的写法 <code>[*this]</code> 通过传值的方式捕获了当前对象本身，此时lambda表达式中存在的就是一个对象的拷贝，即便当前对象被销毁了，我们依旧可以通过这个拷贝访问到目标；</p><p>代码修改如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Foo</span></span><br><span class="line">&#123;</span><br><span class="line">    std::shared_ptr&lt;<span class="type">int</span>&gt; p; <span class="comment">// 不能用unique_ptr，因为它的拷贝构造函数是被delete禁止使用的</span></span><br><span class="line"></span><br><span class="line">    <span class="function">std::function&lt;<span class="title">void</span><span class="params">()</span>&gt; <span class="title">f</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        p.<span class="built_in">reset</span>(<span class="keyword">new</span> <span class="built_in">int</span>(<span class="number">10</span>));</span><br><span class="line">        <span class="keyword">return</span> [*<span class="keyword">this</span>]</span><br><span class="line">        &#123;</span><br><span class="line">            cout &lt;&lt; <span class="number">5</span> &lt;&lt; endl;</span><br><span class="line">            cout &lt;&lt; *p &lt;&lt; endl;</span><br><span class="line">            cout &lt;&lt; <span class="number">6</span> &lt;&lt; endl;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> foo = <span class="keyword">new</span> <span class="built_in">Foo</span>();</span><br><span class="line">    cout &lt;&lt; <span class="number">1</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">auto</span> f = foo-&gt;<span class="built_in">f</span>();  <span class="comment">// 获取了一个类内成员函数</span></span><br><span class="line">    cout &lt;&lt; <span class="number">2</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">delete</span> foo;  <span class="comment">// 销毁这个对象</span></span><br><span class="line">    cout &lt;&lt; <span class="number">3</span> &lt;&lt; endl;</span><br><span class="line">    <span class="comment">// 尝试在销毁后继续使用这个对象，我们是通过lambda中=捕获的this指针来访问对象的</span></span><br><span class="line">    <span class="built_in">f</span>();  <span class="comment">// 这里直接报错了 Segmentation fault (core dumped)</span></span><br><span class="line">    cout &lt;&lt; <span class="number">4</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时重新编译，就能成功访问到指针p指向的对象了，并不受foo对象已经被delete的影响；</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ ./test</span><br><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">5</span><br><span class="line">10</span><br><span class="line">6</span><br><span class="line">4</span><br></pre></td></tr></table></figure><h1 id="10-字符串转换"><a href="#10-字符串转换" class="headerlink" title="10.字符串转换"></a>10.字符串转换</h1><blockquote><p>没看懂这两个函数是干嘛的，找到的代码连编译都过不去，跳过吧</p></blockquote><p>新增from_chars函数和to_chars函数</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">https://zh.cppreference.com/w/cpp/utility/from_chars</span><br><span class="line">https://blog.csdn.net/defaultbyzt/article/details/120151801</span><br></pre></td></tr></table></figure><h1 id="11-std-variant"><a href="#11-std-variant" class="headerlink" title="11.std::variant"></a>11.std::variant</h1><p>C++17增加<code>std::variant</code>实现类似union的功能，但却比union更高级，举个例子union里面不能有string这种类型，但<code>std::variant</code>却可以，还可以支持更多复杂类型，如map等，看代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123; <span class="comment">// c++17可编译</span></span><br><span class="line">    <span class="function">std::variant&lt;<span class="type">int</span>, std::string&gt; <span class="title">var</span><span class="params">(<span class="string">&quot;hello&quot;</span>)</span></span>;</span><br><span class="line">    cout &lt;&lt; var.<span class="built_in">index</span>() &lt;&lt; endl;</span><br><span class="line">    var = <span class="number">123</span>;</span><br><span class="line">    cout &lt;&lt; var.<span class="built_in">index</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        var = <span class="string">&quot;world&quot;</span>;</span><br><span class="line">        std::string str = std::<span class="built_in">get</span>&lt;std::string&gt;(var); <span class="comment">// 通过类型获取值</span></span><br><span class="line">        var = <span class="number">3</span>;</span><br><span class="line">        <span class="type">int</span> i = std::<span class="built_in">get</span>&lt;<span class="number">0</span>&gt;(var); <span class="comment">// 通过index获取对应值</span></span><br><span class="line">        cout &lt;&lt; str &lt;&lt; endl;</span><br><span class="line">        cout &lt;&lt; i &lt;&lt; endl;</span><br><span class="line">    &#125; <span class="built_in">catch</span>(...) &#123;</span><br><span class="line">        <span class="comment">// xxx;</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意：一般情况下variant的第一个类型一般要有对应的构造函数，否则编译失败：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">A</span> &#123;</span><br><span class="line">    <span class="built_in">A</span>(<span class="type">int</span> i)&#123;&#125;  </span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::variant&lt;A, <span class="type">int</span>&gt; var; <span class="comment">// 编译失败</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如何避免这种情况呢，可以使用<code>std::monostate</code>来打个桩，模拟一个空状态。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">std::variant&lt;std::monostate, A&gt; var; <span class="comment">// 可以编译成功</span></span><br></pre></td></tr></table></figure><h2 id="12-std-optional"><a href="#12-std-optional" class="headerlink" title="12.std::optional"></a>12.std::optional</h2><p><a href="https://en.cppreference.com/w/cpp/utility/optional">https://en.cppreference.com/w/cpp/utility/optional</a></p><p>有的时候，我们想在异常的时候抛出一个异常的对象，亦或者是在出现一些不可预期的错误的时候，返回一个空值。要怎么区分空值和异常的对象呢？</p><p>在python中，我们有一个专门的None对象可以来处理这件事。在MySQL中，我们也有NULL来标识空；但在CPP中，我们只剩下一个<code>nullptr</code>，其本质是个<strong>指针</strong>，与Py中的None和MySQL中的NULL完全不同！如果想用指针来区分空和异常对象，那就需要用到动态内存管理，亦或者是用智能指针来避免内存泄漏。</p><p>说人话就是，在CPP中没有一个类似None的含义为空的对象，来告诉调用这个程序的人，到底是发生了错误，生成了一个错误的对象，还是说压根什么都没有弄出来。</p><p>于是<code>std::optional</code>就出现了，其可以包含一个类型，并有<code>std::nullopt</code>来专门标识“空”这个含义。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;optional&gt;</span></span></span><br><span class="line"><span class="function">std::optional&lt;<span class="type">int</span>&gt; <span class="title">StoI</span><span class="params">(<span class="type">const</span> std::string &amp;s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> std::<span class="built_in">stoi</span>(s);</span><br><span class="line">    &#125; <span class="built_in">catch</span>(...) &#123;</span><br><span class="line">        <span class="keyword">return</span> std::<span class="literal">nullopt</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::string s&#123;<span class="string">&quot;123&quot;</span>&#125;;</span><br><span class="line">    std::optional&lt;<span class="type">int</span>&gt; o = <span class="built_in">StoI</span>(s);</span><br><span class="line">    <span class="keyword">if</span> (o) &#123;</span><br><span class="line">        cout &lt;&lt; *o &lt;&lt; endl;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;error&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里我们进行了if的判断，首先判断变量o本身，为真代表的确返回了一个int值，为假代表返回的是<code>nullopt</code>；</p><p>随后再使用<code>*o</code>来访问到内部托管的成员。</p><p>需要注意这里是两层的逻辑关系，只有optional对象中成功托管了一个指定的参数类型，其本身才是真的。如果想访问它托管的对象，则需要用解引用。</p><p>比如这里，我们的o对象托管的是一个bool类型的假，但假并不代表空，o对象本身的判断是真，内部对<code>*o</code>的判断才是判断托管的bool值到底是真是假。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;optional&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::optional&lt;<span class="type">bool</span>&gt; o = <span class="literal">false</span>;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">typeid</span>(o).<span class="built_in">name</span>() &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">if</span> (o) <span class="comment">// 这里判断的是optional对象是否有托管一个bool值</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(*o)&#123; <span class="comment">// 这里判断的是托管的bool值本身</span></span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;true&quot;</span> &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;false&quot;</span> &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123; <span class="comment">// 这里则代表托管的是nullopt</span></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;error&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最终运行打印的结果是<code>false</code>；</p><h1 id="13-std-any"><a href="#13-std-any" class="headerlink" title="13.std::any"></a>13.std::any</h1><p><a href="https://en.cppreference.com/w/cpp/utility/any">https://en.cppreference.com/w/cpp/utility/any</a></p><p>这个类型可以托管任意类型的值，与之对应的还有一个<code>std::any_cast</code>来将其托管的值转成我们需要的类型。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;any&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123; <span class="comment">// c++17可编译</span></span><br><span class="line">    std::any a = <span class="number">1</span>;</span><br><span class="line">    cout &lt;&lt; a.<span class="built_in">type</span>().<span class="built_in">name</span>() &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; std::<span class="built_in">any_cast</span>&lt;<span class="type">int</span>&gt;(a) &lt;&lt; endl;</span><br><span class="line">    a = <span class="number">2.2f</span>;</span><br><span class="line">    cout &lt;&lt; a.<span class="built_in">type</span>().<span class="built_in">name</span>() &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; std::<span class="built_in">any_cast</span>&lt;<span class="type">float</span>&gt;(a) &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">if</span> (a.<span class="built_in">has_value</span>()) &#123;</span><br><span class="line">        cout &lt;&lt; a.<span class="built_in">type</span>().<span class="built_in">name</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    a.<span class="built_in">reset</span>();</span><br><span class="line">    <span class="keyword">if</span> (a.<span class="built_in">has_value</span>()) &#123;</span><br><span class="line">        cout &lt;&lt; a.<span class="built_in">type</span>().<span class="built_in">name</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    a = std::<span class="built_in">string</span>(<span class="string">&quot;a&quot;</span>);</span><br><span class="line">    cout &lt;&lt; a.<span class="built_in">type</span>().<span class="built_in">name</span>() &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; std::<span class="built_in">any_cast</span>&lt;std::string&gt;(a) &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">i 1</span><br><span class="line">f 2.2</span><br><span class="line">fNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEE a</span><br></pre></td></tr></table></figure><p>虽然any的出现让cpp也在一定程度上能实现“弱类型”变量，但在具体的开发中，明确变量的类型依旧比使用any好得多。特别是在变量的类型并不可以被直接转换的情况下。</p><h1 id="14-std-apply"><a href="#14-std-apply" class="headerlink" title="14.std::apply"></a>14.std::apply</h1><p>使用<code>std::apply</code>可以将tuple展开作为函数的参数传入，见代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;tuple&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">add</span><span class="params">(<span class="type">int</span> first, <span class="type">int</span> second)</span> </span>&#123; <span class="keyword">return</span> first + second; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> add_lambda = [](<span class="keyword">auto</span> first, <span class="keyword">auto</span> second) &#123; <span class="keyword">return</span> first + second; &#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; std::<span class="built_in">apply</span>(add, std::<span class="built_in">pair</span>(<span class="number">1</span>, <span class="number">2</span>)) &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="built_in">add</span>(std::<span class="built_in">pair</span>(<span class="number">1</span>, <span class="number">2</span>)) &lt;&lt; <span class="string">&quot;\n&quot;</span>; <span class="comment">// error</span></span><br><span class="line">    std::cout &lt;&lt; std::<span class="built_in">apply</span>(add_lambda, std::<span class="built_in">tuple</span>(<span class="number">2.0f</span>, <span class="number">3.0f</span>)) &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="15-std-make-from-tuple"><a href="#15-std-make-from-tuple" class="headerlink" title="15.std::make_from_tuple"></a>15.std::make_from_tuple</h1><p>使用make_from_tuple可以将tuple展开作为构造函数参数</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Foo</span> &#123;</span><br><span class="line">    <span class="built_in">Foo</span>(<span class="type">int</span> first, <span class="type">float</span> second, <span class="type">int</span> third) &#123;</span><br><span class="line">        std::cout &lt;&lt; first &lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; second &lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; third &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   <span class="keyword">auto</span> tuple = std::<span class="built_in">make_tuple</span>(<span class="number">42</span>, <span class="number">3.14f</span>, <span class="number">0</span>);</span><br><span class="line">   std::<span class="built_in">make_from_tuple</span>&lt;Foo&gt;(std::<span class="built_in">move</span>(tuple));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="16-std-string-view"><a href="#16-std-string-view" class="headerlink" title="16.std::string_view"></a>16.std::string_view</h1><p><a href="https://zhuanlan.zhihu.com/p/166359481">https://zhuanlan.zhihu.com/p/166359481</a></p><p><a href="https://en.cppreference.com/w/cpp/string/basic_string_view">https://en.cppreference.com/w/cpp/string/basic_string_view</a></p><p>如果我们只需要一个string的只读类型的话，可以用string_view来托管。其内部只包含一个指向目标字符串的指针，以及字符串的长度。</p><p>string_view内部封装了string的所有只读接口，本来就是给你读的。</p><p>需要注意的是，因为内部只有一个指针，所以当string_view托管的string被销毁了，与之关联的所有string_view都会失效！同样是因为内部只有一个指针和字符串的长度两个变量，所以在传值拷贝的时候，string_view的效率会高很多。</p><ul><li>这和<code>const string&amp;</code> 类型的传值又有什么区别呢？传引用不是也没有拷贝消耗吗？</li></ul><p>这个问题很好，我不知道！百度也没有百度出来……</p><p>我能想到的就是用<code>string_view</code>作为参数的时候，如果入参是一个常量字符串，此时不需要构造string，而使用<code>const string&amp;</code> 接受常量字符串的时候依旧需要构造一个string对象。这部分就会有一定的消耗。</p><h1 id="17-as-const"><a href="#17-as-const" class="headerlink" title="17.as_const"></a>17.as_const</h1><p>C++17使用as_const可以将左值转成const类型</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">std::string str = <span class="string">&quot;str&quot;</span>;</span><br><span class="line"><span class="type">const</span> std::string&amp; constStr = std::<span class="built_in">as_const</span>(str);</span><br></pre></td></tr></table></figure><h1 id="18-file-system"><a href="#18-file-system" class="headerlink" title="18.file_system"></a>18.file_system</h1><p>C++17正式将file_system纳入标准中，提供了关于文件的大多数功能，基本上应有尽有，这里简单举几个例子：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> fs = std::filesystem;</span><br><span class="line">fs::<span class="built_in">create_directory</span>(dir_path); <span class="comment">// 创建文件或者路径</span></span><br><span class="line">fs::<span class="built_in">copy_file</span>(src, dst, fs::copy_options::skip_existing); <span class="comment">// 文件cp</span></span><br><span class="line">fs::<span class="built_in">exists</span>(filename); <span class="comment">// 文件是否存在</span></span><br><span class="line">fs::<span class="built_in">current_path</span>(err_code); <span class="comment">// 获取当前路径</span></span><br></pre></td></tr></table></figure><h1 id="19-shared-mutex"><a href="#19-shared-mutex" class="headerlink" title="19.shared_mutex"></a>19.shared_mutex</h1><p>这玩意是个读写锁。简单介绍一下什么是读写锁：</p><ul><li>读者可以有多个，写者只能有一个</li><li>写锁是互斥的，如果A有锁，B想拿锁就得阻塞等待</li><li>读锁是共享的，C有读锁，D也想读，两个人可以一起看</li><li>读写锁是互斥的，有人写的时候不能读，有人读的时候不能写</li></ul><p>换到专业术语上，就是分为独占锁（写锁）和共享锁（读锁）；</p><p>在C++14中其实已经有了一个<code>shared_timed_mutex</code>，C++17中这个锁的操作与其基本一致，只不过多了几个和时间相关的接口</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">try_lock_for</span>(...);</span><br><span class="line"><span class="built_in">try_lock_shared_for</span>(...);</span><br><span class="line"><span class="built_in">try_lock_shared_until</span>(...);</span><br><span class="line"><span class="built_in">try_lock_until</span>(...);</span><br></pre></td></tr></table></figure><p>具体使用可以参考 </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">https://zh.cppreference.com/w/cpp/thread/shared_mutex</span><br><span class="line">https://zhuanlan.zhihu.com/p/610781321</span><br></pre></td></tr></table></figure><h1 id="The-end"><a href="#The-end" class="headerlink" title="The end"></a>The end</h1><p>关于C++17常用的基本就是这些了，后续遇到新的再更新本文。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;学习C++17的新特性&lt;/p&gt;
&lt;h1 id=&quot;1-构造函数模板推导&quot;&gt;&lt;a href=&quot;#1-构造函数模板推导&quot; class=&quot;headerlink&quot; title=&quot;1.构造函数模板推导&quot;&gt;&lt;/a&gt;1.构造函数模板推导&lt;/h1&gt;&lt;p&gt;在之前，我们如果想用stl容器，都需要</summary>
      
    
    
    
    <category term="遇见C++" scheme="https://blog.musnow.top/categories/%E9%81%87%E8%A7%81C/"/>
    
    
    <category term="C++" scheme="https://blog.musnow.top/tags/C/"/>
    
    <category term="数据结构" scheme="https://blog.musnow.top/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    <category term="C++17" scheme="https://blog.musnow.top/tags/C-17/"/>
    
  </entry>
  
  <entry>
    <title>【面经】230915上海戎磐网络科技C/LINUX实习生</title>
    <link href="https://blog.musnow.top/posts/2553205100/"/>
    <id>https://blog.musnow.top/posts/2553205100/</id>
    <published>2023-09-15T06:50:14.000Z</published>
    <updated>2023-09-15T06:50:14.000Z</updated>
    
    <content type="html"><![CDATA[<p>10分钟就面完了，堪称急速，面试官说我答的不错；而且上来自我介绍完毕后就问问题，不多比比🤣</p><span id="more"></span><h1 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h1><h2 id="1-Linux下线程互斥怎么实现"><a href="#1-Linux下线程互斥怎么实现" class="headerlink" title="1.Linux下线程互斥怎么实现"></a>1.Linux下线程互斥怎么实现</h2><p>加锁，pthread，然后我还提到了cpp的原子变量</p><p><a href="https://blog.musnow.top/posts/1309150756/">https://blog.musnow.top/posts/1309150756/</a></p><h2 id="2-CPP多态怎么实现"><a href="#2-CPP多态怎么实现" class="headerlink" title="2.CPP多态怎么实现"></a>2.CPP多态怎么实现</h2><p>虚函数表，巴拉巴拉</p><p><a href="https://blog.musnow.top/posts/3933786088/">https://blog.musnow.top/posts/3933786088/</a></p><h2 id="3-CPP为啥要引入模板"><a href="#3-CPP为啥要引入模板" class="headerlink" title="3.CPP为啥要引入模板"></a>3.CPP为啥要引入模板</h2><p>代码更高复用</p><p><a href="https://blog.musnow.top/posts/2940029419/">https://blog.musnow.top/posts/2940029419/</a></p><h2 id="4-NAT怎么实现的？"><a href="#4-NAT怎么实现的？" class="headerlink" title="4.NAT怎么实现的？"></a>4.NAT怎么实现的？</h2><p>转化表，IP地址替换，巴拉巴拉吧说一大堆</p><p><a href="https://blog.musnow.top/posts/3482559497/">https://blog.musnow.top/posts/3482559497/</a></p><h2 id="5-进程通信"><a href="#5-进程通信" class="headerlink" title="5.进程通信"></a>5.进程通信</h2><p>老问题了</p><h2 id="6-inet-ntoa函数知道吗？连续调用会有什么问题？"><a href="#6-inet-ntoa函数知道吗？连续调用会有什么问题？" class="headerlink" title="6.inet_ntoa函数知道吗？连续调用会有什么问题？"></a>6.inet_ntoa函数知道吗？连续调用会有什么问题？</h2><blockquote><p>这是最后一个问题，面试官说我答的挺好的</p></blockquote><p>我先说了这个函数是用于16位IP地址和字符串的转换的；</p><p>然后面试官这里问了一个业务上的问题</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s %s\n&quot;</span>,<span class="built_in">inet_ntoa</span>(x),<span class="built_in">inet_ntoa</span>(y));<span class="comment">// x和y是两个ip地址</span></span><br></pre></td></tr></table></figure><p>这个函数会不会有什么错误的地方？</p><blockquote><p>请注意，这里是面试时候的描述，面试官肯定只能给你描述个大概的，并不会细致到具体的传参应该传什么类型的变量，所以传参x和y也只是个伪代码，想问的地方不在这里！</p></blockquote><p>这里我说了<code>inet_ntoa</code>是采用static变量来返回ip字符串的，线程不安全，有可能两个调用最终返回了一个相同的IP地址，又明说了我不确定；（肯定有问题，不然问你干嘛？）</p><hr><p>面试结束了，来测试一下到底是啥情况吧！</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">in_addr</span> ip1;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">in_addr</span> ip2;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">inet_aton</span>(<span class="string">&quot;192.168.3.1&quot;</span>,&amp;ip1);</span><br><span class="line">    <span class="built_in">inet_aton</span>(<span class="string">&quot;10.161.33.42&quot;</span>,&amp;ip2);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s %s\n&quot;</span>,<span class="built_in">inet_ntoa</span>(ip1),<span class="built_in">inet_ntoa</span>(ip2));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果如下，两个IP地址返回了同一个，我猜对了；</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ ./test</span><br><span class="line">192.168.3.1 192.168.3.1</span><br></pre></td></tr></table></figure><p>为什么呢？打印一下地址，会得到如下输出，两次调用返回了相同的地址，自然打印出来的结果相同；</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%x %x\n&quot;</span>,<span class="built_in">inet_ntoa</span>(ip1),<span class="built_in">inet_ntoa</span>(ip2));</span><br><span class="line"><span class="comment">//68db1ef0 68db1ef0</span></span><br></pre></td></tr></table></figure><p>对于这个函数而言，它需要给我们返回一个字符串，又必须保证这个字符串能在函数外被正常访问（不能被释放），再加上这是一个C语言接口，那么就只有三种方案了</p><ul><li>函数里面malloc，需要用户手动free</li><li>static变量</li><li>让用户传入一个有效的地址，将数据写入作为输出型参数</li></ul><p>第一个方案肯定是不可行的！这相当于官方提供了一个<strong>极其容易导致内存泄漏</strong>的接口！这不得被开发者喷死？比如本题提到的场景里面就是两次printf而已，除此之外没有保存这个返回值，更别提free了，这里就直接两次内存泄漏了！</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s %s\n&quot;</span>,inet_ntoa(ip1),inet_ntoa(ip2));</span><br><span class="line"><span class="comment">// 如果用malloc后的字符串地址做返回值，这里就是两个内存泄漏</span></span><br></pre></td></tr></table></figure><p>第三个方案也不方便，系统依赖用户传入一个数组的入参，我们知道ipv4的IP地址字符串最长是<code>3*4+3=15</code>位，那么如果用户只传入一个<code>char arr[12]</code>呢？越界访问的问题怎么解决？相当于系统之中依旧会出现参数不匹配而可能导致的地址访问错误！</p><p><strong>而这个函数本身的工作很简单，完全没必要弄那么复杂</strong>；</p><p>最终linux系统采用了static变量的方式，来返回这个IP地址的字符串；man手册里面是这么说的，直接看最后一句，翻译过来的意思是<strong>后续的调用会覆盖掉前面的值</strong>；</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"> The inet_ntoa() function converts the Internet host address in, </span><br><span class="line"> given in network byte order, to a string in IPv4 dotted-decimal notation.  </span><br><span class="line"> The string  is returned in a statically allocated buffer,</span><br><span class="line">which subsequent calls will overwrite.</span><br></pre></td></tr></table></figure><p>所以最终我们看到的结果就是两次打印出了相同的IP地址；</p><p>这里还涉及到第二个知识点，<a href="https://blog.musnow.top/posts/3888883052/">printf的传参顺序</a>;</p><p>简单说来就是printf是从右往左执行的（其实所有函数的传参都是这样，这也是为什么缺省值要从右边往左给）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s %s\n&quot;</span>,<span class="built_in">inet_ntoa</span>(ip1),<span class="built_in">inet_ntoa</span>(ip2));</span><br></pre></td></tr></table></figure><p>这里的执行顺序如下</p><ul><li>ip2结构体传给函数，转成ip地址字符串后存在static变量中</li><li>ip1结构体传给函数，转成ip地址字符串后存在了static变量中，覆盖了ip2的结果</li></ul><p>最终打印出来的两个字符串都是ip1的地址！</p><p>对于<code>inet_aton</code>函数而言，<strong>正确的调用</strong>办法是每次调用后都取走返回的IP地址字符串，可以用<code>std::string</code>接收，也可以用strcmp拷贝到一个自己定义的字符串数组变量中；</p><p>你学会了吗，骚年？</p><blockquote><p><code>inet_aton</code>这个函数最早出现于本站的此博客：<a href="https://blog.musnow.top/posts/368672249/">【Linux】来写一个udp的服务端+客户端</a></p></blockquote><h1 id="项目"><a href="#项目" class="headerlink" title="项目"></a>项目</h1><p>因为是cpp的岗位，所以没有问python的机器人项目问题；</p><h2 id="1-视频点播传一半关闭了怎么解决"><a href="#1-视频点播传一半关闭了怎么解决" class="headerlink" title="1.视频点播传一半关闭了怎么解决"></a>1.视频点播传一半关闭了怎么解决</h2><p>两次面试都问到了这个问题，我提到了将新的文件和本地已有文件进行校验，跳过已有数据</p><h2 id="2-传一半剩下的数据后端怎么处理，什么时候删除？"><a href="#2-传一半剩下的数据后端怎么处理，什么时候删除？" class="headerlink" title="2.传一半剩下的数据后端怎么处理，什么时候删除？"></a>2.传一半剩下的数据后端怎么处理，什么时候删除？</h2><p>我提到了前后端用md5验证来确认视频文件无误，如果有问题，可以设置一个定时器，一小时后删除错误的数据</p><h2 id="3-用户修改了视频后上传怎么处理？"><a href="#3-用户修改了视频后上传怎么处理？" class="headerlink" title="3.用户修改了视频后上传怎么处理？"></a>3.用户修改了视频后上传怎么处理？</h2><p>同第一个，进行一定的数据校验，然后再复写没有的数据；</p><blockquote><p>然而这些功能我一个都没有实现🤣</p></blockquote><h1 id="效率"><a href="#效率" class="headerlink" title="效率"></a>效率</h1><p>面经还没写完，结果已经出啦，过了初试！但是要线下复试；</p>]]></content>
    
    
    <summary type="html">230915上海戎磐网络科技C/LINUX实习生</summary>
    
    
    
    <category term="求职路上一去不复返" scheme="https://blog.musnow.top/categories/%E6%B1%82%E8%81%8C%E8%B7%AF%E4%B8%8A%E4%B8%80%E5%8E%BB%E4%B8%8D%E5%A4%8D%E8%BF%94/"/>
    
    
    <category term="面经" scheme="https://blog.musnow.top/tags/%E9%9D%A2%E7%BB%8F/"/>
    
  </entry>
  
  <entry>
    <title>【MySQL】字节跳动MySQL连环40问</title>
    <link href="https://blog.musnow.top/posts/3873856211/"/>
    <id>https://blog.musnow.top/posts/3873856211/</id>
    <published>2023-09-15T00:52:14.000Z</published>
    <updated>2023-09-15T00:52:30.000Z</updated>
    
    <content type="html"><![CDATA[<p>字节MySQL连环40问，网图</p><span id="more"></span><p><img src="https://img.musnow.top/i/2023/09/188abb653b96cb823385befe4c196698.jpg" alt="QQ图片20230915081943"></p><p>虽然感觉这玩意和字节跳动没关系，但是管他的？直接开始回答！</p><h1 id="1-MySQL中有哪几种锁？"><a href="#1-MySQL中有哪几种锁？" class="headerlink" title="1.MySQL中有哪几种锁？"></a>1.MySQL中有哪几种锁？</h1><blockquote><p>会的不全，所以查的GPT</p></blockquote><p>MySQL中有多种类型的锁，主要包括以下几种：</p><ol><li>共享锁（Shared Lock）：也称为<strong>读锁</strong>，多个会话可以同时持有共享锁，并且不互斥。共享锁适用于读取操作，多个会话可以并发读取同一份数据而不会产生冲突。</li><li>排他锁（Exclusive Lock）：也称为<strong>写锁</strong>，排他锁与其他任何锁都互斥，只有一个会话可以持有排他锁。排他锁适用于写入或修改操作，确保在某个会话持有排他锁的时候，其他会话无法同时进行写入操作。</li><li>记录锁（Record Lock）：记录锁（<strong>行锁</strong>）是针对某条记录的锁定，用于保护特定记录的完整性。在使用InnoDB存储引擎时，读取或修改某条记录时会自动给该记录加上记录锁，其他会话则无法对该记录进行并发写入或删除操作。</li><li>Gap锁：Gap锁是InnoDB引擎的一种锁机制，<strong>用于防止幻读</strong>。它锁定了一个范围，但不包含实际的记录，用于防止其他会话在这个范围内插入新记录，以避免幻读现象的发生。</li><li>表锁（Table Lock）：表锁是对整个表格进行锁定，可以在某些特殊情况下使用，但会阻塞其他会话的读取和写入操作。在需要并发读写的情况下，表锁的性能较低，因此一般不推荐使用。</li></ol><p>除此之外，还有一个NEXT-KEY锁：</p><p>NEXT-KEY 锁是 InnoDB 存储引擎中的一种锁机制，用于<strong>解决幻读</strong>问题。它是通过将 Gap 锁和 记录锁 组合而成的。</p><p>具体来说，当一个事务在 InnoDB 表中执行范围查询时，如使用 <code>&lt;</code>、<code>&lt;=</code>、<code>&gt;</code>、<code>&gt;=</code> 等操作符，InnoDB 引擎会为查询涉及到的范围加上 NEXT-KEY 锁。这个 NEXT-KEY 锁包含两部分：</p><ol><li>Gap 锁：锁定了查询范围内的间隙（Gap），防止其他事务向该范围内插入新的记录。</li><li>记录锁：锁定了满足查询条件的记录，防止其他事务对这些记录进行并发修改或删除。</li></ol><p>通过使用 NEXT-KEY 锁，InnoDB 可以有效地避免幻读现象的发生。它保证了在一个事务读取一个范围的数据时，<strong>其他事务无法并发地在该范围内插入新的记录</strong>，从而保证了读取的一致性。</p><p>需要注意的是，NEXT-KEY 锁只在事务隔离级别为<strong>可重复读</strong>（REPEATABLE READ）或更高级别时使用（MySQL默认隔离级别为可重复读）。在较高的并发环境下，使用 NEXT-KEY 锁可能会增加锁冲突的概率，因此在设计数据库和查询时需要考虑到锁的开销和事务的隔离级别。</p><h1 id="2-MySQL中有哪些不同的表格？"><a href="#2-MySQL中有哪些不同的表格？" class="headerlink" title="2.MySQL中有哪些不同的表格？"></a>2.MySQL中有哪些不同的表格？</h1><blockquote><p>这个也是GPT回答的，注意，表格和存储引擎不是同一个概念！</p></blockquote><p>在MySQL中，有以下几种不同的表格类型：</p><ol><li>MyISAM：MyISAM是旧版本MySQL的默认表格类型。它提供了快速的读取速度，适用于大量的并发读取操作。不过，MyISAM不支持事务处理和崩溃恢复功能。</li><li>InnoDB：InnoDB是一种支持事务处理和崩溃恢复功能的表格类型。它提供了行级锁定和外键约束等高级功能，适用于需要数据完整性和并发写入操作的场景。InnoDB是<strong>MySQL 5.5版本后</strong>的默认表格类型。</li><li>Memory：Memory（也称为Heap）表格是将数据存储在内存中的临时表格类型。它在读取和写入方面非常快速，但它的数据是临时的，当数据库服务器重启时，表格中的数据将会丢失。</li><li>Archive：Archive表格是一种高度压缩的表格类型，适用于存储大量历史数据和归档数据。它对于读取操作不太有效，但在大量写入和存储空间方面具有优势。</li><li>CSV：CSV表格允许将数据以CSV（逗号分隔值）格式存储在文件中，支持导入和导出数据。它不支持索引，事务处理和其他高级特性。</li></ol><p>除了以上列举的几种常见的表格类型外，MySQL还支持其他一些特殊用途的表格类型，如Partitioned（分区表格）和Federated（联合表格）等。</p><ul><li>表格和存储引擎是同一个东西吗？并<strong>不是</strong>！</li></ul><p>在关系型数据库中，表格（Table）是指一个逻辑上的数据结构，用来组织和存储数据。一张表格由若干列（Column）和若干行（Row）组成，每列定义了一种数据类型和一个字段名，表格中的每一行则代表一个实体或记录，每个单元格存储着对应列的一个数值或字符串。</p><p>存储引擎（Storage Engine）则是指实现了数据库的表格和索引等功能的底层软件模块，它负责将表格数据存储到磁盘、跟踪并处理事务、执行查询语句等任务。不同的存储引擎具有各自的特点和优缺点，在不同场景下选择合适的存储引擎可以提高数据库的性能和可靠性。</p><h1 id="3-MyISAM和InnoDB的区别？"><a href="#3-MyISAM和InnoDB的区别？" class="headerlink" title="3.MyISAM和InnoDB的区别？"></a>3.MyISAM和InnoDB的区别？</h1><p>MyISAM</p><ul><li>不支持事务；</li><li>采用非聚簇索引，普通索引和主键索引的形式相同；</li><li>一张表包含三个本地文件；</li></ul><p>InnoDB</p><ul><li>支持事务；</li><li>采用聚簇索引，普通索引存放的是主键索引中的key值，需要回表查询；可以用索引覆盖来优化；</li><li>一张表包含两个本地文件；</li></ul><h1 id="4-InnoDB支持的四种事务隔离级别和区别"><a href="#4-InnoDB支持的四种事务隔离级别和区别" class="headerlink" title="4.InnoDB支持的四种事务隔离级别和区别"></a>4.InnoDB支持的四种事务隔离级别和区别</h1><p>四种隔离级别：读未提交，读已提交，可重复读，串行化；</p><p>这部分直接去看我的<a href="https://blog.musnow.top/posts/3474107655/">MySQL索引</a>博客，里面详细介绍了区别，这里就不重写一遍了；</p><h1 id="5-CHAR和VARCHAR的区别"><a href="#5-CHAR和VARCHAR的区别" class="headerlink" title="5.CHAR和VARCHAR的区别"></a>5.CHAR和VARCHAR的区别</h1><ul><li>char是定长字符串，最长255；varchar是变长字符串，最长65535；</li><li>这就意味着varchar需要更多空间来存放当前字符串长度等信息，并且会根据当前字符串长度动态开辟空间大小，不会有额外的存储空间浪费；</li><li>而char是定死的空间，<code>char(8)</code>里面即便只有一个字符也会占用八个的空间（会用空格进行补齐）；</li><li>在字符串长度确定的情况下，比如计算长度确定的MD5，那就可以用char定长存储；长度不确定的情况下，比如人名、邮箱等信息，可以采用varchar；</li></ul><p>顺带说一下varchar和text的区别；需要进行索引的长文可以用TEXT进行存储（注意，只有MyISAM支持全文索引）</p><ol><li>存储空间：VARCHAR列存储的内容长度是可变的，而TEXT列可以存储大量的可变长度的文本数据。VARCHAR在存储时会根据实际存储的内容长度进行调整，而TEXT没有固定的最大长度限制，可以用来存储非常长的文本。由于TEXT可以存储更大的数据量，因此它通常占用更多的存储空间。</li><li>查询性能：由于VARCHAR具有固定的最大长度限制，数据库可以更好地优化和管理存储空间，这可能会在某些情况下提升查询性能。而TEXT由于其可变长度和大容量，可能会对某些查询操作稍有影响。</li><li>索引和排序：VARCHAR可以被索引和排序，这意味着可以根据这些列进行快速搜索和排序操作。而TEXT类型通常不直接支持索引和排序，需要额外的配置和处理才能实现类似的功能。</li></ol><p>如下user1表做测试，会发现我们无法给TEXT类型上普通索引。给出的提示是，<code>BLOG/TEXT</code>类型不能在没有指定长度的时候上索引；因为你的长度不确定，如果MySQL将一个几万字的TEXT存到内存里面作为索引节点，那么就会占用过多的内存空间。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">MariaDB [hello_mysql]&gt; desc user1;</span><br><span class="line">+-------+------------------+------+-----+---------+-------+</span><br><span class="line">| Field | Type             | Null | Key | Default | Extra |</span><br><span class="line">+-------+------------------+------+-----+---------+-------+</span><br><span class="line">| id    | int(10) unsigned | NO   | PRI | NULL    |       |</span><br><span class="line">| name  | varchar(200)     | NO   |     | NULL    |       |</span><br><span class="line">| info  | text             | NO   |     | NULL    |       |</span><br><span class="line">+-------+------------------+------+-----+---------+-------+</span><br><span class="line">3 rows in set (0.001 sec)</span><br><span class="line">MariaDB [hello_mysql]&gt; alter table user1 add index(info);</span><br><span class="line">ERROR 1170 (42000): BLOB/TEXT column &#x27;info&#x27; used in key specification without a key length</span><br></pre></td></tr></table></figure><p>即便在创建列的时候给定了TEXT的长度，依旧不能创建索引。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">MariaDB [hello_mysql]&gt; alter table user1 add info1 TEXT(20) NOT NULL;</span><br><span class="line">Query OK, 0 rows affected (0.002 sec)</span><br><span class="line">Records: 0  Duplicates: 0  Warnings: 0</span><br><span class="line"></span><br><span class="line">MariaDB [hello_mysql]&gt; desc user1;</span><br><span class="line">+-------+------------------+------+-----+---------+-------+</span><br><span class="line">| Field | Type             | Null | Key | Default | Extra |</span><br><span class="line">+-------+------------------+------+-----+---------+-------+</span><br><span class="line">| id    | int(10) unsigned | NO   | PRI | NULL    |       |</span><br><span class="line">| name  | varchar(200)     | NO   |     | NULL    |       |</span><br><span class="line">| info  | text             | NO   |     | NULL    |       |</span><br><span class="line">| info1 | tinytext         | NO   |     | NULL    |       |</span><br><span class="line">+-------+------------------+------+-----+---------+-------+</span><br><span class="line">4 rows in set (0.001 sec)</span><br><span class="line"></span><br><span class="line">MariaDB [hello_mysql]&gt; alter table user1 add index(info1);</span><br><span class="line">ERROR 1170 (42000): BLOB/TEXT column &#x27;info1&#x27; used in key specification without a key length</span><br></pre></td></tr></table></figure><p>正确的写法如下，需要在创建索引的时候，括号指定索引的长度；比如<code>index(info1(10))</code>含义就是给info1列的前10个字符建立索引。只要TEXT里面存放的文本前10个字符重复率低，那么这个索引就是有意义的！</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">MariaDB [hello_mysql]&gt; alter table user1 add index(info1(10));</span><br><span class="line">Query OK, 0 rows affected (0.007 sec)</span><br><span class="line">Records: 0  Duplicates: 0  Warnings: 0</span><br></pre></td></tr></table></figure><h1 id="6-主键和候选键-码-有啥区别？"><a href="#6-主键和候选键-码-有啥区别？" class="headerlink" title="6.主键和候选键(码)有啥区别？"></a>6.主键和候选键(码)有啥区别？</h1><p>候选键是一些可以选用（备选）为主键或者唯一键的类型；</p><p>比如一个学生表里面，包含学生主键的INT自增ID，学生学号，学生身份证，学生姓名，学生性别等等信息；在这个表里面，除了主键这个INT的ID，我们还可以把学生的学号和学生的身份证作为主键或者唯一键，因为他们都包含唯一性！</p><p>这时候，这些可以作为主键的列，就叫做候选键；</p><ul><li>候选键也需要保持唯一性</li><li>候选键需要遵循最小原则，不能是某一个聚合唯一标识的子集；（比如我需要用<strong>部门ID和部门内员工ID</strong>来唯一标识一个员工，此时部门ID就不能作为这个员工表的候选键，因为在整个表中部门ID会重复）</li></ul><p>在《数据库系统概率》这门课里面，会把键称作为码，本质上是一个东西。</p><blockquote><p>到底是谁把key翻译成码的？真无语😒</p></blockquote><h1 id="7-myisamchk是用来干什么的"><a href="#7-myisamchk是用来干什么的" class="headerlink" title="7.myisamchk是用来干什么的"></a>7.myisamchk是用来干什么的</h1><p>一个命令行工具（在bash下使用，不是在MySQL命令行使用）</p><blockquote><p>Myisamchk是MyISAM表维护的一个非常实用的工具。可以使用myisamchk实用程序来获得有关数据库表的信息或检查、修复、优化他们。myisamchk适用MyISAM表(对应.MYI和.MYD文件的表)。</p></blockquote><p>这个命令了解即可，下面是两篇使用博客。有需要再去深入学习用法</p><p><a href="http://www.4u4v.net/myisamchk-gadgets-manual.html">http://www.4u4v.net/myisamchk-gadgets-manual.html</a></p><p><a href="https://www.cnblogs.com/analyzer/articles/1381538.html">https://www.cnblogs.com/analyzer/articles/1381538.html</a></p><h1 id="8-如果表中有一列定义为TIMESTAMP会发生什么"><a href="#8-如果表中有一列定义为TIMESTAMP会发生什么" class="headerlink" title="8.如果表中有一列定义为TIMESTAMP会发生什么"></a>8.如果表中有一列定义为TIMESTAMP会发生什么</h1><p>TIMESTAMP底层一般是4个字节，在MySQL里面进行查询的时候，会根据系统时区，转成可读时间进行输出。包括使用cpp devel包获取到的也是可读时间；</p><p>因为只有4个字节，所以TIMESTAMP最多能表示 <code>1970-01-01 00:00:01</code>到<code>2038-01-19 03:14:07</code>，这也是一个2038年问题，需要改成8字节存储才能存放更长的时间。</p><p>另外，如果你想更加精确的标识时间，而不依赖于MySQL对时间戳的自动转换，那么就可以用BIGINT或者DECIMAL类型来存放时间戳数字，再在应用层进行时间戳和可读时间之间的转换。</p><h1 id="9-怎么看到表格定义的所有索引"><a href="#9-怎么看到表格定义的所有索引" class="headerlink" title="9.怎么看到表格定义的所有索引"></a>9.怎么看到表格定义的所有索引</h1><p>两种方式都可以</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> index <span class="keyword">from</span> 表名;</span><br><span class="line"><span class="keyword">show</span> keys <span class="keyword">from</span> 表名;</span><br></pre></td></tr></table></figure><h1 id="10-LIKE声明中的-是什么意思"><a href="#10-LIKE声明中的-是什么意思" class="headerlink" title="10.LIKE声明中的%是什么意思"></a>10.LIKE声明中的%是什么意思</h1><p>代表通配符，匹配所有字符串。下面举几个例子</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">查询 &#x27;张%&#x27;</span><br><span class="line">    张丽丽</span><br><span class="line">    张扣扣</span><br><span class="line">    张三</span><br><span class="line">    张阿斯顿</span><br><span class="line"></span><br><span class="line">查询 &#x27;%张%&#x27;</span><br><span class="line">里张里</span><br><span class="line">    十大张撒打发</span><br><span class="line"></span><br><span class="line">查询 &#x27;%张&#x27;</span><br><span class="line">xx张</span><br><span class="line">xxxxx张</span><br></pre></td></tr></table></figure><p>需要注意，只有<code>关键字%</code>的使用方式才能用上索引，另外两种匹配方式无法使用索引！</p><h1 id="11-列对比运算符是什么"><a href="#11-列对比运算符是什么" class="headerlink" title="11.列对比运算符是什么"></a>11.列对比运算符是什么</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">等于 =</span><br><span class="line">不等于 &lt;&gt; !=</span><br><span class="line">大于和大于等于  &gt; &gt;=</span><br><span class="line">小于和小于等于  &lt; &lt;=</span><br><span class="line">区间 BETWEEN .. AND ...</span><br><span class="line">是否在列表中 IN</span><br><span class="line">模糊匹配 LIKE</span><br><span class="line">NULL比较 IS NULL, IS NOT NULL</span><br></pre></td></tr></table></figure><h1 id="12-BLOB和TEXT有什么区别？"><a href="#12-BLOB和TEXT有什么区别？" class="headerlink" title="12.BLOB和TEXT有什么区别？"></a>12.BLOB和TEXT有什么区别？</h1><p>GPT说的：</p><ol><li>存储容量：BLOB可以存储二进制数据，而TEXT只能存储纯文本数据。</li><li>字符集排序规则：BLOB没有字符集排序规则，而TEXT有，默认为字符集的排序规则。</li><li>数据排序和比较：BLOB会按二进制方式进行排序和比较，而TEXT会按字符排序规则进行排序和比较。</li><li>存储方式：BLOB数据以二进制形式存储，没有字符集转换；而TEXT数据会根据字符集进行转换和存储。</li><li>索引：在MySQL中，BLOB和TEXT列可以有索引，但有一些限制。BLOB列或前缀索引的最大长度是768字节，对于UTF-8字符集是255个字符。而TEXT列或前缀索引的最大长度是3072字节，在UTF-8字符集中是1024个字符。</li><li>默认值：BLOB和TEXT列不能具有默认值。</li></ol><p>总的来说，BLOB适合存储二进制数据，例如图像、音频或视频文件等。而TEXT适合存储纯文本数据，如长文本、文章内容等。根据具体的需求，你可以选择适当的数据类型来存储相应的数据。</p><blockquote><p>实际上，把图片、音频这些静态资源存入数据库是不合理的……</p></blockquote><h1 id="13-MySQL-fetch-array和MySQL-fetch-obj有什么区别？"><a href="#13-MySQL-fetch-array和MySQL-fetch-obj有什么区别？" class="headerlink" title="13.MySQL_fetch_array和MySQL_fetch_obj有什么区别？"></a>13.MySQL_fetch_array和MySQL_fetch_obj有什么区别？</h1><p>PHP里面的函数，不学，直接跳过</p><h1 id="14-MyISAM表格将在那里存储？并且还提供其存储格式？"><a href="#14-MyISAM表格将在那里存储？并且还提供其存储格式？" class="headerlink" title="14.MyISAM表格将在那里存储？并且还提供其存储格式？"></a>14.MyISAM表格将在那里存储？并且还提供其存储格式？</h1><p>在linux下，MyISAM表格以文件形式存储在数据目录下的对应数据库目录中。每个表格对应一个.MYD数据文件（用于存储表格数据）和一个.MYI索引文件（用于存储表格索引），以及一个.frm表格定义文件（包含表格定义信息，如字段名、数据类型等）</p><p>MyISAM使用一种称为“静态行格式”的存储格式来存储表格数据。这种格式用于在磁盘上保存由定长行组成的表格，每个行定长，占用相同的存储空间，以便更快地读取和写入数据。MyISAM表格还支持动态行格式，这种格式允许可变行长度，因此可以更有效地存储可变长度的数据类型（如VARCHAR，TEXT等）。</p><h1 id="15-MySQL如何优化DISTINCT"><a href="#15-MySQL如何优化DISTINCT" class="headerlink" title="15.MySQL如何优化DISTINCT?"></a>15.MySQL如何优化DISTINCT?</h1><p>使用索引，减少查询行数来优化去重操作</p><h1 id="16-如何显示前50行？"><a href="#16-如何显示前50行？" class="headerlink" title="16.如何显示前50行？"></a>16.如何显示前50行？</h1><p>查询语句后带上limit就可以</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> 表名 limit <span class="number">50</span>;</span><br></pre></td></tr></table></figure><h1 id="17-可以使用多少列创建索引？"><a href="#17-可以使用多少列创建索引？" class="headerlink" title="17.可以使用多少列创建索引？"></a>17.可以使用多少列创建索引？</h1><p>根据实际使用场景来确定用几列，并没有固定限制。理论上来说需要保持最小原则，不要包含多余的无效列（除非你需要用来进行索引优化，减少回表操作）</p><h1 id="18-now和current-date有什么区别？"><a href="#18-now和current-date有什么区别？" class="headerlink" title="18.now和current_date有什么区别？"></a>18.now和current_date有什么区别？</h1><p>now会返回一直到时分秒的信息，current_date只会返回当日日期</p><h1 id="19-什么是非标准字符串类型"><a href="#19-什么是非标准字符串类型" class="headerlink" title="19.什么是非标准字符串类型"></a>19.什么是非标准字符串类型</h1><blockquote><p>GPT</p></blockquote><p>非标准字符串类型是指在数据库中没有明确定义或标准化的字符串数据类型。这些类型通常是特定数据库管理系统（DBMS）或应用程序开发框架所支持的扩展。由于不同的DBMS和框架有各自的特性和需求，可能会引入额外的非标准字符串类型以满足特定的数据存储和操作需求。</p><p>举例来说，MySQL数据库在其标准字符串类型中包含了CHAR、VARCHAR、TEXT等。而非标准字符串类型可能是根据具体需求和扩展开发的，如JSON、XML、BLOB、CLOB等。这些非标准类型在一些特定场景中使用广泛，例如存储非结构化的文本数据、大型二进制数据、以及存储和查询复杂的结构化数据等。</p><p>需要注意的是，非标准字符串类型在不同的DBMS和开发框架之间可能存在差异，并且在跨平台和迁移时可能会出现兼容性问题。因此，在使用非标准字符串类型时，建议仔细了解相关的文档和规范，并评估其对应用程序的影响和可移植性。</p><h1 id="20-什么是通用SQL函数"><a href="#20-什么是通用SQL函数" class="headerlink" title="20.什么是通用SQL函数"></a>20.什么是通用SQL函数</h1><p>以下列举了一些常见的通用SQL函数：</p><ol><li>聚合函数：如SUM、AVG、COUNT、MIN、MAX等，用于对数据进行统计和聚合计算。</li><li>字符串函数：如CONCAT、SUBSTRING、UPPER、LOWER、LENGTH等，用于处理和操作字符串数据。</li><li>数值函数：如ABS、ROUND、CEILING、FLOOR等，用于执行数值计算和转换。</li><li>日期和时间函数：如DATE, TIME, YEAR, MONTH, DAY等，用于处理日期和时间数据的计算和格式化。</li><li>条件函数：如IF, CASE WHEN, COALESCE等，用于根据条件执行不同的逻辑和返回不同的结果。</li><li>类型转换函数：如CAST、CONVERT等，用于在不同的数据类型之间进行转换。</li></ol><p>这只是一小部分通用SQL函数的例子，实际上还有很多其他的函数可用于不同的数据处理和查询需求。需要注意的是，尽管这些函数在大多数DBMS中都存在，但某些特定的DBMS可能会提供额外的函数或有稍微不同的语法，因此在使用函数时应查阅相应的文档和规范以确保兼容性和正确性。</p><h1 id="21-MySQL支持事务吗？"><a href="#21-MySQL支持事务吗？" class="headerlink" title="21.MySQL支持事务吗？"></a>21.MySQL支持事务吗？</h1><p>肯定支持，这个问题第四点就已经详细问了</p><h1 id="22-MySQL里面记录货币用什么类型好？"><a href="#22-MySQL里面记录货币用什么类型好？" class="headerlink" title="22.MySQL里面记录货币用什么类型好？"></a>22.MySQL里面记录货币用什么类型好？</h1><p>因为浮点数的精度问题，可以用BIGINT来存放以<strong>分</strong>为单位的货币，实际调用的时候再加上小数点，来保证数据准确。</p><p>如果不用BIGINT，那就需要用DECIMAL来存放货币。</p><blockquote><p>B站冲浪看到的</p></blockquote><h1 id="23-MySQL有关权限的表有那几个"><a href="#23-MySQL有关权限的表有那几个" class="headerlink" title="23.MySQL有关权限的表有那几个"></a>23.MySQL有关权限的表有那几个</h1><p>在MySQL中，有几个与权限相关的系统表和视图，用于管理用户、角色和权限。以下是一些常见的权限相关的表和视图：</p><ol><li>mysql.user：这个表包含了MySQL实例上的所有用户账户信息，包括用户名、密码等。该表记录了每个用户的全局权限。</li><li>mysql.db：这个表记录了用户对数据库级别的权限。它指定了哪个用户对哪个数据库具有什么样的权限。</li><li>mysql.tables_priv：这个表记录了用户对表级别的权限。它存储了用户对某个具体表的权限信息（如SELECT、INSERT、UPDATE、DELETE等）。</li><li>mysql.columns_priv：这个表记录了用户对列级别的权限。它存储了用户对表中某个具体列的权限信息。</li><li>mysql.procs_priv：这个表记录了用户对存储过程和函数的权限。</li><li>mysql.roles：这个表存储了角色的相关信息，包括角色名、角色的创建者等。</li></ol><p>除了上述的表之外，MySQL还提供了一些权限相关的视图，这些视图可以方便地查看用户、角色和权限的信息，如：</p><ul><li>information_schema.USER_PRIVILEGES：显示所有用户的权限信息。</li><li>information_schema.SCHEMA_PRIVILEGES：显示所有数据库的权限信息。</li><li>information_schema.TABLE_PRIVILEGES：显示所有表的权限信息。</li><li>information_schema.COLUMN_PRIVILEGES：显示所有列的权限信息。</li></ul><p>如下是个使用示例</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> information_schema.USER_PRIVILEGES;</span><br></pre></td></tr></table></figure><p>这些表和视图可以通过查询相应的系统表或视图来查看和管理用户、角色和权限。请注意，具体的系统表和视图名称可能因MySQL版本和配置而有所不同。为了确保准确性，请参考MySQL官方文档或特定版本的文档。</p><h1 id="24-列的字符串类型可以是什么"><a href="#24-列的字符串类型可以是什么" class="headerlink" title="24.列的字符串类型可以是什么"></a>24.列的字符串类型可以是什么</h1><p>TEXT CHAR VARCHAR，详见第五点</p><h1 id="25-MySQL作为发布系统的存储，一天五万条以上的增量，预计运维三年，如何优化？"><a href="#25-MySQL作为发布系统的存储，一天五万条以上的增量，预计运维三年，如何优化？" class="headerlink" title="25.MySQL作为发布系统的存储，一天五万条以上的增量，预计运维三年，如何优化？"></a>25.MySQL作为发布系统的存储，一天五万条以上的增量，预计运维三年，如何优化？</h1><blockquote><p>没见过这种业务，只能问GPT</p></blockquote><p>对于一个MySQL作为发布系统存储的场景，处理每天超过五万条增量数据并且需要保持三年的数据，以下是一些优化建议：</p><ol><li>数据库硬件和配置优化：<ul><li>硬件性能：确保数据库服务器具备足够的计算、内存和存储资源，以处理高负载的写入和读取操作。</li><li>存储设备：使用高性能的存储设备（如SSD）来提高写入和读取速度。</li><li>MySQL参数调优：根据实际情况调整MySQL的配置参数，例如设置合理的缓冲区大小、并发连接数、查询缓存等。</li></ul></li><li>数据库架构优化：<ul><li>分库分表：考虑将数据进行分库分表来分担单个数据库的负载压力。根据数据的特点和访问模式，合理划分数据到不同的库表中。</li><li>索引优化：根据查询需求创建合适的索引，以加快查询速度。避免过多的索引和冗余索引，以减少维护成本。</li><li>分区表：如果数据的时间范围有明显的界限，可以考虑使用MySQL的分区表功能，将数据按时间范围进行分区，提高查询性能和维护效率。</li></ul></li><li>数据写入优化：<ul><li>批量插入：使用批量插入方式（如INSERT INTO … VALUES (), (), ()…）来减少单条插入的开销，提高写入性能。</li><li>事务处理：将多个写入操作放在一个事务中，确保数据的一致性和完整性，减少IO开销。</li></ul></li><li>数据归档和压缩：<ul><li>数据归档：对于历史数据，可以将其归档到独立的存储介质中，例如将旧数据迁移到归档数据库或者离线存储系统中以减轻主数据库的负载。</li><li>数据压缩：对于不频繁查询的历史数据，可以考虑使用压缩算法（例如MySQL的压缩表功能或者第三方压缩库）进行存储，以减少存储空间占用。</li></ul></li><li>监控和优化工具：<ul><li>使用监控工具实时监测数据库的性能指标，如查询速度、磁盘使用、锁等情况，及时发现潜在的性能瓶颈并进行调优。</li><li>使用性能优化工具，如Explain分析、慢查询日志等，来找出慢查询和低效的SQL语句，并进行优化。</li></ul></li></ol><p>以上是一些常见的优化建议，具体优化方案还需要根据实际场景和需求进行调整。同时，建议在进行优化前，充分了解应用的读写特征、数据访问模式和业务需求，以便有针对性地进行优化工作。</p><h1 id="26-锁的优化策略？"><a href="#26-锁的优化策略？" class="headerlink" title="26.锁的优化策略？"></a>26.锁的优化策略？</h1><h1 id="27-索引的底层实现和优化？"><a href="#27-索引的底层实现和优化？" class="headerlink" title="27.索引的底层实现和优化？"></a>27.索引的底层实现和优化？</h1><p>底层用B+实现，优化索引方式见索引博客 <a href="https://blog.musnow.top/posts/3474107655/">https://blog.musnow.top/posts/3474107655/</a></p><h1 id="28-什么情况下有索引但是无法使用"><a href="#28-什么情况下有索引但是无法使用" class="headerlink" title="28.什么情况下有索引但是无法使用"></a>28.什么情况下有索引但是无法使用</h1><p>索引失效，见索引博客 <a href="https://blog.musnow.top/posts/3474107655/">https://blog.musnow.top/posts/3474107655/</a></p><h1 id="29-实践中如何优化MySQL"><a href="#29-实践中如何优化MySQL" class="headerlink" title="29.实践中如何优化MySQL"></a>29.实践中如何优化MySQL</h1><p>太宽泛了，不好回答</p><ul><li>索引优化</li><li>分表</li><li>事务隔离性选择</li></ul><h1 id="30-优化数据库的办法？"><a href="#30-优化数据库的办法？" class="headerlink" title="30.优化数据库的办法？"></a>30.优化数据库的办法？</h1><p>和29题重合，不做回答</p><h1 id="31-简单描述索引、主键、唯一索引、联合索引的区别，对数据库性能有什么影响（读写两方面）"><a href="#31-简单描述索引、主键、唯一索引、联合索引的区别，对数据库性能有什么影响（读写两方面）" class="headerlink" title="31.简单描述索引、主键、唯一索引、联合索引的区别，对数据库性能有什么影响（读写两方面）"></a>31.简单描述索引、主键、唯一索引、联合索引的区别，对数据库性能有什么影响（读写两方面）</h1><p>见索引博客 <a href="https://blog.musnow.top/posts/3474107655/">https://blog.musnow.top/posts/3474107655/</a></p><h1 id="32-数据库的事务是什么"><a href="#32-数据库的事务是什么" class="headerlink" title="32.数据库的事务是什么"></a>32.数据库的事务是什么</h1><p>见事务博客 <a href="https://blog.musnow.top/posts/2200233148/">https://blog.musnow.top/posts/2200233148/</a></p><h1 id="33-SQL注入漏洞的产生和原因，如何防止"><a href="#33-SQL注入漏洞的产生和原因，如何防止" class="headerlink" title="33.SQL注入漏洞的产生和原因，如何防止"></a>33.SQL注入漏洞的产生和原因，如何防止</h1><p>SQL注入漏洞是一种常见的安全漏洞，它可以使攻击者通过构造恶意的SQL语句来绕过应用程序的输入验证，进而执行非法的数据库操作或获取敏感信息。以下是SQL注入漏洞产生的原因和一些防止方法：</p><ol><li>原因：<ul><li>不正确的输入验证：当应用程序没有对用户的输入进行充分验证和过滤时，攻击者可以通过输入特定的字符或语句来修改SQL语句的结构，从而执行恶意操作。</li><li>拼接字符串构造SQL语句：如果应用程序使用拼接字符串的方式构造SQL查询语句，并且未对用户输入进行正确的转义处理，就容易受到SQL注入攻击。</li></ul></li><li>防止方法：<ul><li>使用参数化查询或预编译语句：参数化查询将用户输入作为参数传递给SQL语句，而不是直接拼接字符串。这样可以通过数据库驱动程序自动处理转义和编码，有效防止SQL注入攻击。</li><li>输入验证和过滤：对用户的输入数据进行验证和过滤，只接受符合规范的数据。可以使用白名单、黑名单、正则表达式等方法进行输入验证和过滤。</li><li>最小权限原则：在数据库中为应用程序使用的账号设置最小权限，即只授予应用程序完成必要操作所需的最低权限，避免攻击者利用注入漏洞进行更危险的操作。</li><li>不要直接暴露数据库错误信息：在生产环境中，不要将详细的数据库错误信息返回给用户，以防止攻击者从中获取关键信息。可以记录错误日志并给用户一个友好的错误提示。</li><li>定期更新和修补数据库和应用程序：及时安装数据库和应用程序的安全补丁，以修复已知的漏洞，并确保使用最新的安全措施。</li></ul></li></ol><p>总之，为了防止SQL注入漏洞，关键是要对用户输入数据进行合理验证、过滤和转义处理，并使用参数化查询或预编译语句来构造SQL语句。同时，保持应用程序和数据库的安全性，并及时更新和修补已知的安全漏洞。</p><h1 id="34-如何为表中字段选择合适数据类型"><a href="#34-如何为表中字段选择合适数据类型" class="headerlink" title="34.如何为表中字段选择合适数据类型"></a>34.如何为表中字段选择合适数据类型</h1><p>肯定是根据具体情况回答</p><h1 id="35-存储时期？"><a href="#35-存储时期？" class="headerlink" title="35.存储时期？"></a>35.存储时期？</h1><p>感觉这道题有问题，不管他</p><h1 id="36-索引相关问题？"><a href="#36-索引相关问题？" class="headerlink" title="36.索引相关问题？"></a>36.索引相关问题？</h1><p>和31重合，不回答</p><h1 id="37-解释MySQL中外连接、内连接、自连接的区别"><a href="#37-解释MySQL中外连接、内连接、自连接的区别" class="headerlink" title="37.解释MySQL中外连接、内连接、自连接的区别"></a>37.解释MySQL中外连接、内连接、自连接的区别</h1><ol><li>内连接（INNER JOIN）：<ul><li>内连接返回两个表中满足连接条件的记录，即只返回两个表中能够匹配的行。</li><li>内连接使用一个连接谓词（JOIN）或者在FROM子句中使用逗号（,）来表示。</li><li>内连接可以根据指定的连接条件将两个表中的列进行匹配。如果未提供连接条件，则会返回两个表的笛卡尔积。</li><li>语法示例：SELECT * FROM 表1 INNER JOIN 表2 ON 表1.列 &#x3D; 表2.列;</li></ul></li><li>外连接（OUTER JOIN）：<ul><li>外连接将返回两个表中满足连接条件的记录，并且还包括不满足连接条件的记录。</li><li>外连接分为左外连接（LEFT JOIN）和右外连接（RIGHT JOIN）。</li><li>左外连接返回左表中的所有记录，以及右表中与左表满足连接条件的记录。如果右表中没有匹配的记录，则会返回NULL值。</li><li>右外连接返回右表中的所有记录，以及左表中与右表满足连接条件的记录。如果左表中没有匹配的记录，则会返回NULL值。</li><li>语法示例：<ul><li>左外连接：SELECT * FROM 表1 LEFT JOIN 表2 ON 表1.列 &#x3D; 表2.列;</li><li>右外连接：SELECT * FROM 表1 RIGHT JOIN 表2 ON 表1.列 &#x3D; 表2.列;</li></ul></li></ul></li><li>自连接（SELF JOIN）：<ul><li>自连接是指将表视为两个独立的实例，使用别名来区分它们，然后根据某些条件将它们连接在一起。</li><li>自连接通常用于在同一个表中根据某种关系进行数据查询。</li><li>语法示例：SELECT 别名1.列, 别名2.列 FROM 表 别名1, 表 别名2 WHERE 别名1.列 &#x3D; 别名2.列;</li></ul></li></ol><p>总结：</p><ul><li>内连接返回两个表中匹配的记录，外连接返回满足连接条件的记录以及不满足连接条件的记录，而自连接是对同一个表进行连接操作。</li><li>内连接和外连接需要使用JOIN关键字，而自连接使用同一个表的别名进行连接。</li><li>内连接和外连接可以根据连接条件将两个表进行关联，而自连接可以根据表中的某些条件进行关联。</li></ul><h1 id="38-MySQL中事务回滚机制描述"><a href="#38-MySQL中事务回滚机制描述" class="headerlink" title="38.MySQL中事务回滚机制描述"></a>38.MySQL中事务回滚机制描述</h1><p>见事务博客 <a href="https://blog.musnow.top/posts/2200233148/">https://blog.musnow.top/posts/2200233148/</a></p><h1 id="39-SQL语言包含哪几部分？每部分都有哪些操作关键字"><a href="#39-SQL语言包含哪几部分？每部分都有哪些操作关键字" class="headerlink" title="39.SQL语言包含哪几部分？每部分都有哪些操作关键字"></a>39.SQL语言包含哪几部分？每部分都有哪些操作关键字</h1><p>包括DQL数据查询语言，DML数据操作语言（增删改），数据控制语言DCL用来管理数据库，事务控制语言TCL用来控制事务，数据定义语言DDL用来创建删除表</p><ol><li>数据查询语言（Data Query Language，DQL）：用于从数据库中查询和检索数据。常用的操作关键字包括：<ul><li>SELECT：用于从一个或多个表中选择数据列以进行查询。</li><li>FROM：指定要查询的表。</li><li>WHERE：用于指定查询的条件。</li><li>GROUP BY：按照指定的列对结果进行分组。</li><li>HAVING：用于指定对分组后的结果进行筛选的条件。</li><li>ORDER BY：指定结果集的排序方式。</li></ul></li><li>数据操作语言（Data Manipulation Language，DML）：用于对数据库中的数据进行增加、修改和删除操作。常用的操作关键字包括：<ul><li>INSERT INTO：向表中插入新的行或数据。</li><li>UPDATE：更新表中已有的数据。</li><li>DELETE FROM：从表中删除指定的行或数据。</li></ul></li><li>数据定义语言（Data Definition Language，DDL）：用于创建、修改和删除数据库和表结构。常用的操作关键字包括：<ul><li>CREATE DATABASE：创建新的数据库。</li><li>CREATE TABLE：创建新的数据表。</li><li>ALTER TABLE：修改已存在的数据表结构。</li><li>DROP DATABASE：删除现有的数据库。</li><li>DROP TABLE：删除现有的数据表。</li></ul></li><li>数据控制语言（Data Control Language，DCL）：用于管理数据库中的用户权限和访问权限。常用的操作关键字包括：<ul><li>GRANT：授予用户特定的权限。</li><li>REVOKE：撤销用户的权限。</li></ul></li><li>事务控制语言（Transaction Control Language，TCL）：用于管理数据库的事务处理。常用的操作关键字包括：<ul><li>COMMIT：提交一个事务，使其永久生效。</li><li>ROLLBACK：回滚一个事务，撤销之前的操作，使其不生效。</li><li>SAVEPOINT：在事务中设置保存点，以便在需要时进行回滚。</li></ul></li></ol><h1 id="40-完整性的约束包括那些？"><a href="#40-完整性的约束包括那些？" class="headerlink" title="40.完整性的约束包括那些？"></a>40.完整性的约束包括那些？</h1><p>原子性、隔离性、持久性；这里说的完整性应该就是一致性；</p><p>具体的解释依旧是去看事务的博客 <a href="https://blog.musnow.top/posts/2200233148/">https://blog.musnow.top/posts/2200233148/</a></p>]]></content>
    
    
    <summary type="html">字节MySQL连环40问</summary>
    
    
    
    <category term="学习sql" scheme="https://blog.musnow.top/categories/%E5%AD%A6%E4%B9%A0sql/"/>
    
    
    <category term="mysql" scheme="https://blog.musnow.top/tags/mysql/"/>
    
  </entry>
  
  <entry>
    <title>【面经】230913上海零念科技CPP实习生</title>
    <link href="https://blog.musnow.top/posts/2719794733/"/>
    <id>https://blog.musnow.top/posts/2719794733/</id>
    <published>2023-09-13T09:32:14.000Z</published>
    <updated>2023-09-13T10:32:14.000Z</updated>
    
    <content type="html"><![CDATA[<p>230913上海零念科技CPP实习生面试记录</p><span id="more"></span><p>上来先做了个自我介绍，然后面试官介绍了他们是做系统进程调度的；</p><h1 id="CPP"><a href="#CPP" class="headerlink" title="CPP"></a>CPP</h1><p>题目顺序并非实际问的顺序</p><h2 id="1-类的大小"><a href="#1-类的大小" class="headerlink" title="1.类的大小"></a>1.类的大小</h2><p>类的大小和什么东西有关系？</p><p>我答了成员变量和虚函数表</p><h2 id="2-多态怎么实现的"><a href="#2-多态怎么实现的" class="headerlink" title="2.多态怎么实现的"></a>2.多态怎么实现的</h2><p>顺着虚函数表问的，就说了一下动态多态的基本实现方式</p><h2 id="3-只能在栈上的类"><a href="#3-只能在栈上的类" class="headerlink" title="3.只能在栈上的类"></a>3.只能在栈上的类</h2><p>禁止拷贝构造和赋值，构造函数私有化，提供单独函数在栈上开辟空间；</p><p>顺便问了一下动态内存管理的基础形式</p><h2 id="4-智能指针"><a href="#4-智能指针" class="headerlink" title="4.智能指针"></a>4.智能指针</h2><p>哪些类型？有啥区别？weak ptr怎么解决循环引用问题的？</p><p>weak ptr的lock函数用过吗？有没有办法获取到shared ptr的引用计数？</p><p>unique_ptr可以转成share_ptr吗？</p><p>如果要用C++11的类型转换，要使用哪一个来进行unique_ptr和share_ptr的转换？（这个不会，应该是static_cast）</p><p>定制删除器是干嘛的？</p><p>智能指针线程安全吗？</p><p>拷贝构造share_ptr会不会有内存泄漏？</p><h2 id="5-类型转换"><a href="#5-类型转换" class="headerlink" title="5.类型转换"></a>5.类型转换</h2><p>C++11的类型转换，几个，区别是什么？</p><p>指针之间转换要用什么？（不会，答的static）</p><p>dynamic_cast父子转换的时候，向上还是向下是安全的？（子转成父是安全的，即向上安全）</p><h2 id="6-单例"><a href="#6-单例" class="headerlink" title="6.单例"></a>6.单例</h2><p>几种类型，怎么实现？</p><h2 id="7-模板"><a href="#7-模板" class="headerlink" title="7.模板"></a>7.模板</h2><p>模板的声明和定义为啥不能分离？（忘记了）</p><p>模板特化是什么？函数模板支持半特化吗？（不支持）</p><h2 id="8-C-线程和async有啥区别？"><a href="#8-C-线程和async有啥区别？" class="headerlink" title="8.C++线程和async有啥区别？"></a>8.C++线程和async有啥区别？</h2><p>thread是类，aysnc是函数</p><p>async有两种用法，一个是立马异步执行，会开一个线程；第二个是延迟同步执行，在使用<code>future.get</code>的时候才会执行。</p><p>这部分是在云账房面试的时候问道的，得亏我专门去学了，开心！</p><h2 id="9-C-14新特性"><a href="#9-C-14新特性" class="headerlink" title="9.C++14新特性"></a>9.C++14新特性</h2><p>知道的全说了，auto，lambda新特性，constexpr（和c++11的区别），变量模板，二进制变量，然后还说了最后几个std的函数看不明白；面试官人很好，一直说没关系；</p><p>专门问了<code>constexpr</code>声明变量和const有啥区别（不知道）</p><blockquote><p>GPT的回答</p><ol><li>时间点：<code>constexpr</code> 是在编译时确定值的，而 <code>const</code> 是在运行时确定值的。</li><li>编译期计算：<code>constexpr</code> 变量可以用于编译时期间的计算，比如数组大小、模板参数等需要在编译阶段确定大小的场景。而 <code>const</code> 变量只是表示它的值不可以修改，在编译阶段无法使用 <code>const</code> 变量进行编译期计算。</li><li>初始化：<code>constexpr</code> 变量必须在声明时进行初始化，并且只能使用常量表达式初始化；<code>const</code> 变量可以在声明时初始化，也可以稍后赋值，但赋值后就不能再修改。</li><li>地址：<code>constexpr</code> 变量往往会被编译器优化，可能不会占用内存空间，并且在编译期间被消除。<code>const</code> 变量在运行时分配内存，并且有相应的内存地址。</li><li>但是这两个关键字声明的变量都具有常量属性，不可修改；</li></ol></blockquote><p>对C++17有没有了解？（无）</p><h2 id="10-stl用过什么？"><a href="#10-stl用过什么？" class="headerlink" title="10.stl用过什么？"></a>10.stl用过什么？</h2><p>把常用的stl都说了一遍</p><p>stl线程安全吗？当然不</p><h2 id="11-vector和array区别"><a href="#11-vector和array区别" class="headerlink" title="11.vector和array区别"></a>11.vector和array区别</h2><p>array是定长数组，vector动态开辟</p><p>array可以使用迭代器，保证代码风格统一</p><p>这里顺便提到了<code>[]</code>的重载，面试官问了vector里面at函数和<code>[]</code>重载的区别（at会抛异常，<code>[]</code>不会）</p><h2 id="12-emplace-back和push-back区别"><a href="#12-emplace-back和push-back区别" class="headerlink" title="12.emplace_back和push_back区别"></a>12.emplace_back和push_back区别</h2><p>我说了emplace_back能节省一次拷贝的消耗；</p><p>面试官问要怎么使用才能节省这个消耗？使用方式（不会）</p><p>emplace_back既然高效，为啥没有取代push_back？（不会，这里我就说了一下设计考虑兼容性的问题）</p><h2 id="13-初始化列表、构造函数体内初始化、成员变量给缺省值"><a href="#13-初始化列表、构造函数体内初始化、成员变量给缺省值" class="headerlink" title="13.初始化列表、构造函数体内初始化、成员变量给缺省值"></a>13.初始化列表、构造函数体内初始化、成员变量给缺省值</h2><p>那个更好？有啥区别？</p><p>引用是没有办法使用缺省值的，只有常量&#x2F;普通变量可以用缺省值；</p><p>在VS2019里面调试测试了一下运行顺序：</p><ul><li>缺省值（会优化成初始化列表）&#x2F;初始化列表</li><li>函数体内</li></ul><p>具体的测试参考 <a href="https://blog.musnow.top/posts/2894176175/">CPP类和对象默认成员函数</a>，里面详细注明了构造顺序；</p><h2 id="14-默认构造函数"><a href="#14-默认构造函数" class="headerlink" title="14.默认构造函数"></a>14.默认构造函数</h2><p>什么时候可以不自己写构造函数？</p><p>这里没有答全，感觉自己已经被绕晕了</p><h2 id="15-function和bind的作用"><a href="#15-function和bind的作用" class="headerlink" title="15.function和bind的作用"></a>15.function和bind的作用</h2><p>如题</p><h2 id="16-final-x2F-overide-x2F-explicit"><a href="#16-final-x2F-overide-x2F-explicit" class="headerlink" title="16.final&#x2F;overide&#x2F;explicit"></a>16.final&#x2F;overide&#x2F;explicit</h2><p>作用</p><p>explicit忘记了，<strong>面试官说没关系，反正也不用</strong>🤣</p><h1 id="Linux"><a href="#Linux" class="headerlink" title="Linux"></a>Linux</h1><h2 id="1-进程通信"><a href="#1-进程通信" class="headerlink" title="1.进程通信"></a>1.进程通信</h2><p>有哪些，这里主要问了共享内存和管道的优劣，使用谁的资源消耗更优（这里问的是资源消耗，不是通信速度）</p><blockquote><p>我答的是因为管道是文件描述符，操作系统需要维护文件和进程之间的关系，所以消耗会高一点；然后共享内存是直接在页表上操作，没有额外的消耗；</p><p>咱也不知道对不对，感觉答案应该是下面这个</p><p><img src="https://img.musnow.top/i/2023/09/17766a5a0226a48b578aed58d9ed5c1d.png" alt="image-20230913212808024"></p></blockquote><p>问有没有用过消息队列（知道这玩意，没用过）</p><h2 id="2-进程和线程区别"><a href="#2-进程和线程区别" class="headerlink" title="2.进程和线程区别"></a>2.进程和线程区别</h2><p>说了资源消耗区别，功能比较隔离的时候适合用进程，还举了个epoll的reactor模式的例子（我瞎编的，说实话，也不知道对不对）</p><h2 id="3-开发环境"><a href="#3-开发环境" class="headerlink" title="3.开发环境"></a>3.开发环境</h2><p>前期用vs2019，后期用vscode+remote ssh；</p><p>面试官问我很多个文件怎么进行编译和管理，我说了makefile；问有没有用过cmake（无）</p><h2 id="4-编译链接过程"><a href="#4-编译链接过程" class="headerlink" title="4.编译链接过程"></a>4.编译链接过程</h2><p>这个其实是第一个问的问题，就简单地说了一下；</p><h2 id="5-动静态库"><a href="#5-动静态库" class="headerlink" title="5.动静态库"></a>5.动静态库</h2><p>有啥区别？优缺点？</p><h1 id="The-end"><a href="#The-end" class="headerlink" title="The end"></a>The end</h1><p>没有问网络，也没有写OJ，也没有问项目；</p><p>这次的面试官很耐心，会引导你回答问题。爱了；</p>]]></content>
    
    
    <summary type="html">230913上海零念科技CPP实习生</summary>
    
    
    
    <category term="求职路上一去不复返" scheme="https://blog.musnow.top/categories/%E6%B1%82%E8%81%8C%E8%B7%AF%E4%B8%8A%E4%B8%80%E5%8E%BB%E4%B8%8D%E5%A4%8D%E8%BF%94/"/>
    
    
    <category term="面经" scheme="https://blog.musnow.top/tags/%E9%9D%A2%E7%BB%8F/"/>
    
  </entry>
  
  <entry>
    <title>【MySQL】事务</title>
    <link href="https://blog.musnow.top/posts/2200233148/"/>
    <id>https://blog.musnow.top/posts/2200233148/</id>
    <published>2023-09-10T00:52:14.000Z</published>
    <updated>2023-09-10T00:52:30.000Z</updated>
    
    <content type="html"><![CDATA[<p>学习了之后，你会对MySQL如何进行数据的访问控制有更深刻的了解；</p><span id="more"></span><p>本文中有大量截图，如果出现404的图片，请评论告知，谢谢；</p><h1 id="1-什么是事务？"><a href="#1-什么是事务？" class="headerlink" title="1.什么是事务？"></a>1.什么是事务？</h1><h2 id="1-1-场景举例"><a href="#1-1-场景举例" class="headerlink" title="1.1 场景举例"></a>1.1 场景举例</h2><h3 id="1-1-1-转账"><a href="#1-1-1-转账" class="headerlink" title="1.1.1 转账"></a>1.1.1 转账</h3><p>当A需要给B转账50元的时候，后台应该进行如何处理？</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 先判断用户还有多少余额（这里的user_id=A只是一个示例，知道什么意思就行）</span></span><br><span class="line"><span class="keyword">select</span> money <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">where</span> user_id<span class="operator">=</span>A;</span><br><span class="line"><span class="comment">-- 如果余额充足，那就给A扣50</span></span><br><span class="line"><span class="keyword">update</span> <span class="keyword">user</span> <span class="keyword">set</span> money <span class="operator">=</span> money <span class="operator">-</span> <span class="number">50</span> <span class="keyword">where</span> user_id<span class="operator">=</span>A;</span><br><span class="line"><span class="comment">-- 然后给B加50</span></span><br><span class="line"><span class="keyword">update</span> <span class="keyword">user</span> <span class="keyword">set</span> money <span class="operator">=</span> money <span class="operator">+</span> <span class="number">50</span> <span class="keyword">where</span> user_id<span class="operator">=</span>B;</span><br></pre></td></tr></table></figure><p>这一个操作，需要3个SQL语句才能完成，但很明显，我们即便在当前的服务器端对这3条语句的操作进行加锁，也没有办法避免如下的情况</p><ul><li>服务器负载过高，进程被kill了</li><li>服务器断电了</li><li>MySQL服务器抽风挂掉了</li><li>等等不可抗力</li></ul><p>这时候，如果在执行第一条查询语句后就挂掉了，那还不会有啥问题；但如果是在执行完毕第二条扣钱的语句之后挂掉了，那问题就大了！</p><ul><li>A给B转钱，A的钱扣了，B的钱没有加，这怎么可以？</li></ul><p>最终还需要程序员通过MySQL的日志一个个核对到底是谁出现了这样的情况，给人家把钱加回去，那太过麻烦；在数据量大的时候，这种工作更是不应该由人工手动完成的！</p><p>所以，MySQL就需要提供一种方法，让我们能够实现类似原子性的操作。在执行这3条语句的时候，<strong>只能出现两种情况</strong>：</p><ul><li>成功执行，A扣了钱，B也加了钱，转账成功；</li><li>执行失败，但是A和B的钱都没有变化，并告知用户转账失败；</li></ul><p>这样才是靠谱的结果！</p><h3 id="1-1-2-卖票"><a href="#1-1-2-卖票" class="headerlink" title="1.1.2 卖票"></a>1.1.2 卖票</h3><p>另外<span id="jump1">一个场景</span>就是卖票，其也包含了多条SQL</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> ticket <span class="keyword">where</span> tid<span class="operator">=</span>?; <span class="comment">-- 查询某某车次高铁的票还有没有余量</span></span><br><span class="line"><span class="comment">-- 有余量，进行售卖流程；这里可能要操作另外一张表来添加买票者的用户信息</span></span><br><span class="line"><span class="keyword">update</span> ticket <span class="keyword">set</span> num<span class="operator">=</span>num<span class="number">-1</span> <span class="keyword">where</span> tid<span class="operator">=</span>?; <span class="comment">-- 售卖流程结束，扣去这张票</span></span><br></pre></td></tr></table></figure><p>如果有两个客户端都同时来执行这两条SQL语句，那么就会出现问题；</p><ul><li>只剩一张票</li><li>客户端A进行查询，发现有票，开始执行卖票流程</li><li>客户端B进行查询，也发现有票，开始执行卖票流程</li><li>此时A执行完毕，将票的数量-1，卖完票了；</li><li>随后B执行完毕，也将票的数量-1，此时就会出现票数是负数的情况！</li><li>更难受的是，同一张票被错误地卖给了两个用户！</li></ul><p>这时候在客户端里面加锁是不顶用的，两个客户端都不是同一个进程，锁无法共享；需要MySQL解决这个问题，就还得提供更加严格的访问控制，在A没有完成整个卖票逻辑，票数没有扣掉的情况下，<strong>B不可以来查询票数</strong>；</p><h2 id="1-2-事务的介绍"><a href="#1-2-事务的介绍" class="headerlink" title="1.2 事务的介绍"></a>1.2 事务的介绍</h2><p>事务（transaction）就是一组DML语句的集合，这些语句在逻辑上是一个整体；执行这组语句，必须全部成功，亦或者是全部失败。</p><p>在执行这组SQL的时候，MySQL需要将其视作一个原子性的操作；这个操作不能被其他事务打断，出现问题的时候还需要回滚到开始执行之前的初始状态；事务还能使不同客户端看到的数据是不同的，不同事务之间的操作不会相互影响；只有事务结束后，双方才能看到对方的操作（根据隔离级别不同，这点也会有区别）；</p><p>正如上面的两个场景所提到的操作，同一个时刻对于MySQL的一个数据库来说，其可能有多个客户端进行不同业务的操作，如果都在访问同一个表，在不加访问控制的情况下，一定会出现访问临界资源的数据二义性问题。</p><blockquote><p>事务的出现，是客户端在实际应用场景下的需要，</p></blockquote><p>所以，一个完整的事务，除了是多条DML语句的集合，还需要满足下面4个特性</p><ul><li>原子性：一个事务中的所有操作，要么全部完成，要么全部失败；如果事务在执行过程中发现错误，那就需要回滚（Rollback）到事务开始之前的状态，就好比这个事务并没有执行过一般</li><li>一致性：事务开始之前和结束后，数据库的完整性没有被破坏。进行的操作复合我们预设的要求；这包含数据的准确度、串联性以及后续数据库可以自发完成预定的工作；</li><li>隔离性：数据库允许多个并发事务同时对数据库中的数据进行CURD操作，隔离性保证这些事务之间的操作并不会由于并发的交叉运行而出现不一致的情况。事务隔离性分为不同级别，具体的区别会在后文详解<ul><li>读未提交（Read Uncommitted）</li><li>读已提交（Read Committed）</li><li>可重复读（Repeatble Read）</li><li>串行化（Serializable）</li></ul></li><li>持久性：事务处理完毕后，对事务的修改是永久的，即便系统宕机了也不会丢失（除非硬盘坏了）</li></ul><p>上面的四个属性，简称为ACID；</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">原子性（Atomicity，或称不可分割性）</span><br><span class="line">一致性（Consistency）</span><br><span class="line">隔离性（Isolation，又称独立性）</span><br><span class="line">持久性（Durability）</span><br></pre></td></tr></table></figure><p>其中，一致性是由原子性、隔离性、持久性来保证的，只要满足了这三个性质，自然能实现一致性。简单记忆，AID来保证C；</p><h2 id="1-3-事务的存储引擎支持"><a href="#1-3-事务的存储引擎支持" class="headerlink" title="1.3 事务的存储引擎支持"></a>1.3 事务的存储引擎支持</h2><p>在MySQL中，只有<code>Innodb</code>支持事务，<code>MyISAM</code>是不支持事务的；</p><p>我们可以用如下语句来查询MySQL的引擎和支持的特性</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line">MariaDB [hello_mysql]<span class="operator">&gt;</span> <span class="keyword">show</span> engines \G</span><br><span class="line"><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span> <span class="number">1.</span> <span class="type">row</span> <span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span></span><br><span class="line">      Engine: MEMORY</span><br><span class="line">     Support: YES</span><br><span class="line">     Comment: Hash based, stored <span class="keyword">in</span> memory, useful <span class="keyword">for</span> temporary tables</span><br><span class="line">Transactions: <span class="keyword">NO</span></span><br><span class="line">          XA: <span class="keyword">NO</span></span><br><span class="line">  Savepoints: <span class="keyword">NO</span></span><br><span class="line"><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span> <span class="number">2.</span> <span class="type">row</span> <span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span></span><br><span class="line">      Engine: MRG_MyISAM</span><br><span class="line">     Support: YES</span><br><span class="line">     Comment: Collection <span class="keyword">of</span> identical MyISAM tables</span><br><span class="line">Transactions: <span class="keyword">NO</span></span><br><span class="line">          XA: <span class="keyword">NO</span></span><br><span class="line">  Savepoints: <span class="keyword">NO</span></span><br><span class="line"><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span> <span class="number">3.</span> <span class="type">row</span> <span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span></span><br><span class="line">      Engine: CSV</span><br><span class="line">     Support: YES</span><br><span class="line">     Comment: Stores tables <span class="keyword">as</span> CSV files</span><br><span class="line">Transactions: <span class="keyword">NO</span></span><br><span class="line">          XA: <span class="keyword">NO</span></span><br><span class="line">  Savepoints: <span class="keyword">NO</span></span><br><span class="line"><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span> <span class="number">4.</span> <span class="type">row</span> <span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span></span><br><span class="line">      Engine: BLACKHOLE</span><br><span class="line">     Support: YES</span><br><span class="line">     Comment: <span class="operator">/</span>dev<span class="operator">/</span><span class="keyword">null</span> storage engine (anything you write <span class="keyword">to</span> it disappears)</span><br><span class="line">Transactions: <span class="keyword">NO</span></span><br><span class="line">          XA: <span class="keyword">NO</span></span><br><span class="line">  Savepoints: <span class="keyword">NO</span></span><br><span class="line"><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span> <span class="number">5.</span> <span class="type">row</span> <span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span></span><br><span class="line">      Engine: MyISAM</span><br><span class="line">     Support: YES</span><br><span class="line">     Comment: Non<span class="operator">-</span>transactional engine <span class="keyword">with</span> good performance <span class="keyword">and</span> small data footprint</span><br><span class="line">Transactions: <span class="keyword">NO</span></span><br><span class="line">          XA: <span class="keyword">NO</span></span><br><span class="line">  Savepoints: <span class="keyword">NO</span></span><br><span class="line"><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span> <span class="number">6.</span> <span class="type">row</span> <span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span></span><br><span class="line">      Engine: ARCHIVE</span><br><span class="line">     Support: YES</span><br><span class="line">     Comment: gzip<span class="operator">-</span>compresses tables <span class="keyword">for</span> a low storage footprint</span><br><span class="line">Transactions: <span class="keyword">NO</span></span><br><span class="line">          XA: <span class="keyword">NO</span></span><br><span class="line">  Savepoints: <span class="keyword">NO</span></span><br><span class="line"><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span> <span class="number">7.</span> <span class="type">row</span> <span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span></span><br><span class="line">      Engine: FEDERATED</span><br><span class="line">     Support: YES</span><br><span class="line">     Comment: Allows <span class="keyword">to</span> access tables <span class="keyword">on</span> other MariaDB servers, supports transactions <span class="keyword">and</span> more</span><br><span class="line">Transactions: YES</span><br><span class="line">          XA: <span class="keyword">NO</span></span><br><span class="line">  Savepoints: YES</span><br><span class="line"><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span> <span class="number">8.</span> <span class="type">row</span> <span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span></span><br><span class="line">      Engine: PERFORMANCE_SCHEMA</span><br><span class="line">     Support: YES</span><br><span class="line">     Comment: Performance Schema</span><br><span class="line">Transactions: <span class="keyword">NO</span></span><br><span class="line">          XA: <span class="keyword">NO</span></span><br><span class="line">  Savepoints: <span class="keyword">NO</span></span><br><span class="line"><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span> <span class="number">9.</span> <span class="type">row</span> <span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span></span><br><span class="line">      Engine: SEQUENCE</span><br><span class="line">     Support: YES</span><br><span class="line">     Comment: Generated tables filled <span class="keyword">with</span> sequential <span class="keyword">values</span></span><br><span class="line">Transactions: YES</span><br><span class="line">          XA: <span class="keyword">NO</span></span><br><span class="line">  Savepoints: YES</span><br><span class="line"><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span> <span class="number">10.</span> <span class="type">row</span> <span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span></span><br><span class="line">      Engine: InnoDB</span><br><span class="line">     Support: <span class="keyword">DEFAULT</span> <span class="comment">-- 默认引擎</span></span><br><span class="line">     Comment: Supports transactions, <span class="type">row</span><span class="operator">-</span>level locking, <span class="keyword">foreign</span> keys <span class="keyword">and</span> encryption <span class="keyword">for</span> tables <span class="comment">-- 描述</span></span><br><span class="line">Transactions: YES  <span class="comment">-- 支持事务</span></span><br><span class="line">          XA: YES  </span><br><span class="line">  Savepoints: YES  <span class="comment">-- 支持事务中的保存点</span></span><br><span class="line"><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span> <span class="number">11.</span> <span class="type">row</span> <span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span></span><br><span class="line">      Engine: Aria</span><br><span class="line">     Support: YES</span><br><span class="line">     Comment: Crash<span class="operator">-</span>safe tables <span class="keyword">with</span> MyISAM heritage</span><br><span class="line">Transactions: <span class="keyword">NO</span></span><br><span class="line">          XA: <span class="keyword">NO</span></span><br><span class="line">  Savepoints: <span class="keyword">NO</span></span><br><span class="line"><span class="number">11</span> <span class="keyword">rows</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.000</span> sec)</span><br></pre></td></tr></table></figure><h2 id="1-4-保存点"><a href="#1-4-保存点" class="headerlink" title="1.4 保存点"></a>1.4 保存点</h2><p>所谓保存点，就是在事务执行过程中，给当前的数据设置一个savepoint，这样在出现问题的时候，可以回退到当前的数据中；就好比之后的操作没有进行一样；</p><p>游戏中的保存点其实也是这样的功能，让玩家回退到打某个BOSS之前，包括当时你收集的材料，都会回退到打这个BOSS之前的状态；</p><p>你可以理解为，是给当前的数据拍了张照片，出现问题的时候，用这个照片里面的东西复写掉新的东西。这便是保存点的作用；</p><h2 id="1-5-基础命令操作"><a href="#1-5-基础命令操作" class="headerlink" title="1.5 基础命令操作"></a>1.5 基础命令操作</h2><p>先提一下事务的开启和结束方式，以及如何设置保存点和回滚吧</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 开启，这两种方式是一样的</span></span><br><span class="line"><span class="keyword">begin</span>;</span><br><span class="line"><span class="keyword">start</span> transaction;</span><br><span class="line"><span class="comment">-- 设置保存点（名字可以自由更改，但不能有重复）</span></span><br><span class="line"><span class="keyword">savepoint</span> save1; <span class="comment">-- 创建一个保存点save1</span></span><br><span class="line"><span class="keyword">rollback</span> <span class="keyword">to</span> save1; <span class="comment">-- 回滚到保存点save1</span></span><br><span class="line"><span class="keyword">rollback</span>; <span class="comment">-- 回滚到事务开始</span></span><br><span class="line"><span class="comment">-- 结束</span></span><br><span class="line"><span class="keyword">commit</span>; <span class="comment">-- 提交事务</span></span><br></pre></td></tr></table></figure><h1 id="2-使用"><a href="#2-使用" class="headerlink" title="2.使用"></a>2.使用</h1><p>了解了事务为什么存在，下面就是来使用一下事务了；</p><h2 id="2-1-提交方式"><a href="#2-1-提交方式" class="headerlink" title="2.1 提交方式"></a>2.1 提交方式</h2><p>事务的提交方式有两种方式</p><ul><li>自动提交</li><li>手动提交</li></ul><p>默认情况下，MySQL的自动提交是处于开启状态的</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">MariaDB [hello_mysql]&gt; show variables like &#x27;autocommit&#x27;;</span><br><span class="line">+---------------+-------+</span><br><span class="line">| Variable_name | Value |</span><br><span class="line">+---------------+-------+</span><br><span class="line">| autocommit    | ON    |</span><br><span class="line">+---------------+-------+</span><br><span class="line">1 row in set (0.001 sec)</span><br></pre></td></tr></table></figure><p>我们可以用下面的语句来设置是否开启自动提交（只对当前会话生效）</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">set</span> autocommit <span class="operator">=</span> <span class="number">0</span>; <span class="comment">-- 关闭自动提交</span></span><br><span class="line"><span class="keyword">set</span> autocommit <span class="operator">=</span> <span class="number">1</span>; <span class="comment">-- 开启</span></span><br></pre></td></tr></table></figure><p>这两个提交方式有啥区别呢？是不是开了自动提交就什么都不用管了？后文我们再通过实测来说明；</p><h2 id="2-2-场景演示"><a href="#2-2-场景演示" class="headerlink" title="2.2 场景演示"></a>2.2 场景演示</h2><p>最开始测试的时候，先将事务隔离级别设置为读未提交；请注意，不要在有生产环境的MySQL中进行此项操作；</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 设置全局隔离级别为读未提交</span></span><br><span class="line"><span class="keyword">set</span> <span class="keyword">global</span> transaction isolation level READ UNCOMMITTED; </span><br><span class="line"><span class="comment">-- 重启mysql终端后查看隔离级别</span></span><br><span class="line"><span class="keyword">select</span> @<span class="variable">@tx</span>_isolation; </span><br><span class="line"><span class="operator">+</span><span class="comment">------------------+</span></span><br><span class="line"><span class="operator">|</span> @<span class="variable">@tx</span>_isolation   <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">------------------+</span></span><br><span class="line"><span class="operator">|</span> READ<span class="operator">-</span>UNCOMMITTED <span class="operator">|</span>   <span class="comment">-- 成功设置读未提交的隔离级级别</span></span><br><span class="line"><span class="operator">+</span><span class="comment">------------------+</span></span><br><span class="line"><span class="number">1</span> <span class="type">row</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.000</span> sec)</span><br></pre></td></tr></table></figure><h3 id="2-2-1-数据回滚演示"><a href="#2-2-1-数据回滚演示" class="headerlink" title="2.2.1 数据回滚演示"></a>2.2.1 数据回滚演示</h3><p>设置完毕后，进入测试数据库，创建如下测试表</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> test_ruc(</span><br><span class="line">id <span class="type">int</span> unsigned <span class="keyword">primary</span> key,</span><br><span class="line">user_id <span class="type">int</span> unsigned <span class="keyword">not</span> <span class="keyword">null</span>,</span><br><span class="line">    name <span class="type">varchar</span>(<span class="number">30</span>) <span class="keyword">not</span> <span class="keyword">null</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>先给表里面插入几个基本的数据：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> test_ruc <span class="keyword">values</span> (<span class="number">1</span>,<span class="number">10</span>,<span class="string">&#x27;李华&#x27;</span>),(<span class="number">2</span>,<span class="number">20</span>,<span class="string">&#x27;王五&#x27;</span>);</span><br></pre></td></tr></table></figure><p>插入后，我们在两侧的终端中都可以看到已有的数据</p><p><img src="https://img.musnow.top/i/2023/09/319fbe3f23373d34fb0eff4a249ef16b.png" alt="image-20230910163833837"></p><p>随后在两个终端中都开启一个事务，左侧终端插入一个数据，右侧终端查看</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> test_ruc <span class="keyword">values</span> (<span class="number">3</span>,<span class="number">30</span>,<span class="string">&#x27;左侧终端插入&#x27;</span>);</span><br></pre></td></tr></table></figure><p>可以看到，两侧的终端都可以看到这份数据</p><p><img src="https://img.musnow.top/i/2023/09/8021cf95d4fa8a29c24771161f17cf52.png" alt="image-20230910164315360"></p><p>此时将左侧终端强制退出（使用<code>CTRL+\</code>），右侧再次查询，会发现新插入的数据没有了；这里便是事务的<strong>原子性</strong>的体现，左侧的终端所执行的事务没有<code>commit</code>就因为异常退出了，MySQL自动将数据回滚到了这个事务执行之前，即没有插入这份新数据；</p><p><img src="https://img.musnow.top/i/2023/09/db2ea78350e2fe7927f8367f7aecf2db.png" alt="image-20230910164414488"></p><p>左侧重新链接MySQL，开启一个事务；在右侧插入一个数据，随后创建保存点<code>save1</code>；插入第二个数据，创建保存点<code>save2</code>；</p><p>在左侧查询，我们可以看到右侧插入的两条新数据；</p><p><img src="https://img.musnow.top/i/2023/09/cf012a62e99049bc5b41b66583e7b49a.png" alt="image-20230910165426916"></p><p>在右侧回滚到保存点save1，会发现插入的数据2没有了；这与保存点的预期操作相符合；</p><p><img src="https://img.musnow.top/i/2023/09/99e569e2c4fde9770594fc1176aa52ec.png" alt="image-20230910165719357"></p><p>将右侧终端强制退出，再次查询数据，可以看到第一次插入的数据也没有了，数据又回到了右侧终端事务开始之前的样子。</p><p><img src="https://img.musnow.top/i/2023/09/60cb747da1ac4756bce1c6e6ff12ace0.png" alt="image-20230910171826318"></p><p>这里能得出一个结论：如果终端异常退出，MySQL会将数据回滚到事务开始时；你可以理解为，我们使用<code>begin;</code>的时候就已经创建了一个隐藏的保存点，MySQL在异常的时候只会将数据回退到这个<strong>事务开始之时</strong>的隐藏保存点，无论中途用户有没有设置其他保存点！</p><p>即：在异常退出的时候，MySQL会自动帮我们执行<code>rollback</code>命令回退到事务开头！</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">rollback</span>; <span class="comment">-- 回退到事务开头</span></span><br></pre></td></tr></table></figure><p>这样就能避免最开始提到的，转账系统中给A扣了钱但是没有给B加钱的问题！</p><h3 id="2-2-2-数据持久化演示"><a href="#2-2-2-数据持久化演示" class="headerlink" title="2.2.2 数据持久化演示"></a>2.2.2 数据持久化演示</h3><p>接着我们再来看看，如果执行了commit之后又会是什么情况；</p><p>右侧提交了事务后退出，左侧依旧能查询倒已经提交的数据。代表数据已经被持久化写入到了磁盘（当然这个时候也不一定立刻刷盘了，但是这已经能代表MySQL将我们的数据加入到了持久化策略中，并不需要我们管啥时候刷盘的问题！）</p><p><img src="https://img.musnow.top/i/2023/09/e04e7e3b782a176b62e140c1143b1695.png" alt="image-20230910213252764"></p><h3 id="2-2-3-自动提交"><a href="#2-2-3-自动提交" class="headerlink" title="2.2.3 自动提交"></a>2.2.3 自动提交</h3><p>前面提到了，MySQL的自动提交默认是开启的；那么这个自动提交有什么作用呢？是不是开启了自动提交，就不需要手动创建事务了？</p><p><strong>并不是</strong>！在之前的测试中，<code>autocommit</code>是开启的；我们已经证明了，手动<code>begin</code>创建的事务，在没有手动<code>commit</code>的时候不会被写入磁盘（不进行持久化）；这代表我们手动创建的事务，不会受到<code>autocommit</code>是否开关的影响；（开着的时候都没有自动提交，关闭的时候肯定更不会自动提交了）</p><ul><li>那么这个<code>autocommit</code>会影响谁呢？</li></ul><p>开启两个终端，左侧将自动提交关闭，随后插入一个数据；插入后会发现右侧看不到左侧新插入的数据！</p><blockquote><p>备注：<code>set autocommit = 0;</code>语句只会影响当前终端，不会影响另外的终端。</p></blockquote><p><img src="https://img.musnow.top/i/2023/09/05a473c988222c4e9f669040110ce010.png" alt="image-20230911081342217"></p><p>此时手动进行<code>commit</code>，右侧就看得到数据了！</p><p><img src="https://img.musnow.top/i/2023/09/b0c20ecfa43ae1ba23143c78abea5a3d.png" alt="image-20230911081509985"></p><p>而如果我们不手动执行<code>commit</code>就把左侧终端<code>CTRL+\</code>退出，那么新插入的这一条数据会丢失！</p><h3 id="2-2-4-单条SQL和事务的关系"><a href="#2-2-4-单条SQL和事务的关系" class="headerlink" title="2.2.4 单条SQL和事务的关系"></a>2.2.4 单条SQL和事务的关系</h3><p>欸？我们明明没有<code>begin</code>开启事务，为什么可以执行<code>commit</code>呢？</p><p>这是因为，在MySQL中，每一个不主动使用事务的单条SQL语句，都会视作一个事务进行操作！既我们之前没学习事务时，执行的所有单条SQL也是一个个各自独立的事务！</p><p>知道了这一点，你就能理解<strong>自动提交的作用</strong>了：在执行单条SQL的时候，是否自动提交该SQL语句的事务。</p><p>将<code>autocommit</code>重新开启，再进行测试；会发现左侧插入的数据右侧可以立马看到，无需手动<code>commit</code>。这便是自动提交的作用的体现！</p><p><img src="https://img.musnow.top/i/2023/09/2fa8f41ee1644efb200d2fdbe65677ac.png" alt="image-20230911082134863"></p><h2 id="2-3-结论"><a href="#2-3-结论" class="headerlink" title="2.3 结论"></a>2.3 结论</h2><p>经过上面的这些简单测试，我们可以看到事务的原子性和持久性，做一个总结</p><ul><li>输入了<code>begin/start transaction</code>手动创建的事务，必须通过<code>commit</code>手动挡提交，才会持久化；这一点和<code>autocommit</code>无关！</li><li>事务可以设置保存点和手动回滚，出现异常的时候，MySQL会自动回退到事务开头；</li><li>对于<code>InnoDB</code>存储引擎而言，所有的单条SQL语句都会被视作一个事务，自动提交；</li><li><code>select</code>语句会有一些差别，因为MySQL有MVCC访问控制（后文讲解）</li></ul><p>操作事务的一些注意事项</p><ul><li>只有<code>InnoDB</code>才支持事务，<code>MyISAM</code>不支持;</li><li>一个事务被提交了之后，不可以执行<code>rollback</code>;</li><li>创建了保存点后，可以选择回退到哪一个保存点，亦或者是回退到事务开头；</li></ul><h1 id="3-事务隔离级别"><a href="#3-事务隔离级别" class="headerlink" title="3.事务隔离级别"></a>3.事务隔离级别</h1><h2 id="3-1-基本说明"><a href="#3-1-基本说明" class="headerlink" title="3.1 基本说明"></a>3.1 基本说明</h2><p>事务的隔离级别和事务的隔离性息息相关</p><ul><li>MySQL的单个数据库可能被多个进程&#x2F;线程同时进行访问和事务操作；</li><li>一个事务是由多个SQL语句组成的，任何一个事务，都会存在执行前&#x2F;中&#x2F;后的阶段。所谓原子性，就是MySQL要保证各个客户端要么只能看到事务执行前或者执行后的数据；执行中的事务，对于其他用户来看是原子的，出现异常会被自动回滚；</li><li>但事务毕竟还是存在执行中的概念，其他客户端是有可能看到某个事物执行中的状态的，这就需要隔离性来介入了；</li><li>隔离性：保证事务在执行过程中尽量不受干扰；</li><li>隔离级别：允许事务受不同程度的干扰；</li></ul><p>开头就提到了，MySQL的事务有4种隔离级别</p><ul><li>读未提交（Read Uncommitted）：在这个隔离级别中，所有事务都可以看到其他事物还没有提交的内容（你可以理解为压根没有隔离性，之前的测试使用的就是这个隔离级别）这种情况下就容易引起并发和读取数据的不一致问题，还有<strong>脏读</strong>问题（对方没有commit的数据就叫做脏数据），生产环境中是打死不能用这个隔离级别的！</li><li>读已提交（Read Committed）：在这个隔离级别中，事务只可以看到其他事务已经提交了的内容。这已经满足了隔离的基本定义：只能看到其他事务开始前或者开始后的内容；但是这种隔离模式会产生<strong>不可重复读</strong>的问题（相同<code>select</code>会出现不同结果）；</li><li>可重复读（Repeatable Read）：为了解决不可重复读的问题，这个隔离级别保证了事务在运行过程中多次读取相同数据时会得到相同结果；但是这个隔离级别在某些数据库中可能会出现<strong>幻读</strong>问题；MySQL默认采用此隔离级别；</li><li>串行化（Serializable）：所谓串行化，就是MySQL给数据库的所有操作都上锁，必须要排队运行。一个事务在运行时，另外一个事务得等它运行完毕了才能进来运行，这样能最大程度保证隔离性；但是会降低效率；</li></ul><p>隔离级别是由MySQL进行各种类型的加锁来实现的，比如表锁、行锁、读写锁、间隙锁（GAP）、NEXT-KEY锁（GAP+行锁）等等；</p><blockquote><p>这里还需要验证另外一件事，MySQL如果开启了串行化，客户端c&#x2F;cpp操作还需要加锁吗？<code>mysqlquery</code>的操作是会阻塞还是直接错误退出？</p></blockquote><p>在MySQL中，事务的隔离级别可以分别设置全局的隔离级别和当前客户端的隔离级别；如果没有主动设置客户端的隔离级别，则会继承全局的隔离级别。顾名思义，会话隔离级别只会影响当前的会话，不会影响另外的客户端；</p><p>另外，全局的隔离级别会在数据库服务重启后，被重置为配置文件中默认的隔离级别（一般是RR）</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 设置 会话/全局 隔离级别</span></span><br><span class="line"><span class="keyword">set</span> [session <span class="operator">|</span> <span class="keyword">global</span>] transaction isolation level [read uncommitted <span class="operator">|</span> read committed <span class="operator">|</span> repeatable read <span class="operator">|</span> serializable ]</span><br><span class="line"><span class="comment">-- 查看当前会话的隔离级别</span></span><br><span class="line"><span class="keyword">select</span> @<span class="variable">@session</span>.tx_isolation;</span><br><span class="line"><span class="comment">-- 查看全局的隔离级别</span></span><br><span class="line"><span class="keyword">select</span> @<span class="variable">@tx</span>_isolation;</span><br></pre></td></tr></table></figure><h2 id="3-2-读未提交"><a href="#3-2-读未提交" class="headerlink" title="3.2 读未提交"></a>3.2 读未提交</h2><p>这个隔离级别在第二大点里面就已经测试过了，左侧终端插入的数据，即便没有commit，在右侧终端中也能看得到，这里就不二次演示了</p><p><img src="https://img.musnow.top/i/2023/09/8021cf95d4fa8a29c24771161f17cf52.png" alt="image-20230910164315360"></p><p>清楚已有的数据，来测试一下会话隔离级别的作用；默认情况下，全局和会话的隔离级别都是RR；</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">MariaDB [hello_mysql]&gt; select @@tx_isolation;</span><br><span class="line">+-----------------+</span><br><span class="line">| @@tx_isolation  |</span><br><span class="line">+-----------------+</span><br><span class="line">| REPEATABLE-READ |</span><br><span class="line">+-----------------+</span><br><span class="line">1 row in set (0.000 sec)</span><br><span class="line"></span><br><span class="line">MariaDB [hello_mysql]&gt; select @@session.tx_isolation;</span><br><span class="line">+------------------------+</span><br><span class="line">| @@session.tx_isolation |</span><br><span class="line">+------------------------+</span><br><span class="line">| REPEATABLE-READ        |</span><br><span class="line">+------------------------+</span><br><span class="line">1 row in set (0.000 sec)</span><br></pre></td></tr></table></figure><p>将左侧的终端中的会话隔离级别设置为读未提交</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">set</span> session transaction isolation level read uncommitted;</span><br></pre></td></tr></table></figure><p><strong>插入数据之前</strong>，执行一次<code>select</code>全列查询，两侧都是空；</p><p>在左侧插入数据后，右侧查看会发现依旧是<code>empty set</code>没有结果；只有左侧<code>commit</code>之后，右侧才能看到数据；这是因为在之前测试的时候，<strong>我们将自动提交关闭了</strong>；右侧看不到我们还没有提交的事务；</p><p><img src="https://img.musnow.top/i/2023/09/9c76acac8deca528d4226b226146de13.png" alt="image-20230911100829407"></p><p>右侧手动开启事务后，即便没有进行<code>commit</code>，但是左侧因为设置了读未提交，所以可以直接看到右侧还没有提交的事务中的修改。这便是这个隔离级别的特性；</p><p><img src="https://img.musnow.top/i/2023/09/6ba51b47e8c05b4171645e423f1ad6a2.png" alt="image-20230911101100927"></p><h2 id="3-3-读已提交"><a href="#3-3-读已提交" class="headerlink" title="3.3 读已提交"></a>3.3 读已提交</h2><p>接下来再将全局隔离级别设置为读已提交，重新开启两个终端进行测试；</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set global transaction isolation level read committed;</span><br></pre></td></tr></table></figure><p>设置完毕，重启终端后，可以看到两侧的隔离级别都是读已提交，自动提交都是开启的；</p><p><img src="https://img.musnow.top/i/2023/09/bc6c1464a3c9331191aee2a24f9273e4.png" alt="image-20230911102633596"></p><p>两侧都开启一个事务，左侧插入数据，右侧查看，发现没有内容；</p><p><img src="https://img.musnow.top/i/2023/09/8e60ab3a2b5b4bff70b80ed22bce706b.png" alt="image-20230911103402950"></p><p>左侧commit之后，右侧才可以看到这个数据；</p><p><img src="https://img.musnow.top/i/2023/09/9ec9807c381ccebd42a77a741151c422.png" alt="image-20230911103432740"></p><p>这符合我们对<strong>读已提交</strong>这个隔离级别的字面理解，但是这并不代表这个隔离级别没有问题！</p><h3 id="3-3-1-出问题的场景"><a href="#3-3-1-出问题的场景" class="headerlink" title="3.3.1 出问题的场景"></a>3.3.1 出问题的场景</h3><p>来看看下面这个场景：</p><ul><li>公司需要根据员工工资，分发不同级别的奖金：<ul><li>2000-4000 级别一</li><li>4001-8000 级别二</li><li>8001-15000 级别三</li></ul></li><li>甲开启了一个客户端，开始用MySQL筛选不同工资区间的员工，记录下来；</li><li>乙开启了一个客户端，想要给员工丁加工资<ul><li>丁原本的工资是3000</li><li>乙给丁加了2000工资，丁的工资变成了5000，跳到了工资级别二；</li><li>乙提交修改（commit）</li></ul></li><li>假设甲已经完成了对2000-4000级别工资的员工筛选，此时乙过来给丁加了工资，丁跳到了工资级别二；</li><li>因为隔离级别是读已提交，甲在筛选工资级别二的人员时，会把刚刚被修改过的丁也给纳入进去；</li><li>这时候，对于甲而言，<strong>丁就同时出现在了工资级别一和二的人员中，这明显是不合理的</strong>！</li></ul><p>这个场景被称为<code>不可重复读</code>，即在一个事务中，同一个查询语句，可能会因为其他事务的提交而产生不同的结果；换做SQL语句来描述，在读已提交的隔离级别中，同一个select语句只能执行一次，第二次执行的时候，可能会获取到和第一次不同的结果，所以这个问题才被称作<code>不可重复读</code>（不可以重复执行select）问题；</p><hr><p>来实际演示一下，两侧都开启一个新的事务，左侧终端更新表中的用户id，只要它不提交，右侧就看不到修改。</p><p><img src="https://img.musnow.top/i/2023/09/8789693271635e5d27c7ad0873937af8.png" alt="image-20230911105147039"></p><p>但是提交了之后，右侧就能看到这个用户id的改变，在进行数据筛选的时候，这种情形就会出现问题！</p><p><img src="https://img.musnow.top/i/2023/09/c9f4f3c119361dfcfab135c9e4342921.png" alt="image-20230911105214340"></p><h2 id="3-4-可重复读"><a href="#3-4-可重复读" class="headerlink" title="3.4 可重复读"></a>3.4 可重复读</h2><p>所以，为了避免上面提到的这个问题，MySQL还提供了一个可重复读的隔离级别，且默认采用的就是这个隔离级别；</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">set</span> <span class="keyword">global</span> transaction isolation level  repeatable read;</span><br></pre></td></tr></table></figure><p>可重复读就解决了上面提到的问题，即便其他事务提交了修改，当前事务也看不到这份修改，只有当前事务结束后，才能看到最新的数据；</p><p>看下图，两侧都开启一个事务，不管左侧是否有提交事务，右侧都看不到左侧新插入的数据；</p><p><img src="https://img.musnow.top/i/2023/09/c702bd94bb9b4f1b39da177aba23faf0.png" alt="image-20230911150201158"></p><p>只有右侧也提交了自己的事务，才能看到左侧插入的新数据；</p><p><img src="https://img.musnow.top/i/2023/09/8e5ce5e2e310cf65a10b003bb0036e3e.png" alt="image-20230911150323005"></p><p>这就保证了，右侧这个事务在运行的始终，它执行的相同<code>select</code>语句的结果永远都是一样的，不会出现不可重复读的问题！</p><p>而如果在RR级别中，同时访问相同数据，会出现<strong>加锁</strong>的情况，下图中，右侧插入了主键为6的数据，此时左侧如果也尝试插入一个主键为6的数据，会进入阻塞状态；</p><p><img src="https://img.musnow.top/i/2023/09/fa7dbb9ad31fd27e00307f37aac40a4e.png" alt="image-20230911151027879"></p><p>如果很久都不继续操作，就会因为等待超时，跳出等待</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">MariaDB [hello_mysql]&gt; insert into test_ruc values (6,60,&#x27;天数&#x27;);</span><br><span class="line">ERROR 1205 (HY000): Lock wait timeout exceeded; try restarting transaction</span><br></pre></td></tr></table></figure><p>但当前事务中插入的数据依旧是存在的，当前事务也没有结束</p><p><img src="https://img.musnow.top/i/2023/09/d8de538b5a89adf04842efd2097239c6.png" alt="image-20230911151335335"></p><p>再次尝试插入这个主键为6的数据，依旧会陷入阻塞态，只有右侧的事务被提交了之后，左侧才会出现主键冲突的提示，禁止插入；</p><p><img src="https://img.musnow.top/i/2023/09/be7f7f5c5a63329fbe574ba4ff22d085.png" alt="image-20230911151444595"></p><p>左侧commit了之后，右侧才能看到左侧新插入的主键为5的数据；</p><p><img src="https://img.musnow.top/i/2023/09/0827a5499036b9e5b024b60f174ec44a.png" alt="image-20230911151710391"></p><h2 id="3-5-串行化"><a href="#3-5-串行化" class="headerlink" title="3.5 串行化"></a>3.5 串行化</h2><p>这个就比较简单了，一个事务没结束，另外一个就阻塞等待；</p><p>串行化是最高的隔离级别，但其并发性能很低，实际上用的也不多；</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">set</span> <span class="keyword">global</span> transaction isolation level  serializable;</span><br></pre></td></tr></table></figure><p>两侧终端都开始事务，查询的时候是不会加锁的，但是左侧执行<code>update</code>的时候，阻塞了（可以通过左侧update的执行时间观察到阻塞现象，截图看的不是很明显）；右侧也执行一次<code>update</code>，左侧的update就立马成功了，右侧显示报错检测到死锁，建议尝试重启事务；</p><p><img src="https://img.musnow.top/i/2023/09/d75f063fa7959ec6c7926eba70d25e35.png" alt="image-20230911110259760"></p><p>再来试试，两侧都开启事务，左侧尝试插入一个数据，<strong>会阻塞</strong>；右侧<code>commit</code>之后，左侧的插入就立马成功了！</p><p><img src="https://img.musnow.top/i/2023/09/8f8ed448629e2b9a842eb819c91f6cea.png" alt="image-20230911110525989"></p><p>这便是串行化的表现：两个事务如果都是在执行select的读取操作，则不会被阻塞，但如果有一个事务要执行<strong>增删改</strong>，那么就必须等待其他事务都结束了，这个操作才能被执行；</p><h3 id="3-5-1-串行化的适用场景"><a href="#3-5-1-串行化的适用场景" class="headerlink" title="3.5.1 串行化的适用场景"></a>3.5.1 串行化的适用场景</h3><p>回到 <a href="#jump1">1.1.2 卖票</a> 的场景，在这个场景下，如果你需要保证客户端A的卖票逻辑完全执行完毕了，客户端B才能过来查询票数，那就需要使用串行化；</p><p>但是，串行化中，我们是可以执行查询操作的！那么在A没有结束的情况下，B不还是会查询到有剩余票数？</p><blockquote><p>实际上，我们的卖票操作并不是直连数据库实现的，而是有一个服务端进程来提供API，供客户端来查询剩余票数，剩下的卖票操作其实都是服务端来实现的（让客户端直连MySQL来执行SQL是非常不可靠的，很有可能出现SQL注入攻击）</p></blockquote><p>所以，这个问题得在服务端进程中加锁解决！MySQL本身即便使用串行化也是没有办法解决这个问题的；</p><p>但是，别忘了，MySQL还有另外一个东西——<strong>约束</strong>；你可以设置一个触发器，更新剩余票数的时候，拒绝将票数设置为负数；这样客户端B即便进入了卖票业务，最终将剩余票数的数据设置为负数的时候，<strong>也会被MySQL阻止插入</strong>，这个卖票的事务B就相当于错误退出了，所有操作都会被回滚！而隔离级别就是避免A和B同时修改一个数据而导致的错误；</p><p>二者相辅相成，就能解决这个问题；当然，在服务端API处理逻辑中加锁是更好的解决办法，既可以保证数据一致性，又能隔离客户端和MySQL服务；</p><blockquote><p>后文讲到的当前读也能在某种程度上解决这个问题，反正解决的办法多多！</p></blockquote><h3 id="3-5-2-串行化和CPP"><a href="#3-5-2-串行化和CPP" class="headerlink" title="3.5.2 串行化和CPP"></a>3.5.2 串行化和CPP</h3><p>如果将 MySQL 的隔离级别（isolation level）设置为最高级别的串行化（SERIALIZABLE），那么并发的多线程操作可能会遇到以下情况之一：</p><ol><li>阻塞：当一个线程正在使用某个数据时，其他线程需要等待该线程释放锁才能继续进行操作。这会导致其他线程在获得所需锁之前被阻塞。</li><li>错误退出：如果多个线程同时操作相同的数据，并且它们无法同时持有访问该数据的锁，就会引发死锁。在这种情况下，某些线程会被系统终止，从而导致错误退出。</li></ol><p>所以，并不是说你将MySQL的隔离级别设置好了，那么客户端就啥事不用干了；最好的操作依旧是在客户端就加锁进行一定的访问控制，因为MySQL Query函数的错误退出+退出情况识别，相比于客户端进行访问控制更难以操作；</p><h2 id="3-6-总结"><a href="#3-6-总结" class="headerlink" title="3.6 总结"></a>3.6 总结</h2><ul><li>隔离级别越高，安全性越高，数据库的并发性能就越低；我们需要根据业务逻辑，选用合适的隔离级别；</li><li>不可重复读的问题在于其他客户端的修改和删除，同样的select语句会查出不同的结果，是不合理的；</li><li>幻读的重点在于新增，其他客户端新增的记录可能被我们当前的客户端查询到；但是在MySQL中，这个问题是不存在的，因为<code>InnoDB</code>通过NEXT-KEY锁解决了幻读问题；</li><li>事务也分为长短事务的概念，事务之间互相影响，主要指的是事务在并行阶段（都没有<code>commit</code>的时候）产生的影响；</li><li>一般情况下，我们使用MySQL默认的RR的事务级别就可以了；</li></ul><p>下面给出一个不同事务级别之间的区别的表格，Y代表会出现这个问题，N代表不会出现这个问题</p><table><thead><tr><th>隔离级别</th><th>脏读</th><th>不可重复读</th><th>幻读</th><th>加锁读</th></tr></thead><tbody><tr><td>读未提交</td><td>Y</td><td>Y</td><td>Y</td><td>不加锁</td></tr><tr><td>读已提交</td><td>N</td><td>Y</td><td>Y</td><td>不加锁</td></tr><tr><td>可重复读</td><td>N</td><td>N</td><td>N</td><td>不加锁</td></tr><tr><td>串行化</td><td>N</td><td>N</td><td>N</td><td>加锁</td></tr></tbody></table><h2 id="3-7-一致性"><a href="#3-7-一致性" class="headerlink" title="3.7 一致性"></a>3.7 一致性</h2><ul><li>事务执行的结果，必须使数据库从一个一致性状态，变到另一个一致性状态。当数据库只包含事务 成功提交的结果时，数据库处于一致性状态。</li><li>如果系统运行发生中断，某个事务尚未完成而被迫中 断，而改未完成的事务对数据库所做的修改已被写入数据库，此时数据库就处于一种不正确（不一致）的状态。因此一致性是通过<strong>原子性</strong>来保证的。</li><li>其实一致性和用户的业务逻辑强相关，一般MySQL提供技术支持，但是一致性还是要用户业务逻辑做支撑（比如客户端如果不使用事务，那MySQL也没有办法帮助维护），所以说，一致性是由用户决定是否维护的。 </li><li>技术上，通过AID保证C</li></ul><h1 id="4-隔离性的理解"><a href="#4-隔离性的理解" class="headerlink" title="4.隔离性的理解"></a>4.隔离性的理解</h1><p>说完了隔离级别，接下来再深入理解一下隔离性</p><h2 id="4-1-MVCC"><a href="#4-1-MVCC" class="headerlink" title="4.1 MVCC"></a>4.1 MVCC</h2><p>数据库并发的场景一共有下面三种</p><ul><li><code>读-读</code>：不存在任何问题，不需要访问控制</li><li><code>读-写</code>：有线程安全问题，可能会遇到隔离性中的脏读、幻读、不可重复读问题；</li><li><code>写-写</code>：有线程安全问题，还有可能出现更新丢失问题；</li></ul><p>我们主要关注的是读写并发的情况，这也是数据库最常遇到的处理场景；</p><p>再MySQL中，采用了MVCC（多版本并发控制）来解决读写冲突，这是一种无锁的并发控制机制；</p><p>在了解MVCC之前，我们需要了解几个前置知识：</p><ul><li>三个隐藏列字段</li><li>UNDO日志</li><li>READ VIEW</li></ul><h3 id="4-1-1-隐藏列字段"><a href="#4-1-1-隐藏列字段" class="headerlink" title="4.1.1 隐藏列字段"></a>4.1.1 隐藏列字段</h3><p>在MySQL中，每一个表都存在三个隐藏的列字段</p><ul><li>DB_TRX_ID：6 byte，最近修改(修改&#x2F;插入)事务ID，记录创建这条记录&#x2F;最后一次修改该记录的事务ID；</li><li>DB_ROLL_PTR: 7 byte，回滚指针，指向这条记录的上一个版本（简单理解成，指向历史版本就 行，这些数据一般在 <code>undo log</code> 中） </li><li>DB_ROW_ID: 6 byte，隐含的自增ID（隐藏主键），如果数据表没有主键， InnoDB 会自动以 DB_ROW_ID 产生一个<strong>聚簇索引</strong>；</li><li>补充：实际还有一个删除flag隐藏字段，既记录被更新或删除并不代表真的删除，而是删除flag变了；</li></ul><p>假设有如下表结构</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> if <span class="keyword">not</span> <span class="keyword">exists</span> student(</span><br><span class="line">    name <span class="type">varchar</span>(<span class="number">11</span>) <span class="keyword">not</span> <span class="keyword">null</span>,</span><br><span class="line">    age <span class="type">int</span> <span class="keyword">not</span> <span class="keyword">null</span></span><br><span class="line">);</span><br><span class="line"><span class="comment">-- 插入一条记录</span></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> student (name, age) <span class="keyword">values</span> (<span class="string">&#x27;张三&#x27;</span>, <span class="number">19</span>);</span><br></pre></td></tr></table></figure><p>那么这个表中的实际数据是这样的</p><table><thead><tr><th>name</th><th>age</th><th>DB_TRX_ID(创建这个记录的事务ID)</th><th>DB_ROW_ID（隐藏主键）</th><th>DB_ROLL_PTR（回滚指针）</th></tr></thead><tbody><tr><td>张三</td><td>19</td><td>NULL</td><td>1</td><td>NULL</td></tr></tbody></table><p>我们并不知道创建这个记录的事务ID，所以设置为NULL；因为是第一条记录，所以隐藏主键是1；因为是第一条记录，所以没有回滚的地方，回滚指针也是NULL（换句话说，如果回滚指针为NULL，代表这个就是这个表中的第一条记录了）</p><h3 id="4-1-2-undo日志"><a href="#4-1-2-undo日志" class="headerlink" title="4.1.2 undo日志"></a>4.1.2 undo日志</h3><p>MySQL是以服务进程的方式在内存中运行的，我们对数据的CURD操作，都需要通过MySQL将其刷入到硬盘上进行持久化，MySQL为这些操作会提供一个专门的<code>buffer pool</code>内存缓冲区；而<code>undo log/redo log</code>也是内存中的一块区域，对于MySQL而言</p><ul><li>日志需要立刻刷盘（有一个专门的线程来管理日志）</li><li>数据根据运行策略，选择合适的时间刷盘（因为数据量一般比较大，如果实时刷盘会造成较大IO负载，影响进程运行）</li></ul><p>先来说说<code>redo log</code>，这里包含了MySQL中的所有尚未落盘的CURD操作；如果MySQL还没有写入数据的时候就挂了，那么下次启动的时候就会从<code>redo log</code>里面恢复数据，来确保数据的一致性和完整性；</p><p>在MySQL存储路径<code>/var/lib/mysql</code>中的<code>ib_logfile0/ib_logfile1</code>就是<code>redo log</code>；</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-rw-rw----. 1 mysql mysql  50331648 Sep 11 03:16 ib_logfile0</span><br><span class="line">-rw-rw----. 1 mysql mysql  50331648 Sep  9 21:03 ib_logfile1</span><br></pre></td></tr></table></figure><p>而<code>undo log</code>主要用于以下功能</p><ol><li>回滚事务</li><li>MVCC（多版本控制&#x2F;隔离性和隔离级别）</li></ol><p>假设我们来了一个update操作，将刚刚插入的张三的年龄改成30岁，对于MySQL而言就会在<code>undo log</code>里面做如下处理；</p><ul><li>该update操作对应的事务<code>DB_TRX_ID</code>是10；</li><li>将旧数据放入<code>undo log</code>中，并将当前数据的<code>DB_ROLL_PTR</code>指向旧数据的地址；</li><li>如果需要回滚，那么就通过<code>DB_ROLL_PTR</code>找到旧数据，复写回去；</li></ul><p><img src="https://img.musnow.top/i/2023/09/6f386ba45e0c26e72de76bff973c4a4f.png" alt="image-20230911172501941"></p><p>如果再来一次修改，将张三的名字改成李四，也是依照这个逻辑在<code>undo log</code>中新增旧数据，并链接<code>DB_ROLL_PTR</code>指针；</p><ul><li>事务11修改这条数据，先申请锁；</li><li>将现有数据复制到<code>undo log</code>中（头插），并将<code>DB_ROLL_PTR</code>指针指向旧数据的地址；</li><li>修改记录中的name，并且将<code>DB_TRX_ID</code>改成当前事务的ID 11；</li><li>事务11提交，释放锁；</li></ul><p><img src="https://img.musnow.top/i/2023/09/d4a9aca8bdd9c3e38daa5b07896e7684.png" alt="image-20230911173024425"></p><p>这样，我们就有了一个类似于链表的历史版本链；每次回退的时候，都可以找到历史数据，覆盖当前的数据。这些版本我们称之为<code>快照</code>；</p><p>而插入和删除都可以写入<code>undo log</code>，但是只有更新和删除能形成历史版本链；</p><ul><li>删除是将删除flag置为真，旧数据依旧可以写入到<code>undo log</code>中，如果需要回滚，将这行记录恢复；</li><li>插入并没有历史版本，但也需要将其放入<code>undo log</code>中，事务回滚的时候需要将新插入的数据删除；</li><li>事务提交了之后，已有的历史记录可以被删除；</li></ul><p>增删改都说了，那么<code>select</code>呢？</p><p>一般而言，查询不会产生数据写入操作，也不需要设置历史版本链；</p><p>但是在之前关于RR级别隔离性的验证中，我们看到了<code>select</code>无法看到另外一个事务已经提交了的数据，这说明<code>select</code>有时候读取的是<strong>历史版本</strong>的数据，而并非当前最新的数据！</p><p>读取历史数据我们称之为<code>快照读</code>，在RR级别中默认采用的就是快照读；读取最新数据叫做当前读（增删改都是当前读）；还有一种读取是为了更新而查询；</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> ... <span class="comment">-- 在RR级别下，默认是快照读</span></span><br><span class="line"><span class="keyword">select</span> ... <span class="keyword">for</span> <span class="keyword">update</span>; <span class="comment">-- 为了更新而查询</span></span><br><span class="line"><span class="comment">-- MySQL会将当前行上排他锁，上锁了之后，其他客户端只能查询该行，无法修改</span></span><br><span class="line"><span class="keyword">select</span> ... lock <span class="keyword">in</span> share mode; <span class="comment">-- 查询最新数据（当前读）</span></span><br><span class="line"><span class="comment">-- 是串行化的，只有其他事务完成了，才能查询到最新结果；</span></span><br></pre></td></tr></table></figure><p>除了手动指定<code>select</code>的查询方式以外，隔离级别会影响<code>select</code>的默认行为，比如在串行化隔离级别的场景下，默认执行的就是<strong>当前读</strong>；</p><p>在RR模式下进行测试，会发现当前读会阻塞当前的客户端（右侧客户端阻塞）；</p><p><img src="https://img.musnow.top/i/2023/09/4025f787fda333689872e3295712df1b.png" alt="image-20230911200703608"></p><p>只有左侧的事务在提交了之后，右侧的查询才会返回最新的结果；</p><p><img src="https://img.musnow.top/i/2023/09/1675840504edd0a5689e3a6ec052a4dd.png" alt="image-20230911201033979"></p><p>这是因为<strong>当前读</strong>，包括增删改操作，是需要加锁的；如果要在RR模式下实现当前读，那么整个系统就需要<strong>串行化</strong>执行；</p><p>而快照读不需要加锁，因为它可以读取历史版本，而历史版本是不会被其他线程修改的，也就不需要维护访问控制，提高了并发效率；</p><p>那么，MySQL是如何实现快照读的呢？</p><h3 id="4-1-3-Read-View"><a href="#4-1-3-Read-View" class="headerlink" title="4.1.3 Read View"></a>4.1.3 Read View</h3><p><code>Read View</code>就是MySQL为快照读生成的一个<strong>读视图</strong>；在事务执行快照读的时候（即执行<code>select</code>的时候）将当前数据拍一张照，这样在这个事务中，后续的所有<code>select</code>都只会看到这个照片里面的结果，看不到其他事务最新的修改（不管其他事务是否commit）。</p><blockquote><p>快照读的现象我们已经在本文 <code>3.4 可重复读</code> 中演示过了，这里就不再二次演示了；</p></blockquote><p><code>Read View</code>在MySQL的源码中其实就是一个类，该类中包含一些可读性判断的信息，内部有条件，来标明当前事务能够看到那个版本的数据，即有可能是当前最新的数据，也有可能是<code>undo log</code>中的某个历史版本；</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ReadView</span> &#123;</span><br><span class="line"><span class="comment">// 省略...</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">/** 高水位，大于等于这个ID的事务均不可见*/</span></span><br><span class="line">    <span class="type">trx_id_t</span> m_low_limit_id</span><br><span class="line">    <span class="comment">/** 低水位：小于这个ID的事务均可见 */</span></span><br><span class="line">    <span class="type">trx_id_t</span> m_up_limit_id;</span><br><span class="line">    <span class="comment">/** 创建该 Read View 的事务ID*/</span></span><br><span class="line">    <span class="type">trx_id_t</span> m_creator_trx_id;</span><br><span class="line">    <span class="comment">/** 创建视图时的活跃事务id列表，是一个位图 */</span></span><br><span class="line">    <span class="type">ids_t</span> m_ids;</span><br><span class="line">    <span class="comment">/** 配合purge，标识该视图不需要小于m_low_limit_no的UNDO LOG，</span></span><br><span class="line"><span class="comment">    * 如果其他视图也不需要，则可以删除小于m_low_limit_no的UNDO LOG*/</span></span><br><span class="line">    <span class="type">trx_id_t</span> m_low_limit_no;</span><br><span class="line">    <span class="comment">/** 标记视图是否被关闭*/</span></span><br><span class="line">    <span class="type">bool</span> m_closed;</span><br><span class="line">    <span class="comment">// 省略...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>单独说明一下这里的4个重要的变量；其中需要注意，在这里面<strong>up是低水位，low是高水位</strong>，这是由他们保存的数据的性质决定的，请不要和这两个单词的本意混淆！</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">m_ids; <span class="comment">// 一张位图，用来保存Read View生成时，系统正活跃（没有结束的）的事务ID</span></span><br><span class="line">up_limit_id; <span class="comment">// 记录m_ids列表中事务ID最小的ID </span></span><br><span class="line">low_limit_id; <span class="comment">// ReadView生成时刻系统尚未分配的下一个事务ID，也就是目前已出现过的事务ID的最大值+1</span></span><br><span class="line">creator_trx_id <span class="comment">// 创建该ReadView的事务ID</span></span><br></pre></td></tr></table></figure><p>要知道，当前事务是知道自己的事务ID的（<code>DB_TRX_ID</code>），那么我们手中就有快照读中最大最小的事务ID，以及当前活跃中的事务ID；那么在读取版本链的时候，就进行如下匹配，设当前开启的这个<strong>事务为A</strong>:</p><ul><li>版本链中的事务ID不存在于<code>m_ids</code>中，代表<strong>事务A开启</strong>的时候，这个事务已经提交了，所以我们可以读取这个事务操作的结果；</li><li>版本链中的事务ID存在于<code>m_ids</code>中，代表事务A开启的时候，这个事务是<strong>活跃状态</strong>，那么我就不应该读到这个事务的操作结果；</li><li>版本链的中的事务ID大于<code>low_limit_id</code>，代表事务A开启的时候，这个事务还不存在，所以也不应该看到这个在A之后来的事务的操作结果；（A还没操作完毕，这个新事务就来了）</li><li>版本链中的事物ID小于<code>up_limit_id</code>，代表事物A开启的时候，这个事物都不知道是是它的父亲辈还是爷爷辈了，<strong>长辈给你留下的东西肯定得好好收着</strong>；说人话：这个是A来之前的之前就已经结束了的事物，肯定是可以读取其结果的；</li></ul><p>在MySQL中我们可以看到如下源码，链接也贴出来了，github上可以查看源码；这个函数就是用来判断当前事务应该能看到那些版本链的，具体的判断逻辑参考中文注释（英文注释是官方留的）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这个函数是ReadView类的成员函数 ReadView::changes_visible </span></span><br><span class="line"><span class="comment">// 源码链接 https://github.com/mysql/mysql-server/blob/ea1efa9822d81044b726aab20c857d5e1b7e046a/storage/innobase/include/read0types.h#L162  </span></span><br><span class="line"></span><br><span class="line"><span class="comment">// [[nodiscard]] 代表这个函数的返回值不能被忽略，一定需要使用该返回值；否则编译器会爆警告；即告知程序员必须关注这个函数的返回值！</span></span><br><span class="line"><span class="comment">// 函数的返回值是当前事务能否看到某一个事务id值的版本链，入参是目标事务id</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/** Check whether the changes by id are visible.</span></span><br><span class="line"><span class="comment">  @param[in]    id      transaction id to check against the view</span></span><br><span class="line"><span class="comment">  @param[in]    name    table name</span></span><br><span class="line"><span class="comment">  @return whether the view sees the modifications of id. */</span></span><br><span class="line">  [[nodiscard]] <span class="function"><span class="type">bool</span> <span class="title">changes_visible</span><span class="params">(<span class="type">trx_id_t</span> id,</span></span></span><br><span class="line"><span class="params"><span class="function">                                     <span class="type">const</span> <span class="type">table_name_t</span> &amp;name)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">    <span class="built_in">ut_ad</span>(id &gt; <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 小于最小的事务id或者等于当前事务id，则代表这个事务我们可以看到 </span></span><br><span class="line">    <span class="keyword">if</span> (id &lt; m_up_limit_id || id == m_creator_trx_id) &#123;</span><br><span class="line">      <span class="keyword">return</span> (<span class="literal">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">check_trx_id_sanity</span>(id, name);</span><br><span class="line"><span class="comment">// 如果这个id比当前事务中的高水位还大，说明这个id是后来者，不应该看到</span></span><br><span class="line">    <span class="keyword">if</span> (id &gt;= m_low_limit_id) &#123;</span><br><span class="line">      <span class="keyword">return</span> (<span class="literal">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// 如果当前事务创建时，没有活跃事务</span></span><br><span class="line">    <span class="comment">// 且 m_up_limit_id &lt;= id &lt; m_low_limit_id </span></span><br><span class="line">    <span class="comment">// 那么这个事务ID就可以被看到，返回真</span></span><br><span class="line">     <span class="keyword">else</span> <span class="keyword">if</span> (m_ids.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">      <span class="built_in">return</span> (<span class="literal">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">const</span> <span class="type">ids_t</span>::value_type *p = m_ids.<span class="built_in">data</span>();</span><br><span class="line"><span class="comment">// 如果上面都没有匹配到，那就检查这个id是否在活跃列表m_ids中</span></span><br><span class="line">    <span class="comment">// std::binary_search的返回值：是否在位图中，true代表在，false代表不在</span></span><br><span class="line">    <span class="comment">// 如果在，那么这个事务是活跃状态，不能被看到</span></span><br><span class="line">    <span class="comment">// 如果不在，那么这个事务是已经提交了，可以被看到</span></span><br><span class="line">    <span class="keyword">return</span> (!std::<span class="built_in">binary_search</span>(p, p + m_ids.<span class="built_in">size</span>(), id));</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>如果查到不应该看到当前版本，接下来就是遍历下一个版本，直到符合条件，即可以看到。这便是我们select当前读的时候，会自动产生的<code>ReadView</code>结构体的作用；</p><p>根据这份源码，我们也能知道<code>m_ids</code>位图中，并不需要存放当前事务ID，因为会有额外的判断来处理当前事务ID！</p><h2 id="4-2-快照读实操"><a href="#4-2-快照读实操" class="headerlink" title="4.2 快照读实操"></a>4.2 快照读实操</h2><h3 id="4-2-1-快照是什么时候生成的？"><a href="#4-2-1-快照是什么时候生成的？" class="headerlink" title="4.2.1 快照是什么时候生成的？"></a>4.2.1 快照是什么时候生成的？</h3><p>假设当前的事务流程如下，事务2能看到事务1的操作结果吗？</p><table><thead><tr><th>事务1</th><th>事务2</th></tr></thead><tbody><tr><td>事务开始</td><td>事务开始</td></tr><tr><td>插入数据1并提交事务</td><td></td></tr><tr><td></td><td>第一次查询</td></tr><tr><td>重开一个新事务，插入数据2并提交</td><td></td></tr><tr><td></td><td>第二次查询</td></tr></tbody></table><p>来实操一下，开两个MySQL终端，隔离级别设置为RR；图中黄字标出了每一个SQL的执行顺序；我们会发现，当左侧终端提交了第一个插入的数据后，右侧才查询，<strong>是可以看到这条新插入的数据的</strong>！</p><p>而左侧插入的第二条数据右侧就看不到了，很明显，此时访问的就是快照中的旧数据，而不是新数据了；</p><p><img src="https://img.musnow.top/i/2023/09/c8def576b68454081f60029cfa781b5a.png" alt="image-20230912094327001"></p><p>这就告诉我们：快照读的<strong>快照</strong>是在事务中第一次执行<code>select</code>语句的时候生成的！并不是事务开始的时候生成的！</p><p>这也非常合理，如果你的当前事务压根没有进行<code>select</code>语句，那我也就没有必要生成快照了，毕竟快照的底层是<code>ReadView</code>对象，也是会占用内存空间的！而增删改操作本身就是当前读，无需生成快照！</p><h3 id="4-2-2-实例解释ReadView的成员变量"><a href="#4-2-2-实例解释ReadView的成员变量" class="headerlink" title="4.2.2 实例解释ReadView的成员变量"></a>4.2.2 实例解释ReadView的成员变量</h3><p>用实际例子来解释一下ReadView里面的4个成员变量到底应该存放什么值；</p><p>假设有下面这个数据</p><table><thead><tr><th>name</th><th>age</th><th>DB_TRX_ID(创建这个记录的事务ID)</th><th>DB_ROW_ID（隐藏主键）</th><th>DB_ROLL_PTR（回滚指针）</th></tr></thead><tbody><tr><td>张三</td><td>19</td><td>NULL</td><td>1</td><td>NULL</td></tr></tbody></table><p>一共有4个事务同时运行，事务序号就是事务ID</p><table><thead><tr><th>事务2</th><th>事务3</th><th>事务4</th><th>事务5</th></tr></thead><tbody><tr><td>事务开始</td><td>事务开始</td><td>事务开始</td><td>事务开始</td></tr><tr><td>……</td><td>……</td><td>……</td><td>修改张三的年龄并提交</td></tr><tr><td>运行</td><td>快照读</td><td>运行</td><td>……</td></tr><tr><td>……</td><td>……</td><td>……</td><td>……</td></tr></tbody></table><p>在这种情况下，事务3对某行数据进行了快照读，MySQL就会在这时候生成一个<code>ReadView</code>，内部变量赋值如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">m_ids; <span class="comment">// 2,4 (当前事务5已经提交了，所以除了自己就只有2和4活跃中)</span></span><br><span class="line">up_limit_id; <span class="comment">// 2 (m_ids中最小事务ID)</span></span><br><span class="line">low_limit_id; <span class="comment">// 5 + 1 = 6 (当前已经出现的最大事务ID+1)</span></span><br><span class="line">creator_trx_id <span class="comment">// 3 (当前事务ID)</span></span><br></pre></td></tr></table></figure><p>当事务3进行快照读的时候，就会拿事务5的这份数据进行比较，最终得到的结果是，事务3的快照是<strong>可以</strong>看到事务5对数据进行的修改的！</p><p>而且对于全局来说，事务5提交的这份数据也是当前最新的数据！</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 比较流程（依照上方MySQL的源码）</span></span><br><span class="line"><span class="number">5</span> &lt; up_limit_id || <span class="number">5</span> == <span class="number">3</span>; <span class="comment">// 不小于最小的，且也不等于当前的事务ID 3</span></span><br><span class="line"><span class="number">5</span> &gt; low_limit_id; <span class="comment">// 不大于最大的</span></span><br><span class="line"><span class="comment">// 判断5是否在m_ids里面</span></span><br><span class="line">m_ids.<span class="built_in">contains</span>(<span class="number">5</span>); <span class="comment">// 不在</span></span><br><span class="line"><span class="comment">// 结论：return true;</span></span><br></pre></td></tr></table></figure><h2 id="4-3-当前读实操"><a href="#4-3-当前读实操" class="headerlink" title="4.3 当前读实操"></a>4.3 当前读实操</h2><p>快照读的场景基本搞明白了，再来试试当前读（这里小提一嘴，<strong>写-写并发</strong>可以理解为所有操作都是当前读，需要串行化）</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> ... lock <span class="keyword">in</span> share mode;</span><br></pre></td></tr></table></figure><p>下面是两个不同的操作流程，最终会得到不同的结果；操作之前，先执行如下两个sql</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">delete</span> <span class="keyword">from</span> test_ruc;</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> test_ruc <span class="keyword">values</span> (<span class="number">1</span>,<span class="number">20</span>,<span class="string">&#x27;张三&#x27;</span>);</span><br></pre></td></tr></table></figure><p>在第一次测试中，我们在左侧终端更新数据之前就执行了一次快照读，此时MySQL会生成快照，即便在左侧终端的事务commit了之后，右侧也无法看到最新的<code>user_id=18</code>的数据；<strong>此时使用当前读，就可以读取到最新的数据</strong>！</p><p><img src="https://img.musnow.top/i/2023/09/c7088a7f3657cc02ea436a8bfd30cb88.png" alt="image-20230912103634717"></p><p>而在第二次测试中，我们让左侧终端完成所有操作，右侧终端再去查询，会发现快照读和当前读都能查询到最新的修改；</p><p><img src="https://img.musnow.top/i/2023/09/615e7b7cfb64f9d8f4020469bd669cf3.png" alt="image-20230912103902180"></p><p>由此可见</p><ul><li>快照读的快照是第一次select查询的时候生成的</li><li>当前读能绕过快照查看到最新数据！</li></ul><h2 id="4-4-RR和RC的区别"><a href="#4-4-RR和RC的区别" class="headerlink" title="4.4 RR和RC的区别"></a>4.4 RR和RC的区别</h2><ul><li>正是Read View生成时机的不同，从而造成RC,RR级别下快照读的结果的不同</li><li>在RR级别下的某个事务的对某条记录的第一次快照读会创建一个快照及Read View, 将当前系统活 跃的其他事务记录起来</li><li>此后在调用快照读的时候，还是使用的是同一个Read View，所以只要当前事务在其他事务提交更新之前使用过快照读，那么之后的快照读使用的都是同一个Read View，所以对之后的修改不可见；</li><li>即RR级别下，快照读生成Read View时，Read View会记录此时所有其他活动事务的快照，这些事务的修改对于当前事务都是不可见的。而早于Read View创建的事务所做的修改均是可见；</li><li>而在RC级别下的，事务中，每次快照读都会<strong>新生成一个快照</strong>和Read View, 这就是我们在RC级别下的事务中可以看到别的事务提交的更新的原因；</li><li>总之在RC隔离级别下，是每个快照读都会生成并获取最新的Read View；而在RR隔离级别下，则是同一个事务中的第一个快照读才会创建Read View，之后的快照读获取的都是同一个Read View。 </li><li>正是RC每次快照读，都会形成Read View，所以，RC才会有不可重复读问题。</li></ul><h1 id="The-end"><a href="#The-end" class="headerlink" title="The end"></a>The end</h1><p>关于MySQL事务的内容到这里基本就OVER了，内容多多，也需要多多理解和复习！</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">可以深入阅读如下文章</span><br><span class="line">https://blog.csdn.net/SnailMann/article/details/94724197</span><br><span class="line">https://www.cnblogs.com/f-ck-need-u/archive/2018/05/08/9010872.html</span><br><span class="line">https://blog.csdn.net/chenghan_yang/article/details/97630626</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">事务的学习</summary>
    
    
    
    <category term="学习sql" scheme="https://blog.musnow.top/categories/%E5%AD%A6%E4%B9%A0sql/"/>
    
    
    <category term="Linux" scheme="https://blog.musnow.top/tags/Linux/"/>
    
    <category term="mysql" scheme="https://blog.musnow.top/tags/mysql/"/>
    
  </entry>
  
  <entry>
    <title>【MySQL】索引</title>
    <link href="https://blog.musnow.top/posts/3474107655/"/>
    <id>https://blog.musnow.top/posts/3474107655/</id>
    <published>2023-09-07T09:52:14.000Z</published>
    <updated>2023-09-07T09:52:30.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-索引"><a href="#1-索引" class="headerlink" title="1.索引"></a>1.索引</h1><h2 id="1-1-为啥需要索引？"><a href="#1-1-为啥需要索引？" class="headerlink" title="1.1 为啥需要索引？"></a>1.1 为啥需要索引？</h2><p>对于数据库而言，查询始终是一个高频的操作；假设在数据量到百万级的时候，查询一个用户信息就要花5秒中，那用户肯定不愿意等待你的系统响应，这就造成了用户流失。</p><p>所以，MySQL必须使用某种方式来保证查询的高速可靠，索引就诞生了；</p><p>对于使用者而言，索引是很香的，因为你只需要执行<code>create index</code>给指定的列，那么MySQL就会自动帮你维护一系列索引创建的操作，查询嘎嘎快！</p><p>但，查询速度的提高是以插入、更新、删除等操作的速度为代价的，这些写操作会增加大量的IO；索引的价值在于提高海量数据的查询速度；</p><p>常见的索引</p><ul><li>主键索引</li><li>唯一键索引</li><li>普通索引</li><li>复合索引</li><li>全文索引</li></ul><h2 id="1-2-索引的效果"><a href="#1-2-索引的效果" class="headerlink" title="1.2 索引的效果"></a>1.2 索引的效果</h2><p>通过如下的大数据用例，我们能看到索引的效果几何</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">drop</span> database if <span class="keyword">exists</span> `bit_index`;</span><br><span class="line"><span class="keyword">create</span> database if <span class="keyword">not</span> <span class="keyword">exists</span> `bit_index` <span class="keyword">default</span> <span class="type">character</span> <span class="keyword">set</span> utf8;</span><br><span class="line">use `bit_index`;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 构建一个8000000条记录的数据</span></span><br><span class="line"><span class="comment">-- 构建的海量表数据需要有差异性，所以使用存储过程来创建， 拷贝下面代码就可以了，暂时不用理解</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 产生随机字符串</span></span><br><span class="line">delimiter $$</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">function</span> rand_string(n <span class="type">INT</span>)</span><br><span class="line"><span class="keyword">returns</span> <span class="type">varchar</span>(<span class="number">255</span>)</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line"><span class="keyword">declare</span> chars_str <span class="type">varchar</span>(<span class="number">100</span>) <span class="keyword">default</span></span><br><span class="line"><span class="string">&#x27;abcdefghijklmnopqrstuvwxyzABCDEFJHIJKLMNOPQRSTUVWXYZ&#x27;</span>;</span><br><span class="line"><span class="keyword">declare</span> return_str <span class="type">varchar</span>(<span class="number">255</span>) <span class="keyword">default</span> <span class="string">&#x27;&#x27;</span>;</span><br><span class="line"><span class="keyword">declare</span> i <span class="type">int</span> <span class="keyword">default</span> <span class="number">0</span>;</span><br><span class="line">while i <span class="operator">&lt;</span> n do</span><br><span class="line"><span class="keyword">set</span> return_str <span class="operator">=</span>concat(return_str,<span class="built_in">substring</span>(chars_str,<span class="built_in">floor</span>(<span class="number">1</span><span class="operator">+</span>rand()<span class="operator">*</span><span class="number">52</span>),<span class="number">1</span>));</span><br><span class="line"><span class="keyword">set</span> i <span class="operator">=</span> i <span class="operator">+</span> <span class="number">1</span>;</span><br><span class="line"><span class="keyword">end</span> while;</span><br><span class="line"><span class="keyword">return</span> return_str;</span><br><span class="line"><span class="keyword">end</span> $$</span><br><span class="line">delimiter ;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 产生随机数字</span></span><br><span class="line">delimiter $$</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">function</span> rand_num( )</span><br><span class="line"><span class="keyword">returns</span> <span class="type">int</span>(<span class="number">5</span>)</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line"><span class="keyword">declare</span> i <span class="type">int</span> <span class="keyword">default</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">set</span> i <span class="operator">=</span> <span class="built_in">floor</span>(<span class="number">10</span><span class="operator">+</span>rand()<span class="operator">*</span><span class="number">500</span>);</span><br><span class="line"><span class="keyword">return</span> i;</span><br><span class="line"><span class="keyword">end</span> $$</span><br><span class="line">delimiter ;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 创建存储过程，向雇员表添加海量数据</span></span><br><span class="line">delimiter $$</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">procedure</span> insert_emp(<span class="keyword">in</span> <span class="keyword">start</span> <span class="type">int</span>(<span class="number">10</span>),<span class="keyword">in</span> max_num <span class="type">int</span>(<span class="number">10</span>))</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line"><span class="keyword">declare</span> i <span class="type">int</span> <span class="keyword">default</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">set</span> autocommit <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">repeat</span><br><span class="line"><span class="keyword">set</span> i <span class="operator">=</span> i <span class="operator">+</span> <span class="number">1</span>;</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> EMP <span class="keyword">values</span> ((<span class="keyword">start</span><span class="operator">+</span>i)</span><br><span class="line">,rand_string(<span class="number">6</span>),<span class="string">&#x27;SALESMAN&#x27;</span>,<span class="number">0001</span>,curdate(),<span class="number">2000</span>,<span class="number">400</span>,rand_num());</span><br><span class="line">until i <span class="operator">=</span> max_num</span><br><span class="line"><span class="keyword">end</span> repeat;</span><br><span class="line"><span class="keyword">commit</span>;</span><br><span class="line"><span class="keyword">end</span> $$</span><br><span class="line">delimiter ;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 雇员表</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `EMP` (</span><br><span class="line">  `empno` <span class="type">int</span>(<span class="number">6</span>) unsigned zerofill <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;雇员编号&#x27;</span>,</span><br><span class="line">  `ename` <span class="type">varchar</span>(<span class="number">10</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;雇员姓名&#x27;</span>,</span><br><span class="line">  `job` <span class="type">varchar</span>(<span class="number">9</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;雇员职位&#x27;</span>,</span><br><span class="line">  `mgr` <span class="type">int</span>(<span class="number">4</span>) unsigned zerofill <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;雇员领导编号&#x27;</span>,</span><br><span class="line">  `hiredate` datetime <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;雇佣时间&#x27;</span>,</span><br><span class="line">  `sal` <span class="type">decimal</span>(<span class="number">7</span>,<span class="number">2</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;工资月薪&#x27;</span>,</span><br><span class="line">  `comm` <span class="type">decimal</span>(<span class="number">7</span>,<span class="number">2</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;奖金&#x27;</span>,</span><br><span class="line">  `deptno` <span class="type">int</span>(<span class="number">2</span>) unsigned zerofill <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;部门编号&#x27;</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 执行存储过程，添加8000000条记录</span></span><br><span class="line"><span class="keyword">call</span> insert_emp(<span class="number">100001</span>, <span class="number">8000000</span>);</span><br></pre></td></tr></table></figure><p>在这个表里面，有大量的数据，其默认状态下，并没有配置索引</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">MariaDB [bit_index]&gt; desc EMP;</span><br><span class="line">+----------+--------------------------+------+-----+---------+-------+</span><br><span class="line">| Field    | Type                     | Null | Key | Default | Extra |</span><br><span class="line">+----------+--------------------------+------+-----+---------+-------+</span><br><span class="line">| empno    | int(6) unsigned zerofill | NO   |     | NULL    |       |</span><br><span class="line">| ename    | varchar(10)              | YES  |     | NULL    |       |</span><br><span class="line">| job      | varchar(9)               | YES  |     | NULL    |       |</span><br><span class="line">| mgr      | int(4) unsigned zerofill | YES  |     | NULL    |       |</span><br><span class="line">| hiredate | datetime                 | YES  |     | NULL    |       |</span><br><span class="line">| sal      | decimal(7,2)             | YES  |     | NULL    |       |</span><br><span class="line">| comm     | decimal(7,2)             | YES  |     | NULL    |       |</span><br><span class="line">| deptno   | int(2) unsigned zerofill | YES  |     | NULL    |       |</span><br><span class="line">+----------+--------------------------+------+-----+---------+-------+</span><br><span class="line">8 rows in set (0.001 sec)</span><br></pre></td></tr></table></figure><p>此时如果你直接全列查询，进程就会阻塞在这里</p><p><img src="https://img.musnow.top/i/2023/09/bd7ed9436789f27dec4d4ba2ab40ea5b.png" alt="image-20230907172052198"></p><p>进MySQL的文件路径看看，会发现这张表的大小已经到了惊人的564mb，虽然我们的内存也许能存的下这么大的数据，但实际IO读写这么大量的数据是非常耗时的</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@vm-cnt8:/var/lib/mysql/bit_index]# ll -h</span><br><span class="line">total 565M</span><br><span class="line">-rw-rw----. 1 mysql mysql   61 Sep  6 05:36 db.opt</span><br><span class="line">-rw-rw----. 1 mysql mysql  770 Sep  6 05:36 EMP.frm</span><br><span class="line">-rw-rw----. 1 mysql mysql 564M Sep  6 05:39 EMP.ibd</span><br></pre></td></tr></table></figure><p>在之前的查询操作中提到过，对于这种大数据表的时候，我们应该避免使用全列查询，而应该设置<code>limit</code>只查询出少量用例数据，来判断这个表的数据结构和作用</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">MariaDB [bit_index]&gt; select * from EMP limit 3;</span><br><span class="line">+--------+--------+----------+------+---------------------+---------+--------+--------+</span><br><span class="line">| empno  | ename  | job      | mgr  | hiredate            | sal     | comm   | deptno |</span><br><span class="line">+--------+--------+----------+------+---------------------+---------+--------+--------+</span><br><span class="line">| 100002 | FNXAKX | SALESMAN | 0001 | 2023-09-06 00:00:00 | 2000.00 | 400.00 |    327 |</span><br><span class="line">| 100003 | rQbLBy | SALESMAN | 0001 | 2023-09-06 00:00:00 | 2000.00 | 400.00 |    394 |</span><br><span class="line">| 100004 | wRVdDF | SALESMAN | 0001 | 2023-09-06 00:00:00 | 2000.00 | 400.00 |    195 |</span><br><span class="line">+--------+--------+----------+------+---------------------+---------+--------+--------+</span><br><span class="line">3 rows in set (0.001 sec)</span><br></pre></td></tr></table></figure><p>在没有索引的情况下进行一个查询，用时大约在1.6秒左右</p><p><img src="https://img.musnow.top/i/2023/09/cec2caa51179f05f7309b5c968a539df.png" alt="image-20230907172357990"></p><p>这时候我们来对empno列创建一个主键索引</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> EMP <span class="keyword">add</span> <span class="keyword">primary</span> key(empno);</span><br></pre></td></tr></table></figure><p>因为表中的数据很多，所以设置主键索引也需要耗费一定时间，这个时间内，其实就是MySQL在后台帮我们创建索引所需要的数据结构的过程</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">MariaDB [bit_index]&gt; alter table EMP add primary key(empno);</span><br><span class="line">Query OK, 0 rows affected (17.184 sec)              </span><br><span class="line">Records: 0  Duplicates: 0  Warnings: 0</span><br></pre></td></tr></table></figure><p>再来查询一下刚刚查询的数据，可以看到，用时只有<code>0.000 sec</code>，直接秒回！</p><p><img src="https://img.musnow.top/i/2023/09/0a7e44f14cf052534721da8beca3a073.png" alt="image-20230907172541115"></p><p>这便是索引在提升性能方面的重大作用！</p><h2 id="1-3-MySQL和文件系统"><a href="#1-3-MySQL和文件系统" class="headerlink" title="1.3 MySQL和文件系统"></a>1.3 MySQL和文件系统</h2><h3 id="1-3-1-Linux文件系统"><a href="#1-3-1-Linux文件系统" class="headerlink" title="1.3.1 Linux文件系统"></a>1.3.1 Linux文件系统</h3><p>在之前对<a href="https://blog.musnow.top/posts/2864480005/">Linux文件系统</a>的学习中，我们知道在磁盘中，一个区块是512KB，在Linux系统中，为了提高效率，会采用4KB的分块对数据进行读取。哪怕你只是修改1KB，也是需要将4KB完整读取，再写入回去的。</p><p><img src="https://img.musnow.top/i/2023/09/cda9058519a11abeed3a167eb6690d0c.png" alt="image-20230907174710578"></p><p>因为机械硬盘物理结构的限制，<strong>随机读取的性能不佳</strong>，一次性读取100KB数据，远远优于100次读取1KB。因为一次性读取的时候，只需要一次寻道就能将磁头摆到正确的位置，往里面写数据就完事了。但多次读取小数据的时候，尽管相邻的两次IO操作在同一时刻发出，但如果它们的请求的扇区地址相差很大的话也只能称为随机访问，而非连续访问。</p><p>随机访问就要多次寻道，每次写入的量又很少，大大增加了IO的负担。</p><h3 id="1-3-2-MySQL和磁盘交互基本单位-16KB"><a href="#1-3-2-MySQL和磁盘交互基本单位-16KB" class="headerlink" title="1.3.2 MySQL和磁盘交互基本单位 16KB"></a>1.3.2 MySQL和磁盘交互基本单位 16KB</h3><p>而MySQL中，为了更好的实现对数据IO量的缩减和控制，其内部将16KB作为一次IO的基本单位，这个大小我们叫做MySQL的文件Page；</p><ul><li>MySQL中的数据文件，都是以Page为基本单位保存至磁盘里面的；</li><li>MySQL中的CURD操作，都需要通过计算来定位到需要修改和访问的数据的位置；</li><li>涉及到计算的操作都需要CPU参与，CPU只能处理内存中的数据，这就要求MySQL需要提前将一部分数据加载到内存中；</li><li>所以在MySQL运行的这段时间内，其操作的数据会同时存在于内存和磁盘中，需要以特定的策略将内存中的数据刷新到磁盘中；这个操作就是IO，基本单位是Page；</li><li>为了更好的管理这些操作，MySQL会自己维护一个<code>buffer pool</code>的内存空间，来进行缓存。</li><li>MySQL是一个应用程序，它的所有文件IO操作都需要通过操作系统提供的接口来实现！但内部的刷盘逻辑是可以由MySQL来调用系统接口来自主控制的，而不需要呆板地遵守操作系统的自动策略；（MySQL创建<code>buffer pool</code>也是基于更高的自主性来考虑的）</li><li>最终目标是尽可能地减少IO操作，提高运行效率；</li></ul><p>运行如下命令可以看到MySQL中关于Page设置的全局变量，即16KB</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">MariaDB [bit_index]&gt; SHOW GLOBAL STATUS LIKE &#x27;innodb_page_size&#x27;;</span><br><span class="line">+------------------+-------+</span><br><span class="line">| Variable_name    | Value |</span><br><span class="line">+------------------+-------+</span><br><span class="line">| Innodb_page_size | 16384 |</span><br><span class="line">+------------------+-------+</span><br><span class="line">1 row in set (0.001 sec)</span><br></pre></td></tr></table></figure><h3 id="1-3-3-为什么要用Page为单位进行交互？"><a href="#1-3-3-为什么要用Page为单位进行交互？" class="headerlink" title="1.3.3 为什么要用Page为单位进行交互？"></a>1.3.3 为什么要用Page为单位进行交互？</h3><p>为何MySQL和磁盘进行IO交互的时候，要采用Page的方案进行交互呢？用多少，加载多少不香吗？</p><p>先来个测试用例看看吧，这是一个非常简单的用户表</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 主键默认生成主键索引</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> if <span class="keyword">not</span> <span class="keyword">exists</span> <span class="keyword">user</span> (</span><br><span class="line">    id <span class="type">int</span> <span class="keyword">primary</span> key, </span><br><span class="line">    age <span class="type">int</span> <span class="keyword">not</span> <span class="keyword">null</span>,</span><br><span class="line">    name <span class="type">varchar</span>(<span class="number">16</span>) <span class="keyword">not</span> <span class="keyword">null</span></span><br><span class="line">);</span><br><span class="line"><span class="comment">-- 插入多条记录，主键没有按顺序插入</span></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">insert</span> <span class="keyword">into</span> <span class="keyword">user</span> (id, age, name) <span class="keyword">values</span>(<span class="number">3</span>, <span class="number">18</span>, <span class="string">&#x27;杨过&#x27;</span>);</span><br><span class="line">Query OK, <span class="number">1</span> <span class="type">row</span> affected (<span class="number">0.01</span> sec)</span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">insert</span> <span class="keyword">into</span> <span class="keyword">user</span> (id, age, name) <span class="keyword">values</span>(<span class="number">4</span>, <span class="number">16</span>, <span class="string">&#x27;小龙女&#x27;</span>);</span><br><span class="line">Query OK, <span class="number">1</span> <span class="type">row</span> affected (<span class="number">0.00</span> sec)</span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">insert</span> <span class="keyword">into</span> <span class="keyword">user</span> (id, age, name) <span class="keyword">values</span>(<span class="number">2</span>, <span class="number">26</span>, <span class="string">&#x27;黄蓉&#x27;</span>);</span><br><span class="line">Query OK, <span class="number">1</span> <span class="type">row</span> affected (<span class="number">0.01</span> sec)</span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">insert</span> <span class="keyword">into</span> <span class="keyword">user</span> (id, age, name) <span class="keyword">values</span>(<span class="number">5</span>, <span class="number">36</span>, <span class="string">&#x27;郭靖&#x27;</span>);</span><br><span class="line">Query OK, <span class="number">1</span> <span class="type">row</span> affected (<span class="number">0.00</span> sec)</span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">insert</span> <span class="keyword">into</span> <span class="keyword">user</span> (id, age, name) <span class="keyword">values</span>(<span class="number">1</span>, <span class="number">56</span>, <span class="string">&#x27;欧阳锋&#x27;</span>);</span><br><span class="line">Query OK, <span class="number">1</span> <span class="type">row</span> affected (<span class="number">0.00</span> sec)</span><br><span class="line"><span class="comment">-- 最终发现数据是有序的</span></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> <span class="keyword">user</span>; </span><br><span class="line"><span class="operator">+</span><span class="comment">----+-----+-----------+</span></span><br><span class="line"><span class="operator">|</span> id <span class="operator">|</span> age <span class="operator">|</span> name      <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-----+-----------+</span></span><br><span class="line"><span class="operator">|</span> <span class="number">1</span>  <span class="operator">|</span> <span class="number">56</span>  <span class="operator">|</span> 欧阳锋     <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> <span class="number">2</span>  <span class="operator">|</span> <span class="number">26</span>  <span class="operator">|</span> 黄蓉       <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> <span class="number">3</span>  <span class="operator">|</span> <span class="number">18</span>  <span class="operator">|</span> 杨过       <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> <span class="number">4</span>  <span class="operator">|</span> <span class="number">16</span>  <span class="operator">|</span> 小龙女     <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> <span class="number">5</span>  <span class="operator">|</span> <span class="number">36</span>  <span class="operator">|</span> 郭靖       <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-----+-----------+</span></span><br><span class="line"><span class="number">5</span> <span class="keyword">rows</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure><p>在上面的5条记录中，如果MySQL要查找id&#x3D;2的记录，第一次加载id&#x3D;1，第二次加载id&#x3D;2，一次一条记录，<strong>那么就需要2次IO</strong>。如果要找id&#x3D;5，那么就需要5次IO。</p><p>但，如果这5条(或者更多)都被保存在一个Page中(16KB，能保存很多记录)，那么第一次IO查找id&#x3D;2的时候，整个Page会被加载到MySQL的<code>Buffer Pool</code>中，这里完成了一次IO。但是往后如果在查找id&#x3D;1,3,4,5等，完全不需要进行IO了，而是直接在内存中进行了。所以，就在单Page里面，大大减少了IO的次数！</p><p>虽然我们不能保证后续的几次IO一定在这次加载的Page中，但根据<code>局部性原理</code>，其访问相近的几条数据的概率是很大的！所以这样最终是能提升IO效率的！</p><p>往往IO效率低下的最主要矛盾不是IO单次数据量的大小，<strong>而是IO的次数</strong>。</p><h2 id="1-4-B-树和Page"><a href="#1-4-B-树和Page" class="headerlink" title="1.4 B+树和Page"></a>1.4 B+树和Page</h2><p>有了对Page的认识，接下来就需要用一个数据结构来维护这些加载到<code>Buffer Pool</code>当中的Page了。这时候，我们的B+树就登场了。</p><h3 id="1-4-1-单个Page"><a href="#1-4-1-单个Page" class="headerlink" title="1.4.1 单个Page"></a>1.4.1 单个Page</h3><p>单个Page里面存放的肯定是一部分的数据，我们可以加上前后指针，以双链表的形式将所有Page连起来，这样就能实现数据的遍历；在MySQL中，就是这么操作的。</p><p><img src="https://img.musnow.top/i/2023/09/fafa9750da8082ecdf3927663eb49941.png" alt="image-20230907182425023"></p><p>因为存在主键，MySQL还会给单个Page中的数据依照主键进行排序，从上图就能看出阿里，单个Page中数据是依照主键按序排列的；且每一个数据都会链接到下一个数据上；</p><p>这样排序后，数据库在进行数据筛选的时候，就能更好的定位到数据的位置，减少查询耗时。插入时排序也能让后续在进行数据降序&#x2F;升序输出的时候，无需二次对数据进行排序了；</p><h3 id="1-4-2-多个Page"><a href="#1-4-2-多个Page" class="headerlink" title="1.4.2 多个Page"></a>1.4.2 多个Page</h3><p>既然一个Page是如此，那多个Page呢？</p><ul><li>前面提到了，当MySQL需要加载数据的时候，会将和这个数据相邻近的其他数据，以16KB为单位一起加载到一个Page里面，并连接到这个双向链表上；</li><li>这样，我们就可以通过多个Page的遍历来进行数据的定位</li><li>可链表是一个线性结构，MySQL肯定不可能用线性结构来维护数据吧？那样查询的效率也太低了，每次都需要O(N)的遍历，数据一多就慢慢慢！</li></ul><p><img src="https://img.musnow.top/i/2023/09/12d3385dee351703d07d0104f014b80a.png" alt="image-20230907183025895"></p><p>所以，我们肯定要在双向链表的基础上添加其他的结构来进行查找的优化！这时候就可以引入<strong>目录</strong>了</p><h4 id="页目录"><a href="#页目录" class="headerlink" title="页目录"></a>页目录</h4><p>在我们看书的时候，就会有目录来帮助我们快速查找到某一个章节。比如我们想看第九章的内容，那就可以先看目录，找到第九章的页码，再进行阅读。</p><p>对于MySQL中的数据，这个情景也是适用的，我们给数据上一个目录，查询的时候先根据目录定位到具体的page，我们可以知道1-10号数据都在这个page里面，那就直接去里面找就行了；这时候查找的效率就比单纯的从链表开头进行遍历快多了！</p><p>当然，和书籍的目录需要消耗纸张一样，在MySQL中对数据设置目录也是需要消耗空间的，这就是一种用空间换时间的做法，而在生产环境中，时间显然更加宝贵！</p><h4 id="单页目录"><a href="#单页目录" class="headerlink" title="单页目录"></a>单页目录</h4><p>在单个Page里面，我们可以安如下的方式设定一个目录，嗝一定间隔就设置一个新的节点作为目录。在数据量小的时候，这个目录的作用不算大，但数据量一大，目录对搜索效率的提升是非常可观的！</p><blockquote><p>比如，我们要查找id&#x3D;4记录，之前必须线性遍历4次，才能拿到结果。现在直接通过目录2[3]，直接进行定位新的起始位置，只需要遍历3次就能找到结果，提高了效率。</p></blockquote><p>即便在单个Page中添加目录会导致这个Page实际存放的数据变少，但这是必要的牺牲！</p><p><img src="https://img.musnow.top/i/2023/09/052c18b6ad7065a68f008d8234f08dfc.png" alt="image-20230907191523912"></p><h4 id="多页目录"><a href="#多页目录" class="headerlink" title="多页目录"></a>多页目录</h4><p>前面提到，MySQL会自动把新的数据加载到一个Page中，并链接到已有链表上；但是线性遍历需要大量的IO，每次遇到新的Page的时候，就需要将其加载到内存里面，进行遍历，这就使得单个Page中的目录不那么实用了；</p><ul><li>单个Page的目录是小节目录</li><li>多个Page的目录是章节目录</li></ul><p>所以我们必须给多个Page也加上一个顶层的章节目录，进一步优化效率！</p><ul><li>使用一个Page来指向多个Page，存放每个Page的起始key值（假设每个Page中的key都有序且为升序）；这个Page中不存放实际的数据，只有目录值；</li><li>遍历的时候，先通过多Page的目录找到我们要去的Page，再去访问该实际存储数据的Page中的单Page目录，最终查找到目标数据；</li><li>所以，每个多Page的目录项中就是一个键值+对应普通Page的指针</li></ul><p><img src="https://img.musnow.top/i/2023/09/f14ce259e947e2cc699ae2341e3e83cd.png" alt="image-20230907192840730"></p><p>一层目录Page不够，我们还可以再加一层。这样就实现了一个类似于二叉树的结构，只不过每一个节点Page中都包含多个Page的key+指针，最终只有叶子节点是实际存储数据的！</p><p><img src="https://img.musnow.top/i/2023/09/485204263a90e86428707dd92244878b.png" alt="image-20230907193042036"></p><p>这个数据结构就叫做B+树（注意，不是B树！）而整个上图中的数据接就是MySQL中对user表做的索引！</p><p>此时的查询，需要经过的节点肯定变少了，比如我们需要查询<code>id=12</code>的用户：</p><ul><li>顶层判断，12&gt;11&gt;1，向右走【2次比较】</li><li>第二层判断，12&gt;11且12&lt;16，向左走，来到具体的Page【2次比较】</li><li>查找单页目录，12&gt;11且12&lt;13；【2次比较】</li><li>从11开始遍历，走一步就能找到【1次比较】</li></ul><p>最终，我们查找12的操作只用了7次就成功了。而从投开始遍历需要12次才能找到它；</p><p>遍历次数的减少，就等同于IO次数的减少，最终查询的效率就变高了！</p><blockquote><p>这里的分析可能有误，不过结论是没有问题的，分页肯定能增加查找的效率！</p></blockquote><p>另外，MySQL还可以根据访问的频率，定期的释放一些Page；比如在B+树中，可能树的右半部分很少被访问，那就可以暂时释放这部分Page的空间，给其他表使用，真到遇到访问的时候，再去读盘去除这部分数据。<strong>这是由MySQL的缓存策略来自主决定的</strong>；</p><p>毕竟当一个表非常大的时候，将其全部加载到内存里面是不可行的！必须要用缓存策略和局部性原理来加载频繁使用的数据到内存中，才能在效率和负载上达到平衡；</p><p>不然你的MySQL无脑缓存Page导致占用过多内存，操作系统看不下去直接给你KILL了，那业务就完蛋了！🤣</p><h3 id="1-4-3-小结"><a href="#1-4-3-小结" class="headerlink" title="1.4.3 小结"></a>1.4.3 小结</h3><ul><li>Page分为目录页和数据页。目录页只放各个下级Page的最小键值和该Page的指针。</li><li>查找的时候，自顶向下找，只需要加载部分目录页到内存，即可完成算法的整个查找过程，大大减少了IO次数</li><li>范围查询的时候，可以找到区间边界的两个节点的位置，然后直接通过叶子节点的链表进行遍历，取出数据即可！</li><li>MySQL可以根据访问频率，适当地预先加载或者释放一些Page的空间，并不是说一张表的所有数据都必须全部加载到内存里面；</li></ul><p>后续我还会学习B树和B+树数据结构在CPP中的实现，敬请关注我的博客！</p><h2 id="1-5-为什么其他数据结构不适合索引？"><a href="#1-5-为什么其他数据结构不适合索引？" class="headerlink" title="1.5 为什么其他数据结构不适合索引？"></a>1.5 为什么其他数据结构不适合索引？</h2><p>在认识这个问题之前，我们首先要记住上文提到的一个结论：真正影响索引性能的，是和硬盘IO的次数，IO次数越少，性能越高；</p><ul><li>链表、线性表：都是线性遍历，压根没有索引的功能</li><li>二叉搜索树：在极端场景下会退化成普通二叉树，还是线性遍历</li><li><code>AVLTree/RBTree</code>：虽然相对平衡，但二叉结构会导致树的整体过高，自顶向下查询的时候，需要经过多层的多次IO，才能找到目标数据（B+树的层数更少，在这种情况下B+树更优秀）</li><li>HASH：虽然查找的时候很快，基本能做到O(1)，但范围查询的效果不佳；在MySQL中也是支持HASH索引的，比如<code>MEMOY/HEAP/NDB</code>存储引擎；</li></ul><p><img src="https://img.musnow.top/i/2023/09/ab7bb4e2660ff869b45d61974beb6ed7.png" alt="image-20230907193621724"></p><p>那B树为什么不适合呢？作为一个多叉树结构，B树的同层能比红黑树存储更多信息，看上去也是可以做索引的呀？</p><p>牵扯到B树和B+树的区别了，来看看二者的结构图</p><p><img src="https://img.musnow.top/i/2023/09/d485930385b11585cdb3c15e87e2b2df.png" alt="image-20230907145442565"></p><p>文字说明如下：</p><ul><li>B树的每一个节点都会存放一定的数据和page指针；</li><li>B+树只有叶子节点会存放数据，非叶子节点只有page的目录；</li><li>B+树的叶子节点全部相连；</li></ul><p>这就引出了B+树的两个优点：</p><ul><li>因为B+树的非叶子节点只需要存储page目录，所以在一个非叶子节点中就能存放较多的目录索引，使得树整体更矮；</li><li>B+树的叶子节点全部相连，方便进行范围遍历，比如<code>where sal&gt;100 and sal &lt; 300</code>的这种范围条件，就可以直接通过叶子节点的链表向后遍历来解决；</li></ul><p>最终的效率问题依旧落到了如何让树更矮来<strong>减少IO次数</strong>，因为在整体上B+树都能做到较矮，查询效率优秀，方便范围查询；所以MySQL主要选用了B+树作为索引结构。</p><h2 id="1-6-聚簇-x2F-非聚簇索引"><a href="#1-6-聚簇-x2F-非聚簇索引" class="headerlink" title="1.6 聚簇&#x2F;非聚簇索引"></a>1.6 聚簇&#x2F;非聚簇索引</h2><h3 id="1-6-1-说明"><a href="#1-6-1-说明" class="headerlink" title="1.6.1 说明"></a>1.6.1 说明</h3><p>InnoDB的数据是和B+树一起存放的，叶子节点里面有数据；这种数据和索引在一起的形式，叫做<strong>聚簇索引</strong>。</p><p><img src="https://img.musnow.top/i/2023/09/c569f1a484e8f61b916751b6d6305a2b.png" alt="image-20230907145652553"></p><p>MyISAM的叶子中没有数据，而是存放的指向数据表对应位置的指针，有额外的一张表来存放所有数据；这种数据和索引分离的形式，叫做<strong>非聚簇索引</strong>；</p><p><img src="https://img.musnow.top/i/2023/09/6be83a012b547b33adf2f8e9cab5252d.png" alt="image-20230907145704130"></p><p>对于MyISAM存储引擎来说，<strong>其很适合进行查询</strong>，特别是大文本查找和全文索引（后文会提到）；</p><h3 id="1-6-2-实机演示"><a href="#1-6-2-实机演示" class="headerlink" title="1.6.2 实机演示"></a>1.6.2 实机演示</h3><blockquote><p>在MySQL中，我们可以通过实际文件的数量看出InnoDB和MyISAM存储引擎的区别；其也反映了聚簇&#x2F;非聚簇索引的性质。</p></blockquote><p>这里我们新建一个数据库，创建user1表，默认采用的是InnoDB作为存储引擎</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">MariaDB [hello_mysql]&gt; create table user1( id int unsigned primary key, name varchar(200) NOT NULL );</span><br><span class="line">Query OK, 0 rows affected (0.008 sec)</span><br></pre></td></tr></table></figure><p>在MySQL的文件存储路径中，可以查看到user1表对应了两个文件，其中<code>.ibd</code>后缀指的就是InnoDB，其内部同时包含了该表中的数据和索引值；</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@vm-cnt8:/var/lib/mysql/hello_mysql]# ll</span><br><span class="line">total 104</span><br><span class="line">-rw-rw----. 1 mysql mysql    61 Sep  7 02:59 db.opt</span><br><span class="line">-rw-rw----. 1 mysql mysql  1545 Sep  7 03:00 user1.frm</span><br><span class="line">-rw-rw----. 1 mysql mysql 98304 Sep  7 03:00 user1.ibd</span><br></pre></td></tr></table></figure><p>再来创建一个属性完全相同的user2表，但采用MyISAM存储引擎</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">MariaDB [hello_mysql]&gt; create table user2( id int unsigned primary key, name varchar(200) NOT NULL ) engine=MyISAM;</span><br><span class="line">Query OK, 0 rows affected (0.002 sec)</span><br></pre></td></tr></table></figure><p>此时能看到，MyISAM对应的存储文件有3个，<code>.MYI</code>包含的是索引，<code>.MYD</code>包含的是实际数据；</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[root@vm-cnt8:/var/lib/mysql/hello_mysql]# ll</span><br><span class="line">total 112</span><br><span class="line">-rw-rw----. 1 mysql mysql    61 Sep  7 02:59 db.opt</span><br><span class="line">-rw-rw----. 1 mysql mysql  1545 Sep  7 03:00 user1.frm</span><br><span class="line">-rw-rw----. 1 mysql mysql 98304 Sep  7 03:00 user1.ibd</span><br><span class="line">-rw-rw----. 1 mysql mysql  1545 Sep  7 03:03 user2.frm</span><br><span class="line">-rw-rw----. 1 mysql mysql     0 Sep  7 03:03 user2.MYD</span><br><span class="line">-rw-rw----. 1 mysql mysql  1024 Sep  7 03:03 user2.MYI</span><br></pre></td></tr></table></figure><p>两表都有一个占用空间完全相同的<code>.frm</code>文件，这个文件中存储的就是该表的结构属性信息，因为两个表的结构完全相同，所以这个文件的大小也相同；</p><h2 id="1-7-回表查找"><a href="#1-7-回表查找" class="headerlink" title="1.7 回表查找"></a>1.7 回表查找</h2><p>创建<strong>辅助索引</strong>的时候，MyISAM依旧创建一个B+树，叶子节点也是指向对应位置的指针；所以在MyISAM中，主键&#x2F;非主键索引区别不大，无非是是否允许冗余数据的问题。</p><p><img src="https://img.musnow.top/i/2023/09/2540a3c70fb29ad3e861374ef8a0cbe1.png" alt="image-20230907145845574"></p><p>InnoDB的辅助索引中，不再直接存放节点数据，而是存放<strong>主键key值</strong>，查询的时候根据key值回到<strong>主键索引表</strong>中进行查询，需要<strong>查询两次</strong>才能获取到结果。</p><blockquote><p>如果辅助索引中还保存数据，就会造成极大的空间浪费，一份数据被保存两次甚至更多次，显然是不合理的。</p></blockquote><p>InnoDB这个先查辅助索引表，再回到主键表中查询的动作，叫做<code>回表查询</code>；</p><p>话虽是这么说，但也并不是每次查询我们都需要回表的。比如下图是一个复合键的索引表，假设数字是用户ID（主键），文字是用户姓名，在这种情况下，我们通过用户姓名查询用户ID的时候，就不需要回到主键表也能获取到结果。</p><p><img src="https://img.musnow.top/i/2023/09/6004dda4aa0dd67277e214f2fa4497db.png" alt="image-20230907144213435"></p><p>另外，在一般的数据库中，B+树并不会很深，所以即便需要进行回表的两次查询，效率也不会受到较大影响；（但肯定会有一定损失）</p><h1 id="2-索引操作"><a href="#2-索引操作" class="headerlink" title="2.索引操作"></a>2.索引操作</h1><h2 id="2-1-创建索引的原则"><a href="#2-1-创建索引的原则" class="headerlink" title="2.1 创建索引的原则"></a>2.1 创建索引的原则</h2><ul><li>比较频繁作为查询条件的字段应该创建索引</li><li>唯一性太差的字段不适合单独创建索引，即使频繁作为查询条件</li><li>更新非常频繁的字段不适合作创建索引（因为每次更新都得重置索引，增加IO压力）</li><li>不会出现在where子句中的字段不该创建索引（不作为查询条件的字段）</li></ul><p>另外，如果在创建表的时候么有指定主键，那么MySQL会自动帮我们创建一个隐藏的自增主键ID（不然就没办法支持其他索引和其本身的快速查找了）</p><h2 id="2-2-创建主键索引"><a href="#2-2-创建主键索引" class="headerlink" title="2.2 创建主键索引"></a>2.2 创建主键索引</h2><p>创建表的时候指定<code>primary key</code>，默认就会创建主键索引</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> user1( id <span class="type">int</span> unsigned <span class="keyword">primary</span> key, name <span class="type">varchar</span>(<span class="number">200</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> );</span><br></pre></td></tr></table></figure><p>创建表的最后，指定某列为主键索引，这个和第一种方式本质上没区别</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> user1( id <span class="type">int</span> unsigned , name <span class="type">varchar</span>(<span class="number">200</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>, <span class="keyword">primary</span> key(id) );</span><br></pre></td></tr></table></figure><p>创建表了之后再添加主键</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 创建表</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> user1( id <span class="type">int</span> unsigned , name <span class="type">varchar</span>(<span class="number">200</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>);</span><br><span class="line"><span class="comment">-- 添加主键</span></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> user1 <span class="keyword">add</span> <span class="keyword">primary</span> key(id);</span><br></pre></td></tr></table></figure><p>主键索引的特点：</p><ul><li>一个表里面本来就只能有一个主键，所以主键索引也只有一个（复合主键也只算一个主键）</li><li>主键索引的效率高（主键列不可重复）</li><li>主键列不能为NULL，所以也不存在无法被索引的值</li><li>一般都会用数字来作为主键，在索引中方便数据比较</li></ul><h2 id="2-3-唯一键索引"><a href="#2-3-唯一键索引" class="headerlink" title="2.3 唯一键索引"></a>2.3 唯一键索引</h2><p>当你给某一列设置为唯一键的时候，MySQL就会自动创建唯一键索引；唯一键索引其实就是普通的辅助索引，只不过其和主键一样都包含唯一的键值约束；</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 直接指定唯一键</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> user2(id <span class="type">int</span> <span class="keyword">primary</span> key, name <span class="type">varchar</span>(<span class="number">200</span>) <span class="keyword">unique</span>);</span><br><span class="line"><span class="comment">-- 创建语句末尾指定唯一键</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> user2(id <span class="type">int</span> <span class="keyword">primary</span> key, name <span class="type">varchar</span>(<span class="number">200</span>),<span class="keyword">unique</span>(name));</span><br><span class="line"><span class="comment">-- 创建后再添加唯一键</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> user2(id <span class="type">int</span> <span class="keyword">primary</span> key, name <span class="type">varchar</span>(<span class="number">200</span>));</span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> user2 <span class="keyword">add</span> <span class="keyword">unique</span>(name);</span><br></pre></td></tr></table></figure><p>唯一索引的特点：</p><ul><li>一个表中，可以有多个唯一索引，包括复合唯一键的索引；</li><li>查询效率高；</li><li>如果在某一列建立唯一索引，必须保证这列不能有重复数据；</li><li>如果一个唯一索引上指定<code>not null</code>，等价于主键索引；</li><li>如果删除唯一键索引，也会同时删除唯一的约束属性；</li></ul><h2 id="2-4-普通键索引"><a href="#2-4-普通键索引" class="headerlink" title="2.4 普通键索引"></a>2.4 普通键索引</h2><p>创建普通索引依旧有3种方式</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 在表的定义最后，指定某列为索引</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> user3(id <span class="type">int</span> <span class="keyword">primary</span> key,</span><br><span class="line">    name <span class="type">varchar</span>(<span class="number">20</span>),</span><br><span class="line">    email <span class="type">varchar</span>(<span class="number">30</span>),</span><br><span class="line">    index(name)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 创建完表以后指定某列为普通索引</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> user3(id <span class="type">int</span> <span class="keyword">primary</span> key, name <span class="type">varchar</span>(<span class="number">20</span>), email</span><br><span class="line"><span class="type">varchar</span>(<span class="number">30</span>));</span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> user3 <span class="keyword">add</span> index(name);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 创建索引的时候指定名字</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> user3(id <span class="type">int</span> <span class="keyword">primary</span> key, name <span class="type">varchar</span>(<span class="number">20</span>), email</span><br><span class="line"><span class="type">varchar</span>(<span class="number">30</span>));</span><br><span class="line"><span class="keyword">create</span> index idx_name <span class="keyword">on</span> user3(name); <span class="comment">-- 创建一个索引名为 idx_name 的索引</span></span><br></pre></td></tr></table></figure><p>普通索引的特点：</p><ul><li>一个表中可以有多个普通索引</li><li>普通索引中的键值可以重复，但不要在大量重复的键值上建立索引（比如性别）</li></ul><h2 id="2-5-复合-x2F-联合索引"><a href="#2-5-复合-x2F-联合索引" class="headerlink" title="2.5 复合&#x2F;联合索引"></a>2.5 复合&#x2F;联合索引</h2><p>给多个键值创建索引，操作如下</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> index 索引名字 <span class="keyword">on</span> 表名(字段<span class="number">1</span>,字段<span class="number">2</span>);</span><br><span class="line"><span class="comment">-- 如果需要索引按不同的规则排序，可以在字段后加DESC和ASC</span></span><br><span class="line"><span class="keyword">create</span> index 索引名字 <span class="keyword">on</span> 表名(字段<span class="number">1</span> <span class="keyword">DESC</span>,字段<span class="number">2</span> <span class="keyword">ASC</span>);</span><br></pre></td></tr></table></figure><p>此时我们创建的索引，在字段1和字段2上会共用一个索引的<code>Key_name</code>，索引名字是相同的。</p><p>复合索引有一个好处，如果使用InnoDB时，<strong>需要查询的结果包含在索引字段中</strong>，那就可以节省一次返还到主键索引中查询的回表步骤，可以在一定程度上提高效率（在上文中已经提及此事）</p><ul><li>上面这种操作叫做<strong>索引覆盖</strong>（覆盖索引），直接从普通索引表中查询到结果；</li><li>建立复合索引相比于建立多个单列索引，还能在一定程度上减少空间消耗，提高效率；</li></ul><p>另外，在进行复合索引的查询的时候，<strong>我们只能使用用户名来查询用户ID</strong>，返过来是不行的（不会使用索引）。因为在MySQL对索引进行匹配的时候，只会匹配最左侧的索引值；</p><p>比如下图中，充当判断条件的是用户名字，通过用户名字查用户ID是OK的，反过来就不行；这种情况下MySQL不会使用索引，依旧是全表遍历；</p><p><img src="https://img.musnow.top/i/2023/09/6004dda4aa0dd67277e214f2fa4497db.png" alt="image-20230907144213435"></p><p>这种叫做MySQL索引的<strong>最左匹配原则</strong></p><blockquote><p>详解：<a href="https://blog.csdn.net/weixin_47162914/article/details/123793589">联合索引-最左匹配原则</a></p></blockquote><p>MySQL在创建复合索引的时候，首先会<strong>对最左边字段排序</strong>，也就是第一个字段，然后再在保证第一个字段有序的情况下，再排序第二个字段，以此类推。所以联合索引最左列是绝对有序的，其他字段无序。</p><p>举个例子：可以把联合索引看成“电话簿”，姓名作为联合索引，姓是第一列，名是第二列，当查找人名时，是先确定这个人姓再根据名确定人。只有名没有姓就查不到。</p><h2 id="2-6-全文索引"><a href="#2-6-全文索引" class="headerlink" title="2.6 全文索引"></a>2.6 全文索引</h2><p>如果对文章或者大量文字的字段进行检索的时候，就会使用到全文索引。MySQL提供全文索引机制，但是要求表的存储引擎必须是<code>MyISAM</code>；而且默认的全文索引只支持英文，不支持中文。如果对中文进行全文检索，可以使用sphinx的中文版(coreseek)。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 创建表，FULLTEXT设置全文索引</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> articles (</span><br><span class="line">    id <span class="type">INT</span> UNSIGNED AUTO_INCREMENT <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">PRIMARY</span> KEY,</span><br><span class="line">    title <span class="type">VARCHAR</span>(<span class="number">200</span>),</span><br><span class="line">    body TEXT,</span><br><span class="line">    FULLTEXT (title,body) </span><br><span class="line">)engine<span class="operator">=</span>MyISAM;</span><br><span class="line"><span class="comment">-- 插入测试数据</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> articles (title,body) <span class="keyword">VALUES</span></span><br><span class="line">    (<span class="string">&#x27;MySQL Tutorial&#x27;</span>,<span class="string">&#x27;DBMS stands for DataBase ...&#x27;</span>),</span><br><span class="line">    (<span class="string">&#x27;How To Use MySQL Well&#x27;</span>,<span class="string">&#x27;After you went through a ...&#x27;</span>),</span><br><span class="line">    (<span class="string">&#x27;Optimizing MySQL&#x27;</span>,<span class="string">&#x27;In this tutorial we will show ...&#x27;</span>),</span><br><span class="line">    (<span class="string">&#x27;1001 MySQL Tricks&#x27;</span>,<span class="string">&#x27;1. Never run mysqld as root. 2. ...&#x27;</span>),</span><br><span class="line">    (<span class="string">&#x27;MySQL vs. YourSQL&#x27;</span>,<span class="string">&#x27;In the following database comparison ...&#x27;</span>),</span><br><span class="line">    (<span class="string">&#x27;MySQL Security&#x27;</span>,<span class="string">&#x27;When configured properly, MySQL ...&#x27;</span>);</span><br></pre></td></tr></table></figure><p>创建好表之后，查询表中索引信息，可以看到title和body字段都用上了索引名字为<code>title</code>的全文索引</p><p><img src="https://img.musnow.top/i/2023/09/f0c396d35a81e6ab863f7bec84174f48.png" alt="image-20230907155913783"></p><p>假设我们查询这个表中有没有包含database的文字数据，虽然成功查询了结果，但是并没有使用到全文索引</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> articles <span class="keyword">where</span> body <span class="keyword">like</span> <span class="string">&#x27;%database%&#x27;</span>;</span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------------+------------------------------------------+</span></span><br><span class="line"><span class="operator">|</span> id <span class="operator">|</span> title             <span class="operator">|</span> body                                     <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------------+------------------------------------------+</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">1</span> <span class="operator">|</span> MySQL Tutorial    <span class="operator">|</span> DBMS stands <span class="keyword">for</span> DataBase ...             <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">5</span> <span class="operator">|</span> MySQL vs. YourSQL <span class="operator">|</span> <span class="keyword">In</span> the following database comparison ... <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------------+------------------------------------------+</span></span><br><span class="line"><span class="number">2</span> <span class="keyword">rows</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.000</span> sec)</span><br></pre></td></tr></table></figure><p>使用explain语句可以看出是否有使用全文索引，这里的key为NULL就代表么有使用上索引；这个工具的作用是<strong>预执行</strong>，并不会实际上运行这个语句，但是会告诉你我想<strong>怎么运行它</strong>；</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">explain select * from articles where body like &#x27;%database%&#x27;\G</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">           id: 1</span><br><span class="line">  select_type: SIMPLE</span><br><span class="line">        table: articles</span><br><span class="line">         type: ALL</span><br><span class="line">possible_keys: NULL</span><br><span class="line">          key: NULL</span><br><span class="line">      key_len: NULL</span><br><span class="line">          ref: NULL</span><br><span class="line">         rows: 6</span><br><span class="line">        Extra: Using where</span><br><span class="line">1 row in set (0.000 sec)</span><br></pre></td></tr></table></figure><p>要想使用全文索引，得这么写</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> articles <span class="keyword">WHERE</span> <span class="keyword">MATCH</span> (title,body) AGAINST (<span class="string">&#x27;database&#x27;</span>);</span><br></pre></td></tr></table></figure><p>再用explain工具看看，此时就可以看到key里面显示的是title，成功使用上了全文索引</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">explain SELECT * FROM articles WHERE MATCH (title,body) AGAINST</span><br><span class="line">    -&gt; (&#x27;database&#x27;)\G</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">           id: 1</span><br><span class="line">  select_type: SIMPLE</span><br><span class="line">        table: articles</span><br><span class="line">         type: fulltext</span><br><span class="line">possible_keys: title</span><br><span class="line">          key: title</span><br><span class="line">      key_len: 0</span><br><span class="line">          ref: </span><br><span class="line">         rows: 1</span><br><span class="line">        Extra: Using where</span><br><span class="line">1 row in set (0.000 sec)</span><br></pre></td></tr></table></figure><h3 id="explain工具"><a href="#explain工具" class="headerlink" title="explain工具"></a>explain工具</h3><p>这里对explain工具显示的列作一个说明。这个工具的作用是<strong>预执行</strong>，并不会实际上运行这个语句，但是会告诉你我想<strong>怎么运行它</strong>；输出结果包含如下列：</p><ul><li>id — 选择标识符，id 越大优先级越高，越先被执行；</li><li>select_type — 表示查询的类型；</li><li>table — 输出结果集的表；</li><li>partitions — 匹配的分区；</li><li>type — 表示表的连接类型；</li><li>possible_keys — 表示查询时，可能使用的索引；</li><li><strong>key — 表示实际使用的索引；</strong></li><li>key_len — 索引字段的长度；</li><li>ref—  列与索引的比较；</li><li>rows — 大概估算的行数；</li><li>filtered — 按表条件过滤的行百分比；</li><li>Extra — 执行情况的描述和说明。</li></ul><h2 id="2-7-查询-x2F-删除索引"><a href="#2-7-查询-x2F-删除索引" class="headerlink" title="2.7 查询&#x2F;删除索引"></a>2.7 查询&#x2F;删除索引</h2><p>如果需要删除主键索引，直接把主键删了就行了</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> 表名 <span class="keyword">drop</span> <span class="keyword">primary</span> key;</span><br></pre></td></tr></table></figure><p>删除普通索引语句如下</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> 表名 <span class="keyword">drop</span> index 索引名字;</span><br></pre></td></tr></table></figure><p>注意，索引的名字不一定和字段名相同（在创建索引的时候可以指定索引名字），需要使用如下语句查看</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> keys <span class="keyword">from</span> 表名;</span><br></pre></td></tr></table></figure><p>比如user2表中包含id主键索引和name的主键索引，其结果查询如下；其中的<code>Key_name</code>才是索引的名字，不一定和字段名相同！删除索引的时候需要使用索引名字！</p><p><img src="https://img.musnow.top/i/2023/09/e01d3842d22be7c1f41568ef3802d1e0.png" alt="image-20230907153259042"></p><p>还可以用如下语句来更加清楚的看到每个索引的相关属性</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> index <span class="keyword">from</span> 表名\G;</span><br></pre></td></tr></table></figure><p>我给user2表添加一个键值，并设置普通索引</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> user2 <span class="keyword">add</span> qq <span class="type">varchar</span>(<span class="number">40</span>); <span class="comment">-- 添加一个键值</span></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> user2 <span class="keyword">add</span> index(qq); <span class="comment">-- 添加普通索引</span></span><br></pre></td></tr></table></figure><p>使用<code>show index from 表名\G;</code>语句查看user2表的索引属性；在这里可以看到，唯一键索引的属性和普通索引是完全相同的，<strong>所以才说唯一键的索引本质上还是普通索引</strong>。</p><p>这里还写明了索引的类型是BTREE，其就是B+树；</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">MariaDB [hello_mysql]&gt; desc user2;</span><br><span class="line">+-------+------------------+------+-----+---------+-------+</span><br><span class="line">| Field | Type             | Null | Key | Default | Extra |</span><br><span class="line">+-------+------------------+------+-----+---------+-------+</span><br><span class="line">| id    | int(10) unsigned | NO   | PRI | NULL    |       |</span><br><span class="line">| name  | varchar(200)     | NO   | UNI | NULL    |       |</span><br><span class="line">| qq    | varchar(40)      | YES  | MUL | NULL    |       |</span><br><span class="line">+-------+------------------+------+-----+---------+-------+</span><br><span class="line">3 rows in set (0.001 sec)</span><br><span class="line"></span><br><span class="line">MariaDB [hello_mysql]&gt; show index from user2\G;</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">        Table: user2</span><br><span class="line">   Non_unique: 0</span><br><span class="line">     Key_name: PRIMARY</span><br><span class="line"> Seq_in_index: 1</span><br><span class="line">  Column_name: id</span><br><span class="line">    Collation: A</span><br><span class="line">  Cardinality: 0</span><br><span class="line">     Sub_part: NULL</span><br><span class="line">       Packed: NULL</span><br><span class="line">         Null: </span><br><span class="line">   Index_type: BTREE</span><br><span class="line">      Comment: </span><br><span class="line">Index_comment: </span><br><span class="line">*************************** 2. row ***************************</span><br><span class="line">        Table: user2</span><br><span class="line">   Non_unique: 0</span><br><span class="line">     Key_name: name</span><br><span class="line"> Seq_in_index: 1</span><br><span class="line">  Column_name: name</span><br><span class="line">    Collation: A</span><br><span class="line">  Cardinality: 0</span><br><span class="line">     Sub_part: NULL</span><br><span class="line">       Packed: NULL</span><br><span class="line">         Null: </span><br><span class="line">   Index_type: BTREE</span><br><span class="line">      Comment: </span><br><span class="line">Index_comment: </span><br><span class="line">*************************** 3. row ***************************</span><br><span class="line">        Table: user2</span><br><span class="line">   Non_unique: 1</span><br><span class="line">     Key_name: qq</span><br><span class="line"> Seq_in_index: 1</span><br><span class="line">  Column_name: qq</span><br><span class="line">    Collation: A</span><br><span class="line">  Cardinality: NULL</span><br><span class="line">     Sub_part: NULL</span><br><span class="line">       Packed: NULL</span><br><span class="line">         Null: YES</span><br><span class="line">   Index_type: BTREE</span><br><span class="line">      Comment: </span><br><span class="line">Index_comment: </span><br><span class="line">3 rows in set (0.000 sec)</span><br><span class="line"></span><br><span class="line">ERROR: No query specified</span><br></pre></td></tr></table></figure><h2 id="2-8-什么时候索引会失效？"><a href="#2-8-什么时候索引会失效？" class="headerlink" title="2.8 什么时候索引会失效？"></a>2.8 什么时候索引会失效？</h2><blockquote><p><a href="https://cloud.tencent.com/developer/article/2035778">https://cloud.tencent.com/developer/article/2035778</a></p><p><a href="https://zhuanlan.zhihu.com/p/361172794">https://zhuanlan.zhihu.com/p/361172794</a></p></blockquote><h3 id="2-8-1-如果条件中有or-x2F-and"><a href="#2-8-1-如果条件中有or-x2F-and" class="headerlink" title="2.8.1 如果条件中有or&#x2F;and"></a>2.8.1 如果条件中有or&#x2F;and</h3><p>如果条件中有or&#x2F;and，即使其中<strong>有部分条件带索引</strong>也不会使用；</p><p>先说结论：如果在使用and和or进行查询的时候，只有两列都包含了索引才会使用；</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 创建示例表，其中id是主键，user_id没有创建索引</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> user3(</span><br><span class="line">id <span class="type">int</span> unsigned <span class="keyword">primary</span> key,</span><br><span class="line">user_id <span class="type">int</span> unsigned <span class="keyword">not</span> <span class="keyword">null</span>,</span><br><span class="line">    name <span class="type">varchar</span>(<span class="number">30</span>) <span class="keyword">not</span> <span class="keyword">null</span></span><br><span class="line">);</span><br><span class="line"><span class="comment">-- 插入示例数据</span></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> user3 <span class="keyword">values</span> </span><br><span class="line">(<span class="number">1</span>,<span class="number">10</span>,<span class="string">&#x27;甲&#x27;</span>),(<span class="number">2</span>,<span class="number">20</span>,<span class="string">&#x27;丙&#x27;</span>),(<span class="number">3</span>,<span class="number">30</span>,<span class="string">&#x27;乙&#x27;</span>),(<span class="number">4</span>,<span class="number">40</span>,<span class="string">&#x27;丁&#x27;</span>),</span><br><span class="line">(<span class="number">5</span>,<span class="number">50</span>,<span class="string">&#x27;尼斯&#x27;</span>),(<span class="number">6</span>,<span class="number">23</span>,<span class="string">&#x27;企鹅&#x27;</span>),(<span class="number">7</span>,<span class="number">14</span>,<span class="string">&#x27;倪浩&#x27;</span>),(<span class="number">9</span>,<span class="number">21</span>,<span class="string">&#x27;test&#x27;</span>);</span><br></pre></td></tr></table></figure><p>这时候如果用如下语句进行查询，那就不会使用索引</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> user3 <span class="keyword">where</span> id<span class="operator">=</span><span class="number">3</span> <span class="keyword">or</span> user_id<span class="operator">=</span><span class="number">40</span>;</span><br></pre></td></tr></table></figure><p>使用<code>explain</code>命令来查看运行过程，可以看到key一列为空，代表没有使用索引</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">MariaDB [hello_mysql]&gt; explain select * from user3 where id=3 or user_id=40\G;</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">           id: 1</span><br><span class="line">  select_type: SIMPLE</span><br><span class="line">        table: user3</span><br><span class="line">         type: ALL</span><br><span class="line">possible_keys: PRIMARY</span><br><span class="line">          key: NULL</span><br><span class="line">      key_len: NULL</span><br><span class="line">          ref: NULL</span><br><span class="line">         rows: 4</span><br><span class="line">        Extra: Using where</span><br><span class="line">1 row in set (0.000 sec)</span><br><span class="line"></span><br><span class="line">ERROR: No query specified</span><br><span class="line"></span><br><span class="line">MariaDB [hello_mysql]&gt; explain select * from user3 where id=2 and user_id=30\G;</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">           id: 1</span><br><span class="line">  select_type: SIMPLE</span><br><span class="line">        table: NULL</span><br><span class="line">         type: NULL</span><br><span class="line">possible_keys: NULL</span><br><span class="line">          key: NULL</span><br><span class="line">      key_len: NULL</span><br><span class="line">          ref: NULL</span><br><span class="line">         rows: NULL</span><br><span class="line">        Extra: Impossible WHERE noticed after reading const tables</span><br><span class="line">1 row in set (0.001 sec)</span><br><span class="line"></span><br><span class="line">ERROR: No query specified</span><br></pre></td></tr></table></figure><p>直接查询id，有使用索引</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">MariaDB [hello_mysql]&gt; explain select * from user3 where id=2\G;</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">           id: 1</span><br><span class="line">  select_type: SIMPLE</span><br><span class="line">        table: user3</span><br><span class="line">         type: const</span><br><span class="line">possible_keys: PRIMARY</span><br><span class="line">          key: PRIMARY</span><br><span class="line">      key_len: 4</span><br><span class="line">          ref: const</span><br><span class="line">         rows: 1</span><br><span class="line">        Extra: </span><br><span class="line">1 row in set (0.000 sec)</span><br><span class="line"></span><br><span class="line">ERROR: No query specified</span><br></pre></td></tr></table></figure><p>此时如果给<code>user_id</code>列加上索引后重新操作，那结果就不一样了</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> user3 <span class="keyword">add</span> <span class="keyword">unique</span>(user_id); <span class="comment">-- 唯一键索引</span></span><br></pre></td></tr></table></figure><p>可以看到，有使用索引（在我的测试中，并不是每次都会使用索引，这大概是因为我的内容列太少了，不如直接遍历？）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">MariaDB [hello_mysql]&gt; explain select * from user3 where id=2 and user_id=20\G;</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">           id: 1</span><br><span class="line">  select_type: SIMPLE</span><br><span class="line">        table: user3</span><br><span class="line">         type: const</span><br><span class="line">possible_keys: PRIMARY,user_id</span><br><span class="line">          key: PRIMARY</span><br><span class="line">      key_len: 4</span><br><span class="line">          ref: const</span><br><span class="line">         rows: 1</span><br><span class="line">        Extra: </span><br><span class="line">1 row in set (0.000 sec)</span><br><span class="line"></span><br><span class="line">ERROR: No query specified</span><br></pre></td></tr></table></figure><h3 id="2-8-2-复合索引没有使用最左列"><a href="#2-8-2-复合索引没有使用最左列" class="headerlink" title="2.8.2 复合索引没有使用最左列"></a>2.8.2 复合索引没有使用最左列</h3><p>使用sn + name + age创建复合索引，我们假设它们的顺序是 A + B + C，以下联合索引的使用情况如下：</p><p><img src="https://img.musnow.top/i/2023/09/d5285b42e3341a5dda532dfdaf6fc7dc.png" alt="image"></p><p>从结果可以看出，只有A+B+C或者A+B&#x2F;A+C才能触发索引，而使用B+C无法触发索引，因为没有使用最左列；</p><h3 id="2-8-3-错误模糊查询"><a href="#2-8-3-错误模糊查询" class="headerlink" title="2.8.3  错误模糊查询"></a>2.8.3  错误模糊查询</h3><p>模糊查询的时候，只有<code>关键字%</code>才能用到索引，使用<code>%关键字</code>或者<code>%关键字%</code>都是无法使用索引的；</p><p>测试表结构如下，其中ename是用户名，我给他添加了一个普通索引</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">MariaDB [bit_index]&gt; desc EMP;</span><br><span class="line">+----------+--------------------------+------+-----+---------+-------+</span><br><span class="line">| Field    | Type                     | Null | Key | Default | Extra |</span><br><span class="line">+----------+--------------------------+------+-----+---------+-------+</span><br><span class="line">| empno    | int(6) unsigned zerofill | NO   | PRI | NULL    |       |</span><br><span class="line">| ename    | varchar(10)              | YES  |     | NULL    |       |</span><br><span class="line">| job      | varchar(9)               | YES  |     | NULL    |       |</span><br><span class="line">| mgr      | int(4) unsigned zerofill | YES  |     | NULL    |       |</span><br><span class="line">| hiredate | datetime                 | YES  |     | NULL    |       |</span><br><span class="line">| sal      | decimal(7,2)             | YES  |     | NULL    |       |</span><br><span class="line">| comm     | decimal(7,2)             | YES  |     | NULL    |       |</span><br><span class="line">| deptno   | int(2) unsigned zerofill | YES  |     | NULL    |       |</span><br><span class="line">+----------+--------------------------+------+-----+---------+-------+</span><br><span class="line">8 rows in set (0.001 sec)</span><br><span class="line"></span><br><span class="line">MariaDB [bit_index]&gt; alter table EMP add index(ename);</span><br><span class="line">Query OK, 0 rows affected (11.911 sec)              </span><br><span class="line">Records: 0  Duplicates: 0  Warnings: 0</span><br></pre></td></tr></table></figure><p>然后进行测试。注意看下方3次查询的like条件区别，以及是否使用了索引；可以看到，只有第一次使用<code>FN%</code>作为查询条件的时候，才使用了索引</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">MariaDB [bit_index]&gt; explain select * from EMP where ename like &#x27;FN%&#x27;\G;</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">           id: 1</span><br><span class="line">  select_type: SIMPLE</span><br><span class="line">        table: EMP</span><br><span class="line">         type: range</span><br><span class="line">possible_keys: ename</span><br><span class="line">          key: ename</span><br><span class="line">      key_len: 33</span><br><span class="line">          ref: NULL</span><br><span class="line">         rows: 22000</span><br><span class="line">        Extra: Using index condition</span><br><span class="line">1 row in set (0.000 sec)</span><br><span class="line"></span><br><span class="line">ERROR: No query specified</span><br><span class="line"></span><br><span class="line">MariaDB [bit_index]&gt; explain select * from EMP where ename like &#x27;%FN%&#x27;\G;</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">           id: 1</span><br><span class="line">  select_type: SIMPLE</span><br><span class="line">        table: EMP</span><br><span class="line">         type: ALL</span><br><span class="line">possible_keys: NULL</span><br><span class="line">          key: NULL</span><br><span class="line">      key_len: NULL</span><br><span class="line">          ref: NULL</span><br><span class="line">         rows: 7968250</span><br><span class="line">        Extra: Using where</span><br><span class="line">1 row in set (0.000 sec)</span><br><span class="line"></span><br><span class="line">ERROR: No query specified</span><br><span class="line"></span><br><span class="line">MariaDB [bit_index]&gt; explain select * from EMP where ename like &#x27;%FN&#x27;\G;</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">           id: 1</span><br><span class="line">  select_type: SIMPLE</span><br><span class="line">        table: EMP</span><br><span class="line">         type: ALL</span><br><span class="line">possible_keys: NULL</span><br><span class="line">          key: NULL</span><br><span class="line">      key_len: NULL</span><br><span class="line">          ref: NULL</span><br><span class="line">         rows: 7968250</span><br><span class="line">        Extra: Using where</span><br><span class="line">1 row in set (0.000 sec)</span><br><span class="line"></span><br><span class="line">ERROR: No query specified</span><br></pre></td></tr></table></figure><h3 id="2-8-4-列运算"><a href="#2-8-4-列运算" class="headerlink" title="2.8.4 列运算"></a>2.8.4 列运算</h3><p>如果包含索引的列进行了运算，也不会使用索引；</p><p>比如下方，直接进行<code>id=5</code>查询的时候，可以使用索引，但用<code>id+2=5</code>进行查询的时候无法使用索引；</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">MariaDB [hello_mysql]&gt; explain select * from user3 where id=5\G;</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">           id: 1</span><br><span class="line">  select_type: SIMPLE</span><br><span class="line">        table: user3</span><br><span class="line">         type: const</span><br><span class="line">possible_keys: PRIMARY</span><br><span class="line">          key: PRIMARY</span><br><span class="line">      key_len: 4</span><br><span class="line">          ref: const</span><br><span class="line">         rows: 1</span><br><span class="line">        Extra: </span><br><span class="line">1 row in set (0.000 sec)</span><br><span class="line"></span><br><span class="line">ERROR: No query specified</span><br><span class="line"></span><br><span class="line">MariaDB [hello_mysql]&gt; explain select * from user3 where id+2=5\G;</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">           id: 1</span><br><span class="line">  select_type: SIMPLE</span><br><span class="line">        table: user3</span><br><span class="line">         type: ALL</span><br><span class="line">possible_keys: NULL</span><br><span class="line">          key: NULL</span><br><span class="line">      key_len: NULL</span><br><span class="line">          ref: NULL</span><br><span class="line">         rows: 8</span><br><span class="line">        Extra: Using where</span><br><span class="line">1 row in set (0.000 sec)</span><br><span class="line"></span><br><span class="line">ERROR: No query specified</span><br></pre></td></tr></table></figure><h3 id="2-8-5-使用函数"><a href="#2-8-5-使用函数" class="headerlink" title="2.8.5 使用函数"></a>2.8.5 使用函数</h3><p>查询列如果使用任意 MySQL 提供的函数就会导致索引失效，这一点的情况和上一点进行运算其实是类似的，毕竟函数也是一种内置的运算；</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">MariaDB [hello_mysql]&gt; explain select * from user3 where ifnull(id,0)=5\G;</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">           id: 1</span><br><span class="line">  select_type: SIMPLE</span><br><span class="line">        table: user3</span><br><span class="line">         type: ALL</span><br><span class="line">possible_keys: NULL</span><br><span class="line">          key: NULL</span><br><span class="line">      key_len: NULL</span><br><span class="line">          ref: NULL</span><br><span class="line">         rows: 8</span><br><span class="line">        Extra: Using where</span><br><span class="line">1 row in set (0.001 sec)</span><br><span class="line"></span><br><span class="line">ERROR: No query specified</span><br></pre></td></tr></table></figure><h3 id="2-8-6-类型转换"><a href="#2-8-6-类型转换" class="headerlink" title="2.8.6 类型转换"></a>2.8.6 类型转换</h3><p>当查询的条件和其本身的数据类型不同时，不会触发索引；</p><p>比如 address 为字符串类型，而查询的时候设置了 int 类型的值就会导致索引失效，如下图所示：</p><p><img src="https://img.musnow.top/i/2023/09/fb421f166c9d97c932ad6c579ea55f10.png" alt="image"></p><h3 id="2-8-7-使用is-not-null"><a href="#2-8-7-使用is-not-null" class="headerlink" title="2.8.7 使用is not null"></a>2.8.7 使用is not null</h3><p>当在查询中使用了 is not null 也会导致索引失效，而 is null 则会正常触发索引的，如下图所示：</p><p><img src="https://img.musnow.top/i/2023/09/87c89678b12c5b3a0fbb33686e46c6ec.png" alt="image.png"></p><h1 id="3-索引优化"><a href="#3-索引优化" class="headerlink" title="3.索引优化"></a>3.索引优化</h1><h2 id="3-1-关联查询优化"><a href="#3-1-关联查询优化" class="headerlink" title="3.1 关联查询优化"></a>3.1 关联查询优化</h2><p>保证被驱动表的JOIN字段已经创建了索引，需要 JOIN 的字段，数据类型保持绝对一致。</p><ul><li>LEFT JOIN 时，<strong>选择小表作为驱动表， 大表作为被驱动表</strong> 。减少外层循环的次数。</li><li>INNER JOIN 时，MySQL会自动将小结果集的表选为驱动表 。</li></ul><p><strong>选择相信MySQL优化策略</strong>。能够直接多表关联的尽量直接关联，不用子查询。(减少查询的趟数）</p><blockquote><p>不建议使用子查询，建议将子查询SQL拆开结合程序多次查询，或使用 JOIN 来代替子查询，参考第二点；</p></blockquote><p>另外，衍生表建不了索引。这点也需要注意</p><h2 id="3-2-子查询优化"><a href="#3-2-子查询优化" class="headerlink" title="3.2 子查询优化"></a>3.2 子查询优化</h2><p>MySQL从4.1版本开始支持子查询，使用子查询可以进行SELECT语句的嵌套查询，即一个SELECT查询的结果作为另一个SELECT语句的条件。 </p><p>子查询可以一次性完成很多逻辑上需要多个步骤才能完成的SQL操作，子查询是 MySQL 的一项重要的功能，可以帮助我们通过一个 SQL 语句实现比较复杂的查询。</p><p>但是，<strong>子查询的执行效率不高</strong>。原因： </p><ul><li>执行子查询时，MySQL需要为内层查询语句的查询结果 建立一个临时表 ，然后外层查询语句从临时表中查询记录。查询完毕后，再撤销这些临时表。这样会消耗过多的CPU和IO资源，产生大量的慢查询。 </li><li>子查询的结果集存储的<strong>临时表</strong>，不论是内存临时表还是磁盘临时表都<strong>不会存在索引</strong> ，所以查询性能会受到一定的影响。</li><li>对于返回结果集比较大的子查询，其对查询性能的影响也就越大。 在MySQL中，可以使用连接（JOIN）查询来替代子查询。连接查询不需要建立临时表 ，其速度比子查询要快 ，如果查询中使用索引的话，性能就会更好。</li></ul><p>结论：尽量不要使用 NOT IN 或者 NOT EXISTS，用<code>LEFT JOIN xxx ON xx WHERE xx IS NULL</code>替代；</p><h2 id="3-3-排序优化"><a href="#3-3-排序优化" class="headerlink" title="3.3 排序优化"></a>3.3 排序优化</h2><ul><li>SQL 中，可以在 WHERE 子句和 ORDER BY 子句中使用索引，目的是在 WHERE 子句中 避免全表扫 描 ，在 ORDER BY 子句 避免使用 FileSort 排序 。当然，某些情况下全表扫描，或者 FileSort 排 序不一定比索引慢。但总的来说，我们还是要避免，以提高查询效率。</li><li>尽量使用 Index 完成 ORDER BY 排序。如果 WHERE 和 ORDER BY 后面是相同的列就使用单索引列； 如果不同就使用联合索引。</li><li>无法使用 Index 时，需要对 FileSort 方式进行调优。</li></ul><h2 id="3-4-GROUP-BY优化"><a href="#3-4-GROUP-BY优化" class="headerlink" title="3.4 GROUP BY优化"></a>3.4 GROUP BY优化</h2><p>group by使用索引的原则几乎跟<code>order by</code>一致 ，group by即使没有过滤条件用到索引，也可以直接使用索引。</p><ul><li>group by 先排序再分组，遵照索引建的<strong>最佳左前缀法则</strong>；</li><li>当无法使用索引列事，增大 <code>max_length_for_sort_data</code> 和 <code>sort_buffer_size</code> 参数的设置；</li><li>where效率高于having，能写在where限定的条件就不要写在having中了！</li><li>减少使用order by，和业务沟通能不排序就不排序，或将排序放到程序端去做。Order by、group by、distinct这些语句较为耗费CPU，数据库的CPU资源是极其宝贵的。</li><li>包含了order by、group by、distinct这些查询的语句，where条件过滤出来的结果集请保持在1000行 以内，否则SQL会很慢。</li></ul><h2 id="3-5-索引覆盖"><a href="#3-5-索引覆盖" class="headerlink" title="3.5 索引覆盖"></a>3.5 索引覆盖</h2><p>这一点在上文的回表查找中已经提及了，即使用复合索引，并将你需要查询的目标字段以最左匹配原则设置到复合索引中，减少回表操作。</p><p>当然，这依旧需要遵循索引创建的原则，即如果某列数据重复量过多，则不应该作为索引列（如果真的需要，可以放在复合索引的最后面，这样能减少以之为查询判据的场景）</p>]]></content>
    
    
    <summary type="html">索引的学习</summary>
    
    
    
    <category term="学习sql" scheme="https://blog.musnow.top/categories/%E5%AD%A6%E4%B9%A0sql/"/>
    
    
    <category term="Linux" scheme="https://blog.musnow.top/tags/Linux/"/>
    
    <category term="mysql" scheme="https://blog.musnow.top/tags/mysql/"/>
    
  </entry>
  
  <entry>
    <title>【MySQL】复合查询 | 内外链接（未完成）</title>
    <link href="https://blog.musnow.top/posts/2529084145/"/>
    <id>https://blog.musnow.top/posts/2529084145/</id>
    <published>2023-09-06T23:52:14.000Z</published>
    <updated>2023-09-06T23:52:30.000Z</updated>
    
    <content type="html"><![CDATA[<p>各类复合查询和笛卡尔积、内外链接的操作</p><span id="more"></span><h1 id="1-基础查询"><a href="#1-基础查询" class="headerlink" title="1.基础查询"></a>1.基础查询</h1><p>在之前的MySQL的CURD基本操作博客中，讲述了一部分查询的语法，但是在实际的生产活动中，那种最基础的查询方式不足以满足复杂查询条件时的要求，所以在普通查询的基础上，MySQL还提供了功能更强大的复合查询，本文就让我们一起来学学复合查询的操作吧！</p><blockquote><p>依旧是使用scott提供的这张表，来进行复合查询的操作。</p></blockquote><p>在那之前，先复习一下普通查询的基本操作吧！</p><ul><li>查询工资高于500或者岗位为MANAGER的成员，同时他们的姓名首字母为大写J</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> emp <span class="keyword">where</span> (sal <span class="operator">&gt;</span> <span class="number">500</span> <span class="keyword">or</span> job <span class="operator">=</span> <span class="string">&#x27;MANAGER&#x27;</span>) <span class="keyword">and</span> ename <span class="keyword">like</span> <span class="string">&#x27;J%&#x27;</span>;</span><br></pre></td></tr></table></figure><ul><li>按照部门号升序、雇员的工资降序排序</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> emp <span class="keyword">order</span> <span class="keyword">by</span> deptno, sal <span class="keyword">desc</span>;</span><br></pre></td></tr></table></figure><ul><li>显示工资高于平均工资的员工信息</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> emp <span class="keyword">where</span> sal <span class="operator">&gt;</span> (<span class="keyword">select</span> <span class="built_in">avg</span>(sal) <span class="keyword">from</span> emp);</span><br></pre></td></tr></table></figure><ul><li>显示每个部门的平均工资和最高工资</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> deptno, <span class="built_in">avg</span>(sal), <span class="built_in">max</span>(sal) <span class="keyword">from</span> emp <span class="keyword">group</span> <span class="keyword">by</span> deptno;</span><br></pre></td></tr></table></figure><ul><li>显示每种岗位的雇员数量和平均工资</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> job,<span class="built_in">count</span>(<span class="operator">*</span>),<span class="built_in">avg</span>(sal) <span class="keyword">from</span> emp <span class="keyword">group</span> <span class="keyword">by</span> job;</span><br><span class="line"><span class="comment">-- 默认情况下会保留6位小数，可以用format函数保留到2位</span></span><br><span class="line"><span class="keyword">select</span> job,<span class="built_in">count</span>(<span class="operator">*</span>),format(<span class="built_in">avg</span>(sal),<span class="number">2</span>) <span class="keyword">from</span> emp <span class="keyword">group</span> <span class="keyword">by</span> job;</span><br><span class="line"><span class="comment">-- 格式化后的输出结果如下</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-----------+----------+--------------------+</span></span><br><span class="line"><span class="operator">|</span> job       <span class="operator">|</span> <span class="built_in">count</span>(<span class="operator">*</span>) <span class="operator">|</span> format(<span class="built_in">avg</span>(sal),<span class="number">2</span>) <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-----------+----------+--------------------+</span></span><br><span class="line"><span class="operator">|</span> ANALYST   <span class="operator">|</span>        <span class="number">2</span> <span class="operator">|</span> <span class="number">3</span>,<span class="number">000.00</span>           <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> CLERK     <span class="operator">|</span>        <span class="number">4</span> <span class="operator">|</span> <span class="number">1</span>,<span class="number">037.50</span>           <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> MANAGER   <span class="operator">|</span>        <span class="number">3</span> <span class="operator">|</span> <span class="number">2</span>,<span class="number">758.33</span>           <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> PRESIDENT <span class="operator">|</span>        <span class="number">1</span> <span class="operator">|</span> <span class="number">5</span>,<span class="number">000.00</span>           <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> SALESMAN  <span class="operator">|</span>        <span class="number">4</span> <span class="operator">|</span> <span class="number">1</span>,<span class="number">400.00</span>           <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-----------+----------+--------------------+</span></span><br><span class="line"><span class="number">5</span> <span class="keyword">rows</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.000</span> sec)</span><br></pre></td></tr></table></figure><h1 id="2-多表查询"><a href="#2-多表查询" class="headerlink" title="2.多表查询"></a>2.多表查询</h1><p>基础查询的操作就复习上面几个就差不多了，接下来我们先看复合查询的第一个大点，多表查询。</p><p>所谓多表查询，就是将一个表和另外一个表合并，再在这个合并了之后的表里面进行查询；</p><ul><li>比如：显示雇员名、雇员工资以及所在部门的名字</li></ul><p>因为雇员名是在emp表里面，部门名字是在dept表里面，所以我们就需要进行多表的联合查询才能一次取到结果（一次查询的效率优于两次独立查询）</p><p>其基本语句就是在from后面添加多个表，并使用<code>表名.表中字段名</code>来指定某一个表中的字段；如果这个字段只有一个表中有，那就可以不用指定表名（但依旧建议指定表名避免出错）</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> 表<span class="number">1</span>,表<span class="number">2</span>,...;</span><br></pre></td></tr></table></figure><h2 id="2-1-笛卡尔积"><a href="#2-1-笛卡尔积" class="headerlink" title="2.1 笛卡尔积"></a>2.1 笛卡尔积</h2><p>先来一个全列查询，看看效果</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> emp,dept;</span><br></pre></td></tr></table></figure><p>可以看到，dept表直接拼接在了emp表之后，而且emp表中的每一个值都被根据dept中不同的部门ID重复了4次。这是因为在MySQL中，他并不知道你需要什么数据，所以进行数据拼接的时候，是采用穷举的方式来拼接的！</p><p>这个不加任何过滤条件，穷举拼接得到的结果被称为<code>笛卡尔积</code>！</p><p><img src="https://img.musnow.top/i/2023/09/3ab44ca912fdd37336acec9da9271b4e.png" alt="image-20230908082727650"></p><h2 id="2-2-指定条件"><a href="#2-2-指定条件" class="headerlink" title="2.2 指定条件"></a>2.2 指定条件</h2><p>接下来再回到上面提到的问题：显示雇员名、雇员工资以及所在部门的名字；</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> emp.ename,emp.sal,dept.dname <span class="keyword">from</span> emp,dept;</span><br></pre></td></tr></table></figure><p>虽然我们选中了我们需要的列来显示，但依旧没有解决笛卡尔积中穷举出来的无效数据；</p><p><img src="https://img.musnow.top/i/2023/09/962f9b4daf49a81d8a0c1a5cedcff9ba.png" alt="image-20230908083214029"></p><p>这时候就需要添加上筛选条件，来剔除掉无效的数据。</p><p>和当前员工的部门编号不同的部门数据就是无效的，我们添加上员工部门编号和部门表中的部门编号相同的条件，就可以剔除掉无效的数据。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> emp.ename,emp.sal,dept.dname <span class="keyword">from</span> emp,dept <span class="keyword">where</span> emp.deptno <span class="operator">=</span> dept.deptno;</span><br></pre></td></tr></table></figure><p>这时候筛选出来的数据，才是正确的每个员工和其对应的部门名字的数据；每个员工也不在会重复4次了。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">MariaDB [scott]&gt; select emp.ename,emp.sal,dept.dname from emp,dept where emp.deptno = dept.deptno;</span><br><span class="line">+--------+---------+------------+</span><br><span class="line">| ename  | sal     | dname      |</span><br><span class="line">+--------+---------+------------+</span><br><span class="line">| SMITH  |  800.00 | RESEARCH   |</span><br><span class="line">| ALLEN  | 1600.00 | SALES      |</span><br><span class="line">| WARD   | 1250.00 | SALES      |</span><br><span class="line">| JONES  | 2975.00 | RESEARCH   |</span><br><span class="line">| MARTIN | 1250.00 | SALES      |</span><br><span class="line">| BLAKE  | 2850.00 | SALES      |</span><br><span class="line">| CLARK  | 2450.00 | ACCOUNTING |</span><br><span class="line">| SCOTT  | 3000.00 | RESEARCH   |</span><br><span class="line">| KING   | 5000.00 | ACCOUNTING |</span><br><span class="line">| TURNER | 1500.00 | SALES      |</span><br><span class="line">| ADAMS  | 1100.00 | RESEARCH   |</span><br><span class="line">| JAMES  |  950.00 | SALES      |</span><br><span class="line">| FORD   | 3000.00 | RESEARCH   |</span><br><span class="line">| MILLER | 1300.00 | ACCOUNTING |</span><br><span class="line">+--------+---------+------------+</span><br><span class="line">14 rows in set (0.004 sec)</span><br></pre></td></tr></table></figure><p>再来做两个小练习</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 显示部门号为10的部门名字，员工名字和员工工资；</span></span><br><span class="line">MariaDB [scott]<span class="operator">&gt;</span> <span class="keyword">select</span> emp.ename,emp.sal,dept.dname <span class="keyword">from</span> emp,dept <span class="keyword">where</span> emp.deptno <span class="operator">=</span> dept.deptno <span class="keyword">and</span> dept.deptno <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line"><span class="operator">+</span><span class="comment">--------+---------+------------+</span></span><br><span class="line"><span class="operator">|</span> ename  <span class="operator">|</span> sal     <span class="operator">|</span> dname      <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">--------+---------+------------+</span></span><br><span class="line"><span class="operator">|</span> CLARK  <span class="operator">|</span> <span class="number">2450.00</span> <span class="operator">|</span> ACCOUNTING <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> KING   <span class="operator">|</span> <span class="number">5000.00</span> <span class="operator">|</span> ACCOUNTING <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> MILLER <span class="operator">|</span> <span class="number">1300.00</span> <span class="operator">|</span> ACCOUNTING <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">--------+---------+------------+</span></span><br><span class="line"><span class="number">3</span> <span class="keyword">rows</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.001</span> sec)</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 显示各个部门员工的姓名，工资，工资级别</span></span><br><span class="line">MariaDB [scott]<span class="operator">&gt;</span> <span class="keyword">select</span> emp.ename,emp.sal,salgrade.grade <span class="keyword">from</span> emp,salgrade <span class="keyword">where</span> emp.sal <span class="keyword">between</span> losal <span class="keyword">and</span> hisal;</span><br><span class="line"><span class="operator">+</span><span class="comment">--------+---------+-------+</span></span><br><span class="line"><span class="operator">|</span> ename  <span class="operator">|</span> sal     <span class="operator">|</span> grade <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">--------+---------+-------+</span></span><br><span class="line"><span class="operator">|</span> SMITH  <span class="operator">|</span>  <span class="number">800.00</span> <span class="operator">|</span>     <span class="number">1</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> ALLEN  <span class="operator">|</span> <span class="number">1600.00</span> <span class="operator">|</span>     <span class="number">3</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> WARD   <span class="operator">|</span> <span class="number">1250.00</span> <span class="operator">|</span>     <span class="number">2</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> JONES  <span class="operator">|</span> <span class="number">2975.00</span> <span class="operator">|</span>     <span class="number">4</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> MARTIN <span class="operator">|</span> <span class="number">1250.00</span> <span class="operator">|</span>     <span class="number">2</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> BLAKE  <span class="operator">|</span> <span class="number">2850.00</span> <span class="operator">|</span>     <span class="number">4</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> CLARK  <span class="operator">|</span> <span class="number">2450.00</span> <span class="operator">|</span>     <span class="number">4</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> SCOTT  <span class="operator">|</span> <span class="number">3000.00</span> <span class="operator">|</span>     <span class="number">4</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> KING   <span class="operator">|</span> <span class="number">5000.00</span> <span class="operator">|</span>     <span class="number">5</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> TURNER <span class="operator">|</span> <span class="number">1500.00</span> <span class="operator">|</span>     <span class="number">3</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> ADAMS  <span class="operator">|</span> <span class="number">1100.00</span> <span class="operator">|</span>     <span class="number">1</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> JAMES  <span class="operator">|</span>  <span class="number">950.00</span> <span class="operator">|</span>     <span class="number">1</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> FORD   <span class="operator">|</span> <span class="number">3000.00</span> <span class="operator">|</span>     <span class="number">4</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> MILLER <span class="operator">|</span> <span class="number">1300.00</span> <span class="operator">|</span>     <span class="number">2</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">--------+---------+-------+</span></span><br><span class="line"><span class="number">14</span> <span class="keyword">rows</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.001</span> sec)</span><br></pre></td></tr></table></figure><h1 id="3-自链接"><a href="#3-自链接" class="headerlink" title="3.自链接"></a>3.自链接</h1><p>所谓自连接，是在同一张表中进行链接和查询</p><p>比如显示员工FORD上级领导的员工编号和姓名</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 使用子查询</span></span><br><span class="line"><span class="keyword">select</span> empno,ename <span class="keyword">from</span> emp <span class="keyword">where</span> emp.empno<span class="operator">=</span>(<span class="keyword">select</span> mgr <span class="keyword">from</span> emp <span class="keyword">where</span></span><br><span class="line">ename<span class="operator">=</span><span class="string">&#x27;FORD&#x27;</span>);</span><br><span class="line"><span class="comment">-- 使用多表查询（其实是给emp表起两个不同的别名）</span></span><br><span class="line"><span class="keyword">select</span> leader.empno,leader.ename <span class="keyword">from</span> emp leader, emp worker <span class="keyword">where</span></span><br><span class="line">leader.empno <span class="operator">=</span> worker.mgr <span class="keyword">and</span> worker.ename<span class="operator">=</span><span class="string">&#x27;FORD&#x27;</span>;</span><br></pre></td></tr></table></figure><p>这种在一张表里面进行笛卡儿积的查询操作，就叫做自链接。最终都可以获取到正确结果</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">+--------+-------+</span><br><span class="line">| empno  | ename |</span><br><span class="line">+--------+-------+</span><br><span class="line">| 007566 | JONES |</span><br><span class="line">+--------+-------+</span><br><span class="line">1 row in set (0.001 sec)</span><br></pre></td></tr></table></figure><h1 id="4-子查询"><a href="#4-子查询" class="headerlink" title="4.子查询"></a>4.子查询</h1><p>子查询值得是，将一个查询语句作为子操作，嵌入到一个sql语句中；</p><p>我们可以把子查询的结果也当作是一张表来进行处理，这样一想就能理解子查询是怎么玩的了。</p><h2 id="4-1-单行子查询"><a href="#4-1-单行子查询" class="headerlink" title="4.1 单行子查询"></a>4.1 单行子查询</h2><p>显示和SMITH同一个部门的员工</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> emp <span class="keyword">where</span> deptno <span class="operator">=</span> (<span class="keyword">select</span> deptno <span class="keyword">from</span> emp <span class="keyword">where</span> ename<span class="operator">=</span><span class="string">&#x27;smith&#x27;</span>);</span><br></pre></td></tr></table></figure><p>在这个查询中，子查询语句是<code>(select deptno from emp where ename=&#39;smith&#39;)</code>，这个语句返回的结果只有一行，所以被称为单行子查询；</p><h2 id="4-2-多行子查询"><a href="#4-2-多行子查询" class="headerlink" title="4.2 多行子查询"></a>4.2 多行子查询</h2><p>有单行查询，自然也有多行查询。但是如果一个语句返回了多条结果，将其直接作为判据肯定是不行的，这会导致判据不唯一，MySQL不知道你到底想要比较的是那一部分的数据。这时候就需要用下面几个关键字来帮忙了</p><ul><li>in：查询存在于某某结果里面的数据</li><li>all：查询比这个结果中所有值都大&#x2F;小的数据</li><li>any：查询比这个结果中某一个值大&#x2F;小的数据</li></ul><p>以下是几个示例</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 查询和10号部门工作岗位相同的员工名字、岗位、工资、部门号，但是不包含10号部门自己的员工</span></span><br><span class="line"><span class="keyword">select</span> ename,job,sal,deptno <span class="keyword">from</span> emp <span class="keyword">where</span> job <span class="keyword">in</span> (<span class="keyword">select</span> job <span class="keyword">from</span> emp <span class="keyword">where</span> deptno<span class="operator">=</span><span class="number">10</span>) <span class="keyword">and</span> deptno <span class="operator">&lt;&gt;</span> <span class="number">10</span>;</span><br><span class="line"><span class="operator">+</span><span class="comment">-------+---------+---------+--------+</span></span><br><span class="line"><span class="operator">|</span> ename <span class="operator">|</span> job     <span class="operator">|</span> sal     <span class="operator">|</span> deptno <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-------+---------+---------+--------+</span></span><br><span class="line"><span class="operator">|</span> SMITH <span class="operator">|</span> CLERK   <span class="operator">|</span>  <span class="number">800.00</span> <span class="operator">|</span>     <span class="number">20</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> JONES <span class="operator">|</span> MANAGER <span class="operator">|</span> <span class="number">2975.00</span> <span class="operator">|</span>     <span class="number">20</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> BLAKE <span class="operator">|</span> MANAGER <span class="operator">|</span> <span class="number">2850.00</span> <span class="operator">|</span>     <span class="number">30</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> ADAMS <span class="operator">|</span> CLERK   <span class="operator">|</span> <span class="number">1100.00</span> <span class="operator">|</span>     <span class="number">20</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> JAMES <span class="operator">|</span> CLERK   <span class="operator">|</span>  <span class="number">950.00</span> <span class="operator">|</span>     <span class="number">30</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-------+---------+---------+--------+</span></span><br><span class="line"><span class="number">5</span> <span class="keyword">rows</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.001</span> sec)</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 显示部门工资比30号部门所有员工工资都高的员工姓名、工资、部门号</span></span><br><span class="line"><span class="keyword">select</span> ename,sal,deptno <span class="keyword">from</span> emp <span class="keyword">where</span> sal <span class="operator">&gt;</span> <span class="keyword">all</span>(<span class="keyword">select</span> sal <span class="keyword">from</span> emp <span class="keyword">where</span> deptno <span class="operator">=</span> <span class="number">30</span>);</span><br><span class="line"><span class="operator">+</span><span class="comment">-------+---------+--------+</span></span><br><span class="line"><span class="operator">|</span> ename <span class="operator">|</span> sal     <span class="operator">|</span> deptno <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-------+---------+--------+</span></span><br><span class="line"><span class="operator">|</span> JONES <span class="operator">|</span> <span class="number">2975.00</span> <span class="operator">|</span>     <span class="number">20</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> SCOTT <span class="operator">|</span> <span class="number">3000.00</span> <span class="operator">|</span>     <span class="number">20</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> KING  <span class="operator">|</span> <span class="number">5000.00</span> <span class="operator">|</span>     <span class="number">10</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> FORD  <span class="operator">|</span> <span class="number">3000.00</span> <span class="operator">|</span>     <span class="number">20</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-------+---------+--------+</span></span><br><span class="line"><span class="number">4</span> <span class="keyword">rows</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.001</span> sec)</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">各类复合查询和笛卡尔积、内外链接的操作</summary>
    
    
    
    <category term="学习sql" scheme="https://blog.musnow.top/categories/%E5%AD%A6%E4%B9%A0sql/"/>
    
    
    <category term="Linux" scheme="https://blog.musnow.top/tags/Linux/"/>
    
    <category term="mysql" scheme="https://blog.musnow.top/tags/mysql/"/>
    
  </entry>
  
  <entry>
    <title>【Linux】root和子用户都能执行的命令，sudo无法执行（已解决）</title>
    <link href="https://blog.musnow.top/posts/2473452644/"/>
    <id>https://blog.musnow.top/posts/2473452644/</id>
    <published>2023-09-01T10:12:55.000Z</published>
    <updated>2023-09-01T10:12:55.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>全流程帖子 <a href="https://ask.oceanbase.com/t/topic/35604437/7">https://ask.oceanbase.com/t/topic/35604437/7</a></p></blockquote><h1 id="1-问题"><a href="#1-问题" class="headerlink" title="1.问题"></a>1.问题</h1><p>如题，在编译miniob的时候遇到如下错误</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[mu@vm-cnt8:~/code/miniob]$ sudo bash build.sh init</span><br><span class="line">build.sh init</span><br><span class="line">HEAD is now at 5df3037d Merge branch <span class="string">&#x27;release-2.1.12-stable-pull&#x27;</span> into patches-2.1</span><br><span class="line">build.sh: line 83: cmake: <span class="built_in">command</span> not found</span><br><span class="line">build.sh: line 91: cmake: <span class="built_in">command</span> not found</span><br><span class="line">build.sh: line 99: cmake: <span class="built_in">command</span> not found</span><br><span class="line">build.sh: line 107: cmake: <span class="built_in">command</span> not found</span><br></pre></td></tr></table></figure><p>根据字面意思，是cmake命令找不到，但是我的系统里面已经有了符合条件的环境；以下是gihub&#x2F;miniob仓库中docs里面<code>how_to_build.md</code>的内容</p><blockquote><p>MiniOB 需要使用：</p><ul><li>cmake 版本 &gt;&#x3D; 3.13</li><li>gcc&#x2F;clang gcc建议8.3以上，编译器需要支持c++20新标准</li><li>flex (2.5+), bison (3.7+) 用于生成词法语法分析代码</li></ul></blockquote><p>我使用的系统是centos8-steam的vmware虚拟机；当前使用的miniob的commit为</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">76221e46e66ef408771ce886aa0c586a09374b0d</span><br></pre></td></tr></table></figure><p>以下是我的系统中各个依赖项的版本号，可以看到在子用户中，依赖项的所有命令都可以正常执行</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">[mu@vm-cnt8:~/code/miniob]$ gcc --version</span><br><span class="line">gcc (GCC) 8.5.0 20210514 (Red Hat 8.5.0-20)</span><br><span class="line">Copyright (C) 2018 Free Software Foundation, Inc.</span><br><span class="line">This is free software; see the <span class="built_in">source</span> <span class="keyword">for</span> copying conditions.  There is NO</span><br><span class="line">warranty; not even <span class="keyword">for</span> MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.</span><br><span class="line"></span><br><span class="line">[mu@vm-cnt8:~/code/miniob]$ cmake --version</span><br><span class="line">cmake version 3.27.4</span><br><span class="line"></span><br><span class="line">CMake suite maintained and supported by Kitware (kitware.com/cmake).</span><br><span class="line">[mu@vm-cnt8:~/code/miniob]$ flex --version</span><br><span class="line">flex 2.6.1</span><br><span class="line">[mu@vm-cnt8:~/code/miniob]$ bison --version</span><br><span class="line">bison (GNU Bison) 3.8</span><br><span class="line">Written by Robert Corbett and Richard Stallman.</span><br><span class="line"></span><br><span class="line">Copyright (C) 2021 Free Software Foundation, Inc.</span><br><span class="line">This is free software; see the <span class="built_in">source</span> <span class="keyword">for</span> copying conditions.  There is NO</span><br><span class="line">warranty; not even <span class="keyword">for</span> MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.</span><br></pre></td></tr></table></figure><p>在root中，也可以正常执行这些命令</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">[root@vm-cnt8:~]# cmake --version</span><br><span class="line">cmake version 3.27.4</span><br><span class="line"></span><br><span class="line">CMake suite maintained and supported by Kitware (kitware.com/cmake).</span><br><span class="line">[root@vm-cnt8:~]# flex --version</span><br><span class="line">flex 2.6.1</span><br><span class="line">[root@vm-cnt8:~]# bison --version</span><br><span class="line">bison (GNU Bison) 3.8</span><br><span class="line">Written by Robert Corbett and Richard Stallman.</span><br><span class="line"></span><br><span class="line">Copyright (C) 2021 Free Software Foundation, Inc.</span><br><span class="line">This is free software; see the source for copying conditions.  There is NO</span><br><span class="line">warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.</span><br></pre></td></tr></table></figure><p>但是sudo执行miniob的安装脚本的时候，却找不到cmake命令</p><h1 id="2-debug过程"><a href="#2-debug过程" class="headerlink" title="2.debug过程"></a>2.debug过程</h1><p>经过大佬的教学，知道了一个新的sudo用法：<code>sudo -E</code></p><blockquote><p><code>sudo -E</code> 是继承当前用户的环境变量运行sudo后面的命令，否则环境变量会被清理掉；</p></blockquote><p>但是在初次使用的时候，依旧无法成功编译miniob，也找不到cmake命令</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">[mu@vm-cnt8:~/code/miniob]$ sudo -E bash build.sh init</span><br><span class="line">[sudo] password for mu: </span><br><span class="line">build.sh init</span><br><span class="line">HEAD is now at 5df3037d Merge branch &#x27;release-2.1.12-stable-pull&#x27; into patches-2.1</span><br><span class="line">build.sh: line 83: cmake: command not found</span><br><span class="line">build.sh: line 91: cmake: command not found</span><br><span class="line">build.sh: line 99: cmake: command not found</span><br><span class="line">build.sh: line 107: cmake: command not found</span><br><span class="line"></span><br><span class="line">[mu@vm-cnt8:~]$ sudo -E cmake --version</span><br><span class="line">[sudo] password for mu: </span><br><span class="line">sudo: cmake: command not found</span><br></pre></td></tr></table></figure><h1 id="3-最终解决：PATH环境变量"><a href="#3-最终解决：PATH环境变量" class="headerlink" title="3.最终解决：PATH环境变量"></a>3.最终解决：PATH环境变量</h1><p>最终的解决办法是我自己想出来的（大佬也回复了我这个解决方案）</p><p>当前在子用户使用 <code>sudo -E</code>是找不到cmake命令的。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[mu@vm-cnt8:~]$ sudo -E cmake --version</span><br><span class="line">[sudo] password for mu: </span><br><span class="line">sudo: cmake: command not found</span><br></pre></td></tr></table></figure><p>我的系统里面的PATH环境变量如下。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[mu@vm-cnt8:~]$ sudo <span class="built_in">env</span> | grep PATH</span><br><span class="line">PATH=/sbin:/bin:/usr/sbin:/usr/bin</span><br></pre></td></tr></table></figure><p>而cmake的路径如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[mu@vm-cnt8:~]$ type cmake</span><br><span class="line">cmake is /usr/local/bin/cmake</span><br><span class="line">[mu@vm-cnt8:~]$ whereis cmake</span><br><span class="line">cmake: /usr/local/bin/cmake /usr/share/cmake</span><br></pre></td></tr></table></figure><p>有没有可能，是因为cmake不在PATH环境变量里面，导致sudo的时候找不到命令呢？虽然在root和mu用户下都可以直接执行cmake。</p><p>于是我就去root里面执行了一下软连接</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@vm-cnt8:~]# ls /usr/bin | grep cmake</span><br><span class="line">[root@vm-cnt8:~]# ln -s /usr/local/bin/cmake /usr/bin/cmake</span><br><span class="line">[root@vm-cnt8:~]# ll /usr/bin | grep cmake</span><br><span class="line">lrwxrwxrwx. 1 root root          20 Sep  1 05:57 cmake -&gt; /usr/local/bin/cmake</span><br></pre></td></tr></table></figure><p>再来试试</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ sudo -E cmake --version</span><br><span class="line">cmake version 3.27.4</span><br><span class="line"></span><br><span class="line">CMake suite maintained and supported by Kitware (kitware.com/cmake).</span><br></pre></td></tr></table></figure><p>最后再来试试编译，应该是OK了，init成功执行，编译也通过了，没有报错</p><p><img src="https://img.musnow.top/i/2023/09/7e206210ba3f9ffa5df6a492ae7b457a.png" alt="image-20230901181050840"></p><p>感谢miniob社区大佬们的帮助！</p><h1 id="4-结论"><a href="#4-结论" class="headerlink" title="4.结论"></a>4.结论</h1><p>如果出现一个命令，root和子用户都可以执行，但是子用户中sudo却找不到此命令，可以尝试检查一下该命令所在路径是否与当前系统的PATH环境变量不符合！</p>]]></content>
    
    
    <summary type="html">root和子用户都能执行的命令，sudo却无法执行，如何解决？</summary>
    
    
    
    <category term="玩上Linux" scheme="https://blog.musnow.top/categories/%E7%8E%A9%E4%B8%8ALinux/"/>
    
    
    <category term="Linux" scheme="https://blog.musnow.top/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>【win】Windows下MSI Afterburner如何让其不在某个软件中显示帧数</title>
    <link href="https://blog.musnow.top/posts/4160666395/"/>
    <id>https://blog.musnow.top/posts/4160666395/</id>
    <published>2023-08-31T13:44:31.000Z</published>
    <updated>2023-08-31T13:44:31.000Z</updated>
    
    <content type="html"><![CDATA[<p>Windows下MSI Afterburner如何让其不在某个软件中显示帧数</p><span id="more"></span><h1 id="1-问题说明"><a href="#1-问题说明" class="headerlink" title="1.问题说明"></a>1.问题说明</h1><p>总所周知，<code>MSI Afterburner</code>这个软件可以在游戏里面展示你当前电脑的各项生命体征，包括GPU&#x2F;CPU功耗频率温度，内存占用，当前帧数等等数据，不管是用来监看电脑运行是否正常，还是用来小超一下显卡，都是很好用的东西，再加上毫无广告+免费，几乎是人手必备的PC良药</p><p><img src="https://img.musnow.top/i/2023/08/22a440a97052d98344faa1679af7e4a1.png" alt="image-20230831211541651"></p><p>但总有时候这个软件会抽风，比如我的电脑里面，最新版本的这个软件，就会把照片莫名其妙的也识别成了一个游戏，在里面显示帧数，最离谱的是，最下方的预览其他图片的小框框里面，也给你显示了帧数</p><p><img src="https://img.musnow.top/i/2023/08/33033ee6b815fd496aefff2db7b41983.png" alt="image-20230831211739693"></p><p>这肯定很恼火，我们要怎么样才能让他不在这里面显示呢？</p><h1 id="2-配置"><a href="#2-配置" class="headerlink" title="2.配置"></a>2.配置</h1><p>和<code>MSI Afterburner</code>捆绑下载的有这么一个软件，其实它才是负责将数据投屏到你的屏幕上的软件，在这里面，我们就可以设置在某个软件中不显示帧数</p><p><img src="https://img.musnow.top/i/2023/08/38ddd77df81cad02c8ac53f0834550f8.png" alt="image-20230831212031500"></p><p>对于正常安装的软件，我们都可以找到软件的安装路径，选中它的exe可执行文件，再设置一下把帧数器关闭，就可以避免错误地显示帧数影响软件自身的使用</p><p><img src="https://img.musnow.top/i/2023/08/952d106d45b52990e2bd63ae4ddc5534.png" alt="image-20230831212050181"></p><p>但是windows自带的相册就有点恼火了，<strong>我们压根不知道它的可执行文件在哪里</strong>！</p><h1 id="3-windows系统应用的可执行文件"><a href="#3-windows系统应用的可执行文件" class="headerlink" title="3.windows系统应用的可执行文件"></a>3.windows系统应用的可执行文件</h1><p>windows绝大部分的系统自带软件都在这里面，你需要打开显示隐藏文件夹才能看到此文件夹</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">C:\Program Files\WindowsApps\</span><br></pre></td></tr></table></figure><p>而<a href="https://zhidao.baidu.com/question/1550787637804576787.html">照片软件路径</a>如下（我的win11版本是<code>22H2 22621.963</code>）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">C:\Program Files\WindowsApps\Microsoft.Windows.Photos_2023.11080.4003.0_x64__8wekyb3d8bbwe</span><br></pre></td></tr></table></figure><p>这里面有一个<code>PhotosApp.exe</code>，就是windows自带照片的可执行文件了；</p><p>但是！你会发现你压根没有 <code>C:\Program Files\WindowsApps\</code>这个文件夹的进入权限，更别提找到这个照片软件的exe了！</p><p>百度了一下，找到了一个教程 <a href="https://www.bkqs.com.cn/content/kn928o443.html">Win10下WindowsApps权限怎么获取</a>；顺带一提，为了避免原文失效，这篇文章也转载到了本站。</p><blockquote><p>注意！毕竟这算是系统底层文件夹了，我不确定这样修改文件夹权限是否会出现问题！如果你担心出现问题，<strong>请不要操作</strong>，在不打游戏的时候不要启动MSI Afterbuner是更好的选择！</p><p>如果出现问题，参考 【<a href="https://blog.csdn.net/oh_futrue/article/details/91042020">WindowsApps 权限问题导致Microsoft Store及其下载的应用不能启动（闪退）的解决办法</a>】 复原权限！实在不行就恐怕要重装系统了 🤣</p><p><img src="https://img.musnow.top/i/2023/08/91c5e537eee80c51f1e2788b15a7d997.png" alt="image-20230831214242664"></p><p>目前我这边还么有出现异常情况，毕竟我修改为了<code>everyone</code>理论上来说是并不会出现权限不够而导致某个程序无法执行的问题的</p></blockquote><p>根据教程里面的步骤一步一步来，就可以获取到这个文件夹的进入权限</p><p><img src="https://img.musnow.top/i/2023/08/f35c62ab02b889383a3f88a3b9700629.png" alt="image-20230831212801573"></p><h1 id="4-禁用照片中的帧数显示"><a href="#4-禁用照片中的帧数显示" class="headerlink" title="4.禁用照片中的帧数显示"></a>4.禁用照片中的帧数显示</h1><p>找到这个<code>PhotosApp.exe</code>之后，在<code>RivaTuner</code>这个软件里面选中这个可执行文件，将其的display关闭</p><p><img src="https://img.musnow.top/i/2023/08/b98f245a377bbfe1369b7cb9809fc9a5.png" alt="image-20230831212557862"></p><p>好了，这下没有胡乱显示帧数了！</p><p><img src="https://img.musnow.top/i/2023/08/d0f3baad38aec23619141b8cf92b6292.png" alt="image-20230831212631268"></p>]]></content>
    
    
    <summary type="html">Windows下MSI Afterburner如何让其不在某个软件中显示帧数</summary>
    
    
    
    <category term="电脑使用小贴士" scheme="https://blog.musnow.top/categories/%E7%94%B5%E8%84%91%E4%BD%BF%E7%94%A8%E5%B0%8F%E8%B4%B4%E5%A3%AB/"/>
    
    
    <category term="windows" scheme="https://blog.musnow.top/tags/windows/"/>
    
  </entry>
  
  <entry>
    <title>【win】Windows下C盘里面的WindowsApps文件夹权限怎么获取</title>
    <link href="https://blog.musnow.top/posts/3712817486/"/>
    <id>https://blog.musnow.top/posts/3712817486/</id>
    <published>2023-08-31T13:34:31.000Z</published>
    <updated>2023-08-31T13:34:31.000Z</updated>
    
    <content type="html"><![CDATA[<p>避免原文失效，转载此文</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">原文 https://www.bkqs.com.cn/content/kn928o443.html</span><br></pre></td></tr></table></figure><h1 id="Win下WindowsApps权限怎么获取"><a href="#Win下WindowsApps权限怎么获取" class="headerlink" title="Win下WindowsApps权限怎么获取"></a>Win下WindowsApps权限怎么获取</h1><p><code>2023-01-31 14:32:17</code></p><p>Win10下WindowsApps权限怎么获取？WindowsApps安装的是Windows应用商店的应用程序，访问此文件夹需要获取权限才能进入。具体怎么设置呢？一起来了解下吧！</p><p><img src="https://img.musnow.top/i/2023/08/df83e62f3e53e132acb209f09a797b6f.png"></p><h2 id="操作方法"><a href="#操作方法" class="headerlink" title="操作方法"></a>操作方法</h2><ul><li><p>01</p><p>1、在计算机中，打开此电脑。点击查看选项，并勾选选项框中的“隐藏的项目”。如图所示；</p><p><img src="https://img.musnow.top/i/2023/08/ac1473123b0f35d32f01b7539023fb51.png"></p></li><li><p>02</p><p>2、在此电脑窗口中，找到系统盘下的“WindowsApps”（隐藏的文件夹），具体路径为“C:\Program Files\WindowsApps”。如图所示；</p><p><img src="https://img.musnow.top/i/2023/08/9a1d5608930d12c04e4303e3b923a747.png"></p></li><li><p>03</p><p>3、选中WindowsApps文件夹，并点击鼠标右键，在弹出的选项框中点击“属性”选项。如图所示；</p><p><img src="https://img.musnow.top/i/2023/08/32e95c80075f35fb9004e63797b1f1d7.png"></p></li><li><p>04</p><p>4、点击属性选项后，这个时候会打开“WindowsApps属性”对话框。如图所示；</p><p><img src="https://img.musnow.top/i/2023/08/5ede94735ea0e66cb1115012e795b0df.png"></p></li><li><p>05</p><p>5、在WindowsApps属性对话框中，切换到“安全”选项卡。如图所示；</p><p><img src="https://img.musnow.top/i/2023/08/b92921c8b6547e8a81e68752e96c830f.png"></p></li><li><p>06</p><p>6、在安全选项卡下，看到提示“必须具有读取权限才能查看对象属性”，并点击“高级”选项按钮。如图所示；</p><p><img src="https://img.musnow.top/i/2023/08/a13b0247ca7b99c1793189336e492c85.png"></p></li><li><p>07</p><p>7、点击高级选项后，这个时候会打开“WindowsApps的高级安全设置”对话窗口。如图所示；</p><p><img src="https://img.musnow.top/i/2023/08/434d13327223687c0ae808b9e5bd0226.png"></p></li><li><p>08</p><p>8、在WindowsApps的高级安全设置对话窗口中，点击所有者后的“更改”按钮。如图所示；</p><p><img src="https://img.musnow.top/i/2023/08/c7060a1aacb894d0ea904202291e9267.png"></p></li><li><p>09</p><p>9、点击更改后，这个时候会打开“选择用户或组”对话框。如图所示；</p><p><img src="https://img.musnow.top/i/2023/08/9b02a003b59c4ce73a72690fc414c038.png"></p></li><li><p>10</p><p>10、在输入要选择的对象名称输入框中，输入“Everyone”，并点击“确定”按钮。如图所示；</p><p><img src="https://img.musnow.top/i/2023/08/fa792f7c20c081c4079f02f6734e2e8d.png"></p></li><li><p>11</p><p>11、点击确定后，这个时候会跳转到WindowsApps的高级安全设置对话窗口。如图所示；</p><p><img src="https://img.musnow.top/i/2023/08/f132cedbea9f1c6677375c0661e68994.png"></p></li><li><p>12</p><p>12、接着勾选所有者下的“替换子容器和对象的所有者”，并点击“确定”按钮。如图所示；</p><p><img src="https://img.musnow.top/i/2023/08/bf8f5bb96b5daa6290850574d2258bb7.png"></p></li><li><p>13</p><p>13、点击确定后，这个时候会弹出Windows安全对话框，进行更改所有权。如图所示；</p><p><img src="https://img.musnow.top/i/2023/08/74051d49c0138f62d250c588acb0eaa4.png"></p></li><li><p>14</p><p>14、更改所有权完成后，这个时候就能正常访问“WindowsApps”文件夹了。如图所示；</p><p><img src="https://img.musnow.top/i/2023/08/c523ded7262708fbef624c1c742997f8.png"></p></li></ul>]]></content>
    
    
    <summary type="html">Win下C盘里面的WindowsApps权限怎么获取</summary>
    
    
    
    <category term="电脑使用小贴士" scheme="https://blog.musnow.top/categories/%E7%94%B5%E8%84%91%E4%BD%BF%E7%94%A8%E5%B0%8F%E8%B4%B4%E5%A3%AB/"/>
    
    
    <category term="windows" scheme="https://blog.musnow.top/tags/windows/"/>
    
  </entry>
  
  <entry>
    <title>【Linux】centos8安装bison3.8</title>
    <link href="https://blog.musnow.top/posts/1067381808/"/>
    <id>https://blog.musnow.top/posts/1067381808/</id>
    <published>2023-08-30T10:31:55.000Z</published>
    <updated>2023-08-30T10:31:55.000Z</updated>
    
    <content type="html"><![CDATA[<p>centos8安装<code>bison3.8</code>的教程，感觉这个软件包很<code>小众</code>啊，百度找不到安装教程，最终还是在起脚旮旯里面翻出来了很久之前的文档，好在没有过时；</p><span id="more"></span><blockquote><p><a href="https://linux.cn/lfs/LFS-BOOK-7.7-systemd/chapter06/bison.html">https://linux.cn/lfs/LFS-BOOK-7.7-systemd/chapter06/bison.html</a></p></blockquote><p><img src="https://img.musnow.top/i/2023/09/db6be01dbd28cd3371fdf8e5d657b968.png" alt="image-20230901215525821"></p><p>虽然centos8中你可以使用yum直接安装，但是哪个安装的版本太低了，达不到如今的需求</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install -y bison</span><br></pre></td></tr></table></figure><p>我这边直接用yum安装的是<code>3.0.4</code>的版本，已经是2015年的东西了，最新的版本已经到3.8了，而且我正在使用的新项目miniob就要求更高的版本，所以老版本肯定是不行的；</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">bison (GNU Bison) 3.0.4</span><br><span class="line">Written by Robert Corbett and Richard Stallman.</span><br><span class="line"></span><br><span class="line">Copyright (C) 2015 Free Software Foundation, Inc.</span><br><span class="line">This is free software; see the source for copying conditions.  There is NO</span><br><span class="line">warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.</span><br></pre></td></tr></table></figure><p>先用yum把安装好了的删掉</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum remove bison</span><br></pre></td></tr></table></figure><blockquote><p>我看有的文章说需要先安装前置依赖项<code>flex</code>，这里带上吧。因为我的系统里面不知道什么时候就已经安装好了这个东西了</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install flex</span><br></pre></td></tr></table></figure></blockquote><p>去官网 <a href="http://ftp.gnu.org/gnu/bison/">http://ftp.gnu.org/gnu/bison/</a> 下载最新的压缩包</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget http://ftp.gnu.org/gnu/bison/bison-3.8.tar.gz</span><br></pre></td></tr></table></figure><p>解压并进入文件夹</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">tar -zxvf bison-3.8.tar.gz</span><br><span class="line">cd bison-3.8</span><br></pre></td></tr></table></figure><p>配置安装路径，这里我使用了<code>/usr/local</code>这个目录，如果你查看过安装后的bison，你会发现它的安装包的逻辑是和<code>/usr/local</code>目录一致的，当然你也可以修改成你自己想要的目录</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># ls /usr/local/</span><br><span class="line">bin  doc  etc  games  include  lib  lib64  libexec  openssl-1.1.1  sbin  share  src</span><br></pre></td></tr></table></figure><p>使用如下命令配置安装路径为<code>/usr/local</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./configure -prefix=/usr/local/</span><br></pre></td></tr></table></figure><p>目录配置好了之后，make安装</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make install</span><br></pre></td></tr></table></figure><blockquote><p>如果要卸载，用<code>make uninstall</code></p></blockquote><p>安装好了之后执行<code>bison --version</code>，你会得到如下输出</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-bash: /usr/bin/bison: No such file or directory</span><br></pre></td></tr></table></figure><p>这是因为我们在<code>/usr/local</code>里面安装的东西没有在path中，没有办法直接执行，需要我们将其软链接到<code>/usr/bin</code>里面；</p><p>如果你的安装正确了，应该可以在<code>/usr/local/bin</code>里面找到<code>bison</code>; 如果你安装的路径不同，那就去你安装路径下找<code>bison</code>的可执行文件；</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># ls /usr/local/bin</span></span><br><span class="line">2to3-3.10  bison  cmake  cpack  ctest  docker-compose  idle3.10  pip3.10  pydoc3.10  python3.10  python3.10-config  yacc</span><br></pre></td></tr></table></figure><p>将其软连接一下就ok了</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># ln -s /usr/local/bin/bison /usr/bin/bison</span></span><br><span class="line"><span class="comment"># ls /usr/bin/bison</span></span><br><span class="line">/usr/bin/bison</span><br></pre></td></tr></table></figure><p>再次检查版本，安装<code>3.8</code>成功！</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># bison --version</span><br><span class="line">bison (GNU Bison) 3.8</span><br><span class="line">Written by Robert Corbett and Richard Stallman.</span><br><span class="line"></span><br><span class="line">Copyright (C) 2021 Free Software Foundation, Inc.</span><br><span class="line">This is free software; see the source for copying conditions.  There is NO</span><br><span class="line">warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;centos8安装&lt;code&gt;bison3.8&lt;/code&gt;的教程，感觉这个软件包很&lt;code&gt;小众&lt;/code&gt;啊，百度找不到安装教程，最终还是在起脚旮旯里面翻出来了很久之前的文档，好在没有过时；&lt;/p&gt;</summary>
    
    
    
    <category term="玩上Linux" scheme="https://blog.musnow.top/categories/%E7%8E%A9%E4%B8%8ALinux/"/>
    
    
    <category term="Linux" scheme="https://blog.musnow.top/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>【Linux】centos8安装cmake3.27.4</title>
    <link href="https://blog.musnow.top/posts/343476194/"/>
    <id>https://blog.musnow.top/posts/343476194/</id>
    <published>2023-08-30T10:30:55.000Z</published>
    <updated>2023-08-30T10:30:55.000Z</updated>
    
    <content type="html"><![CDATA[<p>第一步，去<a href="https://cmake.org/download/">官网</a>下安装包，一定不要下错了</p><p><img src="https://img.musnow.top/i/2023/08/a7b64c50664a8d69fb805fcbb17edcbe.png" alt="image-20230830175242958"></p><p>下好了之后，用ftp软件传到云服务器或者虚拟机上，也可以用wget直接下载</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget https://github.com/Kitware/CMake/releases/download/v3.27.4/cmake-3.27.4.tar.gz</span><br></pre></td></tr></table></figure><p>我用的是centos8系统，安装之前先准备好这些依赖项</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">yum install -y gcc gcc-c++ make automake</span><br><span class="line">yum install -y openssl  openssl-devel</span><br></pre></td></tr></table></figure><p>把下载好的安装包传上去后，解压（在root用户下操作）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar -zxvf cmake-3.27.4.tar.gz </span><br></pre></td></tr></table></figure><p>解压完毕后进入文件夹</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cd cmake-3.27.4</span><br></pre></td></tr></table></figure><p>执行命令</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./bootstrap</span><br></pre></td></tr></table></figure><p>耐心等候完成后，依次运行下面两个命令</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">gmake</span><br><span class="line">gmake install</span><br></pre></td></tr></table></figure><p>最终判断是否安装成功</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cmake --version</span><br></pre></td></tr></table></figure><p>出现如下信息就是搞定了</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># cmake --version</span><br><span class="line">cmake version 3.27.4</span><br><span class="line"></span><br><span class="line">CMake suite maintained and supported by Kitware (kitware.com/cmake).</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;第一步，去&lt;a href=&quot;https://cmake.org/download/&quot;&gt;官网&lt;/a&gt;下安装包，一定不要下错了&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img.musnow.top/i/2023/08/a7b64c50664a8d69fb805fcbb</summary>
      
    
    
    
    <category term="玩上Linux" scheme="https://blog.musnow.top/categories/%E7%8E%A9%E4%B8%8ALinux/"/>
    
    
    <category term="Linux" scheme="https://blog.musnow.top/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>【C++】C++14的那些新特性</title>
    <link href="https://blog.musnow.top/posts/1184922698/"/>
    <id>https://blog.musnow.top/posts/1184922698/</id>
    <published>2023-08-28T14:40:46.000Z</published>
    <updated>2023-08-28T14:40:46.000Z</updated>
    
    <content type="html"><![CDATA[<p>学习C++14的那些新特性</p><span id="more"></span><p><img src="https://img.musnow.top/i/2023/08/0061de987afa3c3003cbfa4762397ac5.png" alt="v2-642fda8762a7dcda4556e14c8ff5c1ef_1440w"></p><p>为了方便指定使用C++14来编译代码，本文的测试都是在linux下进行的，g++版本如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ g++ --version</span><br><span class="line">g++ (GCC) 8.5.0 20210514 (Red Hat 8.5.0-4)</span><br></pre></td></tr></table></figure><p>如果你和我一样，也是使用VSC来链接linux进行代码编写，那一定要记得修改C++插件里面的CPP版本，否则默认以C++11来进行语法高亮的话，会把C++11不支持的语法标红，影响我们学习</p><p><img src="https://img.musnow.top/i/2023/08/8363f819fd562b1bd452551e970ff4a3.png" alt="image-20230828230838973"></p><blockquote><p>本文参考 <a href="https://zhuanlan.zhihu.com/p/588826142">https://zhuanlan.zhihu.com/p/588826142</a> 进行学习;</p><p>官方文档 <a href="https://zh.cppreference.com/w/cpp/14">https://zh.cppreference.com/w/cpp/14</a></p></blockquote><h1 id="1-lambda新特性"><a href="#1-lambda新特性" class="headerlink" title="1.lambda新特性"></a>1.lambda新特性</h1><p>C++14给lambda表达式添加了两个新功能</p><ul><li>参数推断（auto）</li><li>参数初始化后捕获（可以在<code>[]</code>对某个新参数进行赋值）</li></ul><p>先来复习一下C++11中学习的lambda捕获的基本方式</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[val]：表示值传递方式捕捉变量val</span><br><span class="line">[=]：表示值传递方式捕获所有父作用域中的变量(包括this)</span><br><span class="line">[&amp;val]：表示引用传递捕捉变量val</span><br><span class="line">[&amp;]：表示引用传递捕捉所有父作用域中的变量(包括this)</span><br><span class="line">[this]：表示值传递方式捕捉当前的this指针</span><br></pre></td></tr></table></figure><p>在C++14中，新增的是下面的这种情况</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">30</span>;</span><br><span class="line"><span class="comment">// [] 中赋值了一个参数</span></span><br><span class="line"><span class="comment">// () 中可以使用auto关键字来推断参数类型</span></span><br><span class="line"><span class="keyword">auto</span> func = [x = <span class="number">3</span>](<span class="keyword">auto</span> y) &#123;<span class="keyword">return</span> x + y; &#125;;</span><br><span class="line">cout &lt;&lt; <span class="built_in">func</span>(a) &lt;&lt; endl;</span><br></pre></td></tr></table></figure><p>运行测试，可以看到成功输出了结果</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ make</span><br><span class="line">g++ test.cpp -o test -std=c++14</span><br><span class="line">$ ./test</span><br><span class="line">33</span><br></pre></td></tr></table></figure><p>修改一下类型，也能正常调用</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">double</span> a = <span class="number">30.2</span>;</span><br><span class="line"><span class="keyword">auto</span> func = [x = <span class="number">3</span>](<span class="keyword">auto</span> y)</span><br><span class="line">&#123; <span class="keyword">return</span> x + y; &#125;;</span><br><span class="line">cout &lt;&lt; <span class="built_in">func</span>(a) &lt;&lt; endl;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ ./test</span><br><span class="line">33.2</span><br></pre></td></tr></table></figure><p>如果想将赋值参数和原本的捕获方式一起使用，则需要将<strong>赋值参数</strong>放在<code>[]</code>的最<strong>后面</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">test_lambda2</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">10</span>, b = <span class="number">20</span>;</span><br><span class="line">    <span class="type">int</span> c = <span class="number">1</span>, d = <span class="number">3</span>, e = <span class="number">5</span>;</span><br><span class="line">    <span class="comment">// 赋值的参数要放在[]的最后面，捕获方式放在前面</span></span><br><span class="line">    <span class="keyword">auto</span> func6 = [=, f = <span class="number">30</span>, g = <span class="number">40</span>]</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">return</span> (a + b + c + d + e + f + g);</span><br><span class="line">    &#125;;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">func6</span>() &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ ./test</span><br><span class="line">109</span><br></pre></td></tr></table></figure><p>初始化捕获的好处是可以支持<strong>移动捕获</strong>了；不然在C++11中，lambda就只能使用赋值捕获和引用捕获</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::unique_ptr&lt;Item&gt; <span class="title">item</span><span class="params">(<span class="keyword">new</span> Item())</span></span>;</span><br><span class="line"><span class="comment">// std::move改为右值进行赋值后捕获</span></span><br><span class="line"><span class="keyword">auto</span> func = [m = std::<span class="built_in">move</span>(item)] &#123; <span class="comment">/* do something */</span> &#125;;</span><br></pre></td></tr></table></figure><p>这个新特性的提出，也让lambda成功有了和bind比拼的能力。在C++11中，bind的优势就是在于<strong>移动捕获</strong>的支持；如今lambda也有了这份能力了，我们可以更灵活地根据场景选用lambda或者bind，而不是只能使用bind了。</p><h1 id="2-变量模板"><a href="#2-变量模板" class="headerlink" title="2.变量模板"></a>2.变量模板</h1><h2 id="2-1-示例"><a href="#2-1-示例" class="headerlink" title="2.1 示例"></a>2.1 示例</h2><p>看清楚这个名字啊！是<strong>变量模板</strong>，可不是什么函数模板哈！</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line">T pi = <span class="built_in">T</span>(<span class="number">3.1415926535897932385L</span>); <span class="comment">// variable template</span></span><br><span class="line"><span class="comment">// 数字最后的L代表这是一个长浮点型</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test_value_template</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; pi&lt;<span class="type">double</span>&gt; &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; pi&lt;<span class="type">float</span>&gt; &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; pi&lt;<span class="type">int</span>&gt; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如上就是一个最最最简单的变量模板，我们在传入对应的类型后，他就会转成我们需要的类型</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ make</span><br><span class="line">g++ test.cpp -o test -std=c++14</span><br><span class="line">$ ./test</span><br><span class="line">3.14159</span><br><span class="line">3.14159</span><br><span class="line">3</span><br></pre></td></tr></table></figure><h2 id="2-2-类中使用"><a href="#2-2-类中使用" class="headerlink" title="2.2 类中使用"></a>2.2 类中使用</h2><p>当你需要在类中使用模板变量的时候，这个变量必须定义为<code>static</code>；</p><p>因为它是模板，我们还可以接用模板本身就有的特性，将这个模板针对某一个类型进行<strong>特化</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Limits</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">    <span class="type">static</span> <span class="type">const</span> T min; <span class="comment">// 声明静态成员模板</span></span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">const</span> T Limits::min = &#123; &#125;; <span class="comment">// 定义静态成员模板，全部使用默认值</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 下面三个是模板变量的特化</span></span><br><span class="line"><span class="keyword">template</span>&lt;&gt;</span><br><span class="line"><span class="type">const</span> <span class="type">float</span> Limits::min&lt;<span class="type">float</span>&gt; = <span class="number">4.5</span>;</span><br><span class="line"><span class="keyword">template</span>&lt;&gt;</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> Limits::min&lt;<span class="type">double</span>&gt; = <span class="number">5.5</span>;</span><br><span class="line"><span class="keyword">template</span>&lt;&gt;</span><br><span class="line"><span class="type">const</span> std::string Limits::min&lt;std::string&gt; = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::cout &lt;&lt; Limits::min&lt;<span class="type">int</span>&gt; &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; Limits::min&lt;<span class="type">float</span>&gt; &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; Limits::min&lt;<span class="type">double</span>&gt; &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; Limits::min&lt;std::string&gt; &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ ./test</span><br><span class="line">0</span><br><span class="line">4.5</span><br><span class="line">5.5</span><br><span class="line">hello</span><br></pre></td></tr></table></figure><h2 id="2-3-和类型转换的区别"><a href="#2-3-和类型转换的区别" class="headerlink" title="2.3 和类型转换的区别"></a>2.3 和类型转换的区别</h2><p>这里我又直接定义了一个变量，使用<code>static_cast</code>直接转换变量，看看结果会不会有什么区别</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 数字最后的L代表这是一个长浮点型</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line">T pi = <span class="built_in">T</span>(<span class="number">3.1415926535897932385L</span>); <span class="comment">// 变量模板</span></span><br><span class="line"></span><br><span class="line"><span class="type">long</span> <span class="type">double</span> lpi = <span class="number">3.1415926535897932385L</span>; <span class="comment">// 直接定义长浮点型</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test_value_template</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; pi&lt;<span class="type">double</span>&gt; &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; pi&lt;<span class="type">float</span>&gt; &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; pi&lt;<span class="type">int</span>&gt; &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot; ----- \n&quot;</span>;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="built_in">static_cast</span>&lt;<span class="type">double</span>&gt;(lpi) &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">static_cast</span>&lt;<span class="type">float</span>&gt;(lpi) &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">static_cast</span>&lt;<span class="type">int</span>&gt;(lpi) &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看上去二者的结果完全相同，那么既然可以直接使用变量类型转换，为什么还要新增一个模板变量呢？</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ ./test</span><br><span class="line">3.14159</span><br><span class="line">3.14159</span><br><span class="line">3</span><br><span class="line"> ----- </span><br><span class="line">3.14159</span><br><span class="line">3.14159</span><br><span class="line">3</span><br></pre></td></tr></table></figure><blockquote><p>以下内容来自GPT，我觉得它说的很对</p></blockquote><p>定义一个变量并使用数据转换（类型转换）是一种常见的编程方式，但与变量模板有一些区别：</p><ol><li><strong>通用性：</strong> 变量模板允许你通过模板参数来生成多个不同类型的变量，从而在不同的上下文中使用。这使得代码更具通用性和可扩展性，因为你可以为多个类型生成相应的变量。相比之下，直接定义变量并使用数据转换通常只适用于特定的一种数据类型。</li><li><strong>模板化：</strong> 变量模板是一种模板化的方式来生成变量，它遵循 C++ 的模板机制，这意味着你可以使用模板<strong>特化</strong>、部分特化等技术来定制化生成的变量，以满足不同的需求。而使用数据转换时，你必须显式地执行类型转换，这可能会在代码中引入不必要的重复。</li><li><strong>编译时计算：</strong> 变量模板通常用于在编译时生成值，因此可以在编译阶段进行类型检查和计算。这有助于提高代码的性能和安全性。而数据转换可能在运行时进行，可能会引入一些运行时开销和类型错误的风险。</li><li><strong>抽象性：</strong> 变量模板可以在更高的抽象层次上操作数据，使代码更具表达力和可读性。它允许你以更自然的方式描述某个值与特定类型之间的关系，而不必显式进行类型转换。</li></ol><p>总之，变量模板提供了一种更灵活、通用和模板化的方式来生成变量，适用于需要在不同类型上工作的情况。当你需要为多个类型生成特定的变量或值时，变量模板是一种更优雅和强大的选择。</p><h1 id="3-constexpr限制放宽"><a href="#3-constexpr限制放宽" class="headerlink" title="3.constexpr限制放宽"></a>3.constexpr限制放宽</h1><p>在C++11中被引入的constexpr，可以让编译器在编译程序的期间，就将一部分工作完成，不必等到运行期间再做；在C++11中，constexpr的限制很严格，这导致它并不好用：</p><ul><li>constexpr修饰变量，要求变量必须可以在编译器推导出来</li><li>constexpr修饰函数（返回值），函数内除了可以包含using和typedef指令以及<code>static_asssert</code>断言外，只能包含一条<code>return</code>语句</li><li>constexpr同时可以修饰构造函数，但也会要求使用这个构造函数的时候，可以在编译器就把相关的内容全推导出来</li></ul><p>以下是一个比较基础的C++11中的用例，给该函数设置了<code>constexpr</code>关键字后，该函数就可以在编译期间被计算出结果，再用<code>static_assert</code>在编译期间断言结果是否正确；</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">constexpr</span> <span class="type">int</span> <span class="title">factorial</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (n &lt;= <span class="number">1</span>) ? <span class="number">1</span> : n * <span class="built_in">factorial</span>(n - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">test_constexpr1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constexpr</span> <span class="type">int</span> result = <span class="built_in">factorial</span>(<span class="number">5</span>); <span class="comment">// 编译时计算阶乘</span></span><br><span class="line">    <span class="built_in">static_assert</span>(result == <span class="number">120</span>, <span class="string">&quot;Factorial of 5 should be 120&quot;</span>); <span class="comment">// 编译时断言</span></span><br><span class="line">    cout &lt;&lt; result &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果在C++11中的constexpr函数内包含其他语句，编译的时候会报错，翻译过来是该函数内部不是一个return返回语句</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ g++ test.cpp -o test -std=c++11</span><br><span class="line">test.cpp: In function ‘constexpr int FuncNew(int)’:</span><br><span class="line">test.cpp:96:1: error: body of ‘constexpr’ function ‘constexpr int FuncNew(int)’ not a return-statement</span><br><span class="line"> &#125;</span><br><span class="line"> ^</span><br></pre></td></tr></table></figure><p>c++14中，对constexpr的限制放宽了，允许使用<strong>循环、if、switch</strong>等等语句，但是主旨还是一样的，需要在编译期间就可以计算出全部内容；限制放宽之后，这个关键字便可以更灵活的使用了。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 计算前n项和，C++11</span></span><br><span class="line"><span class="function"><span class="keyword">constexpr</span> <span class="type">int</span> <span class="title">Func</span><span class="params">(<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> n &gt; <span class="number">0</span> ? <span class="built_in">Func</span>(n - <span class="number">1</span>) + n : <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 计算前N项和，C++14</span></span><br><span class="line"><span class="function"><span class="keyword">constexpr</span> <span class="type">int</span> <span class="title">FuncNew</span><span class="params">(<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n &lt;= <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        sum += i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="4-二进制变量"><a href="#4-二进制变量" class="headerlink" title="4.二进制变量"></a>4.二进制变量</h1><p>可以使用<code>0b</code>或者<code>0B</code>开头直接定义二进制变量。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;    </span><br><span class="line">    <span class="type">int</span> bit1 = <span class="number">0b1001</span>;</span><br><span class="line">    <span class="type">int</span> bit2 = <span class="number">0B</span>1011;</span><br><span class="line">    std::cout &lt;&lt; bit1 &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; bit2 &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ g++ test.cpp -o test -std=c++14</span><br><span class="line">$ ./test</span><br><span class="line">9 11</span><br></pre></td></tr></table></figure><p>我在测试中发现，当我用C++11编译此代码的时候，似乎也没有引发编译错误，难道说0b是在C++11里面就支持了吗？</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ g++ test.cpp -o test -std=c++11</span><br><span class="line">$ ./test</span><br><span class="line">9 11</span><br></pre></td></tr></table></figure><p>GPT给出了0B这种二进制变量是在C++14中引入的确认，并提到了为什么会出现上述情况；虽然C++11看上去编译和运行都没有问题，但我们还是得遵循版本，选用正确的版本进行编译，才能根本上避免错误</p><blockquote><p>C++标准通常是向后兼容的，这意味着较新版本的编译器通常会继续支持较旧版本的标准。例如，如果你在使用支持C++11标准的编译器（如g++）时，使用了C++14或更高版本的特性，通常不会引发编译错误，因为这些编译器会尽量向后兼容，以保持现有代码的可编译性。</p><p>在你提到的情况下，即使你使用g++编译器以C++11标准编译，它仍然可以理解和接受C++14引入的二进制字面量特性。这是编译器开发者的一种设计选择，以便使代码的迁移更加平滑。但是，为了遵循最佳实践和保持代码的可读性，当你在使用特定C++标准的功能时，最好将编译器选项设置为该标准的版本，以确保代码的可移植性。</p></blockquote><h1 id="5-数字分隔符"><a href="#5-数字分隔符" class="headerlink" title="5.数字分隔符"></a>5.数字分隔符</h1><p>在日常生活中使用数字的时候，为了更好的可读性，我们会以3个数组或者4个数组为分割，打一个点</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1,0000,0000 一亿</span><br><span class="line">100,000,000</span><br></pre></td></tr></table></figure><p>C++14中，也支持了这样的打点，以方便我们更好的看出大数字的位数</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">test_num_div</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> big_num1 = <span class="number">100000000</span>;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> big_num2 = <span class="number">100&#x27;000&#x27;000</span>;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> big_num3 = <span class="number">1&#x27;0000&#x27;0000</span>;</span><br><span class="line">    cout &lt;&lt; big_num1 &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; big_num2 &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; big_num3 &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>需要注意，这样的操作不会对数字本身有任何影响</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ ./test</span><br><span class="line">100000000</span><br><span class="line">100000000</span><br><span class="line">100000000</span><br></pre></td></tr></table></figure><p>在C++11中这种语法是不支持的</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">$ g++ test.cpp -o test -std=c++11</span><br><span class="line">test.cpp:116:29: warning: multi-character character constant [-Wmultichar]</span><br><span class="line">     long long big_num2 = 100&#x27;000&#x27;000;</span><br><span class="line">                             ^~~~~</span><br><span class="line">test.cpp:117:27: warning: multi-character character constant [-Wmultichar]</span><br><span class="line">     long long big_num3 = 1&#x27;0000&#x27;0000;</span><br><span class="line">                           ^~~~~~</span><br><span class="line">test.cpp: In function ‘void test_num_div()’:</span><br><span class="line">test.cpp:116:29: error: expected ‘,’ or ‘;’ before &#x27;\x303030&#x27;</span><br><span class="line">     long long big_num2 = 100&#x27;000&#x27;000;</span><br><span class="line">                             ^~~~~</span><br><span class="line">test.cpp:117:27: error: expected ‘,’ or ‘;’ before &#x27;\x30303030&#x27;</span><br><span class="line">     long long big_num3 = 1&#x27;0000&#x27;0000;</span><br><span class="line">                           ^~~~~~</span><br></pre></td></tr></table></figure><h1 id="6-返回值auto推导"><a href="#6-返回值auto推导" class="headerlink" title="6.返回值auto推导"></a>6.返回值auto推导</h1><p>c++14新增了函数返回值的推导，当返回值声明为auto时，编译器会根据你的return语句推导出你的返回值类型。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">Func</span><span class="params">(T x, T y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="built_in">Func</span>(<span class="number">3</span>, <span class="number">4</span>) &lt;&lt; std::endl; <span class="comment">// 返回值推导为int</span></span><br><span class="line">    std::cout &lt;&lt; <span class="built_in">Func</span>(<span class="number">3.1</span>, <span class="number">4.2</span>) &lt;&lt; std::endl; <span class="comment">// 返回值推导为double</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ make</span><br><span class="line">g++ test.cpp -o test -std=c++14</span><br><span class="line">$ ./test</span><br><span class="line">7</span><br><span class="line">7.3</span><br></pre></td></tr></table></figure><p>这个推导是有限制条件的</p><p>1、如果有多个推导语句，那么多个推导的结果必须一致</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 编译报错，第一个return推导为int，第二个return推导为double，两次推导结果不一致</span></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">Func</span><span class="params">(<span class="type">int</span> flag)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (flag &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">3.14</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2、如果没有return或者return为void类型，那么auto会被推导为void。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">f</span><span class="params">()</span> </span>&#123;&#125;              <span class="comment">// returns void</span></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">g</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="built_in">f</span>(); &#125; <span class="comment">// returns void</span></span><br><span class="line"><span class="function"><span class="keyword">auto</span>* <span class="title">x</span><span class="params">()</span> </span>&#123;&#125;             <span class="comment">// error: cannot deduce auto* from void</span></span><br></pre></td></tr></table></figure><p>3、一旦在函数中看到return语句，从该语句推导出的返回类型就可以在函数的其余部分中使用，包括在其他return语句中。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">Sum</span><span class="params">(<span class="type">int</span> i)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (i &lt;= <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> i; <span class="comment">// 返回值被推导为int</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Sum</span>(i - <span class="number">1</span>) + i; <span class="comment">// sum的返回值已经被推导出来了，所以这里是没有问题的</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是如果还没被推导出来，那就不能使用。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">Sum</span><span class="params">(<span class="type">int</span> i)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (i &gt; <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Sum</span>(i - <span class="number">1</span>) + i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 编译报错，因为Sum的返回值还没有被推导出来，所以还不能使用</span></span><br><span class="line">error: use of ‘<span class="function"><span class="keyword">auto</span> <span class="title">Sum</span><span class="params">(<span class="type">int</span>)</span>’ before deduction of ‘<span class="keyword">auto</span>’</span></span><br></pre></td></tr></table></figure><p>4、不能推导初始化列表。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">func</span> <span class="params">()</span> </span>&#123; <span class="keyword">return</span> &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;; &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 编译报错</span></span><br><span class="line">error: returning initializer list</span><br></pre></td></tr></table></figure><p>5、虚函数不能使用返回值推导</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Item</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">auto</span> <span class="title">Func</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 编译报错</span></span><br><span class="line">error: <span class="keyword">virtual</span> function cannot have deduced <span class="keyword">return</span> type</span><br></pre></td></tr></table></figure><h1 id="7-deprecated-标记"><a href="#7-deprecated-标记" class="headerlink" title="7.[[deprecated]]标记"></a>7.<code>[[deprecated]]</code>标记</h1><p>这个标记的作用是告知其他人，某个函数被弃用了，不允许继续调用该函数；该字段的好处在于，如果一个方法已经在后续不需要使用了，你可以先给他加上这个关键字，然后再进行其他的代码检查，确认无误后，再将这个函数整体清除；</p><p>别人也不需要去检查函数的实现，因为在编译过程中编译器就会告诉你这个函数被弃用；<strong>但是编译依旧是成功的</strong>！</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">[[deprecated]]</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">test_return_auto</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="built_in">Func</span>(<span class="number">3</span>, <span class="number">4</span>) &lt;&lt; std::endl; <span class="comment">// 返回值推导为int</span></span><br><span class="line">    std::cout &lt;&lt; <span class="built_in">Func</span>(<span class="number">3.1</span>, <span class="number">4.2</span>) &lt;&lt; std::endl; <span class="comment">// 返回值推导为double</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">test_return_auto</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在编译的时候，编译器会警告你，这个函数已经被弃用了；但这里只是警告，编译依旧成功了，所以最终还是需要程序猿去瞅一眼各个警告到底是什么意思。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">$ make</span><br><span class="line">g++ test.cpp -o test -std=c++14</span><br><span class="line">test.cpp: In function ‘int main()’:</span><br><span class="line">test.cpp:145:22: warning: ‘int test_return_auto()’ is deprecated [-Wdeprecated-declarations]</span><br><span class="line">     test_return_auto();</span><br><span class="line">                      ^</span><br><span class="line">test.cpp:132:5: note: declared here</span><br><span class="line"> int test_return_auto()</span><br><span class="line">     ^~~~~~~~~~~~~~~~</span><br><span class="line">test.cpp:145:22: warning: ‘int test_return_auto()’ is deprecated [-Wdeprecated-declarations]</span><br><span class="line">     test_return_auto();</span><br><span class="line">                      ^</span><br><span class="line">test.cpp:132:5: note: declared here</span><br><span class="line"> int test_return_auto()</span><br><span class="line">     ^~~~~~~~~~~~~~~~</span><br></pre></td></tr></table></figure><hr><h1 id="std库的新特性"><a href="#std库的新特性" class="headerlink" title="std库的新特性"></a>std库的新特性</h1><p>以下是STD库的新增内容！</p><h2 id="8-std-make-unique"><a href="#8-std-make-unique" class="headerlink" title="8.std::make_unique"></a>8.std::make_unique</h2><p>这个东西在cplusplus网站上找不到释义，所以就去<a href="https://zh.cppreference.com/">cpp的官网</a>上找了</p><blockquote><p><a href="https://zh.cppreference.com/w/cpp/memory/unique_ptr/make_unique">https://zh.cppreference.com/w/cpp/memory/unique_ptr/make_unique</a></p></blockquote><p>该函数定义在<code>&lt;memory&gt;</code>头文件中</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt; <span class="keyword">class</span> T, <span class="keyword">class</span>... Args &gt;</span></span><br><span class="line"><span class="function">unique_ptr&lt;T&gt; <span class="title">make_unique</span><span class="params">( Args&amp;&amp;... args )</span></span>;</span><br><span class="line"><span class="comment">//(1)(C++14 起) (仅对非数组类型)</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt; <span class="keyword">class</span> T &gt;</span></span><br><span class="line"><span class="function">unique_ptr&lt;T&gt; <span class="title">make_unique</span><span class="params">( std::<span class="type">size_t</span> size )</span></span>;</span><br><span class="line"><span class="comment">//(2)(C++14 起) (仅对未知边界数组)</span></span><br><span class="line"><span class="keyword">template</span>&lt; <span class="keyword">class</span> <span class="title class_">T</span>, <span class="keyword">class</span>... Args &gt;</span><br><span class="line"><span class="comment">/* unspecified */</span> <span class="built_in">make_unique</span>( Args&amp;&amp;... args ) = <span class="keyword">delete</span>;</span><br><span class="line"><span class="comment">//(3)(C++14 起) (仅对已知边界数组)</span></span><br></pre></td></tr></table></figure><p>作用是构造 <code>T</code> 类型对象并将其包装进 <a href="https://zh.cppreference.com/w/cpp/memory/unique_ptr">std::unique_ptr</a>；</p><table><thead><tr><th>参数</th><th>说明</th></tr></thead><tbody><tr><td>args</td><td>将要构造的 <code>T</code> 实例所用的参数列表。</td></tr><tr><td>size</td><td>要构造的数组大小</td></tr></tbody></table><ol><li>构造非数组类型 <code>T</code> 对象。传递参数 <code>args</code> 给 <code>T</code> 的构造函数。此重载只有在 <code>T</code> 不是数组类型时才会参与重载决议。函数等价于：</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">unique_ptr</span>&lt;T&gt;(<span class="keyword">new</span> <span class="built_in">T</span>(std::forward&lt;Args&gt;(args)...))</span><br></pre></td></tr></table></figure><ol start="2"><li>构造拥有动态大小的数组。<a href="https://zh.cppreference.com/w/cpp/language/value_initialization">值初始化</a>数组元素。此重载只有在 <code>T</code> 是未知边界数组时才会参与重载决议。函数等价于：</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">unique_ptr</span>&lt;T&gt;(<span class="keyword">new</span> std::<span class="type">remove_extent_t</span>&lt;T&gt;[size]())</span><br></pre></td></tr></table></figure><p>使用示例</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">test_class</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">test_class</span>(<span class="type">int</span> a=<span class="number">-1</span>):_a(a)&#123;&#125;</span><br><span class="line">    <span class="type">int</span> _a;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::unique_ptr&lt;test_class&gt; pt = std::<span class="built_in">make_unique</span>&lt;test_class&gt;(<span class="number">3</span>);</span><br><span class="line">    cout &lt;&lt; pt-&gt;_a &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ make</span><br><span class="line">g++ test.cpp -o test -std=c++14</span><br><span class="line">$ ./test</span><br><span class="line">3</span><br></pre></td></tr></table></figure><h2 id="9-std-shared-timed-mutex与std-shared-lock"><a href="#9-std-shared-timed-mutex与std-shared-lock" class="headerlink" title="9.std::shared_timed_mutex与std::shared_lock"></a>9.std::shared_timed_mutex与std::shared_lock</h2><p>c++11引入了多线程线程的一些库，但是是没有读写锁的，因此在c++14引入了读写锁的相关实现（头文件shared_mutex），其实c++14读写锁也还不够完善，直到c++17读写锁这块才算是完备起来。</p><p><code>std::shared_timed_mutex</code>是带超时的读写锁对象，接口还算比较简洁易懂，和之前接触过的其他锁基本一致；内部成员中<code>lock()</code>是写锁，<code>lock_shared()</code>是读锁;</p><p><a href="https://zh.cppreference.com/w/cpp/thread/shared_timed_mutex">https://zh.cppreference.com/w/cpp/thread/shared_timed_mutex</a></p><p><img src="https://img.musnow.top/i/2023/08/9c8a79016b52e8d7845bdee6a98fc151.png" alt="image-20230829082045636"></p><p><code>std::shared_lock</code>是加锁的RAII实现，即构造时加锁，析构时解锁；我们使用<code>shared_lock/unique_lock</code>来从<code>shared_timed_mutex</code>中获取锁的时候，就会自动获取读锁和写锁；</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">std::shared_timed_mutex mutex;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">readOperation</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 读锁是多人可以获取的，所以要用shared_lock (读锁)</span></span><br><span class="line">    <span class="function">std::shared_lock&lt;std::shared_timed_mutex&gt; <span class="title">lock</span><span class="params">(mutex)</span></span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Read operation: &quot;</span> &lt;&lt; sharedResource &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">writeOperation</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 写锁互斥获取，用unique_lock (写锁)</span></span><br><span class="line">    <span class="function">std::unique_lock&lt;std::shared_timed_mutex&gt; <span class="title">lock</span><span class="params">(mutex)</span></span>;</span><br><span class="line">    sharedResource++;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Write operation: &quot;</span> &lt;&lt; sharedResource &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="10-std-exchange"><a href="#10-std-exchange" class="headerlink" title="10.std::exchange"></a>10.std::exchange</h2><p>c++14新增了一个接口<code>std::exchange</code>（头文件utility），其实这个也并不算是新增的，因为这个接口其实在c++11的时候就有了，只不过在c++11中作为一个内部函数，不暴露给用户使用，在c++14中才把它暴露出来给用户使用。使用方法也很简单。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::string s1 = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">    std::string s2 = <span class="string">&quot;world&quot;</span>;</span><br><span class="line">    std::<span class="built_in">exchange</span>(s1, s2);</span><br><span class="line">    std::cout &lt;&lt; s1 &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; s2 &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出结果</span></span><br><span class="line">world world</span><br></pre></td></tr></table></figure><p>我们可以看到，exchange会把第二个值赋值给第一个值，但是不会改变第二个值。我们来看下它的实现吧。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// Assign @p __new_val to @p __obj and return its previous value.</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> _Tp, <span class="keyword">typename</span> _Up = _Tp&gt;</span><br><span class="line">  _GLIBCXX20_CONSTEXPR</span><br><span class="line">  <span class="keyword">inline</span> _Tp</span><br><span class="line">  </span><br><span class="line">  <span class="built_in">exchange</span>(_Tp&amp; __obj, _Up&amp;&amp; __new_val)</span><br><span class="line">  <span class="built_in">noexcept</span>(__and_&lt;is_nothrow_move_constructible&lt;_Tp&gt;,</span><br><span class="line">    is_nothrow_assignable&lt;_Tp&amp;, _Up&gt;&gt;::value)</span><br><span class="line">  &#123; <span class="keyword">return</span> std::__exchange(__obj, std::forward&lt;_Up&gt;(__new_val)); &#125;  </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// C++11 version of std::exchange for internal use.</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> _Tp, <span class="keyword">typename</span> _Up = _Tp&gt;</span><br><span class="line">  _GLIBCXX20_CONSTEXPR</span><br><span class="line">  <span class="keyword">inline</span> _Tp</span><br><span class="line">  __exchange(_Tp&amp; __obj, _Up&amp;&amp; __new_val)</span><br><span class="line">  &#123;</span><br><span class="line">    _Tp __old_val = std::<span class="built_in">move</span>(__obj);</span><br><span class="line">    __obj = std::forward&lt;_Up&gt;(__new_val);</span><br><span class="line">    <span class="keyword">return</span> __old_val;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>通过注释我们可以明白含义，它的作用是把第二个值赋值给第一个值，同时返回第一个值的旧值。</p><p>除此之外，我们这里说明一个关键的点。exchange的第二个参数是万能引用，所以说他是既可以接收左值，也可以接收右值的，所以我们可以这样来使用。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::string s1 = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">    <span class="comment">// 第二个值是纯右值</span></span><br><span class="line">    std::<span class="built_in">exchange</span>(s1, <span class="string">&quot;world&quot;</span>);</span><br><span class="line">    std::cout &lt;&lt; s1 &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    std::string s2 = <span class="string">&quot;hello world&quot;</span>;</span><br><span class="line">    <span class="comment">// 第二个值通过move语义转成右值</span></span><br><span class="line">    std::<span class="built_in">exchange</span>(s1, std::<span class="built_in">move</span>(s2));</span><br><span class="line">    std::cout &lt;&lt; s1 &lt;&lt; <span class="string">&quot; | &quot;</span> &lt;&lt; s2 &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出结果，注意这里s2为空字符串，因为s2的东西已经被移动拷贝给s1了</span></span><br><span class="line">world</span><br><span class="line">hello world | </span><br></pre></td></tr></table></figure><h2 id="11-std-integer-sequence"><a href="#11-std-integer-sequence" class="headerlink" title="11.std::integer_sequence"></a>11.std::integer_sequence</h2><p>类模板 <code>std::integer_sequence</code> 表示一个编译时的整数序列。在用作<a href="https://zh.cppreference.com/w/cpp/language/function_template">函数模板</a>的实参时，能推导<a href="https://zh.cppreference.com/w/cpp/language/parameter_pack">参数包</a> <code>Ints</code> 并将它用于包展开。</p><p><a href="https://zh.cppreference.com/w/cpp/utility/integer_sequence">https://zh.cppreference.com/w/cpp/utility/integer_sequence</a></p><p>这个实在是太难懂了，搞不明白是干嘛的，放弃了😥</p><h2 id="12-std-quoted"><a href="#12-std-quoted" class="headerlink" title="12.std::quoted"></a>12.std::quoted</h2><p><a href="https://zh.cppreference.com/w/cpp/io/manip/quoted">https://zh.cppreference.com/w/cpp/io/manip/quoted</a></p><p>该函数模板位于 <code>&lt;iomanip&gt;</code> 头文件中，用于在输入输出流中处理被引号包围的字符串。它通常用于处理 CSV（逗号分隔值）文件或其他格式，其中字段被引号括起来以处理包含特殊字符（如逗号、换行符等）的情况。</p><p>对于<code>cout</code>而言，quoted会将字符串包围在双引号中输出</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">test_quorted</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::string data = <span class="string">&quot;Hello, \&quot;world\&quot;\n&quot;</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 输出流中使用 std::quoted，会将字符串在&quot;内包围输出</span></span><br><span class="line">    std::cout &lt;&lt; std::<span class="built_in">quoted</span>(data) &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ ./test</span><br><span class="line">&quot;Hello, \&quot;world\&quot;</span><br><span class="line">&quot;</span><br></pre></td></tr></table></figure><p>以下是官方给的一个示例</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iomanip&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sstream&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::stringstream ss;</span><br><span class="line">    std::string in = <span class="string">&quot;String with spaces, and embedded \&quot;quotes\&quot; too&quot;</span>;</span><br><span class="line">    std::string out;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">auto</span> show = [&amp;](<span class="type">const</span> <span class="keyword">auto</span>&amp; what) &#123;</span><br><span class="line">        &amp;what == &amp;in</span><br><span class="line">            ?   std::cout &lt;&lt; <span class="string">&quot;read in     [&quot;</span> &lt;&lt; in &lt;&lt; <span class="string">&quot;]\n&quot;</span></span><br><span class="line">                          &lt;&lt; <span class="string">&quot;stored as   [&quot;</span> &lt;&lt; ss.<span class="built_in">str</span>() &lt;&lt; <span class="string">&quot;]\n&quot;</span></span><br><span class="line">            :   std::cout &lt;&lt; <span class="string">&quot;written out [&quot;</span> &lt;&lt; out &lt;&lt; <span class="string">&quot;]\n\n&quot;</span>;</span><br><span class="line">    &#125;;</span><br><span class="line"> </span><br><span class="line">    ss &lt;&lt; std::<span class="built_in">quoted</span>(in);</span><br><span class="line">    <span class="built_in">show</span>(in);</span><br><span class="line">    ss &gt;&gt; std::<span class="built_in">quoted</span>(out);</span><br><span class="line">    <span class="built_in">show</span>(out);</span><br><span class="line"> </span><br><span class="line">    ss.<span class="built_in">str</span>(<span class="string">&quot;&quot;</span>); <span class="comment">// clear the stream buffer</span></span><br><span class="line"> </span><br><span class="line">    in = <span class="string">&quot;String with spaces, and embedded $quotes$ too&quot;</span>;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> delim &#123;<span class="string">&#x27;$&#x27;</span>&#125;;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> escape &#123;<span class="string">&#x27;%&#x27;</span>&#125;;</span><br><span class="line"> </span><br><span class="line">    ss &lt;&lt; std::<span class="built_in">quoted</span>(in, delim, escape);</span><br><span class="line">    <span class="built_in">show</span>(in);</span><br><span class="line">    ss &gt;&gt; std::<span class="built_in">quoted</span>(out, delim, escape);</span><br><span class="line">    <span class="built_in">show</span>(out);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">read in     [String with spaces, and embedded &quot;quotes&quot; too]</span><br><span class="line">stored as   [&quot;String with spaces, and embedded \&quot;quotes\&quot; too&quot;]</span><br><span class="line">written out [String with spaces, and embedded &quot;quotes&quot; too]</span><br><span class="line"> </span><br><span class="line">read in     [String with spaces, and embedded $quotes$ too]</span><br><span class="line">stored as   [$String with spaces, and embedded %$quotes%$ too$]</span><br><span class="line">written out [String with spaces, and embedded $quotes$ too]</span><br></pre></td></tr></table></figure><p>在给定的代码中，<code>delim</code> 和 <code>escape</code> 是用于指定自定义的分隔符和转义字符的参数。这些参数是用于 <code>std::quoted</code> 函数的重载形式，允许你指定不同于默认引号的字符来包围字符串，并指定一个不同于默认转义字符的字符来转义引号字符。以下是关于这两个参数的详细解释：</p><ol><li><code>delim</code>: 分隔符 在第一个用法中，<code>std::quoted</code> 函数使用了三个参数的重载形式：<code>std::quoted(in, delim, escape)</code>。<code>delim</code> 参数用于指定包围字符串的分隔符。通常情况下，<code>std::quoted</code> 使用双引号作为默认分隔符，但在某些情况下，你可能想要使用其他字符来包围字符串，以避免与字符串本身的字符冲突。在你的代码示例中，分隔符 <code>delim</code> 被设置为 <code>$</code>，这意味着字符串会被包围在 <code>$</code> 字符内。</li><li><code>escape</code>: 转义字符 <code>escape</code> 参数允许你指定一个字符，用于转义分隔符字符本身。在默认情况下，<code>std::quoted</code> 使用双引号 <code>&quot;</code> 作为转义字符，以确保在字符串中嵌入的引号不会被解释为结束引号。但如果你选择了自定义的分隔符，你可能还需要指定一个不同于默认转义字符的字符来进行转义。在你的代码示例中，转义字符 <code>escape</code> 被设置为 <code>%</code>，这意味着在字符串中，如果你想要表示分隔符 <code>$</code> 本身，你需要使用 <code>%$</code>。</li></ol><p>这部分也不是很容易搞明白它是干嘛的，如果面试官问道了就说我不会吧😭</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;学习C++14的那些新特性&lt;/p&gt;</summary>
    
    
    
    <category term="遇见C++" scheme="https://blog.musnow.top/categories/%E9%81%87%E8%A7%81C/"/>
    
    
    <category term="C++" scheme="https://blog.musnow.top/tags/C/"/>
    
    <category term="数据结构" scheme="https://blog.musnow.top/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    <category term="C++14" scheme="https://blog.musnow.top/tags/C-14/"/>
    
  </entry>
  
  <entry>
    <title>【leetcode】1137. 第 N 个泰波那契数</title>
    <link href="https://blog.musnow.top/posts/563921472/"/>
    <id>https://blog.musnow.top/posts/563921472/</id>
    <published>2023-08-27T09:32:44.000Z</published>
    <updated>2023-08-27T09:32:44.000Z</updated>
    
    <content type="html"><![CDATA[<p>今天是学习动归的第一天，先来一道简单题练练手吧！</p><h1 id="1-题目"><a href="#1-题目" class="headerlink" title="1.题目"></a>1.题目</h1><blockquote><p>leetcode <a href="https://leetcode.cn/problems/n-th-tribonacci-number/">1137. 第 N 个泰波那契数</a></p></blockquote><p>泰波那契序列 Tn 定义如下： </p><p>T0 &#x3D; 0, T1 &#x3D; 1, T2 &#x3D; 1, 且在 n &gt;&#x3D; 0 的条件下 <code>Tn+3 = Tn + Tn+1 + Tn+2</code></p><p>给你整数 <code>n</code>，请返回第 n 个泰波那契数 Tn 的值。</p><p>需要注意的是，这里的不是我们常用的斐波那契数列，哪个是 <code>Tn = Tn-1 + Tn-2</code>，而这里是三个；</p><h1 id="2-动归解法"><a href="#2-动归解法" class="headerlink" title="2.动归解法"></a>2.动归解法</h1><p>动态递归的思路是需要找到一个递归方程，本题中的递归方程已经给出来了。但是需要注意的是，当n小于3的时候，这个递归方程是不可用的（因为我们没有办法计算T<sub>负数</sub>的值）</p><h2 id="2-1-解法1-递归"><a href="#2-1-解法1-递归" class="headerlink" title="2.1 解法1-递归"></a>2.1 解法1-递归</h2><p>如下是我的第一个解法，通过递归函数计算数值，并提前写入0、1、2这三个数值到数组里面。</p><p>如果数组里面有值，直接取出来，如果没有值，在计算了之后再赋值到数组里面。这样就能保证在整个递归流程中，相同下标处的数据只会被计算一次（不这么做会超时）</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> DEF -1 <span class="comment">//默认值</span></span></span><br><span class="line">    <span class="comment">// 直接用递归会超时</span></span><br><span class="line">    <span class="comment">// 想法是将数据存到vector里面，避免针对某一个数的二次递归运算</span></span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> <span class="title function_">fib</span><span class="params">(<span class="type">int</span> n,<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;&amp; _map)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(_map[n] != DEF)&#123;</span><br><span class="line">            <span class="keyword">return</span> _map[n];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> ans = fib(n<span class="number">-1</span>,_map) + fib(n<span class="number">-2</span>,_map)+fib(n<span class="number">-3</span>,_map);</span><br><span class="line">        _map[n] = ans;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="title function_">tribonacci</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt; _map(<span class="number">40</span>,DEF);</span><br><span class="line">        _map[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        _map[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">        _map[<span class="number">2</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 初始化并传引用给递归函数</span></span><br><span class="line">        <span class="keyword">return</span> fib(n,_map);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>使用该方法的通过率如图</p><p><img src="https://img.musnow.top/i/2023/08/6da34c2bc594bf2893b2b0edaee08c21.png" alt="image-20230827172927657"></p><h2 id="2-2-方法2-迭代"><a href="#2-2-方法2-迭代" class="headerlink" title="2.2 方法2-迭代"></a>2.2 方法2-迭代</h2><p>还是相同的思路，只不过这次我们不用递归，而是用迭代来计算出数组里面对应下标的值，最后再返回给用户</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">tribonacci</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(n&lt;=<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> n;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt; _map(n+<span class="number">1</span>,DEF);</span><br><span class="line">    _map[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    _map[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    _map[<span class="number">2</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">3</span>;i&lt;_map.size();i++)&#123;</span><br><span class="line">        _map[i] = _map[i<span class="number">-3</span>] +_map[i<span class="number">-2</span>]+_map[i<span class="number">-1</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> _map[n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该办法的通过率如图，时间复杂度和空间复杂度都是<code>O(N)</code></p><p><img src="https://img.musnow.top/i/2023/08/eddf5511ea8346939633d018000e406f.png" alt="image-20230827173201195"></p><h2 id="2-3-迭代-变量"><a href="#2-3-迭代-变量" class="headerlink" title="2.3 迭代+变量"></a>2.3 迭代+变量</h2><p>既然在计算的时候我们只需要用到当前数据和该数据之前的3个变量，所以我们完全可以用固定的几个变量来实现这个操作，每次计算之后，都对变量进行一次轮换就ok了，官方的题解就是这么操作的</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">tribonacci</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (n &lt;= <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> p = <span class="number">0</span>, q = <span class="number">0</span>, r = <span class="number">1</span>, s = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">3</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        p = q;</span><br><span class="line">        q = r;</span><br><span class="line">        r = s;</span><br><span class="line">        s = p + q + r;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样操作，时间复杂度还是O(N)，但是空间复杂度就降到O(1)了！</p><p><img src="https://img.musnow.top/i/2023/08/0681a6444a756d58fe395a2202b0ce18.png" alt="image-20230827173339364"></p><h1 id="3-矩阵计算"><a href="#3-矩阵计算" class="headerlink" title="3.矩阵计算"></a>3.矩阵计算</h1><p>如果不用递归，还可以用矩阵乘法运算，该方法的时间复杂度是<code>O(LogN)</code></p><p><a href="https://leetcode.cn/problems/n-th-tribonacci-number/solutions/921898/di-n-ge-tai-bo-na-qi-shu-by-leetcode-sol-kn16/">https://leetcode.cn/problems/n-th-tribonacci-number/solutions/921898/di-n-ge-tai-bo-na-qi-shu-by-leetcode-sol-kn16/</a></p><p><img src="https://img.musnow.top/i/2023/08/a0431301252e331d1d2e9ac952358063.png" alt="image-20230827173653674"></p><p>奈何本人线代知识忘记了，完全看不懂</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">public:</span><br><span class="line">    <span class="type">int</span> <span class="title function_">tribonacci</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (n &lt;= <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="type">long</span>&gt;&gt; q = &#123;&#123;<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>&#125;, &#123;<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>&#125;, &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>&#125;&#125;;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="type">long</span>&gt;&gt; res = <span class="built_in">pow</span>(q, n);</span><br><span class="line">        <span class="keyword">return</span> res[<span class="number">0</span>][<span class="number">2</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="type">long</span>&gt;&gt; <span class="built_in">pow</span>(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="type">long</span>&gt;&gt;&amp; a, <span class="type">long</span> n) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="type">long</span>&gt;&gt; ret = &#123;&#123;<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>&#125;, &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>&#125;&#125;;</span><br><span class="line">        <span class="keyword">while</span> (n &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((n &amp; <span class="number">1</span>) == <span class="number">1</span>) &#123;</span><br><span class="line">                ret = multiply(ret, a);</span><br><span class="line">            &#125;</span><br><span class="line">            n &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">            a = multiply(a, a);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="type">long</span>&gt;&gt; multiply(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="type">long</span>&gt;&gt;&amp; a, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="type">long</span>&gt;&gt;&amp; b) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="type">long</span>&gt;&gt; c(<span class="number">3</span>, <span class="built_in">vector</span>&lt;<span class="type">long</span>&gt;(<span class="number">3</span>));</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">3</span>; j++) &#123;</span><br><span class="line">                c[i][j] = a[i][<span class="number">0</span>] * b[<span class="number">0</span>][j] + a[i][<span class="number">1</span>] * b[<span class="number">1</span>][j] + a[i][<span class="number">2</span>] * b[<span class="number">2</span>][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> c;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>测了一下效果，好像效率和使用2.3的办法没啥区别，那我还是用动归吧😭</p><p><img src="https://img.musnow.top/i/2023/08/858eede4f1ef9c10b2eb69f2150eae9d.png" alt="image-20230827173941225"></p><p>以后有时间了再来纠结这个答案的思路</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;今天是学习动归的第一天，先来一道简单题练练手吧！&lt;/p&gt;
&lt;h1 id=&quot;1-题目&quot;&gt;&lt;a href=&quot;#1-题目&quot; class=&quot;headerlink&quot; title=&quot;1.题目&quot;&gt;&lt;/a&gt;1.题目&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;leetcode &lt;a href=</summary>
      
    
    
    
    <category term="把题目都给刷干净" scheme="https://blog.musnow.top/categories/%E6%8A%8A%E9%A2%98%E7%9B%AE%E9%83%BD%E7%BB%99%E5%88%B7%E5%B9%B2%E5%87%80/"/>
    
    
    <category term="C++" scheme="https://blog.musnow.top/tags/C/"/>
    
    <category term="OJ刷题" scheme="https://blog.musnow.top/tags/OJ%E5%88%B7%E9%A2%98/"/>
    
    <category term="leetcode" scheme="https://blog.musnow.top/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>【网络】CDN/PCDN/SDN详解</title>
    <link href="https://blog.musnow.top/posts/292924834/"/>
    <id>https://blog.musnow.top/posts/292924834/</id>
    <published>2023-08-27T02:49:28.000Z</published>
    <updated>2023-08-27T02:49:28.000Z</updated>
    
    <content type="html"><![CDATA[<p>朴实的学习原因：京东实习生招聘条目上写了这些技术，那就给他学了！</p><span id="more"></span><blockquote><p>参考<br><a href="https://blog.csdn.net/baidu_41651554/article/details/122218513">https://blog.csdn.net/baidu_41651554/article/details/122218513</a></p></blockquote><p>嗨嗨嗨，直接上菜！</p><h1 id="1-CDN"><a href="#1-CDN" class="headerlink" title="1.CDN"></a>1.CDN</h1><p>CDN的全程是content delivery network，内容分发网络；说人话就是把网站产生的内容分发到各个用户请求的网络里去，具有 <strong>分布式</strong> 网络的特点！</p><h2 id="1-1-前置声明"><a href="#1-1-前置声明" class="headerlink" title="1.1 前置声明"></a>1.1 前置声明</h2><p>当代网络形势错综复杂，特别是视频、音频类网络服务的兴起，给互联网的贷款造成了很大的压力啊！</p><p>以之前很火的“延禧攻略”为例，当时曾经在某视频APP实现了1千万用户同时在线观看。如果大家观看的是1080p清晰度的视频（理论上需要4Mbps带宽），那么，累计需要的流量带宽是<br>$$<br>10,000,000×4Mbps&#x3D;40,000,000Mbps&#x3D;40Tbps<br>$$<br>这个数字老恐怖了！对于优酷、爱奇艺这样的互联网视频内容提供商来说，这无疑是非常巨大的流量压力。</p><p>如果按服务器用的10Gbps的万兆网卡来算，那也需要四千块万兆网卡才能顶得住这么大的流量消耗，更别提压根没有那么多地方给你插这么多网卡的事情了；</p><p>有这么一个说法：当用户打开一个页面，等待超过4秒，他就会关闭这个页面。也就是说，这个用户就会流失。用户流失对于公司来说可就是金钱流失！</p><p>所以，没有任何一家互联网服务提供商原因因为网络的问题而流失客户，那么我们就得像个办法来解决这种流量短时间暴发的问题！</p><p>而CDN，就是一项非常有效的<strong>缩短时延</strong>的技术。</p><h2 id="1-2-技术主体"><a href="#1-2-技术主体" class="headerlink" title="1.2 技术主体"></a>1.2 技术主体</h2><p>CDN缩短用户延时的办法也非常“简单”，其实就是将云服务部署到用户身边。在访问的时候，根据DNS的多线解析能力（即为不同地区提供不同的IP解析）选择离用户最近的服务器来为用户提供服务。</p><p><img src="https://img.musnow.top/i/2023/08/1298b6b472d89a0007ac82fb213b1aeb.png" alt="image-20230827105913951"></p><p>因为这样，CDN就在内容层面上进行了一定的筛选和分发，所以他就叫内容分发网络；</p><p>具体来说，CDN就是采用更多的缓存服务器（CDN边缘节点），布放在用户访问相对集中的地区或网络中。当用户访问网站时，利用全局负载技术，将用户的访问指向距离最近的缓存服务器上，由缓存服务器响应用户请求。（有点像电商的本地仓）</p><p>大家可能觉得，这个不就是“镜像服务器”嘛？其实不一样。镜像服务器是源内容服务器的完整复制。而CDN，是部分内容的缓存，智能程度更高。</p><p>确切地说，<strong>CDN&#x3D;更智能的镜像+缓存+流量导流</strong></p><p>而且还需要注意的是，CDN并不是只能缓存视频内容，它还可以对网站的静态资源（例如各类型图片、html、css、js等）进行分发，对移动应用APP的静态内容（例如安装包apk文件、APP内的图片视频等）进行分发。</p><p>CDN的具体工作流程。举个例子，如果某个用户想要访问优酷的视频点播内容，那么：</p><p><img src="https://img.musnow.top/i/2023/08/8ad3d099d1138c6b02472adeb5a2097c.png" alt="img"></p><p>具体步骤如下</p><ol><li>当用户点击对应资源内容，应用根据域名地址到底层触发DNS请求；</li><li>先是请求的本地运营商的DNS，再转发到CDN域名服务的DNS；</li><li>CDN域名服务的DNS会将CDN的<strong>全局均衡负载服务器</strong>的IP地址返回给用户；</li><li>用户向CDN的负载均衡设备发起URL的访问请求；</li><li>CDN的负载均衡设备根据用户IP地址，以及用户请求的内容URL，选择一台用户所属区域（离用户越近越好）的<strong>缓存服务器</strong>；</li><li>负载均衡设备告诉用户这台缓存服务器的IP地址，让用户向所选择的缓存服务器发起请求；</li><li>用户向缓存服务器发起请求，缓存服务器响应，将用户请求内容发送给用户</li><li>如果这台服务器上没有用户想要的内容，那就根据CDN设置的<strong>回源服务器</strong>（又称源站）来请求该URL</li><li>缓存服务器从<strong>源站</strong>拉取内容缓存到本地，并传输给用户；并根据用户设置的缓存策略来判断是否需要保留该资源到本地，是则进行缓存。</li></ol><p>在CDN工作的整个流程中，源站的服务器IP是对用户不可见的；CDN服务在实现了一定的资源访问加速的基础上，还附带了隐藏源站IP的功能，避免源站直接遭受火力打击（指服务器被攻击）</p><h2 id="1-3-静态加速"><a href="#1-3-静态加速" class="headerlink" title="1.3 静态加速"></a>1.3 静态加速</h2><p>所谓静态加速，是只加速源站所提供服务中的静态资源，包括js、html、css、图片、音视频等不会出现变动的资源文件。将这些资源在CDN云服务器内进行缓存，用户访问静态资源的时候从CDN传输给用户，访问asp、php、jsp等动态资源的时候，从源站抓取，既保证了数据的及时性，又提高了静态资源的加载速度。</p><p>相比于动态资源文件，静态资源，特别是图片，是访问过程中消耗流量较大的部分；使用静态资源加速能大大减轻源站的网络贷款和资源负载的压力，又减少了用户的加载速度，使得网络服务能更快的展现在用户面前；</p><h2 id="1-4-动态加速"><a href="#1-4-动态加速" class="headerlink" title="1.4 动态加速"></a>1.4 动态加速</h2><p>动态加速是指CDN的DNS解析中通过动态链路探测，监控网络环境的变化，监控各地网络延迟，寻找到一条最<strong>稳定、最高效、最快速</strong>的路径，回源动态资源，从而实现动态资源（如asp、php、jsp等）加速。然后构成链路列表，绑定到DNS解析上，更新到CDN的本地域名服务器上。简单架构见下图所示。</p><p><img src="https://img.musnow.top/i/2023/08/9b51e87fe04bacbd8591b55e5d62f679.png" alt="img"></p><h2 id="1-5-数据节点的更新和同步"><a href="#1-5-数据节点的更新和同步" class="headerlink" title="1.5 数据节点的更新和同步"></a>1.5 数据节点的更新和同步</h2><p>cdn分为推拉两种方式</p><ul><li>推是服务器将内容推到cdn节点上</li><li>拉是cdn在第一次接受请求的时候从服务器拉取资源进行响应并保存</li></ul><p>当资源在cdn缓存之后，如果服务器上的资源发生变化，cdn节点是不会知道的，除非缓存时间到期重新拉取或者修改新资源的访问。</p><p>动态资源的话，一般都是无延迟的。静态对于 css 和 js 来说，建议在编译生成的阶段，为文件名加上时间戳。而且最好是在文件名里面，而不是 querystring 里面加。这是最方便的方案，因为一旦发生了更新，每次去取的一定是新文件，不涉及缓存刷新的问题。</p><h2 id="1-6-CDN的好处"><a href="#1-6-CDN的好处" class="headerlink" title="1.6 CDN的好处"></a>1.6 CDN的好处</h2><h3 id="1-6-1-对服务商"><a href="#1-6-1-对服务商" class="headerlink" title="1.6.1 对服务商"></a>1.6.1 对服务商</h3><p>采用CDN技术，最大的好处，就是加速了网站的访问——用户与内容之间的物理距离缩短，用户的等待时间也得以缩短。</p><p>而且，分发至不同线路的缓存服务器，也让<strong>跨运营商</strong>之间的访问得以加速。例如中国移动手机用户访问中国电信网络的内容源，可以通过在中国移动假设CDN服务器，进行加速。效果是非常明显的。</p><p>此外，CDN还有安全方面的好处。内容进行分发后，<strong>源服务器的IP被隐藏</strong>，受到攻击的概率会大幅下降。而且，当某个服务器故障时，系统会调用临近的健康服务器，进行服务，避免对用户造成影响。</p><p>正因为CDN的好处很多，所以，目前所有主流的互联网服务提供商，都采用了CDN技术。所有的云服务提供商，也都提供了CDN服务（价格，按流量计费）</p><h3 id="1-6-2-对通信行业"><a href="#1-6-2-对通信行业" class="headerlink" title="1.6.2 对通信行业"></a>1.6.2 对通信行业</h3><ul><li><strong>互联网服务提供商</strong>采用CDN，是以存储换时延。花钱购置CDN服务器或云计算服务，以此换取更好的用户体验。</li><li><strong>通信运营商</strong>也追捧CDN，但它们的目的，是以存储换带宽 ——通过服务“下沉”，减轻上层骨干网络的流量压力，避免硬件扩容，降低网络建设成本。</li></ul><p>以上文提到的爱奇艺看视频的高带宽问题为例，如果不采用CDN，那就是巨大的流量流入同一个机房，这会导致这个机房入网&#x2F;出网的线路被拥塞，影响其他业务的进行！</p><p>同样的，如果大量的业务流量数据在骨干网跑来跑去，<strong>骨干网肯定吃不消，要拼命扩容</strong>。如果这些业务流量数据在底层就被解决了，那么，骨干网的带宽压力自然就减轻了。</p><p>很多运营商已经将CDN下沉到地市级，以此减轻压力，同时可以提升用户体验！可谓是一举两得的美事！</p><p><img src="https://img.musnow.top/i/2023/08/9806e61f7d240e45b2701d25668935e7.png" alt="img"></p><h1 id="2-PCDN"><a href="#2-PCDN" class="headerlink" title="2.PCDN"></a>2.PCDN</h1><p>PCDN技术是P2P技术+CDN技术的集和，在认识PCDN之前，我们首先要简单了解一下P2P技术</p><h2 id="2-1-P2P"><a href="#2-1-P2P" class="headerlink" title="2.1 P2P"></a>2.1 P2P</h2><p>P2P即<code>Peer to Peer</code>，是一种对等连接方式，纯P2P架构包含如下内容</p><ul><li>没有总是在线的服务器</li><li>任意端之间直接通信</li><li>对等方之间可以间断链接，并可以动态改变IP地址</li></ul><p>实际的用例如下</p><ul><li>文件分发（BT下载）</li><li>流媒体</li><li>VolP</li><li>内网穿透式访问（建立P2P链接，直接和内网主机通信）</li></ul><p><img src="https://img.musnow.top/i/2023/08/ebc51e20db9f5b31b0067fead78826ae.png" alt="image"></p><p>关于P2P想了解更多信息可以查看此文：<a href="https://cloud.tencent.com/developer/article/2095486">详解P2P技术</a></p><h2 id="2-2-PCDN"><a href="#2-2-PCDN" class="headerlink" title="2.2 PCDN"></a>2.2 PCDN</h2><h3 id="2-2-1-流程"><a href="#2-2-1-流程" class="headerlink" title="2.2.1 流程"></a>2.2.1 流程</h3><p>前面提到了，PCDN是P2P+CDN，那么其是如何将P2P技术和CDN结合起来的呢？</p><p>在阿里云官网上可以看到对PCDN的介绍：<a href="https://developer.aliyun.com/article/130907">一篇文章解读提速、降费黑科技：PCDN定义、功能、架构、场景和优势</a>；本文是对这篇文章的个人理解。</p><blockquote><p>PCDN产品是与传统CDN互补协作的关系，以P2P技术为核心的分布式PCDN系统可与传统CDN、云CDN无缝集成，形成互补协作，相对于CDN拥有成本更低、质量更好两方面的核心优势。</p></blockquote><p>P2P 内容分发网络（英文名：P2P CDN，以下简称PCDN）是以P2P技术为基础，通过挖掘利用边缘网络海量碎片化闲置资源而构建的低成本高品质内容分发网络服务。你可以通过集成PCDN SDK（以下简称SDK）接入该服务后能获得等同（或略高于）CDN的分发质量，同时显著降低分发成本。适用于<strong>视频点播、直播、大文件下载</strong>等业务场景。</p><p>使用PCDN后的http请求处理流程如下图：</p><p><img src="https://img.musnow.top/i/2023/08/d2bba1440e3c9b80ec949459fd8617a8.png" alt="image-20230827133437729"></p><p>P2P的加入，就是将一些数据<strong>预先留存在部分终端设备</strong>（比如家用路由器，个人电脑，个人NAS）等产品上，再通过P2P技术，从这些Peer做种端获取到一部分数据，以此为周边用户提供服务。</p><p>使用PCDN的SDK后，在请求DNS之后，还会去请求<strong>PCDN的调度系统</strong>，PCDN同时会返回可用的CDN服务器，和可用的P2P做种端，用户能同时从<strong>多端</strong>获取到数据（根据文件分块，从不同地方获取同一文件不同分块的数据，提高文件下载速度）</p><p>比如一个文件有1MB，那么使用PCDN，我们可能服务商的从<strong>CDN服务器</strong>拉取了500KB，再从上图中所示的两个peerid端获取到了500KB数据；</p><p>因为p2p使用的是个人的peer终端节点，不仅数量多，<strong>且分布比CDN服务器更广</strong>，理论上来说至少能获得<strong>等同于</strong>仅使用CDN技术的速度优势，如果用户可以连接到的peer较多，则速度就会<strong>大于</strong>仅使用CDN技术！</p><p>而这些作为peer的做种端，会定期从CDN缓存一部分热门数据到本地，并为其他与自己建立P2P链接的终端提供服务。</p><blockquote><p>京东云路由器、迅雷的网心云、百度云盘PC客户端的闲时带宽上传，其实都是使用了PCDN技术的终端产品，其会在占用一小部分用户带宽的基础上，给用户提供京豆&#x2F;现金奖励；<br>但是PCDN似乎和运营商的政策冲突，具体的就不了解了，本文只是来学习技术的。</p></blockquote><h3 id="2-2-2-优点"><a href="#2-2-2-优点" class="headerlink" title="2.2.2 优点"></a>2.2.2 优点</h3><p>以下优点来自阿里云那篇文章</p><ul><li><p>价格低：通过P2P技术可为客户提供更低成本的内容分发服务，（以峰值带宽计价）为云CDN价格的1&#x2F;2，为传统CDN价格的1&#x2F;4，可显著降低客户的分发成本；</p><p>因为使用了更多P2P节点，减轻了CDN服务器、源站服务器的网络带宽压力，所以PCDN能在一定程度上起到降本增效的作用。</p></li><li><p>质量好：通过CDN+P2P多级节点调度，一个请求可由CDN和多个P2P源同时提供内容，通过资源冗余提高了服务可用性，播放流畅率高于纯CDN，在大文件下载场景中更是能极大提高下载速度；通过调用海量分布式P2P节点， 平均播放流畅率 &gt; 97%，平均首播时间小于1秒，用户体验得到有效提升。</p></li><li><p>成熟稳定：多年为优酷土豆提供优质的视频播放、下载等加速服务，接入带宽超10T，经历了海量用户规模的<strong>长时间验证</strong>。拥有内网穿透、缓存处理、种子管理、传输策略等各方面的核心技术和专利；（这是阿里云给自己打的广告）</p></li></ul><p><img src="https://img.musnow.top/i/2023/08/16fb75b6c4dae42f968da0e5510cd069.png" alt="image-20230827135320425"></p><h2 id="2-3-常见名词"><a href="#2-3-常见名词" class="headerlink" title="2.3 常见名词"></a>2.3 常见名词</h2><p>以下是PCDN中常见的名词；这里面漏了的一级节点指的应该是CDN服务器；</p><p><img src="https://img.musnow.top/i/2023/08/121f5a17dd247d2ba0cd17676bf53139.png" alt="image-20230827134515066"></p><p>由此可见，上文提到的京东云路由器、迅雷的网心云，这些客户端在用户的电脑启动后，其就是作为PCDN的<strong>三级节点</strong>接入整个PCDN的网络的，其提供的也是三级带宽；</p><h2 id="2-4-基础架构"><a href="#2-4-基础架构" class="headerlink" title="2.4 基础架构"></a>2.4 基础架构</h2><p>关键组件</p><ul><li>index服务：全局调度，把用户请求调度到最佳的机房</li><li>ZooKeeper (Global&amp;Local)：服务活动情况汇报给调度服务，动态配置更新</li><li>Nignx Proxy：支持私有协议的Nginx代理服务，针对不同文件一致性Hash到不同的Channel服务</li><li>Channel服务：记录文件和拥有文件的端点地址信息，为下载提供就近的端点地址</li><li>Realy服务：服务P2P建立连接和通讯</li><li>Hot服务：hot文件发现和推送</li></ul><p>以下是PCDN技术的架构图</p><p><img src="https://img.musnow.top/i/2023/08/459dd3bd580e337a248093066360ca91.png" alt="image-20230827135429913"></p><p>整个技术的流程在上文已经讲解过了。这里的架构图阿里云的文章并没有提供更多的说明，具体的就得在真正需要开发PCDN的时候在公司内部深入学习了。</p><h2 id="2-5-适用范围"><a href="#2-5-适用范围" class="headerlink" title="2.5 适用范围"></a>2.5 适用范围</h2><p>PCDN产品适用于视频点播、直播、大文件下载等业务领域。</p><ul><li>视频点播：长视频点播，热度集中的短视频点播。</li><li>视频直播：大型晚会赛事直播、地方网台直播、秀场互动直播。</li><li>大文件下载：超过1MB且热度集中的的文件分发，如应用市场分发、在线音频分发。</li></ul><h1 id="3-SDN"><a href="#3-SDN" class="headerlink" title="3.SDN"></a>3.SDN</h1><p>SDN全称<code>Software Defined Network</code>，概念最早由斯坦福大学的<code>Nick McKeown</code>教授于2009年提出；谷歌于2010到2012年建立的数据中心网络B4是SDN的成功案例；</p><p>该技术学习于b站<a href="https://www.bilibili.com/video/BV15L411E7eE/?share_source=copy_web&vd_source=7fc715db968d24a91828ac8fad0e1ad8">【408 计算机网络新增考点—软件定义网络SDN（字幕版）】</a></p><h2 id="3-1-看看路由器的功能"><a href="#3-1-看看路由器的功能" class="headerlink" title="3.1 看看路由器的功能"></a>3.1 看看路由器的功能</h2><p>路由器具备如下功能</p><ul><li>报文转发</li><li>路由选择</li></ul><p>在当前的路由器架构中，分为数据层面和控制层面。</p><ul><li>为了构建出自己的路由表，路由器必须要和周边的其他路由器定期通信，才能通过自己的路由算法设置出路由表，并选择正确的路由路径（这个耗时较长）</li><li>在数据层面，路由器采用硬件，查表进行转发（耗时低）</li></ul><p><img src="https://img.musnow.top/i/2023/08/f7ec770dd37e6f4a19c73cd9133cdf90.png" alt="image-20230827143545493"></p><blockquote><p><strong>分组</strong>是网络专有名词。大多数<a href="https://baike.baidu.com/item/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/18763?fromModule=lemma_inlink">计算机网络</a>都不能连续地传送任意长的数据，所以实际上网络系统把<a href="https://baike.baidu.com/item/%E6%95%B0%E6%8D%AE%E5%88%86%E5%89%B2/4395664?fromModule=lemma_inlink">数据分割</a>成小块，然后逐块地发送，这种小块就称作分组（packet）。也有些书籍把分组定义为网络层的<a href="https://baike.baidu.com/item/%E5%8D%8F%E8%AE%AE%E6%95%B0%E6%8D%AE%E5%8D%95%E5%85%83/8226389?fromModule=lemma_inlink">协议数据单元</a>。</p><p>说白了分组就是一个报文！</p></blockquote><h2 id="3-2-SDN核心思想"><a href="#3-2-SDN核心思想" class="headerlink" title="3.2 SDN核心思想"></a>3.2 SDN核心思想</h2><blockquote><p>SDN这种新型<strong>网络体系结构</strong>的核心思想，是将网络的控制层和数据层面玻璃，让控制层可以通过软件来控制数据层的较多设备</p></blockquote><p>在SDN体系中，路由器的路由软件被剥离开，路由器之间也不再需要交换路由信息。</p><ul><li>控制层面：有一个逻辑上集中的远程控制器，对多个交换机进行控制；该远程控制器可以由多台物理主机组成</li></ul><p>远程控制器会掌握各个主机和整个网络体系的状态，并为每一个路由分组计算出最佳的路由，和生成正确的转发表；这时候，底层的路由器硬件就仅仅需要进行查表转发，而不需要进行耗时的路由表生产和算法计算了，大大减轻了底层交换机和路由器硬件的压力。</p><p><img src="https://img.musnow.top/i/2023/08/feb23bbf0d7ea8acff297ff8111488fa.png" alt="image-20230827145453526"></p><h2 id="3-3-OpenFlow协议"><a href="#3-3-OpenFlow协议" class="headerlink" title="3.3 OpenFlow协议"></a>3.3 OpenFlow协议</h2><p>OpenFlow协议是一个受到高度认可的标准，其一般在SDN中进行使用，但SDN并不一定要用OpenFlow；</p><blockquote><p>OpenFlow协议由<strong>开放网络基金会ONF</strong>负责指定，该基金会致力于SDN的发展和标准化；OpenFlow协议目前较为成熟的是1.3版本</p></blockquote><p>OpenFlow协议是SDN体系结构中，控制层面和数据层面之间的通信接口，该协议可以允许控制层面的控制器对数据层面的物理设备进行直接的访问和控制。</p><p><img src="https://img.musnow.top/i/2023/08/0c9a0b49911c437a7d31a4090004fa1a.png" alt="image-20230827145816552"></p><h2 id="3-4-路由转发的区别"><a href="#3-4-路由转发的区别" class="headerlink" title="3.4 路由转发的区别"></a>3.4 路由转发的区别</h2><h3 id="3-4-1-传统路由表"><a href="#3-4-1-传统路由表" class="headerlink" title="3.4.1 传统路由表"></a>3.4.1 传统路由表</h3><p>传统的路由转发是查询路由表，根据地址掩码计算目的网络，判断是否与当前条目匹配，如果匹配，则从对应的「下一条」中发送出去。</p><p>路由转发这部分内容在我的IP协议详解博客中有所涉及：<a href="https://blog.musnow.top/posts/3482559497/">点我</a></p><p><img src="https://img.musnow.top/i/2023/08/e154eeaf46fb0ce68d4ca6c6ea946920.png" alt="image-20230827150215508"></p><h3 id="3-4-2-SDN广义转发"><a href="#3-4-2-SDN广义转发" class="headerlink" title="3.4.2 SDN广义转发"></a>3.4.2 SDN广义转发</h3><p>SDN在这基础上新增了更多的内容，称为<strong>广义转发</strong>：</p><ol><li>进行匹配：能够对网络体系结构中的各层（数据链路层，网络层，传输层）首部中的字段进行匹配</li><li>执行动作：不仅转发分组，还可以实现负载均衡、重写IP首部（类似NAT中的路由地址转换）、人为阻挡或丢弃一些分组（类似防火墙）</li></ol><p>在SDN广义转发中，完成这一操作的设备不再称为路由器，而是叫做OpenFlow交换机（或分组交换机），也可以简称为交换机。</p><h3 id="3-4-3-流表"><a href="#3-4-3-流表" class="headerlink" title="3.4.3 流表"></a>3.4.3 流表</h3><p>在SDN中替代 了传统路由表的是「流表（Flow Table）」</p><ul><li>一个流就是整个网络中的一组分组序列，在此序列中的每个分组都是<code>共享分组首部某些字段的值</code>，例如，某个流可以是共享相同的源IP和目的IP地址的一连串分组</li><li>OpenFlow交换机中的刘表是由SDN远程控制器来管理的，SDN远程控制器通过一个安全信道，通过OpenFlow协议来管理OpenFlow交换机中的流表</li></ul><p><img src="https://img.musnow.top/i/2023/08/da25636e91b2ab521809adc0d568a7d4.png" alt="image-20230827150934738"></p><ul><li>每个OpenFlow交换机必须有一个或者多个流表</li><li>每一个流表包含多个流表项目</li><li>每个流表项包含三个字段：首部字段值（匹配字段）、计数器、动作（类似下一跳）</li></ul><p>OpenFlow的首部字段值跨越了三个层次的首部，既可以处理数据链路层的MAC帧，又可以处理IP报文，或者是TCP&#x2F;UDP的端口</p><p><img src="https://img.musnow.top/i/2023/08/fa579c04d7c630a4b94a6158c1b0d384.png" alt="image-20230827151212669"></p><p>计数器字段包含一组计数器</p><ul><li>记录已经与该流表项匹配的分组数量的计数器；</li><li>记录该流表项上次更新到现在经历的时间的计数器</li></ul><p>动作字段是一族动作，当分组匹配到某个流表项时，执行下方的一个或者多个动作</p><ul><li>把分组转发到指定的端口</li><li>丢弃分组</li><li>把分组进行复制后，从多个端口转发出去</li><li>重写分组中的首部字段</li></ul><h3 id="3-4-4-VLAN"><a href="#3-4-4-VLAN" class="headerlink" title="3.4.4 VLAN"></a>3.4.4 VLAN</h3><blockquote><p>关于该报文中VLAN部分可以查看此博客：<a href="https://blog.csdn.net/LawssssCat/article/details/127204720">https://blog.csdn.net/LawssssCat/article/details/127204720</a></p></blockquote><p>VLAN是一种用于进一步虚拟化划分局域网的方式，假如一台路由器有4个网口，其可以通过将LAN1和LAN2设置成VLAN10，LAN3和LAN4设置成VLAN20来模拟出两个局域网</p><p><img src="https://img.musnow.top/i/2023/08/8cfceb7090ae21914683d034f680f485.png" alt="image-20230827153454860"></p><p>vlan（virtual lan）技术提供了一种灵活的解决方案；将交换机的接口根据业务需要添加到不同的vlan中，从而实现二层隔离。</p><ul><li>隔离广播域，即广播包只在本 vlan 中传播，从而在一定程度上可以提高整个网络的处理能力；</li><li>提高安全性，一个 vlan 内的用户和其他 vlan 内的用户不能互访，提高了网络的安全性；</li><li>增加带宽利用&#x2F;降低延迟&#x2F;管理作用</li></ul><h2 id="3-5-举例"><a href="#3-5-举例" class="headerlink" title="3.5 举例"></a>3.5 举例</h2><h3 id="3-5-1-简单转发"><a href="#3-5-1-简单转发" class="headerlink" title="3.5.1 简单转发"></a>3.5.1 简单转发</h3><p>通过不同的流表项来设置转发路径和转发动作，动作中的<code>转发(3)</code>代表从该交换机的3号端口转发出去。端口号在图中有标注；</p><p><img src="https://img.musnow.top/i/2023/08/6faaa19507feedb4784efd2c5a5ac376.png" alt="image-20230827151650945"></p><h3 id="3-5-2-负载均衡"><a href="#3-5-2-负载均衡" class="headerlink" title="3.5.2 负载均衡"></a>3.5.2 负载均衡</h3><p>第二个栗子是负载均衡的栗子，在下面的场景中，我们想要H3发送的分组通过<code>S2-S1-S3-H5/H6</code>，要H4发送的分组通过<code>S2-S3-H5/H6</code>；以达到负载均衡的目的。</p><p><img src="https://img.musnow.top/i/2023/08/5f152f13954536e40cb1b6b815f0c9ad.png" alt="image-20230827151718483"></p><p>使用传统的源IP和目的IP的转发方式，无法实现这样的负载均衡。在传统场景下，当S2在数据链路层发现目的MAC地址是S3的MAC地址的时候，无论如何都会直接发送给S3，而不是从S1处绕路。</p><p>但在SDN场景中，就可以通过两个不同的流表项来规定不同转发动作，实现这样的负载均衡（这里的<code>转发(4)</code>代表从S2的4号端口转发出去）</p><p><img src="https://img.musnow.top/i/2023/08/2d076ac5eca2dc6f7480020f2e0fd57f.png" alt="image-20230827151948106"></p><h3 id="3-5-3-防火墙"><a href="#3-5-3-防火墙" class="headerlink" title="3.5.3 防火墙"></a>3.5.3 防火墙</h3><p>如果我们想让S2主机只接收来自S1的数据而不接受S3的数据，就可以通过只设置S1的源IP地址的流表项，来丢弃S3发送的数据（匹配不上的数据就会被丢弃）</p><p><img src="https://img.musnow.top/i/2023/08/f7be65147a7d7897ae6d4402ad2d8f26.png" alt="image-20230827152217555"></p><h2 id="3-6-SDN体系结构的特征"><a href="#3-6-SDN体系结构的特征" class="headerlink" title="3.6 SDN体系结构的特征"></a>3.6 SDN体系结构的特征</h2><p>下图中包含了SDN的体系结构一览图和SDN的四个关键特征</p><ol><li>基于流的转发</li><li>数据层面与控制层面分离</li><li>位于数据层面分组交换机之外的网络控制功能</li><li>可编程的网络</li></ol><p>其中，SDN控制器是这个架构中最复杂的设备，其通过南向API控制底层的OpenFlow交换机，通过北向API接受其他网络控制器的策略配置。</p><p><img src="https://img.musnow.top/i/2023/08/a6678beda5464d34757501e8cc95580e.png" alt="image-20230827152358531"></p><h3 id="3-6-1-SDN控制器"><a href="#3-6-1-SDN控制器" class="headerlink" title="3.6.1 SDN控制器"></a>3.6.1 SDN控制器</h3><p>SDN控制器可以分成三个层次</p><ul><li>其通信层通过OpenFlow协议与交换机通信</li><li>中间间来根据各种策略管理各个交换机</li><li>北向API接收来自其他控制策略发起端的配置</li></ul><p><img src="https://img.musnow.top/i/2023/08/46dc0f081cfa38af5ea0d3d89e0ccc68.png" alt="image-20230827152554869"></p><p>这里使用的<code>RESTful API </code>是基于HTTP的API，也是我们较常见的API接口；</p><h3 id="3-6-2-开源SDN控制器"><a href="#3-6-2-开源SDN控制器" class="headerlink" title="3.6.2 开源SDN控制器"></a>3.6.2 开源SDN控制器</h3><p>常用的开源SDN控制器有OPEN DAYLIGHT和ONOS；</p><h3 id="3-6-3-SDN的优势"><a href="#3-6-3-SDN的优势" class="headerlink" title="3.6.3 SDN的优势"></a>3.6.3 SDN的优势</h3><blockquote><p>原文链接：<a href="https://blog.csdn.net/as12138/article/details/131273381">https://blog.csdn.net/as12138/article/details/131273381</a></p></blockquote><p>SDN相比于传统网络架构，有许多优点和优势。</p><ol><li><p>高度可编程性：SDN架构中的控制器负责管理交换机和路由器，使得网络更加可编程、可配置。管理员可以通过控制器实现灵活调整网络拓扑、管理流量和配置流调度策略，提升网络的可演变性、可定制化和可伸缩性。</p></li><li><p>网络智能集中化：在SDN中，网络智能被集中在控制器中，通过控制器进行集中式管理和控制。这种分离的模式避免了网络设备中任务的复杂，提升了网络的可管理性和可控制性。此外，集中化的管理方式也可以在网络中间件和应用中实现智能控制，如分布式存储、云计算等。</p></li><li><p>可扩展性：SDN中的网络设备是通用的硬件设备，不需要特定的功能区分，同时也不需要更新硬件，只需更新控制器即可实现拓扑可伸缩和灵活的网络管理。</p></li><li><p>自动化和提高效率：SDN中可以实现网络的自动化，通过控制器进行自动化的网络管理，可以避免手动管理网络的局限性和不确定性，从而提高网络的效率和稳定性，同时，自动化网络管理也可以降低网络维护的成本和时间。</p></li><li><p>安全可靠性提升：网络安全和可靠性是企业网络中最基本的需求。传统的网络安全往往需要通过一些特定设备和协议来实现。相比之下，SDN中的控制器可以根据网络实时状态自动优化管理策略，安全可靠的方式来提高网络的安全性。</p></li></ol><p>总之，SDN的优势在于其灵活的可编程性、集中式智能管理、高效的自动化网络管理和增强网络安全性。以上优势也是SDN技术应用广泛的主要原因，越来越多的企业和组织将SDN技术应用到自己的网络架构中，以满足未来网络的需求和挑战。</p><h2 id="3-6-4-SDN应用前景"><a href="#3-6-4-SDN应用前景" class="headerlink" title="3.6.4 SDN应用前景"></a>3.6.4 SDN应用前景</h2><p>SDN技术目前已经实现了基础网络配置、流控制、网络安全等功能。在未来，SDN技术还会面临更多的挑战和机遇。</p><ol><li><p>5G时代：5G技术将会改变网络的面貌，加速物联网应用的普及。SDN作为架构灵活、可编程的网络方式，将会在5G网络中发挥重要作用，实现网络的自动化和智能化管理。</p></li><li><p>IoT设备：物联网技术带来大量设备的连接，SDN技术的价值在于自动化了物联网设备的管理、安全和监控。未来，SDN技术将会成为物联网管理的重要工具。</p></li><li><p>AI：随着人工智能的发展，SDN的业界应用已经开始大规模落地。这将加速智能交通、智能城市和自动驾驶等领域的发展。</p></li><li><p>集成新技术：SDN可以很容易地与其他技术相结合，例如NFV（网络功能虚拟化）和AI（人工智能），以提高网络的效率和适应性。</p></li><li><p>云计算：SDN技术的灵活性和可编程性，也使得SDN与云计算等新技术的结合变得更加自然。在未来，SDN技术将与云技术紧密结合，实现业务流程的自动化、快速应用部署和弹性云资源管理。</p></li></ol><p>总而言之，SDN技术将为未来网络的发展和实现各种应用提供支撑。在日益增长的网络需求和复杂的网络技术背景下，SDN的灵活性和高可用性将会带来更大的发展空间和市场需求。SDN技术应当继续研究和发展，以满足更多的网络需求和挑战。</p><h2 id="3-7-总结"><a href="#3-7-总结" class="headerlink" title="3.7 总结"></a>3.7 总结</h2><p><img src="https://img.musnow.top/i/2023/08/3a0e7fd1ff2494f51ec6121d4a60e108.png" alt="image-20230827152810972"></p>]]></content>
    
    
    <summary type="html">朴实的学习原因：京东实习生招聘条目上写了这些技术，那就给他学了！</summary>
    
    
    
    <category term="差生文具多" scheme="https://blog.musnow.top/categories/%E5%B7%AE%E7%94%9F%E6%96%87%E5%85%B7%E5%A4%9A/"/>
    
    
    <category term="CDN" scheme="https://blog.musnow.top/tags/CDN/"/>
    
    <category term="SDN" scheme="https://blog.musnow.top/tags/SDN/"/>
    
    <category term="P2P" scheme="https://blog.musnow.top/tags/P2P/"/>
    
  </entry>
  
</feed>
