<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>慕雪的寒舍</title>
  
  <subtitle>雪下了一夜</subtitle>
  <link href="https://blog.musnow.top/atom.xml" rel="self"/>
  
  <link href="https://blog.musnow.top/"/>
  <updated>2023-03-13T11:32:09.558Z</updated>
  <id>https://blog.musnow.top/</id>
  
  <author>
    <name>muxue</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>【C++】将浮点数每一位拆分并输出</title>
    <link href="https://blog.musnow.top/2023/03/13/oj/%E5%B0%86%E6%B5%AE%E7%82%B9%E6%95%B0%E6%AF%8F%E4%B8%80%E4%BD%8D%E6%8B%86%E5%88%86%E8%BE%93%E5%87%BA/"/>
    <id>https://blog.musnow.top/2023/03/13/oj/%E5%B0%86%E6%B5%AE%E7%82%B9%E6%95%B0%E6%AF%8F%E4%B8%80%E4%BD%8D%E6%8B%86%E5%88%86%E8%BE%93%E5%87%BA/</id>
    <published>2023-03-13T11:14:28.000Z</published>
    <updated>2023-03-13T11:32:09.558Z</updated>
    
    <content type="html"><![CDATA[<p>将浮点数每一位拆分并输出</p><span id="more"></span>]]></content>
    
    
    <summary type="html">&lt;p&gt;将浮点数每一位拆分并输出&lt;/p&gt;</summary>
    
    
    
    <category term="把题目都给刷干净" scheme="https://blog.musnow.top/categories/%E6%8A%8A%E9%A2%98%E7%9B%AE%E9%83%BD%E7%BB%99%E5%88%B7%E5%B9%B2%E5%87%80/"/>
    
    
    <category term="C++" scheme="https://blog.musnow.top/tags/C/"/>
    
    <category term="OJ刷题" scheme="https://blog.musnow.top/tags/OJ%E5%88%B7%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>【图】拓扑排序</title>
    <link href="https://blog.musnow.top/2023/03/12/data_structure/14%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F/"/>
    <id>https://blog.musnow.top/2023/03/12/data_structure/14%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F/</id>
    <published>2023-03-12T01:00:49.000Z</published>
    <updated>2023-03-12T01:13:27.604Z</updated>
    
    <content type="html"><![CDATA[<p>本文搬运自csdn</p><span id="more"></span><h3 id="文章目录"><a href="#文章目录" class="headerlink" title="文章目录"></a>文章目录</h3><ul><li><a href="#%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F">拓扑排序</a><ul><li><a href="#%E4%BB%80%E4%B9%88%E6%98%AF%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F">什么是拓扑排序？</a></li><li><a href="#%E6%80%8E%E4%B9%88%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F">怎么拓扑排序？</a></li><li><a href="#%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F%E5%AE%9E%E7%8E%B0">拓扑排序实现</a></li></ul></li><li><a href="#%E5%85%B3%E9%94%AE%E8%B7%AF%E5%BE%84">关键路径</a><ul><li><a href="#%E4%BB%80%E4%B9%88%E6%98%AF%E5%85%B3%E9%94%AE%E8%B7%AF%E5%BE%84">什么是关键路径？</a></li><li><a href="#%E6%80%8E%E4%B9%88%E6%B1%82%E5%85%B3%E9%94%AE%E8%B7%AF%E5%BE%84">怎么求关键路径？</a></li><li><a href="#%E5%85%B3%E9%94%AE%E8%B7%AF%E5%BE%84%E5%AE%9E%E7%8E%B0">关键路径实现</a></li><li><a href="#%E6%B1%82%E5%85%B3%E9%94%AE%E8%B7%AF%E5%BE%84%E8%BF%87%E7%A8%8B%E7%A4%BA%E4%BE%8B">求关键路径过程示例</a></li></ul></li></ul><h1 id="拓扑排序"><a href="#拓扑排序" class="headerlink" title="拓扑排序"></a><a class="link"   href="https://so.csdn.net/so/search?q=%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F&spm=1001.2101.3001.7020" >拓扑排序<i class="fas fa-external-link-alt"></i></a></h1><h2 id="什么是拓扑排序？"><a href="#什么是拓扑排序？" class="headerlink" title="什么是拓扑排序？"></a>什么是拓扑排序？</h2><p>  在图论中，<strong>拓扑排序</strong>是一个<strong>有向无环图</strong>的所有顶点的线性序列(获得拓扑有序序列)。且该序列必须满足下面两个条件：</p><ol><li>每个顶点出现且只出现一次。</li><li>若存在一条从顶点 A 到顶点 B 的路径，那么在序列中顶点 A 出现在顶点 B 的前面。</li></ol><p>有向无环图（DAG）才有拓扑排序，非DAG图没有拓扑排序一说。</p><p><img                       lazyload                     alt="image"                     data-src="https://img1.musnow.top/i/2023/03/640d23c77df53.png"                                     >  </p><h2 id="怎么拓扑排序？"><a href="#怎么拓扑排序？" class="headerlink" title="怎么拓扑排序？"></a>怎么拓扑排序？</h2><p><strong>拓扑排序步骤：</strong></p><ol><li>在有向图中选一个没有前驱的顶点且输出之。</li><li>从图中删除该顶点和所有以它为尾的弧。</li></ol><p>  重复上述两步，直至全部顶点均已输出，或者当前图中不存在无前驱的顶点为止。后一种情况则说明有向图中存在环。</p><p><img                       lazyload                     alt="image"                     data-src="https://img1.musnow.top/i/2023/03/eb618be1ff4873833c8469dae9093d1e.png"                                     ><br>  图中，V1 和 V6 没有前驱，则可任选一个。假设先输出 V6，在删除 V6 及弧 &lt;V6, V4&gt;,&lt;V6, V5&gt; 之后，只有顶点 V1 没有前驱，输出 V1 且删去 V1 及弧 &lt;V1, V2&gt;,&lt;V1, V3&gt; 和 &lt;V1, V4&gt;，之后 V3 和 V4 都没有前驱。依此类推，可从中任选一个继续进行。整个拓扑排序的过程如上图。</p><h2 id="拓扑排序实现"><a href="#拓扑排序实现" class="headerlink" title="拓扑排序实现"></a>拓扑排序实现</h2><p>  我们采用<strong>邻接表</strong>作有向图的存储结构，且在头结点中增加一个存放顶点入度的数组。入度为零的顶点即为没有前驱的顶点，删除顶点以及它为尾的弧的操作，则可换以弧头顶点的入度减 1 来实现。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">Status <span class="title function_">TopologicalSort</span><span class="params">(ALGraph G)</span>&#123;</span><br><span class="line"><span class="comment">//有向图G采用邻接表存储结构 </span></span><br><span class="line"><span class="comment">//若G无回路，则输出G的顶点的一个拓扑序列并返回OK，否则ERROR </span></span><br><span class="line">FindInDegree(G, indegree);<span class="comment">//对各顶点求入度indegree[0..vernum-1] </span></span><br><span class="line">InitStack(S);</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;G.vexnum;i++)<span class="comment">//建零入度顶点栈S </span></span><br><span class="line"><span class="keyword">if</span>(!indegree[i])<span class="comment">//入度为0者进栈 </span></span><br><span class="line">Push(S, i);</span><br><span class="line">count = <span class="number">0</span>;<span class="comment">//对输出顶点计数 </span></span><br><span class="line"><span class="keyword">while</span>(!StackEmpty(S))&#123;</span><br><span class="line">Pop(S, i);printf(i, G.vertices[i].data);count++;<span class="comment">//输出i号顶点并计数 </span></span><br><span class="line"><span class="keyword">for</span>(p=G.vertices[i].firstarc; p; p=p-&gt;nextarc)&#123;</span><br><span class="line">k = p-&gt;adjvex;<span class="comment">//对i号顶点的每个邻接点的入度减1 </span></span><br><span class="line"><span class="keyword">if</span>(!(--indegree[k]))<span class="comment">//若入度减为0，则入栈 </span></span><br><span class="line">Push(S, k);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(count&lt;G.vexnum)<span class="comment">//该有向图有回路 </span></span><br><span class="line"><span class="keyword">return</span> ERROR;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  对有 n 个顶点和 e 条弧的有向图而言，建立求各顶点的入度的时间复杂度 O(e)；建零入度顶点栈的时间复杂度为 O(n)；在拓扑排序过程中，若有向图无环，则每个顶点进一次栈，出一次栈，入度减 1 的操作在 WHILE 语句中总共执行 e 次，所以，总的**时间复杂度为 O(n+e)**。<br>  当有向图中无环时，也可利用深度优先遍历进行拓扑排序，因为图中无环，则由图中某点出发进行深度优先搜索遍历时，最先退出 DFS 函数的顶点即出度为零的顶点，是拓扑有序序列中最后一个顶点。由此，按退出 DFS 函数的先后记录下来的顶点序列(如同求强连通分量时 finished 数组中的顶点序列)即为逆向的拓扑有序序列。  </p><h1 id="关键路径"><a href="#关键路径" class="headerlink" title="关键路径"></a>关键路径</h1><h2 id="什么是关键路径？"><a href="#什么是关键路径？" class="headerlink" title="什么是关键路径？"></a>什么是关键路径？</h2><p><strong>AOE网：</strong> 在一个表示工程的带权有向图中，用顶点表示事件（如V1），用有向边表示活动（如&lt;V1,V2&gt; &#x3D; a1），边上的权值表示活动的持续时间，称这样的有向图为边表示的活动的网。<br><strong>源点：</strong> 在AOE网中，没有入边的顶点称为源点；如顶点V1。<br><strong>终点：</strong> 在AOE网中，没有出边的顶点称为终点；如顶点V9。<br><strong>AOE网的性质：</strong></p><ol><li>只有在进入某顶点的活动都已经结束，该顶点所代表的事件才发生；例如，V5 事件发生需要 a4 和 a5 两个活动都结束。</li><li>只有在某顶点所代表的事件发生后，从该顶点出发的各活动才开始；例如，V5 事件结束，活动 a7 和 a8 活动才能开始。<br><img                       lazyload                     alt="image"                     data-src="https://img1.musnow.top/i/2023/03/d52c8bebe169544eea3f93136b617d61.jpeg"                                     ></li></ol><p>  在AOE网中，所有活动都完成才能到达终点，因此完成整个工程所必须花费的时间（即最短工期）应该为源点到终点的最大路径长度。具有最大路径长度的路径称为<strong>关键路径</strong>。关键路径上的活动称为<strong>关键活动</strong>。<br>  假设开始点是 V1，从 V1 到 Vi 的最长路径长度叫做事件 Vi 的<strong>最早发生事件</strong>。这个时间决定了所有以 Vi 为尾的弧所表示的活动的<strong>最早开始时间</strong>。我们用 e(i) 表示活动 ai 的最早开始时间。还可以定义一个活动的<strong>最迟开始时间</strong> l(i)，这是在不推迟整个过程完成的前提下，活动 ai 最迟必须开始进行的时间。两者之差 l(i)-e(i) 意味着完成活动 ai 的时间余量。我们把 l(i)&#x3D;e(i) 的活动叫做关键活动。</p><p><strong>向关键路径要时间，向非关键路径要资源。</strong></p><ol><li><strong>从前往后，计算工期与每项活动的最早开始时间；</strong></li><li><strong>从后往前，倒推每项活动最晚开始时间。</strong></li><li><strong>关键路径：最早开始时间&#x3D;最晚开始时间</strong></li></ol><h2 id="怎么求关键路径？"><a href="#怎么求关键路径？" class="headerlink" title="怎么求关键路径？"></a>怎么求关键路径？</h2><p>ve(j)：最早发生时间<br>vl(j)：最迟发生时间</p><ol><li>输入 e 条弧&lt;j, k&gt;，建立 AOE-网的存储结构；</li><li>从源点 v0 出发，令 <code>ve[0]=0</code>，按拓扑有序求其余各顶点的最早发现时间 <code>ve[i] (1≤i≤n-1)</code>。如果得到的拓扑有序序列中顶点个数小于网中顶点数 n，则说明网中存在环，不能求关键路径，算法终止；否则执行步骤(3)。</li><li>从汇点 vn 出发，令 <code>vl[n-1]=ve[n-1]</code>，按逆拓扑有序求其余各顶点的最迟发生时间<code> vl[i] (n-2≥i≥2)</code>；</li><li>根据各顶点的 ve 和 vl 值，求每条弧 s 的最早开始时间 e(s) 和最迟开始时间 l(s)。若某条弧满足条件 e(s)&#x3D;l(s)，则为关键活动。</li></ol><p>  根据上述算法，计算各顶点的 ve 值是在拓扑排序的过程中进行的，需对拓扑排序的算法作如下修改：</p><ol><li>在拓扑排序之前设初值，令 <code>ve[i]=0 (0≤i≤n-1)</code>；</li><li>在算法中增加一个计算 vj 的直接后继 vk 的最早发生时间的操作：若 <code>ve[j]+dut(&lt;j, k&gt;) &gt; ve[k]</code>，则 <code>ve[k]=ve[j]+dut(&lt;j, k&gt;)</code>；</li><li>为了能按逆拓扑有序序列的顺序计算各顶点的 vl 值，需记下在拓扑排序的过程中求得的拓扑有序序列，这需要在拓扑排序算法中，增设一个栈以记录拓扑有序序列，则在计算求得各顶点的 ve 值之后，从栈顶至栈底便为逆拓扑有序序列。</li></ol><h2 id="关键路径实现"><a href="#关键路径实现" class="headerlink" title="关键路径实现"></a>关键路径实现</h2><p><strong>改写的拓扑排序代码：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">Status <span class="title function_">TopologicalOrder</span><span class="params">(ALGraph G, Stack &amp;T)</span>&#123;</span><br><span class="line"><span class="comment">//有向图G采用邻接表存储结构，求各顶点事件的最早发生时间 ve(全局变量) </span></span><br><span class="line"><span class="comment">//T为拓扑序列顶点栈，S为零入度顶点栈 </span></span><br><span class="line"><span class="comment">//若G无回路，则用栈T返回G的一个拓扑序列，且函数值为OK，否则ERROR </span></span><br><span class="line">FindInDegree(G, indegree);<span class="comment">//对各顶点求入度indegree[0..vernum-1] </span></span><br><span class="line">InitStack(S);<span class="comment">//建零入度顶点栈S </span></span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;G.vexnum;i++)<span class="comment">//建零入度顶点栈S </span></span><br><span class="line"><span class="keyword">if</span>(!indegree[i])<span class="comment">//入度为0者进栈 </span></span><br><span class="line">Push(S, i);</span><br><span class="line">InitStack(T);count = <span class="number">0</span>;ve[<span class="number">0.</span>.G.vexnum-<span class="number">1</span>] = <span class="number">0</span>;<span class="comment">//初始化 </span></span><br><span class="line"><span class="keyword">while</span>(!StackEmpty(S))&#123;</span><br><span class="line">Pop(S, j);Push(T, j);count++;<span class="comment">//j号顶点入T栈并计数 </span></span><br><span class="line"><span class="keyword">for</span>(p=G.vertices[j].firstarc; p; p=p-&gt;nextarc)&#123;</span><br><span class="line">k = p-&gt;adjvex;<span class="comment">//对j号顶点的每个邻接点的入度减1 </span></span><br><span class="line"><span class="keyword">if</span>(--indegree[k] == <span class="number">0</span>)<span class="comment">//若入度减为0，则入栈 </span></span><br><span class="line">Push(S, k);</span><br><span class="line"><span class="keyword">if</span>(ve[j]+ *(p-&gt;info)&gt;ve[k])</span><br><span class="line">ve[k] = ve[j] + *(p-&gt;info);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(count &lt; G.vexnum)<span class="comment">//该有向图有回路 </span></span><br><span class="line"><span class="keyword">return</span> ERROR;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="keyword">return</span> OK;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p><strong>关键路径算法：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">Status <span class="title function_">CriticalPath</span><span class="params">(ALGraph G)</span>&#123;</span><br><span class="line"><span class="comment">//G为有向图，输出G的各项关键活动 </span></span><br><span class="line"><span class="keyword">if</span>(!TopologicalOrder(G, T))</span><br><span class="line"><span class="keyword">return</span> ERROR;</span><br><span class="line">vl[<span class="number">0.</span>.G.vexnum-<span class="number">1</span>] = ve[G.vexnum-<span class="number">1</span>];<span class="comment">//初始化顶点事件的最迟发生事件 </span></span><br><span class="line"><span class="keyword">while</span>(!StackEmpty(T))&#123;<span class="comment">//按拓扑逆序求各顶点的vl值 </span></span><br><span class="line"><span class="keyword">for</span>(Pop(T, j),p=G.vertices[j].firstarc; p; p=p-&gt;nextarc)&#123;</span><br><span class="line">k = p-&gt;adjvex;dut = *(p-&gt;info);</span><br><span class="line"><span class="keyword">if</span>(vl[k]-dut &lt; vl[j])</span><br><span class="line">vl[j] = vl[k]-dut;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;G.vexnum;j++)&#123;<span class="comment">//求ee，el和关键活动 </span></span><br><span class="line"><span class="keyword">for</span>(p=G.vertices[j].firstarc; p; p=p-&gt;nextarc)&#123;</span><br><span class="line">k = p-&gt;adjvex;dut = *(p-&gt;info);</span><br><span class="line">ee = ve[j];el = vl[k]-dut;</span><br><span class="line">tag = (ee==el)?<span class="string">&#x27;*&#x27;</span>:<span class="string">&#x27;&#x27;</span>;</span><br><span class="line">printf(j, k, dut, ee, el, tag);<span class="comment">//输出关键活动 </span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p>  上面两种算法的时间复杂度均为 O(n+e)，计算弧的活动最早开始时间和最迟开始时间的时间复杂度为 O(e)，所以总的求关键路径的**时间复杂度为 O(n+e)**。  </p><h2 id="求关键路径过程示例"><a href="#求关键路径过程示例" class="headerlink" title="求关键路径过程示例"></a>求关键路径过程示例</h2><p><img                       lazyload                     alt="image"                     data-src="https://img1.musnow.top/i/2023/03/f0dcb74c0eff3d6f56e8415a2664e1dd.png"                                     ><br><img                       lazyload                     alt="image"                     data-src="https://img1.musnow.top/i/2023/03/d52c8bebe169544eea3f93136b617d61.jpeg"                                     > </p><p>上图的关键活动为 a1，a4，a7，a8，a10 和 a11。它们构成两条关键路径：(V1，V2，V5，V7，V9) 和 (V1，V2，V5，V8，V9)。  </p><p><strong>实践证明：用 AOE-网来估算某些工程完成的时间是非常有用的。只有在不改变网的关键路径的情况下，提高关键活动的速度才有效。若网中有几条关键路径，那么，单是提高一条关键路径上的关键活动的速度，还不能导致整个工程缩短工期，而必须提高同时在几条关键路径上的活动速度。</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">版权声明：本文为CSDN博主「qw&amp;amp;jy」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。</span><br><span class="line">原文链接：https://blog.csdn.net/qq_43448856/article/details/119959241</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;本文搬运自csdn&lt;/p&gt;</summary>
    
    
    
    <category term="数据结构太复杂" scheme="https://blog.musnow.top/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%A4%AA%E5%A4%8D%E6%9D%82/"/>
    
    
    <category term="数据结构" scheme="https://blog.musnow.top/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    <category term="Java" scheme="https://blog.musnow.top/tags/Java/"/>
    
    <category term="图" scheme="https://blog.musnow.top/tags/%E5%9B%BE/"/>
    
  </entry>
  
  <entry>
    <title>【教程】Typora+PicGo+又拍云UOS搭建博客图床</title>
    <link href="https://blog.musnow.top/2023/03/12/tools/17%E5%8F%88%E6%8B%8D%E4%BA%91uos+picgo/"/>
    <id>https://blog.musnow.top/2023/03/12/tools/17%E5%8F%88%E6%8B%8D%E4%BA%91uos+picgo/</id>
    <published>2023-03-12T00:35:28.000Z</published>
    <updated>2023-03-12T00:49:13.175Z</updated>
    
    <content type="html"><![CDATA[<p>Typora+PicGo+又拍云UOS搭建博客图床</p><span id="more"></span><h1 id="1-又拍云uos配置"><a href="#1-又拍云uos配置" class="headerlink" title="1.又拍云uos配置"></a>1.又拍云uos配置</h1><h2 id="1-1-创建"><a href="#1-1-创建" class="headerlink" title="1.1 创建"></a>1.1 创建</h2><p>进入控制台后，点击云存储，创建云存储服务。配置你的服务名称，操作员名称，和操作员的权限。</p><p>请保存操作员的密码，后续配置picgo用得到</p><p><img                       lazyload                     alt="image"                     data-src="https://img1.musnow.top/i/2023/03/51c2ef0cca2e70e32b09857f5358c54c.png"                      alt="image-20230312084831623"                ></p><h2 id="1-2-加速域名"><a href="#1-2-加速域名" class="headerlink" title="1.2 加速域名"></a>1.2 加速域名</h2><p>点击如下图齿轮进入配置页面</p><p><img                       lazyload                     alt="image"                     data-src="https://img1.musnow.top/i/2023/03/8e0fadfea5eb848011682a22a44f83ba.png"                      alt="image-20230312083903790"                ></p><p>在下图绑定你的域名（需要已备案域名）</p><p><img                       lazyload                     alt="image"                     data-src="https://img1.musnow.top/i/2023/03/625bc16e55372917417c26d5c3e819c2.png"                      alt="image-20230312084009866"                ></p><h2 id="1-3-https"><a href="#1-3-https" class="headerlink" title="1.3 https"></a>1.3 https</h2><p>随后在下图所示处配置域名的证书。如果你没有ssl证书，可以在又拍云的控制台主页申请一个免费的<code>let’s encrpy</code>证书</p><p><img                       lazyload                     alt="image"                     data-src="https://img1.musnow.top/i/2023/03/24b7d19b0bea93e1b84a24389afaf237.png"                      alt="image-20230312084046578"                ></p><h2 id="1-4-访问控制"><a href="#1-4-访问控制" class="headerlink" title="1.4 访问控制"></a>1.4 访问控制</h2><p>在访问控制里面可以配置各种形式的控制。对于博客图床而言，referer防盗链是一定要打开的，其余根据自己的需求进行配置</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">IP黑白名单 <span class="comment"># 白名单：允许的ip,黑名单：不允许的ip</span></span><br><span class="line"><span class="comment"># 如果发现某一个ip的请求次数过多，有恶意请求嫌疑，可以暂时将这个ip设置为黑名单</span></span><br><span class="line">CORS 跨域共享 <span class="comment"># 参考http://ruanyifeng.com/blog/2016/04/cors.html</span></span><br><span class="line">地区访问限制 <span class="comment"># 禁止或允许特定地区的限制</span></span><br><span class="line">Referer 防盗链 <span class="comment"># 重点，建议开启白名单，只将自己的域名添加到白名单中（建议开启）</span></span><br><span class="line">User-Agent 防盗链 <span class="comment"># 限制只有某种类型的客户端、浏览器可以访问资源</span></span><br><span class="line">Token 防盗链 <span class="comment"># 有些麻烦，请自行了解。对于静态博客而言，并不方便</span></span><br><span class="line">回源鉴权 <span class="comment"># 如果源站服务器有鉴权操作，可以在这里配置</span></span><br><span class="line">IP 访问限制 <span class="comment"># 对单个ip的请求速率进行限制（建议开启）</span></span><br><span class="line">CC 防护 <span class="comment"># 防护cc攻击</span></span><br><span class="line">WAF 保护 <span class="comment"># Web Application Firewall</span></span><br></pre></td></tr></table></figure><h1 id="2-picgo配置"><a href="#2-picgo配置" class="headerlink" title="2.picgo配置"></a>2.picgo配置</h1><p>相比于阿里云oss，这里的picgo配置就挺明了了</p><p><img                       lazyload                     alt="image"                     data-src="https://img1.musnow.top/i/2023/03/be5e600f6ec7f568f6c9722d88291f7e.png"                      alt="image-20230312084344938"                ></p><p>在picgo的<strong>上传区</strong>测试一下是否能正常上传</p><h1 id="3-typora"><a href="#3-typora" class="headerlink" title="3.typora"></a>3.typora</h1><p>typora的偏好设置中，图像一栏选择上传图片，勾选如下几项。</p><p>上传服务设置为<code>picgo(app)</code>，路径填写为你picgo的安装路径。</p><p><img                       lazyload                     alt="image"                     data-src="https://img1.musnow.top/i/2023/03/59936c6ea7a652bd02ca47fa81b94f7e.png"                      alt="image-20230312084419417"                ></p><p>随后点击左下角验证图片上传，出现如下所示代表配置成功</p><p><img                       lazyload                     alt="image"                     data-src="https://img1.musnow.top/i/2023/03/42c1bf3d071335235ff8c6d201a5a66e.png"                      alt="image-20230312084524751"                ></p><p>此时我们的图床就已经配置好了</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;Typora+PicGo+又拍云UOS搭建博客图床&lt;/p&gt;</summary>
    
    
    
    <category term="差生文具多" scheme="https://blog.musnow.top/categories/%E5%B7%AE%E7%94%9F%E6%96%87%E5%85%B7%E5%A4%9A/"/>
    
    
    <category term="图床" scheme="https://blog.musnow.top/tags/%E5%9B%BE%E5%BA%8A/"/>
    
    <category term="typora" scheme="https://blog.musnow.top/tags/typora/"/>
    
  </entry>
  
  <entry>
    <title>【建站】hexo搭建博客+建站相关教程</title>
    <link href="https://blog.musnow.top/2023/03/12/blog/%E5%BB%BA%E7%AB%99%E6%95%99%E7%A8%8B/"/>
    <id>https://blog.musnow.top/2023/03/12/blog/%E5%BB%BA%E7%AB%99%E6%95%99%E7%A8%8B/</id>
    <published>2023-03-12T00:28:14.000Z</published>
    <updated>2023-03-12T01:27:08.223Z</updated>
    
    <content type="html"><![CDATA[<p>关于HEXO建站相关博客汇总</p><span id="more"></span><h1 id="1-hexo部署和主题自定义"><a href="#1-hexo部署和主题自定义" class="headerlink" title="1.hexo部署和主题自定义"></a>1.hexo部署和主题自定义</h1><p><a href="https://blog.musnow.top/2022/04/16/blog/%E4%BD%BF%E7%94%A8hexo%E5%92%8Ckeep%E4%B8%BB%E9%A2%98%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/">【教程】hexo搭建博客+keep主题美化</a></p><h1 id="2-配置图床"><a href="#2-配置图床" class="headerlink" title="2.配置图床"></a>2.配置图床</h1><p>以下为typora+picgo配置图床的教程</p><p><a href="https://blog.musnow.top/2023/01/23/tools/11picgo%E8%AE%BE%E7%BD%AE%E5%91%BD%E5%90%8D%E6%A0%BC%E5%BC%8F/">【Picgo】正确重命名文件，避免重复上传</a></p><h2 id="2-1-阿里云oss"><a href="#2-1-阿里云oss" class="headerlink" title="2.1 阿里云oss"></a>2.1 阿里云oss</h2><p><a href="https://blog.musnow.top/2022/01/11/tools/1%E9%98%BF%E9%87%8C%E4%BA%91oss+picgo+typora/">【教程】Typora+PicGo+阿里云OSS搭建博客图床（超详细）</a></p><h2 id="2-2-lsky自建图床"><a href="#2-2-lsky自建图床" class="headerlink" title="2.2 lsky自建图床"></a>2.2 lsky自建图床</h2><p>自建图床的优势在于，图片都在你服务器的本地，可以直接tar打包进行备份，或者下载到本地。个人不太喜欢oss的一点，就是大多数oss服务商都没有提供批量下载oss内部文件的选项。虽然可以用python脚本来实现这一操作。但服务商能提供还是更好嘛！</p><p>估计是考虑到存储服务器的负载问题，所以没有提供这个功能。毕竟批量下载大量文件，是很耗资源的。</p><p><a href="https://blog.musnow.top/2023/01/28/docker/5docker%E9%85%8D%E7%BD%AElskypro%E5%9B%BE%E5%BA%8A/#4-picgo">【Docker】配置lsky pro兰空图床</a></p><h2 id="2-3-又拍云uos"><a href="#2-3-又拍云uos" class="headerlink" title="2.3 又拍云uos"></a>2.3 又拍云uos</h2><p>相比于阿里云oss的bucket只有防盗链，又拍云的uos还有ip黑白名单，cc防护，单ip访问限制等等功能。对于博客图床防盗刷而言，很有用。</p><p>但又拍云uos需要<strong>域名已备案</strong>才能自定义域名，否则只能使用官方提供的测试域名。如果你的域名已备案，个人更推荐使用又拍云uos作为博客图床。</p><p><a href="https://blog.musnow.top/2023/03/12/tools/17%E5%8F%88%E6%8B%8D%E4%BA%91uos+picgo/">【教程】Typora+PicGo+又拍云UOS搭建博客图床</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;关于HEXO建站相关博客汇总&lt;/p&gt;</summary>
    
    
    
    <category term="差生文具多" scheme="https://blog.musnow.top/categories/%E5%B7%AE%E7%94%9F%E6%96%87%E5%85%B7%E5%A4%9A/"/>
    
    
    <category term="Hexo" scheme="https://blog.musnow.top/tags/Hexo/"/>
    
  </entry>
  
  <entry>
    <title>【docker】通过配置文件，修改已有容器的端口映射</title>
    <link href="https://blog.musnow.top/2023/03/11/docker/11%E4%BF%AE%E6%94%B9%E5%B7%B2%E6%9C%89%E5%AE%B9%E5%99%A8%E7%9A%84%E7%AB%AF%E5%8F%A3%E6%98%A0%E5%B0%84/"/>
    <id>https://blog.musnow.top/2023/03/11/docker/11%E4%BF%AE%E6%94%B9%E5%B7%B2%E6%9C%89%E5%AE%B9%E5%99%A8%E7%9A%84%E7%AB%AF%E5%8F%A3%E6%98%A0%E5%B0%84/</id>
    <published>2023-03-11T11:45:33.000Z</published>
    <updated>2023-03-11T12:00:52.818Z</updated>
    
    <content type="html"><![CDATA[<p>docker修改已有容器的端口映射</p><span id="more"></span><blockquote><p>参考 <a class="link"   href="https://www.jb51.net/article/257510.htm" >https://www.jb51.net/article/257510.htm<i class="fas fa-external-link-alt"></i></a></p></blockquote><h1 id="1-需求"><a href="#1-需求" class="headerlink" title="1.需求"></a>1.需求</h1><p>之前我在我的nas上部署了一个centos容器，当时脑子抽了，没想起来要多映射几个端口。只映射了容器的22端口（ssh）</p><p>对于应用开发而言，没有能够直接访问的端口可太蛋疼了。在centos里面开frp穿透出来访问吧，又太麻烦。</p><p>如果在绿联的控制台里面修改端口隐射，<strong>会直接创建一个新的容器</strong>，原有容器的信息会丢失。现在这个centos系统已经用了一段时间了，开发环境都配置好了。创建一个新容器就是得重头配置，虽然不是啥难事，但是太耗时间了！！！😥</p><p>于是就想着，能否通过修改配置文件的方式，实现修改容器的端口映射。</p><h1 id="2-操作"><a href="#2-操作" class="headerlink" title="2.操作"></a>2.操作</h1><h2 id="2-1-开启ssh并关闭docker服务"><a href="#2-1-开启ssh并关闭docker服务" class="headerlink" title="2.1 开启ssh并关闭docker服务"></a>2.1 开启ssh并关闭docker服务</h2><p>修改之前，<strong>需要开启绿联nas的ssh服务</strong>。绿联nas如何开启ssh参考 <a class="link"   href="https://www.bilibili.com/video/BV1J84y1C7Zu/?spm_id_from=333.337.search-card.all.click" >视频<i class="fas fa-external-link-alt"></i></a></p><p>链接上ssh之后，先使用<code>docker ps</code>，查看需要修改容器的id。注意，这里的id并不是完整的容器id，先记录下来。</p><p><img                       lazyload                     alt="image"                     data-src="https://img1.musnow.top/i/2023/03/4531c3a572e0afe317768fee05254943.png"                      alt="image-20230311193038037"                ></p><p>图中也能看到，当前这个centos容器只映射了22端口</p><hr><p>进入绿联的客户端，关闭docker服务</p><p><img                       lazyload                     alt="image"                     data-src="https://img1.musnow.top/i/2023/03/aa3879c8c27f9e13e4300376eec8176b.png"                      alt="image-20230311192756106"                ></p><p>命令行里面再次执行<code>docker ps</code>，确认docker服务确实已经关闭</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ docker ps</span><br><span class="line">Cannot connect to the Docker daemon at unix:///var/run/docker.sock. Is the docker daemon running?</span><br></pre></td></tr></table></figure><p>如果显示如上，则代表docker并没有在运行。</p><hr><h2 id="2-2-找到docker安装路径"><a href="#2-2-找到docker安装路径" class="headerlink" title="2.2 找到docker安装路径"></a>2.2 找到docker安装路径</h2><p>接下来要做的，就是查看docker安装的位置。对于群晖、威联通、绿联这种nas而言，其系统内对docker安装挂载的位置是不同的。比如绿联的nas自带了16gb的闪存，但docker的安装位置并不在这里面。</p><p>一般的centos系统（以我的云服务器为例），docker的安装位置应该是如下路径</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/var/lib/docker</span><br></pre></td></tr></table></figure><p>ls查看内部文件，如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># ls /var/lib/docker</span><br><span class="line">containers  image  network  overlay2  plugins  swarm  tmp  trust  volumes</span><br></pre></td></tr></table></figure><p>而绿联的系统并没有这个路径</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">can&#x27;t open &#x27;/var/lib/docker&#x27;: No such file or directory</span><br></pre></td></tr></table></figure><p>查看<code>/var/lib</code>，并没有发现docker文件夹</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># ls /var/lib/</span><br><span class="line">dbus   nginx  samba</span><br></pre></td></tr></table></figure><p>查看<code>/var</code>，发现了一个dockerd，猜测这是docker相关文件存放的位置</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># ls /var</span><br><span class="line">all_aria2.txt    dockerd          factory   </span><br></pre></td></tr></table></figure><p>里面只有一个json文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># ls /var/dockerd</span><br><span class="line">daemon.json</span><br></pre></td></tr></table></figure><p>cat命令查看，果不其然，是docker的安装路径</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># cat /var/dockerd/daemon.json</span><br><span class="line">&#123;&quot;data-root&quot;:&quot;/mnt/media_rw/2550c297-7334-455f-9fce-e0a00aad40c8/.ugreen_nas/6&quot;,&quot;log-level&quot;:&quot;warn&quot;,&quot;iptables&quot;:true,&quot;api-cors-header&quot;:&quot;*&quot;,&quot;host375&quot;],&quot;registry-mirrors&quot;:[&quot;https://registry.docker-cn.com&quot;]&#125;</span><br></pre></td></tr></table></figure><p>这就是docker的安装位置了</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/mnt/media_rw/2550c297-7334-455f-9fce-e0a00aad40c8/.ugreen_nas/6</span><br></pre></td></tr></table></figure><p>ls查看，文件结构和云服务器的docker安装位置基本一样，这代表我们找对了！</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># ls /mnt/media_rw/2550c297-7334-455f-9fce-e0a00aad40c8/.ugreen_nas/6</span><br><span class="line">buildkit    containerd  containers  image       network     overlay2    plugins     runtimes    swarm    </span><br><span class="line">tmp        trust       volumes</span><br></pre></td></tr></table></figure><h2 id="2-3-找到对应容器的配置文件路径"><a href="#2-3-找到对应容器的配置文件路径" class="headerlink" title="2.3 找到对应容器的配置文件路径"></a>2.3 找到对应容器的配置文件路径</h2><p>docker路径下的<code>containers</code>文件夹，包含了不同容器的配置<strong>文件夹</strong>。ls查看，发现都是一些看不懂的字符串。实际上，这里的字符串就是容器的id</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># ls /mnt/media_rw/2550c297-7334-455f-9fce-e0a00aad40c8/.ugreen_nas/6/containers</span><br><span class="line">2b8f29d7b4b0ad624fb02048cb91c569e6e52409fe246e1c741bdd13ed7242cf  9113e1ec4740726feb9623a897f81b9066bc1b63811bfc0a65875d8a2c46c603</span><br><span class="line">47aa763o2da18686c6301047ef57f24fb611a2ebea2066f0dbk68205a40777e3</span><br></pre></td></tr></table></figure><p>前面提到，<code>docker ps</code>显示的容器id并不是完整的。因为完整的很长很长，不可能在ps命令里面全显示出来。</p><p>我需要修改的目标容器，缩短的id如下，对应的正是<code>containers</code>文件夹里面的第一个文件夹</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2b8f29d7b4b0</span><br></pre></td></tr></table></figure><p>看看这个文件夹里面有啥东西</p><p><font color=Red>注意</font>：此时命令已经很长很长。避免出错，建议开个记事本，在里面把命令写好，再复制到终端中执行！</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ls -l /mnt/media_rw/2550c297-7334-455f-9fce-e0a00aad40c8/.ugreen_nas/6/containers/2b8f29d7b4b0ad624fb02048cb91c569e6e52409fe246e1c741bdd13ed7242cf</span><br></pre></td></tr></table></figure><p>得到的文件结构如下，我们需要修改的是<code>config.v2.json</code>和<code>hostconfig.json</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">-rw-r-----    1 root     root         87802 Mar 11 18:12 2b8f29d7b4b0ad624fb02048cb91c569e6e52409fe246e1c741bdd13ed7242cf-json.log</span><br><span class="line">drwx------    2 root     root          4096 Feb 23 18:42 checkpoints</span><br><span class="line">-rw-------    1 root     root          3300 Mar 11 18:12 config.v2.json</span><br><span class="line">-rw-r--r--    1 root     root          1925 Mar 11 18:12 hostconfig.json</span><br><span class="line">-rw-r--r--    1 root     root            13 Mar 11 18:12 hostname</span><br><span class="line">-rw-r--r--    1 root     root           174 Mar 11 18:12 hosts</span><br><span class="line">drwx--x---    2 root     root          4096 Feb 23 18:43 mounts</span><br><span class="line">-rw-r--r--    1 root     root            83 Mar 11 18:12 resolv.conf</span><br><span class="line">-rw-r--r--    1 root     root            71 Mar 11 18:12 resolv.conf.hash</span><br></pre></td></tr></table></figure><h2 id="2-4-备份"><a href="#2-4-备份" class="headerlink" title="2.4 备份"></a>2.4 备份</h2><p>在linux的命令行中操作，备份是必不可少的！使用cp命令，把配置文件复制一份，并在名字中添加上<code>.bak</code>予以区别</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cp 源文件 目标文件</span><br></pre></td></tr></table></figure><p>以下是cp命令备份<code>config.v2.json</code>文件的命令示例</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cp /mnt/media_rw/2550c297-7334-455f-9fce-e0a00aad40c8/.ugreen_nas/6/containers/2b8f29d7b4b0ad624fb02048cb91c569e6e52409fe246e1c741bdd13ed7242cf/config.v2.json /mnt/media_rw/2550c297-7334-455f-9fce-e0a00aad40c8/.ugreen_nas/6/containers/2b8f29d7b4b0ad624fb02048cb91c569e6e52409fe246e1c741bdd13ed7242cf/config.v2.bak.json</span><br></pre></td></tr></table></figure><p>备份了我们需要修改的两个文件后，接下来就是修改配置文件了</p><h2 id="2-5-修改配置文件"><a href="#2-5-修改配置文件" class="headerlink" title="2.5 修改配置文件"></a>2.5 修改配置文件</h2><h3 id="2-5-1-hostconfig-json"><a href="#2-5-1-hostconfig-json" class="headerlink" title="2.5.1  hostconfig.json"></a>2.5.1  hostconfig.json</h3><p>使用vim来进行编辑（编辑之前，可以用cat先复制出内容，放到vsc等编辑器中格式化，方便找到对应的位置）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim /mnt/media_rw/2550c297-7334-455f-9fce-e0a00aad40c8/.ugreen_nas/6/containers/2b8f29d7b4b0ad624fb02048cb91c569e6e52409fe246e1c741bdd13ed7242cf/hostconfig.json</span><br></pre></td></tr></table></figure><p>如下便是要修改的字段，可以看到里面只有对22端口的映射</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">&quot;PortBindings&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;22/tcp&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">            <span class="punctuation">&#123;</span></span><br><span class="line">                <span class="attr">&quot;HostIp&quot;</span><span class="punctuation">:</span> <span class="string">&quot;0.0.0.0&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;HostPort&quot;</span><span class="punctuation">:</span> <span class="string">&quot;22222&quot;</span></span><br><span class="line">            <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="punctuation">&#123;</span></span><br><span class="line">                <span class="attr">&quot;HostIp&quot;</span><span class="punctuation">:</span> <span class="string">&quot;::&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;HostPort&quot;</span><span class="punctuation">:</span> <span class="string">&quot;22222&quot;</span></span><br><span class="line">            <span class="punctuation">&#125;</span></span><br><span class="line">        <span class="punctuation">]</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>我们照猫画虎，直接添加上另外两个端口的映射。</p><p>在英文输入法下，按<code>i</code>进入vim的编辑模式，通过键盘移动光标到指定位置，修改文件</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">&quot;PortBindings&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;22/tcp&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">            <span class="punctuation">&#123;</span></span><br><span class="line">                <span class="attr">&quot;HostIp&quot;</span><span class="punctuation">:</span> <span class="string">&quot;0.0.0.0&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;HostPort&quot;</span><span class="punctuation">:</span> <span class="string">&quot;22222&quot;</span></span><br><span class="line">            <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="punctuation">&#123;</span></span><br><span class="line">                <span class="attr">&quot;HostIp&quot;</span><span class="punctuation">:</span> <span class="string">&quot;::&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;HostPort&quot;</span><span class="punctuation">:</span> <span class="string">&quot;22222&quot;</span></span><br><span class="line">            <span class="punctuation">&#125;</span></span><br><span class="line">        <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;50000/tcp&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">            <span class="punctuation">&#123;</span></span><br><span class="line">                <span class="attr">&quot;HostIp&quot;</span><span class="punctuation">:</span> <span class="string">&quot;0.0.0.0&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;HostPort&quot;</span><span class="punctuation">:</span> <span class="string">&quot;50000&quot;</span></span><br><span class="line">            <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="punctuation">&#123;</span></span><br><span class="line">                <span class="attr">&quot;HostIp&quot;</span><span class="punctuation">:</span> <span class="string">&quot;::&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;HostPort&quot;</span><span class="punctuation">:</span> <span class="string">&quot;50000&quot;</span></span><br><span class="line">            <span class="punctuation">&#125;</span></span><br><span class="line">        <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;50001/tcp&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">            <span class="punctuation">&#123;</span></span><br><span class="line">                <span class="attr">&quot;HostIp&quot;</span><span class="punctuation">:</span> <span class="string">&quot;0.0.0.0&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;HostPort&quot;</span><span class="punctuation">:</span> <span class="string">&quot;50001&quot;</span></span><br><span class="line">            <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="punctuation">&#123;</span></span><br><span class="line">                <span class="attr">&quot;HostIp&quot;</span><span class="punctuation">:</span> <span class="string">&quot;::&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;HostPort&quot;</span><span class="punctuation">:</span> <span class="string">&quot;50001&quot;</span></span><br><span class="line">            <span class="punctuation">&#125;</span></span><br><span class="line">        <span class="punctuation">]</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>编辑好了之后，按esc退出编辑模式，<code>:wq</code>保存并退出</p><hr><h3 id="2-5-2-config-v2-json"><a href="#2-5-2-config-v2-json" class="headerlink" title="2.5.2 config.v2.json"></a>2.5.2 config.v2.json</h3><p>这个文件需要修改的是如下字段</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">&quot;ExposedPorts&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;22/tcp&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span><span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>添加上刚刚在<code>hostconfig.json</code>里面新增的端口</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">&quot;ExposedPorts&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;22/tcp&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;50000/tcp&quot;</span><span class="punctuation">:</span><span class="punctuation">&#123;</span><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;50001/tcp&quot;</span><span class="punctuation">:</span><span class="punctuation">&#123;</span><span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>同样<code>:wq</code>保存并退出</p><h2 id="2-6-现在就已经修改好啦！"><a href="#2-6-现在就已经修改好啦！" class="headerlink" title="2.6 现在就已经修改好啦！"></a>2.6 现在就已经修改好啦！</h2><p>相同的位置还可以修改容器的hostname。</p><p>用docker安装的centos镜像，是不能在centos系统中修改容器hostname的（修改可以，但是不会生效）</p><h1 id="3-重启docker，查看是否修改成功"><a href="#3-重启docker，查看是否修改成功" class="headerlink" title="3.重启docker，查看是否修改成功"></a>3.重启docker，查看是否修改成功</h1><p>在客户端里面重启docker服务之后，使用docker ps命令查看端口映射是否修改成功</p><p><img                       lazyload                     alt="image"                     data-src="https://img1.musnow.top/i/2023/03/04cbabad9ae0b3f2dbe29136281063b8.png"                      alt="image-20230311195511866"                ></p><p>可以看到，多出了50000和50001端口，修改成功！</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;docker修改已有容器的端口映射&lt;/p&gt;</summary>
    
    
    
    <category term="docker真好玩" scheme="https://blog.musnow.top/categories/docker%E7%9C%9F%E5%A5%BD%E7%8E%A9/"/>
    
    
    <category term="Linux" scheme="https://blog.musnow.top/tags/Linux/"/>
    
    <category term="CentOS" scheme="https://blog.musnow.top/tags/CentOS/"/>
    
    <category term="Docker" scheme="https://blog.musnow.top/tags/Docker/"/>
    
  </entry>
  
  <entry>
    <title>【js】用html+javascript静态页面实现伪重定向</title>
    <link href="https://blog.musnow.top/2023/03/10/tools/16%E4%BD%BF%E7%94%A8js%E5%AE%9E%E7%8E%B0%E9%87%8D%E5%AE%9A%E5%90%91/"/>
    <id>https://blog.musnow.top/2023/03/10/tools/16%E4%BD%BF%E7%94%A8js%E5%AE%9E%E7%8E%B0%E9%87%8D%E5%AE%9A%E5%90%91/</id>
    <published>2023-03-10T11:50:31.000Z</published>
    <updated>2023-03-11T11:25:36.228Z</updated>
    
    <content type="html"><![CDATA[<p>javascript代码实现一个伪重定向</p><span id="more"></span><h1 id="1-前言"><a href="#1-前言" class="headerlink" title="1.前言"></a>1.前言</h1><p>本站的域名之前有修改过，<strong>但一些朋友的友链，和开往里面的链接尚未更新</strong>。旧的域名又米有备案，不能解析到国内服务器上用nginx进行30x转发。</p><p>这时候我就想到了一招，用js的代码来实现一个url的切换，相当于一个伪重定向。因为是静态文件，能直接部署到netlify等平台上。</p><p>百度了一下js是否支持这种语法，嘿，支持！</p><p>那不直接开整！</p><h1 id="2-代码"><a href="#2-代码" class="headerlink" title="2.代码"></a>2.代码</h1><p>关于http的30x状态码，其代表站点域名或路径更改</p><ul><li>301重定向：永久</li><li>302重定向：临时</li></ul><p>html代码部分很简单，设置body和站点标题都为301重定向，告诉访问者，站点已经换了新的域名</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span><span class="tag">&lt;<span class="name">title</span>&gt;</span>301 Moved Permanently<span class="tag">&lt;/<span class="name">title</span>&gt;</span><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">center</span>&gt;</span><span class="tag">&lt;<span class="name">h1</span>&gt;</span>301 Moved Permanently<span class="tag">&lt;/<span class="name">h1</span>&gt;</span><span class="tag">&lt;/<span class="name">center</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p><code>script</code>部分，通过<code>window</code>获取当前的域名，判断域名是否为目标域名（下文代码中的<code>旧域名</code>）</p><p>如果不是，则什么都不做。如果是，则覆盖url到新域名。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--放在head后，body前--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"><span class="keyword">var</span> path = <span class="variable language_">window</span>.<span class="property">location</span>.<span class="property">href</span>;</span></span><br><span class="line"><span class="language-javascript">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;current path:&quot;</span>,path)<span class="comment">//打印到控制台</span></span></span><br><span class="line"><span class="language-javascript">    <span class="comment">// 睡眠函数</span></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">function</span> <span class="title function_">sleep</span> (time) &#123;</span></span><br><span class="line"><span class="language-javascript">      <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve</span>) =&gt;</span> <span class="built_in">setTimeout</span>(resolve, time));</span></span><br><span class="line"><span class="language-javascript">    &#125;</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="comment">// 睡500ms,之后执行下面的内容</span></span></span><br><span class="line"><span class="language-javascript">    <span class="title function_">sleep</span>(<span class="number">500</span>).<span class="title function_">then</span>(<span class="function">() =&gt;</span> &#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="comment">// 如果url不是预先设定好的这个，则啥都不做</span></span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">if</span> (path!=<span class="string">&quot;旧域名1&quot;</span> &amp;&amp; path!=<span class="string">&quot;旧域名2&quot;</span>) &#123;</span></span><br><span class="line"><span class="language-javascript">          <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;url not match, do nothing&quot;</span>)</span></span><br><span class="line"><span class="language-javascript">        &#125;</span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">else</span>&#123;<span class="comment">// 否则重定向</span></span></span><br><span class="line"><span class="language-javascript">          <span class="variable language_">window</span>.<span class="property">location</span>.<span class="title function_">replace</span>(<span class="string">&quot;https://blog.musnow.top/&quot;</span>);</span></span><br><span class="line"><span class="language-javascript">        &#125;</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    &#125;)</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这里我还用sleep函数休眠了500ms，否则切换很快，访客不注意的话，还不一定能发现301重定向。</p><hr><p>如果你不需要sleep，那代码更少</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"><span class="keyword">var</span> path = <span class="variable language_">window</span>.<span class="property">location</span>.<span class="property">href</span>;</span></span><br><span class="line"><span class="language-javascript">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;current path:&quot;</span>,path)</span></span><br><span class="line"><span class="language-javascript">    <span class="comment">// 如果url不是预先设定好的这两个，则啥都不做</span></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">if</span> (path!=<span class="string">&quot;旧域名&quot;</span>) &#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;url not match, do nothing&quot;</span>)</span></span><br><span class="line"><span class="language-javascript">    &#125;</span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">else</span>&#123;<span class="comment">// 否则重定向</span></span></span><br><span class="line"><span class="language-javascript">       <span class="variable language_">window</span>.<span class="property">location</span>.<span class="title function_">replace</span>(<span class="string">&quot;https://blog.musnow.top/&quot;</span>);</span></span><br><span class="line"><span class="language-javascript">    &#125;</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><h1 id="3-netlify部署"><a href="#3-netlify部署" class="headerlink" title="3.netlify部署"></a>3.netlify部署</h1><p>将刚刚写好的代码写入一个<code>index.html</code>文件，再放入一个文件夹（netlify的上传只能上传文件夹）</p><p>如果你想，还可以在文件夹里面放一个<code>favicon.ico</code>作为临时的站点logo</p><p>打开netlify，找到Add new site，选择手动部署</p><p><img                       lazyload                     alt="image"                     data-src="https://img1.musnow.top/i/2023/03/640b1d697d4b2.png"                      alt="image-20230310200548549"                ></p><p>在这里上传文件夹</p><p><img                       lazyload                     alt="image"                     data-src="https://img1.musnow.top/i/2023/03/640b1d7ed3638.png"                      alt="image-20230310200727885"                ></p><p>部署好了之后，可以在domain settings里面配置域名为你的旧域名</p><p><img                       lazyload                     alt="image"                     data-src="https://img1.musnow.top/i/2023/03/640b1dfe2efe5.png"                      alt="image-20230310200935284"                ></p><h1 id="4-测试"><a href="#4-测试" class="headerlink" title="4.测试"></a>4.测试</h1><p>先访问旧域名，显示301重定向的信息</p><p><img                       lazyload                     alt="image"                     data-src="https://img1.musnow.top/i/2023/03/640b1e203e735.png"                      alt="image-20230310201009342"                ></p><p>休眠的时间到了之后，就会被重定向到当前的站点</p><p><img                       lazyload                     alt="image"                     data-src="https://img1.musnow.top/i/2023/03/640b1e6d4a595.png"                      alt="image-20230310201122790"                ></p><p>目的达成！</p><h1 id="5-添加上尾随参数"><a href="#5-添加上尾随参数" class="headerlink" title="5.添加上尾随参数"></a>5.添加上尾随参数</h1><p>如果你的站点有部署umami或者百度统计等<strong>访问统计</strong>服务，则可以在源码中跳转的链接里面加上来源</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">window</span>.<span class="property">location</span>.<span class="title function_">replace</span>(<span class="string">&quot;https://blog.musnow.top/?utm_source=旧域名&quot;</span>);</span><br></pre></td></tr></table></figure><p>这样，在访问统计中，就能得知有多少用户用了旧域名访问了你的站点</p><p><img                       lazyload                     alt="image"                     data-src="https://img1.musnow.top/i/2023/03/640b207623dc3.png"                      alt="image-20230310201912571"                ></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;javascript代码实现一个伪重定向&lt;/p&gt;</summary>
    
    
    
    <category term="差生文具多" scheme="https://blog.musnow.top/categories/%E5%B7%AE%E7%94%9F%E6%96%87%E5%85%B7%E5%A4%9A/"/>
    
    
    <category term="hexo" scheme="https://blog.musnow.top/tags/hexo/"/>
    
  </entry>
  
  <entry>
    <title>【Python】pip下载使用国内镜像源</title>
    <link href="https://blog.musnow.top/2023/03/10/Python/11pip%E5%AE%89%E8%A3%85%E4%BD%BF%E7%94%A8%E9%95%9C%E5%83%8F%E6%BA%90/"/>
    <id>https://blog.musnow.top/2023/03/10/Python/11pip%E5%AE%89%E8%A3%85%E4%BD%BF%E7%94%A8%E9%95%9C%E5%83%8F%E6%BA%90/</id>
    <published>2023-03-10T00:31:00.000Z</published>
    <updated>2023-03-10T03:58:33.195Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-如何使用"><a href="#1-如何使用" class="headerlink" title="1.如何使用"></a>1.如何使用</h2><p>在直接用pip安装的时候，有时候会非常非常慢</p><p>可以用下面的命令，在安装的时候使用清华的镜像源</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-i https://pypi.tuna.tsinghua.edu.cn/simple</span><br></pre></td></tr></table></figure><p>比如下面的操作</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip3.10 install -r requirements.txt -i https://pypi.tuna.tsinghua.edu.cn/simple</span><br></pre></td></tr></table></figure><p>速度直接起飞</p><h2 id="2-修改配置文件"><a href="#2-修改配置文件" class="headerlink" title="2.修改配置文件"></a>2.修改配置文件</h2><p>在用户的家目录下创建一个<code>.pip</code>文件夹，并在里面创建一个<code>pip.conf</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[global]</span><br><span class="line">index-url = https://pypi.tuna.tsinghua.edu.cn/simple</span><br><span class="line">[install]</span><br><span class="line">trusted-host = https://pypi.tuna.tsinghua.edu.cn</span><br></pre></td></tr></table></figure><p>保存后，查看是否配置成功</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ pip3.10 config list</span><br><span class="line">global.index-url=&#x27;https://pypi.tuna.tsinghua.edu.cn/simple&#x27;</span><br><span class="line">install.trusted-host=&#x27;https://pypi.tuna.tsinghua.edu.cn&#x27;</span><br></pre></td></tr></table></figure><p>这样就配置好了</p><hr><p>windows下pip配置文件路径如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">C:\Users\用户名\pip\pip.ini</span><br></pre></td></tr></table></figure><p>输入如下内容</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[global]</span><br><span class="line">index-url = https://pypi.tuna.tsinghua.edu.cn/simple</span><br><span class="line">[install]</span><br><span class="line">trusted-host = pypi.tuna.tsinghua.edu.cn</span><br></pre></td></tr></table></figure><h2 id="3-镜像源汇总"><a href="#3-镜像源汇总" class="headerlink" title="3.镜像源汇总"></a>3.镜像源汇总</h2><p>目前我测试能直接访问的镜像源有下面几个。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">清华 https://pypi.tuna.tsinghua.edu.cn/simple</span><br><span class="line">豆瓣 https://pypi.doubanio.com/simple/</span><br><span class="line">中科大 https://mirrors.bfsu.edu.cn/pypi/web/simple/</span><br><span class="line">阿里云 https://mirrors.aliyun.com/pypi/simple/</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;1-如何使用&quot;&gt;&lt;a href=&quot;#1-如何使用&quot; class=&quot;headerlink&quot; title=&quot;1.如何使用&quot;&gt;&lt;/a&gt;1.如何使用&lt;/h2&gt;&lt;p&gt;在直接用pip安装的时候，有时候会非常非常慢&lt;/p&gt;
&lt;p&gt;可以用下面的命令，在安装的时候使用清华的镜像源&lt;</summary>
      
    
    
    
    <category term="速通Python" scheme="https://blog.musnow.top/categories/%E9%80%9F%E9%80%9APython/"/>
    
    
    <category term="Python" scheme="https://blog.musnow.top/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>【Linux】浏览器写代码！部署code-server远程vscode网页</title>
    <link href="https://blog.musnow.top/2023/03/09/docker/10code-server/"/>
    <id>https://blog.musnow.top/2023/03/09/docker/10code-server/</id>
    <published>2023-03-09T13:45:33.000Z</published>
    <updated>2023-03-11T11:25:36.263Z</updated>
    
    <content type="html"><![CDATA[<p>部署code-server远程vscode网页，在浏览器上写代码！</p><span id="more"></span><p>参考文档 <a class="link"   href="https://developer.aliyun.com/article/876967#slide-7" >https://developer.aliyun.com/article/876967#slide-7<i class="fas fa-external-link-alt"></i></a></p><h1 id="1-什么是code-server？"><a href="#1-什么是code-server？" class="headerlink" title="1.什么是code-server？"></a>1.什么是code-server？</h1><p>注意，这不是在linux系统上安装vscode软件（和windows一样的vscode客户端）</p><blockquote><p>开源仓库 <a class="link"   href="https://github.com/coder/code-server" >https://github.com/coder/code-server<i class="fas fa-external-link-alt"></i></a></p></blockquote><p>code-server是一个社区项目（非微软官方）其作用是在你的linux主机（云服务器）上部署一个可以在<strong>浏览器</strong>上访问的vscode页面，类似官方的<code>vscode.dev</code></p><blockquote><p>微软官方推出的vscode网页版 <a class="link"   href="https://vscode.dev/" >https://vscode.dev/<i class="fas fa-external-link-alt"></i></a> </p><p>它可以通过浏览器的api访问你<strong>电脑上的本地文件</strong>，此时浏览器就是一个vscode客户端</p><p><img                       lazyload                     alt="image"                     data-src="https://img1.musnow.top/i/2023/03/6409e2f59a83a.png"                      alt="image-20230309214517648"                ></p></blockquote><p>code-server同理，其访问的是你linux服务器上的文件，作用类似于vscode插件<code>remote ssh</code>，让我们可以用浏览器，在任何电脑、<strong>平板</strong>上进行远程开发，无须下载vscode客户端或者ssh软件！</p><p><img                       lazyload                     alt="image"                     data-src="https://img1.musnow.top/i/2023/03/6409edd1712e7.png"                      alt="image-20230309223145036"                ></p><h2 id="1-1-官方的vscode-server"><a href="#1-1-官方的vscode-server" class="headerlink" title="1.1 官方的vscode-server?"></a>1.1 官方的vscode-server?</h2><p>微软官方确实有一个vscode-server，在官网可以下载。我测试了之后，发现它是打了一个隧道，通过<code>vscode.dev</code>的子域名访问，会转发到你的主机上。</p><p><img                       lazyload                     alt="image"                     data-src="https://img1.musnow.top/i/2023/03/6409f5464d748.png"                      alt="image-20230309230334118"                ></p><p>在我这里的测试，<strong>发现压根连不上微软的服务器</strong>。想想其实也很正常，因为vscode-server的文档页面连中文都没有，再加上微软的服务器，国内用不了也是意料之中</p><h1 id="2-安装"><a href="#2-安装" class="headerlink" title="2.安装"></a>2.安装</h1><h2 id="2-1-下载安装包"><a href="#2-1-下载安装包" class="headerlink" title="2.1 下载安装包"></a>2.1 下载安装包</h2><p>截至本文创作时间<code>23-03-09</code>，code-server的最新版本是<code>4.10.1</code>，可以用下面的命令获取到linux下的安装包</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget https://github.com/cdr/code-server/releases/download/v4.10.1/code-server-4.10.1-linux-amd64.tar.gz </span><br></pre></td></tr></table></figure><p>如果上面这个命令你无法访问，可以去github的releases里面手动下载安装包</p><blockquote><p><a class="link"   href="https://github.com/coder/code-server/releases/" >https://github.com/coder/code-server/releases/<i class="fas fa-external-link-alt"></i></a></p></blockquote><p>我的系统是amd64，即x86架构。在github里面也是找<code>linux amd64</code>的包进行安装</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ uname -a</span><br><span class="line">Linux 1c2261732150 5.10.120 #0 SMP Fri Jan 6 08:05:47 2023 x86_64 x86_64 x86_64 GNU/Linux</span><br></pre></td></tr></table></figure><p>如果你使用的是树莓派等设备，请用<code>uname -a</code>确认你的系统架构，并下载对应的包</p><hr><p>github的release下载慢，可以用下面这个网站加速（用迅雷下，速度起飞）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://doget.nocsdn.com/#/</span><br></pre></td></tr></table></figure><p>下载完成后，将压缩包用xftp传输到服务器上</p><h2 id="2-2-解压"><a href="#2-2-解压" class="headerlink" title="2.2 解压"></a>2.2 解压</h2><p>使用下面的命令解压刚刚下载好的压缩包</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar -zxvf code-server-4.10.1-linux-amd64.tar.gz</span><br></pre></td></tr></table></figure><p>给解压出来的文件夹改个短名字vsc</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mv code-server-4.10.1-linux-amd64 vsc</span><br></pre></td></tr></table></figure><p>cd进入这个文件夹</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cd vsc</span><br></pre></td></tr></table></figure><p><code>ls -l</code>，基本文件如下</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">total 792</span><br><span class="line">drwxr-xr-x   8 muxue muxue   4096 Mar  4 12:26 .</span><br><span class="line">drwx------   6 muxue muxue   4096 Mar  9 22:42 ..</span><br><span class="line">drwxr-xr-x   2 muxue muxue   4096 Mar  4 12:26 bin</span><br><span class="line">drwxr-xr-x   3 muxue muxue   4096 Mar  4 12:26 lib</span><br><span class="line">-rw-r--r--   1 muxue muxue   1084 Mar  3 17:13 LICENSE</span><br><span class="line">drwxr-xr-x 243 muxue muxue  12288 Mar  4 12:26 node_modules</span><br><span class="line">-rw-r--r--   1 muxue muxue 480100 Mar  4 12:26 npm-shrinkwrap.json</span><br><span class="line">drwxr-xr-x   5 muxue muxue   4096 Mar  3 17:13 out</span><br><span class="line">-rw-r--r--   1 muxue muxue   5235 Mar  4 12:24 package.json</span><br><span class="line">-rwxr-xr-x   1 muxue muxue   4877 Mar  3 17:13 postinstall.sh</span><br><span class="line">-rw-r--r--   1 muxue muxue   3056 Mar  3 17:13 README.md</span><br><span class="line">drwxr-xr-x   3 muxue muxue   4096 Mar  3 17:14 src</span><br><span class="line">-rw-r--r--   1 muxue muxue 180977 Mar  3 17:13 ThirdPartyNotices.txt</span><br><span class="line">drwxr-xr-x   2 muxue muxue   4096 Mar  3 17:14 typings</span><br><span class="line">-rw-r--r--   1 muxue muxue  76688 Mar  4 12:26 yarn.lock</span><br></pre></td></tr></table></figure><p>直接进入bin文件夹，我们需要用的可执行文件就在里头</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ ls</span><br><span class="line">code-server</span><br></pre></td></tr></table></figure><p>这个<code>code-server</code>就是我们要的可执行文件</p><h2 id="2-3-启动code-server"><a href="#2-3-启动code-server" class="headerlink" title="2.3 启动code-server"></a>2.3 启动code-server</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">export PASSWORD=&quot;配置一个密码&quot;</span><br><span class="line">code-server --port 8888 --host 0.0.0.0 --auth password</span><br></pre></td></tr></table></figure><p>上面这个命令，启动之后，会创建一个端口为8888的web服务，此时使用<code>ip:8888</code>的方式，应该就可以访问到你的code-server服务了！</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[2023-03-09T14:52:07.081Z] info  Wrote default config file to ~/.config/code-server/config.yaml</span><br><span class="line">[2023-03-09T14:52:07.516Z] info  code-server 4.10.0 ac1fba8bde0c3f29bf6bc27d3d7d75cb2390a7c2</span><br><span class="line">[2023-03-09T14:52:07.517Z] info  Using user-data-dir ~/.local/share/code-server</span><br><span class="line">[2023-03-09T14:52:07.532Z] info  Using config file ~/.config/code-server/config.yaml</span><br><span class="line">[2023-03-09T14:52:07.532Z] info  HTTP server listening on http://0.0.0.0:8888/</span><br><span class="line">[2023-03-09T14:52:07.532Z] info    - Authentication is enabled</span><br><span class="line">[2023-03-09T14:52:07.532Z] info      - Using password from $PASSWORD</span><br><span class="line">[2023-03-09T14:52:07.532Z] info    - Not serving HTTPS</span><br></pre></td></tr></table></figure><p>出现下面的页面，那就是安装成功了！输入你刚刚设置的密码，就可以像使用vscode一样使用code-server了！</p><p><img                       lazyload                     alt="image"                     data-src="https://img1.musnow.top/i/2023/03/6409f2f7b9a46.png"                      alt="image-20230309225342649"                ></p><h2 id="2-4-配置文件"><a href="#2-4-配置文件" class="headerlink" title="2.4 配置文件"></a>2.4 配置文件</h2><p>首次启动了之后，会在你的用户路径下生成一个<code>.config/code-server</code>文件夹，里面有一个<code>config.yaml</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ ls .config/code-server</span><br><span class="line">config.yaml</span><br></pre></td></tr></table></figure><p>打开这个文件，可以在里面配置code-server的密码，以及https访问。其余的配置项我还没有关注过，可以去看看github上的文档</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">bind-addr: 127.0.0.1:8080</span><br><span class="line">auth: password</span><br><span class="line">password: 64f1881b805917a449d80874</span><br><span class="line">cert: false</span><br></pre></td></tr></table></figure><p>默认的密码巨长，改成你自己的即可。在这里还可以修改默认绑定的ip和端口，后续启动code-server，就不需要手动指定了，直接运行即可</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./code-server</span><br></pre></td></tr></table></figure><h2 id="2-5-tmux后台运行"><a href="#2-5-tmux后台运行" class="headerlink" title="2.5 tmux后台运行"></a>2.5 tmux后台运行</h2><blockquote><p>nohup运行code-server有一点问题，所以要用tmux</p></blockquote><p>如果没有这个软件，先安装</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo yum install tmux</span><br></pre></td></tr></table></figure><p>创建一个新会话，你可以理解为这是一个脱离于bash的独立shell页面，即便当前bash退出了，code-server也不会退出</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tmux new -s vscode_online</span><br></pre></td></tr></table></figure><p>开启新会话后，进入vsc的bin目录，启动code-server，命令是不变的</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./code-server</span><br></pre></td></tr></table></figure><p><img                       lazyload                     alt="image"                     data-src="https://img1.musnow.top/i/2023/03/640a78b909107.png"                      alt="image-20230310082417260"                ></p><p>随后直接关掉当前bash，此时就已经实现了code-server的后台运行</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 接入会话</span></span><br><span class="line">tmux a -t vscode_online</span><br><span class="line"></span><br><span class="line"><span class="comment"># 结束会话</span></span><br><span class="line">tmux kill-session -t vscode_online</span><br></pre></td></tr></table></figure><h1 id="3-一些问题"><a href="#3-一些问题" class="headerlink" title="3.一些问题"></a>3.一些问题</h1><h2 id="3-1-nginx转发遇到1006错误"><a href="#3-1-nginx转发遇到1006错误" class="headerlink" title="3.1 nginx转发遇到1006错误"></a>3.1 nginx转发遇到1006错误</h2><p>我在采用nginx转发的时候，遇到了这个问题</p><p><img                       lazyload                     alt="image"                     data-src="https://img1.musnow.top/i/2023/03/6409e922986ac.png"                      alt="image-20230309221146320"                ></p><p>个人猜测，这大概率是因为我在<code>config.yaml</code>里面配置了<code>code-server</code>的https导致的</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">cert:</span> <span class="literal">false</span> <span class="comment"># 关闭https</span></span><br></pre></td></tr></table></figure><p>将cert修改回false，再次测试，发现还是有这个问题！</p><blockquote><p>实际上，如果你进行了nginx转发，并不需要配置code-server的https</p><p>保持默认的http即可</p></blockquote><hr><p>后来发现是我的nginx转发设置有问题，正确的转发配置如下</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">location</span> / &#123;</span><br><span class="line"><span class="attribute">proxy_pass</span>   http://127.0.0.1:8888;</span><br><span class="line"><span class="attribute">proxy_set_header</span> Host <span class="variable">$host</span>;</span><br><span class="line"><span class="attribute">proxy_set_header</span> Upgrade <span class="variable">$http_upgrade</span>;</span><br><span class="line"><span class="attribute">proxy_set_header</span> Connection upgrade;</span><br><span class="line"><span class="attribute">proxy_set_header</span> Accept-Encoding gzip;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面给出一个https的完整文件！</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">    <span class="attribute">listen</span> <span class="number">443</span> ssl;</span><br><span class="line">    <span class="attribute">server_name</span>  code.musnow.top;  <span class="comment"># 域名</span></span><br><span class="line">    <span class="comment"># 注意文件位置，是从/etc/nginx/下开始算起的</span></span><br><span class="line">    <span class="attribute">ssl_certificate</span> cert/musnow_top.crt; </span><br><span class="line">    <span class="attribute">ssl_certificate_key</span> cert/musnow_top.key;</span><br><span class="line">    <span class="attribute">ssl_session_timeout</span> <span class="number">5m</span>;</span><br><span class="line">    <span class="attribute">ssl_protocols</span> TLSv1 TLSv1.<span class="number">1</span> TLSv1.<span class="number">2</span>;</span><br><span class="line">    <span class="attribute">ssl_ciphers</span> ECDHE-RSA-AES128-GCM-SHA256:HIGH:!aNULL:!MD5:!RC4:!DHE;</span><br><span class="line">    <span class="attribute">ssl_prefer_server_ciphers</span> <span class="literal">on</span>;</span><br><span class="line"></span><br><span class="line">    <span class="attribute">client_max_body_size</span> <span class="number">1024m</span>;</span><br><span class="line"></span><br><span class="line">    <span class="section">location</span> / &#123;</span><br><span class="line">       <span class="attribute">proxy_set_header</span> Host <span class="variable">$host</span>;</span><br><span class="line">        <span class="attribute">proxy_set_header</span> Upgrade <span class="variable">$http_upgrade</span>;</span><br><span class="line">        <span class="attribute">proxy_set_header</span> Connection upgrade;</span><br><span class="line">        <span class="attribute">proxy_set_header</span> Accept-Encoding gzip;</span><br><span class="line">        <span class="comment"># 当下是直接用yum安装的nginx，可以直接用本地ip访问</span></span><br><span class="line">        <span class="attribute">proxy_pass</span> http://127.0.0.1:8888;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment"># 强制重定向</span></span><br><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">    <span class="attribute">listen</span> <span class="number">80</span>; <span class="comment"># 监听80端口</span></span><br><span class="line">    <span class="attribute">server_name</span>  code.musnow.top;  <span class="comment"># 域名</span></span><br><span class="line">    <span class="comment">#把http的域名请求转成https</span></span><br><span class="line">    <span class="attribute">return</span> <span class="number">301</span> https://<span class="variable">$host</span><span class="variable">$request_uri</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-2-C-x2F-C-插件"><a href="#3-2-C-x2F-C-插件" class="headerlink" title="3.2 C&#x2F;C++插件"></a>3.2 C&#x2F;C++插件</h2><p>由于code-server是一个第三方项目，所以一些官方的插件（如pylance）直接在code-server的插件商店里面搜是没有的</p><p>我们需要去微软的vscode官网上下载插件的VSIX文件，使用本地文件的方式进行安装</p><blockquote><p><a class="link"   href="https://marketplace.visualstudio.com/VSCode" >https://marketplace.visualstudio.com/VSCode<i class="fas fa-external-link-alt"></i></a></p></blockquote><p><img                       lazyload                     alt="image"                     data-src="https://img1.musnow.top/i/2023/03/6409f4d54a065.png"                      alt="image-20230309230141057"                ></p><p>不过，pylance用这个办法依旧无法安装。看来有些插件只有官方的vsc才能安装</p><h2 id="3-3-本地文件"><a href="#3-3-本地文件" class="headerlink" title="3.3 本地文件"></a>3.3 本地文件</h2><p>如果你用过vscode的<code>remote-ssh</code>插件连过你这个服务器，用户目录下面会有两个文件夹</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">.vsc</span><br><span class="line">.vscode-server</span><br></pre></td></tr></table></figure><p>这两个文件夹是vscode的插件<code>remote-ssh</code>生成的，和本文安装的code-server无关！</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;部署code-server远程vscode网页，在浏览器上写代码！&lt;/p&gt;</summary>
    
    
    
    <category term="差生文具多" scheme="https://blog.musnow.top/categories/%E5%B7%AE%E7%94%9F%E6%96%87%E5%85%B7%E5%A4%9A/"/>
    
    
    <category term="Linux" scheme="https://blog.musnow.top/tags/Linux/"/>
    
    <category term="vscode" scheme="https://blog.musnow.top/tags/vscode/"/>
    
    <category term="CentOS" scheme="https://blog.musnow.top/tags/CentOS/"/>
    
  </entry>
  
  <entry>
    <title>【Docker】限制已运行容器的Cpu和内存</title>
    <link href="https://blog.musnow.top/2023/03/06/docker/9docker%E9%99%90%E5%88%B6%E5%AE%B9%E5%99%A8Cpu%E5%86%85%E5%AD%98/"/>
    <id>https://blog.musnow.top/2023/03/06/docker/9docker%E9%99%90%E5%88%B6%E5%AE%B9%E5%99%A8Cpu%E5%86%85%E5%AD%98/</id>
    <published>2023-03-06T09:45:33.000Z</published>
    <updated>2023-03-11T11:25:36.258Z</updated>
    
    <content type="html"><![CDATA[<p>docker限制已运行容器的Cpu和内存</p><span id="more"></span><h2 id="1-问题描述"><a href="#1-问题描述" class="headerlink" title="1.问题描述"></a>1.问题描述</h2><p>最近云服务器的内存经常不够用，而且是<strong>莫名其妙</strong>的增多，在腾讯云的控制台里面看，4g的内存占用了3.2g，就卡到连ssh都连不上了</p><blockquote><p>PS: 已换过网络和设备，确认不是网络问题导致无法ssh</p></blockquote><p><img                       lazyload                     alt="image"                     data-src="https://img1.musnow.top/i/2023/03/6405c2f8c3a35.png"                      alt="img"                ></p><p>实在没辙了，只能把我的几个不热门的kook-bot移植到replit白嫖，再限制一下lsky图床docker镜像的内存用量</p><blockquote><p>其实主要是<code>nsfw-api</code>的内存用量，我发现有人故意给我的图床上传h图。lsky后台由于鉴黄不通过，不允许上传，也看不到是谁干的。隔这压力测试呢？</p><p>我的图床基本只对自己的博客使用。开放游客上传，也只是方便大家临时上传一些图片，还请大家手下留情！！！😥</p></blockquote><p>这个操作我做了几次，也算是一个高频操作了。在此记录一下如何更改一个正在运行中容器的内存限制</p><h2 id="2-修改内存限制"><a href="#2-修改内存限制" class="headerlink" title="2.修改内存限制"></a>2.修改内存限制</h2><p>先使用ps命令查看当前容器和对应的id</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker ps</span><br></pre></td></tr></table></figure><p>可以看到，lsky图床和nsfw的镜像分别是第二个和第三个</p><p><img                       lazyload                     alt="image"                     data-src="https://img1.musnow.top/i/2023/03/6405c3777d10c.png"                      alt="image-20230306184202020"                ></p><p>再用stats命令查看当前的状态</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker stats</span><br></pre></td></tr></table></figure><p><img                       lazyload                     alt="image"                     data-src="https://img1.musnow.top/i/2023/03/6405c43bed272.png"                      alt="image-20230306184518474"                ></p><p>可以看到，图床的内存没有进行限制，nsfw的内存已经被限制到了618mb，当前已用565mb，基本要满了</p><p>重启一下容器，发现初始化的时候只需要100mb左右的内存，合计着现在就有人在往图床里面上传图片？🤣🤣🤣</p><p><img                       lazyload                     alt="image"                     data-src="https://img1.musnow.top/i/2023/03/6405c412e1f22.png"                      alt="image-20230306184437446"                ></p><p>这怎么行，直接给它内存限制干到512mb，能省一点内存是一点，不能因为图床导致我服务器卡死。</p><p>修改限制，要使用的是<code>container update</code>命令</p><blockquote><p><a class="link"   href="https://www.yiibai.com/docker/container_update.html#:~:text=docker%20container,update%20%E5%91%BD%E4%BB%A4%E7%94%A8%E4%BA%8E%E6%9B%B4%E6%96%B0%E4%B8%80%E4%B8%AA%E6%88%96%E5%A4%9A%E4%B8%AA%E5%AE%B9%E5%99%A8%E7%9A%84%E9%85%8D%E7%BD%AE%E3%80%82" >参考文档<i class="fas fa-external-link-alt"></i></a></p><table><thead><tr><th>名称,简写</th><th>默认值</th><th>描述</th></tr></thead><tbody><tr><td>–blkio-weight</td><td>0</td><td>阻塞IO(相对权重)，介于<code>10</code>和<code>1000</code>之间，或<code>0</code>禁用(默认为<code>0</code>)</td></tr><tr><td>–cpu-period</td><td>0</td><td>限制CPU CFS(完全公平的调度程序)周期</td></tr><tr><td>–cpu-quota</td><td>0</td><td>限制CPU CFS(完全公平的调度程序)配额</td></tr><tr><td>–cpu-rt-period</td><td>0</td><td>限制CPU实时周期(以微秒为单位)</td></tr><tr><td>–cpu-rt-runtime</td><td>0</td><td>以微秒为单位限制CPU实时运行时间</td></tr><tr><td>–cpu-shares, -c</td><td>0</td><td>CPU份额(相对权重)</td></tr><tr><td>–cpuset-cpus</td><td></td><td>允许执行的CPU(0-3,0)</td></tr><tr><td>–cpuset-mems</td><td></td><td>允许执行的内存率(0-3,0.1)</td></tr><tr><td>–kernel-memory</td><td></td><td>内核内存限制</td></tr><tr><td>–memory, -m</td><td></td><td>内存限制</td></tr><tr><td>–memory-reservation</td><td></td><td>内存软限制</td></tr><tr><td>–memory-swap</td><td></td><td>交换限制等于内存加交换：<code>-1</code>以启用无限制的交换</td></tr><tr><td>–restart</td><td></td><td>重新启动在容器退出时应用的策略</td></tr><tr><td>模板如下</td><td></td><td></td></tr></tbody></table></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker container update 容器名 --memory=&quot;2g&quot;  --memory-swap=&quot;-1&quot;</span><br></pre></td></tr></table></figure><p>上面的命令会限制容器的内存为2gb，交换内存设置为<code>-1</code>（以启用无限制的交换）</p><p>比如我现在想修改nsfw容器的内存限制，应该如下操作</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker container update nsfw-api --memory=&quot;0.5g&quot; </span><br></pre></td></tr></table></figure><p>然后发现报错了</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Error response from daemon: Cannot update container 418fc2a79fa7ad2e637babe17424ee60e9027ef4a7fada3f279864e76bdaaa10: Memory limit should be smaller than already set memoryswap limit, update the memoryswap at the same time</span><br></pre></td></tr></table></figure><p>大概意思是让我们同时更新交换内存</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker container update nsfw-api --memory=&quot;0.5g&quot;  --memory-swap=&quot;-1&quot;</span><br></pre></td></tr></table></figure><p>现在就ok了，执行成功会显示镜像的名字</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nsfw-api</span><br></pre></td></tr></table></figure><p>在<code>stats</code>看一下，发现已经修改成功了</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker stats</span><br></pre></td></tr></table></figure><p><img                       lazyload                     alt="image"                     data-src="https://img1.musnow.top/i/2023/03/6405c73f35462.png"                      alt="image-20230306185809744"                ></p><p>修改其他容器的效果也是一样的，目的已经达到啦！</p><h2 id="3-修改cpu限制"><a href="#3-修改cpu限制" class="headerlink" title="3.修改cpu限制"></a>3.修改cpu限制</h2><p>下面的命令意思是限制容器只能使用主机上两个cpu</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker container update  容器名 --cpus=2</span><br></pre></td></tr></table></figure><p>但我没有理解这个<code>两个cpu</code>是什么含义。考虑到大部分时期，cpu负载都不会很大，暂时先不设置这个了</p><blockquote><p><a class="link"   href="https://www.cnblogs.com/sparkdev/p/8052522.html" >https://www.cnblogs.com/sparkdev/p/8052522.html<i class="fas fa-external-link-alt"></i></a></p><p><a class="link"   href="https://zhuanlan.zhihu.com/p/388012843" >https://zhuanlan.zhihu.com/p/388012843<i class="fas fa-external-link-alt"></i></a></p></blockquote>]]></content>
    
    
    <summary type="html">&lt;p&gt;docker限制已运行容器的Cpu和内存&lt;/p&gt;</summary>
    
    
    
    <category term="docker真好玩" scheme="https://blog.musnow.top/categories/docker%E7%9C%9F%E5%A5%BD%E7%8E%A9/"/>
    
    
    <category term="Docker" scheme="https://blog.musnow.top/tags/Docker/"/>
    
  </entry>
  
  <entry>
    <title>【Linux】修改linux下的时区和系统时间</title>
    <link href="https://blog.musnow.top/2023/03/04/Linux/36linux%E4%BF%AE%E6%94%B9%E6%97%B6%E5%8C%BA/"/>
    <id>https://blog.musnow.top/2023/03/04/Linux/36linux%E4%BF%AE%E6%94%B9%E6%97%B6%E5%8C%BA/</id>
    <published>2023-03-04T01:30:55.000Z</published>
    <updated>2023-03-11T11:25:36.239Z</updated>
    
    <content type="html"><![CDATA[<p>用配置文件，修改linux系统下的时区（所用系统 CentOS8）</p><span id="more"></span><h2 id="1-问题来源"><a href="#1-问题来源" class="headerlink" title="1.问题来源"></a>1.问题来源</h2><p>在linux上使用python的logging模块的时候，发现了一个问题，那就是模块里面的<code>%(asctime)s</code>打印的时间并非东八区的时间，而是格林尼治时间，比东八区的时间少了8小时</p><p>对于日志来说，这怎么行？总不能每次看日志的时候，自己手动给时间加8小时吧！</p><h2 id="2-解决"><a href="#2-解决" class="headerlink" title="2.解决"></a>2.解决</h2><p>百度了一下后，发现是我系统的时区问题。这个Centos系统是用docker安装的，内部的时区没有正常设置</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">date</span><br></pre></td></tr></table></figure><p>通过date命令可以查看系统当前的时间</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Sat Mar  4 01:29:59 UTC 2023</span><br></pre></td></tr></table></figure><p>会发现是3月4日的凌晨1点，但实际上我是在上午9点写下的这篇博客</p><p><img                       lazyload                     alt="image"                     data-src="https://img1.musnow.top/i/2023/03/6402a0423fa7b.png"                      alt="image-20230304093451196"                ></p><p>这就需要我们修改时区了！</p><hr><p>刚开始，我尝试用<code>tzselect</code>命令进行时区的选择，再选择了上海时区后，系统的时间还是有问题。然后发现，需要修改文件配置，才能让时间生效</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">/etc/timezone <span class="comment"># 时区的配置</span></span><br><span class="line">/etc/localtime <span class="comment"># 时间</span></span><br><span class="line">/usr/share/zoneinfo/Asia <span class="comment">#这里边放着亚洲主要城市的时间</span></span><br></pre></td></tr></table></figure><p>而我的系统中，第一个文件压根不存在！</p><p>要用下面的两个命令来修改配置文件（root下执行）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo &quot;Asia/Shanghai&quot; &gt; /etc/timezone</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">rm -rf /etc/localtime</span><br><span class="line">ln -s /usr/share/zoneinfo/Asia/Shanghai /etc/localtime</span><br></pre></td></tr></table></figure><p>修改完毕，再次执行<code>date</code>命令，可以看到时间已经正常了</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Sat Mar  4 09:31:33 CST 2023</span><br></pre></td></tr></table></figure><p>python的logging模块中打印的时间也正常了</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[23-03-04 09:31:39] DEBUG:log.py:debug:9 | test in main</span><br><span class="line">[23-03-04 09:31:39] ERROR:log.py:exception:24 | Exception occurred</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File &quot;/home/kook/code/py-test/log.py&quot;, line 32, in test</span><br><span class="line">    a = 10/0</span><br><span class="line">ZeroDivisionError: division by zero</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;用配置文件，修改linux系统下的时区（所用系统 CentOS8）&lt;/p&gt;</summary>
    
    
    
    <category term="玩上Linux" scheme="https://blog.musnow.top/categories/%E7%8E%A9%E4%B8%8ALinux/"/>
    
    
    <category term="Linux" scheme="https://blog.musnow.top/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>【Python】解决SSL certificate problem unable to get local issuer certificate</title>
    <link href="https://blog.musnow.top/2023/02/24/Python/10ssl%E6%8A%A5%E9%94%99%E8%AF%81%E4%B9%A6%E9%94%99%E8%AF%AF%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95/"/>
    <id>https://blog.musnow.top/2023/02/24/Python/10ssl%E6%8A%A5%E9%94%99%E8%AF%81%E4%B9%A6%E9%94%99%E8%AF%AF%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95/</id>
    <published>2023-02-24T01:19:00.000Z</published>
    <updated>2023-03-12T04:31:19.924Z</updated>
    
    <content type="html"><![CDATA[<p>CentOS8 出现 SSL certificate problem: unable to get local issuer certificate 解决办法</p><span id="more"></span><h1 id="1-错误来源"><a href="#1-错误来源" class="headerlink" title="1.错误来源"></a>1.错误来源</h1><p>我在一个docker安装的<code>Centos8.5</code>系统中启动我自己写的kook机器人时，遇到了下面的bug</p><p><img                       lazyload                     alt="image"                     data-src="https://img1.musnow.top/i/2023/02/63f80f61bd112.png"                      alt="原图"                ></p><p>其大概意思是没有办法获取到本地的<code>issuer certificate</code>。如果你知道证书和CA的含义，那么大概能猜到这个报错是什么意思。</p><blockquote><p>所有站点的ssl证书，都需要经过CA机构的认证和颁发。操作系统会默认<strong>内嵌</strong>已有CA机构的公钥，以用于解密CA颁发的证书中的数字签名。</p></blockquote><p>因为CA机构是内嵌在操作系统本地的，如果一个证书的颁发机构不在本地已有CA中，该站点就会被报不安全。</p><p>而无法获取本地<code>issuer certificate</code>，我猜测意思就是没有办法获取道操作系统内嵌的CA</p><h1 id="2-解决"><a href="#2-解决" class="headerlink" title="2.解决"></a>2.解决</h1><p>刚开始我尝试过通过python的ssl模组取消证书验证、更新本地证书和openssl，都没有解决这个问题。</p><p>在Kook平台<code>khl.py</code>服务器的大佬帮助下，最终定位并解决了这个问题。</p><h2 id="2-1-更新本地ca包"><a href="#2-1-更新本地ca包" class="headerlink" title="2.1 更新本地ca包"></a>2.1 更新本地ca包</h2><p>先 <code>yum install ca-certificates</code>，已经装过的话那就是 <code>yum update ca-certificates</code> 如果不行再 <code>pip3 install certifi</code></p><p>操作完毕上面的步骤，发现本地已经安装了最新版本的<code>ca-certificates</code>，python也有安装<code>certifi</code>包</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">$ yum update ca-certificates</span><br><span class="line">Repository extras is listed more than once in the configuration</span><br><span class="line">Warning: failed loading &#x27;/etc/yum.repos.d/epel.repo&#x27;, skipping.</span><br><span class="line">Last metadata expiration check: 8:42:37 ago on Thu 23 Feb 2023 03:09:14 PM UTC.</span><br><span class="line">Dependencies resolved.</span><br><span class="line">Nothing to do.</span><br><span class="line">Complete!</span><br><span class="line"></span><br><span class="line">$ pip3.10 install  certifi</span><br><span class="line">Defaulting to user installation because normal site-packages is not writeable</span><br><span class="line">Requirement already satisfied: certifi in ./.local/lib/python3.10/site-packages (2022.12.7)</span><br><span class="line"></span><br><span class="line">$ pip3.10 install  certifi -U</span><br><span class="line">Defaulting to user installation because normal site-packages is not writeable</span><br><span class="line">Requirement already satisfied: certifi in ./.local/lib/python3.10/site-packages (2022.12.7)</span><br></pre></td></tr></table></figure><h2 id="2-2-查看本地主机的链接"><a href="#2-2-查看本地主机的链接" class="headerlink" title="2.2 查看本地主机的链接"></a>2.2 查看本地主机的链接</h2><p>于是尝试使用如下命令，看看主机是否能成功连接到<code>kaiheila.cn</code>(kookapp.cn) 并认证ssl证书</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">openssl s_client -connect www.kookapp.cn:443 -showcerts</span><br></pre></td></tr></table></figure><p>输出了如下的信息</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br></pre></td><td class="code"><pre><span class="line">depth=2 C = US, O = DigiCert Inc, OU = www.digicert.com, CN = DigiCert Global Root CA</span><br><span class="line">verify return:1</span><br><span class="line">depth=1 C = US, O = &quot;DigiCert, Inc.&quot;, CN = RapidSSL Global TLS RSA4096 SHA256 2022 CA1</span><br><span class="line">verify return:1</span><br><span class="line">depth=0 CN = *.kookapp.cn</span><br><span class="line">verify return:1</span><br><span class="line">CONNECTED(00000003)</span><br><span class="line">---</span><br><span class="line">Certificate chain</span><br><span class="line"> 0 s:CN = *.kookapp.cn</span><br><span class="line">   i:C = US, O = &quot;DigiCert, Inc.&quot;, CN = RapidSSL Global TLS RSA4096 SHA256 2022 CA1</span><br><span class="line">-----BEGIN CERTIFICATE-----</span><br><span class="line">MIIHkTCCBXmgAwIBAgIQCUlurlf6m1VXsuISNqlT8DANBgkqhkiG9w0BAQsFADBc</span><br><span class="line">MQswCQYDVQQGEwJVUzEXMBUGA1UEChMORGlnaUNlcnQsIEluYy4xNDAyBgNVBAMT</span><br><span class="line">K1JhcGlkU1NMIEdsb2JhbCBUTFMgUlNBNDA5NiBTSEEyNTYgMjAyMiBDQTEwHhcN</span><br><span class="line">MjIwNjE1MDAwMDAwWhcNMjMwNjE1MjM1OTU5WjAXMRUwEwYDVQQDDAwqLmtvb2th</span><br><span class="line">cHAuY24wggEiMA0GCSqGSIb3DQEBAQUAA4IBDwAwggEKAoIBAQDB1uHkQ/oEkGNl</span><br><span class="line">oVa6wHz424VznxL+eUt6AAfNhtIXeone8rtnJqeoDJ24lmBYUrL00tChCp4rdTdd</span><br><span class="line">crqPppDYSEY7+/U0hf39pDrmsGKZeeOu7JvANjtvqLFdXsqe5CnXtxAo5QUXB9gc</span><br><span class="line">kttoLTZZX5O1Gyi6mqDtsFCTaVpsQmZWVcbA21zLAdAZJyUyzM2VyfCUPQHs+VFE</span><br><span class="line">rcmA9SN8nkppLyf00lIHCWR6v9HYC2XgjHN2JX8ARJwTEddhHjvleMc/SlHncU6f</span><br><span class="line">pZ8itWx8NzBL6MwPKEjmHgKp0VYBMY6PHrSR/j/XtgOweodp1JBIr6yLLlyCu/lJ</span><br><span class="line">ksCwMUIZAgMBAAGjggOSMIIDjjAfBgNVHSMEGDAWgBTwnIX9op99j8lou9XUiU0d</span><br><span class="line">vtOQ/zAdBgNVHQ4EFgQUYe6lb4/s4J82aqWfNDaev2MD8k4wIwYDVR0RBBwwGoIM</span><br><span class="line">Ki5rb29rYXBwLmNuggprb29rYXBwLmNuMA4GA1UdDwEB/wQEAwIFoDAdBgNVHSUE</span><br><span class="line">FjAUBggrBgEFBQcDAQYIKwYBBQUHAwIwgZ8GA1UdHwSBlzCBlDBIoEagRIZCaHR0</span><br><span class="line">cDovL2NybDMuZGlnaWNlcnQuY29tL1JhcGlkU1NMR2xvYmFsVExTUlNBNDA5NlNI</span><br><span class="line">QTI1NjIwMjJDQTEuY3JsMEigRqBEhkJodHRwOi8vY3JsNC5kaWdpY2VydC5jb20v</span><br><span class="line">UmFwaWRTU0xHbG9iYWxUTFNSU0E0MDk2U0hBMjU2MjAyMkNBMS5jcmwwPgYDVR0g</span><br><span class="line">BDcwNTAzBgZngQwBAgEwKTAnBggrBgEFBQcCARYbaHR0cDovL3d3dy5kaWdpY2Vy</span><br><span class="line">dC5jb20vQ1BTMIGHBggrBgEFBQcBAQR7MHkwJAYIKwYBBQUHMAGGGGh0dHA6Ly9v</span><br><span class="line">Y3NwLmRpZ2ljZXJ0LmNvbTBRBggrBgEFBQcwAoZFaHR0cDovL2NhY2VydHMuZGln</span><br><span class="line">aWNlcnQuY29tL1JhcGlkU1NMR2xvYmFsVExTUlNBNDA5NlNIQTI1NjIwMjJDQTEu</span><br><span class="line">Y3J0MAkGA1UdEwQCMAAwggF/BgorBgEEAdZ5AgQCBIIBbwSCAWsBaQB3AOg+0No+</span><br><span class="line">9QY1MudXKLyJa8kD08vREWvs62nhd31tBr1uAAABgWbUskcAAAQDAEgwRgIhAL1q</span><br><span class="line">ZKig2NqYtlAVnaXtJ7Tk+OuROrPHGR8t2zyNTb6xAiEAsLL5yuvJ/WtIj0bLwbKR</span><br><span class="line">0/nFe/Juub3aZjrNvUhzZIIAdQA1zxkbv7FsV78PrUxtQsu7ticgJlHqP+Eq76gD</span><br><span class="line">wzvWTAAAAYFm1LJ6AAAEAwBGMEQCIDK3qkxuTUB1Dngycy9/LECyVXjlpi2eJBAC</span><br><span class="line">6oZPJQ/VAiBs1iupiYwavmD2m6QrDzzZrW2MJWx4LMxCtvf6pmN3NwB3ALc++yTf</span><br><span class="line">nE26dfI5xbpY9Gxd/ELPep81xJ4dCYEl7bSZAAABgWbUsnkAAAQDAEgwRgIhAL5v</span><br><span class="line">fkeeQAwowpkUhf0U/Z2fFiL8IY+QsCyED40zw0d1AiEA02UjHM3tztsrMn2xyzmT</span><br><span class="line">kVgXnly/OozP+LjdwdsTa6gwDQYJKoZIhvcNAQELBQADggIBAGdBom7y2NXOZL7K</span><br><span class="line">xtZFBFQCBJrEQOHZvuN4Etkmotb+0aVnrEZ/Qc5+zl86YqURcmOZgPhzSjuVfTvU</span><br><span class="line">sJJ1TkC/tMYofoo1Db7B5yRxQmjEYRNLFAZ8rbP/pd5Js8ZGWW7RcxqG+zebqDDD</span><br><span class="line">2CWvpiJNStu/yjWwdsFXQUwU0XOGUfwJDHD0eSBaa3uclAn3kUqF82l2X9qzvy9E</span><br><span class="line">exGjPOSWyNuksjeScr32OyNUrwo7RUYJU4Ztl8xaiaxcvg7u2/o9WWzPhHMVI6ij</span><br><span class="line">rJbj6Wn+BMe3SMYcR/L+foItjWAuOqOVB7IKO32JgCkP1vyl8AWs0up8ddI/9jn3</span><br><span class="line">px8ii0HphKJnkCPZNmLnnOhFXQjoPy2PRmKqusP0kleJw1ZpQXsQpm3yZqFggyFH</span><br><span class="line">8S4ii83kkHBynC89dlwlBIkF29Ds4mYjau6mZZxE69By7ptvFvcYREYslaRMxd16</span><br><span class="line">6PEf5mp5jBKSiI2iYcP8PQOudhObpkuw+KHz8ntkf++HeluuEiqsKyiyyiXm5dmR</span><br><span class="line">E/9uIUjPcQia5ohs2VpAgOLhLG6yphWCHQ6awFj9q3Ce1Mm5yXyZFvLXWGwoJj6j</span><br><span class="line">CVXAZDchwX4uiHW2fI3GHz1pTPg0L3NE/M2CHnQWJlh9cgOljmaZXCeKmLdA9phD</span><br><span class="line">+NQho5xVElRiF+rijlrkMutS7p1Y</span><br><span class="line">-----END CERTIFICATE-----</span><br><span class="line"> 1 s:C = US, O = &quot;DigiCert, Inc.&quot;, CN = RapidSSL Global TLS RSA4096 SHA256 2022 CA1</span><br><span class="line">   i:C = US, O = DigiCert Inc, OU = www.digicert.com, CN = DigiCert Global Root CA</span><br><span class="line">-----BEGIN CERTIFICATE-----</span><br><span class="line">MIIFyzCCBLOgAwIBAgIQCgWbJfVLPYeUzGYxR3U4ozANBgkqhkiG9w0BAQsFADBh</span><br><span class="line">MQswCQYDVQQGEwJVUzEVMBMGA1UEChMMRGlnaUNlcnQgSW5jMRkwFwYDVQQLExB3</span><br><span class="line">d3cuZGlnaWNlcnQuY29tMSAwHgYDVQQDExdEaWdpQ2VydCBHbG9iYWwgUm9vdCBD</span><br><span class="line">QTAeFw0yMjA1MDQwMDAwMDBaFw0zMTExMDkyMzU5NTlaMFwxCzAJBgNVBAYTAlVT</span><br><span class="line">MRcwFQYDVQQKEw5EaWdpQ2VydCwgSW5jLjE0MDIGA1UEAxMrUmFwaWRTU0wgR2xv</span><br><span class="line">YmFsIFRMUyBSU0E0MDk2IFNIQTI1NiAyMDIyIENBMTCCAiIwDQYJKoZIhvcNAQEB</span><br><span class="line">BQADggIPADCCAgoCggIBAKY5PJhwCX2UyBb1nelu9APen53D5+C40T+BOZfSFaB0</span><br><span class="line">v0WJM3BGMsuiHZX2IHtwnjUhLL25d8tgLASaUNHCBNKKUlUGRXGztuDIeXb48d64</span><br><span class="line">k7Gk7u7mMRSrj+yuLSWOKnK6OGKe9+s6oaVIjHXY+QX8p2I2S3uew0bW3BFpkeAr</span><br><span class="line">LBCU25iqeaoLEOGIa09DVojd3qc/RKqr4P11173R+7Ub05YYhuIcSv8e0d7qN1sO</span><br><span class="line">1+lfoNMVfV9WcqPABmOasNJ+ol0hAC2PTgRLy/VZo1L0HRMr6j8cbR7q0nKwdbn4</span><br><span class="line">Ar+ZMgCgCcG9zCMFsuXYl/rqobiyV+8U37dDScAebZTIF/xPEvHcmGi3xxH6g+dT</span><br><span class="line">CjetOjJx8sdXUHKXGXC9ka33q7EzQIYlZISF7EkbT5dZHsO2DOMVLBdP1N1oUp0/</span><br><span class="line">1f6fc8uTDduELoKBRzTTZ6OOBVHeZyFZMMdi6tA5s/jxmb74lqH1+jQ6nTU2/Mma</span><br><span class="line">hGNxUuJpyhUHezgBA6sto5lNeyqc+3Cr5ehFQzUuwNsJaWbDdQk1v7lqRaqOlYjn</span><br><span class="line">iomOl36J5txTs0wL7etCeMRfyPsmc+8HmH77IYVMUOcPJb+0gNuSmAkvf5QXbgPI</span><br><span class="line">Zursn/UYnP9obhNbHc/9LYdQkB7CXyX9mPexnDNO7pggNA2jpbEarLmZGi4grMmf</span><br><span class="line">AgMBAAGjggGCMIIBfjASBgNVHRMBAf8ECDAGAQH/AgEAMB0GA1UdDgQWBBTwnIX9</span><br><span class="line">op99j8lou9XUiU0dvtOQ/zAfBgNVHSMEGDAWgBQD3lA1VtFMu2bwo+IbG8OXsj3R</span><br><span class="line">VTAOBgNVHQ8BAf8EBAMCAYYwHQYDVR0lBBYwFAYIKwYBBQUHAwEGCCsGAQUFBwMC</span><br><span class="line">MHYGCCsGAQUFBwEBBGowaDAkBggrBgEFBQcwAYYYaHR0cDovL29jc3AuZGlnaWNl</span><br><span class="line">cnQuY29tMEAGCCsGAQUFBzAChjRodHRwOi8vY2FjZXJ0cy5kaWdpY2VydC5jb20v</span><br><span class="line">RGlnaUNlcnRHbG9iYWxSb290Q0EuY3J0MEIGA1UdHwQ7MDkwN6A1oDOGMWh0dHA6</span><br><span class="line">Ly9jcmwzLmRpZ2ljZXJ0LmNvbS9EaWdpQ2VydEdsb2JhbFJvb3RDQS5jcmwwPQYD</span><br><span class="line">VR0gBDYwNDALBglghkgBhv1sAgEwBwYFZ4EMAQEwCAYGZ4EMAQIBMAgGBmeBDAEC</span><br><span class="line">AjAIBgZngQwBAgMwDQYJKoZIhvcNAQELBQADggEBAAfjh/s1f5dDdfm0sNm74/dW</span><br><span class="line">MbbsxfYV1LoTpFt+3MSUWvSbiPQfUkoV57b5rutRJvnPP9mSlpFwcZ3e1nSUbi2o</span><br><span class="line">ITGA7RCOj23I1F4zk0YJm42qAwJIqOVenR3XtyQ2VR82qhC6xslxtNf7f2Ndx2G7</span><br><span class="line">Mem4wpFhyPDT2P6UJ2MnrD+FC//ZKH5/ERo96ghz8VqNlmL5RXo8Ks9rMr/Ad9xw</span><br><span class="line">Y4hyRvAz5920myUffwdUqc0SvPlFnahsZg15uT5HkK48tHR0TLuLH8aRpzh4KJ/Y</span><br><span class="line">p0sARNb+9i1R4Fg5zPNvHs2BbIve0vkwxAy+R4727qYzl3027w9jEFC6HMXRaDc=</span><br><span class="line">-----END CERTIFICATE-----</span><br><span class="line">---</span><br><span class="line">Server certificate</span><br><span class="line">subject=CN = *.kookapp.cn</span><br><span class="line"></span><br><span class="line">issuer=C = US, O = &quot;DigiCert, Inc.&quot;, CN = RapidSSL Global TLS RSA4096 SHA256 2022 CA1</span><br><span class="line"></span><br><span class="line">---</span><br><span class="line">No client certificate CA names sent</span><br><span class="line">Peer signing digest: SHA256</span><br><span class="line">Peer signature type: RSA-PSS</span><br><span class="line">Server Temp Key: X25519, 253 bits</span><br><span class="line">---</span><br><span class="line">SSL handshake has read 3993 bytes and written 392 bytes</span><br><span class="line">Verification: OK</span><br><span class="line">---</span><br><span class="line">New, TLSv1.3, Cipher is TLS_AES_256_GCM_SHA384</span><br><span class="line">Server public key is 2048 bit</span><br><span class="line">Secure Renegotiation IS NOT supported</span><br><span class="line">Compression: NONE</span><br><span class="line">Expansion: NONE</span><br><span class="line">No ALPN negotiated</span><br><span class="line">Early data was not sent</span><br><span class="line">Verify return code: 0 (ok)</span><br><span class="line">---</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>在这里面能看到如下内容</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SSL handshake has read 3993 bytes and written 392 bytes</span><br><span class="line">Verification: OK</span><br></pre></td></tr></table></figure><p>也就是说，我们的本地主机是能成功认证<code>kookapp.cn</code>的ssl证书的，那么问题就出现在python的ssl模块中了！</p><h2 id="2-3-检测python的ssl模块"><a href="#2-3-检测python的ssl模块" class="headerlink" title="2.3 检测python的ssl模块"></a>2.3 检测python的ssl模块</h2><p>python开启一个REPL，输入如下的两行代码</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> ssl</span><br><span class="line">ssl.create_default_context().cert_store_stats()</span><br></pre></td></tr></table></figure><p>输出的内容如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; import ssl</span><br><span class="line">&gt;&gt;&gt; ssl.create_default_context().cert_store_stats()</span><br><span class="line">&#123;&#x27;x509&#x27;: 0, &#x27;crl&#x27;: 0, &#x27;x509_ca&#x27;: 0&#125;</span><br></pre></td></tr></table></figure><p>这里就能看出来问题了，全都是0！难怪说没有办法获取本地的CA</p><p>作为对比，一台<strong>正常的</strong>windows11电脑输出如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; import ssl</span><br><span class="line">&gt;&gt;&gt; ssl.create_default_context().cert_store_stats()</span><br><span class="line">&#123;&#x27;x509&#x27;: 87, &#x27;crl&#x27;: 0, &#x27;x509_ca&#x27;: 84&#125;</span><br></pre></td></tr></table></figure><h2 id="2-4-解决错误"><a href="#2-4-解决错误" class="headerlink" title="2.4 解决错误"></a>2.4 解决错误</h2><p>找到了错误，那就得想办法解决！</p><p>python开启一个REPL，输入如下的两行代码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">import ssl</span><br><span class="line">ssl.get_default_verify_paths()</span><br></pre></td></tr></table></figure><p>输出内容如下，这是本地python查找ca证书的位置</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; import ssl</span><br><span class="line">&gt;&gt;&gt; ssl.get_default_verify_paths()</span><br><span class="line">DefaultVerifyPaths(cafile=None, capath=&#x27;/usr/local/openssl-1.1.1/ssl/certs&#x27;, openssl_cafile_env=&#x27;SSL_CERT_FILE&#x27;, openssl_cafile=&#x27;/usr/local/openssl-1.1.1/ssl/cert.pem&#x27;, openssl_capath_env=&#x27;SSL_CERT_DIR&#x27;, openssl_capath=&#x27;/usr/local/openssl-1.1.1/ssl/certs&#x27;)</span><br></pre></td></tr></table></figure><p>其中<code>/usr/local/openssl-1.1.1/ssl/cert.pem</code>中应该会保存CA的信息</p><p>查看本地的这个文件的内容</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ls /usr/local/openssl-1.1.1/ssl/cert.pem</span><br></pre></td></tr></table></figure><p>好家伙，发现文件压根不存在！</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ls: cannot access &#x27;/usr/local/openssl-1.1.1/ssl/cert.pem&#x27;: No such file or directory</span><br></pre></td></tr></table></figure><p>看看openssl的版本和路径</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">openssl  version -d</span><br></pre></td></tr></table></figure><p>输出如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">OPENSSLDIR: &quot;/etc/pki/tls&quot;</span><br></pre></td></tr></table></figure><p>于是看看这个目录下有没有我们需要的<code>cert.pem</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ ls /etc/pki/tls</span><br><span class="line">cert.pem  certs  ct_log_list.cnf  misc  openssl.cnf  private</span><br></pre></td></tr></table></figure><p>有！那么接下来要做的，就是创建一个软连接，将其弄到&#x2F;usr&#x2F;local中！</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ln -s /etc/pki/tls/cert.pem /usr/local/openssl-1.1.1/ssl/cert.pem</span><br></pre></td></tr></table></figure><h1 id="3-完美！"><a href="#3-完美！" class="headerlink" title="3.完美！"></a>3.完美！</h1><p>做完这一切后，再次运行机器人，这次么有报错了！</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ py3 main.py</span><br><span class="line">[FileManage] load all files</span><br><span class="line">[BOT] Start at: [23-02-24 00:25:29]</span><br><span class="line">[BOT.TASK] fetch_public_channel success</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>也成功响应了命令！</p><p><img                       lazyload                     alt="image"                     data-src="https://img1.musnow.top/i/2023/02/63f812d3abf94.png"                      alt="image-20230224092852118"                ></p><p>似乎这个问题在mac下更常见？由于没有使用过mac设备，本文不解释相关内容</p><p><img                       lazyload                     alt="image"                     data-src="https://img1.musnow.top/i/2023/02/63f81349c99b9.png"                      alt="image-20230224093050205"                ></p><p><img                       lazyload                     alt="image"                     data-src="https://img1.musnow.top/i/2023/03/640d558b80b56.png"                                     ></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;CentOS8 出现 SSL certificate problem: unable to get local issuer certificate 解决办法&lt;/p&gt;</summary>
    
    
    
    <category term="速通Python" scheme="https://blog.musnow.top/categories/%E9%80%9F%E9%80%9APython/"/>
    
    
    <category term="Python" scheme="https://blog.musnow.top/tags/Python/"/>
    
    <category term="CentOS" scheme="https://blog.musnow.top/tags/CentOS/"/>
    
  </entry>
  
  <entry>
    <title>【Nas】绿联安装CentOS8容器</title>
    <link href="https://blog.musnow.top/2023/02/23/nas/10%E7%BB%BF%E8%81%94%E5%AE%89%E8%A3%85centos/"/>
    <id>https://blog.musnow.top/2023/02/23/nas/10%E7%BB%BF%E8%81%94%E5%AE%89%E8%A3%85centos/</id>
    <published>2023-02-23T14:25:57.000Z</published>
    <updated>2023-03-11T11:25:36.235Z</updated>
    
    <content type="html"><![CDATA[<p>绿联安装CentOS8容器</p><span id="more"></span><h1 id="1-创建容器"><a href="#1-创建容器" class="headerlink" title="1.创建容器"></a>1.创建容器</h1><p>先在客户端安装容器，随后用xshell进入绿联的ssh（如何<a class="link"   href="https://www.bilibili.com/video/BV1J84y1C7Zu/?spm_id_from=333.337.search-card.all.click" >开启ssh参考视频<i class="fas fa-external-link-alt"></i></a>）</p><blockquote><p>简单说来，就是在客户端里面开启远程调试，将远程调试的验证码和下面的密码拼起来，就是绿联ssh的root密码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">L#W$%W1uGa</span><br></pre></td></tr></table></figure><p>端口是922，利用putty或者xshell等软件链接（推荐xshell）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh 绿联本地ip:922</span><br></pre></td></tr></table></figure><p>会出现提示框要你输入账户和密码，账户写root，密码用上面拼好的密码，直接复制后，<code>shift+ins</code>粘贴到终端后回车</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">注意，终端内填写密码是不会有任何提示的，需要盲敲</span><br></pre></td></tr></table></figure></blockquote><p>执行如下命令，以<strong>特权模式</strong>创建一个centos容器，并将容器内的22端口映射给主机的22222端口</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">docker run -d \</span><br><span class="line">-p 22222:22 \</span><br><span class="line">--name centos \</span><br><span class="line">--privileged=true \</span><br><span class="line">centos:latest \</span><br><span class="line">/usr/sbin/init</span><br></pre></td></tr></table></figure><p>搞定了之后，进绿联客户端，停止容器运行，设置一个文件路径给容器内部，方便docker容器和nas资料互传（不设置也不是不行）</p><p><img                       lazyload                     alt="image"                     data-src="https://img1.musnow.top/i/2023/02/63f74c586cb56.png"                      alt="image-20230223192152276"                ></p><p>注意，在客户端配置的时候，需要把所有能给的选项（<code>-i -t 高级选项</code>）全都勾上，避免docker安装的centos缺少权限；</p><hr><p>回到绿联的ssh终端，用下面的命令进入容器内部</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker exec -it centos /bin/bash</span><br></pre></td></tr></table></figure><p>你也可以用客户端里面的终端功能，但是那个太简陋了，不太好用。既然都已经能ssh连上绿联了，那完全没必要用客户端</p><h2 id="1-1-判断是否成功以特权模式安装"><a href="#1-1-判断是否成功以特权模式安装" class="headerlink" title="1.1 判断是否成功以特权模式安装"></a>1.1 判断是否成功以特权模式安装</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl </span><br></pre></td></tr></table></figure><p>执行此命令，看看是否有如下输出。如果没有，代表没有成功以特权模式安装。<code>systemctl</code>在linux中很常用，且开启容器的ssh也需要使用此命令！</p><p><img                       lazyload                     alt="image"                     data-src="https://img1.musnow.top/i/2023/02/63f74e0d90e2c.png"                      alt="image-20230223192918079"                ></p><p>如果没能成功使用，请重试上面的步骤</p><h1 id="2-更新软件"><a href="#2-更新软件" class="headerlink" title="2.更新软件"></a>2.更新软件</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum update -y &amp;&amp; yum upgrade -y</span><br></pre></td></tr></table></figure><p>第一次执行此命令的时候，大概率会出现下面的报错</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Error: Failed to download metadata for repo &#x27;appstream&#x27;: Cannot prepare internal mirrorlist</span><br></pre></td></tr></table></figure><p>参考 <a class="link"   href="https://blog.csdn.net/weixin_43252521/article/details/124409151" >Error: Failed to download metadata for repo ‘appstream‘: Cannot prepare internal mirrorlist<i class="fas fa-external-link-alt"></i></a> 博客，用下面的命令解决这个问题</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cd /etc/yum.repos.d/</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sed -i &#x27;s/mirrorlist/#mirrorlist/g&#x27; /etc/yum.repos.d/CentOS-*</span><br><span class="line">sed -i &#x27;s|#baseurl=http://mirror.centos.org|baseurl=http://vault.centos.org|g&#x27; /etc/yum.repos.d/CentOS-*</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum makecache</span><br></pre></td></tr></table></figure><p>执行<code>makecache</code>后，系统会获取一些内容，让后我们重新指向如下命令</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum update -y &amp;&amp; yum upgrade -y</span><br></pre></td></tr></table></figure><p>会进行一连串的更新，直到出现下面的complete窗口，代表成功！</p><p><img                       lazyload                     alt="image"                     data-src="https://img1.musnow.top/i/2023/02/63f74f439f368.png"                      alt="image-20230223193425765"                ></p><p><img                       lazyload                     alt="image"                     data-src="https://img1.musnow.top/i/2023/02/63f74edeaacc9.png"                      alt="image-20230223193247217"                ></p><h1 id="3-ssh链接"><a href="#3-ssh链接" class="headerlink" title="3.ssh链接"></a>3.ssh链接</h1><h2 id="3-1-安装passwd"><a href="#3-1-安装passwd" class="headerlink" title="3.1 安装passwd"></a>3.1 安装passwd</h2><p>一个linux系统，不能ssh链接可不行，我们需要更新一下内容，实现ssh链接</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install passwd</span><br></pre></td></tr></table></figure><p>先安装passwd命令，设置root的密码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">passwd</span><br></pre></td></tr></table></figure><p>会弹出来让你输入密码，盲敲就行</p><h2 id="3-2-安装vim和openssh"><a href="#3-2-安装vim和openssh" class="headerlink" title="3.2 安装vim和openssh"></a>3.2 安装vim和openssh</h2><p>用下面的命令安装vim和openssh</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install vim openssh-server openssh-clients -y</span><br></pre></td></tr></table></figure><p>安装完毕后，修改ssh的配置文件（vim的使用请百度）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/ssh/sshd_config</span><br></pre></td></tr></table></figure><p><strong>取消注释</strong>下面的字段即可开启ssh</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Port 22</span><br><span class="line">ListenAddress 0.0.0.0</span><br><span class="line">ListenAddress ::</span><br><span class="line"></span><br><span class="line">PermitRootLogin yes</span><br><span class="line">PubkeyAuthentication yes</span><br><span class="line">AuthorizedKeysFile .ssh/authorized_keys</span><br></pre></td></tr></table></figure><p>修改好了之后，退出终端；</p><p>用下面的命令重启ssh服务，并设置开机启动ssh</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">systemctl restart sshd.service</span><br><span class="line">systemctl enable sshd.service</span><br></pre></td></tr></table></figure><p>如果一切正常的话，这两个命令应该什么都不会输出！</p><h2 id="3-3-尝试ssh链接"><a href="#3-3-尝试ssh链接" class="headerlink" title="3.3 尝试ssh链接"></a>3.3 尝试ssh链接</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh 绿联本地ip:22222</span><br></pre></td></tr></table></figure><p>会弹出来让你验证登录，到这里就是ok了</p><p><img                       lazyload                     alt="image"                     data-src="https://img1.musnow.top/i/2023/02/63f750c5f3325.png"                      alt="image-20230223194054648"                ></p><h2 id="3-4-配置ls命令颜色"><a href="#3-4-配置ls命令颜色" class="headerlink" title="3.4 配置ls命令颜色"></a>3.4 配置ls命令颜色</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/profile</span><br></pre></td></tr></table></figure><p>在末尾添加如下字段</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">export LS_OPTIONS=&#x27;--color=auto&#x27;</span><br><span class="line">alias ls=&#x27;ls $LS_OPTIONS&#x27;</span><br><span class="line">alias ll=&#x27;ls $LS_OPTIONS -lA&#x27;</span><br></pre></td></tr></table></figure><p>随后重启容器即可</p><h2 id="3-5-配置yum阿狸源"><a href="#3-5-配置yum阿狸源" class="headerlink" title="3.5 配置yum阿狸源"></a>3.5 配置yum阿狸源</h2><p>备份原有源</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar -zcvf CentOS-bk.tar.gz /etc/yum.repos.d/CentOS-*</span><br></pre></td></tr></table></figure><p>看看本地的centos是什么版本</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat /etc/redhat-release</span><br></pre></td></tr></table></figure><p>我这里的版本是8.5</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CentOS Linux release 8.5.2111</span><br></pre></td></tr></table></figure><p>替换阿里源</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">curl -o /etc/yum.repos.d/CentOS-Base.repo http://mirrors.aliyun.com/repo/Centos-8.repo</span><br><span class="line">curl -o /etc/yum.repos.d/epel.repo http://mirrors.aliyun.com/repo/epel-8.repo</span><br></pre></td></tr></table></figure><p>重新生成缓存</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">yum clean all</span><br><span class="line">yum makecache</span><br></pre></td></tr></table></figure><p><img                       lazyload                     alt="image"                     data-src="https://img1.musnow.top/i/2023/02/63f7562e6d44a.png"                      alt="image-20230223200200975"                ></p><p>现在速度快多了！</p><h1 id="开用！"><a href="#开用！" class="headerlink" title="开用！"></a>开用！</h1><p>后续的使用就不再多说拉！既然你想安装centos，想必对linux的了解肯定比我多😂</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;绿联安装CentOS8容器&lt;/p&gt;</summary>
    
    
    
    <category term="捣鼓折腾nas" scheme="https://blog.musnow.top/categories/%E6%8D%A3%E9%BC%93%E6%8A%98%E8%85%BEnas/"/>
    
    
    <category term="CentOS" scheme="https://blog.musnow.top/tags/CentOS/"/>
    
    <category term="nas" scheme="https://blog.musnow.top/tags/nas/"/>
    
  </entry>
  
  <entry>
    <title>【Docker】配置CentOS容器时出现 Error Failed to download metadata for repo &#39;appstream&#39; Cannot prepare internal mirrorlist</title>
    <link href="https://blog.musnow.top/2023/02/23/docker/8docker%E5%AE%89%E8%A3%85centos%E9%81%87%E5%88%B0%E6%8A%A5%E9%94%99/"/>
    <id>https://blog.musnow.top/2023/02/23/docker/8docker%E5%AE%89%E8%A3%85centos%E9%81%87%E5%88%B0%E6%8A%A5%E9%94%99/</id>
    <published>2023-02-23T09:45:33.000Z</published>
    <updated>2023-03-12T03:52:02.657Z</updated>
    
    <content type="html"><![CDATA[<p>本站经常搬运一些其他博主文章，主要是为了持久化访问。避免日后他人删文or原文无法访问；所有搬运的文章都会写明原文地址，并且不会展示本站的<code>copyright_info</code></p><span id="more"></span><p>下文所出现的场景，是我在linux上使用docker安装centos容器时出现的！</p><hr><p>✨在学习使用 docker 技术过程中，基于 centos 镜像自定义新的镜像，其中基础镜像 centos 需要提前安装好 <a class="link"   href="https://so.csdn.net/so/search?q=vim&spm=1001.2101.3001.7020" >vim<i class="fas fa-external-link-alt"></i></a> 和 net-tools，然而在刚开始通过 <code>yum -y install vim</code> 安装 vim 时，便出现了错误提示信息：<br><img                       lazyload                     alt="image"                     data-src="https://img1.musnow.top/i/2023/03/640d4c609da98.png"                                     ></p><pre><code>Error: Failed to download metadata for repo &#39;appstream&#39;: Cannot prepare internal mirrorlist: No URLs in mirrorlist</code></pre><p>✨上面的报错信息意思是，<strong>从仓库 ‘appstream’ 下载元数据失败：由于镜像列表中没有 URL，不能准备内部镜像列表</strong>。</p><h1 id="🥎问题分析："><a href="#🥎问题分析：" class="headerlink" title="🥎问题分析："></a>🥎问题分析：</h1><ul><li>✨第一种可能的情况便是网络连接问题。检查是否可以连接外部网络，可以使用 <code>ping baidu.com</code> 查看是否有丢包情况。如果丢包，则进一步检查网络连接是否正常；如果没有丢包，继续阅读下文</li><li>✨那么第二种情况，便是 CentOS 已经停止维护的问题。2020 年 12 月 8 号，CentOS 官方宣布了停止维护 CentOS Linux 的计划，并推出了 CentOS Stream 项目，CentOS Linux 8 作为 RHEL 8 的复刻版本，生命周期缩短，于 2021 年 12 月 31 日停止更新并停止维护（EOL），</li><li>更多的信息可以查看 <a class="link"   href="https://blog.centos.org/2020/12/future-is-centos-stream/?spm=a2c4g.11186623.0.0.3b005eb35dW2Kg" >CentOS 官方公告<i class="fas fa-external-link-alt"></i></a>。<strong>如果需要更新 CentOS，需要将镜像从 <a class="link"   href="http://mirror.centos.org/" >mirror.centos.org<i class="fas fa-external-link-alt"></i></a> 更改为 <a class="link"   href="https://vault.centos.org/" >vault.centos.org<i class="fas fa-external-link-alt"></i></a></strong></li></ul><h1 id="🥎那么针对上面提到的第二种情况，给出的解决方法如下："><a href="#🥎那么针对上面提到的第二种情况，给出的解决方法如下：" class="headerlink" title="🥎那么针对上面提到的第二种情况，给出的解决方法如下："></a>🥎那么针对上面提到的第二种情况，给出的解决方法如下：</h1><ul><li><p>🔔 <strong>首先</strong>，进入到 yum 的 repos 目录</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cd /etc/yum.repos.d/</span><br></pre></td></tr></table></figure></li><li><p>🔔<strong>其次</strong>，修改 centos 文件内容</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sed -i &#x27;s/mirrorlist/#mirrorlist/g&#x27; /etc/yum.repos.d/CentOS-*</span><br><span class="line">sed -i &#x27;s|#baseurl=http://mirror.centos.org|baseurl=http://vault.centos.org|g&#x27; /etc/yum.repos.d/CentOS-*</span><br></pre></td></tr></table></figure></li><li><p>🔔 <strong>然后</strong>，生成缓存更新（第一次更新，速度稍微有点慢，耐心等待两分钟左右）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum makecache</span><br></pre></td></tr></table></figure></li><li><p>🔔 <strong>最后</strong>，运行 yum update 并重新安装 vim</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">yum update -y</span><br><span class="line">yum -y install vim</span><br></pre></td></tr></table></figure></li></ul><p>🎉<strong>至此，针对第二种情况出现的问题成功解决！</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">原文作者：ReadThroughLife</span><br><span class="line">原文地址：https://blog.csdn.net/weixin_43252521/article/details/124409151</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;本站经常搬运一些其他博主文章，主要是为了持久化访问。避免日后他人删文or原文无法访问；所有搬运的文章都会写明原文地址，并且不会展示本站的&lt;code&gt;copyright_info&lt;/code&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="docker真好玩" scheme="https://blog.musnow.top/categories/docker%E7%9C%9F%E5%A5%BD%E7%8E%A9/"/>
    
    
    <category term="CentOS" scheme="https://blog.musnow.top/tags/CentOS/"/>
    
    <category term="Docker" scheme="https://blog.musnow.top/tags/Docker/"/>
    
  </entry>
  
  <entry>
    <title>【C++】C++11中局部static变量的线程安全问题</title>
    <link href="https://blog.musnow.top/2023/02/20/cpp/29C++11%E5%B1%80%E9%83%A8%E9%9D%99%E6%80%81%E5%8F%98%E9%87%8F%E5%88%9D%E5%A7%8B%E5%8C%96%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E9%97%AE%E9%A2%98/"/>
    <id>https://blog.musnow.top/2023/02/20/cpp/29C++11%E5%B1%80%E9%83%A8%E9%9D%99%E6%80%81%E5%8F%98%E9%87%8F%E5%88%9D%E5%A7%8B%E5%8C%96%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E9%97%AE%E9%A2%98/</id>
    <published>2023-02-20T13:13:46.000Z</published>
    <updated>2023-03-10T14:54:08.274Z</updated>
    
    <content type="html"><![CDATA[<p>C++11中局部static变量的线程安全问题</p><span id="more"></span><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>大家都知道，在C++11标准中，要求局部静态变量初始化具有<a class="link"   href="https://so.csdn.net/so/search?q=%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8&spm=1001.2101.3001.7020" >线程安全<i class="fas fa-external-link-alt"></i></a>性，所以我们可以很容易实现一个线程安全的单例类：</p><pre><code>class Foo&#123;public:    static Foo *getInstance()    &#123;        static Foo s_instance;        return &amp;s_instance;    &#125;private:    Foo() &#123;&#125;&#125;;</code></pre><p>在C++标准中，是这样描述的（在<a class="link"   href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2012/n3337.pdf" >标准草案<i class="fas fa-external-link-alt"></i></a>的6.7节中）：</p><blockquote><p>such a variable is initialized the first time control passes through its declaration; such a variable is considered initialized upon the completion of its initialization. If the initialization exits by throwing an exception, the initialization is not complete, so it will be tried again the next time control enters the declaration. If control enters the declaration concurrently while the variable is being initialized, the concurrent execution shall wait for completion of the initialization. If control re-enters the declaration recursively while the variable is being initialized, the behavior is undefined.</p></blockquote><h1 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h1><p>标准关于局部静态变量初始化，有这么几点要求：</p><ol><li>变量在代码第一次执行到变量声明的地方时初始化。</li><li>初始化过程中发生异常的话视为未完成初始化，未完成初始化的话，需要下次有代码执行到相同位置时再次初始化。</li><li>在当前线程执行到需要初始化变量的地方时，如果有其他线程正在初始化该变量，则阻塞当前线程，直到初始化完成为止。</li><li>如果初始化过程中发生了对初始化的递归调用，则视为未定义行为。</li></ol><p>关于第4点，如果不明白，可以参考以下代码：</p><pre><code>class Bar&#123;public:    static Bar *getInstance()    &#123;        static Bar s_instance;        return &amp;s_instance;    &#125;private:    Bar()    &#123;        getInstance();    &#125;&#125;;</code></pre><h1 id="GCC的实现"><a href="#GCC的实现" class="headerlink" title="GCC的实现"></a>GCC的实现</h1><p>以GCC 7.3.0版本为例，我们来分析GCC是如何实现标准的。</p><h2 id="Foo-getInstance"><a href="#Foo-getInstance" class="headerlink" title="Foo::getInstance()"></a>Foo::getInstance()</h2><p>使用GCC编译后，我们使用gdb将文章开头的<code>Foo::getInstance()</code>反汇编：</p><pre><code>Dump of assembler code for function Foo::getInstance():   0x00005555555546ea &lt;+0&gt;:     push   %rbp   0x00005555555546eb &lt;+1&gt;:     mov    %rsp,%rbp=&gt; 0x00005555555546ee &lt;+4&gt;:     movzbl 0x20092b(%rip),%eax        # 0x555555755020 &lt;_ZGVZN3Foo11getInstanceEvE10s_instance&gt;   0x00005555555546f5 &lt;+11&gt;:    test   %al,%al   0x00005555555546f7 &lt;+13&gt;:    sete   %al   0x00005555555546fa &lt;+16&gt;:    test   %al,%al   0x00005555555546fc &lt;+18&gt;:    je     0x55555555472b &lt;Foo::getInstance()+65&gt;   0x00005555555546fe &lt;+20&gt;:    lea    0x20091b(%rip),%rdi        # 0x555555755020 &lt;_ZGVZN3Foo11getInstanceEvE10s_instance&gt;   0x0000555555554705 &lt;+27&gt;:    callq  0x5555555545b0 &lt;__cxa_guard_acquire@plt&gt;   0x000055555555470a &lt;+32&gt;:    test   %eax,%eax   0x000055555555470c &lt;+34&gt;:    setne  %al   0x000055555555470f &lt;+37&gt;:    test   %al,%al   0x0000555555554711 &lt;+39&gt;:    je     0x55555555472b &lt;Foo::getInstance()+65&gt;   0x0000555555554713 &lt;+41&gt;:    lea    0x2008fe(%rip),%rdi        # 0x555555755018 &lt;_ZZN3Foo11getInstanceEvE10s_instance&gt;   0x000055555555471a &lt;+48&gt;:    callq  0x555555554734 &lt;Foo::Foo()&gt;   0x000055555555471f &lt;+53&gt;:    lea    0x2008fa(%rip),%rdi        # 0x555555755020 &lt;_ZGVZN3Foo11getInstanceEvE10s_instance&gt;   0x0000555555554726 &lt;+60&gt;:    callq  0x5555555545a0 &lt;__cxa_guard_release@plt&gt;   0x000055555555472b &lt;+65&gt;:    lea    0x2008e6(%rip),%rax        # 0x555555755018 &lt;_ZZN3Foo11getInstanceEvE10s_instance&gt;   0x0000555555554732 &lt;+72&gt;:    pop    %rbp   0x0000555555554733 &lt;+73&gt;:    retq   End of assembler dump.</code></pre><p>在<code>+4</code>、<code>+20</code>、<code>+53</code>出现的<code>_ZGVZN3Foo11getInstanceEvE10s_instance</code>使用<code>c++filt</code>分析为<code>guard variable for Foo::getInstance()::s_instance</code>，而<code>+41</code>、<code>+65</code>位置出现的<code>_ZZN3Foo11getInstanceEvE10s_instance</code>则为<code>Foo::getInstance()::s_instance</code>。后者是<code>s_instance</code>这个局部静态变量，前者从名字看就知道是个<code>guard</code>标志变量，用来指示局部静态变量的初始化状态。</p><h3 id="4-18"><a href="#4-18" class="headerlink" title="+4 ~ +18"></a>+4 ~ +18</h3><p>测试<code>guard</code>变量的第一个字节，如果为<code>0</code>，代表<code>s_instance</code>未初始化，进入<code>+27</code>；否则代表<code>s_instance</code>已初始化，进入<code>+65</code>。</p><h3 id="20-～-27"><a href="#20-～-27" class="headerlink" title="+20 ～ +27"></a>+20 ～ +27</h3><p>以<code>guard</code>变量地址作为参数，执行<code>__cxa_guard_acquire</code>函数。</p><h3 id="32-～-39"><a href="#32-～-39" class="headerlink" title="+32 ～ +39"></a>+32 ～ +39</h3><p>测试返回值，如果为<code>0</code>，代表<code>s_instance</code>已初始化，进入<code>+65</code>；否则代表<code>s_instance</code>未初始化，进入<code>+41</code>。</p><h3 id="41-～-48"><a href="#41-～-48" class="headerlink" title="+41 ～ +48"></a>+41 ～ +48</h3><p>初始化<code>s_instance</code></p><h3 id="53-～-60"><a href="#53-～-60" class="headerlink" title="+53 ～ +60"></a>+53 ～ +60</h3><p>以<code>guard</code>变量地址作为参数，执行<code>__cxa_guard_release</code>函数。</p><h3 id="65-～-73"><a href="#65-～-73" class="headerlink" title="+65 ～ +73"></a>+65 ～ +73</h3><p>返回<code>s_instance</code>地址</p><h2 id="cxa-guard-acquire"><a href="#cxa-guard-acquire" class="headerlink" title="__cxa_guard_acquire"></a>__cxa_guard_acquire</h2><p>我们来看看<code>__cxa_guard_acquire</code>这个函数具体做了什么，该函数代码位于<code>gcc-7-7.3.0/gcc-7.3.0/libstdc++-v3/libsupc++/guard.cc</code>。由于这个函数针对不同平台做了不同的实现，有些我们不需要的代码，以我机器的设置，支持线程和futex系统调用，所以删除了一些不相关的代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> __cxa_guard_acquire (__guard *g)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// If the target can reorder loads, we need to insert a read memory</span></span><br><span class="line">    <span class="comment">// barrier so that accesses to the guarded variable happen after the</span></span><br><span class="line">    <span class="comment">// guard test.</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1</span></span><br><span class="line">    <span class="keyword">if</span> (_GLIBCXX_GUARD_TEST_AND_ACQUIRE (g))</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// If __atomic_* and futex syscall are supported, don&#x27;t use any global</span></span><br><span class="line">    <span class="comment">// mutex.</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2</span></span><br><span class="line">    <span class="keyword">if</span> (__gthread_active_p ())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> *gi = (<span class="type">int</span> *) (<span class="type">void</span> *) g;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3</span></span><br><span class="line">        <span class="type">const</span> <span class="type">int</span> guard_bit = _GLIBCXX_GUARD_BIT;</span><br><span class="line">        <span class="type">const</span> <span class="type">int</span> pending_bit = _GLIBCXX_GUARD_PENDING_BIT;</span><br><span class="line">        <span class="type">const</span> <span class="type">int</span> waiting_bit = _GLIBCXX_GUARD_WAITING_BIT;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 4</span></span><br><span class="line">            <span class="function"><span class="type">int</span> <span class="title">expected</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br><span class="line">            <span class="keyword">if</span> (__atomic_compare_exchange_n(gi, &amp;expected, pending_bit, <span class="literal">false</span>,</span><br><span class="line">                                            __ATOMIC_ACQ_REL,</span><br><span class="line">                                            __ATOMIC_ACQUIRE))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// This thread should do the initialization.</span></span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 5</span></span><br><span class="line">            <span class="keyword">if</span> (expected == guard_bit)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// Already initialized.</span></span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 6</span></span><br><span class="line">            <span class="keyword">if</span> (expected == pending_bit)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// Use acquire here.</span></span><br><span class="line"></span><br><span class="line">                <span class="comment">// 7</span></span><br><span class="line">                <span class="type">int</span> newv = expected | waiting_bit;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 8</span></span><br><span class="line">                <span class="keyword">if</span> (!__atomic_compare_exchange_n(gi, &amp;expected, newv, <span class="literal">false</span>,</span><br><span class="line">                                                 __ATOMIC_ACQ_REL,</span><br><span class="line">                                                 __ATOMIC_ACQUIRE))</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="comment">// 9</span></span><br><span class="line">                    <span class="keyword">if</span> (expected == guard_bit)</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="comment">// Make a thread that failed to set the</span></span><br><span class="line">                        <span class="comment">// waiting bit exit the function earlier,</span></span><br><span class="line">                        <span class="comment">// if it detects that another thread has</span></span><br><span class="line">                        <span class="comment">// successfully finished initialising.</span></span><br><span class="line">                        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 10</span></span><br><span class="line">                    <span class="keyword">if</span> (expected == <span class="number">0</span>)</span><br><span class="line">                        <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 11</span></span><br><span class="line">                expected = newv;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 12</span></span><br><span class="line">            <span class="built_in">syscall</span> (SYS_futex, gi, _GLIBCXX_FUTEX_WAIT, expected, <span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">acquire</span> (g);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>首先检测<code>guard</code>变量，<code>guard</code>变量等于<code>1</code>的话，直接返回<code>0</code>，代表<code>s_instance</code>已初始化，不需要再次初始化。</li><li>检测是否为多线程环境，如果没有多线程的话，也就没有必要去做额外工作来保证线程安全了。</li><li><code>guard_bit</code>表示<code>s_instance</code>已经初始化成功；<code>pending_bit</code>表示<code>s_instance</code>正在初始化；<code>waiting_bit</code>表示有其他线程正在等待<code>s_instance</code>的初始化。</li><li>使用一个原子操作来检测<code>guard</code>变量是否为<code>0</code>，如果为<code>0</code>，则由当前线程初始化<code>s_instance</code>，把<code>pending_bit</code>写入guard变量，返回<code>1</code>。如果不为<code>0</code>，则将guard当前值写入<code>expected</code>。</li><li>检测<code>expected</code>值是否为<code>guard_bit</code>，如果是，则<code>s_instance</code>已初始化完成，不再需要初始化，返回<code>0</code>。</li><li>检测<code>expected</code>值是否为<code>pending_bit</code>，如果是，说明<code>s_instance</code>正在初始化，且没有其他线程等待初始化。</li><li>将<code>newv</code>变量设置为<code>pending_bit | waiting_bit</code>，表示<code>s_instance</code>正在初始化且有线程正在等待初始化。</li><li>使用一个原子操作来检测<code>guard</code>变量是否为<code>pending_bit</code>，如果不是，说明有其他线程修改了<code>guard</code>变量，需要做进一步检测；如果是，说明没有其他线程修改<code>guard</code>变量，则将<code>pending_bit | waiting_bit</code>写入<code>guard</code>变量。</li><li>如果<code>expected</code>等于<code>guard_bit</code>，说明<code>s_instance</code>被初始化成功，不需要再初始化，返回<code>0</code>。</li><li>如果<code>expected</code>等于<code>0</code>，说明<code>s_instance</code>初始化失败，回到<code>4</code>重新开始检测。</li><li>如果在<code>8</code>中没有其他线程修改过<code>guard</code>变量，将<code>expected</code>设置为<code>pending_bit | waiting_bit</code>，表示<code>s_instance</code>正在初始化且有线程（也就是当前线程）正在等待初始化。</li><li>如果在<code>6</code>处没有进入if分支，说明<code>expected</code>等于<code>pending_bit | waiting_bit</code>，如果进入了if分支，由<code>11</code>可得，此时<code>expected</code>也被修改为了<code>pending_bit | waiting_bit</code>。总之，此时<code>s_instance</code>正在初始化且有线程正在等待初始化。利用<code>futex</code>系统调用，再次检测<code>guard</code>变量是否发生了变化，如果发生了变化，回到<code>4</code>重新开始检测；如果没有发生变化，仍然等于<code>pending_bit | waiting_bit</code>，则挂起当前线程。</li></ol><p>总之，<code>__cxa_guard_acquire</code>要么返回<code>0</code>要么返回<code>1</code>，用来指示<code>s_instance</code>已初始化或未初始化。<code>__cxa_guard_acquire</code>可能会导致当前线程挂起，这发生在<code>s_instance</code>正在初始化的时候。</p><h2 id="cxa-guard-release"><a href="#cxa-guard-release" class="headerlink" title="__cxa_guard_release"></a>__cxa_guard_release</h2><p>由于<code>__cxa_guard_acquire</code>可能导致当前线程挂起，因此需要在<code>s_instance</code>初始化完成后使用将<code>__cxa_guard_release</code>线程唤醒。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> __cxa_guard_release (__guard *g) <span class="keyword">throw</span> ()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// If __atomic_* and futex syscall are supported, don&#x27;t use any global</span></span><br><span class="line">    <span class="comment">// mutex.</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1</span></span><br><span class="line">    <span class="keyword">if</span> (__gthread_active_p ())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> *gi = (<span class="type">int</span> *) (<span class="type">void</span> *) g;</span><br><span class="line">        <span class="type">const</span> <span class="type">int</span> guard_bit = _GLIBCXX_GUARD_BIT;</span><br><span class="line">        <span class="type">const</span> <span class="type">int</span> waiting_bit = _GLIBCXX_GUARD_WAITING_BIT;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2</span></span><br><span class="line">        <span class="type">int</span> old = __atomic_exchange_n (gi, guard_bit, __ATOMIC_ACQ_REL);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3</span></span><br><span class="line">        <span class="keyword">if</span> ((old &amp; waiting_bit) != <span class="number">0</span>)</span><br><span class="line">            <span class="built_in">syscall</span> (SYS_futex, gi, _GLIBCXX_FUTEX_WAKE, INT_MAX);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">set_init_in_progress_flag</span>(g, <span class="number">0</span>);</span><br><span class="line">    _GLIBCXX_GUARD_SET_AND_RELEASE (g);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>检测是否为多线程环境</li><li>使用原子操作将<code>guard</code>变量置为<code>guard_bit</code>，同时获取<code>guard</code>变量原始值。</li><li>如果<code>guard</code>变量原始值包含<code>waiting_bit</code>，说明有线程挂起（或将要调用<code>futex</code>欲使线程挂起），调用<code>futex</code>唤醒挂起的进程。</li></ol><h2 id="cxa-guard-abort"><a href="#cxa-guard-abort" class="headerlink" title="__cxa_guard_abort"></a>__cxa_guard_abort</h2><p>由于<code>s_instance</code>可能初始化失败（本例中并未体现），因此还有一个<code>__cxa_guard_abort</code>函数。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> __cxa_guard_abort (__guard *g) <span class="keyword">throw</span> ()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// If __atomic_* and futex syscall are supported, don&#x27;t use any global</span></span><br><span class="line">    <span class="comment">// mutex.</span></span><br><span class="line">    <span class="keyword">if</span> (__gthread_active_p ())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> *gi = (<span class="type">int</span> *) (<span class="type">void</span> *) g;</span><br><span class="line">        <span class="type">const</span> <span class="type">int</span> waiting_bit = _GLIBCXX_GUARD_WAITING_BIT;</span><br><span class="line">        <span class="type">int</span> old = __atomic_exchange_n (gi, <span class="number">0</span>, __ATOMIC_ACQ_REL);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> ((old &amp; waiting_bit) != <span class="number">0</span>)</span><br><span class="line">            <span class="built_in">syscall</span> (SYS_futex, gi, _GLIBCXX_FUTEX_WAKE, INT_MAX);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">set_init_in_progress_flag</span>(g, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>与<code>__cxa_guard_release</code>基本一致，不同的地方在于会将<code>guard</code>变量置<code>0</code>。</p><h2 id="递归初始化调用"><a href="#递归初始化调用" class="headerlink" title="递归初始化调用"></a>递归初始化调用</h2><p>由于在C++11标准中，初始化如果发生了递归是未定义行为，所以GCC 7.3.0针对是否为<a class="link"   href="https://so.csdn.net/so/search?q=%E5%A4%9A%E7%BA%BF%E7%A8%8B&spm=1001.2101.3001.7020" >多线程<i class="fas fa-external-link-alt"></i></a>环境做了不同的处理。如果是多线程环境，不进行额外处理，会发生死锁；如果是单线程环境，则会抛异常。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// acquire() is a helper function used to acquire guard if thread support is</span></span><br><span class="line"><span class="comment">// not compiled in or is compiled in but not enabled at run-time.</span></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">int</span></span></span><br><span class="line"><span class="function"><span class="title">acquire</span><span class="params">(__guard *g)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// Quit if the object is already initialized.</span></span><br><span class="line">    <span class="keyword">if</span> (_GLIBCXX_GUARD_TEST(g))</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">init_in_progress_flag</span>(g))</span><br><span class="line">        <span class="built_in">throw_recursive_init_exception</span>();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">set_init_in_progress_flag</span>(g, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>看到了GCC如此复杂的实现，我的个人感想是还是不要自己造轮子来保证单例类的线程安全了，想要做到和GCC一样的高效还是比较难的，利用C++11标准的带来的便利就挺好。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">原文作者：imred</span><br><span class="line">原文链接：https://blog.csdn.net/imred/article/details/89069750</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;C++11中局部static变量的线程安全问题&lt;/p&gt;</summary>
    
    
    
    <category term="遇见C++" scheme="https://blog.musnow.top/categories/%E9%81%87%E8%A7%81C/"/>
    
    
    <category term="C++" scheme="https://blog.musnow.top/tags/C/"/>
    
    <category term="C++11" scheme="https://blog.musnow.top/tags/C-11/"/>
    
  </entry>
  
  <entry>
    <title>【Curl】通过curl模拟referer获取到有防盗链的图片</title>
    <link href="https://blog.musnow.top/2023/02/20/tools/15curl%E6%A8%A1%E6%8B%9Freferer%E8%8E%B7%E5%8F%96%E8%B5%84%E6%BA%90/"/>
    <id>https://blog.musnow.top/2023/02/20/tools/15curl%E6%A8%A1%E6%8B%9Freferer%E8%8E%B7%E5%8F%96%E8%B5%84%E6%BA%90/</id>
    <published>2023-02-20T04:20:31.000Z</published>
    <updated>2023-03-11T11:25:36.228Z</updated>
    
    <content type="html"><![CDATA[<p>本文所描述操作仅供学习curl命令，请勿用于盗刷他人图床等违规操作！🙅‍♀️</p><span id="more"></span><h1 id="1-说明"><a href="#1-说明" class="headerlink" title="1.说明"></a>1.说明</h1><p>当我想把51la添加到我的导航站点，却发现它的icon图标有防盗链，禁止空referer访问的；</p><p>这点完全可以理解，为了防止他人盗刷本站的图片，通常我们都需要给图片地址加上防盗链。</p><p><img                       lazyload                     alt="image"                     data-src="https://img1.musnow.top/i/2023/02/63f2fa1399fff.png"                      alt="image-20230220124149093"                ></p><p>其实51la提供了自己的icon，但这里提供的icon像素特别低，只有16*16，在我的导航站点上的显示就没有那么友好了</p><p><img                       lazyload                     alt="image"                     data-src="https://img1.musnow.top/i/2023/02/63f2fb32ccc10.png"                      alt="image-20230220124643681"                ></p><p><img                       lazyload                     alt="image"                     data-src="https://img1.musnow.top/i/2023/02/63f2fb5f7cf73.png"                      alt="image-20230220124728488"                ></p><p>所以我才想把稍微清晰一点的icon图标下载下来</p><h1 id="2-curl使用"><a href="#2-curl使用" class="headerlink" title="2.curl使用"></a>2.curl使用</h1><blockquote><p>参考 <a class="link"   href="https://www.ruanyifeng.com/blog/2019/09/curl-reference.html" >https://www.ruanyifeng.com/blog/2019/09/curl-reference.html<i class="fas fa-external-link-alt"></i></a></p></blockquote><p>要避开这个403访问，需要做的就是给请求头给定一个referer字段，告诉51la的服务器，我是通过他自己的域名访问图标文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">curl \</span><br><span class="line">-H &#x27;Referer: https://v6.51.la/&#x27; \</span><br><span class="line">https://v6-static.51.la/v6-static/202302161047/favicon.ico \</span><br><span class="line">-o favicon.ico</span><br></pre></td></tr></table></figure><p>对上面提到的几个参数做一定解释</p><ul><li>-H设定请求头，需要符号http协议的标准<code>key: value</code></li><li>-o将获取到的内容保存为文件，在后面指定文件名（这里我指定为了<code>favicon.ico</code>）</li></ul><p>在linux下用这个命令，就能成功拉取到51la的站点图片</p><p><img                       lazyload                     alt="image"                     data-src="https://img1.musnow.top/i/2023/02/63f2fb9421523.png"                      alt="image-20230220124820822"                ></p><p>如果不加referer字段，则还是会返回403</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ curl https://v6-static.51.la/v6-static/202302161047/favicon.ico </span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;&lt;title&gt;403 Forbidden&lt;/title&gt;&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;center&gt;&lt;h1&gt;403 Forbidden&lt;/h1&gt;&lt;/center&gt;</span><br><span class="line">&lt;hr&gt;&lt;center&gt;openresty&lt;/center&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;本文所描述操作仅供学习curl命令，请勿用于盗刷他人图床等违规操作！🙅‍♀️&lt;/p&gt;</summary>
    
    
    
    <category term="差生文具多" scheme="https://blog.musnow.top/categories/%E5%B7%AE%E7%94%9F%E6%96%87%E5%85%B7%E5%A4%9A/"/>
    
    
    <category term="Linux" scheme="https://blog.musnow.top/tags/Linux/"/>
    
    <category term="curl" scheme="https://blog.musnow.top/tags/curl/"/>
    
  </entry>
  
  <entry>
    <title>【C++】thread|mutex|atomic|condition_variable</title>
    <link href="https://blog.musnow.top/2023/02/19/cpp/28C++%E7%BA%BF%E7%A8%8B/"/>
    <id>https://blog.musnow.top/2023/02/19/cpp/28C++%E7%BA%BF%E7%A8%8B/</id>
    <published>2023-02-19T15:30:46.000Z</published>
    <updated>2023-03-11T11:25:36.272Z</updated>
    
    <content type="html"><![CDATA[<p>本篇博客，让我们来认识一下C++中的线程操作</p><span id="more"></span><blockquote><p>所用编译器：vs2019</p><p>阅读本文前，建议先了解线程的概念 👉 <a href="https://blog.musnow.top/2022/12/23/note_linux/19%E7%BA%BF%E7%A8%8B%E4%BA%92%E6%96%A5/">线程概念</a></p></blockquote><h1 id="1-基本介绍"><a href="#1-基本介绍" class="headerlink" title="1.基本介绍"></a>1.基本介绍</h1><p>在不同的操作系统，windows、linux、mac上，都会对多线程操作提供自己的系统调用接口</p><p>为什么C++需要封装一个线程？直接用系统的接口不好吗？</p><p>在<a href="https://blog.musnow.top/2022/11/01/note_linux/14%E6%96%87%E4%BB%B6io/#1-%E4%BB%80%E4%B9%88%E6%98%AF%E6%96%87%E4%BB%B6%EF%BC%9F">Linux文件博客</a>中，已经谈过了这一点：对于C++、python、java这些<strong>跨平台</strong>的语言来说，如果直接用系统的接口，是可以实现对应操作的。但是，这样会导致代码<strong>只能在某一个特定平台</strong>，甚至是某一个版本的特定操作系统上才能正常运行，直接与跨平台的特性相违背。</p><p>解决的办法呢，就是对系统的接口套一个语言级别的软件层，<strong>封装系统的接口</strong>。并用<code>条件编译</code>的方式来识别不同的操作系统，已调用不同操作系统的系统接口，以实现跨平台性</p><h1 id="2-thread类"><a href="#2-thread类" class="headerlink" title="2.thread类"></a>2.thread类</h1><blockquote><p><a class="link"   href="https://legacy.cplusplus.com/reference/thread/thread/thread/" >https://legacy.cplusplus.com/reference/thread/thread/thread/<i class="fas fa-external-link-alt"></i></a></p></blockquote><h2 id="2-1-构造-x2F-赋值"><a href="#2-1-构造-x2F-赋值" class="headerlink" title="2.1 构造&#x2F;赋值"></a>2.1 构造&#x2F;赋值</h2><p><img                       lazyload                     alt="image"                     data-src="https://img1.musnow.top/i/2023/02/63f20f5b7be4e.png"                      alt="image-20230219195214155"                ></p><p><img                       lazyload                     alt="image"                     data-src="https://img1.musnow.top/i/2023/02/63f20f5f8605c.png"                      alt="image-20230219200034593"                ></p><p>线程是不允许拷贝构造和赋值重载的，但是其支持<strong>右值引用</strong>的重载（主要是为了匿名对象构造）也支持空构造</p><blockquote><p>右值：无法进行取地址的变量</p></blockquote><h2 id="2-2-get-id"><a href="#2-2-get-id" class="headerlink" title="2.2 get_id"></a>2.2 get_id</h2><p>对于线程而言，比较重要的就是这个id号了，其用于标识线程的唯一性</p><p><img                       lazyload                     alt="image"                     data-src="https://img1.musnow.top/i/2023/02/63f22efb3c6f0.png"                      alt="image-20230219221526489"                ></p><h2 id="2-3-join-x2F-detach"><a href="#2-3-join-x2F-detach" class="headerlink" title="2.3 join&#x2F;detach"></a>2.3 join&#x2F;detach</h2><p>创建好了一个线程，我们需要进行join等待或者detach分离</p><ul><li>如果主线程不需要获取子进程执行的结果，可以直接执行detach</li><li>如果需要等待子线程执行，则执行join</li></ul><p>为什么会产生这两个分歧呢？是因为join等待是有一定消耗的。如果我们不关心线程执行的返回值，应该采用detach尽量减小消耗</p><h2 id="2-4-使用示例"><a href="#2-4-使用示例" class="headerlink" title="2.4 使用示例"></a>2.4 使用示例</h2><p>相比于Linux系统提供的pthread接口，C++的使用方法更加直接</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; a + b &lt;&lt; endl;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="function">thread <span class="title">t1</span><span class="params">(Add, <span class="number">10</span>, <span class="number">20</span>)</span></span>;</span><br><span class="line"><span class="function">thread <span class="title">t2</span><span class="params">(Add, <span class="number">10</span>, <span class="number">30</span>)</span></span>;</span><br><span class="line">t1.<span class="built_in">join</span>();</span><br><span class="line">t2.<span class="built_in">join</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img                       lazyload                     alt="image"                     data-src="https://img1.musnow.top/i/2023/02/63f220e7cf62b.png"                      alt="image-20230219211523002"                ></p><h2 id="2-5-空构造和移动赋值"><a href="#2-5-空构造和移动赋值" class="headerlink" title="2.5 空构造和移动赋值"></a>2.5 空构造和移动赋值</h2><p>如果我们只是定义了一个t1，没有直接调用构造函数指定其要运行的函数（其实是调用了空构造）那么要怎么给这个线程指定函数呢？</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">thread t3;<span class="comment">//调用了空构造</span></span><br></pre></td></tr></table></figure><p>别忘了，虽然线程不支持拷贝构造，但他有移动赋值！</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">thread&amp; <span class="keyword">operator</span>= (thread&amp;&amp; rhs) <span class="keyword">noexcept</span>;</span><br></pre></td></tr></table></figure><p>我们要做的，就是采用匿名对象的方式，赋值给t3</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">thread t3;</span><br><span class="line">t3 = <span class="built_in">thread</span>(Add, <span class="number">20</span>, <span class="number">30</span>);</span><br><span class="line">t3.<span class="built_in">join</span>();</span><br></pre></td></tr></table></figure><p><img                       lazyload                     alt="image"                     data-src="https://img1.musnow.top/i/2023/02/63f22a162f785.png"                      alt="image-20230219215433403"                ></p><h2 id="2-6-joinable"><a href="#2-6-joinable" class="headerlink" title="2.6 joinable"></a>2.6 joinable</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">joinable</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">noexcept</span></span>;</span><br></pre></td></tr></table></figure><p>这个函数的作用是标识一个线程是否还能进行join；下面几种情况，线程不能被join</p><ul><li>只调用了空构造（都没有指定需要运行的函数怎么join等待？）</li><li>被move了（move会将对象变成将亡值，也就是右值）</li><li>该对象已经调用过join或者detach</li></ul><p>如果是在多层函数中调用的线程，那可能join之前就可以判断一下当前对象是否还能join</p><h2 id="2-7-swap-x2F-move"><a href="#2-7-swap-x2F-move" class="headerlink" title="2.7 swap&#x2F;move"></a>2.7 swap&#x2F;move</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">swap</span> <span class="params">(thread&amp; x)</span> <span class="keyword">noexcept</span></span>;</span><br></pre></td></tr></table></figure><p>该成员函数的作用是将另外一个线程切换给当前线程</p><p><img                       lazyload                     alt="image"                     data-src="https://img1.musnow.top/i/2023/02/63f23b7a0ba31.png"                      alt="image-20230219230844481"                ></p><p>其本质就是一个move移动赋值</p><p><img                       lazyload                     alt="image"                     data-src="https://img1.musnow.top/i/2023/02/63f23c727a61c.png"                      alt="image-20230219231249899"                ></p><p>被移动后的线程t3不再<code>joinable</code>，不会运行，也不能被join或detach</p><p><img                       lazyload                     alt="image"                     data-src="https://img1.musnow.top/i/2023/02/63f23bc928163.png"                      alt="image-20230219231000662"                ></p><p>强行join会报错</p><p><img                       lazyload                     alt="image"                     data-src="https://img1.musnow.top/i/2023/02/63f23bf8def67.png"                      alt="image-20230219231048460"                ></p><h2 id="2-8-linux下编译"><a href="#2-8-linux下编译" class="headerlink" title="2.8 linux下编译"></a>2.8 linux下编译</h2><p>由于std是对系统接口进行的封装\</p><p>所以在linux下编译带c++线程库的代码时，需要带上pthread库的选项</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">g++ test.cpp -o test -std=c++11 -lpthread</span><br></pre></td></tr></table></figure><h1 id="3-std-ref"><a href="#3-std-ref" class="headerlink" title="3.std::ref"></a>3.std::ref</h1><p>这里有一个特殊的函数ref，要想知道其作用，我们需要先看下面这个场景</p><h2 id="3-1-引用传参"><a href="#3-1-引用传参" class="headerlink" title="3.1 引用传参"></a>3.1 引用传参</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _CRT_SECURE_NO_WARNINGS 1</span></span><br><span class="line"><span class="comment">//#include &lt;stdio.h&gt;</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Print</span><span class="params">(<span class="type">int</span> n,<span class="type">int</span>&amp; a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; this_thread::<span class="built_in">get_id</span>() &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt;  a++ &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line"><span class="function">thread <span class="title">t1</span><span class="params">(Print,<span class="number">10</span>, count)</span></span>;</span><br><span class="line"><span class="function">thread <span class="title">t2</span><span class="params">(Print,<span class="number">10</span>, count)</span></span>;</span><br><span class="line">t1.<span class="built_in">join</span>();</span><br><span class="line">t2.<span class="built_in">join</span>();</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;main: &quot;</span> &lt;&lt; count &lt;&lt; endl;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个场景中，我想达到的目标是让t1和t2两个线程帮我们对count进行++，最终在main里面打印结果；可编译会发现报错，不给我们这样写</p><p><img                       lazyload                     alt="image"                     data-src="https://img1.musnow.top/i/2023/02/63f1fbf492ae1.png"                      alt="image-20230219183743136"                ></p><p>相同的代码在linux下也出现了编译错误，所用g++版本如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">g++ (GCC) 11.2.1 20220127 (Red Hat 11.2.1-9)</span><br></pre></td></tr></table></figure><p><img                       lazyload                     alt="image"                     data-src="https://img1.musnow.top/i/2023/02/63f1e519b4676.png"                      alt="image-20230219170012180"                ></p><p>为了确认具体的报错位置，我们先把<code>int&amp; a</code>的引用去掉，再看看情况</p><p><img                       lazyload                     alt="image"                     data-src="https://img1.musnow.top/i/2023/02/63f19d78e1d62.png"                      alt="image-20230219115434795"                ></p><p>能看到，在没有采用<strong>引用传参</strong>的情况下，函数中对count进行的操作并不会反馈到main中，因为采用的是<strong>传值</strong>，会进行拷贝。</p><h2 id="3-2-thread构造函数"><a href="#3-2-thread构造函数" class="headerlink" title="3.2 thread构造函数"></a>3.2 thread构造函数</h2><p>那为什么加上引用之后，会报错呢？这就和thread的构造函数有关系了</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">Fn</span>, <span class="keyword">class</span>... Args&gt;</span><br><span class="line"><span class="function"><span class="keyword">explicit</span> <span class="title">thread</span> <span class="params">(Fn&amp;&amp; fn, Args&amp;&amp;... args)</span></span>;</span><br></pre></td></tr></table></figure><p>如上，当我们构造一个线程对象的时候，采用的是<a href="https://blog.musnow.top/2022/09/28/note_cpp/20c++11%E7%89%B9%E6%80%A7/#7-%E5%8F%AF%E5%8F%98%E6%A8%A1%E6%9D%BF%E5%8F%82%E6%95%B0">可变模板参数</a>；在我的博客中写到过，可变模板参数需要采用<code>递归</code>来进行参数类型的推测。</p><p>由于底层实现的问题（也只能是这个原因了）在进行构造的完美转发时，所有的参数都采用了<code>拷贝</code>而不是引用传参。</p><p>这也就导致我们没有办法将一个参数通过<strong>引用</strong>传入线程需要执行的函数！</p><blockquote><p>用指针肯定是可以的，可C++搞出引用这个东西，就是为了避免使用指针</p></blockquote><h2 id="3-3-ref出场"><a href="#3-3-ref出场" class="headerlink" title="3.3 ref出场"></a>3.3 ref出场</h2><blockquote><p><a class="link"   href="https://legacy.cplusplus.com/reference/functional/ref/?kw=ref" >https://legacy.cplusplus.com/reference/functional/ref/?kw=ref<i class="fas fa-external-link-alt"></i></a></p></blockquote><p>于是乎，std库中就新增了一个库函数<code>ref</code>，来解决这个问题</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ref的用法</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt; <span class="function">reference_wrapper&lt;T&gt; <span class="title">ref</span> <span class="params">(T&amp; elem)</span> <span class="keyword">noexcept</span></span>;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt; <span class="function">reference_wrapper&lt;T&gt; <span class="title">ref</span> <span class="params">(reference_wrapper&lt;T&gt;&amp; x)</span> <span class="keyword">noexcept</span></span>;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt; <span class="function"><span class="type">void</span> <span class="title">ref</span> <span class="params">(<span class="type">const</span> T&amp;&amp;)</span> </span>= <span class="keyword">delete</span>;</span><br></pre></td></tr></table></figure><blockquote><p>Constructs an object of the appropriate <a class="link"   href="https://legacy.cplusplus.com/reference_wrapper" >reference_wrapper<i class="fas fa-external-link-alt"></i></a> type to hold a reference to elem.</p><p>If the argument is itself a <a class="link"   href="https://legacy.cplusplus.com/reference_wrapper" >reference_wrapper<i class="fas fa-external-link-alt"></i></a> <em>(2)</em>, it creates a copy of x instead.</p><p>The function calls the proper <a class="link"   href="https://legacy.cplusplus.com/reference_wrapper" >reference_wrapper<i class="fas fa-external-link-alt"></i></a> constructor.</p></blockquote><p>这个函数会构造一个合适的<code>reference_wrapper</code>对象，来管理一个变量的<strong>引用</strong>。如果参数本身就是<code>reference_wrapper</code>类型，则会调用<code>reference_wrapper</code>的拷贝构造。</p><p>而ref函数不能传递右值，其右值引用的重载是被<code>delete</code>的</p><p><img                       lazyload                     alt="image"                     data-src="https://img1.musnow.top/i/2023/02/63f1e6be2fd55.png"                      alt="image-20230219170711744"                ></p><h2 id="3-4-ref使用"><a href="#3-4-ref使用" class="headerlink" title="3.4 ref使用"></a>3.4 ref使用</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">thread <span class="title">t1</span><span class="params">(Print,<span class="number">10</span>, ref(count))</span></span>;</span><br><span class="line"><span class="function">thread <span class="title">t2</span><span class="params">(Print,<span class="number">10</span>, ref(count))</span></span>;</span><br><span class="line">t1.<span class="built_in">join</span>();</span><br><span class="line">t2.<span class="built_in">join</span>();</span><br></pre></td></tr></table></figure><p>使用了该库函数之后，编译不再报错，main中的值也成功被修改</p><p><img                       lazyload                     alt="image"                     data-src="https://img1.musnow.top/i/2023/02/63f1e573a7d52.png"                      alt="image-20230219170142211"                ></p><p>通过ref传递的参数，也会遵守函数本身的变量规则。如果函数本身没有采用引用传参，则还是调用传值参数，会进行拷贝；</p><p><img                       lazyload                     alt="image"                     data-src="https://img1.musnow.top/i/2023/02/63f1e703647b4.png"                      alt="image-20230219170821981"                ></p><p>为了避免后续出现这种问题，可以给所有对线程的左值传参都带上ref😏比如给两个线程函数传入同一把锁的时候，就需要采用<code>ref</code>进行引用传参</p><h1 id="4-指令重排"><a href="#4-指令重排" class="headerlink" title="4.指令重排"></a>4.指令重排</h1><blockquote><p><a class="link"   href="https://zhuanlan.zhihu.com/p/271701839" >谈谈指令重排 - 知乎<i class="fas fa-external-link-alt"></i></a></p><p><a class="link"   href="https://developer.aliyun.com/article/1155673#:~:text=%E6%8C%87%E4%BB%A4%E9%87%8D%E6%8E%92%E7%9A%84%E6%96%B9%E5%BC%8F%201%20%E7%BC%96%E8%AF%91%E5%99%A8%E4%BC%98%E5%8C%96%20%E9%87%8D%E6%96%B0%E5%AE%89%E6%8E%92%E8%AF%AD%E5%8F%A5%E7%9A%84%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F%202,%E6%8C%87%E4%BB%A4%E5%B9%B6%E8%A1%8C%E9%87%8D%E6%8E%92%20%E5%88%A9%E7%94%A8%E6%8C%87%E4%BB%A4%E7%BA%A7%E5%B9%B6%E8%A1%8C%E6%8A%80%E6%9C%AF%E5%B0%86%E5%A4%9A%E4%B8%AA%E6%8C%87%E4%BB%A4%E5%B9%B6%E8%A1%8C%E6%89%A7%E8%A1%8C%EF%BC%8C%E5%A6%82%E6%9E%9C%E6%8C%87%E4%BB%A4%E4%B9%8B%E5%89%8D%E6%B2%A1%E6%9C%89%E6%95%B0%E6%8D%AE%E4%BE%9D%E8%B5%96%EF%BC%8C%E5%A4%84%E7%90%86%E5%99%A8%E5%8F%AF%E4%BB%A5%E6%94%B9%E5%8F%98%E5%AF%B9%E5%BA%94%E6%9C%BA%E5%99%A8%E6%8C%87%E4%BB%A4%E7%9A%84%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F%203%20%E5%86%85%E5%AD%98%E7%B3%BB%E7%BB%9F%E9%87%8D%E6%8E%92%20%E7%94%B1%E4%BA%8E%E5%A4%84%E7%90%86%E4%BD%BF%E7%94%A8%E7%BC%93%E5%AD%98%E5%92%8C%E8%AF%BB%E5%86%99%E7%BC%93%E5%86%B2%E5%8C%BA%EF%BC%8C%E6%89%80%E4%BB%A5%E5%AE%83%E4%BB%AC%E6%98%AF%E4%B9%B1%E5%BA%8F%E7%9A%84" >面试官: 有了解过指令重排吗，什么是happens-before<i class="fas fa-external-link-alt"></i></a></p></blockquote><h2 id="4-1-什么是重排序"><a href="#4-1-什么是重排序" class="headerlink" title="4.1 什么是重排序"></a>4.1 什么是重排序</h2><p>首先，什么是重排序❓计算机在执行过程中，为了提高性能，会对编译器和编译器做<code>指令重排</code>。</p><p>这么做为啥可以提高性能呢❓</p><p>我们知道计算机在执行的时候都是一个个指令去执行，不同的指令可能操作的硬件不一样，在执行的过程中可能会产生<code>中断</code>。</p><p>打个比方，两个指令a和b他们操作的东西各不相同，如果加载a的时候停顿了，b就加载不到，但是实际上它们互补影响，我也可以先加载b在加载a，所以<code>指令重排</code>是减少停顿的一种方法，这样大大提高了效率。</p><h3 id="4-1-1-指令重排的方式"><a href="#4-1-1-指令重排的方式" class="headerlink" title="4.1.1 指令重排的方式"></a>4.1.1 指令重排的方式</h3><p>指令重排一般分为以下三种</p><ul><li><code>编译器优化</code> 重新安排语句的执行顺序</li><li><code>指令并行重排</code> 利用指令级并行技术将多个指令并行执行，如果指令之前没有数据依赖，处理器可以改变对应机器指令的执行顺序</li><li><code>内存系统重排</code> 由于处理使用缓存和读写缓冲区，所以它们是乱序的</li></ul><p>指令重排可以保证<code>串行语义</code>一致，但是没有义务保证<code>多线程间的语义</code>也一致**。所以在多线程下，指令重排序可能会导致一些问题</p><h2 id="4-2-实际场景"><a href="#4-2-实际场景" class="headerlink" title="4.2 实际场景"></a>4.2 实际场景</h2><p>以懒汉的单例模式为例</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取单例对象</span></span><br><span class="line"><span class="function"><span class="type">static</span> InfoMgr* <span class="title">GetInstance</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (_sp == <span class="literal">nullptr</span>)<span class="comment">//第一次检测保证单例</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function">unique_lock&lt;mutex&gt; <span class="title">lock</span><span class="params">(_mtx)</span></span>;</span><br><span class="line">        <span class="keyword">if</span> (_sp == <span class="literal">nullptr</span>)<span class="comment">//第二次检测保证线程安全</span></span><br><span class="line">        &#123;</span><br><span class="line">            _sp = <span class="keyword">new</span> InfoMgr;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> _sp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一般情况下，<code>new</code>一个新对象，执行的顺序应该是这样的</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">operator new</span><br><span class="line">构造对象</span><br><span class="line">赋值给_sp</span><br></pre></td></tr></table></figure><p>但编译器如果进行了指令重排，可能就会变成这样</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">operator new</span><br><span class="line">赋值给_sp</span><br><span class="line">构造对象</span><br></pre></td></tr></table></figure><p>如果一个线程执行到第二步<code>赋值给_sp</code>的时候，因为时间片到了被切换走了；其他线程来获取单例，就会导致<code>_sp</code>变量是一个已经被赋值了，但是其指向的是<strong>没有初始化的空对象</strong>，这是错误的！</p><h2 id="4-3-可行的解决办法：内存栅栏"><a href="#4-3-可行的解决办法：内存栅栏" class="headerlink" title="4.3 可行的解决办法：内存栅栏"></a>4.3 可行的解决办法：内存栅栏</h2><p>所谓内存栅栏，是系统提供的的接口，用于禁止cpu对指令的优化；</p><blockquote><p><a class="link"   href="https://blog.csdn.net/qq_16498553/article/details/128030833" >https://blog.csdn.net/qq_16498553/article/details/128030833<i class="fas fa-external-link-alt"></i></a></p></blockquote><p>但内存栈栏是系统接口，没有跨平台性；这里只做了解，知道有这个问题即可！</p><hr><p>在一般情况下，我们不需要担心<code>4.2</code>中提到的问题，因为指令优化是有严格规则的，不会对赋值和构造这类指令进行胡乱优化（因为这样优化并不会有效率提升啊）</p><p>但这也需要看具体平台的底层实现了！</p><h1 id="5-获取线程返回值"><a href="#5-获取线程返回值" class="headerlink" title="5.获取线程返回值"></a>5.获取线程返回值</h1><h2 id="5-1-输出型参数"><a href="#5-1-输出型参数" class="headerlink" title="5.1 输出型参数"></a>5.1 输出型参数</h2><p>在C语言中，想获取线程返回值，需要使用输出型参数（C++可以用引用传值）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">Add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b,<span class="type">int</span>&amp; out)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">out = a + b;</span><br><span class="line"><span class="keyword">return</span> out;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test2</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> ret = <span class="number">0</span>;</span><br><span class="line"><span class="function">thread <span class="title">t2</span><span class="params">(Add, <span class="number">10</span>, <span class="number">39</span>, ref(ret))</span></span>;</span><br><span class="line">t2.<span class="built_in">join</span>();</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;main: &quot;</span> &lt;&lt; ret &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img                       lazyload                     alt="image"                     data-src="https://img1.musnow.top/i/2023/02/63f21f423ea1b.png"                      alt="image-20230219210821383"                ></p><h2 id="5-2-lambda"><a href="#5-2-lambda" class="headerlink" title="5.2 lambda"></a>5.2 lambda</h2><p>在C++中，还可以使用lambda表达式，来在<code>main</code>中获取线程的返回值</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">Add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test2</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> ret = <span class="number">0</span>;</span><br><span class="line"><span class="function">thread <span class="title">t1</span><span class="params">([&amp;ret]() &#123; ret = Add(<span class="number">10</span>, <span class="number">29</span>); &#125;)</span></span>;</span><br><span class="line">t1.<span class="built_in">join</span>();</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;main: &quot;</span> &lt;&lt; ret &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img                       lazyload                     alt="image"                     data-src="https://img1.musnow.top/i/2023/02/63f219625e81a.png"                      alt="image-20230219204317460"                ></p><h1 id="6-函数重载问题"><a href="#6-函数重载问题" class="headerlink" title="6.函数重载问题"></a>6.函数重载问题</h1><p>在我测试的时候发现，如果一个函数具有重载，线程是不支持的；</p><p>具体的原因嘛，我猜和线程构造的可变模板参数有关系。</p><p><img                       lazyload                     alt="image"                     data-src="https://img1.musnow.top/i/2023/02/63f22aa4c21de.png"                      alt="img"                ></p><p>百度了一下，解决办法，是给第一个参数传入一个<strong>函数指针</strong>或者fuctional对象，手动指定使用的是哪一个函数。</p><p>当然，还有一个解决办法：线程调用的函数不要有重载😂</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">Add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b,<span class="type">int</span>&amp; out)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">out = a + b;</span><br><span class="line"><span class="keyword">return</span> out;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> tmp = a + b;</span><br><span class="line">cout &lt;&lt; tmp &lt;&lt; endl;;</span><br><span class="line"><span class="keyword">return</span> tmp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test2</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> ret = <span class="number">0</span>;</span><br><span class="line"><span class="comment">// 使用函数指针指定对应的函数</span></span><br><span class="line"><span class="function">thread <span class="title">t2</span><span class="params">(<span class="keyword">static_cast</span>&lt;<span class="type">int</span>(*)(<span class="type">int</span> a, <span class="type">int</span> b, <span class="type">int</span>&amp; out)&gt;(Add), <span class="number">10</span>, <span class="number">39</span>, ref(ret))</span></span>;</span><br><span class="line">t2.<span class="built_in">join</span>();</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;main: &quot;</span> &lt;&lt; ret &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img                       lazyload                     alt="image"                     data-src="https://img1.musnow.top/i/2023/02/63f22bfb930fa.png"                      alt="image-20230219220238736"                ></p><h1 id="7-this-thread"><a href="#7-this-thread" class="headerlink" title="7.this_thread"></a>7.this_thread</h1><p>std库中还用命名空间对线程的一些操作进行了封装</p><p><img                       lazyload                     alt="image"                     data-src="https://img1.musnow.top/i/2023/02/63f3137e63079.png"                      alt="image-20230220143023521"                ></p><ul><li>get_id 获取线程id号（其实线程类里面已经有这个东东了，但是为了方便函数中直接调用，又多开了一个函数）</li><li>yield 放弃自己的时间片</li><li>sleep_until 休眠到一个时间点（比如睡到明天早八）</li><li>sleep_for 休眠一定时间（睡2分钟）</li></ul><p>下面来对后面三个函数做一点解释（第一个就不解释了哈）</p><h2 id="7-1-yield"><a href="#7-1-yield" class="headerlink" title="7.1 yield"></a>7.1 yield</h2><p>yield的作用是让出当前线程的时间片；</p><p>我们知道每一个线程运行时都会有一个自己的时间片，时间片到了，就会进行线程的切换；</p><p>以下面的场景为例</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">volatile</span> <span class="type">bool</span> ready = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">count1m</span><span class="params">(<span class="type">int</span> id)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// 如果main没有设置ready信号，线程会一直让出自己的时间片，不会运行</span></span><br><span class="line"><span class="keyword">while</span> (!ready) </span><br><span class="line">&#123;            </span><br><span class="line">this_thread::<span class="built_in">yield</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 开始运行，++数据</span></span><br><span class="line"><span class="keyword">volatile</span> <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (i=<span class="number">0</span>; i &lt; <span class="number">10000000</span>; i++) </span><br><span class="line">&#123; </span><br><span class="line">; <span class="comment">// 循环体啥都不干</span></span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; id;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test4</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">thread threads[<span class="number">10</span>];</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;创建10个线程 计数\n&quot;</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i) </span><br><span class="line">&#123;</span><br><span class="line">threads[i] = <span class="built_in">thread</span>(count1m, i);</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;创建10个线程 完毕\n&quot;</span>;</span><br><span class="line">ready = <span class="literal">true</span>;<span class="comment">//设置状态，让线程开始运行</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;main set ture: &quot;</span> &lt;&lt; ready &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span>&amp; th : threads) </span><br><span class="line">&#123;</span><br><span class="line">th.<span class="built_in">join</span>();</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;\nmain join 成功&quot;</span> &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行结果</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">创建10个线程 计数</span><br><span class="line">创建10个线程 完毕</span><br><span class="line">main set ture: 1</span><br><span class="line">3746089215</span><br><span class="line">main join 成功</span><br></pre></td></tr></table></figure><p>在这个场景中，每一个线程被设置了task后，都会先进入一个while循环，等待主线程进行ready的设置</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (!ready) </span><br><span class="line">&#123;            </span><br><span class="line">;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时我们就可以在while循环中进行yield让线程<strong>让出自己</strong>的时间片。否则这个线程会一直疯狂访问ready，导致cpu占用提高。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 如果main没有设置ready信号，线程会一直让出自己的时间片，不会运行</span></span><br><span class="line"><span class="keyword">while</span> (!ready) </span><br><span class="line">&#123;            </span><br><span class="line">this_thread::<span class="built_in">yield</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这种<strong>轮询检测</strong>的场景下，使用yield能避免某一个线程长时间占用执行流，解决了其他线程的饥饿问题。</p><h2 id="7-2-sleep-until"><a href="#7-2-sleep-until" class="headerlink" title="7.2 sleep_until"></a>7.2 sleep_until</h2><p>用<a class="link"   href="https://legacy.cplusplus.com/reference/thread/this_thread/sleep_until/" >cplusplus<i class="fas fa-external-link-alt"></i></a>的示例代码来学习使用方法，这里涉及到了多个库函数，详见注释</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;chrono&gt;</span>  <span class="comment">//std::chrono</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iomanip&gt;</span> <span class="comment">//std::put_time</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ctime&gt;</span>   <span class="comment">//std::time_t, std::tm, std::localtime, std::mktime</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 直接把main当作一个线程</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test5</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">time_t</span> tt = chrono::system_clock::<span class="built_in">to_time_t</span>(chrono::system_clock::<span class="built_in">now</span>()); <span class="comment">// 获取当前时间的时间戳</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">tm</span>* ptm = <span class="built_in">localtime</span>(&amp;tt); <span class="comment">// 设置一个tm结构体，从当前时间戳创建</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Current time: &quot;</span> &lt;&lt; <span class="built_in">put_time</span>(ptm, <span class="string">&quot;%X&quot;</span>) &lt;&lt; <span class="string">&#x27;\n&#x27;</span>; <span class="comment">// 打印当前时间</span></span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Waiting for the next minute to begin...\n&quot;</span>;</span><br><span class="line">(ptm-&gt;tm_min)++; <span class="comment">// 设置ptm的min为下一分钟</span></span><br><span class="line">ptm-&gt;tm_sec = <span class="number">0</span>; <span class="comment">// 下一分钟的第0s</span></span><br><span class="line">this_thread::<span class="built_in">sleep_until</span>(chrono::system_clock::<span class="built_in">from_time_t</span>(<span class="built_in">mktime</span>(ptm))); <span class="comment">// 等待下一分钟开始运行</span></span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="built_in">put_time</span>(ptm, <span class="string">&quot;%X&quot;</span>) &lt;&lt; <span class="string">&quot; reached!\n&quot;</span>; <span class="comment">// 再次打印当前时间</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果如下，会等到下一分钟的第0s继续执行</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Current time: 15:13:40</span><br><span class="line">Waiting for the next minute to begin...</span><br><span class="line">15:14:00 reached!</span><br></pre></td></tr></table></figure><h2 id="7-3-sleep-for"><a href="#7-3-sleep-for" class="headerlink" title="7.3 sleep_for"></a>7.3 sleep_for</h2><p>这个函数的作用和windows、linux下都有的sleep函数一样，是睡指定的时间</p><p>需要用std中的<code>chrono</code>模块来指定运行的时间，支持从小时一直到纳秒</p><p><img                       lazyload                     alt="image"                     data-src="https://img1.musnow.top/i/2023/02/63f341a573324.png"                      alt="image-20230220174718938"                ></p><p>示例如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">test6</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">time_t</span> now;</span><br><span class="line"><span class="built_in">time</span>(&amp;now);<span class="comment">//获取当前时间戳</span></span><br><span class="line">cout &lt;&lt; now &lt;&lt; endl;</span><br><span class="line">this_thread::<span class="built_in">sleep_for</span>(chrono::<span class="built_in">seconds</span>(<span class="number">30</span>));<span class="comment">//睡30s</span></span><br><span class="line"><span class="built_in">time</span>(&amp;now);<span class="comment">//获取当前时间戳</span></span><br><span class="line">cout &lt;&lt; now &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，进程确实休眠了30s</p><p><img                       lazyload                     alt="image"                     data-src="https://img1.musnow.top/i/2023/02/63f31fbf07392.png"                      alt="image-20230220152240203"                ></p><h1 id="8-mutex"><a href="#8-mutex" class="headerlink" title="8.mutex"></a>8.mutex</h1><p>有了线程，那肯定离不开锁；关于线程加锁的问题，详见<a href="https://blog.musnow.top/2022/12/23/note_linux/19%E7%BA%BF%E7%A8%8B%E4%BA%92%E6%96%A5/#4-3-%E7%BA%BF%E7%A8%8B%E5%8A%A0%E9%94%81">我的linux博客</a></p><p>这里只对C++中锁的只用方法做一定演示</p><h2 id="8-1-构造"><a href="#8-1-构造" class="headerlink" title="8.1 构造"></a>8.1 构造</h2><p><img                       lazyload                     alt="image"                     data-src="https://img1.musnow.top/i/2023/02/63f3482920bbf.png"                      alt="image-20230220181505745"                ></p><p>锁的构造相对较简单，只有一个无参的构造，其不支持拷贝构造（比如函数传参中，一个锁被拷贝了，就失去了意义）</p><h2 id="8-2-成员函数"><a href="#8-2-成员函数" class="headerlink" title="8.2 成员函数"></a>8.2 成员函数</h2><p>其余成员就是一个锁的基本接口，对应的也是<code>pthread_mutex</code>中的几个接口</p><ul><li>lock 加锁，不能申请锁则阻塞等待</li><li>try_lock 测试是否能申请锁，不能申请则return</li><li>unlock 解锁</li></ul><p><img                       lazyload                     alt="image"                     data-src="https://img1.musnow.top/i/2023/02/63f3486d109dd.png"                      alt="image-20230220181614701"                ></p><h2 id="8-3-场景"><a href="#8-3-场景" class="headerlink" title="8.3 场景"></a>8.3 场景</h2><p>所谓加锁，保护的就是临界资源；比如在下面的代码示例中，全局变量<code>count1</code>就是一个临界资源，其能够被多个执行流访问。</p><p><font color=Red>注意：</font>如果你展开了std命名空间，其中有一个<code>count</code>函数，会和你自己定义的全局<code>count</code>变量冲突。刚开始我就定义了count，发现报错变量不明确。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> TOP 100</span></span><br><span class="line"><span class="keyword">volatile</span> <span class="type">int</span> count1 = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (count1 == TOP)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; this_thread::<span class="built_in">get_id</span>() &lt;&lt; <span class="string">&quot; : &quot;</span> &lt;&lt; count1++ &lt;&lt; endl;</span><br><span class="line">this_thread::<span class="built_in">sleep_for</span>(chrono::<span class="built_in">milliseconds</span>(<span class="number">10</span>));</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; this_thread::<span class="built_in">get_id</span>() &lt;&lt; <span class="string">&quot; : &quot;</span> &lt;&lt; count1 &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test7</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">thread threading[<span class="number">10</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">threading[i] = <span class="built_in">thread</span>(func);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">threading[i].<span class="built_in">join</span>();</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;main: &quot;</span> &lt;&lt; count1 &lt;&lt; endl;</span><br><span class="line">this_thread::<span class="built_in">sleep_for</span>(chrono::<span class="built_in">seconds</span>(<span class="number">2</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试的时候，就能看到一个很明显的冲突结果。31752线程已经++到100了，结果它努力的结果被其他两个线程直接复写；</p><p>当然，这里也有可能是显示器乱序打印的结果。要知道，显示器也是一个临界资源</p><p><img                       lazyload                     alt="image"                     data-src="https://img1.musnow.top/i/2023/02/63f34965d82fb.png"                      alt="image-20230220182023292"                ></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">mutex mtx;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (count1 == TOP)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 加锁的粒度要低</span></span><br><span class="line">mtx.<span class="built_in">lock</span>();</span><br><span class="line">cout &lt;&lt; this_thread::<span class="built_in">get_id</span>() &lt;&lt; <span class="string">&quot; : &quot;</span> &lt;&lt; count1++ &lt;&lt; endl;</span><br><span class="line">mtx.<span class="built_in">unlock</span>();</span><br><span class="line">this_thread::<span class="built_in">sleep_for</span>(chrono::<span class="built_in">milliseconds</span>(<span class="number">10</span>));</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; this_thread::<span class="built_in">get_id</span>() &lt;&lt; <span class="string">&quot; : &quot;</span> &lt;&lt; count1 &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>给访问count的函数添加上锁，就能避免掉上面出现的问题</p><p><img                       lazyload                     alt="image"                     data-src="https://img1.musnow.top/i/2023/02/63f34a2934127.png"                      alt="image-20230220182338849"                ></p><h1 id="9-CAS原子操作"><a href="#9-CAS原子操作" class="headerlink" title="9.CAS原子操作"></a>9.CAS原子操作</h1><p>在系统中，提供了一些指令，来实现原子操作！</p><h2 id="9-1-原理"><a href="#9-1-原理" class="headerlink" title="9.1 原理"></a>9.1 原理</h2><p>Compare And Set（或Compare And Swap），简称CAS。其是解决多线程<strong>并行</strong>情况下使用锁造成性能损耗的一种机制，采用这种<strong>无锁的原子操作</strong>可以实现线程安全，避免加锁的笨重性。</p><p>CAS操作包含三个操作数：内存位置（V）、预期原值（A）、新值(B)</p><p>具体操作流程请看下图：</p><p><img                       lazyload                     alt="image"                     data-src="https://img1.musnow.top/i/2023/02/63f362c326f23.png"                      alt="image-20230220200715839"                ></p><p>如果上面的图看不懂，还可以看下面这个图</p><p><img                       lazyload                     alt="image"                     data-src="https://img1.musnow.top/i/2023/02/63f363eb304d7.png"                      alt="image-20230220201332945"                ></p><p>文字描述如下：</p><ul><li>如果内存位置的值（V）与预期原值（A）相同，处理器会将该位置的值<strong>更新</strong>为新值（B） CAS 操作成功！</li><li>否则，处理器不做任何更改，只需要将<strong>当前位置的值进行返回</strong>即可</li></ul><p>CAS是实现<strong>自旋锁</strong>的基础，CAS 利用CPU指令保证了操作的原子性，以达到锁的效果，循环这个指令，直到成功为止。</p><h2 id="9-2-问题"><a href="#9-2-问题" class="headerlink" title="9.2 问题"></a>9.2 问题</h2><p>CAS也不是万能的，其在如下场景下可能会出现问题</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1.有线程a和b</span><br><span class="line">2.有全局变量，初始值为1</span><br><span class="line">3.线程a先来访问，拿走了初始值1</span><br><span class="line">4.发生线程切换，线程b来访问，拿走初始值1，更新为2，又修改回1</span><br><span class="line">5.发生线程切换，线程a继续访问，此时值依旧是1，线程a会认为没有问题，写入</span><br></pre></td></tr></table></figure><p>你可以看到，在上面的场景中，有一个线程把全局变量修改了之后又改了回去，这时候就没有办法从<strong>取值</strong>判断变量是否还是“原来的那个”了</p><blockquote><p>针对这种情况，java并发包中提供了一个带有标记的原子引用类”AtomicStampedReference”，它可以通过控制变量值的版本来保证CAS的正确性。</p></blockquote><p>C&#x2F;C++中有没有办法解决这个问题呢？我没百度到😂</p><h1 id="10-lock-guard"><a href="#10-lock-guard" class="headerlink" title="10.lock_guard"></a>10.lock_guard</h1><p>人如其名，这个类是一个守护锁。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">Mutex</span>&gt; <span class="keyword">class</span> <span class="title class_">lock_guard</span>;</span><br></pre></td></tr></table></figure><p>其运用了RAII的思路，能在构造的时候加锁，析构的时候解锁。我们就不需要自己操作了。</p><p>毕竟，代码一长起来，一个锁有没有被解开，是真的搞不清楚😥</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">mutex mtx;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test7</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> x = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> n = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> m = <span class="number">1000000</span>;</span><br><span class="line">cin &gt;&gt; n;</span><br><span class="line"><span class="function">vector&lt;thread&gt; <span class="title">threading</span><span class="params">(n)</span></span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">&#123;</span><br><span class="line">threading[i] = <span class="built_in">thread</span>([&amp;]() &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i++)</span><br><span class="line">&#123;</span><br><span class="line">lock_guard&lt;mutex&gt; <span class="built_in">t</span>(mtx);<span class="comment">//自动加锁解锁</span></span><br><span class="line">x++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">&#123;</span><br><span class="line">threading[i].<span class="built_in">join</span>();</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;main: &quot;</span> &lt;&lt; x &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img                       lazyload                     alt="image"                     data-src="https://img1.musnow.top/i/2023/02/63f366f3c1b90.png"                      alt="image-20230220202628663"                ></p><p>如果for循环中需要执行的代码很多，而只有x是临界资源的话，那就需要我们<code>手动控制</code>一下作用域<code>&#123;&#125;</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i++)</span><br><span class="line">&#123;</span><br><span class="line">             <span class="comment">//其他代码</span></span><br><span class="line">             &#123;</span><br><span class="line">                 <span class="function">lock_guard&lt;mutex&gt; <span class="title">t</span><span class="params">(mtx)</span></span>;<span class="comment">//自动加锁解锁</span></span><br><span class="line">   x++;</span><br><span class="line">             &#125;</span><br><span class="line">             <span class="comment">//其他代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="11-unique-lock"><a href="#11-unique-lock" class="headerlink" title="11.unique_lock"></a>11.unique_lock</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">Mutex</span>&gt; <span class="keyword">class</span> <span class="title class_">unique_lock</span>;</span><br></pre></td></tr></table></figure><p>如果你学习过智能指针，那肯定就知道这个命名的含义；</p><p><code>unique_lock</code>是<code>lock_graud</code>的增强版本，其在支持自动加锁解锁的前提下，还支持手动加锁解锁；</p><h2 id="11-1-使用示例"><a href="#11-1-使用示例" class="headerlink" title="11.1 使用示例"></a>11.1 使用示例</h2><p>下面就是一个标准的使用场景</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">threading[i] = <span class="built_in">thread</span>([&amp;]() &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i++)</span><br><span class="line">&#123;</span><br><span class="line">unique_lock&lt;mutex&gt; <span class="built_in">t</span>(mtx);<span class="comment">//自动加锁</span></span><br><span class="line">x++;</span><br><span class="line">t.<span class="built_in">unlock</span>(); <span class="comment">//手动解锁</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 模拟其他工作</span></span><br><span class="line">this_thread::<span class="built_in">sleep_for</span>(chrono::<span class="built_in">milliseconds</span>(<span class="number">100</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 又需要访问临界资源</span></span><br><span class="line">t.<span class="built_in">lock</span>();<span class="comment">// 手动解锁</span></span><br><span class="line">x++;</span><br><span class="line">&#125;<span class="comment">// 出作用域，自动解锁</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2 id="11-2-try-lock"><a href="#11-2-try-lock" class="headerlink" title="11.2 try_lock"></a>11.2 try_lock</h2><p>除了最基础的try_lock之外，这个类还支持for和until，和<code>this_thread</code>中的sleep是一样的含义</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">try_lock</span><br><span class="line">Lock mutex if not locked (public member function )</span><br><span class="line"></span><br><span class="line">try_lock_for</span><br><span class="line">Try to lock mutex during time span (public member function )</span><br><span class="line">加锁一直到指定时间解锁（加锁到明天早八）</span><br><span class="line"></span><br><span class="line">try_lock_until</span><br><span class="line">Try to lock mutex until time point (public member function )</span><br><span class="line">加锁xx时间（加锁100秒，时间到了自动解锁）</span><br></pre></td></tr></table></figure><p>时间到了之后，这个函数会进行解锁。如果用户在这之前已经手动解锁了，则什么都不会做</p><h2 id="11-3-release"><a href="#11-3-release" class="headerlink" title="11.3 release"></a>11.3 release</h2><p>这个函数的作用就很独特了，其将自己管理的锁释放掉，不再管理这个锁</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">mutex_type* <span class="title">release</span><span class="params">()</span> <span class="keyword">noexcept</span></span>;</span><br></pre></td></tr></table></figure><p>调用这个函数会返回托管互斥对象的<strong>指针</strong>，释放其所有权。调用后，unique_lock对象不再管理任何互斥对象（即，它处于与if默认构造相同的状态）。</p><p> 注意，此函数不会<strong>锁定或解锁</strong>返回的互斥对象。</p><p>说人话就是，不需要你RALL来管理这个锁了，交给用户自己管理！</p><h1 id="12-share-ptr"><a href="#12-share-ptr" class="headerlink" title="12.share_ptr"></a>12.share_ptr</h1><blockquote><p><code>share_ptr</code>的完整代码请看我的 <a class="link"   href="https://gitee.com/musnow/learn_cpp_code/tree/master/Cpp/23-02-19%20thread" >Gitee<i class="fas fa-external-link-alt"></i></a></p></blockquote><p>在智能指针中，<code>share_ptr</code>采用引用计数来判断有多少次拷贝（拷贝构造、赋值重载），只有拷贝计数器为1的时候，析构才需要释放资源。</p><p>在<code>share_ptr</code>内部有一个变量进行计数。既然有一个计数变量，那就需要保证多线程执行时的原子性！</p><h2 id="12-1-引用计数加锁"><a href="#12-1-引用计数加锁" class="headerlink" title="12.1 引用计数加锁"></a>12.1 引用计数加锁</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">AddRef</span><span class="params">()</span><span class="comment">//新增引用</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">_pMutex-&gt;<span class="built_in">lock</span>();</span><br><span class="line"></span><br><span class="line">++(*_pRefCount);</span><br><span class="line"></span><br><span class="line">_pMutex-&gt;<span class="built_in">unlock</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="12-2-释放"><a href="#12-2-释放" class="headerlink" title="12.2 释放"></a>12.2 释放</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Release</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">bool</span> flag = <span class="literal">false</span>;<span class="comment">//判断锁是否需要被释放</span></span><br><span class="line"></span><br><span class="line">_pMutex-&gt;<span class="built_in">lock</span>();</span><br><span class="line"><span class="keyword">if</span> (--(*_pRefCount) == <span class="number">0</span> &amp;&amp; _ptr)</span><br><span class="line">&#123;</span><br><span class="line">               <span class="comment">//进入了这个函数，代表引用计数为0</span></span><br><span class="line"><span class="keyword">delete</span> _ptr;</span><br><span class="line"><span class="keyword">delete</span> _pRefCount;</span><br><span class="line"><span class="comment">//标识需要释放锁</span></span><br><span class="line">flag = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">_pMutex-&gt;<span class="built_in">unlock</span>();<span class="comment">//解锁</span></span><br><span class="line"><span class="comment">//释放锁</span></span><br><span class="line"><span class="keyword">if</span> (flag)&#123;</span><br><span class="line"><span class="keyword">delete</span> _pMutex;</span><br><span class="line">           &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="12-3-注意事项"><a href="#12-3-注意事项" class="headerlink" title="12.3 注意事项"></a>12.3 注意事项</h2><p><code>share_ptr</code>的加锁只限于这个类对象本身的安全性，这个锁并<strong>不是</strong>用来保护<code>share_ptr</code>所指向的资源的！</p><h1 id="13-atomic"><a href="#13-atomic" class="headerlink" title="13.atomic"></a>13.atomic</h1><p>在全局变量中，计数器是很常用的类型。所以C++中还提供了一个可以进行原子操作的类，对这个变量进行的操作是具有原子性的，不需要我们进行加锁解锁</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt; <span class="keyword">struct</span> <span class="title class_">atomic</span>;</span><br></pre></td></tr></table></figure><h2 id="13-1-基本使用"><a href="#13-1-基本使用" class="headerlink" title="13.1 基本使用"></a>13.1 基本使用</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">atomic&lt;<span class="type">int</span>&gt; val=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test8</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; val &lt;&lt; endl;</span><br><span class="line">val++;</span><br><span class="line">cout &lt;&lt; val &lt;&lt; endl;</span><br><span class="line">val = <span class="number">20</span>;</span><br><span class="line">cout &lt;&lt; val &lt;&lt; endl;</span><br><span class="line">val--;</span><br><span class="line">cout &lt;&lt; val &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果是int类型，原子变量和普通的int变量的使用没有什么区别！</p><p><img                       lazyload                     alt="image"                     data-src="https://img1.musnow.top/i/2023/02/63f4830c02ad0.png"                      alt="image-20230221163836363"                ></p><p>可以看到，重载了以后，原子变量支持<code>++  --</code>，也支持直接赋值</p><p><img                       lazyload                     alt="image"                     data-src="https://img1.musnow.top/i/2023/02/63f48604478a8.png"                      alt="image-20230221165116759"                ></p><p>不过，这些方法标明了，只有整形家族和指针类型可以使用！</p><p><img                       lazyload                     alt="image"                     data-src="https://img1.musnow.top/i/2023/02/63f4862eea490.png"                      alt="image-20230221165159400"                ></p><h2 id="13-2-operator-x3D"><a href="#13-2-operator-x3D" class="headerlink" title="13.2 operator &#x3D;"></a>13.2 operator &#x3D;</h2><p>原子变量可以直接赋值，是因为其重载了 <code>operator =</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//set value (1)</span></span><br><span class="line">T <span class="keyword">operator</span>= (T val) <span class="keyword">noexcept</span>;</span><br><span class="line">T <span class="keyword">operator</span>= (T val) <span class="keyword">volatile</span> <span class="keyword">noexcept</span>;</span><br><span class="line"><span class="comment">//copy [deleted] (2)</span></span><br><span class="line">atomic&amp; <span class="keyword">operator</span>= (<span class="type">const</span> atomic&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">atomic&amp; <span class="keyword">operator</span>= (<span class="type">const</span> atomic&amp;) <span class="keyword">volatile</span> = <span class="keyword">delete</span>;</span><br></pre></td></tr></table></figure><h2 id="13-3-operator-T-x2F-load"><a href="#13-3-operator-T-x2F-load" class="headerlink" title="13.3 operator T&#x2F;load"></a>13.3 operator T&#x2F;load</h2><p><code>operator T </code>的作用，是支持<strong>隐式类型</strong>转换，这样原子变量在进行if比较的时候，会转换成重载后的类型</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">operator</span> <span class="title">T</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">volatile</span> <span class="keyword">noexcept</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">operator</span> <span class="title">T</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">noexcept</span></span>;</span><br></pre></td></tr></table></figure><p>在vs2019里面跳转源码，能看到重载后的这两个函数，其实是调用了load方法</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">_Ty</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">atomic</span> : _Choose_atomic_base_t&lt;_Ty&gt;&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line"><span class="keyword">operator</span> _Ty() <span class="type">const</span> <span class="keyword">volatile</span> <span class="keyword">noexcept</span> &#123;</span><br><span class="line">        <span class="built_in">static_assert</span>(_Deprecate_non_lock_free_volatile&lt;_Ty&gt;, <span class="string">&quot;Never fails&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>-&gt;<span class="built_in">load</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">operator</span> _Ty() <span class="type">const</span> <span class="keyword">noexcept</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>-&gt;<span class="built_in">load</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img                       lazyload                     alt="image"                     data-src="https://img1.musnow.top/i/2023/02/63f4844ba3f8a.png"                      alt="image-20230221164356074"                ></p><p>查看cplusplus的解释，load方法就是返回了其内部所包含的值</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">T <span class="title">load</span> <span class="params">(memory_order sync = memory_order_seq_cst)</span> <span class="type">const</span> <span class="keyword">volatile</span> <span class="keyword">noexcept</span></span>;</span><br><span class="line"><span class="function">T <span class="title">load</span> <span class="params">(memory_order sync = memory_order_seq_cst)</span> <span class="type">const</span> <span class="keyword">noexcept</span></span>;</span><br></pre></td></tr></table></figure><p><img                       lazyload                     alt="image"                     data-src="https://img1.musnow.top/i/2023/02/63f484917ab03.png"                      alt="image-20230221164506017"                ></p><p>这里还特意标注了，load方法的使用是原子性的</p><h2 id="13-4-exchange"><a href="#13-4-exchange" class="headerlink" title="13.4 exchange"></a>13.4 exchange</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">T <span class="title">exchange</span> <span class="params">(T val, memory_order sync = memory_order_seq_cst)</span> <span class="keyword">volatile</span> <span class="keyword">noexcept</span></span>;</span><br><span class="line"><span class="function">T <span class="title">exchange</span> <span class="params">(T val, memory_order sync = memory_order_seq_cst)</span> <span class="keyword">noexcept</span></span>;</span><br></pre></td></tr></table></figure><p><code>exchange</code>函数的作用是修改原子变量管理的值，其返回值是<strong>修改之前</strong>的变量</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Return value</span><br><span class="line">The contained value before the call.</span><br><span class="line">T is atomic&#x27;s template parameter (the type of the contained value).</span><br></pre></td></tr></table></figure><p>以下面的代码为例</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">atomic&lt;<span class="type">int</span>&gt; val=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test8</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; val &lt;&lt; endl;</span><br><span class="line"><span class="type">int</span> tmp = val.<span class="built_in">exchange</span>(<span class="number">450</span>);</span><br><span class="line">cout &lt;&lt; val &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; tmp &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到tmp接收到的结果是val的初始值0，val本身被修改为450</p><p><img                       lazyload                     alt="image"                     data-src="https://img1.musnow.top/i/2023/02/63f48556ad15c.png"                      alt="image-20230221164823139"                ></p><h2 id="13-5-store"><a href="#13-5-store" class="headerlink" title="13.5 store"></a>13.5 store</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">store</span> <span class="params">(T val, memory_order sync = memory_order_seq_cst)</span> <span class="keyword">volatile</span> <span class="keyword">noexcept</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">store</span> <span class="params">(T val, memory_order sync = memory_order_seq_cst)</span> <span class="keyword">noexcept</span></span>;</span><br></pre></td></tr></table></figure><p>这个函数的作用比exchange简单，其只修改存储的变量，没有返回值</p><hr><p>关于原子变量的介绍就这么多，下面来康康C++中的条件变量</p><h1 id="14-condition-variable"><a href="#14-condition-variable" class="headerlink" title="14.condition_variable"></a>14.condition_variable</h1><blockquote><p>条件变量的概念，参考 <a href="https://blog.musnow.top/2022/12/30/note_linux/20%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5/">linux 线程同步</a></p></blockquote><h2 id="14-1-构造和wait"><a href="#14-1-构造和wait" class="headerlink" title="14.1 构造和wait"></a>14.1 构造和wait</h2><p>条件变量，是用于线程同步操作的一个接口。在C++中，条件变量只有一个空构造</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//default (1)</span></span><br><span class="line"><span class="built_in">condition_variable</span>();</span><br><span class="line"><span class="comment">//copy [deleted] (2)</span></span><br><span class="line"><span class="built_in">condition_variable</span> (<span class="type">const</span> condition_variable&amp;) = <span class="keyword">delete</span>;</span><br></pre></td></tr></table></figure><p>当我们进行wait等待的时候，需要往条件变量内传入一个锁；进入wait函数，开始等待前会先解锁，退出函数前会加锁。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//unconditional (1)</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">wait</span> <span class="params">(unique_lock&lt;mutex&gt;&amp; lck)</span></span>;</span><br><span class="line"><span class="comment">//predicate (2)</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">Predicate</span>&gt;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">wait</span> <span class="params">(unique_lock&lt;mutex&gt;&amp; lck, Predicate pred)</span></span>;</span><br></pre></td></tr></table></figure><p>wait函数除了传入锁，还可以传入一个<code>Predicate pred</code>可执行函数体，来判断条件变量是否满足；</p><p>如果指定了pred，则只有当pred返回false时，该函数才会阻塞；并且只有当它变为true时，通知才能解除阻塞线程（这对于检查<strong>虚假唤醒</strong>特别有用）</p><ul><li>虚假唤醒，指的是一些代码错误的情况下，另外一个线程在条件尚未真正就绪的时候就唤醒了该线程</li><li>添加上判断条件，<strong>能在wait中判断条件是否已经真正满足</strong>，从而避免虚假唤醒</li></ul><p>wait内部对pred的检测是下面这样</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (!<span class="built_in">pred</span>()) <span class="built_in">wait</span>(lck);</span><br></pre></td></tr></table></figure><p>只有pred返回真的时候，才会跳出while循环，唤醒线程。</p><p>除了检测虚假唤醒，我们还可以用该执行体，对不同的线程<strong>指定不同的唤醒条件</strong>！</p><h2 id="14-2-其他接口"><a href="#14-2-其他接口" class="headerlink" title="14.2 其他接口"></a>14.2 其他接口</h2><p>其他接口的使用也很直接，其中wait_for和until前面已经介绍过了</p><ul><li>wait：在条件变量中阻塞等待，等待被唤醒</li><li>notify_one：唤醒在该条件变量等待下的一个线程</li><li>notify_all：唤醒在该条件变量下等待的所有线程</li></ul><p><img                       lazyload                     alt="image"                     data-src="https://img1.musnow.top/i/2023/02/63f48806d52a4.png"                      alt="image-20230221165951372"                ></p><h2 id="14-3-实际用例"><a href="#14-3-实际用例" class="headerlink" title="14.3 实际用例"></a>14.3 实际用例</h2><p>当下我们有两个线程，我们的目标是让t1和t2线程共同管理一个变量i，对其进行++，并实现t1打印奇数，t2打印偶数的功能（二者交错打印）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">test9</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// 目标：t1打印奇数，t2打印偶数，二者交错打印</span></span><br><span class="line">    <span class="type">bool</span> ready = <span class="literal">true</span>;</span><br><span class="line"><span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> n = <span class="number">100</span>;</span><br><span class="line">mutex mtx;</span><br><span class="line">condition_variable cv;</span><br><span class="line"></span><br><span class="line"><span class="comment">// t1打印奇数</span></span><br><span class="line"><span class="function">thread <span class="title">t1</span><span class="params">([&amp;]()&#123;</span></span></span><br><span class="line"><span class="params"><span class="function"><span class="keyword">while</span> (i &lt; n)</span></span></span><br><span class="line"><span class="params"><span class="function">&#123;</span></span></span><br><span class="line"><span class="params"><span class="function">            unique_lock&lt;mutex&gt; lock(mtx);</span></span></span><br><span class="line"><span class="params"><span class="function"></span></span></span><br><span class="line"><span class="params"><span class="function">            cout &lt;&lt; <span class="string">&quot;t1 : &quot;</span> &lt;&lt; this_thread::get_id() &lt;&lt; <span class="string">&quot; : &quot;</span> &lt;&lt; i &lt;&lt; endl;</span></span></span><br><span class="line"><span class="params"><span class="function">            i++;</span></span></span><br><span class="line"><span class="params"><span class="function">&#125;</span></span></span><br><span class="line"><span class="params"><span class="function">&#125;)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// t2打印偶数</span></span><br><span class="line"><span class="function">thread <span class="title">t2</span><span class="params">([&amp;]() &#123;</span></span></span><br><span class="line"><span class="params"><span class="function"><span class="keyword">while</span> (i &lt; n)</span></span></span><br><span class="line"><span class="params"><span class="function">&#123;</span></span></span><br><span class="line"><span class="params"><span class="function">unique_lock&lt;mutex&gt; lock(mtx);</span></span></span><br><span class="line"><span class="params"><span class="function">cout &lt;&lt;<span class="string">&quot;t2 : &quot;</span>&lt;&lt;this_thread::get_id() &lt;&lt; <span class="string">&quot; : &quot;</span> &lt;&lt; i &lt;&lt; endl;</span></span></span><br><span class="line"><span class="params"><span class="function">i++;</span></span></span><br><span class="line"><span class="params"><span class="function">&#125;</span></span></span><br><span class="line"><span class="params"><span class="function">&#125;)</span></span>;</span><br><span class="line"></span><br><span class="line">this_thread::<span class="built_in">sleep_for</span>(chrono::<span class="built_in">seconds</span>(<span class="number">3</span>));</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;t1:&quot;</span> &lt;&lt; t1.<span class="built_in">get_id</span>() &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;t2:&quot;</span> &lt;&lt; t2.<span class="built_in">get_id</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">t1.<span class="built_in">join</span>();</span><br><span class="line">t2.<span class="built_in">join</span>();</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当下已经实现出了二者的基本操作，但直接运行我们会发现，t1都已经打印到99了，t2才开始执行，完全不符合交错打印的需求</p><p><img                       lazyload                     alt="image"                     data-src="https://img1.musnow.top/i/2023/02/63f487e871e3c.png"                      alt="image-20230221165920681"                ></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">thread <span class="title">t1</span><span class="params">([&amp;]()&#123;</span></span></span><br><span class="line"><span class="params"><span class="function"><span class="keyword">while</span> (i &lt; n)</span></span></span><br><span class="line"><span class="params"><span class="function">&#123;</span></span></span><br><span class="line"><span class="params"><span class="function">&#123;</span></span></span><br><span class="line"><span class="params"><span class="function">unique_lock&lt;mutex&gt; lock(mtx);</span></span></span><br><span class="line"><span class="params"><span class="function">cout &lt;&lt; <span class="string">&quot;t1 : &quot;</span> &lt;&lt; this_thread::get_id() &lt;&lt; <span class="string">&quot; : &quot;</span> &lt;&lt; i &lt;&lt; endl;</span></span></span><br><span class="line"><span class="params"><span class="function">i++;</span></span></span><br><span class="line"><span class="params"><span class="function">&#125;</span></span></span><br><span class="line"><span class="params"><span class="function"></span></span></span><br><span class="line"><span class="params"><span class="function">this_thread::sleep_for(chrono::microseconds(<span class="number">100</span>));</span></span></span><br><span class="line"><span class="params"><span class="function">&#125;</span></span></span><br><span class="line"><span class="params"><span class="function">&#125;)</span></span>;</span><br></pre></td></tr></table></figure><p>如果在t1的while循环中加上一个休眠，t2的函数体保持不变，则会发现是t2直接加到了99，才让可怜巴巴的t1访问了临界资源（饥饿问题）</p><p><img                       lazyload                     alt="image"                     data-src="https://img1.musnow.top/i/2023/02/63f48a571b2b9.png"                      alt="image-20230221170943659"                ></p><p>这时候，我们就可以使用条件变量来实现线程相互唤醒和交错打印，代码如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 条件变量测试</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test9</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// 目标：t1打印奇数，t2打印偶数，二者交错打印</span></span><br><span class="line"><span class="type">bool</span> ready = <span class="literal">true</span>;</span><br><span class="line"><span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> n = <span class="number">100</span>;</span><br><span class="line">mutex mtx;</span><br><span class="line">condition_variable cv;</span><br><span class="line"></span><br><span class="line"><span class="comment">// t1打印奇数</span></span><br><span class="line"><span class="function">thread <span class="title">t1</span><span class="params">([&amp;]()&#123;</span></span></span><br><span class="line"><span class="params"><span class="function"><span class="keyword">while</span> (i &lt; n)</span></span></span><br><span class="line"><span class="params"><span class="function">&#123;</span></span></span><br><span class="line"><span class="params"><span class="function">            unique_lock&lt;mutex&gt; lock(mtx);</span></span></span><br><span class="line"><span class="params"><span class="function">            <span class="comment">//ready为假的时候，唤醒t1</span></span></span></span><br><span class="line"><span class="params"><span class="function">            cv.wait(lock, [&amp;ready]()&#123;<span class="keyword">return</span> !ready; &#125;);</span></span></span><br><span class="line"><span class="params"><span class="function"></span></span></span><br><span class="line"><span class="params"><span class="function">            cout &lt;&lt; <span class="string">&quot;t1 : &quot;</span> &lt;&lt; this_thread::get_id() &lt;&lt; <span class="string">&quot; : &quot;</span> &lt;&lt; i &lt;&lt; endl;</span></span></span><br><span class="line"><span class="params"><span class="function">            i++;</span></span></span><br><span class="line"><span class="params"><span class="function"></span></span></span><br><span class="line"><span class="params"><span class="function">            ready = <span class="literal">true</span>;</span></span></span><br><span class="line"><span class="params"><span class="function"></span></span></span><br><span class="line"><span class="params"><span class="function">            cv.notify_one();</span></span></span><br><span class="line"><span class="params"><span class="function">&#125;</span></span></span><br><span class="line"><span class="params"><span class="function">&#125;)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// t2打印偶数</span></span><br><span class="line"><span class="function">thread <span class="title">t2</span><span class="params">([&amp;]() &#123;</span></span></span><br><span class="line"><span class="params"><span class="function"><span class="keyword">while</span> (i &lt; n)</span></span></span><br><span class="line"><span class="params"><span class="function">&#123;</span></span></span><br><span class="line"><span class="params"><span class="function">unique_lock&lt;mutex&gt; lock(mtx);</span></span></span><br><span class="line"><span class="params"><span class="function">             <span class="comment">//ready为真的时候，唤醒t2</span></span></span></span><br><span class="line"><span class="params"><span class="function">cv.wait(lock, [&amp;ready]()&#123;<span class="keyword">return</span> ready; &#125;);</span></span></span><br><span class="line"><span class="params"><span class="function"></span></span></span><br><span class="line"><span class="params"><span class="function">cout &lt;&lt;<span class="string">&quot;t2 : &quot;</span>&lt;&lt;this_thread::get_id() &lt;&lt; <span class="string">&quot; : &quot;</span> &lt;&lt; i &lt;&lt; endl;</span></span></span><br><span class="line"><span class="params"><span class="function">i++;</span></span></span><br><span class="line"><span class="params"><span class="function">ready = <span class="literal">false</span>;</span></span></span><br><span class="line"><span class="params"><span class="function"></span></span></span><br><span class="line"><span class="params"><span class="function">cv.notify_one();</span></span></span><br><span class="line"><span class="params"><span class="function">&#125;</span></span></span><br><span class="line"><span class="params"><span class="function">&#125;)</span></span>;</span><br><span class="line"></span><br><span class="line">this_thread::<span class="built_in">sleep_for</span>(chrono::<span class="built_in">seconds</span>(<span class="number">3</span>));</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;t1:&quot;</span> &lt;&lt; t1.<span class="built_in">get_id</span>() &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;t2:&quot;</span> &lt;&lt; t2.<span class="built_in">get_id</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">t1.<span class="built_in">join</span>();</span><br><span class="line">t2.<span class="built_in">join</span>();</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行一下，可以看到我们成功通过条件变量，使这两个线程交错打印奇偶数！</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">t2 : 23208 : 0</span><br><span class="line">t1 : 24896 : 1</span><br><span class="line">t2 : 23208 : 2</span><br><span class="line">t1 : 24896 : 3</span><br><span class="line">t2 : 23208 : 4</span><br><span class="line">t1 : 24896 : 5</span><br><span class="line">t2 : 23208 : 6</span><br><span class="line">t1 : 24896 : 7</span><br><span class="line">t2 : 23208 : 8</span><br><span class="line">t1 : 24896 : 9</span><br><span class="line">t2 : 23208 : 10</span><br><span class="line">t1 : 24896 : 11</span><br><span class="line">//....</span><br><span class="line">t2 : 23208 : 90</span><br><span class="line">t1 : 24896 : 91</span><br><span class="line">t2 : 23208 : 92</span><br><span class="line">t1 : 24896 : 93</span><br><span class="line">t2 : 23208 : 94</span><br><span class="line">t1 : 24896 : 95</span><br><span class="line">t2 : 23208 : 96</span><br><span class="line">t1 : 24896 : 97</span><br><span class="line">t2 : 23208 : 98</span><br><span class="line">t1 : 24896 : 99</span><br><span class="line">t2 : 23208 : 100</span><br></pre></td></tr></table></figure><p>即便在t1中额外加上休眠，也不会影响输出结果的准确性！</p><p><img                       lazyload                     alt="image"                     data-src="https://img1.musnow.top/i/2023/02/63f48c6d2f8ff.png"                      alt="image-20230221171837565"                ></p><p>这便是条件变量对于线程同步控制的用法</p><h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>在学习过linux的线程基础和系统接口后，理解C++这里的多线程操作还算轻松！</p><p>C++语法学习的最后一块拼图也被补上了！</p><p><img                       lazyload                     alt="image"                     data-src="https://img1.musnow.top/i/2023/02/202211021535708.jpg"                      alt="QQ图片20220424132540"                ></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;本篇博客，让我们来认识一下C++中的线程操作&lt;/p&gt;</summary>
    
    
    
    <category term="遇见C++" scheme="https://blog.musnow.top/categories/%E9%81%87%E8%A7%81C/"/>
    
    
    <category term="C++" scheme="https://blog.musnow.top/tags/C/"/>
    
    <category term="C++11" scheme="https://blog.musnow.top/tags/C-11/"/>
    
  </entry>
  
  <entry>
    <title>【Nas】tmm刮削器无法连接tmdb的解决办法（改host）</title>
    <link href="https://blog.musnow.top/2023/02/15/nas/9tmm%E5%88%AE%E5%89%8A%E6%97%A0%E6%B3%95%E8%AE%BF%E9%97%AE%E7%9A%84%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95/"/>
    <id>https://blog.musnow.top/2023/02/15/nas/9tmm%E5%88%AE%E5%89%8A%E6%97%A0%E6%B3%95%E8%AE%BF%E9%97%AE%E7%9A%84%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95/</id>
    <published>2023-02-15T13:25:57.000Z</published>
    <updated>2023-03-11T11:25:36.232Z</updated>
    
    <content type="html"><![CDATA[<p>tmm刮削器无法连接tmdb的解决办法（改host）</p><span id="more"></span><p>如题，最近发现自己windows电脑上的tmm又无法刮削了，打开系统host目一看，发现文件被清空了，得自己重新再搞一遍</p><h1 id="1-思路"><a href="#1-思路" class="headerlink" title="1.思路"></a>1.思路</h1><p>思路很简单，就是我们当前访问 <code>api.themoviedb.org</code>的域名，没有办法找到一个国内能成功访问的ip。所以就会报错 <code>timeout</code></p><p>修改host的作用，就是告诉系统，访问<code>api.themoviedb.org</code>的时候，先在本地hosts文件里面有的这些主机试一试，能成功就不需要去主动找host服务器了</p><p>所以我们只要将国内能访问的ip写入host就可以了</p><h1 id="2-找寻可用host"><a href="#2-找寻可用host" class="headerlink" title="2.找寻可用host"></a>2.找寻可用host</h1><p>有了上面的思路，下面要做的就是看看那些host可以访问</p><p>通过 <a class="link"   href="https://www.itdog.cn/ping/api.themoviedb.org" >ITDOG网站<i class="fas fa-external-link-alt"></i></a>，在线ping <code>api.themoviedb.org</code>站点，可以看到大部分地区的访问都是超时的</p><p><img                       lazyload                     alt="image"                     data-src="https://img1.musnow.top/i/2023/02/63ecde92b026b.png"                      alt="image-20230215213018481"                ></p><p>我们要做的就是找到没有超时的这些ip，记录下来。特别是香港和台湾的</p><p><img                       lazyload                     alt="image"                     data-src="https://img1.musnow.top/i/2023/02/63ecdee791f45.png"                      alt="image-20230215213225991"                ></p><p><img                       lazyload                     alt="image"                     data-src="https://img1.musnow.top/i/2023/02/63ecdef38a4ed.png"                      alt="image-20230215213238033"                ></p><p>要想知道这些ip在你这个地方能不能访问，那就采用windows命令行进行ping，能获取到信息就是ok的</p><p><img                       lazyload                     alt="image"                     data-src="https://img1.musnow.top/i/2023/02/63ecdf3e94acd.png"                      alt="image-20230215213353171"                ></p><h1 id="3-改host"><a href="#3-改host" class="headerlink" title="3.改host"></a>3.改host</h1><p>windows下的文件路径是</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">C:\Windows\System32\drivers\etc\hosts</span><br></pre></td></tr></table></figure><p>下面提供可用的host，建议采用上面的办法自己找一下，因为ip是会变动的</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">13.224.161.52 api.themoviedb.org</span><br><span class="line">99.84.192.81 api.themoviedb.org</span><br><span class="line">13.33.33.60 api.themoviedb.org</span><br><span class="line">13.224.167.74 api.themoviedb.org</span><br><span class="line">13.35.166.20 api.themoviedb.org</span><br><span class="line">202.182.98.125 api.themoviedb.org</span><br><span class="line">13.224.205.59 api.themoviedb.org</span><br><span class="line">54.230.184.46 api.themoviedb.org</span><br><span class="line">31.13.67.19 api.themoviedb.org</span><br><span class="line">99.84.224.92 api.themoviedb.org</span><br><span class="line">99.84.224.149 api.themoviedb.org</span><br><span class="line">99.86.149.118 api.themoviedb.org</span><br><span class="line">65.9.83.54 api.themoviedb.org</span><br><span class="line">99.86.149.118 api.themoviedb.org</span><br><span class="line">13.224.163.98 api.themoviedb.org</span><br></pre></td></tr></table></figure><p>添加完毕后，以管理员身份保存文件（否则权限不足无法写入）</p><p>现在应该就可以了</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;tmm刮削器无法连接tmdb的解决办法（改host）&lt;/p&gt;</summary>
    
    
    
    <category term="捣鼓折腾nas" scheme="https://blog.musnow.top/categories/%E6%8D%A3%E9%BC%93%E6%8A%98%E8%85%BEnas/"/>
    
    
    <category term="nas" scheme="https://blog.musnow.top/tags/nas/"/>
    
  </entry>
  
  <entry>
    <title>【网络】http(s)协议 | content-length详解</title>
    <link href="https://blog.musnow.top/2023/02/15/Linux/35http%E4%B8%ADcontent-length/"/>
    <id>https://blog.musnow.top/2023/02/15/Linux/35http%E4%B8%ADcontent-length/</id>
    <published>2023-02-15T04:30:55.000Z</published>
    <updated>2023-02-15T11:28:13.686Z</updated>
    
    <content type="html"><![CDATA[<p>本文通过一个线上实例，详细介绍http协议中的content-length字段。</p><span id="more"></span><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>http协议是互联网中最重要的协议之一，虽然看上去很简单，但是实际中经常遇到问题，我们就已经遇到好几次了。有长连接相关的，有报文解析相关的。对http协议不能一知半解，必须透彻理解才行。</p><p>本文通过一个线上实例，详细介绍http协议中的content-length字段。</p><h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><p>我们的手机App在做更新时会从服务器上下载的一些资源，一般都是一些小文件，更新的代码差不多是下面这样的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">update</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="type">URL</span> <span class="variable">url</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">URL</span>(<span class="string">&quot;http://172.16.59.129:8000/update/test.so&quot;</span>);</span><br><span class="line">    <span class="type">HttpURLConnection</span> <span class="variable">conn</span> <span class="operator">=</span> (HttpURLConnection) url.openConnection();</span><br><span class="line">    <span class="keyword">if</span>(conn.getResponseCode() == <span class="number">200</span>) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">totalLength</span> <span class="operator">=</span> conn.getContentLength();</span><br><span class="line"><span class="type">BufferedInputStream</span> <span class="variable">in</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedInputStream</span>(conn.getInputStream());</span><br><span class="line"><span class="type">byte</span>[] buffer = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">512</span>];</span><br><span class="line"><span class="type">int</span> <span class="variable">readLength</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">length</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>((length=in.read(buffer)) != -<span class="number">1</span>) &#123;</span><br><span class="line">readLength += length;</span><br><span class="line"><span class="comment">//进度条</span></span><br><span class="line">System.out.println(((<span class="type">float</span>)readLength) /((<span class="type">float</span>)(totalLength)));</span><br><span class="line">&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>比如上面的代码更新一个so文件，先通过content-length获取文件的总大小，然后读Stream，每读一段，就计算出当前读的总大小，除以content-length，用来显示进度条。</p><p>结果weblogic从10升级到12后，content-length一直返回-1，这样就不能显示进度条了，但是文件流还能正常读。把weblogic重启了，一开始还能返回content-length，一会又是-1了。</p><h1 id="原因分析"><a href="#原因分析" class="headerlink" title="原因分析"></a>原因分析</h1><p>Http协议的请求报文和回复报文都有header和body，body就是你要获取的资源，例如一个html页面，一个jpeg图片，而header是用来做某些约定的。例如客户端与服务端商定一些传输格式，客户端先获取头部，得知一些格式信息，然后才开始读取body。</p><blockquote><p>客户端： Accept-Encoding:gzip （给我压缩一下，我用的是流量，先下载下来我再慢慢解压吧）</p><p>服务端1：Content-Encoding:null(没有Content-Encoding头。 我不给压缩，CPU没空，你爱要不要）</p><p>服务端2：Content-Encoding:gzip (给你节省流量，压缩一下）</p></blockquote><blockquote><p>客户端：Connection: keep-alive (大哥，咱好不容易建了个TCP连接，下次接着用）</p><p>服务端1: Connection: keep-alive （都不容易，接着用）</p><p>服务端2: Connection: close (谁跟你接着用，我们这个TCP是一次性的，下次再找我还得重新连)</p></blockquote><p>http协议没有三次握手，一般客户端向服务端请求资源时，以服务端为准。还有一些header并没有协商的过程，而是服务端直接告诉客户端按什么来。例如上述的Content-Length，是服务端告诉客户端body的大小有多大。但是！服务端并不一定能准确的提前告诉你body有多大。服务端要先写header，再写body，如果要在header里把body大小写进去，就得提前知道body大小。如果这个body是动态生成的，服务端先生成完，再开始写header，这样需要很多额外的开销，所以header里不一定有content-length。</p><p>那客户端怎么知道body的大小呢？服务器有三种方式告诉你。</p><p>1.服务器已经知道资源大小，通过content-length这个header告诉你。</p><pre><code>Content-Length:1076(body的大小是1076B，你读取1076B就可以完成任务了）Transfer-Encoding: null</code></pre><p>2.服务器没法提前知道资源的大小，或者不愿意花费资源提前计算资源大小，就会把http回复报文中加一个header叫Transfer-Encoding:chunked，就是分块传输的意思。每一块都使用固定的格式，前边是块的大小，后面是数据，然后最后一块大小是0。这样客户端解析的时候就需要注意去掉一些无用的字段。</p><pre><code>Content-Length:nullTransfer-Encoding:chunked (接下来的body我要一块一块的传，每一块开始是这一块的大小，等我传到大小为0的块时，就没了）</code></pre><p>3.服务器不知道资源的大小，同时也不支持chunked的传输模式，那么就既没有content-length头，也没有transfer-encoding头，这种情况下必须使用短连接，以连接结束来标示数据传输结束，传输结束就能知道大小了。这时候服务器返回的header里Connection一定是close。</p><pre><code>Content-Length:null Transfer-Encoding:null Connection:close(我不知道大小，我也用不了chunked，啥时候我关了tcp连接，就说明传输结束了）</code></pre><h1 id="实验"><a href="#实验" class="headerlink" title="实验"></a>实验</h1><p>我通过nginx在虚拟机里做实验，默认nginx是支持chunked模式的，可以关掉。</p><p>使用的代码如下，可能会调整参数。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">update</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="type">URL</span> <span class="variable">url</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">URL</span>(<span class="string">&quot;http://172.16.59.129:8000/update/test.so&quot;</span>);</span><br><span class="line">    <span class="type">HttpURLConnection</span> <span class="variable">conn</span> <span class="operator">=</span> (HttpURLConnection) url.openConnection();</span><br><span class="line">    <span class="comment">//conn.setRequestProperty(&quot;Accept-Encoding&quot;, &quot;gzip&quot;);</span></span><br><span class="line">    <span class="comment">//conn.setRequestProperty(&quot;Connection&quot;, &quot;keep-alive&quot;);</span></span><br><span class="line">    conn.connect();</span><br><span class="line">    <span class="keyword">if</span>(conn.getResponseCode() == <span class="number">200</span>) &#123;</span><br><span class="line">        System.out.println(conn.getHeaderFields().keySet());</span><br><span class="line">        System.out.println(conn.getHeaderField(<span class="string">&quot;transfer-encoding&quot;</span>));</span><br><span class="line">        System.out.println(conn.getHeaderField(<span class="string">&quot;Content-Length&quot;</span>));</span><br><span class="line">        System.out.println(conn.getHeaderField(<span class="string">&quot;Content-Encoding&quot;</span>));</span><br><span class="line">        System.out.println(conn.getHeaderField(<span class="string">&quot;Connection&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="1-nginx在开启chunked-transfer-encoding的时候"><a href="#1-nginx在开启chunked-transfer-encoding的时候" class="headerlink" title="1.nginx在开启chunked_transfer_encoding的时候"></a>1.nginx在开启chunked_transfer_encoding的时候</h2><p>(1) 在reqeust header里不使用gzip，也就是不加<code>accept-encoding: gzip</code></p><table><thead><tr><th>test.so文件大小</th><th>结果</th></tr></thead><tbody><tr><td>100B</td><td>能正常返回content-length,没有transfer-encoding头</td></tr><tr><td>69M</td><td>能正常返回content-length,没有transfer-encoding头</td></tr><tr><td>3072M</td><td>能正常返回content-length,没有transfer-encoding头</td></tr></tbody></table><p>可以发现nginx不管资源多大，如果客户端不接受gzip的压缩格式，就不会使用chunked模式，而且跟是否使用短连接没关系。</p><p>(2)在request header里加入gzip，<code>accepting-encoding: gzip</code></p><table><thead><tr><th>test.so文件大小</th><th>结果</th></tr></thead><tbody><tr><td>100B</td><td>没有content-length,transfer-encoding&#x3D;trunked</td></tr><tr><td>69M</td><td>没有content-length,transfer-encoding&#x3D;trunked</td></tr><tr><td>3072M</td><td>没有content-length,transfer-encoding&#x3D;trunked</td></tr></tbody></table><p>可以看到nginx在开启<code>chunked_transfer_encoding</code>，并且客户端接受gzip的时候，会使用chunked模式，nginx开启gzip后不会计算资源的大小，直接用chunked模式。</p><h2 id="2-nginx关闭chunked-transfer-encoding"><a href="#2-nginx关闭chunked-transfer-encoding" class="headerlink" title="2.nginx关闭chunked_transfer_encoding"></a>2.nginx关闭chunked_transfer_encoding</h2><p>(1) 在reqeust header里不使用gzip，也就是不加<code>accept-encoding:gzip</code></p><table><thead><tr><th>test.so文件大小</th><th>结果</th></tr></thead><tbody><tr><td>100B</td><td>能正常返回content-length,没有transfer-encoding头</td></tr><tr><td>69M</td><td>能正常返回content-length,没有transfer-encoding头</td></tr><tr><td>3072M</td><td>能正常返回content-length,没有transfer-encoding头</td></tr></tbody></table><p>因为能很容易的知道文件大小，所以nginx还是能返回content-length。</p><p>(2)在request header里加入gzip，<code>accepting-encoding:gzip</code></p><table><thead><tr><th>test.so文件大小</th><th>结果</th></tr></thead><tbody><tr><td>100B</td><td>没有content-length和transfer-encoding头，不论客户端connection为keep-alive还是close，服务端返回的connection头都是close</td></tr><tr><td>69M</td><td>没有content-length和transfer-encoding头，不论客户端connection为keep-alive还是close，服务端返回的connection头都是close</td></tr><tr><td>3072M</td><td>没有content-length和transfer-encoding头，不论客户端connection为keep-alive还是close，服务端返回的connection头都是close</td></tr></tbody></table><p>这就是上面说的第三种情况，不知道大小，也不支持trunked，那就必须使用短连接来标示结束。</p><h1 id="问题解决方案"><a href="#问题解决方案" class="headerlink" title="问题解决方案"></a>问题解决方案</h1><p>咨询了中间件组的同事，以前也遇到类似的问题，因为升级了Weblogic导致客户端解析XML出错，因为使用了chunked模式，中间有一些格式化的字符，而客户端解析的代码并没有考虑chunked模式的解析，导致解析出错。</p><p>因为我们客户端必须用content-length展示进度，因此不能用chunked模式，Weblogic可以把chunked模式关闭。用下面的方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">#!java weblogic.WLST </span><br><span class="line"><span class="title function_">connect</span><span class="params">(<span class="string">&#x27;username’,&#x27;</span>password<span class="string">&#x27;, &#x27;</span>t3://localhost:<span class="number">7001</span><span class="string">&#x27;)</span></span></span><br><span class="line"><span class="string"><span class="params">edit()</span></span></span><br><span class="line"><span class="string"><span class="params">startEdit()</span></span></span><br><span class="line"><span class="string"><span class="params">cd(&quot;Servers/AdminServer/WebServer/AdminServer&quot;)</span></span></span><br><span class="line"><span class="string"><span class="params">cmo.setChunkedTransferDisabled(true)</span></span></span><br><span class="line"><span class="string"><span class="params">save()</span></span></span><br><span class="line"><span class="string"><span class="params">activate()</span></span></span><br><span class="line"><span class="string"><span class="params">exit()</span></span></span><br></pre></td></tr></table></figure><p>改了之后，确实不返回chunked了，但是也没有content-length，因为Weblogic就是不提前获取文件大小，而是强制加了<code>connection:close</code>，也就是前边说的第三种，通过连接结束标识数据结束。最后只能把这些资源放倒apache里了。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>一个好的http客户端，必须充分实现协议，不然就可能出问题，浏览器对于服务端可能产生的各种情况都很好的做了处理，但是自己实现http协议的解析时一定得注意考虑多种情况。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">文章作者：牛立新</span><br><span class="line">原文链接：https://www.cnblogs.com/nxlhero/p/11670942.html</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;本文通过一个线上实例，详细介绍http协议中的content-length字段。&lt;/p&gt;</summary>
    
    
    
    <category term="玩上Linux" scheme="https://blog.musnow.top/categories/%E7%8E%A9%E4%B8%8ALinux/"/>
    
    
    <category term="网络" scheme="https://blog.musnow.top/tags/%E7%BD%91%E7%BB%9C/"/>
    
    <category term="http" scheme="https://blog.musnow.top/tags/http/"/>
    
    <category term="nginx" scheme="https://blog.musnow.top/tags/nginx/"/>
    
  </entry>
  
  <entry>
    <title>【网络】http(s)协议 | 介绍</title>
    <link href="https://blog.musnow.top/2023/02/15/Linux/34http%E5%8D%8F%E8%AE%AE/"/>
    <id>https://blog.musnow.top/2023/02/15/Linux/34http%E5%8D%8F%E8%AE%AE/</id>
    <published>2023-02-15T03:30:55.000Z</published>
    <updated>2023-03-13T10:52:36.996Z</updated>
    
    <content type="html"><![CDATA[<p>已经学习过自己定制一个协议了，现在就来看看当下广泛使用的http协议吧</p><span id="more"></span><h1 id="1-介绍"><a href="#1-介绍" class="headerlink" title="1.介绍"></a>1.介绍</h1><blockquote><p>超文本传输协议（Hyper Text Transfer Protocol，HTTP）是一个简单的请求-响应协议，它通常运行在TCP之上。它指定了客户端可能发送给服务器什么样的消息以及得到什么样的响应。</p></blockquote><p>http和https是当下最通用的协议之一，我们访问的大部分网页用的都是这个协议；</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://www.bilibili.com/</span><br></pre></td></tr></table></figure><p>这两个协议主要的差别，那就是http是用明文传输数据的，我们的数据在互联网裸奔，可能有安全问题；相比之下，https传输数据的过程会对数据进行加密，但这也不代表https是完全安全的。</p><h2 id="1-1-url"><a href="#1-1-url" class="headerlink" title="1.1 url"></a>1.1 url</h2><p>要认识这两个协议，我们要从url的认识开始；</p><p><code>HTTP(S)</code> 不允许使用用户名或密码，一个合法的 <code>HTTP(S)</code> URL 格式如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http(s)://&lt;host&gt;:&lt;port&gt;/&lt;path&gt;?&lt;query&gt;#&lt;frag&gt;</span><br></pre></td></tr></table></figure><ul><li>开头为协议名：http 或 https 协议； </li><li><code>&lt;host&gt;</code>：主机名。一个 URL 中，既可以使用域名也可以使用 IP 表示主机地址</li><li><code>&lt;port&gt;</code>：端口。主机名和端口之间使用冒号分隔。端口是可选的，如果省略将采用默认端口，http 默认端口是 80，https 默认端口 443；</li><li><code>&lt;path&gt;</code>：资源路径。资源在网络主机上的路径，路径也是可选的，缺省访问默认资源； </li><li><code>&lt;query&gt;</code>：查询参数。格式为 key&#x3D;value，多个参数使用 &amp; 分隔；参数也是可选的； </li><li><code>&lt;frag&gt;</code>：片段。从 # 开始到最后，一般用于定位到资源内的一个片段，比如文档的一个章节；片段也是可选的。</li></ul><h3 id="1-1-1-栗子-①"><a href="#1-1-1-栗子-①" class="headerlink" title="1.1.1 栗子 ①"></a>1.1.1 栗子 ①</h3><p>接下来举一个具体的例子</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://blog.musnow.top/2022/08/07/note_linux/6gdb_g++_make_vim/#4-make-x2F-makefile</span><br></pre></td></tr></table></figure><p>如上是我的个人博客中的一篇文章</p><ul><li>协议是https</li><li>域名是<code>blog.musnow.top</code>，对应的就是<code>&lt;host&gt;:&lt;port&gt;</code>；这里隐藏了端口，会在下面说明。</li><li><code>/2022/08/07/note_linux/6gdb_g++_make_vim/</code>这一长串都是文件的路径，其标示了文件在服务器上存放的位置</li><li>这个url内没有带<code>&lt;query&gt;</code>参数</li><li><code>#4-make-x2F-makefile</code>对应的是<code>&lt;frag&gt;</code>片段，标识了我当前浏览的位置</li></ul><p>当你把这个url粘贴道浏览器，其会直接跳转到对应的标题位置，而不是这篇文章的页首；这就是<code>&lt;frag&gt;</code>片段的作用</p><p><img                       lazyload                     alt="image"                     data-src="https://img1.musnow.top/i/2023/02/63ec475e3c6a2.png"                      alt="image-20230215104544655"                ></p><h3 id="1-1-2-栗子-②"><a href="#1-1-2-栗子-②" class="headerlink" title="1.1.2 栗子 ②"></a>1.1.2 栗子 ②</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://www.baidu.com/s?tn=68018901_39_oem_dg&amp;ie=utf-8&amp;word=test</span><br></pre></td></tr></table></figure><p>当我们在百度搜索单词<code>test</code>的时候，百度的url中就会出现<code>&lt;query&gt;</code>参数；</p><p>其中<code>?</code>是参数的开头，后续的一串以<code>&amp;</code>分隔的kv键值对，就是参数的内容。在这里面我们能看到<code>word=test</code>，我们查询的单词test就在这个参数后；</p><p>我们的搜索访问，就是将这些参数传送给服务器，再由百度的服务器返回搜素结果的。</p><h2 id="1-2-域名和端口隐藏"><a href="#1-2-域名和端口隐藏" class="headerlink" title="1.2 域名和端口隐藏"></a>1.2 域名和端口隐藏</h2><p>但我们日常访问的网页中，很少见到过<code>ip:端口</code>的形式，而大多是用域名为我们提供服务的</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://www.bilibili.com/</span><br></pre></td></tr></table></figure><p>这并不代表其背后不需要端口号。而是因为如果我们的访问<strong>不指定端口</strong>的时候，http(s)协议会采用默认端口号80或443，从而实现隐藏端口号提供服务</p><blockquote><p>http 默认端口是 80，https 默认端口 443</p></blockquote><p>毕竟对于用户而言，记住一个域名已经不容易了，还要记住你的服务是在哪一个端口，那就更难了；</p><p>而域名也不是凭空给我们提供服务的，每一个域名都需要绑定一个具体的公网ip（域名解析），才能为用户提供服务。在域名的背后，都是一个ip，每一个ip也就是一台服务器。</p><p>域名的作用，就是来隐藏掉ip这个无规律的长数字，方便用户访问；</p><blockquote><p>你觉得是记住<code>baidu.com</code>容易，还是记住<code>114.514.77.58</code>容易呢？</p></blockquote><p>在命令行使用ping工具，我们能知道一个网站服务器的ip是什么</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ping www.bilibili.com</span><br></pre></td></tr></table></figure><p>比如我们ping一下b站的域名，可以看到其公网ip是<code>183.131.147.29</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">正在 Ping a.w.bilicdn1.com [183.131.147.29] 具有 32 字节的数据:</span><br><span class="line">来自 183.131.147.29 的回复: 字节=32 时间=10ms TTL=55</span><br><span class="line">来自 183.131.147.29 的回复: 字节=32 时间=12ms TTL=55</span><br><span class="line">来自 183.131.147.29 的回复: 字节=32 时间=12ms TTL=55</span><br><span class="line">来自 183.131.147.29 的回复: 字节=32 时间=12ms TTL=55</span><br><span class="line"></span><br><span class="line">183.131.147.29 的 Ping 统计信息:</span><br><span class="line">    数据包: 已发送 = 4，已接收 = 4，丢失 = 0 (0% 丢失)，</span><br><span class="line">往返行程的估计时间(以毫秒为单位):</span><br><span class="line">    最短 = 10ms，最长 = 12ms，平均 = 11ms</span><br></pre></td></tr></table></figure><h2 id="1-3-ip-端口"><a href="#1-3-ip-端口" class="headerlink" title="1.3 ip:端口"></a>1.3 ip:端口</h2><p>我们可以用<code>ip:端口</code>来访问自己的服务（以下ip纯属虚构，如有撞车，纯属巧合）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">114.514.77.58:8080</span><br></pre></td></tr></table></figure><p>当我们把这个粘贴道浏览器，再复制粘贴出来的时候，我们会发现前面多了一个http</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://114.514.77.58:8080</span><br></pre></td></tr></table></figure><p>这是因为当我们使用ip访问一个服务的时候，浏览器会默认采用http的协议去访问，所以在前面加了一个我们看不到的<code>http://</code></p><h2 id="1-4-协议作用"><a href="#1-4-协议作用" class="headerlink" title="1.4 协议作用"></a>1.4 协议作用</h2><p>http协议的作用，就是向<strong>服务器</strong>申请特定的资源，再将资源拉取到本地进行展示or使用。</p><p>资源都是存在我们的服务器上的，当用户请求的时候，服务器必须要知道资源的路径，将其<code>read</code>打开读取，再<code>write</code>写给我们的客户端。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/2022/08/07/note_linux/6gdb_g++_make_vim/</span><br></pre></td></tr></table></figure><p>所以http的请求中才会带上资源的路径，这是方便服务器进行资源文件的读取；同时，文件的路径也是对一个文件的唯一标识，在告诉服务器文件路径的同时，也保证了我们请求的文件的唯一性，不会出现二义性；</p><hr><p>这时候又会出现一个问题，当我们访问网站的根目录的时候，没有提供文件的路径呀，那这时候，访问的什么文件呢？</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://www.baidu.com/</span><br></pre></td></tr></table></figure><p>实际上，我们访问的是服务器根目录的<code>index.html</code>文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">https://www.baidu.com/</span><br><span class="line">https://www.baidu.com/index.html</span><br></pre></td></tr></table></figure><p>你可以试着打开这两个链接，其出现的页面是完全一致的；</p><p><img                       lazyload                     alt="image"                     data-src="https://img1.musnow.top/i/2023/02/63ec4cb9820b6.png"                      alt="image-20230215110843400"                ></p><p>类似于端口号隐藏，http协议也确定了当下使用的网页文件的命名为<code>index.html</code>，当我们访问一个网站的时候，就会默认访问根目录下的<code>index.html</code>文件（既然是默认的，那就可以直接隐藏）如果这个文件不存在，那就不会渲染出我们看到的网页！</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">index.html是用前端语言编写的网页代码</span><br></pre></td></tr></table></figure><p>同理，当我们访问博客的时候，读取道的也不是目录，而是目录下的<code>index.html</code>文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://blog.musnow.top/2022/08/07/note_linux/6gdb_g++_make_vim/</span><br></pre></td></tr></table></figure><p><img                       lazyload                     alt="image"                     data-src="https://img1.musnow.top/i/2023/02/63ec4d38428a8.png"                      alt="image-20230215111050026"                ></p><p>我的博客使用的是hexo框架，其网页的源路径在github上开源了，可以帮助你理解url中的文件路径。</p><p>当前你看到的文件目录，就是博客服务的根目录。访问的博客首页，就是根目录下的<code>index.html</code></p><p><img                       lazyload                     alt="image"                     data-src="https://img1.musnow.top/i/2023/02/63ec4d71b69ed.png"                      alt="image-20230215111147560"                ></p><p>用作示例的<a href="https://blog.musnow.top/2022/08/07/note_linux/6gdb_g++_make_vim/index.html">linux工具使用</a>博客，也可以根据它的路径，找到<code>index.html</code>文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/2022/08/07/note_linux/6gdb_g++_make_vim/</span><br></pre></td></tr></table></figure><p><img                       lazyload                     alt="image"                     data-src="https://img1.musnow.top/i/2023/02/63ec4e066de99.png"                      alt="image-20230215111416443"                ></p><p>这便是http协议url中文件路径的作用！</p><p>这里的<code>/</code>根目录是<strong>服务端设置</strong>的，并不一定是（大概率不是）服务端linux服务器的根目录</p><h2 id="1-5-编码解码"><a href="#1-5-编码解码" class="headerlink" title="1.5 编码解码"></a>1.5 编码解码</h2><p>在url中，还会对一些特殊字符进行编解码，比如中文，和一些特殊的符号</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://blog.musnow.top/2022/08/07/note_linux/6gdb_g++_make_vim/#4-make-x2F-makefile</span><br></pre></td></tr></table></figure><p>比如在作为示例的url中，这里出现了<code>x2F</code>，而原文中是<code>4.make/makefile</code>;这里的编码就是为了避免<code>make/makefile</code>被识别成路径的标识符，从而出现错误。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://www.baidu.com/s?tn=68018901_39_oem_dg&amp;ie=utf-8&amp;word=%E4%BD%A0%E5%A5%BD</span><br></pre></td></tr></table></figure><p>当url路径中有中文的时候，也会被转码成特定的格式</p><p><img                       lazyload                     alt="image"                     data-src="https://img1.musnow.top/i/2023/02/63ec503e1f0d6.png"                      alt="image-20230215112344227"                ></p><p>我们在浏览器上看到的依旧是中文，这是因为浏览器这段帮我们进行了解码</p><blockquote><p>将需要转码的字符转为16进制，然后从右到左，取4位(不足4位直接处理)，每2位做一位，前面加上%，编码成<code>%XY</code>格式</p></blockquote><h1 id="2-http协议请求格式"><a href="#2-http协议请求格式" class="headerlink" title="2.http协议请求格式"></a>2.http协议请求格式</h1><p>了解了http协议中的url网址，现在就可以进一步了解http协议的报头和报文了;</p><p>一个<code>http request/response</code>的基本格式如下</p><p><img                       lazyload                     alt="image"                     data-src="https://img1.musnow.top/i/2023/02/63ec536219bf8.png"                      alt="image-20230215113707995"                ></p><p>在请求中，客户端会提供自己的请求方法（GET&#x2F;POST&#x2F;PUT等等），并提供url来标识自己需要的文件路径；这个url可能是短链接（截取根目录之后的部分），也有可能是完整的链接。</p><p>随后，就会跟上一大堆的请求参数，注意，这里的请求参数并不是url中的<code>&lt;query&gt;</code>参数，而是http协议自身的请求参数。每一个请求参数都用了<code>\r\n</code>作为分隔，这和我们写的<a href="https://blog.musnow.top/2023/02/11/note_linux/32tcp%E5%AE%9E%E7%8E%B0%E8%87%AA%E5%AE%9A%E4%B9%89%E5%8D%8F%E8%AE%AE/#3-1-%E5%8D%8F%E8%AE%AE%E5%AE%9A%E5%88%B6">自定义协议</a>中采用<code>\t</code>进行分割是相同的原理！</p><p>这几个部分中，请求的正文可以不带（为空）</p><h2 id="2-1-读取多长？"><a href="#2-1-读取多长？" class="headerlink" title="2.1 读取多长？"></a>2.1 读取多长？</h2><p>为了让协议读取的时候，能够知道什么时候读取完毕了报头，http协议提供了一个<code>\r\n</code>的空行，读取道这个空行，就代表报头读取完毕了，剩下的内容都是报文。</p><p>而为了标识报文的长度，http协议会在发送的时候提供一个参数<code>content-length</code>，用于标识报文的长度。在读取完毕报头后，肯定是读取到了这个<code>content-length</code>参数的，也就知道后续应该继续读取多长，才能读完整个协议字段！</p><p>关于这部分的介绍，可以查看另外一篇博客 <a href="https://blog.musnow.top/2023/02/15/note_Linux/35http%E4%B8%ADcontent-length/">http协议content-length详解</a></p><h2 id="2-2-响应的状态码"><a href="#2-2-响应的状态码" class="headerlink" title="2.2 响应的状态码"></a>2.2 响应的状态码</h2><p>和我们进程的退出状态一样，http也表明了一部分响应的状态码，其中我们日常最常见到的，是<code>404/403</code>这两个状态码</p><blockquote><p><a class="link"   href="https://baike.baidu.com/item/HTTP%E7%8A%B6%E6%80%81%E7%A0%81/5053660" >http状态码-百度百科<i class="fas fa-external-link-alt"></i></a></p></blockquote><p>状态码就是标识服务器提供的服务状态，告诉客户端它的请求是否成功了。如果状态码是200，代表请求是成功的。其余状态码会有各自的使用场景，比如404状态码，代表请求的资源不存在，所以才叫 <code>404 not found!</code></p><h1 id="3-实例"><a href="#3-实例" class="headerlink" title="3.实例"></a>3.实例</h1><p>完整代码详见 <a class="link"   href="https://gitee.com/musnow/raspberry-practice/tree/master/code" >Gitee<i class="fas fa-external-link-alt"></i></a></p><h2 id="3-1-前端页面"><a href="#3-1-前端页面" class="headerlink" title="3.1 前端页面"></a>3.1 前端页面</h2><p>由于本人并没有学习过前端语法，这里采用 <a class="link"   href="https://www.runoob.com/html/html-tutorial.html" >菜鸟教程<i class="fas fa-external-link-alt"></i></a> 提供的前端示例代码来演示</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;utf-8&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">title</span>&gt;</span>菜鸟教程(runoob.com)<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>我的第一个标题<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>我的第一个段落。<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>我们日常所访问的网页都是这样的代码，经由浏览器进行渲染，再展示出来</p><h2 id="3-2-服务端代码"><a href="#3-2-服务端代码" class="headerlink" title="3.2 服务端代码"></a>3.2 服务端代码</h2><p>由于http是基于tcp的，这里直接把之前写的tcpServer搬过来就能用！具体的代码解析请看注释，想必说的是很清楚的</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> CRLF <span class="string">&quot;\r\n&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CRLF_LEN strlen(CRLF)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SPACE <span class="string">&quot; &quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SPACE_LEN strlen(SPACE)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> HOME_PAGE <span class="string">&quot;index.html&quot;</span> <span class="comment">// 首页文件</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ROOT_PATH <span class="string">&quot;web&quot;</span> <span class="comment">// 网址根目录地址</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取http请求中的路径</span></span><br><span class="line"><span class="function">string <span class="title">getPath</span><span class="params">(string http_request)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">size_t</span> pos = http_request.<span class="built_in">find</span>(CRLF);<span class="comment">//找到第一行的分隔符</span></span><br><span class="line">    <span class="keyword">if</span>(pos == string::npos) </span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">    string request_line = http_request.<span class="built_in">substr</span>(<span class="number">0</span>, pos);<span class="comment">//取出第一行</span></span><br><span class="line">    <span class="comment">//请求的第一行：GET /a/b/c http/1.0</span></span><br><span class="line">    <span class="type">size_t</span> first = request_line.<span class="built_in">find</span>(SPACE);<span class="comment">// 找到第一个空格</span></span><br><span class="line">    <span class="keyword">if</span>(pos == string::npos) </span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="type">size_t</span> second = request_line.<span class="built_in">rfind</span>(SPACE); <span class="comment">// 从后往前找空格</span></span><br><span class="line">    <span class="keyword">if</span>(pos == string::npos) </span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="comment">// 找到两个空格了，两个空格之间的就是请求的路径</span></span><br><span class="line">    string path = request_line.<span class="built_in">substr</span>(first+SPACE_LEN, second - (first+SPACE_LEN));</span><br><span class="line">    <span class="keyword">if</span>(path.<span class="built_in">size</span>() == <span class="number">1</span> &amp;&amp; path[<span class="number">0</span>] == <span class="string">&#x27;/&#x27;</span>) &#123;</span><br><span class="line">        path += HOME_PAGE; <span class="comment">//再加上被隐藏的index.html文件名</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> path;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 读取文件</span></span><br><span class="line"><span class="function">string <span class="title">readFile</span><span class="params">(<span class="type">const</span> string &amp;recource)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">ifstream <span class="title">in</span><span class="params">(recource, ios::binary)</span></span>;</span><br><span class="line">    <span class="keyword">if</span>(!in.<span class="built_in">is_open</span>()) <span class="comment">//文件打开失败</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;404&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 内容</span></span><br><span class="line">    string content;</span><br><span class="line">    string line;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">getline</span>(in, line))</span><br><span class="line">    &#123;</span><br><span class="line">        content += line;</span><br><span class="line">    &#125;</span><br><span class="line">    in.<span class="built_in">close</span>();</span><br><span class="line">    <span class="keyword">return</span> content;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">handlerHttpRequest</span><span class="params">(<span class="type">int</span> sock)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;###########start#############&quot;</span> &lt;&lt; endl;<span class="comment">//打印一个分隔线</span></span><br><span class="line">    <span class="type">char</span> buffer[<span class="number">10240</span>];</span><br><span class="line">    <span class="type">ssize_t</span> s = <span class="built_in">read</span>(sock, buffer, <span class="built_in">sizeof</span>(buffer));</span><br><span class="line">    <span class="keyword">if</span>(s &gt; <span class="number">0</span>)&#123;</span><br><span class="line">        cout &lt;&lt; buffer &lt;&lt; endl;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;###########end############&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    string path = <span class="built_in">getPath</span>(buffer);</span><br><span class="line">    <span class="comment">// 假设用户请求的是 /a/b 路径</span></span><br><span class="line">    <span class="comment">// 那么服务端处理的时候，就需要添加根目录位置和默认的文件名</span></span><br><span class="line">    <span class="comment">// &lt;root&gt;/a/b/index.html</span></span><br><span class="line">    <span class="comment">// 在本次用例中，根目录为 ./web文件夹，所以完整的文件路径应该是</span></span><br><span class="line">    <span class="comment">// ./web/a/b/index.html</span></span><br><span class="line"></span><br><span class="line">    string resources = ROOT_PATH; <span class="comment">// 根目录路径</span></span><br><span class="line">    resources += path; <span class="comment">// 文件路径</span></span><br><span class="line">    <span class="built_in">logging</span>(DEBUG,<span class="string">&quot;[sockfd: %d] filePath: %s&quot;</span>,sock,resources.<span class="built_in">c_str</span>()); <span class="comment">// 打印用作debug</span></span><br><span class="line"></span><br><span class="line">    string html = <span class="built_in">readFile</span>(resources);<span class="comment">// 打开文件</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 开始响应</span></span><br><span class="line">    string response = <span class="string">&quot;HTTP/1.0 200 OK\r\n&quot;</span>;</span><br><span class="line">    <span class="comment">//如果readFile返回的是404，代表文件路径不存在</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">strcmp</span>(html.<span class="built_in">c_str</span>(),<span class="string">&quot;404&quot;</span>)==<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        response = <span class="string">&quot;HTTP/1.0 404 NOT FOUND\r\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 追加后续字段</span></span><br><span class="line">    response += <span class="string">&quot;Content-Type: text/html\r\n&quot;</span>;</span><br><span class="line">    response += (<span class="string">&quot;Content-Length: &quot;</span> + <span class="built_in">to_string</span>(html.<span class="built_in">size</span>()) + <span class="string">&quot;\r\n&quot;</span>);</span><br><span class="line">    response += <span class="string">&quot;\r\n&quot;</span>;</span><br><span class="line">    response += html;</span><br><span class="line">    <span class="comment">// 发送给用户</span></span><br><span class="line">    <span class="built_in">send</span>(sock, response.<span class="built_in">c_str</span>(), response.<span class="built_in">size</span>(), <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-3-测试"><a href="#3-3-测试" class="headerlink" title="3.3 测试"></a>3.3 测试</h2><p>启动服务器之前，请先打开你的云服务器防火墙中的对应端口；这里我绑定的是端口10000，在浏览器中用<code>ip:端口</code>的方式可以正常访问！</p><p><img                       lazyload                     alt="image"                     data-src="https://img1.musnow.top/i/2023/02/63ec6f01b93dd.png"                      alt="image-20230215133459929"                ></p><p>这里标识的<code>不安全</code>是因为我们没有采用带加密的https协议，这不是当下需要考虑的问题。不管他就可以了。</p><p>按F12打开开发者页面，可以看到下方出现了完整的html代码，我们成功提供了服务！</p><p><img                       lazyload                     alt="image"                     data-src="https://img1.musnow.top/i/2023/02/63ec720503cdc.png"                      alt="image-20230215134751216"                ></p><h2 id="3-4-后端打印的报文"><a href="#3-4-后端打印的报文" class="headerlink" title="3.4 后端打印的报文"></a>3.4 后端打印的报文</h2><p>在服务器后端，我们看到其打印出来了一个基本的http请求，和上面说明的格式是一样的。这里简单的进行一部分说明：</p><ul><li>GET：请求方式为获取数据</li><li><code>/</code>：请求的是根路径</li><li><code>HTTP/1.1</code>：使用的http协议版本</li><li><code>Connetion</code>：代表我们和服务器的链接方式，keep-alive代表保持连接</li><li><code>User-Agent</code>：客户端信息，可以看到是windows系统、Chrome内核的浏览器（我是用的是edge浏览器）</li><li>Accept: 支持接收的信息类型</li><li><code>Aceept-Encoding</code>: 对信息进行压缩</li><li><code>Accept-Language</code>：支持的语言</li><li><code>Cookie</code>：身份信息，后面会详细介绍</li></ul><p>其中出现了一个空行，代表报文结束；</p><p><img                       lazyload                     alt="image"                     data-src="https://img1.musnow.top/i/2023/02/63ec78b4c5cf2.png"                      alt="image-20230215141623151"                ></p><p>往下滑，会发现浏览器还发出了第二个请求，路径是<code>/favicon.ico</code>，这是默认的站点头像文件的命名。因为我们的html文件中没有写明站点头像的路径，所以浏览器就尝试请求默认的头像文件</p><p>但是，当前我们的站点根目录web下并没有该文件，应该返回一个404状态码。</p><ul><li>请求中出现了一个新的参数<code>Referer</code>，代表是从当前网页请求头像的。相比之下，请求网页的报文中没有<code>Referer</code>参数</li></ul><p><img                       lazyload                     alt="image"                     data-src="https://img1.musnow.top/i/2023/02/63ec8b10b0daf.png"                      alt="image-20230215153442298"                ></p><p>此时可以随便找个图片做头像，看看能不能加载出来；为了方便，我随便找了一张纯绿色的图片，并将其<a class="link"   href="http://www.ico51.cn/" >在线转换为ico<i class="fas fa-external-link-alt"></i></a>，放入了站点的根目录。</p><p>重启服务器进程，刷新浏览器再次请求，可以看到成功出现了站点的头像；</p><p><img                       lazyload                     alt="image"                     data-src="https://img1.musnow.top/i/2023/02/63ec7575b082e.png"                      alt="image-20230215140232033"                ></p><h2 id="3-5-常见参数表"><a href="#3-5-常见参数表" class="headerlink" title="3.5 常见参数表"></a>3.5 常见参数表</h2><p><img                       lazyload                     alt="image"                     data-src="https://img1.musnow.top/i/2023/02/63ec8de7299b2.png"                      alt="img"                ></p><h1 id="4-请求方法"><a href="#4-请求方法" class="headerlink" title="4.请求方法"></a>4.请求方法</h1><p>一般我们获取一个网页，用的都是GET方法。接下来用一个带按钮的表单创建请求，尝试向服务端发送<code>&lt;query&gt;</code>参数</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;utf-8&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">title</span>&gt;</span>菜鸟教程(runoob.com)<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>我的第一个标题<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>我的第一个段落。<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">&quot;/a/index.html&quot;</span> <span class="attr">method</span>=<span class="string">&quot;get&quot;</span>&gt;</span></span><br><span class="line">    Username: <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">name</span>=<span class="string">&quot;user&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">    Password: <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;password&quot;</span> <span class="attr">name</span>=<span class="string">&quot;passwd&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span> <span class="attr">value</span>=<span class="string">&quot;Submit&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="4-1-GET"><a href="#4-1-GET" class="headerlink" title="4.1 GET"></a>4.1 GET</h2><p>在method里面，我们指定了get方法，此时</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">&quot;/a/index.html&quot;</span> <span class="attr">method</span>=<span class="string">&quot;get&quot;</span>&gt;</span></span><br><span class="line">    Username: <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">name</span>=<span class="string">&quot;user&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">    Password: <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;password&quot;</span> <span class="attr">name</span>=<span class="string">&quot;passwd&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span> <span class="attr">value</span>=<span class="string">&quot;Submit&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure><p>此时页面中出现了两个输入框，供我们输入密码，且密码会显示为<code>****</code>而不是明文</p><p><img                       lazyload                     alt="image"                     data-src="https://img1.musnow.top/i/2023/02/63ec89644d733.png"                      alt="image-20230215152726050"                ></p><p>点击按钮，会跳转到一个404页面，这是因为我们的<code>a/index.html</code>路径并不支持参数请求，所以发送了404错误码</p><p><img                       lazyload                     alt="image"                     data-src="https://img1.musnow.top/i/2023/02/63ec89a063d20.png"                      alt="image-20230215152834203"                ></p><p>不过这不重要，我们看看后端打印的内容。其中参数是追加到url中，以明文传输过来的；正文部分为空，并没有携带参数</p><p><img                       lazyload                     alt="image"                     data-src="https://img1.musnow.top/i/2023/02/63ec8b5dd10c0.png"                      alt="image-20230215153559515"                ></p><h2 id="4-2-POST"><a href="#4-2-POST" class="headerlink" title="4.2 POST"></a>4.2 POST</h2><p>将请求方法改成post，再次尝试</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">&quot;/a/index.html&quot;</span> <span class="attr">method</span>=<span class="string">&quot;post&quot;</span>&gt;</span></span><br><span class="line">    Username: <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">name</span>=<span class="string">&quot;user&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">    Password: <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;password&quot;</span> <span class="attr">name</span>=<span class="string">&quot;passwd&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span> <span class="attr">value</span>=<span class="string">&quot;Submit&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这时候能正常显示出<code>a/index.html</code>页面，url中不再带有参数</p><p><img                       lazyload                     alt="image"                     data-src="https://img1.musnow.top/i/2023/02/63ec8beb1e0c5.png"                      alt="image-20230215153820898"                ></p><p>此时查看后端中的信息，能看到请求方法变为POST，参数出现在了正文部分，而不是url中</p><p><img                       lazyload                     alt="image"                     data-src="https://img1.musnow.top/i/2023/02/63ec8c2e7faa5.png"                      alt="image-20230215153928118"                ></p><h2 id="4-3-GET-x2F-POST区别"><a href="#4-3-GET-x2F-POST区别" class="headerlink" title="4.3 GET&#x2F;POST区别"></a>4.3 GET&#x2F;POST区别</h2><p>这也是GET和POST方法的区别之一：</p><ul><li>GET方法通过url传参</li><li>POST方法会将url参数提取出来，拼接到正文部分</li></ul><p>由此能推出二者的安全性区别</p><ul><li>GET方法相对不安全，因为参数直接以明文贴在了url上</li><li>POST方法以正文传参，使用https协议的时候能进行加密，相对较安全</li></ul><h2 id="4-4-更多方法"><a href="#4-4-更多方法" class="headerlink" title="4.4 更多方法"></a>4.4 更多方法</h2><p>http请求还支持更多方法，如下</p><p><img                       lazyload                     alt="image"                     data-src="https://img1.musnow.top/i/2023/02/63ec8daba6e19.png"                      alt="img"                ></p><h1 id="5-状态码"><a href="#5-状态码" class="headerlink" title="5.状态码"></a>5.状态码</h1><h2 id="5-1-状态码表"><a href="#5-1-状态码表" class="headerlink" title="5.1 状态码表"></a>5.1 状态码表</h2><p>下面是一个响应状态码的总表</p><p><img                       lazyload                     alt="image"                     data-src="https://img1.musnow.top/i/2023/02/63ec8ef551dec.png"                      alt="image-20230215155118813"                ></p><h2 id="5-2-404-x2F-403状态码"><a href="#5-2-404-x2F-403状态码" class="headerlink" title="5.2 404&#x2F;403状态码"></a>5.2 404&#x2F;403状态码</h2><p>我们能看到404和403都是客户端状态码，为什么说是客户端错误呢？这是因为你向服务器请求了一个服务器没有的资源，<strong>这个问题不应该是服务器的问题</strong>。</p><p>这就好比你去西瓜摊买肉，人家压根不卖肉。问题出在你身上，你不应该找西瓜摊老板买肉。所以404状态码，应该是客户端的问题！</p><p>而403状态码的含义是<code>403 forbidden</code>，服务器拒绝了你的请求（你没有权限访问）这也是客户端的问题。你不能去超市买东西，然后问老板能不能让你看看老板的钱罐子。老板肯定不给你看啊！所以才会告诉你403，不给你访问。</p><h2 id="5-3-5xx状态码"><a href="#5-3-5xx状态码" class="headerlink" title="5.3 5xx状态码"></a>5.3 5xx状态码</h2><p>什么时候会出现服务器错误的5xx状态码呢？</p><p>当你请求一个服务，服务端需要处理之后给你返回结果。此时服务器在处理过程中，可能因为程序有bug提前退出，这时候就应该给客户端发送一个<code>5xx</code>状态码，标识服务器在处理你的请求的过程中，出现了错误，无法返回结果。</p><h2 id="5-4-301-x2F-302重定向"><a href="#5-4-301-x2F-302重定向" class="headerlink" title="5.4 301&#x2F;302重定向"></a>5.4 301&#x2F;302重定向</h2><p>关于3开头的状态码，主要谈谈下面这两个</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">301 永久重定向</span><br><span class="line">302 临时重定向</span><br></pre></td></tr></table></figure><p>为何一个是永久，一个是临时呢？</p><p>在http进行响应的时候，服务端可以发送一个<code>location</code>参数，发送一个新的url给客户端；我们的浏览器在收到这个参数后，会自动打开对应的页面</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Location: https://www.baidu.com/</span><br></pre></td></tr></table></figure><p>我们可以用上面的代码来测试一下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 尝试进行302重定向</span></span><br><span class="line">string response = <span class="string">&quot;HTTP/1.1 302 Temporarily moved\r\n&quot;</span>;</span><br><span class="line">response+= <span class="string">&quot;Location: https://www.baidu.com/\r\n&quot;</span>;</span><br><span class="line">response+= <span class="string">&quot;\r\n&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 发送给用户</span></span><br><span class="line"><span class="built_in">send</span>(sock, response.<span class="built_in">c_str</span>(), response.<span class="built_in">size</span>(), <span class="number">0</span>);</span><br></pre></td></tr></table></figure><p>此时访问我们自己的<code>IP:端口</code>，会跳转到百度的页面。这就是重定向的作用</p><p><img                       lazyload                     alt="image"                     data-src="https://img1.musnow.top/i/2023/02/63ec9497019d5.png"                      alt="image-20230215161520817"                ></p><ul><li>那临时重定向和永久重定向有什么区别呢?</li></ul><p>假如我设立了一个公开站点，域名是<code>test.com</code>，这几年一直提供服务，积累了一部分的用户。过了一会，我不想要这个域名了，想换一个<code>test.cn</code>；可用户已经有那么多，大家都只记得你的<code>test.com</code>，如果直接更换域名，就会导致用户无法访问<code>test.com</code>，以为你跑路了，就放弃使用你的网页。</p><p>这样的结果显而易见：严重的客户流失！</p><p>所以，为了避免这个问题，我可以先将服务迁移到<code>test.cn</code>新域名，在旧域名<code>test.com</code>中设置一个301重定向到<code>test.cn</code>，告诉用户我换新域名了。这样持续一段时间后，等到<code>test.com</code>的使用者不多了，就可以考虑彻底取消<code>test.com</code>的解析，关停此域名了。</p><p>在上面的场景中，我是需要更换域名，是永久更换。我们就应该把状态码设置为301，告诉客户端这个域名将被永久重定向到另外一个域名上</p><hr><p>另外的情况是，我有一个<code>example.com</code>域名，我的服务需要进行维护；此时就将<code>example.com</code>重定向到另外一个域名<code>example.cn</code>，指向另外一个服务器，让这个服务器临时提供服务。</p><p>服务维护完毕后，就将重定向取消，继续使用当前的服务器。</p><p>这个场景中，重定向只是维护期间的一个临时策略，所以状态码设置成302，告诉客户端我只是临时进行重定向，我还会回来的。</p><h1 id="6-cookie-x2F-session"><a href="#6-cookie-x2F-session" class="headerlink" title="6.cookie&#x2F;session"></a>6.cookie&#x2F;session</h1><p>日常生活中，当我们在一个web页面中登录了（如github&#x2F;gitee&#x2F;csdn）这个网页在很长一段时间内都会保持登录，直到超时亦或者是出现了异地访问。</p><p>假如你现在有个网页，但是每次用户访问的时候，都需要重新输入用户名和密码，刚刚输入过了，换一个页面又不行了。这样一来，用户还会想用你这个服务吗？</p><p>为了避免此类问题，http协议就需要引入其他的参数，来维持用户的登录会话。cookie&#x2F;session便是因此而来的。</p><h2 id="6-1-set-cookie"><a href="#6-1-set-cookie" class="headerlink" title="6.1 set cookie"></a>6.1 set cookie</h2><p>服务端可以在响应头中带上<code>Set-Cookie</code>字段，给客户端设置上cookie</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">response += <span class="string">&quot;Set-Cookie: This is my cookie test\r\n&quot;</span>;</span><br></pre></td></tr></table></figure><p>打开f12开发者界面，能在其中看到我们设置的cookie</p><p><img                       lazyload                     alt="image"                     data-src="https://img1.musnow.top/i/2023/02/63eca303c2533.png"                      alt="image-20230215171652910"                ></p><p>再次刷新网页，可以看到在之后的请求中，浏览器都会发送一次服务器设置的cookie。这样服务端在收到cookie后，就能解析到自己设置的cookie，确定了指定的用户</p><p><img                       lazyload                     alt="image"                     data-src="https://img1.musnow.top/i/2023/02/63eca34befdf0.png"                      alt="image-20230215171805924"                ></p><p>在服务器端也能看到这个字段</p><p><img                       lazyload                     alt="image"                     data-src="https://img1.musnow.top/i/2023/02/63eca54f23dfe.png"                      alt="image-20230215172640992"                ></p><h2 id="6-2-什么是cookie"><a href="#6-2-什么是cookie" class="headerlink" title="6.2 什么是cookie"></a>6.2 什么是cookie</h2><p>所谓cookie，其实就是浏览器帮我们存取了一定的身份信息在本地（内存or磁盘）</p><p>下一次打开特定的网页的时候，就能显示对应的身份信息（不一定是你的账户密码），并告诉服务器，服务器就识别到了你当前的用户，并为你保持登陆状态。</p><p>既然是保存在用户本地的，那就有可能被窃取。一些恶意软件就会去扫描你浏览器本地缓存中的cookie信息，对于一些安全性不高的网站而言，有了这个cookie，就相当于他有了你的账户，可以直接登录你的账户进行操作。</p><p>因此，引入了另外一种身份认证的方式 <code>cookie+session</code></p><h2 id="6-3-cookie-session"><a href="#6-3-cookie-session" class="headerlink" title="6.3 cookie+session"></a>6.3 cookie+session</h2><p>比起将身份信息存到客户端，存至服务端更为安全（攻击企业服务器的成本，比在用户端植入木马程序的成本更高）</p><ul><li>用户使用账户密码请求登录，服务器收到登录请求，验证成功后，给客户端返回一个<code>唯一字符串session_id</code>来标识用户</li><li>客户端下一次请求的时候，带上了这个唯一字符串</li><li>服务器收到请求，在本地的<code>session_id</code>库中查找这个id，找到后，就将用户信息匹配给客户端，相当于客户端登录成功了</li></ul><p>这样，就将原本存在用户本地的身份认证信息，<strong>存到了服务端中</strong>。客户端就只剩下一个孤零零的字符串id，不会有用户的私密信息。即便丢失，也不会影响用户的隐私。</p><ul><li>你可能会说，那我偷走这个id不也是一样的效果？</li></ul><p>其实没有那么简单，服务端可以将<code>session_id</code>和用户的ip或者终端User-Agent绑定，这样只要用户<strong>切换设备</strong>或者<strong>换了登录的地点</strong>（比如从三亚跑到了哈尔滨）就直接让<code>session_id</code>失效，要求用户重新登录。</p><h1 id="7-长短链接"><a href="#7-长短链接" class="headerlink" title="7.长短链接"></a>7.长短链接</h1><p>在早期的http协议中，采用的都是短链接，一次连接只能处理1次http请求。当时的网页大多以文字为主，数据量很小，一起请求也能够满足需求。</p><p>但现在时代已经变了，一个网页里面有图片，文字，音频，视频。这些文件的体积打起来之后，短链接的方式就不适用了。此时就出现了长链接，一次tcp链接，可以持续传输数据。</p><p>相比短链接，长链接连上之后，能持续传输数据，<strong>避免了tcp3次握手的消耗</strong>，提高了数据传输的效率！</p><h2 id="7-1-Connetion"><a href="#7-1-Connetion" class="headerlink" title="7.1 Connetion"></a>7.1 Connetion</h2><p>在本文的<code>3.4</code>中，便出现了这个参数，一般情况下，会有下面两种情况</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Connetion: keep-alive</span><br><span class="line">Connetion: closed</span><br></pre></td></tr></table></figure><p>其中<code>keep-alive</code>就是长链接，<code>closed</code>代表当前端口只支持短链接。</p><p>当客户端发送的请求头中包含<code>Connetion: keep-alive</code>字段，如果服务器支持长链接，就需要在响应头中也带上<code>Connetion: keep-alive</code>，这样双方协商成功，大家都可以使用长链接。</p><p>如果服务器的响应头中没有带<code>Connetion: keep-alive</code>，那么客户端就会认为服务器不支持长链接，下次请求的时候，会重新向服务器链接，再获取资源。</p><p>如果客户端和服务端任意一方的响应头中包含<code>Connetion: closed</code>，那么就会认为当前的会话只支持短链接，下次请求会重新建立链接。</p><h2 id="7-2-http和tcp的关系"><a href="#7-2-http和tcp的关系" class="headerlink" title="7.2 http和tcp的关系"></a>7.2 http和tcp的关系</h2><p>http虽然是基于tcp的，但http本身是无链接的。</p><blockquote><p>举个最明显的栗子，在你打开一个网页之后，你关闭掉自己的wifi，你的网页并不会因此消失。只是无法进行后续操作而已。</p></blockquote><p>http是一个无链接的应用层协议，其借助tcp进行数据的流式传输，但不一定需要客户端和服务端保持连接。</p><p>所以，http就可以借助单个tcp套接字<strong>持续的传输数据</strong>，也就天然地支持了长链接通信。</p><p>总结一下，http只是借用了tcp的能力，其无连接的特性和tcp没有关系！</p><h2 id="7-3-pipeline"><a href="#7-3-pipeline" class="headerlink" title="7.3 pipeline"></a>7.3 pipeline</h2><p>这其中会牵扯到一个<code>pipeline</code>，其维护了http长链接请求时的<strong>响应顺序</strong>。</p><p>比如人家需要加载一个网页，服务端应该先把网页的整体框架给用户加载出来，再给用户加载图片、视频、音频等资源。下图B站的加载就是一个很好的栗子。</p><p><img                       lazyload                     alt="image"                     data-src="https://img1.musnow.top/i/2023/02/63ee31578364a.png"                      alt="image-20230216213625496"                ></p><p>否则乱序了，比如只出现了一个孤零零的图片，就会让人感觉非常奇怪。</p><h1 id="8-https"><a href="#8-https" class="headerlink" title="8.https"></a>8.https</h1><p>因为http的数据是无加密明文发送的，相对来说并不是非常的安全；为了实现数据加密，https在http的下层添加了一个<code>SSL/TLS</code>软件层，来进行数据加解密工作</p><p><img                       lazyload                     alt="image"                     data-src="https://img1.musnow.top/i/2023/02/63ecc49657516.png"                      alt="image-20230215193931213"                ></p><h2 id="8-1-为啥要加密？"><a href="#8-1-为啥要加密？" class="headerlink" title="8.1 为啥要加密？"></a>8.1 为啥要加密？</h2><p>要知道，所有的加密工作，都是为了防止数据在中间传输的过程，被窃取或修改。如果我们请求一个网站登录的时候，数据包中就会包含我们的账户密码。如果被窃取，我们的隐私就泄露了。这是很难受的一件事！</p><blockquote><p>这也是为什么，我们经常能听到<code>免费公共wifi不安全</code>这一说法，因为我们在这个wifi上进行的所有数据交换，都会走这个wifi的路由器，很容易被<code>中间人</code>窃取并获取到我们的数据包。</p><p>这种情况下，https的加密就更有必要了！</p></blockquote><p>但是，加密解密是需要时间的，所以https响应的速度会稍慢于http。不过当下cpu的执行速度已经非常快，这点时间差距很小，不会特别影响我们的日常使用！</p><p>不过，加密并不是一个万金油，并不是说加密了之后的数据就一定能避免被窃取。但加密可以大大提高窃取破解的成本，无形中降低了数据被窃取的概率，保证了一定的数据安全。</p><h2 id="8-2-常见加密方式"><a href="#8-2-常见加密方式" class="headerlink" title="8.2 常见加密方式"></a>8.2 常见加密方式</h2><h3 id="8-2-1-对称加密"><a href="#8-2-1-对称加密" class="headerlink" title="8.2.1 对称加密"></a>8.2.1 对称加密</h3><p>所谓对称加密，好比有一个带锁的盒子，客户端和服务器都有一把钥匙。客户端先把信息丢进盒子里，再用🔑锁上盒子，发送给服务端。服务端用🔑打开盒子，取出数据。</p><p>因为客户端和服务器持有的钥匙是完全一致的，所以被称为对称加密。在加密的场景下，钥匙一般被称为<code>密钥</code></p><p>在网络场景里，<strong>对称加密是不可取的</strong>。只要客户端和服务端传输密钥的时候被窃取，那么双方的加密就失效了。因为是用同一个密钥来加密解密，我拿走了你的钥匙，自然就能打开你这把锁。</p><p>也就是说，<font color=orange>密钥的传输也需要加密</font>。但是这又引出一个问题，我都没有你的密钥，我怎么解密你发过来的密钥信息？这是一个<code>先有蛋还是先有鸡</code>的死循环！</p><h3 id="8-2-2-非对称加密"><a href="#8-2-2-非对称加密" class="headerlink" title="8.2.2 非对称加密"></a>8.2.2 非对称加密</h3><p>非对称加密场景下，会有一个公钥和私钥</p><ul><li>私钥对数据加密，变成密文</li><li>公钥对数据解密，变成明文</li></ul><p>二者也可以反过来</p><ul><li>私钥对数据解密</li><li>公钥对数据加密</li></ul><p>其中最常用的非对称加密，也就是我们在<a href="https://blog.musnow.top/2022/05/09/note_linux/1%E4%BD%BF%E7%94%A8ssh%E8%BF%9E%E6%8E%A5git/">git的ssh操作</a>中使用过的<code>rsa</code>密钥，其中就有一个<code>.pem</code>公钥和一个私钥。我们将公钥提供给github，私钥保存到本地，就能实现无密码上传数据到git仓库。</p><hr><p>但是非对称加密还是会存在中间人攻击的问题。先看如下图，你应该能发现，其中有一个重要的环节，<strong>就是服务端要把公钥发送给客户端</strong></p><p><img                       lazyload                     alt="image"                     data-src="https://img1.musnow.top/i/2023/02/63ee25050db71.png"                      alt="image-20230216204344555"                ></p><p>在这个场景中，公钥是公开传输给客户端的，也就是后续服务器发送给客户端的所有信息，都可以被其他人用这个公钥解析出来；</p><p>整个环节中，只做到了客户端发送给服务器的信息安全，因为只有服务器拥有私钥，能解密出数据。</p><h3 id="8-2-3-双非对称"><a href="#8-2-3-双非对称" class="headerlink" title="8.2.3 双非对称"></a>8.2.3 双非对称</h3><p>这时候，我们可以采用双非对称密钥加密的方式！既然非对称只能保证单方的数据安全，那使用两个非对称，不就能保证双方数据安全了嘛！</p><ul><li>客户端和服务端交换公钥<code>a&#39; 和 b&#39;</code></li><li>客户端给服务端发信息：先用<code>a&#39;</code>对数据加密，再发送；只能由服务器解密，因为只有服务器有私钥a</li><li>服务端给客户端发信息：先用<code>b&#39;</code>对数据加密，再发送；只能由客户端解密，因为只有客户端有私钥b</li></ul><p><img                       lazyload                     alt="image"                     data-src="https://img1.musnow.top/i/2023/02/63ee2acb5bf6c.png"                      alt="image-20230216210830169"                ></p><p>因为两份私钥都只有客户端和服务器自己拥有，所以黑客没有办法进行数据的窃取，也就保证了数据的安全。</p><p>即便中间人<strong>替换了交换的公钥</strong>，也会因为后续的通信，客户端or服务端<strong>本地的私钥</strong>无法正常解密，而发现数据被窃取！</p><p>但是但是，这样左还算有很大的<strong>缺点</strong></p><ul><li>效率太低（非对称加密解密负载太高，效率低下，特定场景下无法满足要求）</li><li>依旧可能存在安全问题</li></ul><h3 id="8-2-4-非对称-对称"><a href="#8-2-4-非对称-对称" class="headerlink" title="8.2.4 非对称+对称"></a>8.2.4 非对称+对称</h3><ul><li>服务端具有非对称公钥S和私钥S’</li><li>客⼾端发起请求，获取服务端公钥S</li><li>客⼾端在本地生成对称密钥C, 通过公钥S加密, 发送给服务器.</li><li>由于中间人没有私钥，即使截获了数据，也无法还原出内部的原文，也就无法获取到对称密钥</li><li>服务器通过私钥<code>S&#39;</code>解密，还原出客户端发送的对称密钥C，并且使用这个对称密钥加密给客户端发送的响应数据</li><li>后续客户端和服务端都采用密钥C来进行对称加密通信</li></ul><p>因为对称<strong>密钥C在传输过程中是加密</strong>的，只有客户端和服务端知道密钥是什么，也就实现了数据的安全通信！</p><h2 id="8-3-数据摘要（指纹）"><a href="#8-3-数据摘要（指纹）" class="headerlink" title="8.3 数据摘要（指纹）"></a>8.3 数据摘要（指纹）</h2><p>数字指纹(数据摘要)， 其基本原理是利⽤单向散列函数(<code>Hash函数</code>)对信息进行运算，生成⼀串<strong>固定长度</strong>的数字摘要。</p><p>常见的摘要算法有<code>MD5/SHA1/SHA256/SHA512</code>等；</p><p>数字指纹并不是⼀种加密机制，但可以用来判断<strong>数据有没有被窜改</strong>，亦或者是下载的数据包有没有出现损坏。</p><ul><li>同一个数据文件，用同一个方法生成的数据摘要是一致的</li><li>不同文件生成的数据摘要可能会撞车，但几率极低，可以认为具有唯一性！</li><li>我们无法用数据摘要反推出数据内容（怎么可能用一个字符串推测出原本的内容呢？那样还存放源文件干哈？😂）</li></ul><p>数据摘要在网盘产品中也有使用，当我们使用<strong>百度云盘、阿里云盘</strong>的时候，会遇到一个大的资源文件只用了<strong>短短几秒</strong>就成功上传到服务器的情况。此时，我们并不是真的用几秒就把数据传输上去了，而是经历了以下阶段</p><ul><li>网盘客户端对本地文件生成数据摘要</li><li>生成后，判断服务器端<strong>已有文件</strong>中，是否有同该数据摘要相同的文件</li><li>如果有，代表该文件已经存在了云盘的服务器中</li><li>服务器将该文件给你的账户建立一个<strong>软链接&#x2F;硬链接</strong>，就实现了<code>&quot;妙传&quot;</code></li><li>如果没有，则老老实实的从本地上传文件到云盘</li></ul><p>云盘厂家这么做的原因很简单：<strong>避免同一份文件被多次存储</strong>。当下网盘给用户的免费空间动则上T，如果所有文件都重复保存，那对于云服务器厂家来说，资源消耗太大了。</p><p>这个做法并不会产生数据隐私问题，一般只有电影等资源文件才有可能妙传成功。你可以使用一些<code>“其他手段”</code>，比如把资源打个压缩包，并在压缩包中随便丢另外一个文件，让文件的数据指纹和已有资源不相同，就不会进行<code>妙传</code>了。</p><blockquote><p>这样做还有另外一个好处，那就是原资源因为违规被ban的时候，你的资源不会被<code>连坐</code>😂</p></blockquote><h2 id="8-4-数字签名"><a href="#8-4-数字签名" class="headerlink" title="8.4 数字签名"></a>8.4 数字签名</h2><p>对数据摘要进行<strong>加密</strong>，生成的内容被称为<strong>数字签名</strong></p><h2 id="8-5-中间人攻击"><a href="#8-5-中间人攻击" class="headerlink" title="8.5 中间人攻击"></a>8.5 中间人攻击</h2><p>中间人攻击（Man-in-the-MiddleAttack），简称<code>MITM攻击</code></p><p>以<code>8.2.2</code>的单非对称加密为例，中间人可以在整个过程中进行<strong>偷梁换柱</strong>，窃取双方的信息。如下图：</p><p><img                       lazyload                     alt="image"                     data-src="https://img1.musnow.top/i/2023/02/63ee26a502a69.png"                      alt="image-20230216205047679"                ></p><p>透过这个栗子🌰，实际上，如果中间人在客户端和服务端<strong>开始通信之前</strong>就来窃听并<strong>准备换柱</strong>了，他就有可能替换双方密钥，从而解密双方发送的信息！</p><p>最重要的一点，是客户端or服务端<strong>都没有办法证明</strong>，当前的公钥是直接从服务端or客户端发来的，它们没有办法检验公钥的权威性，只能被动接受。由此给中间人<code>偷梁换柱</code>提供了可能。</p><p>这时候，就需要引入CA机构和CA证书了👇</p><h2 id="8-6-CA证书"><a href="#8-6-CA证书" class="headerlink" title="8.6 CA证书"></a>8.6 CA证书</h2><p>所谓CA证书，是由<strong>CA机构</strong>颁发的权威证书。CA机构在颁发证书时，会在证书中附带上该站点的域名，以及申请人（企业）的相关信息</p><ul><li>CA机构会有一个自己的私钥和公钥，其公钥向<strong>所有人</strong>公开</li><li>CA机构的私钥由其自己保存（私钥一定不能泄露）</li><li>当下的浏览器、操作系统都会内置认可的CA；只有被认可的CA，才能为站点提供ssl证书服务</li></ul><p>在我们windows本地就能看到当前操作系统认可的CA机构其公钥；在edge浏览器中，点击右上角选择，进入设置，在选择隐私页面，找到<code>管理证书</code></p><p><img                       lazyload                     alt="image"                     data-src="https://img1.musnow.top/i/2023/02/63ee3dd712d42.png"                      alt="image-20230216222946008"                ></p><p>点击它，就能看到当前本地认可的CA</p><p><img                       lazyload                     alt="image"                     data-src="https://img1.musnow.top/i/2023/02/63ee3e40b1733.png"                      alt="image-20230216223131725"                ></p><h3 id="8-6-1-ssl证书加密原理"><a href="#8-6-1-ssl证书加密原理" class="headerlink" title="8.6.1 ssl证书加密原理"></a>8.6.1 ssl证书加密原理</h3><p>当一个站点获取了ssl证书后，在向用户发送ssl证书中包含的公钥的同时，还会发送一个<strong>由CA机构</strong>对ssl证书公钥做的<strong>数字签名</strong></p><ul><li>ssl证书公钥的数字签名A，通过CA机构的<strong>私钥</strong>进行加密</li><li>ssl证书的公钥B</li></ul><p>当客户端收到这份信息之后，会采用hash函数对收到的ssl证书公钥进行数字签名，得到一个<strong>本地生成的数字签名C</strong></p><p>再用CA机构的公钥对传输过来的数字签名A进行解密，得到数字签名A的明文；判断由CA机构生成的ssl公钥数字签名A是否和本地生成的数字签名C相同；</p><ul><li>如果相同，则代表证书正确！</li><li>不相同，代表证书出现错误！</li></ul><p>画个图，大概就是下面这样</p><p><img                       lazyload                     alt="image"                     data-src="https://img1.musnow.top/i/2023/02/63ee3aa8d2aa1.png"                      alt="image-20230216221611664"                ></p><p>由于当下发送的数据包中，同时存在ssl公钥的明文+由CA机构加密后的数字签名，中间人无法进行任何攻击修改！</p><ul><li>若修改ssl公钥，由于中间人没有CA机构的私钥，无法对修改后的ssl公钥生成对应的加密后数字签名</li><li>若使用CA公钥解密数字签名后修改……依旧会因为没有CA机构私钥，无法把修改后的签名加密回去</li><li>如果中间人用自己的私钥生成一个数字签名，但我不认识你这个CA，也不知道你的公钥是什么，怎么解密你的信息呢？</li></ul><p>综上，中间人要想偷梁换柱，只有一个办法了，那就是拿一个<strong>真的证书</strong>整体替换掉这个数据包。</p><p>可ssl证书中还包含了域名、站点主体等各类信息，我当下访问的是<code>baidu.com</code>，结果收到的证书是<code>qq.com</code>的，那肯定有问题啊！浏览器会直接拒绝访问！😂</p><p>当我们访问一些网站，<strong>浏览器报ssl证书过期</strong>，也是会出现一定的安全问题的！</p><h3 id="8-6-2-ssl证书-非对称-对称"><a href="#8-6-2-ssl证书-非对称-对称" class="headerlink" title="8.6.2 ssl证书+非对称+对称"></a>8.6.2 ssl证书+非对称+对称</h3><p>有了上面这个不能被篡改的ssl证书公钥，下面我们就可以利用<code>非对称+对称加密</code>的方式进行通信了</p><ul><li>客户端收到ssl证书，向服务器发送一个本地生成的密钥D（使用ssl证书公钥进行加密）</li><li>服务端收到密钥D的加密信息，使用ssl证书的私钥进行解密，获取到密钥D</li><li>客户端和服务端使用密钥D进行对称加密通信</li></ul><p>这样即解决了安全问题，又规避了非对称加密的效率问题，一举多得！</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;已经学习过自己定制一个协议了，现在就来看看当下广泛使用的http协议吧&lt;/p&gt;</summary>
    
    
    
    <category term="玩上Linux" scheme="https://blog.musnow.top/categories/%E7%8E%A9%E4%B8%8ALinux/"/>
    
    
    <category term="Linux" scheme="https://blog.musnow.top/tags/Linux/"/>
    
    <category term="网络" scheme="https://blog.musnow.top/tags/%E7%BD%91%E7%BB%9C/"/>
    
    <category term="http" scheme="https://blog.musnow.top/tags/http/"/>
    
  </entry>
  
  <entry>
    <title>【网络】自定义协议 | 序列化和反序列化 | Jsoncpp</title>
    <link href="https://blog.musnow.top/2023/02/12/Linux/33jsoncpp%E5%BA%8F%E5%88%97%E5%8C%96/"/>
    <id>https://blog.musnow.top/2023/02/12/Linux/33jsoncpp%E5%BA%8F%E5%88%97%E5%8C%96/</id>
    <published>2023-02-12T04:30:55.000Z</published>
    <updated>2023-03-11T11:25:36.240Z</updated>
    
    <content type="html"><![CDATA[<p>以tcpServer的<strong>计算器</strong>服务为例，实现用jsoncpp来进行序列化和反序列化</p><span id="more"></span><blockquote><p>阅读本文之前，请先阅读 <a href="https://blog.musnow.top/2023/02/11/note_linux/32tcp%E5%AE%9E%E7%8E%B0%E8%87%AA%E5%AE%9A%E4%B9%89%E5%8D%8F%E8%AE%AE/">自定义协议 | 序列化和反序列化 | 以tcpServer为例</a></p></blockquote><h1 id="1-安装包"><a href="#1-安装包" class="headerlink" title="1.安装包"></a>1.安装包</h1><p>我所用的系统是<code>centos7.6</code>，先用下面的命令查找相关的包</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo yum list | grep jsoncpp-devel</span><br></pre></td></tr></table></figure><p>显示出来的包如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Repository epel is listed more than once in the configuration</span><br><span class="line">jsoncpp-devel.x86_64                0.10.5-2.el7           @epel </span><br></pre></td></tr></table></figure><p>随后安装这个包</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo yum install jsoncpp</span><br></pre></td></tr></table></figure><p>不知道为什么，安装<code>jsoncpp-devel.x86_64</code>显示找不到相关包</p><h2 id="1-1-什么是json？"><a href="#1-1-什么是json？" class="headerlink" title="1.1 什么是json？"></a>1.1 什么是json？</h2><p>json是一个kv键值对的序列化方式，每一个key都对应了一个value</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line"><span class="attr">&quot;data&quot;</span><span class="punctuation">:</span> <span class="string">&quot;value&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>这就有点类似c++中的map，不过json能做的更多</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line"><span class="attr">&quot;data1&quot;</span><span class="punctuation">:</span> <span class="string">&quot;value&quot;</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;data2&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line"><span class="attr">&quot;key1&quot;</span><span class="punctuation">:</span><span class="string">&quot;value1&quot;</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;key2&quot;</span><span class="punctuation">:</span><span class="string">&quot;value2&quot;</span><span class="punctuation">,</span></span><br><span class="line">         <span class="attr">&quot;key3&quot;</span><span class="punctuation">:</span><span class="number">0</span><span class="punctuation">,</span></span><br><span class="line">         <span class="attr">&quot;key4&quot;</span><span class="punctuation">:</span><span class="keyword">true</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>json可以在里面嵌套添加更多的内容，不管是字符串还是整形，还能是bool类型的<code>true/false</code>；</p><p>因为json对反序列化序列化的控制很是不错，可读性也很好，所以被广泛使用！</p><p>相比于自己写一个序列化方式，直接用别人的轮子，也不错👻</p><p>类似的序列化框架还有<code>xml</code></p><h1 id="2-代码示例"><a href="#2-代码示例" class="headerlink" title="2.代码示例"></a>2.代码示例</h1><h2 id="2-1-序列化"><a href="#2-1-序列化" class="headerlink" title="2.1 序列化"></a>2.1 序列化</h2><p>相比我们自己写的序列化方式，json的使用简单多了</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">serialize</span><span class="params">(std::string&amp; out)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">     <span class="comment">//使用jsoncpp的代码</span></span><br><span class="line">    Json::Value root;</span><br><span class="line">    root[<span class="string">&quot;x&quot;</span>] = _x;</span><br><span class="line">    root[<span class="string">&quot;y&quot;</span>] = _y;</span><br><span class="line">    root[<span class="string">&quot;op&quot;</span>] = _ops;</span><br><span class="line"></span><br><span class="line">    Json::FastWriter fw; <span class="comment">// 这个是写成一行，对于计算机来说处理的负担小</span></span><br><span class="line">    <span class="comment">// Json::StyledWriter fw; // 这个会进行格式化，更好看（但是内容没差距）</span></span><br><span class="line">    out = fw.<span class="built_in">write</span>(root);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于<code>fw.write(root)</code>，其返回值是一个string，也方便我们接收</p><p><img                       lazyload                     alt="image"                     data-src="https://img1.musnow.top/i/2023/02/63e87f6032516.png"                      alt="image-20230212135543386"                ></p><p>其中<code>FastWriter</code>和<code>StyledWriter</code>有一点区别，如下</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//FastWriter</span></span><br><span class="line"><span class="punctuation">&#123;</span><span class="attr">&quot;data&quot;</span><span class="punctuation">:</span> <span class="string">&quot;value&quot;</span><span class="punctuation">&#125;</span></span><br><span class="line"><span class="comment">//StyledWriter</span></span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line"><span class="attr">&quot;data&quot;</span><span class="punctuation">:</span> <span class="string">&quot;value&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>简单来说，<code>StyledWriter</code>会对我们的kv键值对进行格式化，更方便人类的阅读。而<code>FastWriter</code>是直接写成一整行，在传输的时候会方便一点（因为不需要<code>\n</code>）</p><h2 id="2-2-反序列化"><a href="#2-2-反序列化" class="headerlink" title="2.2 反序列化"></a>2.2 反序列化</h2><p>反序列化需要一个Reader来读取字符串，并将其内容根据键值隐射给成员变量</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">deserialize</span><span class="params">(<span class="type">const</span> std::string &amp;in)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//json</span></span><br><span class="line">    Json::Value root;</span><br><span class="line">    Json::Reader rd;</span><br><span class="line">    rd.<span class="built_in">parse</span>(in, root);</span><br><span class="line">    _x = root[<span class="string">&quot;x&quot;</span>].<span class="built_in">asInt</span>();</span><br><span class="line">    _y = root[<span class="string">&quot;y&quot;</span>].<span class="built_in">asInt</span>();</span><br><span class="line">    _ops = root[<span class="string">&quot;op&quot;</span>].<span class="built_in">asInt</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="3-测试"><a href="#3-测试" class="headerlink" title="3.测试"></a>3.测试</h1><p>因为jsoncpp是一个第三方库，我们链接的时候需要加上命令<code>-ljsoncpp</code></p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">tcpServer:tcpServer.cpp</span></span><br><span class="line">g++ -o <span class="variable">$@</span> <span class="variable">$^</span> -std=c++11 -lpthread -ljsoncpp</span><br></pre></td></tr></table></figure><p>发送消息后，可以看到，json帮我们格式化为如下形式的字符串</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span><span class="attr">&quot;op&quot;</span><span class="punctuation">:</span><span class="number">43</span><span class="punctuation">,</span><span class="attr">&quot;x&quot;</span><span class="punctuation">:</span><span class="number">1</span><span class="punctuation">,</span><span class="attr">&quot;y&quot;</span><span class="punctuation">:</span><span class="number">200</span><span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#123;</span><span class="attr">&quot;op&quot;</span><span class="punctuation">:</span><span class="number">43</span><span class="punctuation">,</span><span class="attr">&quot;x&quot;</span><span class="punctuation">:</span><span class="number">333</span><span class="punctuation">,</span><span class="attr">&quot;y&quot;</span><span class="punctuation">:</span><span class="number">234</span><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p><img                       lazyload                     alt="image"                     data-src="https://img1.musnow.top/i/2023/02/63e8829420bc4.png"                      alt="image-20230212140924067"                ></p><h1 id="4-gcc给予宏定义"><a href="#4-gcc给予宏定义" class="headerlink" title="4.gcc给予宏定义"></a>4.gcc给予宏定义</h1><p>为了方便对序列化采用的方式进行控制，这里我使用了预处理指令<code>ifdef/endif</code>来进行判断，只要我们在文件头定义了<code>MYPROTOCOL</code>，这里就会采用我们自己的写的序列化方式，否则采用json</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MYPROTOCOL 1  <span class="comment">//如果define了这个，那就使用自己的代码</span></span></span><br></pre></td></tr></table></figure><p><img                       lazyload                     alt="image"                     data-src="https://img1.musnow.top/i/2023/02/63e8bdcb448d6.png"                      alt="image-20230212182113854"                ></p><h2 id="4-1-命令行"><a href="#4-1-命令行" class="headerlink" title="4.1 命令行"></a>4.1 命令行</h2><p>但是在文件里面修改define还是不太方便，我们可以直接采用gcc的命令行参数的方式，进行define的插入（这么做之前，要先删除文件中对<code>MYPROTOCOL</code>的define）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">g++ -DMYPROTOCOL tcpServer.cpp -o tcpServer -lpthread -ljsoncpp</span><br><span class="line">g++ -DMYPROTOCOL tcpClient.cpp -o tcpClient -lpthread -ljsoncpp</span><br></pre></td></tr></table></figure><p>可以看到，不加编译指令编译出来的服务器，采用的是json的方式来序列化</p><p><img                       lazyload                     alt="image"                     data-src="https://img1.musnow.top/i/2023/02/63e8bed2edae3.png"                      alt="image-20230212182627766"                ></p><p>添加了之后，就是用我们自己写的序列化方式来序列化了</p><p><img                       lazyload                     alt="image"                     data-src="https://img1.musnow.top/i/2023/02/63e8bf7e58fae.png"                      alt="image-20230212182919150"                ></p><h2 id="4-2-makefile"><a href="#4-2-makefile" class="headerlink" title="4.2 makefile"></a>4.2 makefile</h2><p>因此，我们可以修改makefile来实现这一点</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"><span class="keyword">.PHONY</span>:all</span></span><br><span class="line"><span class="section">all:tcpClient tcpServer</span></span><br><span class="line">MYSELF=-DMYPROTOCOL</span><br><span class="line"></span><br><span class="line"><span class="section">tcpClient: tcpClient.cpp</span></span><br><span class="line">g++ <span class="variable">$(MYSELF)</span> -o <span class="variable">$@</span> <span class="variable">$^</span> -std=c++11 -lpthread -ljsoncpp</span><br><span class="line"><span class="section">tcpServer:tcpServer.cpp</span></span><br><span class="line">g++ <span class="variable">$(MYSELF)</span> -o <span class="variable">$@</span> <span class="variable">$^</span> -std=c++11 -lpthread -ljsoncpp</span><br><span class="line"></span><br><span class="line"><span class="meta"><span class="keyword">.PHONY</span>:clean</span></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">rm -f tcpClient tcpServer</span><br></pre></td></tr></table></figure><p>当我们需要用自己协议的时候，就在最前面加上</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MYSELF=-DMYPROTOCOL</span><br></pre></td></tr></table></figure><p>否则直接<strong>删除</strong>这个定义，或者注释掉后面的内容，就能采用jsoncpp</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MYSELF=<span class="comment">#-DMYPROTOCOL</span></span><br></pre></td></tr></table></figure><p>这样就方便一些了</p><p><img                       lazyload                     alt="image"                     data-src="https://img1.musnow.top/i/2023/02/63e8c0cf35f88.png"                      alt="image-20230212183456024"                ></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;以tcpServer的&lt;strong&gt;计算器&lt;/strong&gt;服务为例，实现用jsoncpp来进行序列化和反序列化&lt;/p&gt;</summary>
    
    
    
    <category term="玩上Linux" scheme="https://blog.musnow.top/categories/%E7%8E%A9%E4%B8%8ALinux/"/>
    
    
    <category term="Linux" scheme="https://blog.musnow.top/tags/Linux/"/>
    
    <category term="网络" scheme="https://blog.musnow.top/tags/%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
</feed>
