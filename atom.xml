<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>慕雪的寒舍</title>
  
  <subtitle>雪下了一夜</subtitle>
  <link href="https://blog.musnow.top/atom.xml" rel="self"/>
  
  <link href="https://blog.musnow.top/"/>
  <updated>2024-03-19T04:47:49.000Z</updated>
  <id>https://blog.musnow.top/</id>
  
  <author>
    <name>慕雪年华</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>【leetcode】哈希OJ题，383赎金信/202快乐数/242有效的字母异位词</title>
    <link href="https://blog.musnow.top/posts/4214339491/"/>
    <id>https://blog.musnow.top/posts/4214339491/</id>
    <published>2024-03-18T08:18:13.000Z</published>
    <updated>2024-03-19T04:47:49.000Z</updated>
    
    <content type="html"><![CDATA[<p>这几道哈希的题目，其用到的思想适用于很多可以用哈希来解决的题目。</p><h1 id="383-赎金信"><a href="#383-赎金信" class="headerlink" title="383. 赎金信"></a>383. 赎金信</h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><blockquote><p><a href="https://leetcode.cn/problems/ransom-note/">383. 赎金信</a></p></blockquote><p>给你两个字符串：<code>ransomNote</code> 和 <code>magazine</code> ，判断 <code>ransomNote</code> 能不能由 <code>magazine</code> 里面的字符构成。</p><p>如果可以，返回 <code>true</code> ；否则返回 <code>false</code> 。</p><p><code>magazine</code> 中的每个字符只能在 <code>ransomNote</code> 中使用一次。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">示例 1：</span><br><span class="line">输入：ransomNote = &quot;a&quot;, magazine = &quot;b&quot;</span><br><span class="line">输出：false</span><br><span class="line"></span><br><span class="line">示例 2：</span><br><span class="line">输入：ransomNote = &quot;aa&quot;, magazine = &quot;ab&quot;</span><br><span class="line">输出：false</span><br><span class="line"></span><br><span class="line">示例 3：</span><br><span class="line">输入：ransomNote = &quot;aa&quot;, magazine = &quot;aab&quot;</span><br><span class="line">输出：true</span><br></pre></td></tr></table></figure><ul><li><code>1 &lt;= ransomNote.length, magazine.length &lt;= 105</code></li><li><code>ransomNote</code> 和 <code>magazine</code> 由小写英文字母组成</li></ul><h2 id="思路和代码"><a href="#思路和代码" class="headerlink" title="思路和代码"></a>思路和代码</h2><p>因为给出的两个字符串里面都只包含小写的英文字母，所以我们用不上<code>unordered_map</code>，只需要用一个26长度的int数组就可以了。</p><ul><li>26长度的int数组，全部初始化为0；</li><li>遍历，记录magazine中每一个字符出现的次数；</li><li>遍历ransomNote字符串，将magazine中对应字符计数器减一；</li><li>如果某个计数器减至负数，则说明magazine中的字符不够用，返回false；</li><li>如果遍历完毕没有出现问题，则返回true；</li></ul><p>代码如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">canConstruct</span><span class="params">(string ransomNote, string magazine)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(ransomNote.<span class="built_in">size</span>() &gt; magazine.<span class="built_in">size</span>())&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">// 因为已经超过了字符大小，所以肯定不符合条件</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> arr[<span class="number">26</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i&lt;magazine.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            arr[magazine[i] -<span class="string">&#x27;a&#x27;</span>] ++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i&lt;ransomNote.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            arr[ransomNote[i] -<span class="string">&#x27;a&#x27;</span>] --;</span><br><span class="line">            <span class="keyword">if</span>(arr[ransomNote[i] -<span class="string">&#x27;a&#x27;</span>] &lt; <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/03/8a3bc3b098bf98a6b3b28842d6ef6436.png" alt="image-20240318180705925"></p><h1 id="202-快乐数"><a href="#202-快乐数" class="headerlink" title="202. 快乐数"></a>202. 快乐数</h1><h2 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h2><blockquote><p><a href="https://leetcode.cn/problems/happy-number/">202. 快乐数</a></p></blockquote><p>编写一个算法来判断一个数 <code>n</code> 是不是快乐数。</p><p><strong>「快乐数」</strong> 定义为：</p><ul><li>对于一个正整数，每一次将该数替换为它每个位置上的数字的平方和。</li><li>然后重复这个过程直到这个数变为 1，也可能是 <strong>无限循环</strong> 但始终变不到 1。</li><li>如果这个过程 <strong>结果为</strong> 1，那么这个数就是快乐数。</li></ul><p>如果 <code>n</code> 是 <em>快乐数</em> 就返回 <code>true</code> ；不是，则返回 <code>false</code> 。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">示例 1：</span><br><span class="line">输入：n = 19</span><br><span class="line">输出：true</span><br><span class="line">解释：</span><br><span class="line">12 + 92 = 82</span><br><span class="line">82 + 22 = 68</span><br><span class="line">62 + 82 = 100</span><br><span class="line">12 + 02 + 02 = 1</span><br><span class="line"></span><br><span class="line">示例 2：</span><br><span class="line">输入：n = 2</span><br><span class="line">输出：false</span><br></pre></td></tr></table></figure><ul><li><code>1 &lt;= n &lt;= 231 - 1</code></li></ul><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>这道题其实是个数学题，用到哈希的地方是判断之前出现的结果是否已经出现过了。题目中提到“然后重复这个过程直到这个数变为 1，也可能是 <strong>无限循环</strong> 但始终变不到 1”，即可能会有用例，到最后计算的结果出现无限循环。</p><p>此时就需要用哈希来判断某一个结果是否已经出现过，如果出现过，第二次出现的时候就说明重复了，返回false退出循环计算即可。</p><p>代码如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="comment">// 每一次的计算</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getSum</span><span class="params">(<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="type">int</span> sum = <span class="number">0</span>; <span class="comment">// 这里必须赋值为0</span></span><br><span class="line">        <span class="keyword">while</span>(n &gt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            sum += (n%<span class="number">10</span>)*(n%<span class="number">10</span>);</span><br><span class="line">            n/=<span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isHappy</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        unordered_set&lt;<span class="type">int</span>&gt; sets;</span><br><span class="line">        <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            sum = <span class="built_in">getSum</span>(n);</span><br><span class="line">            cout &lt;&lt; sum &lt;&lt; endl;</span><br><span class="line">            <span class="keyword">if</span>(sum == <span class="number">1</span>)&#123; <span class="comment">// 符合题目条件</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(sets.<span class="built_in">count</span>(sum) != <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">// 出现重复了</span></span><br><span class="line">            &#125;</span><br><span class="line">            sets.<span class="built_in">insert</span>(sum);</span><br><span class="line">            n = sum;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/03/839bd09fa76c380a299c5e0c319ad1b9.png" alt="image-20240318181637436"></p><h1 id="242-有效的字母异位词"><a href="#242-有效的字母异位词" class="headerlink" title="242. 有效的字母异位词"></a>242. 有效的字母异位词</h1><h2 id="题目-2"><a href="#题目-2" class="headerlink" title="题目"></a>题目</h2><blockquote><p><a href="https://leetcode.cn/problems/valid-anagram/">242. 有效的字母异位词</a></p></blockquote><p>给定两个字符串 <code>*s*</code> 和 <code>*t*</code> ，编写一个函数来判断 <code>*t*</code> 是否是 <code>*s*</code> 的字母异位词。</p><p><strong>注意：</strong>若 <code>*s*</code> 和 <code>*t*</code> 中每个字符出现的次数都相同，则称 <code>*s*</code> 和 <code>*t*</code> 互为字母异位词。</p><p><strong>示例 1:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: s = &quot;anagram&quot;, t = &quot;nagaram&quot;</span><br><span class="line">输出: true</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: s = &quot;rat&quot;, t = &quot;car&quot;</span><br><span class="line">输出: false</span><br></pre></td></tr></table></figure><p><strong>提示:</strong></p><ul><li><code>1 &lt;= s.length, t.length &lt;= 5 * 104</code></li><li><code>s</code> 和 <code>t</code> 仅包含小写字母</li></ul><h2 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h2><p>字母异位词就是两个字符串中所有字符出现的次数都相同，如果有不同的就不是字母异位词。</p><p>可以用两种思路来解决</p><ul><li>对字符串排序，字母异位词排序后的结果肯定相同</li><li>使用哈希计算每个字符出现的次数，比较两个字符串中每个字符出现的次数是否相同，不相同则出现错误</li></ul><p>这里采用哈希的思路，代码如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isAnagram</span><span class="params">(string s, string t)</span> </span>&#123;</span><br><span class="line">        unordered_map&lt;<span class="type">char</span>,<span class="type">int</span>&gt; maps;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span>&amp;e:s)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(!maps.<span class="built_in">count</span>(e))</span><br><span class="line">            &#123;</span><br><span class="line">                maps[e] = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                maps[e]++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span>&amp;e:t)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(!maps.<span class="built_in">count</span>(e))&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            maps[e]--;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span>&amp;e:maps)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(e.second != <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/03/092cbf9c367cf0a04561d745cb40624d.png" alt="image-20240318181945788"></p>]]></content>
    
    
    <summary type="html">哈希OJ题，383赎金信/202快乐数/242有效的字母异位词</summary>
    
    
    
    <category term="编程学习" scheme="https://blog.musnow.top/categories/%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="把题目都给刷干净" scheme="https://blog.musnow.top/categories/%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0/%E6%8A%8A%E9%A2%98%E7%9B%AE%E9%83%BD%E7%BB%99%E5%88%B7%E5%B9%B2%E5%87%80/"/>
    
    
    <category term="OJ刷题" scheme="https://blog.musnow.top/tags/OJ%E5%88%B7%E9%A2%98/"/>
    
    <category term="Cpp" scheme="https://blog.musnow.top/tags/Cpp/"/>
    
    <category term="leetcode" scheme="https://blog.musnow.top/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>【C语言】带你用偷懒的方式刷爆二叉树OJ题</title>
    <link href="https://blog.musnow.top/posts/4165981723/"/>
    <id>https://blog.musnow.top/posts/4165981723/</id>
    <published>2024-03-15T08:25:30.000Z</published>
    <updated>2024-03-17T08:25:30.000Z</updated>
    
    <content type="html"><![CDATA[<p>本文首发于<code>2022-04-20</code>，2024年重新刷题，对本文做了较大更新，所以重新发布。</p><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>上篇博客我带大家领略了一番链式二叉树的操作，现在让我们来看看二叉树的相关题目，一起来巩固一下知识点吧！</p><p>点我复习上一篇博客的内容！👉 <a href="https://blog.csdn.net/muxuen/article/details/124212851?spm=1001.2014.3001.5501">传送门</a>；</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2023/02/202204161641683.gif" alt="QQ图片20220416140203"></p><h1 id="1-一些选择题"><a href="#1-一些选择题" class="headerlink" title="1.一些选择题"></a>1.一些选择题</h1><h2 id="1-1"><a href="#1-1" class="headerlink" title="1.1"></a>1.1</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">设一棵二叉树中有3个叶子结点，有8个度为1的结点，则该二叉树中总的结点数为（ ）个</span><br><span class="line">A.11</span><br><span class="line">B.12</span><br><span class="line">C.13  √</span><br><span class="line">D.14</span><br></pre></td></tr></table></figure><blockquote><p>设Ni表示度为i的节点个数，则节点总数 N &#x3D; N0 + N1 + N2</p><p>节点个数于节点边的关系： <strong>N个节点的树有N-1个边</strong></p><p>边与度的关系：N - 1 &#x3D; N1 + 2 * N2</p><p>故：N0 + N1 + N2 - 1 &#x3D; N1 + 2 * N2</p><p>因此，得：N0 &#x3D; N2 + 1</p><p>回到原题，N0 &#x3D; 3，N1 &#x3D; 8，可得N2 &#x3D; 2</p><p>因此答案是 3 + 8 + 2 &#x3D; 13</p></blockquote><h2 id="1-2"><a href="#1-2" class="headerlink" title="1.2"></a>1.2</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">有N个元素的完全二叉树的深度是()</span><br><span class="line">答案：logN+1</span><br></pre></td></tr></table></figure><p>高度为h的完全二叉树，节点个数在： <code>2^(h - 1) - 1 &lt; n &lt;= 2^h - 1</code></p><p>即<code>log(n + 1) &lt;= h &lt; log(n + 1) + 1</code></p><p>这里需要注意的是n左右区间的开闭问题</p><p>完全二叉树最少的节点个数是<code>2^(h - 1)-1+1</code>个，所以是<code>n&gt;2^(h - 1) - 1</code></p><hr><h2 id="1-3-由已知遍历序列画出原本树的结构"><a href="#1-3-由已知遍历序列画出原本树的结构" class="headerlink" title="1.3 由已知遍历序列画出原本树的结构"></a>1.3 由已知遍历序列画出原本树的结构</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">已知某二叉树的中序遍历序列为JGDHKBAELIMCF，后序遍历序列为JGKHDBLMIEFCA，则其前序遍历序列为（ ）</span><br><span class="line">A.ABDGHJKCEFILM</span><br><span class="line">B.ABDGJHKCEILMF   √</span><br><span class="line">C.ABDHKGJCEILMF</span><br><span class="line">D.ABDGJHKCEIMLF</span><br></pre></td></tr></table></figure><p>这道题我刚开始的思路是错的，因为我把它当作完全二叉树来看待，但题目并没有说它是完全二叉树</p><blockquote><p>主要思路：可以从后续遍历确定根节点为A，中序遍历可以确定A的左右子树。再继续从后序遍历中确定A左右子树的根节点，依次往下判断</p></blockquote><p>所以我画了一个分析图，如下👇</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2023/02/202204161628643.jpg" alt="IMG_20220415_103954"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">已知某二叉树的前序遍历序列为ABDEC，中序遍历序列为BDEAC，则该二叉树（ ）</span><br><span class="line">A.是满二叉树</span><br><span class="line">B.是完全二叉树，不是满二叉树</span><br><span class="line">C.不是完全二叉树   √</span><br><span class="line">D.是所有的结点都没有右子树的二叉树</span><br></pre></td></tr></table></figure><p>这道题的思路和上一道题是一样的</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2023/02/202204161631511.png" alt="image-20220416163152483"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">已知某二叉树的前序遍历序列为5 7 4 9 6 2 1，中序遍历序列为4 7 5 6 9 1 2，则其后序遍历序列为（ ）</span><br><span class="line">A.4 2 5 7 6 9 1</span><br><span class="line">B.4 2 7 5 6 9 1</span><br><span class="line">C.4 7 6 1 2 9 5  √</span><br><span class="line">D.4 7 2 9 5 6 1</span><br></pre></td></tr></table></figure><p>本题依旧和上面两道题思路相同！</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2023/02/202204161632859.jpg" alt="IMG_20220415_105012"></p><h2 id="1-4-单边树"><a href="#1-4-单边树" class="headerlink" title="1.4 单边树"></a>1.4 单边树</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">一棵非空的二叉树的先序遍历序列与后序遍历序列正好相反，则该二叉树一定满足（ ）</span><br><span class="line">A.所有的结点均无左孩子</span><br><span class="line">B.所有的结点均无右孩子</span><br><span class="line">C.只有一个叶子结点</span><br><span class="line">D.至多只有一个结点</span><br></pre></td></tr></table></figure><p>如果前序遍历和后序遍历序列正好相反，说明它是一个单边树，比如下面这前序和中序序列所构成的树的结构:</p><p>12345（纵向）</p><p>54321</p><p>对于单边树，只有一个叶子节点</p><hr><h2 id="1-5"><a href="#1-5" class="headerlink" title="1.5"></a>1.5</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">20.如果一颗二叉树的前序遍历的结果是ABCD，则满足条件的不同的二叉树有（ ）种</span><br><span class="line"></span><br><span class="line">A.13</span><br><span class="line">B.14 √</span><br><span class="line">C.15</span><br><span class="line">D.16</span><br></pre></td></tr></table></figure><blockquote><p>首先这棵二叉树的高度一定在3~4层之间:</p><p>三层：</p><p>A(B(C,D),()), A((),B(C,D)), A(B(C,()),D), A(B((),C),D),</p><p>A(B,C(D,())), A(B,C((),D))</p><p>四层：</p><p>如果为四层，就是单边树，每一层只有一个节点，除过根节点，其他节点都有两种选择，在上层节点的左边还是右边，所以<code>2*2*2</code>共8种</p><p>总共为14种。</p></blockquote><hr><h1 id="2-OJ题刷起来！"><a href="#2-OJ题刷起来！" class="headerlink" title="2.OJ题刷起来！"></a>2.OJ题刷起来！</h1><h2 id="KY11-二叉树遍历"><a href="#KY11-二叉树遍历" class="headerlink" title="KY11 二叉树遍历"></a>KY11 二叉树遍历</h2><blockquote><p>牛客网 KY11 二叉树遍历 👉<a href="https://www.nowcoder.com/practice/4b91205483694f449f94c179883c1fef?tpId=60&&tqId=29483&rp=1&ru=/activity/oj&qru=/ta/tsing-kaoyan/question-ranking">传送门</a></p></blockquote><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2023/02/202204161645079.png" alt="image-20220416164513012"></p><p>这道题要求我们用先序遍历的操作从<strong>一个数组中读出一个树</strong>，并构建出树的基本结构，再用中序遍历的方式打印出这颗树</p><p>之前我们学习了前序遍历的操作，这里只需要把前序遍历中的printf操作改成构建新树即可</p><ul><li>因为涉及道i的多次调用，所以函数中的i需要取地址，必须保证多次调用的i会同步++</li><li>构建完树的节点，并赋值后，需要递归构建左右子树，最后返回节点的地址</li><li>题目中的#代表NULL，直接return空即可</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdbool.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">char</span> BTDataType;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">BTreeNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">BTDataType data;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">BTreeNode</span>* <span class="title">left</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">BTreeNode</span>* <span class="title">right</span>;</span></span><br><span class="line">&#125;BTNode;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 二叉树中序遍历 </span></span><br><span class="line"><span class="type">void</span> <span class="title function_">BTreeInOrder</span><span class="params">(BTNode* root)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (root == <span class="literal">NULL</span>)&#123;</span><br><span class="line"><span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">BTreeInOrder(root-&gt;left);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%c &quot;</span>, root-&gt;data);</span><br><span class="line">BTreeInOrder(root-&gt;right);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">BTNode* <span class="title function_">CreatTree</span><span class="params">(<span class="type">char</span> *arr,<span class="type">int</span>*i)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (arr[*i] == <span class="string">&#x27;#&#x27;</span>)&#123;</span><br><span class="line">        (*i)++;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">    BTNode* newnode=(BTNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(BTNode));</span><br><span class="line">    </span><br><span class="line">    newnode-&gt;data=arr[(*i)++];<span class="comment">//i必须取地址</span></span><br><span class="line">    newnode-&gt;left=CreatTree(arr,i);<span class="comment">//递归构建左子树</span></span><br><span class="line">    newnode-&gt;right=CreatTree(arr,i);<span class="comment">//递归构建右子树</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> newnode;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> arr[<span class="number">100</span>];</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,arr);</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> i=<span class="number">0</span>;</span><br><span class="line">    BTNode* root=CreatTree(arr,&amp;i);</span><br><span class="line">    BTreeInOrder(root);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="100-相同的树"><a href="#100-相同的树" class="headerlink" title="100 相同的树"></a>100 相同的树</h2><blockquote><p>leetcode：<a href="https://leetcode-cn.com/problems/same-tree/">100. 相同的树</a></p></blockquote><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2023/02/202204161652255.png" alt="image-20220416165211195"></p><p>题目要求很简单，给定两颗树的根节点，要求我们判断这两棵树是否相同</p><ul><li>如果两棵树都为空，树相同</li><li>如果其中一个为空，另外一个不为空，树不同</li><li>如果两个都不为空，但是节点值不相同，树不同</li><li>然后再递归判断左子树和右子树，将它们的结果与<code>&amp;&amp;</code>在一起，其中一个为假，返回假</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="title function_">isSameTree</span><span class="params">(<span class="keyword">struct</span> TreeNode* p, <span class="keyword">struct</span> TreeNode* q)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(p==<span class="literal">NULL</span>&amp;&amp;q==<span class="literal">NULL</span>)<span class="comment">//比较是否两个节点都为空，都为空是真</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(p==<span class="literal">NULL</span>||q==<span class="literal">NULL</span>)<span class="comment">//如果有一个为空，另外一个非空，即为假</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(p-&gt;val!=q-&gt;val)<span class="comment">//都不是空，判断val的值是否相等</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//递归判断左子树和右子树是否相等</span></span><br><span class="line">    <span class="keyword">return</span> isSameTree(p-&gt;left,q-&gt;left)</span><br><span class="line">        &amp;&amp; isSameTree(p-&gt;right,q-&gt;right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2023/02/202204161706054.png" alt="image-20220416170618951"></p><p>学会这道题后，后面一些题目其实只需要把它的代码改一改就能用了😂</p><p>什么？你不信？那就看看下面这道题！</p><hr><h2 id="101-对称二叉树"><a href="#101-对称二叉树" class="headerlink" title="101 对称二叉树"></a>101 对称二叉树</h2><blockquote><p>leetcode：<a href="https://leetcode-cn.com/problems/symmetric-tree/">101. 对称二叉树</a></p></blockquote><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2023/02/202204161657137.png" alt="image-20220416165729067"></p><p>题目要求很简单哈，判断是不是两边对称的树。这和判断树相等有什么区别呢？不就是把左右子树的判断改一下就行了嘛？</p><ul><li>根节点的<strong>左子树的左侧</strong>和根节点的<strong>右子树的右侧</strong>相同，即为对称。</li></ul><p>直接调用上一题的代码！注意最后的return值，是<strong>p的左和q的右</strong>进行判断</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> _isSameTree(<span class="keyword">struct</span> TreeNode* p, <span class="keyword">struct</span> TreeNode* q)&#123;</span><br><span class="line">    <span class="keyword">if</span>(p==<span class="literal">NULL</span>&amp;&amp;q==<span class="literal">NULL</span>)<span class="comment">//比较是否两个节点都为空，都为空是真</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(p==<span class="literal">NULL</span>||q==<span class="literal">NULL</span>)<span class="comment">//如果有一个为空，另外一个非空，即为假</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(p-&gt;val!=q-&gt;val)<span class="comment">//都不是空，判断val的值是否相等</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 递归判断左子树和右子树是否对称相等</span></span><br><span class="line">    <span class="keyword">return</span> _isSameTree(p-&gt;left,q-&gt;right)</span><br><span class="line">        &amp;&amp; _isSameTree(p-&gt;right,q-&gt;left);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> <span class="title function_">isSymmetric</span><span class="params">(<span class="keyword">struct</span> TreeNode* root)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> _isSameTree(root-&gt;left,root-&gt;right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2023/02/202204161706197.png" alt="image-20220416170605085"></p><p>使用迭代法也能解决这道题目。迭代法的思路有点类似层序遍历，但是并不同！</p><ul><li>使用队列存放节点，将根节点的左子树和右子树入队列</li><li>开始循环</li><li>取出队列的两个节点（根节点的左子树和右子树），将左子树的左侧和右子树的右侧入队列，将左子树的右侧和右子树的左侧入队列；</li><li>此时队列中的四个数值就是依照对称需要判断的节点值来排列的，在下一层循环的时候，只需要判断取出队列的头部两个节点的值是否相等就行了。</li><li>当取出的两个节点有一个为空，或者都不为空但节点值不同时，即不符合对称的条件。</li><li>注意，两个节点都为空是符合条件的。</li></ul><p>C++代码如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isSymmetric</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">nullptr</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        queue&lt;TreeNode*&gt; que;</span><br><span class="line">        que.<span class="built_in">push</span>(root-&gt;left);</span><br><span class="line">        que.<span class="built_in">push</span>(root-&gt;right);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(!que.<span class="built_in">empty</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 这里左右的顺序要和上面根节点插入左右的顺序一致</span></span><br><span class="line">            TreeNode* left = que.<span class="built_in">front</span>();</span><br><span class="line">            que.<span class="built_in">pop</span>();</span><br><span class="line">            TreeNode* right = que.<span class="built_in">front</span>();</span><br><span class="line">            que.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="keyword">if</span>(left == <span class="literal">nullptr</span> &amp;&amp; right == <span class="literal">nullptr</span>)&#123;</span><br><span class="line">                <span class="keyword">continue</span>; <span class="comment">// 两个都是空，符合条件，跳过</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 有一个不为空，或者值不同，都是错误的</span></span><br><span class="line">            <span class="keyword">if</span>((left == <span class="literal">nullptr</span> || right == <span class="literal">nullptr</span>) || (left-&gt;val != right-&gt;val))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 对称插入队列</span></span><br><span class="line">            que.<span class="built_in">push</span>(left-&gt;left);</span><br><span class="line">            que.<span class="built_in">push</span>(right-&gt;right);</span><br><span class="line">            que.<span class="built_in">push</span>(left-&gt;right);</span><br><span class="line">            que.<span class="built_in">push</span>(right-&gt;left);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;   </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="572-另外一棵树的子树"><a href="#572-另外一棵树的子树" class="headerlink" title="572 另外一棵树的子树"></a>572 另外一棵树的子树</h2><blockquote><p>leetcode：<a href="https://leetcode-cn.com/problems/subtree-of-another-tree/">572. 另一棵树的子树</a></p></blockquote><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2023/02/202204161700348.png" alt="image-20220416170019257"></p><p>这道题我们要判断<strong>一颗树是否为另外一棵树的子树</strong>，和判断一个字符串是不是另外一个字符串的子串很相似</p><p>其实只需要递归判断每一个节点的左右子树是否和<code>subRoot</code>相同就可以了！</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> _isSameTree(<span class="keyword">struct</span> TreeNode* p, <span class="keyword">struct</span> TreeNode* q)&#123;</span><br><span class="line">    <span class="keyword">if</span>(p==<span class="literal">NULL</span>&amp;&amp;q==<span class="literal">NULL</span>)<span class="comment">//比较是否两个节点都为空，都为空是真</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(p==<span class="literal">NULL</span>||q==<span class="literal">NULL</span>)<span class="comment">//如果有一个为空，另外一个非空，即为假</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(p-&gt;val!=q-&gt;val)<span class="comment">//都不是空，判断val的值是否相等</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//递归判断左子树和右子树是否相等</span></span><br><span class="line">    <span class="keyword">return</span> _isSameTree(p-&gt;left,q-&gt;left)</span><br><span class="line">        &amp;&amp; _isSameTree(p-&gt;right,q-&gt;right);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> <span class="title function_">isSubtree</span><span class="params">(<span class="keyword">struct</span> TreeNode* root, <span class="keyword">struct</span> TreeNode* subRoot)</span>&#123;</span><br><span class="line">    <span class="comment">// if(root==NULL&amp;&amp;subRoot==NULL)</span></span><br><span class="line">    <span class="comment">//     return true;</span></span><br><span class="line">    <span class="comment">// if(root!=NULL&amp;&amp;subRoot==NULL)</span></span><br><span class="line">    <span class="comment">//     return true;</span></span><br><span class="line">    <span class="comment">// 让isSametree函数来比较这俩个</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(root==<span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(_isSameTree(root,subRoot))</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//只要左右有一个是返回真，那就是子树</span></span><br><span class="line">    <span class="keyword">return</span> isSubtree(root-&gt;left,subRoot)</span><br><span class="line">        || isSubtree(root-&gt;right,subRoot);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2023/02/202204161705445.png" alt="image-20220416170549320"></p><p>是不是爽起来了？再来一道！</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2023/02/202204161703532.png" alt="image-20220416170310498"></p><h2 id="102-层序遍历"><a href="#102-层序遍历" class="headerlink" title="102 层序遍历"></a>102 层序遍历</h2><blockquote><p><a href="https://leetcode.cn/problems/binary-tree-level-order-traversal/">https://leetcode.cn/problems/binary-tree-level-order-traversal/</a></p></blockquote><p>这道题在之前的博客中已经讲解过，为了方便后序写层序遍历的类型题目，将层序遍历最基本的代码贴在这里。</p><ul><li>根节点入队列</li><li>队列不为空，开始遍历；</li><li>记录当前队列长度（本层节点数量），出对头节点，将值插入数组，并将该节点的左右子树入队列；</li><li>一层节点遍历完毕后，将这一层的数组插入返回值二维数组中；</li><li>依照以上步骤，直到最后一层（队列为空）；</li></ul><p>代码如下。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">levelOrder</span>(TreeNode* root) &#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; retV;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">nullptr</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> retV;</span><br><span class="line">        &#125;</span><br><span class="line">        queue&lt;TreeNode*&gt; que;</span><br><span class="line">        que.<span class="built_in">push</span>(root);</span><br><span class="line">        <span class="keyword">while</span>(!que.<span class="built_in">empty</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> size = que.<span class="built_in">size</span>();</span><br><span class="line">            vector&lt;<span class="type">int</span>&gt; tempV;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; size;i++)</span><br><span class="line">            &#123;</span><br><span class="line">                TreeNode* front = que.<span class="built_in">front</span>();</span><br><span class="line">                que.<span class="built_in">pop</span>();</span><br><span class="line">                tempV.<span class="built_in">push_back</span>(front-&gt;val);</span><br><span class="line">                <span class="keyword">if</span>(front-&gt;left != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">                    que.<span class="built_in">push</span>(front-&gt;left);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(front-&gt;right != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">                    que.<span class="built_in">push</span>(front-&gt;right);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            retV.<span class="built_in">push_back</span>(tempV); <span class="comment">// 一层结束</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> retV;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="107-层序遍历Ⅱ"><a href="#107-层序遍历Ⅱ" class="headerlink" title="107 层序遍历Ⅱ"></a>107 层序遍历Ⅱ</h2><blockquote><p><a href="https://leetcode.cn/problems/binary-tree-level-order-traversal-ii/">https://leetcode.cn/problems/binary-tree-level-order-traversal-ii/</a></p></blockquote><p>这道题是上一道题的逆置，要求我们从最底层往上返回节点的数组。只需要将上题的返回数组逆置一下就OK了。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">levelOrderBottom</span>(TreeNode* root) &#123;</span><br><span class="line">         vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; retV;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">nullptr</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> retV;</span><br><span class="line">        &#125;</span><br><span class="line">        queue&lt;TreeNode*&gt; que;</span><br><span class="line">        que.<span class="built_in">push</span>(root);</span><br><span class="line">        <span class="keyword">while</span>(!que.<span class="built_in">empty</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> size = que.<span class="built_in">size</span>();</span><br><span class="line">            vector&lt;<span class="type">int</span>&gt; tempV;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; size;i++)</span><br><span class="line">            &#123;</span><br><span class="line">                TreeNode* front = que.<span class="built_in">front</span>();</span><br><span class="line">                que.<span class="built_in">pop</span>();</span><br><span class="line">                tempV.<span class="built_in">push_back</span>(front-&gt;val);</span><br><span class="line">                <span class="keyword">if</span>(front-&gt;left != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">                    que.<span class="built_in">push</span>(front-&gt;left);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(front-&gt;right != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">                    que.<span class="built_in">push</span>(front-&gt;right);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            retV.<span class="built_in">push_back</span>(tempV); <span class="comment">// 一层结束</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 逆置返回值数组即可</span></span><br><span class="line">        <span class="built_in">reverse</span>(retV.<span class="built_in">begin</span>(),retV.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">return</span> retV;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/03/a317dc68b0b4f9b98f31859e359165b2.png" alt="image.png"></p><h2 id="199-二叉树的右视图"><a href="#199-二叉树的右视图" class="headerlink" title="199 二叉树的右视图"></a>199 二叉树的右视图</h2><blockquote><p><a href="https://leetcode.cn/problems/binary-tree-right-side-view/description/">https://leetcode.cn/problems/binary-tree-right-side-view/description/</a></p></blockquote><p>题目要求我们假设自己是从右侧观察一颗二叉树，返回能从右侧观察到的节点。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">    5</span><br><span class="line">  4   6</span><br><span class="line">1   2</span><br></pre></td></tr></table></figure><p>比如这棵树，从右侧可以观察到的节点是<code>[5,6,2]</code>，题目要求返回的就是这个节点组成的数组。</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/03/b0c2e5474f671f282fac457fe734ef2c.png" alt="image.png"></p><p>思路还是层序遍历，这一次不需要把每个节点都入数组了，只需要遍历到<strong>每个层的末尾</strong>（循环到<code>size-1</code>的位置），将这个节点插入数组就行了。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">rightSideView</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; retV;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">nullptr</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> retV;</span><br><span class="line">        &#125;</span><br><span class="line">        queue&lt;TreeNode*&gt; que;</span><br><span class="line">        que.<span class="built_in">push</span>(root);</span><br><span class="line">        <span class="keyword">while</span>(!que.<span class="built_in">empty</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> size = que.<span class="built_in">size</span>();</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; size;i++)</span><br><span class="line">            &#123;</span><br><span class="line">                TreeNode* front = que.<span class="built_in">front</span>();</span><br><span class="line">                que.<span class="built_in">pop</span>();</span><br><span class="line">                <span class="comment">// 每一层的末尾才插入数组</span></span><br><span class="line">                <span class="keyword">if</span>(i == size<span class="number">-1</span>)&#123;</span><br><span class="line">                    retV.<span class="built_in">push_back</span>(front-&gt;val);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span>(front-&gt;left != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">                    que.<span class="built_in">push</span>(front-&gt;left);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(front-&gt;right != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">                    que.<span class="built_in">push</span>(front-&gt;right);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> retV;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/03/85b671427128bdd9adc04f79909a630b.png" alt="image.png"></p><h2 id="637-二叉树的层平均值"><a href="#637-二叉树的层平均值" class="headerlink" title="637 二叉树的层平均值"></a>637 二叉树的层平均值</h2><blockquote><p><a href="https://leetcode.cn/problems/average-of-levels-in-binary-tree/description/">https://leetcode.cn/problems/average-of-levels-in-binary-tree/description/</a></p></blockquote><p>给定一个非空二叉树的根节点 root , 以数组的形式返回每一层节点的平均值。与实际答案相差 <code>10^(-5)</code> 以内的答案可以被接受。</p><p>这道题简单，把每一层的节点都加起来，然后除以节点数量求平均就可以了。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">double</span>&gt; <span class="title">averageOfLevels</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="type">double</span>&gt; retV;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">nullptr</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> retV;</span><br><span class="line">        &#125;</span><br><span class="line">        queue&lt;TreeNode*&gt; que;</span><br><span class="line">        que.<span class="built_in">push</span>(root);</span><br><span class="line">        <span class="keyword">while</span>(!que.<span class="built_in">empty</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> size = que.<span class="built_in">size</span>();</span><br><span class="line">            <span class="type">double</span> sum = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; size;i++)</span><br><span class="line">            &#123;</span><br><span class="line">                TreeNode* front = que.<span class="built_in">front</span>();</span><br><span class="line">                que.<span class="built_in">pop</span>();</span><br><span class="line">                <span class="comment">// 求和</span></span><br><span class="line">                sum += front-&gt;val;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span>(front-&gt;left != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">                    que.<span class="built_in">push</span>(front-&gt;left);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(front-&gt;right != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">                    que.<span class="built_in">push</span>(front-&gt;right);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 一层结束。计算平均</span></span><br><span class="line">            retV.<span class="built_in">push_back</span>(sum/<span class="built_in">static_cast</span>&lt;<span class="type">double</span>&gt;(size*<span class="number">1.0</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> retV;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/03/67b4d7b9120a9184555c39f76908034f.png" alt="image.png"></p><h2 id="226-翻转二叉树"><a href="#226-翻转二叉树" class="headerlink" title="226 翻转二叉树"></a>226 翻转二叉树</h2><blockquote><p>leetcode：<a href="https://leetcode-cn.com/problems/invert-binary-tree/">226. 翻转二叉树</a></p></blockquote><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2023/02/202204161703706.png" alt="image-20220416170322647"></p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>这道题的思路如下哈！</p><ul><li>如果是空树，不需要翻转，直接return；</li><li>如果非空，就把该节点的左右子树交换（这里不需要担心交换后找不到子树的问题，因为并没有把子树删除或者丢掉）</li><li>不需要单独判断空的子树，一并交换就可以；</li><li>当根节点为空的时候，return；</li></ul><h3 id="前序遍历实现"><a href="#前序遍历实现" class="headerlink" title="前序遍历实现"></a>前序遍历实现</h3><p>啪的一下很快哈，代码就写出来了！</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> _invertTree(<span class="keyword">struct</span> TreeNode* root)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(root==<span class="literal">NULL</span>)<span class="comment">//设置退出条件，如果根节点为空就返回</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//让另外两个值来接收原本的左右节点</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span>* <span class="title">left</span>=</span>root-&gt;left;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span>* <span class="title">right</span>=</span>root-&gt;right;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//更改左右节点</span></span><br><span class="line">    root-&gt;right=left;</span><br><span class="line">    root-&gt;left=right;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//递归子树</span></span><br><span class="line">    _invertTree(root-&gt;left);</span><br><span class="line">    _invertTree(root-&gt;right);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> TreeNode* <span class="title function_">invertTree</span><span class="params">(<span class="keyword">struct</span> TreeNode* root)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root==<span class="literal">NULL</span>)<span class="comment">//判断空树</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    _invertTree(root);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2023/02/202204161705971.png" alt="image-20220416170530844"></p><p>使用迭代（循环）的方式进行前序遍历，也可以完成本题</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">invertTree</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">        stack&lt;TreeNode*&gt; st;</span><br><span class="line">        st.<span class="built_in">push</span>(root);</span><br><span class="line">        <span class="keyword">while</span>(!st.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            TreeNode* node = st.<span class="built_in">top</span>();              <span class="comment">// 中</span></span><br><span class="line">            st.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="built_in">swap</span>(node-&gt;left, node-&gt;right); <span class="comment">// 交换</span></span><br><span class="line">            <span class="keyword">if</span>(node-&gt;right) st.<span class="built_in">push</span>(node-&gt;right);   <span class="comment">// 右</span></span><br><span class="line">            <span class="keyword">if</span>(node-&gt;left) st.<span class="built_in">push</span>(node-&gt;left);     <span class="comment">// 左</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="层序遍历实现"><a href="#层序遍历实现" class="headerlink" title="层序遍历实现"></a>层序遍历实现</h3><p>使用层序遍历，思路还是一样的，层序遍历在出队列头部节点的时候，会将左右子树插入队列。只需要在插入之前，将队列头部节点的左右子树指针交换位置，即可。</p><p>注意：不能通过交换左右子树入队列的顺序实现，这样虽然遍历下一层的顺序改变了，但是上一层的节点左右子树的指针并没有被交换，还是原来的顺序，不符合题目要求。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">invertTree</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">nullptr</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        &#125;</span><br><span class="line">        queue&lt;TreeNode*&gt; que;</span><br><span class="line">        que.<span class="built_in">push</span>(root);</span><br><span class="line">        <span class="keyword">while</span>(!que.<span class="built_in">empty</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            TreeNode* front = que.<span class="built_in">front</span>();</span><br><span class="line">            que.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="built_in">swap</span>(front-&gt;left,front-&gt;right);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 虽然这里可以不用写不等于空，但是写上可读性更好。</span></span><br><span class="line">            <span class="keyword">if</span>(front-&gt;left != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">                que.<span class="built_in">push</span>(front-&gt;left);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(front-&gt;right != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">                que.<span class="built_in">push</span>(front-&gt;right);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="429-N叉树层序遍历"><a href="#429-N叉树层序遍历" class="headerlink" title="429 N叉树层序遍历"></a>429 N叉树层序遍历</h2><blockquote><p><a href="https://leetcode.cn/problems/n-ary-tree-level-order-traversal/">https://leetcode.cn/problems/n-ary-tree-level-order-traversal/</a></p></blockquote><p>基于二叉树层序遍历的代码，修改一下就是多叉树了。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">// Definition for a Node.</span></span><br><span class="line"><span class="comment">class Node &#123;</span></span><br><span class="line"><span class="comment">public:</span></span><br><span class="line"><span class="comment">    int val;</span></span><br><span class="line"><span class="comment">    vector&lt;Node*&gt; children;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    Node() &#123;&#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    Node(int _val) &#123;</span></span><br><span class="line"><span class="comment">        val = _val;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    Node(int _val, vector&lt;Node*&gt; _children) &#123;</span></span><br><span class="line"><span class="comment">        val = _val;</span></span><br><span class="line"><span class="comment">        children = _children;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">levelOrder</span>(Node* root) &#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; retV;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">nullptr</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> retV;</span><br><span class="line">        &#125;</span><br><span class="line">        queue&lt;Node*&gt; que;</span><br><span class="line">        que.<span class="built_in">push</span>(root);</span><br><span class="line">        <span class="keyword">while</span>(!que.<span class="built_in">empty</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> size = que.<span class="built_in">size</span>();</span><br><span class="line">            vector&lt;<span class="type">int</span>&gt; tempV;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; size ; j++)&#123;</span><br><span class="line">                Node* temp = que.<span class="built_in">front</span>();</span><br><span class="line">                que.<span class="built_in">pop</span>();</span><br><span class="line">                tempV.<span class="built_in">push_back</span>(temp-&gt;val);</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> i =<span class="number">0</span>;i&lt;temp-&gt;children.<span class="built_in">size</span>();i++)</span><br><span class="line">                &#123;</span><br><span class="line">                    que.<span class="built_in">push</span>(temp-&gt;children[i]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            retV.<span class="built_in">push_back</span>(tempV);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> retV;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/03/d5a314057186dc0fc8880444838d2381.png" alt="image.png"></p><h2 id="515-在每层中找最大值"><a href="#515-在每层中找最大值" class="headerlink" title="515 在每层中找最大值"></a>515 在每层中找最大值</h2><blockquote><p><a href="https://leetcode.cn/problems/find-largest-value-in-each-tree-row/">https://leetcode.cn/problems/find-largest-value-in-each-tree-row/</a></p></blockquote><p>还是层序遍历思路的题目，遍历一层的时候维护一个最大值就可以了。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">largestValues</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; retV;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">nullptr</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> retV;</span><br><span class="line">        &#125;</span><br><span class="line">        queue&lt;TreeNode*&gt; que;</span><br><span class="line">        que.<span class="built_in">push</span>(root);</span><br><span class="line">        <span class="keyword">while</span>(!que.<span class="built_in">empty</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> size = que.<span class="built_in">size</span>();</span><br><span class="line">            <span class="type">int</span> maxNum = INT32_MIN;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i =<span class="number">0</span>;i&lt; size;i++)</span><br><span class="line">            &#123;</span><br><span class="line">                TreeNode* temp = que.<span class="built_in">front</span>();</span><br><span class="line">                que.<span class="built_in">pop</span>();</span><br><span class="line">                maxNum = <span class="built_in">max</span>(maxNum,temp-&gt;val);</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">if</span>(temp-&gt;left != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">                    que.<span class="built_in">push</span>(temp-&gt;left);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(temp-&gt;right != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">                    que.<span class="built_in">push</span>(temp-&gt;right);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            retV.<span class="built_in">push_back</span>(maxNum);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> retV;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/03/42ebd64adefee9120536bd6968a50561.png" alt="image.png"></p><h2 id="116-填充每个节点的下一个右侧节点指针"><a href="#116-填充每个节点的下一个右侧节点指针" class="headerlink" title="116 填充每个节点的下一个右侧节点指针"></a>116 填充每个节点的下一个右侧节点指针</h2><blockquote><p><a href="https://leetcode.cn/problems/populating-next-right-pointers-in-each-node/description/">https://leetcode.cn/problems/populating-next-right-pointers-in-each-node/description/</a></p></blockquote><p>给定一个 完美二叉树 ，其所有叶子节点都在同一层，每个父节点都有两个子节点。二叉树定义如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">  <span class="type">int</span> val;</span><br><span class="line">  Node *left;</span><br><span class="line">  Node *right;</span><br><span class="line">  Node *next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>填充它的每个 next 指针，让这个指针指向其下一个右侧节点。如果找不到下一个右侧节点，则将 next 指针设置为 NULL。</p><p>初始状态下，所有 next 指针都被设置为 NULL。</p><hr><p>还是层序遍历的思路，遍历每一层的时候，将<strong>前一个节点的right</strong>设置为当前节点。</p><p>因为题目提到了node节点的next指针<strong>初始化都为nullptr</strong>，所以不需要我们手动操作每层最后一个节点的nullptr。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">Node* <span class="title">connect</span><span class="params">(Node* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">nullptr</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        &#125;</span><br><span class="line">        queue&lt;Node*&gt; que;</span><br><span class="line">        que.<span class="built_in">push</span>(root);</span><br><span class="line">        <span class="keyword">while</span>(!que.<span class="built_in">empty</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> size = que.<span class="built_in">size</span>();</span><br><span class="line">            Node* prevNode = <span class="literal">nullptr</span>;</span><br><span class="line">            Node* node = <span class="literal">nullptr</span>; <span class="comment">// 始终指向当前节点</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i =<span class="number">0</span>; i&lt; size;i++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// 每层第一个节点，设置前一个节点的值</span></span><br><span class="line">                <span class="keyword">if</span>(i == <span class="number">0</span>)&#123;</span><br><span class="line">                    prevNode = que.<span class="built_in">front</span>(); <span class="comment">// 前一个节点</span></span><br><span class="line">                    que.<span class="built_in">pop</span>();</span><br><span class="line">                    node = prevNode; <span class="comment">// 当前节点</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="comment">// 非第一个</span></span><br><span class="line">                &#123;</span><br><span class="line">                    node = que.<span class="built_in">front</span>(); <span class="comment">// 当前节点</span></span><br><span class="line">                    que.<span class="built_in">pop</span>();</span><br><span class="line">                    prevNode-&gt;next = node;</span><br><span class="line">                    prevNode = prevNode-&gt;next; <span class="comment">// 更新前一个节点为当前节点</span></span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 插入后续节点</span></span><br><span class="line">                <span class="keyword">if</span>(node-&gt;left != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">                    que.<span class="built_in">push</span>(node-&gt;left);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(node-&gt;right != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">                    que.<span class="built_in">push</span>(node-&gt;right);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/03/9316e276ec127d1e7ee096367a4c6e51.png" alt="image.png"></p><h2 id="117-填充每个节点的下一个右侧节点指针Ⅱ"><a href="#117-填充每个节点的下一个右侧节点指针Ⅱ" class="headerlink" title="117 填充每个节点的下一个右侧节点指针Ⅱ"></a>117 填充每个节点的下一个右侧节点指针Ⅱ</h2><blockquote><p><a href="https://leetcode.cn/problems/populating-next-right-pointers-in-each-node-ii/description/">https://leetcode.cn/problems/populating-next-right-pointers-in-each-node-ii/description/</a></p></blockquote><p>上题说的是完全二叉树，这道题是普通二叉树。不过我们写的层序遍历代码本来就是通用的，所以直接复制代码过来就行了，什么都不需要改。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">Node* <span class="title">connect</span><span class="params">(Node* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">nullptr</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        &#125;</span><br><span class="line">        queue&lt;Node*&gt; que;</span><br><span class="line">        que.<span class="built_in">push</span>(root);</span><br><span class="line">        <span class="keyword">while</span>(!que.<span class="built_in">empty</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> size = que.<span class="built_in">size</span>();</span><br><span class="line">            Node* prevNode = <span class="literal">nullptr</span>;</span><br><span class="line">            Node* node = <span class="literal">nullptr</span>; <span class="comment">// 始终指向当前节点</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i =<span class="number">0</span>; i&lt; size;i++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// 每层第一个节点，设置前一个节点的值</span></span><br><span class="line">                <span class="keyword">if</span>(i == <span class="number">0</span>)&#123;</span><br><span class="line">                    prevNode = que.<span class="built_in">front</span>(); <span class="comment">// 前一个节点</span></span><br><span class="line">                    que.<span class="built_in">pop</span>();</span><br><span class="line">                    node = prevNode; <span class="comment">// 当前节点</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="comment">// 非第一个</span></span><br><span class="line">                &#123;</span><br><span class="line">                    node = que.<span class="built_in">front</span>(); <span class="comment">// 当前节点</span></span><br><span class="line">                    que.<span class="built_in">pop</span>();</span><br><span class="line">                    prevNode-&gt;next = node;</span><br><span class="line">                    prevNode = prevNode-&gt;next; <span class="comment">// 更新前一个节点为当前节点</span></span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 插入后续节点</span></span><br><span class="line">                <span class="keyword">if</span>(node-&gt;left != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">                    que.<span class="built_in">push</span>(node-&gt;left);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(node-&gt;right != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">                    que.<span class="built_in">push</span>(node-&gt;right);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/03/0ea9cb0afb401d955754c2f85a50c9f1.png" alt="image.png"></p><h2 id="104-二叉树最大深度"><a href="#104-二叉树最大深度" class="headerlink" title="104 二叉树最大深度"></a>104 二叉树最大深度</h2><blockquote><p><a href="https://leetcode.cn/problems/maximum-depth-of-binary-tree/description/">https://leetcode.cn/problems/maximum-depth-of-binary-tree/description/</a></p></blockquote><p>这道题在链式二叉树的博客中讲解过递归版本。注意二叉树深度的定义：二叉树的 <strong>最大深度</strong> 是指从根节点到最远<strong>叶子节点</strong>的<strong>最长路径</strong>上的节点数。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 二叉树深度，即一共有几层</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">BTreeDepth</span><span class="params">(BTNode* root)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (root == <span class="literal">NULL</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 递归遍历左右子树</span></span><br><span class="line"><span class="type">int</span> left = <span class="built_in">BTreeDepth</span>(root-&gt;left);</span><br><span class="line"><span class="type">int</span> right = <span class="built_in">BTreeDepth</span>(root-&gt;right);</span><br><span class="line"><span class="comment">// 返回左右子树层数高的那一个，加一代表当前层，因为空指针是0</span></span><br><span class="line"><span class="keyword">return</span> left &gt; right ? left + <span class="number">1</span> : right + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用层序遍历也能解决这个问题，遍历到每一层都让深度计数器加一就行了。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxDepth</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> retDepth = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">nullptr</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> retDepth;</span><br><span class="line">        &#125;</span><br><span class="line">        queue&lt;TreeNode*&gt; que;</span><br><span class="line">        que.<span class="built_in">push</span>(root);</span><br><span class="line">        <span class="keyword">while</span>(!que.<span class="built_in">empty</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> size = que.<span class="built_in">size</span>();</span><br><span class="line">            retDepth++; <span class="comment">// 层数加一</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i =<span class="number">0</span>;i&lt; size;i++)</span><br><span class="line">            &#123;</span><br><span class="line">                TreeNode* temp = que.<span class="built_in">front</span>();</span><br><span class="line">                que.<span class="built_in">pop</span>();</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">if</span>(temp-&gt;left != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">                    que.<span class="built_in">push</span>(temp-&gt;left);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(temp-&gt;right != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">                    que.<span class="built_in">push</span>(temp-&gt;right);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> retDepth;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/03/9db4df1d7c69a02f1e809f2fac733fb8.png" alt="image.png"></p><p>下面是代码随想录上的递归思路。使用“回溯”的思想，将每一层的depth送给下一层，然后在每一层开始的时候判断当前深度是否大于存放的深度，并进行更新。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> result;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">getdepth</span><span class="params">(TreeNode* node, <span class="type">int</span> depth)</span> </span>&#123;</span><br><span class="line">        result = depth &gt; result ? depth : result; <span class="comment">// 中</span></span><br><span class="line">        <span class="keyword">if</span> (node-&gt;left == <span class="literal">NULL</span> &amp;&amp; node-&gt;right == <span class="literal">NULL</span>) <span class="keyword">return</span> ;</span><br><span class="line">        <span class="keyword">if</span> (node-&gt;left) &#123; <span class="comment">// 左</span></span><br><span class="line">            <span class="built_in">getdepth</span>(node-&gt;left, depth + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (node-&gt;right) &#123; <span class="comment">// 右</span></span><br><span class="line">            <span class="built_in">getdepth</span>(node-&gt;right, depth + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxDepth</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        result = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="number">0</span>) <span class="keyword">return</span> result;</span><br><span class="line">        <span class="built_in">getdepth</span>(root, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="114-二叉树的最小深度"><a href="#114-二叉树的最小深度" class="headerlink" title="114 二叉树的最小深度"></a>114 二叉树的最小深度</h2><blockquote><p> <a href="https://leetcode.cn/problems/minimum-depth-of-binary-tree/description/">https://leetcode.cn/problems/minimum-depth-of-binary-tree/description/</a></p></blockquote><p>二叉树的最小深度：最小深度是从根节点到最近叶子节点的最短路径上的节点数量。</p><p>以下面的二叉树为例，它的最小深度是从1到节点3，因为3才是第一个叶子节点，而1并不是叶子节点（没有左右子树的节点才是叶子节点）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1</span><br><span class="line">   2</span><br><span class="line">  3  4</span><br><span class="line">   5</span><br></pre></td></tr></table></figure><p>代码如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">minDepth</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> retDepth = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">nullptr</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> retDepth;</span><br><span class="line">        &#125;</span><br><span class="line">        queue&lt;TreeNode*&gt; que;</span><br><span class="line">        que.<span class="built_in">push</span>(root);</span><br><span class="line">        <span class="keyword">while</span>(!que.<span class="built_in">empty</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> size = que.<span class="built_in">size</span>();</span><br><span class="line">            retDepth++; <span class="comment">// 层数加一</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i =<span class="number">0</span>;i&lt; size;i++)</span><br><span class="line">            &#123;</span><br><span class="line">                TreeNode* temp = que.<span class="built_in">front</span>();</span><br><span class="line">                que.<span class="built_in">pop</span>();</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">if</span>(temp-&gt;left != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">                    que.<span class="built_in">push</span>(temp-&gt;left);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(temp-&gt;right != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">                    que.<span class="built_in">push</span>(temp-&gt;right);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 遇到叶子节点，说明就是最小深度，直接返回</span></span><br><span class="line">                <span class="keyword">if</span>(temp-&gt;left == <span class="literal">nullptr</span> &amp;&amp; temp-&gt;right == <span class="literal">nullptr</span>)&#123;</span><br><span class="line">                    <span class="keyword">return</span> retDepth;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> retDepth;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/03/fdeee76497ce1ee5fce7622e2d5c839b.png" alt="image.png"></p><p>如果使用递归的方式，代码如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getDepth</span><span class="params">(TreeNode* node)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> leftDepth = <span class="built_in">getDepth</span>(node-&gt;left);           <span class="comment">// 左</span></span><br><span class="line">        <span class="type">int</span> rightDepth = <span class="built_in">getDepth</span>(node-&gt;right);         <span class="comment">// 右</span></span><br><span class="line">                                                        <span class="comment">// 中</span></span><br><span class="line">        <span class="comment">// 当一个左子树为空，右不为空，这时并不是最低点</span></span><br><span class="line">        <span class="keyword">if</span> (node-&gt;left == <span class="literal">NULL</span> &amp;&amp; node-&gt;right != <span class="literal">NULL</span>) &#123; </span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span> + rightDepth;</span><br><span class="line">        &#125;   </span><br><span class="line">        <span class="comment">// 当一个右子树为空，左不为空，这时并不是最低点</span></span><br><span class="line">        <span class="keyword">if</span> (node-&gt;left != <span class="literal">NULL</span> &amp;&amp; node-&gt;right == <span class="literal">NULL</span>) &#123; </span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span> + leftDepth;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 此时是叶子节点，返回当前的最小高度（即深度）</span></span><br><span class="line">        <span class="type">int</span> result = <span class="number">1</span> + <span class="built_in">min</span>(leftDepth, rightDepth);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">minDepth</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">getDepth</span>(root);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="222-完全二叉树的节点数量"><a href="#222-完全二叉树的节点数量" class="headerlink" title="222 完全二叉树的节点数量"></a>222 完全二叉树的节点数量</h2><blockquote><p><a href="https://leetcode.cn/problems/count-complete-tree-nodes/description/">https://leetcode.cn/problems/count-complete-tree-nodes/description/</a></p></blockquote><p>给你一棵 <strong>完全二叉树</strong> 的根节点 <code>root</code> ，求出该树的节点个数。</p><p><a href="https://baike.baidu.com/item/%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%A0%91/7773232?fr=aladdin">完全二叉树</a> 的定义如下：在完全二叉树中，除了最底层节点可能没填满外，其余每层节点数都达到最大值，并且最下面一层的节点都集中在该层最左边的若干位置。若最底层为第 <code>h</code> 层，则该层包含 <code>1 ~ (2^h)</code> 个节点。</p><hr><p>先按普通二叉树来计算节点的数量，使用层序遍历的思路</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">countNodes</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">nullptr</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        queue&lt;TreeNode*&gt; que;</span><br><span class="line">        que.<span class="built_in">push</span>(root);</span><br><span class="line">        <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(!que.<span class="built_in">empty</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> size = que.<span class="built_in">size</span>();</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i =<span class="number">0</span>;i&lt;size;i++)</span><br><span class="line">            &#123;</span><br><span class="line">                TreeNode* front = que.<span class="built_in">front</span>();</span><br><span class="line">                que.<span class="built_in">pop</span>();</span><br><span class="line">                count++; </span><br><span class="line">                <span class="keyword">if</span>(front-&gt;left != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">                    que.<span class="built_in">push</span>(front-&gt;left);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(front-&gt;right != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">                    que.<span class="built_in">push</span>(front-&gt;right);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>使用递归遍历也能计算节点数量</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> _countNodes(TreeNode* root)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">nullptr</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> left = _countNodes(root-&gt;left);</span><br><span class="line">        <span class="type">int</span> right = _countNodes(root-&gt;right);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span> + left + right;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">countNodes</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> _countNodes(root);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/03/23e323a933739d577ae14b06b12ebb8a.png" alt="image-20240316092433289"></p><hr><p>但是上面这两个思路都是对任何二叉树都适用的，但本题直接说明了是<strong>完全二叉树</strong>。如果用通用的思路来解题，在面试的时候可能会扣分。我们需要用上完全二叉树的特性。</p><p>首先要知道<strong>满二叉树</strong>的节点数量为<code>2^k - 1</code>，k是二叉树的层数。在完全二叉树中，会有多个满二叉树。所以可以将思路转变为，正常计算非满二叉树的节点数量，但如果是满二叉树，获取层数后直接用公式计算节点数量，再二者相加。</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/03/9949b47e3423bf14897b688add450847.png" alt="image-20240316093135112"></p><p>计算满二叉树的层数比较简单，只需要从根节点往左侧、往右侧遍历，计算两侧的节点数量。最后对比左侧右侧节点数量，不同则不是满二叉树。</p><blockquote><p>因为题目已经说明了这棵树是<strong>完全二叉树</strong>，所以<strong>不会出现</strong>下面这种两侧节点数量一致，但中间缺少节点不符合完全二叉树&#x2F;满二叉树条件的情况。</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/03/449114798f3824b2d21fe98eae39ea67.png" alt="image-20240316093752286"></p></blockquote><p>C++代码如下，来自代码随想录。这里层数被初始化为0，这样在后续使用<code>(2 &lt;&lt; leftDepth)</code>的时候，其实就相当于计算2的<code>leftDepth+1</code>次方。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">countNodes</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 开始根据左深度和右深度是否相同来判断该子树是不是满二叉树</span></span><br><span class="line">        TreeNode* left = root-&gt;left;</span><br><span class="line">        TreeNode* right = root-&gt;right;</span><br><span class="line">        <span class="type">int</span> leftDepth = <span class="number">0</span>, rightDepth = <span class="number">0</span>; <span class="comment">// 这里初始为0是有目的的，为了下面求指数方便</span></span><br><span class="line">        <span class="keyword">while</span> (left) &#123;  <span class="comment">// 求左子树深度</span></span><br><span class="line">            left = left-&gt;left;</span><br><span class="line">            leftDepth++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (right) &#123; <span class="comment">// 求右子树深度</span></span><br><span class="line">            right = right-&gt;right;</span><br><span class="line">            rightDepth++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (leftDepth == rightDepth) &#123;</span><br><span class="line">            <span class="keyword">return</span> (<span class="number">2</span> &lt;&lt; leftDepth) - <span class="number">1</span>; <span class="comment">// 注意(2&lt;&lt;1) 相当于2^2，返回满足满二叉树的子树节点数量</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 后序遍历</span></span><br><span class="line">        <span class="type">int</span> leftTreeNum = <span class="built_in">countNodes</span>(root-&gt;left);       <span class="comment">// 左</span></span><br><span class="line">        <span class="type">int</span> rightTreeNum = <span class="built_in">countNodes</span>(root-&gt;right);     <span class="comment">// 右</span></span><br><span class="line">        <span class="type">int</span> result = leftTreeNum + rightTreeNum + <span class="number">1</span>;    <span class="comment">// 中</span></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="110-平衡二叉树"><a href="#110-平衡二叉树" class="headerlink" title="110 平衡二叉树"></a>110 平衡二叉树</h2><blockquote><p><a href="https://leetcode.cn/problems/balanced-binary-tree/">https://leetcode.cn/problems/balanced-binary-tree/</a></p></blockquote><p>这里涉及到高阶数据结构中平衡二叉树的概念，如果你没有了解过，可以移步<a href="https://blog.musnow.top/posts/1396203902">这篇博客</a>；</p><p>简而言之，<strong>平衡二叉树是节点的左右子树高度相差不超过1的树</strong>。这样能保证树的左右两侧节点层数基本一致，方便实现搜索二叉树。</p><p>对于本题而言，我们可以将思路改为计算每个节点左右两侧的树的高度。当高度相差超过1的时候，直接返回错误。这里可以用int来作为递归函数的返回值，用<code>-1</code>代表不符合平衡二叉树的条件。</p><p>题目给出树的节点数量 <code>[0, 5000]</code> ，最大的层数也就5000，用int是足够存放的。</p><p>C++代码如下，使用后序遍历的思想来递归处理。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> _isBalanced(TreeNode* root)&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">nullptr</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 使用后续遍历，如果有一个不符合预期就提前返回</span></span><br><span class="line">        <span class="type">int</span> left = _isBalanced(root-&gt;left);</span><br><span class="line">        <span class="keyword">if</span>(left == <span class="number">-1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> right = _isBalanced(root-&gt;right);</span><br><span class="line">        <span class="keyword">if</span>(right == <span class="number">-1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 都不是负一，计算节点高度插值</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">abs</span>(right -left)&gt;<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;<span class="comment">// 超过1了不符合</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span> + <span class="built_in">max</span>(right,left); <span class="comment">// 返回高的那一个作为当前树的高度</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isBalanced</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> _isBalanced(root) == <span class="number">-1</span> ? <span class="literal">false</span> : <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/03/f2d8a5287cd80e7f2aa5099de585d651.png" alt="image-20240316095740190"></p><h2 id="257-二叉树的所有路径"><a href="#257-二叉树的所有路径" class="headerlink" title="257 二叉树的所有路径"></a>257 二叉树的所有路径</h2><blockquote><p><a href="https://leetcode.cn/problems/binary-tree-paths/">https://leetcode.cn/problems/binary-tree-paths/</a></p></blockquote><p>思路是使用前序遍历，将当前节点的值转为字符串插入到数组中，并插入一个<code>-&gt;</code>字符串；递归的末尾条件分两个</p><ul><li>叶子节点，将当前节点的值插入，不需要额外插入<code>-&gt;</code>字符串；</li><li>空节点，直接返回</li></ul><p>递归函数的传参如下，其中string变量不能传引用，因为这样的话，下一层的修改就会影响上层，上层还需要做删除下一层的元素的操作，很麻烦。<code>vector&lt;string&gt;&amp; retV</code>变量需要传引用，因为它包含了所有路径字符串，作为返回值。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">binaryTreePaths</span><span class="params">(TreeNode* root,string curStr,vector&lt;string&gt;&amp; retV)</span></span></span><br></pre></td></tr></table></figure><hr><p>下面的代码中有一个错误的思路，如果遇到空节点就将字符串插入到数组，对于有一个子树的非叶子节点（此时它的左侧或者右侧是空的），就会多插入一个无效的路径，因为此时这个节点并非叶子节点。</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/03/25aa7223e84bc8baeb4dc74da7e3b5ca.png" alt="image-20240316101831139"></p><p>正确的处理办法是到叶子节点了再插入数组，遇到空节点直接返回，不需要做任何处理。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 字符串不能传引用，不然下层的更改会影响上层</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">binaryTreePaths</span><span class="params">(TreeNode* root,string curStr,vector&lt;string&gt;&amp; retV)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// // 到空节点了就插入到数组中</span></span><br><span class="line">        <span class="comment">// if(root == nullptr)&#123;</span></span><br><span class="line">        <span class="comment">//     // 删除多余的-&gt;</span></span><br><span class="line">        <span class="comment">//     retV.push_back(curStr.substr(0,curStr.size()-2));</span></span><br><span class="line">        <span class="comment">//     return;</span></span><br><span class="line">        <span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 上面的思路错误，如果某个节点有左子树或右子树，此时就会多插入一个无效的路径</span></span><br><span class="line">        <span class="comment">// 正确思路是空节点不处理</span></span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">nullptr</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 到叶子节点了就直接插入到数组中</span></span><br><span class="line">        <span class="keyword">if</span>(root-&gt;left == <span class="literal">nullptr</span> &amp;&amp; root-&gt;right == <span class="literal">nullptr</span>)&#123;</span><br><span class="line">            curStr +=  <span class="built_in">to_string</span>(root-&gt;val);</span><br><span class="line">            retV.<span class="built_in">push_back</span>(curStr); <span class="comment">// 不需要删除多余的-&gt;</span></span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 前序遍历</span></span><br><span class="line">        curStr += <span class="built_in">to_string</span>(root-&gt;val);</span><br><span class="line">        curStr += <span class="string">&quot;-&gt;&quot;</span>;</span><br><span class="line">        <span class="built_in">binaryTreePaths</span>(root-&gt;left,curStr,retV);</span><br><span class="line">        <span class="built_in">binaryTreePaths</span>(root-&gt;right,curStr,retV);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function">vector&lt;string&gt; <span class="title">binaryTreePaths</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        vector&lt;string&gt; retV;</span><br><span class="line">        <span class="built_in">binaryTreePaths</span>(root,<span class="string">&quot;&quot;</span>,retV);</span><br><span class="line">        <span class="keyword">return</span> retV;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/03/f1c77d652f76b84075ebb60c656bc98c.png" alt="image-20240316102109684"></p><p>也可以使用迭代法，就是利用<strong>前序遍历的迭代思路</strong>将代码从递归改成迭代。</p><p>这里需要用到第二个栈，一个栈用来存放遍历的节点，另外一个栈用来存放当前遍历到的节点的上一层的字符串。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;string&gt; <span class="title">binaryTreePaths</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        vector&lt;string&gt; retV;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">nullptr</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> retV;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        stack&lt;TreeNode*&gt; stNode; <span class="comment">// 存放节点</span></span><br><span class="line">        stack&lt;string&gt; stStr; <span class="comment">// 存放上一层的字符串</span></span><br><span class="line">        stNode.<span class="built_in">push</span>(root);</span><br><span class="line">        <span class="comment">// stStr.push(to_string(root-&gt;val));</span></span><br><span class="line">        stStr.<span class="built_in">push</span>(<span class="string">&quot;&quot;</span>); <span class="comment">// 这里一定要插入空字符串而不是根节点的值</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(!stNode.<span class="built_in">empty</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 前序遍历</span></span><br><span class="line">            TreeNode* curNode = stNode.<span class="built_in">top</span>(); <span class="comment">// 中</span></span><br><span class="line">            <span class="comment">// cout &lt;&lt; curNode-&gt;val &lt;&lt; endl;</span></span><br><span class="line">            stNode.<span class="built_in">pop</span>();</span><br><span class="line">            string curStr = stStr.<span class="built_in">top</span>();</span><br><span class="line">            stStr.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="comment">// 遇到叶子节点，插入值然后返回</span></span><br><span class="line">            <span class="keyword">if</span>(curNode-&gt;left == <span class="literal">nullptr</span> &amp;&amp; curNode-&gt;right == <span class="literal">nullptr</span>)&#123;</span><br><span class="line">                <span class="comment">// curStr += &quot;-&gt;&quot;;</span></span><br><span class="line">                curStr += <span class="built_in">to_string</span>(curNode-&gt;val);</span><br><span class="line">                retV.<span class="built_in">push_back</span>(curStr);</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 左</span></span><br><span class="line">            <span class="keyword">if</span>(curNode-&gt;left != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">                stNode.<span class="built_in">push</span>(curNode-&gt;left);</span><br><span class="line">                stStr.<span class="built_in">push</span>(curStr  + <span class="built_in">to_string</span>(curNode-&gt;val)+ <span class="string">&quot;-&gt;&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 右</span></span><br><span class="line">            <span class="keyword">if</span>(curNode-&gt;right != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">                stNode.<span class="built_in">push</span>(curNode-&gt;right);</span><br><span class="line">                stStr.<span class="built_in">push</span>(curStr  + <span class="built_in">to_string</span>(curNode-&gt;val)+ <span class="string">&quot;-&gt;&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> retV;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/03/00bec4e34eef1c6765743903454e323b.png" alt="image-20240316104632107"></p><h2 id="404-左叶子之和"><a href="#404-左叶子之和" class="headerlink" title="404 左叶子之和"></a>404 左叶子之和</h2><blockquote><p><a href="https://leetcode.cn/problems/sum-of-left-leaves/description/">https://leetcode.cn/problems/sum-of-left-leaves/description/</a></p></blockquote><p>给定二叉树的根节点 <code>root</code> ，返回所有左叶子之和。</p><p>这道题我本来的思路是使用层序遍历，除去根节点外，<strong>每一层的第一个就是左叶子的可能节点</strong>。注意是可能，还需要判断这个节点到底是不是叶子节点。如果是就将其加入sum中。</p><p>但是这个思路是<strong>错的</strong>，因为每一层不一定有左侧叶子节点，第一个节点可能是右子树，不符合题目条件。</p><p>正确的办法是用递归，顺序算是中序遍历，当遇到叶子节点和空节点的时候，返回0，当遇到当前节点的左侧节点是叶子节点的时候，返回这个节点的值。</p><p>因为左侧节点不能通过当前节点来判断出来，必须要用父亲节点才能判断，所以“中序”就是在通过父亲节点判断左侧节点是不是叶子节点。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> _sumOfLeftLeaves(TreeNode* root)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 根节点为空，跳过</span></span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">nullptr</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 叶子节点，跳过（因为左侧叶子节点不存在，值视作为0）</span></span><br><span class="line">        <span class="keyword">if</span>(root-&gt;left == <span class="literal">nullptr</span> &amp;&amp; root-&gt;right == <span class="literal">nullptr</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 遍历左侧</span></span><br><span class="line">        <span class="type">int</span> left = _sumOfLeftLeaves(root-&gt;left);</span><br><span class="line">        <span class="comment">// 判断左侧是否为叶子节点，如果是需要进行修正（上一行的递归会跳过叶子节点的情况）</span></span><br><span class="line">        <span class="keyword">if</span>(root-&gt;left &amp;&amp; root-&gt;left-&gt;left == <span class="literal">nullptr</span> &amp;&amp; root-&gt;left-&gt;right==<span class="literal">nullptr</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            left = root-&gt;left-&gt;val; <span class="comment">// 左侧叶子节点的值</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 遍历右侧</span></span><br><span class="line">        <span class="type">int</span> right = _sumOfLeftLeaves(root-&gt;right);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> right + left;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">sumOfLeftLeaves</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> _sumOfLeftLeaves(root);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/03/4b6bc8846a4683698401c3b0057e5c91.png" alt="image-20240316111425986"></p><p>你也可以把代码按下面的方式写，会更好理解一些。当判断出当前左子树是叶子节点，就直接赋值，不是叶子节点才去遍历。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> _sumOfLeftLeaves(TreeNode* root)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 根节点为空，跳过</span></span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">nullptr</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 叶子节点，跳过（因为左侧叶子节点不存在，值视作为0）</span></span><br><span class="line">        <span class="keyword">if</span>(root-&gt;left == <span class="literal">nullptr</span> &amp;&amp; root-&gt;right == <span class="literal">nullptr</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 判断左侧是否为叶子节点</span></span><br><span class="line">        <span class="keyword">if</span>(root-&gt;left &amp;&amp; root-&gt;left-&gt;left == <span class="literal">nullptr</span> &amp;&amp; root-&gt;left-&gt;right==<span class="literal">nullptr</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            left = root-&gt;left-&gt;val; <span class="comment">// 左侧叶子节点的值</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            left = _sumOfLeftLeaves(root-&gt;left);<span class="comment">// 遍历左侧</span></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 遍历右侧</span></span><br><span class="line">        <span class="type">int</span> right = _sumOfLeftLeaves(root-&gt;right);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> right + left;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">sumOfLeftLeaves</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> _sumOfLeftLeaves(root);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/03/4ae5fbd2fe03e19ee457f91c4716c20d.png" alt="image-20240316111635285"></p><p>使用迭代也是借用遍历的思路，都是在父节点判断左子树是否为叶子节点。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">sumOfLeftLeaves</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        stack&lt;TreeNode*&gt; st;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        st.<span class="built_in">push</span>(root);</span><br><span class="line">        <span class="type">int</span> result = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (!st.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            TreeNode* node = st.<span class="built_in">top</span>();</span><br><span class="line">            st.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="keyword">if</span> (node-&gt;left != <span class="literal">NULL</span> &amp;&amp; node-&gt;left-&gt;left == <span class="literal">NULL</span> &amp;&amp; node-&gt;left-&gt;right == <span class="literal">NULL</span>) &#123;</span><br><span class="line">                result += node-&gt;left-&gt;val;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (node-&gt;right) st.<span class="built_in">push</span>(node-&gt;right);</span><br><span class="line">            <span class="keyword">if</span> (node-&gt;left) st.<span class="built_in">push</span>(node-&gt;left);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="513-找树左下角的值"><a href="#513-找树左下角的值" class="headerlink" title="513 找树左下角的值"></a>513 找树左下角的值</h2><blockquote><p><a href="https://leetcode.cn/problems/find-bottom-left-tree-value/">https://leetcode.cn/problems/find-bottom-left-tree-value/</a></p></blockquote><p>给定一个二叉树的 <strong>根节点</strong> <code>root</code>，请找出该二叉树的 <strong>最底层 最左边</strong> 节点的值。</p><p>假设二叉树中至少有一个节点。</p><hr><p>这道题用上题层序遍历的思路才是对的，利用层序遍历走到最底层，将这一层最左侧的节点返回。但是这里会涉及到一个问题，<strong>我们怎么知道自己走到最后一层了呢</strong>？</p><p>实际上，并不需要去特殊判断，只需要将层序遍历每一层的第一个节点的值设置为返回值，这样层序遍历结束后，最后被设置的值就是题目需要求的节点。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">findBottomLeftValue</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">nullptr</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        queue&lt;TreeNode*&gt; que;</span><br><span class="line">        que.<span class="built_in">push</span>(root);</span><br><span class="line">        <span class="type">int</span> ret = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(!que.<span class="built_in">empty</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> size = que.<span class="built_in">size</span>();</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i =<span class="number">0</span>;i&lt;size;i++)</span><br><span class="line">            &#123;</span><br><span class="line">                TreeNode* front = que.<span class="built_in">front</span>();</span><br><span class="line">                que.<span class="built_in">pop</span>();</span><br><span class="line">                <span class="keyword">if</span>(i == <span class="number">0</span>)&#123;</span><br><span class="line">                    ret = front-&gt;val;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(front-&gt;left != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">                    que.<span class="built_in">push</span>(front-&gt;left);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(front-&gt;right != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">                    que.<span class="built_in">push</span>(front-&gt;right);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;   </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/03/6f7b9f6babc8fcbb50d64eb37a926fd0.png" alt="image-20240317161855120"></p><p>递归法使用前序遍历的思想，使用一个变量来记录当前深度，另外一个变量记录最深处左侧节点的值。这里的代码和上文<code>104二叉树的最大深度</code>题目中的思路相似。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> maxDepth = <span class="number">-1</span>; <span class="comment">// 最大深度</span></span><br><span class="line">    <span class="type">int</span> result = <span class="number">0</span>; <span class="comment">// 左侧节点值</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">getMaxDepthLeftNode</span><span class="params">(TreeNode* root,<span class="type">int</span> depth)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// 叶子节点</span></span><br><span class="line">        <span class="keyword">if</span>(root-&gt;right == <span class="literal">nullptr</span> &amp;&amp; root-&gt;left == <span class="literal">nullptr</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(depth &gt; maxDepth)&#123;</span><br><span class="line">                maxDepth = <span class="built_in">max</span>(maxDepth,depth);</span><br><span class="line">                result = root-&gt;val; <span class="comment">// 存放叶子节点的值</span></span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果左侧不为空，往左侧递归</span></span><br><span class="line">        <span class="keyword">if</span>(root-&gt;left != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">            <span class="built_in">getMaxDepthLeftNode</span>(root-&gt;left,depth+<span class="number">1</span>); <span class="comment">// 这里深度加一就相当于加上当前节点</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 往右侧递归</span></span><br><span class="line">        <span class="keyword">if</span>(root-&gt;right != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">            <span class="built_in">getMaxDepthLeftNode</span>(root-&gt;right,depth+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">findBottomLeftValue</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">nullptr</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">getMaxDepthLeftNode</span>(root,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/03/f23bdbc09fdab06e7b0f7542aebeb9a5.png" alt="image-20240317162934828"></p><h2 id="112-路径总和"><a href="#112-路径总和" class="headerlink" title="112 路径总和"></a>112 路径总和</h2><blockquote><p><a href="https://leetcode.cn/problems/path-sum/description/">https://leetcode.cn/problems/path-sum/description/</a></p></blockquote><p>给你二叉树的根节点 <code>root</code> 和一个表示目标和的整数 <code>targetSum</code> 。判断该树中是否存在 <strong>根节点到叶子节点</strong> 的路径，这条路径上所有节点值相加等于目标和 <code>targetSum</code> 。如果存在，返回 <code>true</code> ；否则，返回 <code>false</code> 。</p><p><strong>叶子节点</strong> 是指没有子节点的节点。</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/03/9924f255828e9bf5d223554c29c23c31.png" alt="image-20240317163532398"></p><p>这道题和<code>257 二叉树的所有路径</code>有些类似，不过那道题是需要将路径写入数组，这道题是需要判断有没有路径中节点值的和为指定数的情况。</p><p>递归函数中，传入目标值，当前值（这里的当前值也是用了“回溯”的思想），为了避免错误修改目标值，将其设置为const变量。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">frontTravelTree</span><span class="params">(TreeNode* root,<span class="type">const</span> <span class="type">int</span> targetSum, <span class="type">int</span> curSum)</span></span></span><br></pre></td></tr></table></figure><p>递归的思路如下</p><ul><li>如果当前节点为空，直接返回false，不需要处理</li><li>如果当前节点非空，将当前节点的值加入curSum；</li><li>如果当前节点是叶子节点，判断当前的curSum是否等于targetSum，等于返回true；</li><li>往左侧和右侧递归，返回这两个递归结果的<strong>或</strong>；</li></ul><p>注意，判断targetSum的时候一定要判断是不是叶子节点，我刚开始写的时候就忘记判断了，因为路径可能还没到叶子节点就已经等于targetSum了，但是这种情况不符合题目条件。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">frontTravelTree</span><span class="params">(TreeNode* root,<span class="type">const</span> <span class="type">int</span> targetSum, <span class="type">int</span> curSum)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">nullptr</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        curSum += root-&gt;val;</span><br><span class="line">        <span class="comment">// 当前已经相等，且是叶子节点，返回</span></span><br><span class="line">        <span class="keyword">if</span>(targetSum == curSum &amp;&amp; root-&gt;left == <span class="literal">nullptr</span> &amp;&amp; root-&gt;right == <span class="literal">nullptr</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="type">bool</span> retLeft = <span class="built_in">frontTravelTree</span>(root-&gt;left,targetSum,curSum);</span><br><span class="line">        <span class="type">bool</span> retRight = <span class="built_in">frontTravelTree</span>(root-&gt;right,targetSum,curSum);</span><br><span class="line">        <span class="keyword">return</span> retLeft || retRight;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">hasPathSum</span><span class="params">(TreeNode* root, <span class="type">int</span> targetSum)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">frontTravelTree</span>(root,targetSum,<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/03/15e968da70f14f4a995298e2cef928e4.png" alt="image-20240317163820934"></p><p>使用迭代，也是用前序遍历的思路，用栈来实现。这里的思路和<code>257 二叉树的所有路径</code>中也是一样的，需要用到两个栈，一个用来遍历节点，另外一个保存上一层遍历到的节点curSum。</p><p>注意，因为是前序遍历，且每一次都会让curSum加上当前节点的值，所以stSum这个栈在初始化的时候一定要插入0，而不是根节点的值（不然会二次加根节点的值，会出错）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">hasPathSum</span><span class="params">(TreeNode* root, <span class="type">int</span> targetSum)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">nullptr</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        stack&lt;TreeNode*&gt; stNode; <span class="comment">// 遍历节点</span></span><br><span class="line">        stack&lt;<span class="type">int</span>&gt; stSum; <span class="comment">// 上一层遍历的求和结果</span></span><br><span class="line">        </span><br><span class="line">        stNode.<span class="built_in">push</span>(root);</span><br><span class="line">        stSum.<span class="built_in">push</span>(<span class="number">0</span>); <span class="comment">// 这里一定要插入0而不是根节点的值</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(!stNode.<span class="built_in">empty</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            TreeNode* curNode = stNode.<span class="built_in">top</span>();</span><br><span class="line">            stNode.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="type">int</span> curSum = stSum.<span class="built_in">top</span>();</span><br><span class="line">            stSum.<span class="built_in">pop</span>();</span><br><span class="line">            </span><br><span class="line">            curSum += curNode-&gt;val;</span><br><span class="line">            <span class="comment">// 如果是叶子节点，判断是否相等</span></span><br><span class="line">            <span class="keyword">if</span>(curNode-&gt;left == <span class="literal">nullptr</span> &amp;&amp; curNode-&gt;right == <span class="literal">nullptr</span> &amp;&amp; curSum == targetSum)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 继续向下</span></span><br><span class="line">            <span class="keyword">if</span>(curNode-&gt;left != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">                stNode.<span class="built_in">push</span>(curNode-&gt;left);</span><br><span class="line">                stSum.<span class="built_in">push</span>(curSum);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(curNode-&gt;right != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">                stNode.<span class="built_in">push</span>(curNode-&gt;right);</span><br><span class="line">                stSum.<span class="built_in">push</span>(curSum);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/03/c2f0411797bfce72243ae97448cbd33b.png" alt="image-20240317165115333"></p><h2 id="113-路径总和Ⅱ"><a href="#113-路径总和Ⅱ" class="headerlink" title="113 路径总和Ⅱ"></a>113 路径总和Ⅱ</h2><blockquote><p><a href="https://leetcode.cn/problems/path-sum-ii/">113. 路径总和 II</a></p></blockquote><p>上一题是让我们判断是否存在某一条路径，这题是需要返回所有符合条件的路径。</p><p>思路是使用前序遍历，用一个curSum记录当前遍历到的和，将当前值加入到这个和中并将当前值插入curV数组；</p><p>如果<strong>是叶子节点</strong>，则与targetSum对比，符合条件则将curV数组插入到返回值数组retV中。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="type">void</span> _pathSum(TreeNode* root, <span class="type">const</span> <span class="type">int</span> targetSum,<span class="type">int</span> curSum, vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; retV,vector&lt;<span class="type">int</span>&gt; curV) &#123;</span><br><span class="line">        <span class="comment">// 空节点跳过</span></span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">nullptr</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 前序遍历</span></span><br><span class="line">        curSum += root-&gt;val;</span><br><span class="line">        curV.<span class="built_in">push_back</span>(root-&gt;val);</span><br><span class="line">        <span class="comment">// 叶子节点，且值相等，插入</span></span><br><span class="line">        <span class="keyword">if</span>(root-&gt;left == <span class="literal">nullptr</span> &amp;&amp; root-&gt;right == <span class="literal">nullptr</span> &amp;&amp; curSum == targetSum)&#123;</span><br><span class="line">            retV.<span class="built_in">push_back</span>(curV);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 左右递归</span></span><br><span class="line">        _pathSum(root-&gt;left,targetSum,curSum,retV,curV);</span><br><span class="line">        _pathSum(root-&gt;right,targetSum,curSum,retV,curV);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">pathSum</span>(TreeNode* root, <span class="type">int</span> targetSum) &#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; retV;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">nullptr</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> retV;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        _pathSum(root,targetSum,<span class="number">0</span>,retV,<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;());</span><br><span class="line">        <span class="keyword">return</span> retV;</span><br><span class="line">    &#125;   </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/03/d1bbdfc5f2846feb568ce10501ef2400.png" alt="image-20240318103424964"></p><h2 id="106-从中序与后序遍历序列构造二叉树"><a href="#106-从中序与后序遍历序列构造二叉树" class="headerlink" title="106 从中序与后序遍历序列构造二叉树"></a>106 从中序与后序遍历序列构造二叉树</h2><blockquote><p><a href="https://leetcode.cn/problems/construct-binary-tree-from-inorder-and-postorder-traversal/">106 从中序与后序遍历序列构造二叉树</a></p></blockquote><p>给定两个整数数组 <code>inorder</code> 和 <code>postorder</code> ，其中 <code>inorder</code> 是二叉树的中序遍历， <code>postorder</code> 是同一棵树的后序遍历，请你构造并返回这颗 <em>二叉树</em> 。</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/03/cd173d709ec7bad3687083e5340a185e.png" alt="image-20240317171026511"></p><p>首先，要通过中序和后序遍历的概念知道如何从这两个数组中构造一棵树来。</p><ul><li>后序的最后一个节点是根节点</li><li>确定根节点后，中序遍历中根节点左侧的是左子树，右侧的是右子树；</li><li>继续依照这个概念拆分后序遍历的数组，找到左右子树的根节点…</li></ul><p>对于代码而言，重点就是将左右子树从中序和后序的数组中拆分开来，直到拆分到空节点。</p><ol><li>数组大小为空，说明是空节点</li><li>数组大小不为空，从后序遍历中取出最后一个值作为根节点的值；</li><li>从中序遍历的数组中找到根节点所在位置，作为拆分的中位线；</li><li>将中序遍历的数组依照根节点所在位置拆分成左子数组和右子数组；</li><li>切割后序遍历的数组，依照左侧数组和右侧数组的长度和中序遍历拆分后的长度一致来处理（如果中序拆出来的左子树数组有3个元素，那么后序遍历中左子树的数组就是从前往后数的前3个元素）；</li><li>递归处理左侧和右侧的子树；</li></ol><p>代码如下，主要需要注意的是拆分中序和后序数组时候迭代器的位置，这里的下标拆分范围如果搞不清楚可以打印出来多试试，记住思路是最重要的。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    TreeNode* _buildTree(vector&lt;<span class="type">int</span>&gt;&amp; inorder, vector&lt;<span class="type">int</span>&gt;&amp; postorder) &#123;</span><br><span class="line">        <span class="comment">// 递归分治条件</span></span><br><span class="line">        <span class="keyword">if</span>(inorder.<span class="built_in">size</span>() == <span class="number">0</span> || postorder.<span class="built_in">size</span>() == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 后序遍历的最后一个节点是根节点</span></span><br><span class="line">        <span class="type">int</span> val = postorder[postorder.<span class="built_in">size</span>()<span class="number">-1</span>];</span><br><span class="line">        TreeNode* root = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(val);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 在中序遍历数组中找到这个值，注意题目保证节点值不重复，所以能这么做。</span></span><br><span class="line">        <span class="type">int</span> i = <span class="number">0</span>; <span class="comment">// 提前定义，后面要用</span></span><br><span class="line">        <span class="keyword">for</span>(i = <span class="number">0</span>;i&lt;inorder.<span class="built_in">size</span>();i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(inorder[i] == val)&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 拆中序数组，使用[0,i)区间</span></span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">inorderLeft</span><span class="params">(inorder.begin(),inorder.begin()+i)</span></span>;</span><br><span class="line">        <span class="comment">// 下面这里是[i+1,end)区间，必须额外加一，否则不符合条件</span></span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">inorderRight</span><span class="params">(inorder.begin()+i+<span class="number">1</span>,inorder.end())</span></span>; </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 拆后续数组，因为后续数组的大小肯定和中序一致，从前往后拆就分别对应中序的左数组和右数组了</span></span><br><span class="line">        <span class="comment">// 将后续遍历数组中的的最后一个值删掉，因为当前已经使用了</span></span><br><span class="line">        postorder.<span class="built_in">resize</span>(postorder.<span class="built_in">size</span>()<span class="number">-1</span>); </span><br><span class="line">        <span class="comment">// 这里inorderLeft.size()理论上和i是相同的，所以用i也没问题</span></span><br><span class="line">        <span class="comment">// [0,inorderLeft.size())</span></span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">postorderLeft</span><span class="params">(postorder.begin(),postorder.begin()+inorderLeft.size())</span></span>;</span><br><span class="line">        <span class="comment">// [inorderLeft.size(),end())</span></span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">postorderRight</span><span class="params">(postorder.begin()+inorderLeft.size(),postorder.end())</span></span>;</span><br><span class="line"></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 递归遍历</span></span><br><span class="line">        TreeNode* left = _buildTree(inorderLeft,postorderLeft);</span><br><span class="line">        TreeNode* right = _buildTree(inorderRight,postorderRight);</span><br><span class="line">        <span class="comment">// 链接</span></span><br><span class="line">        root-&gt;left = left;</span><br><span class="line">        root-&gt;right = right;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">buildTree</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; inorder, vector&lt;<span class="type">int</span>&gt;&amp; postorder)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(inorder.<span class="built_in">size</span>() == <span class="number">0</span> || postorder.<span class="built_in">size</span>() == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> _buildTree(inorder,postorder);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/03/77678c2d171a81344112bf3d3f177ef2.png" alt="image-20240317173609279"></p><p>当然，上面的代码性能并不好，因为会有额外的空间复杂度消耗（每次递归都需要构建4个vector数组），我们可以将构建数组的操作改成用下标来标定区间。</p><p>代码如下，同样需要注意下标的区间，详见注释。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    TreeNode* _buildTree(<span class="type">const</span> vector&lt;<span class="type">int</span>&gt;&amp; inorder,<span class="type">int</span> inorderBegin,<span class="type">int</span> inorderEnd,<span class="type">const</span> vector&lt;<span class="type">int</span>&gt;&amp; postorder,<span class="type">int</span> postorderBegin,<span class="type">int</span> postorderEnd) &#123;        </span><br><span class="line">        <span class="keyword">if</span>(inorderBegin&gt;=inorderEnd || postorderBegin &gt;= postorderEnd)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 后序遍历的最后一个节点是根节点</span></span><br><span class="line">        <span class="comment">// int val = postorder[postorder.size()-1];</span></span><br><span class="line">        <span class="type">int</span> val = postorder[postorderEnd<span class="number">-1</span>];</span><br><span class="line">        TreeNode* root = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(val);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 在中序遍历数组中找到这个值，注意题目保证节点值不重复，所以能这么做。</span></span><br><span class="line">        <span class="type">int</span> i = <span class="number">0</span>; <span class="comment">// 提前定义，后面要用</span></span><br><span class="line">        <span class="comment">// for(i = 0;i&lt;inorder.size();i++)</span></span><br><span class="line">        <span class="keyword">for</span>(i = inorderBegin;i&lt;inorderEnd;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(inorder[i] == val)&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 拆中序数组，使用[0,i)区间</span></span><br><span class="line">        <span class="type">int</span> inorderBeginLeft = inorderBegin;</span><br><span class="line">        <span class="type">int</span> inorderEndLeft = inorderBegin+(i-inorderBegin); <span class="comment">// 如果直接加i是错误的，i已经是下标了，再加会超出范围</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 下面这里是[i+1,end)区间，必须额外加一，否则不符合条件</span></span><br><span class="line">        <span class="type">int</span> inorderBeginRight = inorderBegin+(i-inorderBegin)+<span class="number">1</span>; <span class="comment">// 这里需要加一，是跳过被选中的中间节点</span></span><br><span class="line">        <span class="type">int</span> inorderEndRight = inorderEnd;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 拆后续数组，因为后续数组的大小肯定和中序一致，从前往后拆就分别对应中序的左数组和右数组了</span></span><br><span class="line">        <span class="comment">// [0,inorderLeft.size())</span></span><br><span class="line">        <span class="type">int</span> postorderBeginLeft = postorderBegin;</span><br><span class="line">        <span class="type">int</span> postorderEndLeft = postorderBegin + (i - inorderBegin);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// [inorderLeft.size(),end())</span></span><br><span class="line">        <span class="type">int</span> postorderBeginRight = postorderBegin + (i - inorderBegin); <span class="comment">// 这里不需要加一，因为中间没有多出来一个数</span></span><br><span class="line">        <span class="type">int</span> postorderEndRight = postorderEnd <span class="number">-1</span>; <span class="comment">// 排除最后一个节点</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 递归遍历</span></span><br><span class="line">        TreeNode* left = _buildTree(inorder,inorderBeginLeft,inorderEndLeft,postorder,postorderBeginLeft,postorderEndLeft);</span><br><span class="line">        TreeNode* right = _buildTree(inorder,inorderBeginRight,inorderEndRight,postorder,postorderBeginRight,postorderEndRight);</span><br><span class="line">        <span class="comment">// 链接</span></span><br><span class="line">        root-&gt;left = left;</span><br><span class="line">        root-&gt;right = right;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">buildTree</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; inorder, vector&lt;<span class="type">int</span>&gt;&amp; postorder)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(inorder.<span class="built_in">size</span>() == <span class="number">0</span> || postorder.<span class="built_in">size</span>() == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> _buildTree(inorder,<span class="number">0</span>,inorder.<span class="built_in">size</span>(),postorder,<span class="number">0</span>,postorder.<span class="built_in">size</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/03/c20668f2784839f073d00b700bc039d1.png" alt="image-20240317182254991"></p><h2 id="105-从前序和中序遍历构造二叉树"><a href="#105-从前序和中序遍历构造二叉树" class="headerlink" title="105 从前序和中序遍历构造二叉树"></a>105 从前序和中序遍历构造二叉树</h2><blockquote><p><a href="https://leetcode.cn/problems/construct-binary-tree-from-preorder-and-inorder-traversal/">105. 从前序与中序遍历序列构造二叉树</a></p></blockquote><p>给定两个整数数组 <code>preorder</code> 和 <code>inorder</code> ，其中 <code>preorder</code> 是二叉树的<strong>先序遍历</strong>， <code>inorder</code> 是同一棵树的<strong>中序遍历</strong>，请构造二叉树并返回其根节点。</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/03/3b2acc3f4d092a12194f29d9c922f159.png" alt="image-20240317182505486"></p><p>这道题和上一道题的思路基本一致，这里就不用构造vector的思路了，直接用下标的方式来处理。</p><ul><li>前序遍历的第一个值是根节点</li><li>在中序遍历的数组中找到根节点的位置，根据该位置左右拆分数组</li><li>在前序遍历数组中，从第二位开始，根据中序遍历拆出来的两个数组的长度，拆分前序遍历的数组。</li><li>递归处理</li></ul><p>在后序遍历的数组中，需要排除的是最后一位。在前序遍历的数组中，需要排除的是第一位。在拆分数组下标的地方体现出来。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    TreeNode* _buildTree(<span class="type">const</span> vector&lt;<span class="type">int</span>&gt;&amp; preorder,<span class="type">int</span> preorderBegin,<span class="type">int</span> preorderEnd,<span class="type">const</span>  vector&lt;<span class="type">int</span>&gt;&amp; inorder, <span class="type">int</span> inorderBegin,<span class="type">int</span> inorderEnd)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 递归返回条件</span></span><br><span class="line">        <span class="keyword">if</span>(inorderBegin &gt;= inorderEnd || preorderBegin &gt;= preorderEnd)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 前序遍历的第一个</span></span><br><span class="line">        <span class="type">int</span> val = preorder[preorderBegin];</span><br><span class="line">        TreeNode* root = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(val);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 在中序遍历数组中找</span></span><br><span class="line">        <span class="type">int</span> i =<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(i = inorderBegin;i&lt;inorderEnd;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(inorder[i] == val)&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 拆分中序遍历数组</span></span><br><span class="line">        <span class="type">int</span> offset = i-inorderBegin;</span><br><span class="line">        <span class="comment">// 左侧数组[inorderBegin,inorderBegin+offset)</span></span><br><span class="line">        <span class="type">int</span> inorderBeginLeft = inorderBegin;</span><br><span class="line">        <span class="type">int</span> inorderEndLeft = inorderBegin + offset;  <span class="comment">// 这里不能直接加i，应该加i和开头的偏移量</span></span><br><span class="line">        <span class="comment">// 右侧数组[inorderBegin+offset+1,inorderEnd)</span></span><br><span class="line">        <span class="type">int</span> inorderBeginRight = inorderBegin + offset+<span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> inorderEndRight = inorderEnd;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 拆分前序遍历数组</span></span><br><span class="line">        <span class="comment">// 左侧数组[preorderBegin+1,preorderBegin+1+offset)，开头需要加一跳过第一个值</span></span><br><span class="line">        <span class="type">int</span> preorderBeginLeft = preorderBegin+<span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> preorderEndLeft = preorderBegin+<span class="number">1</span>+offset;</span><br><span class="line">        <span class="comment">// 右侧数组[preorderBegin+1+offset,preorderEnd)</span></span><br><span class="line">        <span class="type">int</span> preorderBeginRight = preorderBegin+<span class="number">1</span>+offset;</span><br><span class="line">        <span class="type">int</span> preorderEndRight = preorderEnd;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 递归遍历</span></span><br><span class="line">        TreeNode* left = _buildTree(preorder,preorderBeginLeft,preorderEndLeft,inorder,inorderBeginLeft,inorderEndLeft);</span><br><span class="line">        TreeNode* right = _buildTree(preorder,preorderBeginRight,preorderEndRight,inorder,inorderBeginRight,inorderEndRight);</span><br><span class="line">        <span class="comment">// 链接</span></span><br><span class="line">        root-&gt;left = left;</span><br><span class="line">        root-&gt;right = right;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">buildTree</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; preorder, vector&lt;<span class="type">int</span>&gt;&amp; inorder)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(preorder.<span class="built_in">size</span>() == <span class="number">0</span> || inorder.<span class="built_in">size</span>() == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> _buildTree(preorder,<span class="number">0</span>,preorder.<span class="built_in">size</span>(),inorder,<span class="number">0</span>,inorder.<span class="built_in">size</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/03/61d66d0b4bbef588ec323178e26c13fa.png" alt="image-20240317184256405"></p><h2 id="654-最大二叉树"><a href="#654-最大二叉树" class="headerlink" title="654 最大二叉树"></a>654 最大二叉树</h2><blockquote><p><a href="https://leetcode.cn/problems/maximum-binary-tree/">654. 最大二叉树</a></p></blockquote><p>给定一个不重复的整数数组 <code>nums</code> 。 <strong>最大二叉树</strong> 可以用下面的算法从 <code>nums</code> 递归地构建:</p><ol><li>创建一个根节点，其值为 <code>nums</code> 中的最大值。</li><li>递归地在最大值 <strong>左边</strong> 的 <strong>子数组前缀上</strong> 构建左子树。</li><li>递归地在最大值 <strong>右边</strong> 的 <strong>子数组后缀上</strong> 构建右子树。</li></ol><p>返回 <code>nums</code> 构建的<strong>最大二叉树</strong> 。</p><hr><p>这道题和前面105&#x2F;106这两道题的思路几乎完全一致，用前序遍历递归的思想，先找到最大值作为根节点，然后拆分左右区间（类似与105&#x2F;106题目中拆分中序遍历数组的左右区间）。拆分区间后进行遍历构建左右子树就行了。</p><p>这里要注意递归的退出条件，因为begin&#x2F;end选用的是左闭右开的选择，所以<code>begin==end</code>的情况也是无效的，所以<code>begin&gt;=end</code>作为递归的退出条件。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="comment">// 查找最大值，返回最大值的下标</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">searchMaxIndex</span><span class="params">(<span class="type">const</span> vector&lt;<span class="type">int</span>&gt;&amp; nums,<span class="type">int</span> begin,<span class="type">int</span> end)</span></span>&#123;</span><br><span class="line">        <span class="type">int</span> maxNum = nums[begin];</span><br><span class="line">        <span class="type">int</span> maxNumIndex = begin;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = begin;i&lt;end;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i] &gt; maxNum)&#123;</span><br><span class="line">                maxNum = nums[i];</span><br><span class="line">                maxNumIndex = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxNumIndex;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    TreeNode* _constructMaximumBinaryTree(<span class="type">const</span> vector&lt;<span class="type">int</span>&gt;&amp; nums,<span class="type">int</span> begin,<span class="type">int</span> end)&#123;</span><br><span class="line">        <span class="comment">// 本题采用左闭右开，所以begin==end是无效区间</span></span><br><span class="line">        <span class="keyword">if</span>(nums.<span class="built_in">size</span>() == <span class="number">0</span> || begin&gt;=end)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 找到最大值的下标</span></span><br><span class="line">        <span class="type">int</span> maxNumIndex = <span class="built_in">searchMaxIndex</span>(nums,begin,end);</span><br><span class="line">        TreeNode* root = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(nums[maxNumIndex]);</span><br><span class="line">        <span class="comment">// 左右拆分</span></span><br><span class="line">        <span class="type">int</span> leftBegin = begin;</span><br><span class="line">        <span class="type">int</span> leftEnd = maxNumIndex; </span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> rightBegin = maxNumIndex+<span class="number">1</span>; <span class="comment">// 加一跳过当前选中节点</span></span><br><span class="line">        <span class="type">int</span> rightEnd = end;</span><br><span class="line"></span><br><span class="line">        root-&gt;left = _constructMaximumBinaryTree(nums,leftBegin,leftEnd);</span><br><span class="line">        root-&gt;right = _constructMaximumBinaryTree(nums,rightBegin,rightEnd);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">constructMaximumBinaryTree</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums.<span class="built_in">size</span>() == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> _constructMaximumBinaryTree(nums,<span class="number">0</span>,nums.<span class="built_in">size</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/03/da6a3c1927b4d27c72da012d018f3cbc.png" alt="image-20240317193842851"></p><h2 id="617-合并二叉树"><a href="#617-合并二叉树" class="headerlink" title="617 合并二叉树"></a>617 合并二叉树</h2><blockquote><p><a href="https://leetcode.cn/problems/merge-two-binary-trees/">617. 合并二叉树</a></p></blockquote><p>想象一下，当你将其中一棵覆盖到另一棵之上时，两棵树上的一些节点将会重叠（而另一些不会）。你需要将这两棵树合并成一棵新二叉树。合并的规则是：如果两个节点重叠，那么将这两个节点的值相加作为合并后节点的新值；否则，<strong>不为</strong> null 的节点将直接作为新二叉树的节点。</p><p>返回合并后的二叉树。</p><p><strong>注意:</strong> 合并过程必须从两个树的根节点开始。</p><hr><p>这道题其实就是遍历二叉树多了第二棵树而已，不需要想的太复杂</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    TreeNode* _mergeTrees(TreeNode* root1, TreeNode* root2) &#123;</span><br><span class="line">        <span class="comment">// 如果一棵树为空了，就直接返回另外一棵树来拼接</span></span><br><span class="line">        <span class="keyword">if</span>(root1 == <span class="literal">nullptr</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> root2;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(root2 == <span class="literal">nullptr</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> root1;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 借用root1加上值</span></span><br><span class="line">        root1-&gt;val += root2-&gt;val;</span><br><span class="line">        <span class="comment">// 这里因为root1和root2的遍历顺序都是一样的，所以肯定能匹配上</span></span><br><span class="line">        root1-&gt;left = _mergeTrees(root1-&gt;left,root2-&gt;left);</span><br><span class="line">        root1-&gt;right = _mergeTrees(root1-&gt;right,root2-&gt;right);</span><br><span class="line">        <span class="keyword">return</span> root1;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">mergeTrees</span><span class="params">(TreeNode* root1, TreeNode* root2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> _mergeTrees(root1,root2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/03/6d041cf7b2d1792eeb72179653d0d30d.png" alt="image-20240317205658359"></p><p>使用迭代法的层序遍历思想也能解决这道题，需要将两棵树的根都插入队列中。在开始遍历之前，需要确定我们是用root1还是root2来构造最终的二叉树。</p><ul><li>取出节点，值相加</li><li>如果两个节点的左侧都不为空，入队列（注意顺序要一致）</li><li>如果两个节点的右侧都不为空，入队列</li><li>如果r1的左侧节点为空，r2不为空，将r1的左侧链接为r2</li><li>如果r1的右侧节点为空，r2不为空，将r1的右侧链接为r2</li></ul><p>代码如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">mergeTrees</span><span class="params">(TreeNode* root1, TreeNode* root2)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 如果一棵树为空了，就直接返回另外一棵树来拼接</span></span><br><span class="line">        <span class="keyword">if</span>(root1 == <span class="literal">nullptr</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> root2;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(root2 == <span class="literal">nullptr</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> root1;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 到这里root1和2都不为空</span></span><br><span class="line">        queue&lt;TreeNode*&gt; que;</span><br><span class="line">        que.<span class="built_in">push</span>(root1);</span><br><span class="line">        que.<span class="built_in">push</span>(root2);</span><br><span class="line">        <span class="comment">// 确定用root1来链接树</span></span><br><span class="line">        <span class="keyword">while</span>(!que.<span class="built_in">empty</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 这里不需要多层序遍历的循环，因为root1和root2每一层节点个数不相同</span></span><br><span class="line">            </span><br><span class="line">            TreeNode* r1 = que.<span class="built_in">front</span>();</span><br><span class="line">            que.<span class="built_in">pop</span>();</span><br><span class="line">            TreeNode* r2 = que.<span class="built_in">front</span>();</span><br><span class="line">            que.<span class="built_in">pop</span>();</span><br><span class="line">            r1-&gt;val += r2-&gt;val;</span><br><span class="line">            <span class="comment">// 如果两个节点的左右子树都不空，则都插入数组</span></span><br><span class="line">            <span class="keyword">if</span>(r1-&gt;left != <span class="literal">nullptr</span> &amp;&amp; r2-&gt;left != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">                que.<span class="built_in">push</span>(r1-&gt;left);</span><br><span class="line">                que.<span class="built_in">push</span>(r2-&gt;left);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(r1-&gt;right != <span class="literal">nullptr</span> &amp;&amp; r2-&gt;right != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">                que.<span class="built_in">push</span>(r1-&gt;right);</span><br><span class="line">                que.<span class="built_in">push</span>(r2-&gt;right);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 如果r1的左侧为空，r2不为空，赋值</span></span><br><span class="line">            <span class="keyword">if</span>(r1-&gt;left == <span class="literal">nullptr</span> &amp;&amp; r2-&gt;left != <span class="literal">nullptr</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                r1-&gt;left = r2-&gt;left;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(r1-&gt;right == <span class="literal">nullptr</span> &amp;&amp; r2-&gt;right != <span class="literal">nullptr</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                r1-&gt;right = r2-&gt;right;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/03/5cd92f8447a1213e28984aa6693eeecf.png" alt="image-20240317210547382"></p><h2 id="700-二叉搜索树中的搜索"><a href="#700-二叉搜索树中的搜索" class="headerlink" title="700 二叉搜索树中的搜索"></a>700 二叉搜索树中的搜索</h2><blockquote><p><a href="https://leetcode.cn/problems/search-in-a-binary-search-tree/">700. 二叉搜索树中的搜索</a></p></blockquote><p>给定二叉搜索树（BST）的根节点 <code>root</code> 和一个整数值 <code>val</code>。</p><p>你需要在 BST 中找到节点值等于 <code>val</code> 的节点。 返回以该节点为根的子树。 如果节点不存在，则返回 <code>null</code> 。</p><p> 代码如下，其实就是最最基本的搜索二叉树的查找方式。搜索二叉树的左子树的值小于当前节点的值，右子树的值大于当前节点的值。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    TreeNode* _searchBST(TreeNode* root,<span class="type">const</span> <span class="type">int</span> val) &#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">nullptr</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(root-&gt;val == val)&#123;</span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(root-&gt;val &gt; val)&#123;</span><br><span class="line">            <span class="keyword">return</span> _searchBST(root-&gt;left,val); <span class="comment">// 左侧更小</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> _searchBST(root-&gt;right,val); <span class="comment">// 右侧更小</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">searchBST</span><span class="params">(TreeNode* root, <span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">nullptr</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> _searchBST(root,val);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/03/27109369c080398669b2833e19d5f102.png" alt="image-20240317211001013"></p><p>用循环也能实现，因为这里不涉及到前中后序遍历什么的，只是单纯找一个值，所以用不上队列或者栈</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">searchBST</span><span class="params">(TreeNode* root, <span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 用循环也可以</span></span><br><span class="line">        <span class="keyword">while</span>(root != <span class="literal">nullptr</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(root-&gt;val == val)&#123;</span><br><span class="line">                <span class="keyword">return</span> root;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span>(root-&gt;val &gt; val)</span><br><span class="line">            &#123;</span><br><span class="line">                root = root-&gt;left;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                root = root-&gt;right;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="98-验证二层搜索树"><a href="#98-验证二层搜索树" class="headerlink" title="98 验证二层搜索树"></a>98 验证二层搜索树</h2><blockquote><p><a href="https://leetcode.cn/problems/validate-binary-search-tree/">98. 验证二叉搜索树</a></p></blockquote><p>给你一个二叉树的根节点 <code>root</code> ，判断其是否是一个有效的二叉搜索树。</p><p><strong>有效</strong> 二叉搜索树定义如下：</p><ul><li>节点的左子树只包含 <strong>小于</strong> 当前节点的数。</li><li>节点的右子树只包含 <strong>大于</strong> 当前节点的数。</li><li>所有左子树和右子树自身必须也是二叉搜索树。</li></ul><p>注意：二叉搜索树中不能有重复节点，因为无法判断两个相同节点的区别。</p><hr><p>这道题可以采用中序遍历的方式，构建一个二叉树的数组，并遍历判断这个数组是否有序（搜索二叉树的中序遍历肯定是有序的），代码如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="type">void</span> _inorderTravel(TreeNode* root,vector&lt;<span class="type">int</span>&gt;&amp; v)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">nullptr</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        _inorderTravel(root-&gt;left,v);</span><br><span class="line">        v.<span class="built_in">push_back</span>(root-&gt;val);</span><br><span class="line">        _inorderTravel(root-&gt;right,v);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isValidBST</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 本题保证root非空</span></span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; v;</span><br><span class="line">        _inorderTravel(root,v);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i =<span class="number">0</span>;i&lt;v.<span class="built_in">size</span>()<span class="number">-1</span>;i++)&#123;</span><br><span class="line">            <span class="comment">// 不能有重复节点，这里是大于等于</span></span><br><span class="line">            <span class="keyword">if</span>(v[i] &gt;= v[i+<span class="number">1</span>])&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/03/e947106623f118df8d3af395f66560e9.png" alt="image-20240318104631391"></p><p>当然，不用额外的数组也能写出这道题。思路是用中序遍历，维护一个当前最大值（初始化为<code>LONG_MIN</code>），在中序部分判断当前节点是否小于这个最大值，如果小于等于，则说明当前节点之前有比当前节点更大或等于当前值的节点，这是不符合条件的，返回假。</p><p>其他情况返回真。</p><p>因为本题目保证了root是非空的，所以第一个root的判断返回false&#x2F;true可以根据算法自行选择。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">long</span> maxNum = LONG_MIN;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isValidBST</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">nullptr</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">bool</span> retLeft = <span class="built_in">isValidBST</span>(root-&gt;left);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(root-&gt;val &lt;= maxNum)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            maxNum = root-&gt;val;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="type">bool</span> retRight = <span class="built_in">isValidBST</span>(root-&gt;right);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> retLeft &amp;&amp; retRight;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/03/7def55fee335595ab04630b5e4be6416.png" alt="image-20240318105739796"></p><p>这个算法还是会有一个问题，即二层搜索树中可能会存在本来就等于<code>LONG_MIN</code>的节点，此时会直接返回false，不符合预期。所以应该把maxNum初始化为二叉树中左下角的那个节点的值，来保证无论如何都可以遍历成功，避免我们选用的初始值对算法结果的影响。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    TreeNode* prev = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isValidBST</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">nullptr</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">bool</span> retLeft = <span class="built_in">isValidBST</span>(root-&gt;left);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(prev != <span class="literal">nullptr</span> &amp;&amp; root-&gt;val &lt;= prev-&gt;val)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            prev = root;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="type">bool</span> retRight = <span class="built_in">isValidBST</span>(root-&gt;right);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> retLeft &amp;&amp; retRight;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/03/55533a22daa18eeb746d2d6cf3d913a8.png" alt="image-20240318110020250"></p><h2 id="530-二叉搜索树的最小绝对差"><a href="#530-二叉搜索树的最小绝对差" class="headerlink" title="530 二叉搜索树的最小绝对差"></a>530 二叉搜索树的最小绝对差</h2><blockquote><p><a href="https://leetcode.cn/problems/minimum-absolute-difference-in-bst/">530. 二叉搜索树的最小绝对差</a></p></blockquote><p>给你一个二叉搜索树的根节点 <code>root</code> ，返回 <strong>树中任意两不同节点值之间的最小差值</strong> 。</p><p>差值是一个正数，其数值等于两值之差的绝对值。</p><hr><p>因为题目给的是搜索二叉树，还是和前两题类似，利用中序遍历的有序序列，计算两个相邻节点之间的差值，<strong>差值的最小值只可能是在两个相邻节点之间</strong>。这就好比给你一个有序的<strong>单调递增的数组</strong>，让你返回这个数组中任意两个数的最小差值一样。</p><p>同样，可以用中序遍历将搜索二叉树转为数组再进行处理，具体代码参考上题（一模一样的转化再遍历），这里给出直接用中序遍历递归实现的的算法，思路是维护一个当前节点的<strong>前一个节点的指针</strong>，并依次计算两个相邻节点之间的差值。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> minDiff = INT_MAX;</span><br><span class="line">    TreeNode* prev = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="type">void</span> _getMinimumDifference(TreeNode* root)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">nullptr</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 遍历左侧</span></span><br><span class="line">        _getMinimumDifference(root-&gt;left);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 计算差值</span></span><br><span class="line">        <span class="keyword">if</span>(prev != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">            minDiff = <span class="built_in">min</span>(minDiff,root-&gt;val - prev-&gt;val);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 所有情况都需要更新prev</span></span><br><span class="line">        prev = root;</span><br><span class="line">      </span><br><span class="line">        <span class="comment">// 遍历右侧</span></span><br><span class="line">        _getMinimumDifference(root-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getMinimumDifference</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        _getMinimumDifference(root);</span><br><span class="line">        <span class="keyword">return</span> minDiff;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/03/a214d88159622e177076e223f43e6e95.png" alt="image-20240318143728984"></p><p>使用迭代，利用中序遍历的迭代思路也能解决这道题，这里主要是要记住怎么使用栈进行中序遍历。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getMinimumDifference</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">nullptr</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        stack&lt;TreeNode*&gt; st;</span><br><span class="line"></span><br><span class="line">        TreeNode* prev = <span class="literal">nullptr</span>;</span><br><span class="line">        TreeNode* cur = root;</span><br><span class="line">        <span class="type">int</span> ret = INT_MAX; <span class="comment">// 最小差值</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 两个条件符合都不符合才停止循环</span></span><br><span class="line">        <span class="keyword">while</span>(cur != <span class="literal">nullptr</span> || !st.<span class="built_in">empty</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(cur != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">                st.<span class="built_in">push</span>(cur);</span><br><span class="line">                cur = cur-&gt;left; <span class="comment">// 左</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123; <span class="comment">// 往左一直走到空了</span></span><br><span class="line">                cur = st.<span class="built_in">top</span>(); <span class="comment">// 父亲节点</span></span><br><span class="line">                st.<span class="built_in">pop</span>();</span><br><span class="line">                <span class="comment">// 中序处理，计算最小值</span></span><br><span class="line">                <span class="keyword">if</span>(prev != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">                    ret = <span class="built_in">min</span>(ret,cur-&gt;val - prev-&gt;val);</span><br><span class="line">                &#125;</span><br><span class="line">                prev = cur;</span><br><span class="line">                <span class="comment">// 右</span></span><br><span class="line">                cur = cur-&gt;right;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/03/eb41ec52f3f08a6acd2f547b9604ae29.png" alt="image-20240318144644478"></p><h2 id="501-二叉搜索树中的众数"><a href="#501-二叉搜索树中的众数" class="headerlink" title="501 二叉搜索树中的众数"></a>501 二叉搜索树中的众数</h2><blockquote><p><a href="https://leetcode.cn/problems/find-mode-in-binary-search-tree/">501. 二叉搜索树中的众数</a></p></blockquote><p>给你一个含重复值的二叉搜索树（BST）的根节点 <code>root</code> ，找出并返回 BST 中的所有 <a href="https://baike.baidu.com/item/%E4%BC%97%E6%95%B0/44796">众数</a>（即，出现频率最高的元素）。</p><p>如果树中有不止一个众数，可以按 <strong>任意顺序</strong> 返回。</p><p>假定 BST 满足如下定义：</p><ul><li>结点左子树中所含节点的值 <strong>小于等于</strong> 当前节点的值</li><li>结点右子树中所含节点的值 <strong>大于等于</strong> 当前节点的值</li><li>左子树和右子树都是二叉搜索树</li></ul><hr><p>这道题首先可以按任何二叉树来操作，即遍历整棵树，用map记录某个节点出现的频率，最终将出现频率最高的几个数取出来。</p><p>注意，这里不能一上来就直接用优先级队列，因为优先级队列是没有办法修改某个值的。可以用map统计完后再用优先级队列来排序。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="comment">// 因为只是遍历统计，所以用什么顺序遍历都没有区别</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">inorderTravel</span><span class="params">(TreeNode* root,unordered_map&lt;<span class="type">int</span>,<span class="type">int</span>&gt;&amp; countMap)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">nullptr</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">inorderTravel</span>(root-&gt;left,countMap);</span><br><span class="line">        countMap[root-&gt;val]++;</span><br><span class="line">        <span class="built_in">inorderTravel</span>(root-&gt;right,countMap);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">MyCmp</span>&#123;</span><br><span class="line">    <span class="keyword">public</span>: <span class="comment">// 别忘了设置为公有</span></span><br><span class="line">        <span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">const</span> pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt;&amp; p1, <span class="type">const</span> pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt;&amp; p2)</span></span>&#123;</span><br><span class="line">            <span class="keyword">return</span> p1.second &lt; p2.second; <span class="comment">// 使用小于建立大堆</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">findMode</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; retV;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">nullptr</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> retV;</span><br><span class="line">        &#125;</span><br><span class="line">        unordered_map&lt;<span class="type">int</span>,<span class="type">int</span>&gt; countMap;</span><br><span class="line">        <span class="built_in">inorderTravel</span>(root,countMap);</span><br><span class="line">        <span class="comment">// 使用优先级队列来初始化值</span></span><br><span class="line">        priority_queue&lt;pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt;,vector&lt;pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt;&gt;,MyCmp&gt; <span class="built_in">que</span>(countMap.<span class="built_in">begin</span>(),countMap.<span class="built_in">end</span>());</span><br><span class="line">        <span class="comment">// 取出头部计数器相同的，插入数组</span></span><br><span class="line">        <span class="keyword">auto</span> curPair = que.<span class="built_in">top</span>();</span><br><span class="line">        que.<span class="built_in">pop</span>();</span><br><span class="line">        retV.<span class="built_in">push_back</span>(curPair.first);</span><br><span class="line">        <span class="comment">// 只要队列不为空就继续操作</span></span><br><span class="line">        <span class="keyword">while</span>(!que.<span class="built_in">empty</span>())&#123;</span><br><span class="line">            <span class="comment">// 当当前计数和刚刚插入的一致，则继续插入</span></span><br><span class="line">            <span class="keyword">if</span>(curPair.second == que.<span class="built_in">top</span>().second)&#123;</span><br><span class="line">                curPair = que.<span class="built_in">top</span>();</span><br><span class="line">                que.<span class="built_in">pop</span>();</span><br><span class="line">                retV.<span class="built_in">push_back</span>(curPair.first);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">break</span>; <span class="comment">// 不符合条件，跳出</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> retV;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/03/7add75ede3a5bb148a880b6f8b545578.png" alt="image-20240318150300783"></p><p>不过本题是一个搜索二叉树，解题方法肯定不同。还是那个性质，搜索二叉树的中序遍历结果是有序的，那么我们就可以通过这个有序来遍历计算当前数字出现的频率。同样是维护一个prev指针指向上一个节点，并对连续相同的数进行计数。</p><p>当遇到第一个不相同的节点时，清空计数器，将上一个节点插入返回值数组，重新开始计数。如果新的这个数字的数量大于上一个数字，那么就将返回值数组清空（因为此时返回值数组中的元素是无效的），重新按这个新的count计算众数。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="type">int</span> maxCount = <span class="number">-1</span>; <span class="comment">// 计数器肯定是正的，初始化为负数即可</span></span><br><span class="line">    <span class="type">int</span> count = <span class="number">0</span>; <span class="comment">// 这里不能用count作为参数，因为每一层的修改对全局都是有效的</span></span><br><span class="line">    TreeNode* prev = <span class="literal">nullptr</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">inordereTravelCount</span><span class="params">(TreeNode* root,vector&lt;<span class="type">int</span>&gt;&amp; retV)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">nullptr</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 左</span></span><br><span class="line">        <span class="built_in">inordereTravelCount</span>(root-&gt;left,retV);</span><br><span class="line">        <span class="comment">// 中，计数</span></span><br><span class="line">        <span class="keyword">if</span>(prev == <span class="literal">nullptr</span>)<span class="comment">// 第一个节点</span></span><br><span class="line">        &#123;</span><br><span class="line">            count = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(prev-&gt;val == root-&gt;val) <span class="comment">// 相同</span></span><br><span class="line">        &#123;</span><br><span class="line">            count++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="comment">// 不相同，新的节点</span></span><br><span class="line">        &#123;</span><br><span class="line">            count = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        prev = root;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 和当前记录最大值相同，插入        </span></span><br><span class="line">        <span class="keyword">if</span>(count == maxCount)</span><br><span class="line">        &#123;</span><br><span class="line">            retV.<span class="built_in">push_back</span>(root-&gt;val);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 超过了最大记录，需要清空返回值数组</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(count &gt; maxCount)&#123;</span><br><span class="line">            maxCount = count;</span><br><span class="line">            retV.<span class="built_in">clear</span>();</span><br><span class="line">            retV.<span class="built_in">push_back</span>(root-&gt;val);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">inordereTravelCount</span>(root-&gt;right,retV);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">findMode</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; retV;</span><br><span class="line">        <span class="built_in">inordereTravelCount</span>(root,retV);</span><br><span class="line">        <span class="keyword">return</span> retV;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/03/493f11bd2c3022a88ee7307d30d5932b.png" alt="image-20240318151918601"></p><h2 id="236-二叉树的最近公共祖先"><a href="#236-二叉树的最近公共祖先" class="headerlink" title="236 二叉树的最近公共祖先"></a>236 二叉树的最近公共祖先</h2><blockquote><p><a href="https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-tree/">236. 二叉树的最近公共祖先</a></p></blockquote><p>给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。</p><p><a href="https://baike.baidu.com/item/%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88/8918834?fr=aladdin">百度百科</a>中最近公共祖先的定义为：“对于有根树 T 的两个节点 p、q，最近公共祖先表示为一个节点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（<strong>一个节点也可以是它自己的祖先</strong>）。”</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">示例 1：</span><br><span class="line">输入：root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 1</span><br><span class="line">输出：3</span><br><span class="line">解释：节点 5 和节点 1 的最近公共祖先是节点 3 。</span><br><span class="line"></span><br><span class="line">示例 2：</span><br><span class="line">输入：root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 4</span><br><span class="line">输出：5</span><br><span class="line">解释：节点 5 和节点 4 的最近公共祖先是节点 5 。因为根据定义最近公共祖先节点可以为节点本身。</span><br><span class="line"></span><br><span class="line">示例 3：</span><br><span class="line">输入：root = [1,2], p = 1, q = 2</span><br><span class="line">输出：1</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li>树中节点数目在范围 <code>[2, 105]</code> 内。</li><li><code>-109 &lt;= Node.val &lt;= 109</code></li><li>所有 <code>Node.val</code> <code>互不相同</code> 。</li><li><code>p != q</code></li><li><code>p</code> 和 <code>q</code> 均存在于给定的二叉树中。</li></ul><hr><p>首先要明确，root也可以是自己的公共祖先，所以root等于p或者等于q的情况也是符合条件的。本题需要我们从左右子树中找到p和q，然后再往上返回它的最近公共祖先，即从树的底部往上遍历。<strong>后序遍历</strong>（左右中）就是符合这个条件的。</p><p>下图中，带序号的线代表后序遍历的顺序，长虚线代表每一次的返回值。</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/03/11cc4daf0b5ecc01017d3515b944eb39.png" alt="image-20240318190309074"></p><p>整体思路如下：</p><ul><li>判断root是否等于q&#x2F;p，或者root为空，此时返回root；</li><li>递归判断左侧和右侧，记录返回值</li><li>如果左侧和右侧返回值都不为空，则代表当前节点就是最近的公共祖先节点，返回root节点（当前节点）；</li><li>如果左侧和右侧有一个为空，则返回不为空的那一个；</li><li>如果左侧和右侧都为空，则返回空（代表当前节点的子树中没有找到q和p）；</li></ul><p>代码如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">lowestCommonAncestor</span><span class="params">(TreeNode* root, TreeNode* p, TreeNode* q)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// root也可以是它自己的祖先</span></span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">nullptr</span> || root == p || root == q)&#123;</span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 用后序遍历的思路来处理，这样能找到当前节点的孩子里面有么有q或者p</span></span><br><span class="line">        TreeNode* left = <span class="built_in">lowestCommonAncestor</span>(root-&gt;left, p,  q);</span><br><span class="line">        TreeNode* right = <span class="built_in">lowestCommonAncestor</span>(root-&gt;right, p,  q);</span><br><span class="line">        <span class="comment">// 如果左右都不为空，则代表root就是最近的公共祖先</span></span><br><span class="line">        <span class="keyword">if</span>(left != <span class="literal">nullptr</span> &amp;&amp; right != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// // // 如果两个都为空，代表没有找到，返回空</span></span><br><span class="line">        <span class="comment">// if(left == nullptr &amp;&amp; right == nullptr)&#123;</span></span><br><span class="line">        <span class="comment">//     return nullptr;</span></span><br><span class="line">        <span class="comment">// &#125;</span></span><br><span class="line">        <span class="comment">// // 如果有一个为空，则返回另外一个</span></span><br><span class="line">        <span class="comment">// if(left != nullptr &amp;&amp; right == nullptr)&#123;</span></span><br><span class="line">        <span class="comment">//     return left;</span></span><br><span class="line">        <span class="comment">// &#125;</span></span><br><span class="line">        <span class="comment">// if(left == nullptr &amp;&amp; right != nullptr)&#123;</span></span><br><span class="line">        <span class="comment">//     return right;</span></span><br><span class="line">        <span class="comment">// &#125;</span></span><br><span class="line">        <span class="comment">// return nullptr; // 这里的返回没有意义，因为不会走到这里来</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 上面的三个判断可以精简成下面这个</span></span><br><span class="line">        <span class="comment">// 如果left为空且right也为空的时候，本来就需要返回nullptr，此时返回right也是一样的</span></span><br><span class="line">        <span class="keyword">return</span> left != <span class="literal">nullptr</span> ? left : right;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/03/3fbff287842a54bdb60b89c6ded43521.png" alt="image-20240318184443461"></p><h2 id="235-二叉搜索树的最近公共祖先"><a href="#235-二叉搜索树的最近公共祖先" class="headerlink" title="235 二叉搜索树的最近公共祖先"></a>235 二叉搜索树的最近公共祖先</h2><blockquote><p><a href="https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-search-tree/">235. 二叉搜索树的最近公共祖先</a></p></blockquote><p>给定一个二叉搜索树, 找到该树中两个指定节点的最近公共祖先。</p><p><a href="https://baike.baidu.com/item/%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88/8918834?fr=aladdin">百度百科</a>中最近公共祖先的定义为：“对于有根树 T 的两个结点 p、q，最近公共祖先表示为一个结点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（<strong>一个节点也可以是它自己的祖先</strong>）。”</p><hr><p>本题和上一题要求一致，但树是搜索二叉树。利用这个特性，给定q和p的公共祖先的值肯定在<code>[q, p]</code>范围区间之间（注意q和p没有说明谁更大，所以要判断<code>q&lt;cur&lt; p</code>和<code>p&lt;cur&lt;q</code>的两种情况），找公共祖先，只需要从上往下，找到第一个值符合这个区间范围的节点就可以了。</p><ul><li>搜索二叉树的左侧小于当前节点，右侧大于当前节点；</li><li>从上往下遍历（用前序遍历），此时先处理的是中间节点，那么第一个找到的符合<code>[q,p]</code>区间的节点就是最近的公共祖先，此时往左还是往右都会错过；</li></ul><p>如下所示，找1和8节点的公共祖先（即5），此时如果往左走到3，就会错过8的祖先，往右走到9，就会错过1的公共祖先</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/03/ed75ee6553efc114dccd290d96603fc2.png" alt="image-20240318192043482"></p><p>理解思路了，代码就不难写了，前序遍历的二叉搜索代码就可以了。因为这是搜索二叉树，不需要递归也能实现。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">lowestCommonAncestor</span><span class="params">(TreeNode* root, TreeNode* p, TreeNode* q)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">nullptr</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        TreeNode* cur = root;</span><br><span class="line">        <span class="comment">// 找到q和p中的最小值</span></span><br><span class="line">        <span class="type">int</span> min = q-&gt;val,max = p-&gt;val;</span><br><span class="line">        <span class="keyword">if</span>(min &gt; max)&#123;</span><br><span class="line">            min = max;</span><br><span class="line">            max = q-&gt;val;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(cur != <span class="literal">nullptr</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 符合条件</span></span><br><span class="line">            <span class="keyword">if</span>(cur-&gt;val &gt;= min &amp;&amp; cur-&gt;val &lt;= max)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> cur;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 如果大了，就往左走</span></span><br><span class="line">            <span class="keyword">if</span>(cur-&gt;val &gt; max)&#123;</span><br><span class="line">                cur = cur-&gt;left;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 小了就往右边走</span></span><br><span class="line">            <span class="keyword">if</span>(cur-&gt;val &lt; min)&#123;</span><br><span class="line">                cur = cur-&gt;right;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/03/38160fcf06b8e269687f27e24468d03d.png" alt="image-20240318192653511"></p><h2 id="701-二叉搜索树中的插入操作"><a href="#701-二叉搜索树中的插入操作" class="headerlink" title="701 二叉搜索树中的插入操作"></a>701 二叉搜索树中的插入操作</h2><blockquote><p><a href="https://leetcode.cn/problems/insert-into-a-binary-search-tree/">701. 二叉搜索树中的插入操作</a></p></blockquote><p>给定二叉搜索树（BST）的根节点 <code>root</code> 和要插入树中的值 <code>value</code> ，将值插入二叉搜索树。 返回插入后二叉搜索树的根节点。 输入数据 <strong>保证</strong> ，新值和原始二叉搜索树中的任意节点值都不同。</p><p><strong>注意</strong>，可能存在多种有效的插入方式，只要树在插入后仍保持为二叉搜索树即可。 你可以返回 <strong>任意有效的结果</strong> 。</p><hr><p>这道题没有那么难，因为题目要求的是二叉搜索树，并不是平衡二叉搜索树，所以不存在需要翻转的情况。我们只需要找到这个新节点应该存放的位置，将其链接进去就行了。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">insertIntoBST</span><span class="params">(TreeNode* root, <span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">        TreeNode* newNode = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(val);</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">nullptr</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> newNode;</span><br><span class="line">        &#125;</span><br><span class="line">        TreeNode* cur = root;</span><br><span class="line">        TreeNode* prev = root;</span><br><span class="line">        <span class="keyword">while</span>(cur != <span class="literal">nullptr</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(cur-&gt;val &gt; val)&#123;</span><br><span class="line">                prev = cur;</span><br><span class="line">                cur = cur-&gt;left;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(cur-&gt;val &lt; val)&#123;</span><br><span class="line">                prev = cur;</span><br><span class="line">                cur = cur-&gt;right;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 走到对应位置了</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 上一个节点肯定是叶子节点</span></span><br><span class="line">        <span class="comment">// 当前节点值更大，是左侧</span></span><br><span class="line">        <span class="keyword">if</span>(prev-&gt;val &gt; val)&#123;</span><br><span class="line">            prev-&gt;left = newNode;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 当前节点值更小，所以是右侧</span></span><br><span class="line">        <span class="keyword">if</span>(prev-&gt;val &lt; val)&#123;</span><br><span class="line">            prev-&gt;right = newNode;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/03/535f71322ea3e7dc4ffbab1b94c9d509.png" alt="image-20240318193613367"></p><h2 id="450-删除二叉搜索树中的节点"><a href="#450-删除二叉搜索树中的节点" class="headerlink" title="450 删除二叉搜索树中的节点"></a>450 删除二叉搜索树中的节点</h2><blockquote><p><a href="https://leetcode.cn/problems/delete-node-in-a-bst/">450. 删除二叉搜索树中的节点</a></p></blockquote><p>给定一个二叉搜索树的根节点 <strong>root</strong> 和一个值 <strong>key</strong>，删除二叉搜索树中的 <strong>key</strong> 对应的节点，并保证二叉搜索树的性质不变。返回二叉搜索树（有可能被更新）的根节点的引用。</p><p>一般来说，删除节点可分为两个步骤：</p><ol><li>首先找到需要删除的节点；</li><li>如果找到了，删除它。</li></ol><p><strong>提示:</strong></p><ul><li>节点数的范围 <code>[0, 104]</code></li><li><code>-105 &lt;= Node.val &lt;= 105</code></li><li>节点值唯一</li><li><code>root</code> 是合法的二叉搜索树</li><li><code>-105 &lt;= key &lt;= 105</code></li></ul><hr><p>删除搜索二叉树中的节点需要判断当前的情况</p><ul><li>没找到需要删除的节点，直接返回；</li><li>当前节点是叶子节点，将父节点的指针改成nullptr，delete该节点即可；</li><li>当前节点左侧节点为空，右侧不为空，将右侧节点记录，父节点的指针改成右侧节点，删除当前节点；</li><li>当前节点右侧节点为空，左侧不为空，将左侧节点记录，父节点的指针改成左侧节点，删除当前节点；</li><li>当前节点左侧右侧都不为空，将当前节点的<strong>左侧</strong>移动至<strong>右侧的最左节点</strong>，</li></ul><p>这里最难处理的是最后一种情况，见下图，红色是要被删除的节点5，绿色是该节点的左子树，蓝色是该节点的右子树。我们需要将5节点的左子树3移动到它的右子树的最左侧节点（即移动到6的位置）链接上。</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/03/692196a8807952e769421990232060e8.png" alt="image-20240318200430007"></p><p>因为是二叉搜索树，所以不需要用递归，循环找节点就行了。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"></span><br><span class="line">    <span class="function">TreeNode* <span class="title">deleteOneNode</span><span class="params">(TreeNode* target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (target == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> target;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 右侧为空，无论如何都返回左侧</span></span><br><span class="line">        <span class="keyword">if</span> (target-&gt;right == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> target-&gt;left;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 右侧不为空，统一处理，找到右子树的最左侧节点，进行链接</span></span><br><span class="line">        TreeNode* cur = target-&gt;right;</span><br><span class="line">        <span class="keyword">while</span> (cur-&gt;left != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            cur = cur-&gt;left;</span><br><span class="line">        &#125;</span><br><span class="line">        cur-&gt;left = target-&gt;left;</span><br><span class="line">        <span class="keyword">return</span> target-&gt;right;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">deleteNode</span><span class="params">(TreeNode* root, <span class="type">int</span> key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        &#125;</span><br><span class="line">        TreeNode* cur = root;</span><br><span class="line">        TreeNode* pre = <span class="literal">nullptr</span>; <span class="comment">// 记录cur的父节点，用来删除cur</span></span><br><span class="line">        <span class="keyword">while</span> (cur != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (cur-&gt;val == key) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            pre = cur;</span><br><span class="line">            <span class="keyword">if</span> (cur-&gt;val &gt; key) &#123;</span><br><span class="line">                cur = cur-&gt;left;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                cur = cur-&gt;right;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (pre == <span class="literal">nullptr</span>) &#123; <span class="comment">// 如果搜索树只有头结点</span></span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">deleteOneNode</span>(cur);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 判断删左孩子还是右孩子</span></span><br><span class="line">        <span class="keyword">if</span> (pre-&gt;left != <span class="literal">nullptr</span> &amp;&amp; pre-&gt;left == cur) &#123;</span><br><span class="line">            pre-&gt;left = <span class="built_in">deleteOneNode</span>(cur);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (pre-&gt;right != <span class="literal">nullptr</span> &amp;&amp; pre-&gt;right == cur) &#123;</span><br><span class="line">            pre-&gt;right = <span class="built_in">deleteOneNode</span>(cur);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/03/c59158ebd922e21fcd72d0df02c3d4d0.png" alt="image-20240319105711618"></p><h2 id="669-修建二叉搜索树"><a href="#669-修建二叉搜索树" class="headerlink" title="669 修建二叉搜索树"></a>669 修建二叉搜索树</h2><blockquote><p><a href="https://leetcode.cn/problems/trim-a-binary-search-tree/">669. 修剪二叉搜索树</a></p></blockquote><p>给你二叉搜索树的根节点 <code>root</code> ，同时给定最小边界<code>low</code> 和最大边界 <code>high</code>。通过修剪二叉搜索树，使得所有节点的值在<code>[low, high]</code>中。修剪树 <strong>不应该</strong> 改变保留在树中的元素的相对结构 (即，如果没有被移除，原有的父代子代关系都应当保留)。 可以证明，存在 <strong>唯一的答案</strong> 。</p><p>所以结果应当返回修剪好的二叉搜索树的新的根节点。注意，根节点可能会根据给定的边界发生改变。</p><hr><p>这里使用递归的方式来处理节点，通过返回值来将需要删除的节点排除掉。</p><ul><li>空节点，返回（递归末端条件）；</li><li>如果当前节点小于目标区间，则往右侧找并返回（这就相当于删除了当前节点）；</li><li>如果当前节点大于目标区间，则往左侧找并返回（这就相当于删除了当前节点）；</li><li>如果当前节点符合目标区间，则递归遍历左子树和右子树，并重新赋值新的左子树和右子树；</li></ul><p>其中最后一步是比较重要的，当前节点符合条件后，它的左侧和右侧可能会有不在区间内的节点，所以在递归遍历的同时，需要更新当前节点的左右子树指针，来接受递归后<strong>剔除了不符合条件节点</strong>的树。</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/03/9915c8d233479e5891444fd29a9d1898.png" alt="image-20240319122027435"></p><p>主要是理解如何通过递归的返回值来巧妙的“删除”不符合条件的节点。以上图的树为例，给定区间<code>[2,4]</code>，需要删除的节点是0和1。过程如下</p><ul><li>3符合条件，递归遍历左子树和右子树</li><li>右子树的4符合条件，递归遍历左子树和右子树（都为空，直接返回，相当于对4的节点没有做修改），最终返回4节点，赋值给3节点的right（也相当于没有修改）</li><li>左子树的0不符合条件（小于边界最小值），递归遍历右子树；</li><li>右子树的2符合条件，递归遍历左子树和右子树（2的右子树是空，直接返回）；</li><li>2的左子树1不符合条件（小于边界最小值），递归遍历右子树，此时1的右子树为空，相当于遍历1的这一次也是返回nullptr，并赋值给了2节点的right，相当于删除了节点1；</li><li>此时递归返回，2号节点往上返回（即遍历到0的那一次会返回2号节点），赋值给了3号节点的right，相当于删除了节点0。</li></ul><p>代码如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    TreeNode* _trimBST(TreeNode* root, <span class="type">const</span> <span class="type">int</span> low,<span class="type">const</span> <span class="type">int</span> high) &#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">nullptr</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 注意题目给出的是闭区间，所以这里超出的情况不包括=的情况</span></span><br><span class="line">        <span class="comment">// 如果当前节点值不在区间内，则往右边/左边找是否有符合条件的</span></span><br><span class="line">        <span class="comment">// 如果有则会正常返回符合条件的节点（也相当于通过返回值把当前节点删掉了）</span></span><br><span class="line">        <span class="keyword">if</span>(root-&gt;val &lt; low)&#123;</span><br><span class="line">            <span class="keyword">return</span> _trimBST(root-&gt;right,low,high);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;val &gt; high)&#123;</span><br><span class="line">            <span class="keyword">return</span> _trimBST(root-&gt;left,low,high);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 当前root的值符合范围，递归左子树和右子树，剔除不符合条件的节点</span></span><br><span class="line">        root-&gt;left = _trimBST(root-&gt;left,low,high);</span><br><span class="line">        root-&gt;right = _trimBST(root-&gt;right,low,high);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">trimBST</span><span class="params">(TreeNode* root, <span class="type">int</span> low, <span class="type">int</span> high)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">nullptr</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> _trimBST(root,low,high);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/03/d182dfe0db490518d670dbdb30fea46f.png" alt="image-20240319121234419"></p><h2 id="108-将有序数组转为二叉搜索树"><a href="#108-将有序数组转为二叉搜索树" class="headerlink" title="108 将有序数组转为二叉搜索树"></a>108 将有序数组转为二叉搜索树</h2><blockquote><p><a href="https://leetcode.cn/problems/convert-sorted-array-to-binary-search-tree/">108. 将有序数组转换为二叉搜索树</a></p></blockquote><p>给你一个整数数组 <code>nums</code> ，其中元素已经按 <strong>升序</strong> 排列，请你将其转换为一棵 平衡 二叉搜索树。</p><hr><p>这道题其实没有想象中的那么难，因为题目给的数组是有序的，我们只需要通过<strong>前序遍历</strong>加上拆分数组，最终构建出来的树肯定会是一个平衡的二叉搜索树。</p><p>在上文中的<code>654 最大二叉树</code>中已经使用了拆分数组构建树的方式，那道题是需要找到数组中的最大点。本题的平衡二叉搜索树需要找到<strong>有序数组的中间节点</strong>（即当前的众位树）作为根。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    TreeNode* _sortedArrayToBST(<span class="type">const</span> vector&lt;<span class="type">int</span>&gt;&amp; nums,<span class="type">int</span> left,<span class="type">int</span> right) &#123;</span><br><span class="line">        <span class="keyword">if</span>(left &gt;= right)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> mid = left + ((right - left)/<span class="number">2</span>); </span><br><span class="line">        </span><br><span class="line">        <span class="comment">// int mid = (right - left)/2; // 这样计算的结果是错误的，值可能会小于left，导致陷入死循环</span></span><br><span class="line"></span><br><span class="line">        TreeNode* root = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(nums[mid]);</span><br><span class="line">        root-&gt;left = _sortedArrayToBST(nums,left,mid);</span><br><span class="line">        root-&gt;right = _sortedArrayToBST(nums,mid+<span class="number">1</span>,right);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">sortedArrayToBST</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums.<span class="built_in">size</span>() == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> _sortedArrayToBST(nums,<span class="number">0</span>,nums.<span class="built_in">size</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/03/ad9482d397c93fc97210bb4b8bba543a.png" alt="image-20240319124522237"></p><p>如果使用迭代法，需要三个队列，一个存放节点，一个存放左区间，一个存放右区间。以下代码来自<a href="https://www.programmercarl.com/0108.%E5%B0%86%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E8%BD%AC%E6%8D%A2%E4%B8%BA%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91.html#%E6%80%9D%E8%B7%AF">代码随想录</a>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">sortedArrayToBST</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (nums.<span class="built_in">size</span>() == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">        TreeNode* root = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(<span class="number">0</span>);   <span class="comment">// 初始根节点</span></span><br><span class="line">        queue&lt;TreeNode*&gt; nodeQue;           <span class="comment">// 放遍历的节点</span></span><br><span class="line">        queue&lt;<span class="type">int</span>&gt; leftQue;                 <span class="comment">// 保存左区间下标</span></span><br><span class="line">        queue&lt;<span class="type">int</span>&gt; rightQue;                <span class="comment">// 保存右区间下标</span></span><br><span class="line">        nodeQue.<span class="built_in">push</span>(root);                 <span class="comment">// 根节点入队列</span></span><br><span class="line">        leftQue.<span class="built_in">push</span>(<span class="number">0</span>);                    <span class="comment">// 0为左区间下标初始位置</span></span><br><span class="line">        rightQue.<span class="built_in">push</span>(nums.<span class="built_in">size</span>() - <span class="number">1</span>);     <span class="comment">// nums.size() - 1为右区间下标初始位置</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (!nodeQue.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            TreeNode* curNode = nodeQue.<span class="built_in">front</span>();</span><br><span class="line">            nodeQue.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="type">int</span> left = leftQue.<span class="built_in">front</span>(); leftQue.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="type">int</span> right = rightQue.<span class="built_in">front</span>(); rightQue.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="type">int</span> mid = left + ((right - left) / <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">            curNode-&gt;val = nums[mid];       <span class="comment">// 将mid对应的元素给中间节点</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (left &lt;= mid - <span class="number">1</span>) &#123;          <span class="comment">// 处理左区间</span></span><br><span class="line">                curNode-&gt;left = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(<span class="number">0</span>);</span><br><span class="line">                nodeQue.<span class="built_in">push</span>(curNode-&gt;left);</span><br><span class="line">                leftQue.<span class="built_in">push</span>(left);</span><br><span class="line">                rightQue.<span class="built_in">push</span>(mid - <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (right &gt;= mid + <span class="number">1</span>) &#123;         <span class="comment">// 处理右区间</span></span><br><span class="line">                curNode-&gt;right = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(<span class="number">0</span>);</span><br><span class="line">                nodeQue.<span class="built_in">push</span>(curNode-&gt;right);</span><br><span class="line">                leftQue.<span class="built_in">push</span>(mid + <span class="number">1</span>);</span><br><span class="line">                rightQue.<span class="built_in">push</span>(right);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="538-把二叉搜索树转为累加树"><a href="#538-把二叉搜索树转为累加树" class="headerlink" title="538 把二叉搜索树转为累加树"></a>538 把二叉搜索树转为累加树</h2><blockquote><p><a href="https://leetcode.cn/problems/convert-bst-to-greater-tree/">538. 把二叉搜索树转换为累加树</a></p></blockquote><p>给出二叉 <strong>搜索</strong> 树的根节点，该树的节点值各不相同，请你将其转换为累加树（Greater Sum Tree），使每个节点 <code>node</code> 的新值等于原树中大于或等于 <code>node.val</code> 的值之和。</p><p>提醒一下，二叉搜索树满足下列约束条件：</p><ul><li>节点的左子树仅包含键 <strong>小于</strong> 节点键的节点。</li><li>节点的右子树仅包含键 <strong>大于</strong> 节点键的节点。</li><li>左右子树也必须是二叉搜索树。</li></ul><p><strong>注意：</strong>本题和 1038: <a href="https://leetcode-cn.com/problems/binary-search-tree-to-greater-sum-tree/">https://leetcode-cn.com/problems/binary-search-tree-to-greater-sum-tree/</a> 相同</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/03/7ef89c321b9f619dfccde873ccd90f9c.png" alt="image-20240319124844008"></p><p>题目要求的是将每个节点的值转为它和它右侧的节点的和。用数组可能更好理解一些，即将当前数组下标位置的<strong>值改为它和它右侧的节点的和</strong>。</p><p>所以可以从右侧往左侧遍历这个数组，记录一个求和值，并将当前数组的值加上这个求和值就行了。比如数组<code>[15,24,30]</code>的结果是<code>[68,54,30]</code>；</p><p>对于二叉树也是一样的，从右侧往左侧遍历，顺序是<code>右中左</code>，把中序遍历的代码改一下顺序就行了。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="type">int</span> sum  = <span class="number">0</span>;</span><br><span class="line">    TreeNode* _convertBST(TreeNode* root) &#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">nullptr</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        &#125;</span><br><span class="line">        _convertBST(root-&gt;right);</span><br><span class="line">        sum += root-&gt;val;</span><br><span class="line">        root-&gt;val = sum;</span><br><span class="line">        _convertBST(root-&gt;left);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">convertBST</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">nullptr</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> _convertBST(root);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/03/60fa23c99471735c788fe0f350bac25d.png" alt="image-20240319183019626"></p><p>如果要用迭代法，同样是中序遍历的迭代模板，将左右子树遍历的顺序修改一下就可以了。以下代码来自代码随想录</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> pre; <span class="comment">// 记录前一个节点的数值</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">traversal</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        stack&lt;TreeNode*&gt; st;</span><br><span class="line">        TreeNode* cur = root;</span><br><span class="line">        <span class="keyword">while</span> (cur != <span class="literal">NULL</span> || !st.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (cur != <span class="literal">NULL</span>) &#123;</span><br><span class="line">                st.<span class="built_in">push</span>(cur);</span><br><span class="line">                cur = cur-&gt;right;   <span class="comment">// 右</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                cur = st.<span class="built_in">top</span>();     <span class="comment">// 中</span></span><br><span class="line">                st.<span class="built_in">pop</span>();</span><br><span class="line">                cur-&gt;val += pre;</span><br><span class="line">                pre = cur-&gt;val;</span><br><span class="line">                cur = cur-&gt;left;    <span class="comment">// 左</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">convertBST</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        pre = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">traversal</span>(root);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="3-递归函数什么时候需要返回值？"><a href="#3-递归函数什么时候需要返回值？" class="headerlink" title="3.递归函数什么时候需要返回值？"></a>3.递归函数什么时候需要返回值？</h1><blockquote><p>以下总结来自代码随想录</p></blockquote><p>递归函数什么时候需要返回值？什么时候不需要返回值？这里总结如下三点：</p><ul><li>如果需要搜索整棵二叉树且不用处理递归返回值，递归函数就不要返回值。（题目113路径总和2）</li><li>如果需要搜索整棵二叉树且需要处理递归返回值，递归函数就需要返回值。 （题目236二叉树的最近公共祖先）</li><li>如果要搜索其中一条符合条件的路径，那么递归一定需要返回值，因为遇到符合条件的路径了就要及时返回。（题目112路径总和）</li></ul><h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>本篇刷题笔记到这里就结束啦，如果对涉及到的题目有什么不懂的地方，可以在评论区提出哦！</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2023/02/202204161703532.png" alt="image-20220416170310498"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;本文首发于&lt;code&gt;2022-04-20&lt;/code&gt;，2024年重新刷题，对本文做了较大更新，所以重新发布。&lt;/p&gt;
&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;上篇博客我带</summary>
      
    
    
    
    <category term="编程学习" scheme="https://blog.musnow.top/categories/%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="数据结构" scheme="https://blog.musnow.top/categories/%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
    <category term="C语言" scheme="https://blog.musnow.top/tags/C%E8%AF%AD%E8%A8%80/"/>
    
    <category term="数据结构" scheme="https://blog.musnow.top/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    <category term="OJ刷题" scheme="https://blog.musnow.top/tags/OJ%E5%88%B7%E9%A2%98/"/>
    
    <category term="树" scheme="https://blog.musnow.top/tags/%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>【leetcode】239滑动窗口最大值</title>
    <link href="https://blog.musnow.top/posts/2402466745/"/>
    <id>https://blog.musnow.top/posts/2402466745/</id>
    <published>2024-03-14T01:05:54.000Z</published>
    <updated>2024-03-14T11:09:01.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p><a href="https://leetcode.cn/problems/sliding-window-maximum/description/">239. 滑动窗口最大值 - 力扣（LeetCode）</a></p><p>给你一个整数数组 nums，有一个大小为 k 的滑动窗口从数组的最左侧移动到数组的最右侧。你只可以看到在滑动窗口内的 k 个数字。滑动窗口每次只向右移动一位。</p><p>返回 滑动窗口中的最大值 。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">示例 1：</span><br><span class="line">输入：nums = [1,3,-1,-3,5,3,6,7], k = 3</span><br><span class="line">输出：[3,3,5,5,6,7]</span><br><span class="line">解释：</span><br><span class="line">滑动窗口的位置                最大值</span><br><span class="line">---------------               -----</span><br><span class="line">[1  3  -1] -3  5  3  6  7       3</span><br><span class="line"> 1 [3  -1  -3] 5  3  6  7       3</span><br><span class="line"> 1  3 [-1  -3  5] 3  6  7       5</span><br><span class="line"> 1  3  -1 [-3  5  3] 6  7       5</span><br><span class="line"> 1  3  -1  -3 [5  3  6] 7       6</span><br><span class="line"> 1  3  -1  -3  5 [3  6  7]      7</span><br><span class="line"></span><br><span class="line">示例 2：</span><br><span class="line">输入：nums = [1], k = 1</span><br><span class="line">输出：[1]</span><br></pre></td></tr></table></figure><p>提示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1 &lt;= nums.length &lt;= 105</span><br><span class="line">-104 &lt;= nums[i] &lt;= 104</span><br><span class="line">1 &lt;= k &lt;= nums.length</span><br></pre></td></tr></table></figure><h1 id="思路一"><a href="#思路一" class="headerlink" title="思路一"></a>思路一</h1><h2 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h2><p>我最初自己想的思路是，用一个队列来维护滑动窗口，并用一个当前最大值来记录滑动窗口内的最大值。每次滑动窗口满了（为k），都将这个最大值写入返回值数组中。</p><p>当滑动窗口左侧缩限的时候，判断被出队列的是否为最大值</p><ul><li>不是最大值，不用更新当前最大值；</li><li>是最大值，从队列剩余数据中选出一个新的当前最大值；</li></ul><p>这样就能维护出一个题目需要的数组。代码如下</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">maxSlidingWindow</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> curMax = INT32_MIN; <span class="comment">// 当前最大值</span></span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; retV; <span class="comment">//最大值返回数组</span></span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> size = <span class="number">0</span>;<span class="comment">// 当前队列长度</span></span><br><span class="line">        queue&lt;<span class="type">int</span>&gt; que;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span>&amp;e:nums)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 长度已经等于3了，需要出一个数字</span></span><br><span class="line">            <span class="keyword">if</span>(size == k)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="type">int</span> popNum = que.<span class="built_in">front</span>();</span><br><span class="line">                que.<span class="built_in">pop</span>();</span><br><span class="line">                size--;</span><br><span class="line">                <span class="comment">// 出队列的就是最大值，那需要从队列里面剩下的选出一个最大值</span></span><br><span class="line">                <span class="keyword">if</span>(popNum == curMax)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="type">int</span> count = size;</span><br><span class="line">                    curMax = que.<span class="built_in">front</span>(); <span class="comment">// 重置为队列开头值，避免无法匹配</span></span><br><span class="line">                    <span class="keyword">while</span>(count --)</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="comment">// 选最大值</span></span><br><span class="line">                        <span class="type">int</span> temp = que.<span class="built_in">front</span>();</span><br><span class="line">                        curMax = <span class="built_in">max</span>(curMax,temp);</span><br><span class="line">                        que.<span class="built_in">pop</span>();</span><br><span class="line">                        que.<span class="built_in">push</span>(temp); <span class="comment">// 再插回去</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 出队列的不是最大值，不用处理</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 长度小于3，需要入数字</span></span><br><span class="line">            <span class="keyword">if</span>(size &lt; k)</span><br><span class="line">            &#123;</span><br><span class="line">                curMax = <span class="built_in">max</span>(curMax,e);</span><br><span class="line">                que.<span class="built_in">push</span>(e);</span><br><span class="line">                size++;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 每次size等于3的时候都将最大值写入数组</span></span><br><span class="line">            <span class="keyword">if</span>(size == k)</span><br><span class="line">            &#123;</span><br><span class="line">                retV.<span class="built_in">push_back</span>(curMax);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 数量不足k个，最大值需要插入数组</span></span><br><span class="line">        <span class="keyword">if</span>(nums.<span class="built_in">size</span>() &lt; k)</span><br><span class="line">        &#123;</span><br><span class="line">            retV.<span class="built_in">push_back</span>(curMax);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> retV;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这个代码的时间复杂度是<code>O(N*K)</code>，因为最差情况视作每次都需要重新遍历队列，时间复杂度就很高了。但思路应该是没有问题的，通过了大部分测试用例，只不过在大测试用例中超时了，因为此时K很大，如果需要重新遍历对列找出第二个最大值，耗时会很高。</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/03/dbc1d566677a56a511bb37f3e9823663.png" alt="image.png"></p><p>当然，我想出了另外一个优化方案，就是对于这种大k的情况，维护一个队列中第二大的数据，就不需要遍历对列了。但这样很麻烦，且这个思路本身就已经不适合解这道题了，于是没有尝试。</p><h1 id="思路二"><a href="#思路二" class="headerlink" title="思路二"></a>思路二</h1><h2 id="说明-1"><a href="#说明-1" class="headerlink" title="说明"></a>说明</h2><p>思路二是<a href="https://www.programmercarl.com/0239.%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E6%9C%80%E5%A4%A7%E5%80%BC.html">代码随想录</a>上面的，使用一个单调递增&#x2F;递减对列来维护这个最大值。对于本题而言，使用单调递减序列更适合。</p><p>这个对列需要实现push&#x2F;pop&#x2F;front三个功能，其中front就是当前滑动窗口中的最大值：</p><ul><li>push：当<strong>当前值</strong>小于对列尾部值时，直接插入；大于时，出队列尾部数值，直到当前值小于队列尾部数值，插入；</li><li>pop：如果滑动窗口删除的数据和队头数据一致，出队头数据（因为这是一个需要被删除的最大值）；不一致则不做任何操作；</li><li>front：获取队头数据；</li></ul><p>注意，这个单调对列只是针对本体的需求来写的。本体只是需要滑动窗口中的最大值，对于对列而言并不需要维护滑动窗口中的所有元素，只需要维护几个递减的最大值就行了。</p><blockquote><p>本题也不能用堆来实现，因为堆只能删除堆顶元素，堆顶元素不一定是滑动窗口需要移除的元素。这会导致堆内元素和当前滑动窗口内的元素不对应，会出现问题。</p></blockquote><p>使用C++的deque数据结构就可以实现一个这样的对列。deque是stack&#x2F;queue默认的底层容器，stack&#x2F;queue在C++中是<strong>容器适配器</strong>（因为它们并不是直接实现的，而是借助其他容器实现的）。deque的特性让它支持队头队尾的插入删除操作。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 单调队列（从大到小）</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyQueue</span> </span><br><span class="line">&#123; </span><br><span class="line">deque&lt;<span class="type">int</span>&gt; que; <span class="comment">// 使用deque来实现单调队列</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 每次弹出的时候，比较当前要弹出的数值是否等于队列出口元素的数值，如果相等则弹出。</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">pop</span><span class="params">(<span class="type">int</span> value)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">    <span class="comment">// 先判断是否为空再判断是否相等</span></span><br><span class="line">        <span class="keyword">if</span> (!que.<span class="built_in">empty</span>() &amp;&amp; value == que.<span class="built_in">front</span>()) </span><br><span class="line">        &#123;</span><br><span class="line">            que.<span class="built_in">pop_front</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果push的数值大于入口元素的数值，那么就将队列后端的数值弹出，直到push的数值小于等于队列入口元素的数值为止。</span></span><br><span class="line">    <span class="comment">// 这样就保持了队列里的数值是单调从大到小的了。</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(<span class="type">int</span> value)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (!que.<span class="built_in">empty</span>() &amp;&amp; value &gt; que.<span class="built_in">back</span>()) </span><br><span class="line">        &#123;</span><br><span class="line">            que.<span class="built_in">pop_back</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        que.<span class="built_in">push_back</span>(value);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 查询当前队列里的最大值，直接返回队列前端就可以了。</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">front</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> que.<span class="built_in">front</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h2><p>有了这个单调递减的对列后，我们现在只需要将vector中的元素按K滑动窗口大小往对列输入就可以了。注意，删除元素的时候要删除当前滑动窗口第一个元素，再加入新元素。</p><p>第一次遍历后需要插入一次最大值是因为<strong>第二个循环可能不会进去</strong>，而且第二个循环中会先移动窗口再插入新的最大值，如果不提前插入第一个最大值，可能会漏掉。</p><p>另外，本体限定K不会大于数组的长度，所以第一个循环用K做边界是不会数组越界的。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="comment">// 单调队列（从大到小）</span></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">MyQueue</span> </span><br><span class="line">    &#123; </span><br><span class="line">        deque&lt;<span class="type">int</span>&gt; que; <span class="comment">// 使用deque来实现单调队列</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="comment">// 每次弹出的时候，比较当前要弹出的数值是否等于队列出口元素的数值，如果相等则弹出。</span></span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">pop</span><span class="params">(<span class="type">int</span> value)</span> </span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            <span class="comment">// 先判断是否为空再判断是否相等</span></span><br><span class="line">            <span class="keyword">if</span> (!que.<span class="built_in">empty</span>() &amp;&amp; value == que.<span class="built_in">front</span>()) </span><br><span class="line">            &#123;</span><br><span class="line">                que.<span class="built_in">pop_front</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果push的数值大于入口元素的数值，那么就将队列后端的数值弹出，直到push的数值小于等于队列入口元素的数值为止。</span></span><br><span class="line">        <span class="comment">// 这样就保持了队列里的数值是单调从大到小的了。</span></span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(<span class="type">int</span> value)</span> </span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            <span class="keyword">while</span> (!que.<span class="built_in">empty</span>() &amp;&amp; value &gt; que.<span class="built_in">back</span>()) </span><br><span class="line">            &#123;</span><br><span class="line">                que.<span class="built_in">pop_back</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            que.<span class="built_in">push_back</span>(value);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 查询当前队列里的最大值，直接返回队列前端就可以了。</span></span><br><span class="line">        <span class="function"><span class="type">int</span> <span class="title">front</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> que.<span class="built_in">front</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">maxSlidingWindow</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        MyQueue que;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; retV;</span><br><span class="line">        <span class="comment">// 先把数组前k个元素送入对列</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i =<span class="number">0</span>;i&lt;k;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            que.<span class="built_in">push</span>(nums[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 先把第一个最大值插入</span></span><br><span class="line">        retV.<span class="built_in">push_back</span>(que.<span class="built_in">front</span>());</span><br><span class="line">        <span class="comment">// 然后开始移动滑动窗口</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = k;i&lt;nums.<span class="built_in">size</span>();i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 当i == k 的时候删除0，符合题目条件，不需要修改其他地方的代码</span></span><br><span class="line">            que.<span class="built_in">pop</span>(nums[i - k]); <span class="comment">// 删除滑动窗口第一个元素</span></span><br><span class="line">            que.<span class="built_in">push</span>(nums[i]); <span class="comment">// 插入新元素</span></span><br><span class="line">            <span class="comment">// 插入最大值</span></span><br><span class="line">            retV.<span class="built_in">push_back</span>(que.<span class="built_in">front</span>());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> retV;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/03/30471dcac1c94c4b6abb659af91d11f7.png" alt="image.png"></p><h1 id="The-end"><a href="#The-end" class="headerlink" title="The end"></a>The end</h1><p>单调递增&#x2F;单调递减的对列思想还是第一次遇到，学到了。</p>]]></content>
    
    
    <summary type="html">leetcode239题，滑动窗口最大值</summary>
    
    
    
    <category term="编程学习" scheme="https://blog.musnow.top/categories/%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="把题目都给刷干净" scheme="https://blog.musnow.top/categories/%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0/%E6%8A%8A%E9%A2%98%E7%9B%AE%E9%83%BD%E7%BB%99%E5%88%B7%E5%B9%B2%E5%87%80/"/>
    
    
    <category term="队列" scheme="https://blog.musnow.top/tags/%E9%98%9F%E5%88%97/"/>
    
    <category term="leetcode" scheme="https://blog.musnow.top/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>【leetcode】150.逆波兰表达式求值，以及前缀中缀后缀的相互转换</title>
    <link href="https://blog.musnow.top/posts/3211822811/"/>
    <id>https://blog.musnow.top/posts/3211822811/</id>
    <published>2024-03-13T08:33:43.000Z</published>
    <updated>2024-03-14T01:05:49.000Z</updated>
    
    <content type="html"><![CDATA[<p>本文最初写作于2022-07-18，于近日大量更新，故重新发布。</p><h1 id="1-什么是前缀-x2F-中缀-x2F-后缀表达式？"><a href="#1-什么是前缀-x2F-中缀-x2F-后缀表达式？" class="headerlink" title="1. 什么是前缀&#x2F;中缀&#x2F;后缀表达式？"></a>1. 什么是前缀&#x2F;中缀&#x2F;后缀表达式？</h1><p>我们日常学习数学，使用的表达式就是中缀表达式</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1 + 2 * 3 / 2 - 5</span><br></pre></td></tr></table></figure><p><strong>前缀表达式就是将操作符放在操作数之前的表达式</strong>；中缀转前缀的方式是，先将中缀表达式按运算顺序加上括号，再将操作符移动到对应括号的前面，最后删除括号，就是前缀表达式</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">((1 + ((2 * 3) / 2)) - 5)</span><br><span class="line">- (+(1 / (*(2 3) 2))  5)</span><br><span class="line">- + 1 / * 2 3 2 5</span><br></pre></td></tr></table></figure><p><strong>后缀表达式就是将操作符放在操作数之前的表达式</strong>；同样是加括号，再将运算符移动到括号后，再去括号</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">((1 + ((2 * 3) / 2)) - 5)</span><br><span class="line">((1 ((2 3)* 2)/) + 5) - </span><br><span class="line">1 2 3 * 2 / + 5 - </span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/03/051e1603775a69a8cb8f557b8050812d.png" alt="img"></p><p>前缀表达式又称“波兰表达式”，后缀表达式为“逆波兰表达式”。</p><h1 id="2-表达式转换"><a href="#2-表达式转换" class="headerlink" title="2. 表达式转换"></a>2. 表达式转换</h1><h2 id="2-1-中缀转后缀"><a href="#2-1-中缀转后缀" class="headerlink" title="2.1. 中缀转后缀"></a>2.1. 中缀转后缀</h2><p>中缀表达式转换为后缀表达式的手工做法为：</p><p>按照运算符的优先级对所有的运算单位加括号。例： <code>((a/b) + (((c*d) - (e*f))/g))</code><br>把运算符号移动到对应括号的后面，然后去掉括号。例：<code>((ab)/ (((cd)*(ef)*)-g)/+</code>，去掉括号<code>ab/cd*ef*-g/+</code>；</p><p>以这个中缀表达式为例</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1 + 2 * 3 / 2 - 5</span><br></pre></td></tr></table></figure><p>我们都知道，运算顺序应该是先计算<code>2*3</code>然后在计算<code>6/2</code>，最后计算<code>1+3-5</code>得出结果<code>-1</code>；</p><p>因为<code>* /</code>操作符的优先级高于加减，这里就需要注意这种情况。我们需要用一个栈来存放操作符：</p><ul><li>遇到操作数的时候 <strong>先输出</strong> 到结果表达式中;</li><li>遇到操作符，和<strong>栈顶</strong>进行比较<ul><li>如果栈为空&#x2F;操作符优先级高于栈顶，入栈；</li><li>操作符优先级低于栈顶或和栈顶相同，出栈顶操作符；</li></ul></li><li>最后将栈中的操作符全部出栈，就可以获得后缀表达式；</li></ul><p>用上面这个思路走一遍，即为下面的情况（不知道这样写的大家能不能看明白）</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2023/02/202207181221808.jpg" alt="qq_pic_merged_1658118047047"></p><p>最终得到的结果如下，即需要的后缀表达式。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1 2 3 * 2 / + 5 -</span><br></pre></td></tr></table></figure><p>我们可以用下文提到的代码测试一下这个用例，得出的结果也是<code>-1</code>，正确！</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2023/02/202207181223795.png" alt="image-20220718122342759"></p><p>如果中缀表达式中带括号咋办？</p><ul><li>遇到操作数的时候 <strong>先输出</strong> 到结果表达式中;</li><li>遇到操作符，和<strong>栈顶</strong>进行比较<ul><li>如果栈为空&#x2F;操作符优先级高于栈顶，入栈；</li><li>操作符优先级低于栈顶或和栈顶相同，出栈顶操作符；</li></ul></li><li>如果是左括号<code>(</code>，正常入栈；</li><li>遇到右括号<code>)</code>，出栈内所有操作符，直到遇到对应左括号，注意，最终的输出后缀表达式中不需要添加左括号；</li><li>最后将栈中的操作符全部出栈，就可以获得后缀表达式；</li></ul><p>简单理解，左括号的优先级低于其他运算符，右括号的优先级高于其他运算符，就可以用前文提到的基本办法来处理带括号的中缀表达式了。</p><h2 id="2-2-中缀转前缀"><a href="#2-2-中缀转前缀" class="headerlink" title="2.2. 中缀转前缀"></a>2.2. 中缀转前缀</h2><p>首先设定一个操作符栈，<strong>从右到左</strong>顺序扫描整个中缀表达式</p><ul><li>如果是操作数，则直接归入<strong>最终表达式</strong>；</li><li>如果是操作符，则检测器是否是右括号，如果是右括号，则直接将其入栈；</li><li>如果是左括号，则将栈中的操作符依次弹栈，归入<strong>最终表达式</strong>，直至遇到右括号，将右括号弹栈，处理结束；</li><li>如果是其他操作符，则检测栈顶操作符的优先级与当前操作符的优先级关系，如果栈顶操作符优先级<strong>大于</strong>当前操作符的优先级，则弹栈，并归入<strong>最终表达式</strong>，直至栈顶操作符优先级小于等于当前操作符优先级，这时将当前操作符压栈。</li><li>当扫描完毕整个中缀表达式后，检测操作符栈是否为空，如果不为空，则依次将栈中操作符弹栈，归入<strong>最终表达式</strong>。</li><li>最后，将得出的<strong>最终表达式</strong>进行<strong>逆置</strong>，就得到中缀表达式对应的前缀表达式。</li></ul><p>以下面这个中缀表达式为例</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1 + 2 * 3 / 2 - 5</span><br></pre></td></tr></table></figure><p>使用上述步骤的栈操作示意图如下</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/03/01826c0b1143896defbabb4294308a3d.png" alt="image-20240313145529611"></p><p>得到的前缀表达式如下，符合前文使用加括号法得到的结果！</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- + 1 / * 2 3 2 5</span><br></pre></td></tr></table></figure><h2 id="2-3-后缀转中缀"><a href="#2-3-后缀转中缀" class="headerlink" title="2.3. 后缀转中缀"></a>2.3. 后缀转中缀</h2><p>后缀转中缀会简单一些，因为不需要考虑括号优先级的问题。参考 <a href="https://segmentfault.com/q/1010000004546083">知否</a>;</p><p>从左往右遍历后缀表达式：</p><ul><li>如果是操作数，入栈；</li><li>如果是运算符（设符号为#），从栈顶取两个元素a和b，注意<strong>先取出来的是右操作数</strong>，将<code>&quot;( b # a )&quot;</code>这个字符串入栈。这里加括号是保证运算顺序。</li></ul><p>最终栈顶的字符串就是我们需要的前缀表达式</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1 2 3 * 2 / + 5 - </span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/03/dfd35b63103a70940878c8534ecc05a0.png" alt="image-20240313154453407"></p><p>得到的中缀表达式符合预期！虽然会有多余的括号，但运算顺序是没有问题的。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1 + 2 * 3 / 2 - 5</span><br></pre></td></tr></table></figure><p>C++代码如下，设输入的后缀表达式是有效的。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function">string <span class="title">postfix_to_infix</span><span class="params">(vector&lt;string&gt; expr)</span> </span>&#123;</span><br><span class="line">    stack&lt;string&gt; s;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; expr.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">        <span class="comment">// a number</span></span><br><span class="line">        <span class="keyword">if</span> (!expr[i].<span class="built_in">empty</span>() &amp;&amp; expr[i][<span class="number">0</span>] &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; expr[i][<span class="number">0</span>] &lt;= <span class="string">&#x27;9&#x27;</span>) &#123;</span><br><span class="line">            s.<span class="built_in">push</span>(expr[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// an operator</span></span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            string second = s.<span class="built_in">top</span>(); s.<span class="built_in">pop</span>();</span><br><span class="line">            string first = s.<span class="built_in">top</span>(); s.<span class="built_in">pop</span>();</span><br><span class="line">            s.<span class="built_in">push</span>(<span class="string">&quot;(&quot;</span> + first + expr[i] + second + <span class="string">&quot;)&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> s.<span class="built_in">top</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    vector&lt;string&gt; expr = &#123;<span class="string">&quot;3&quot;</span>, <span class="string">&quot;2&quot;</span>, <span class="string">&quot;5&quot;</span>, <span class="string">&quot;-&quot;</span>, <span class="string">&quot;6&quot;</span>, <span class="string">&quot;*&quot;</span>, <span class="string">&quot;3&quot;</span>, <span class="string">&quot;/&quot;</span>, <span class="string">&quot;+&quot;</span>&#125;;</span><br><span class="line">    <span class="comment">// output: (3+(((2-5)*6)/3))</span></span><br><span class="line">    cout &lt;&lt; <span class="built_in">postfix_to_infix</span>(expr) &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-4-前缀转后缀"><a href="#2-4-前缀转后缀" class="headerlink" title="2.4. 前缀转后缀"></a>2.4. 前缀转后缀</h2><p>依照上述后缀转前缀的思路，前缀转后缀的操作如下</p><p>从<strong>右往左</strong>遍历后缀表达式：</p><ul><li>如果是操作数，入栈；</li><li>如果是运算符（设符号为#），从栈顶取两个元素a和b，注意先取出来的是左操作数，将<code>&quot;( a # b )&quot;</code>这个字符串入栈。这里加括号是保证运算顺序。</li></ul><p>这样运算就能得到中缀表达式。这里就不做演示了。</p><h2 id="2-5-前缀-x2F-后缀转换？"><a href="#2-5-前缀-x2F-后缀转换？" class="headerlink" title="2.5. 前缀&#x2F;后缀转换？"></a>2.5. 前缀&#x2F;后缀转换？</h2><p>因为已经学会了前缀转中缀，后缀转中缀的思路，前后缀的转换用中缀做个跳板就行了。面试的时候能说出思路来就够。</p><h1 id="3-逆波兰表达式求值"><a href="#3-逆波兰表达式求值" class="headerlink" title="3. 逆波兰表达式求值"></a>3. 逆波兰表达式求值</h1><h2 id="3-1-题目来源"><a href="#3-1-题目来源" class="headerlink" title="3.1. 题目来源"></a>3.1. 题目来源</h2><p>leetcode：<a href="https://leetcode.cn/problems/evaluate-reverse-polish-notation/">150. 逆波兰表达式求值</a></p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2023/02/202207181200929.png" alt="image-20220718120022828"></p><h2 id="3-2-思路"><a href="#3-2-思路" class="headerlink" title="3.2. 思路"></a>3.2. 思路</h2><p>逆波兰表达式又称为后缀表达式</p><ul><li>中缀 <code>1 + 2 * 3</code>；</li><li>后缀 <code>1 2 3 + *</code>；</li></ul><p>题目所给的参数是后缀表达式，其操作的思路如下：</p><ul><li>从左往右遍历，遇到操作数，入栈</li><li>遇到运算符，取栈顶两个连续数据进行计算（第二个取出来的是左操作数），再将计算结果入栈</li></ul><p>看起来不难，是因为这道题已经是简化后的版本，<del>其所给后缀表达式中没有出现括号这种特殊优先级的操作</del>。新注：这里理解有误，后缀&#x2F;前缀表达式本来就是从中缀按优先级转换过来的，它们是不会包含括号的！</p><h2 id="3-3-完整代码"><a href="#3-3-完整代码" class="headerlink" title="3.3. 完整代码"></a>3.3. 完整代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//https://leetcode.cn/problems/evaluate-reverse-polish-notation/submissions/</span></span><br><span class="line"><span class="comment">//150逆波兰表达式</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">evalRPN</span><span class="params">(vector&lt;string&gt;&amp; tokens)</span> </span>&#123;</span><br><span class="line">        stack&lt;<span class="type">int</span>&gt; s;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; ch : tokens)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(ch==<span class="string">&quot;+&quot;</span>||ch==<span class="string">&quot;-&quot;</span>||ch==<span class="string">&quot;*&quot;</span>||ch==<span class="string">&quot;/&quot;</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="type">int</span> right=s.<span class="built_in">top</span>();</span><br><span class="line">                s.<span class="built_in">pop</span>();</span><br><span class="line">                <span class="type">int</span> left=s.<span class="built_in">top</span>();</span><br><span class="line">                s.<span class="built_in">pop</span>();</span><br><span class="line">                <span class="keyword">switch</span>(ch[<span class="number">0</span>])</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">case</span> <span class="string">&#x27;+&#x27;</span>:</span><br><span class="line">                        s.<span class="built_in">push</span>(left+right);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">case</span> <span class="string">&#x27;-&#x27;</span>:</span><br><span class="line">                        s.<span class="built_in">push</span>(left-right);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">case</span> <span class="string">&#x27;*&#x27;</span>:</span><br><span class="line">                        s.<span class="built_in">push</span>(left*right);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">case</span> <span class="string">&#x27;/&#x27;</span>:</span><br><span class="line">                        s.<span class="built_in">push</span>(left/right);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">default</span>:</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="comment">// 注意，题目给的vector中是字符串，需要转数字</span></span><br><span class="line">                s.<span class="built_in">push</span>(<span class="built_in">stoi</span>(ch));</span><br><span class="line">            &#125;   </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s.<span class="built_in">top</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2023/02/202207181208425.png" alt="Snipaste_2022-07-18_11-20-17"></p><p>可以使用lambda表达式来改造这个oj的代码</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">evalRPN</span><span class="params">(vector&lt;string&gt;&amp; tokens)</span> </span>&#123;</span><br><span class="line">        stack&lt;<span class="type">int</span>&gt; s;</span><br><span class="line">        map&lt;string,function&lt;<span class="type">int</span>(<span class="type">int</span>,<span class="type">int</span>)&gt;&gt; FuncMap = &#123;</span><br><span class="line">            &#123;<span class="string">&quot;+&quot;</span>,[](<span class="type">int</span> x,<span class="type">int</span> y)&#123;<span class="keyword">return</span> x+y;&#125;&#125;,</span><br><span class="line">            &#123;<span class="string">&quot;-&quot;</span>,[](<span class="type">int</span> x,<span class="type">int</span> y)&#123;<span class="keyword">return</span> x-y;&#125;&#125;,</span><br><span class="line">            &#123;<span class="string">&quot;*&quot;</span>,[](<span class="type">int</span> x,<span class="type">int</span> y)&#123;<span class="keyword">return</span> x*y;&#125;&#125;,</span><br><span class="line">            &#123;<span class="string">&quot;/&quot;</span>,[](<span class="type">int</span> x,<span class="type">int</span> y)&#123;<span class="keyword">return</span> x/y;&#125;&#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; ch : tokens)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(ch==<span class="string">&quot;+&quot;</span>||ch==<span class="string">&quot;-&quot;</span>||ch==<span class="string">&quot;*&quot;</span>||ch==<span class="string">&quot;/&quot;</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="type">int</span> right=s.<span class="built_in">top</span>();</span><br><span class="line">                s.<span class="built_in">pop</span>();</span><br><span class="line">                <span class="type">int</span> left=s.<span class="built_in">top</span>();</span><br><span class="line">                s.<span class="built_in">pop</span>();</span><br><span class="line">                <span class="type">int</span> ret = FuncMap[ch](left,right);</span><br><span class="line">                s.<span class="built_in">push</span>(ret);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                s.<span class="built_in">push</span>(<span class="built_in">stoi</span>(ch));</span><br><span class="line">            &#125;   </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s.<span class="built_in">top</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="4-前缀表达式求值"><a href="#4-前缀表达式求值" class="headerlink" title="4. 前缀表达式求值"></a>4. 前缀表达式求值</h1><p>前缀表达式的计算方法和后缀基本一致。</p><ul><li>从右往左遍历，遇到操作数，入栈；</li><li>遇到操作符，从栈顶取出两个数字进行计算，第一个取出来的数字是左操作数。计算后重新入栈。</li></ul><p>还是以下面的前缀表达式为例</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- + 1 / * 2 3 2 5</span><br></pre></td></tr></table></figure><p>从右往左遍历入栈</p><ul><li>第一波操作后，栈中包括<code>2,3,2,5</code>；</li><li>随后遇到第一个操作符<code>*</code>，从栈取出2和3进行计算，得到6，重新入栈<code>6,2,5</code>；</li><li>遇到第二个操作符<code>/</code>，从栈取出6和2进行计算，得到3，重新入栈<code>3,5</code>；</li><li>操作数1入栈，<code>1,3,5</code>；</li><li>操作符<code>+</code>，从栈中取出1和3进行计算，得到4，入栈<code>4,5</code>；</li><li>操作符<code>-</code>，从栈中取出4和5进行计算，得到最终结果<code>-1</code>；</li></ul><p>这个前缀表达式对应的中缀如下，它的计算结果也是<code>-1</code>，处理正确！</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1 + 2 * 3 / 2 - 5 = -1</span><br></pre></td></tr></table></figure><p>和后缀表达式相比，前缀表达式只有遍历顺序不同，以及从栈取数据时左右操作数位置不同，所以只需要将遍历vector的操作改成<strong>反向迭代器</strong>就可以了。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 计算前缀表达式</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">evalPN</span><span class="params">(vector&lt;string&gt;&amp; tokens)</span> </span>&#123;</span><br><span class="line">    stack&lt;<span class="type">int</span>&gt; s;</span><br><span class="line">    map&lt;string,function&lt;<span class="type">int</span>(<span class="type">int</span>,<span class="type">int</span>)&gt;&gt; FuncMap = &#123;</span><br><span class="line">        &#123;<span class="string">&quot;+&quot;</span>,[](<span class="type">int</span> x,<span class="type">int</span> y)&#123;<span class="keyword">return</span> x+y;&#125;&#125;,</span><br><span class="line">        &#123;<span class="string">&quot;-&quot;</span>,[](<span class="type">int</span> x,<span class="type">int</span> y)&#123;<span class="keyword">return</span> x-y;&#125;&#125;,</span><br><span class="line">        &#123;<span class="string">&quot;*&quot;</span>,[](<span class="type">int</span> x,<span class="type">int</span> y)&#123;<span class="keyword">return</span> x*y;&#125;&#125;,</span><br><span class="line">        &#123;<span class="string">&quot;/&quot;</span>,[](<span class="type">int</span> x,<span class="type">int</span> y)&#123;<span class="keyword">return</span> x/y;&#125;&#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">auto</span> riter = tokens.<span class="built_in">rbegin</span>();</span><br><span class="line">    <span class="keyword">for</span>(;riter != tokens.<span class="built_in">rend</span>();riter++)</span><br><span class="line">    &#123;</span><br><span class="line">        string ch = *riter;</span><br><span class="line">        <span class="keyword">if</span>(ch==<span class="string">&quot;+&quot;</span>||ch==<span class="string">&quot;-&quot;</span>||ch==<span class="string">&quot;*&quot;</span>||ch==<span class="string">&quot;/&quot;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 前缀表达式第一个取出来的是左操作数</span></span><br><span class="line">            <span class="type">int</span> left=s.<span class="built_in">top</span>();</span><br><span class="line">            s.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="type">int</span> right=s.<span class="built_in">top</span>();</span><br><span class="line">            s.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="type">int</span> ret = FuncMap[ch](left,right);</span><br><span class="line">            s.<span class="built_in">push</span>(ret);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            s.<span class="built_in">push</span>(<span class="built_in">stoi</span>(ch));</span><br><span class="line">        &#125;   </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> s.<span class="built_in">top</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用表达式进行测试，得到正确输出</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vector&lt;string&gt; v = &#123;<span class="string">&quot;-&quot;</span>,<span class="string">&quot;+&quot;</span>,<span class="string">&quot;1&quot;</span>,<span class="string">&quot;/&quot;</span>,<span class="string">&quot;*&quot;</span>,<span class="string">&quot;2&quot;</span>,<span class="string">&quot;3&quot;</span>,<span class="string">&quot;2&quot;</span> ,<span class="string">&quot;5&quot;</span>&#125;;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">evalPN</span>(v) &lt;&lt; <span class="string">&quot;\n&quot;</span>; <span class="comment">// 输出 -1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="5-The-end"><a href="#5-The-end" class="headerlink" title="5. The end"></a>5. The end</h1><p>网易雷火的面试考到了前缀表达式求值，故此更新本文</p>]]></content>
    
    
    <summary type="html">leetcode150题逆波兰表达式求值，以及前缀中缀后缀的解释和相互转换</summary>
    
    
    
    <category term="编程学习" scheme="https://blog.musnow.top/categories/%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="把题目都给刷干净" scheme="https://blog.musnow.top/categories/%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0/%E6%8A%8A%E9%A2%98%E7%9B%AE%E9%83%BD%E7%BB%99%E5%88%B7%E5%B9%B2%E5%87%80/"/>
    
    
    <category term="OJ刷题" scheme="https://blog.musnow.top/tags/OJ%E5%88%B7%E9%A2%98/"/>
    
    <category term="Cpp" scheme="https://blog.musnow.top/tags/Cpp/"/>
    
    <category term="leetcode" scheme="https://blog.musnow.top/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>【算法】滑动窗口思想解决数组OJ题目</title>
    <link href="https://blog.musnow.top/posts/19524588/"/>
    <id>https://blog.musnow.top/posts/19524588/</id>
    <published>2024-03-12T04:29:19.000Z</published>
    <updated>2024-03-13T02:35:11.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="基本思路"><a href="#基本思路" class="headerlink" title="基本思路"></a>基本思路</h1><p>滑动窗口在很多地方都有实际使用，比如TCP的发送缓冲区就使用了这个思想来维护。</p><p>对于数组相关的算法OJ题来说，滑动窗口思路主要是基于双指针来实现的，一个作为窗口的左边界，一个作为窗口的右边界，并根据题目的条件来移动左右边界。</p><h1 id="题目1-209-长度最小的子数组"><a href="#题目1-209-长度最小的子数组" class="headerlink" title="题目1-209-长度最小的子数组"></a>题目1-209-长度最小的子数组</h1><p>第一题是leetcode的209，<a href="https://leetcode.cn/problems/minimum-size-subarray-sum/description/">209. 长度最小的子数组 - 力扣（LeetCode）</a>，这也是滑动窗口的一个基础且经典的题目。</p><h2 id="题干"><a href="#题干" class="headerlink" title="题干"></a>题干</h2><p>给定一个含有 n 个正整数的数组和一个正整数 target 。</p><p>找出该数组中满足其总和大于等于 target 的长度最小的 <strong>连续</strong><br>子数组 <code>[numsl, numsl+1, ..., numsr-1, numsr]</code> ，并返回其长度。如果不存在符合条件的子数组，返回 0 。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">示例 1：</span><br><span class="line">输入：target = 7, nums = [2,3,1,2,4,3]</span><br><span class="line">输出：2</span><br><span class="line">解释：子数组 [4,3] 是该条件下的长度最小的子数组。</span><br><span class="line"></span><br><span class="line">示例 2：</span><br><span class="line">输入：target = 4, nums = [1,4,4]</span><br><span class="line">输出：1</span><br><span class="line"></span><br><span class="line">示例 3：</span><br><span class="line">输入：target = 11, nums = [1,1,1,1,1,1,1,1]</span><br><span class="line">输出：0</span><br></pre></td></tr></table></figure><p>进阶：如果你已经实现 <code>O(n)</code> 时间复杂度的解法, 请尝试设计一个 <code>O(n log(n))</code> 时间复杂度的解法。</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>这道题要求的是数组中加起来大于等于target的最小连续子数组。最简单的办法是暴力两次遍历来计算每一个子数组组合的和，再与目标target对比，但这样的时间复杂度是<code>O(N^2)</code>。</p><p>使用滑动窗口来解决这道题才是对的，思路如下。</p><ol><li>left和right作为滑动窗口的左右边界，以right作为for循环的自增；</li><li>right++遍历一个数（滑动窗口扩张），加入到sum中；</li><li>如果sum大于等于target，记录<code>right-left+1</code>为当前子数组长度，开始操作left；</li><li>left++遍历一个数（滑动窗口缩限），将其从sum中删除；</li><li>再次判断sum是否大于等于target，如果大于，继续执行第三部和第四步；</li><li>sum不大于target了，继续for循环操作right，移动右边边界；</li><li>right大于等于下标，循环结束。</li></ol><p>最终得到的len就是最短的子数组。</p><p>注意，操作left的时候要用while循环，而不是用if来操作，因为最终可能会遇到，right固定在最后一位，但left还能继续往前走的情况，如果使用if，那么每个循环中left都最多只能走一次，会漏掉情况。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>对于这类问题，可以用打印下标的方式进行调试。最终测试的时候记得把打印注释掉，因为它们很耗时，可能会导致你的答案超时。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">minSubArrayLen</span><span class="params">(<span class="type">int</span> target, vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> left = <span class="number">0</span>,right=<span class="number">0</span>; <span class="comment">// 滑动窗口</span></span><br><span class="line">        <span class="type">int</span> minRange = INT32_MAX; <span class="comment">// 因为需要获取最小值，所以要用一个最大值来比较</span></span><br><span class="line">        <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(right =<span class="number">0</span>;right&lt;nums.<span class="built_in">size</span>();right++)</span><br><span class="line">        &#123;</span><br><span class="line">            sum += nums[right];</span><br><span class="line">            <span class="keyword">while</span>(sum &gt;= target) <span class="comment">// 这里必须要用while，需要考虑right是最后一个但left还可以继续走的情况</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//cout &lt;&lt; &quot;fix: &quot; &lt;&lt; left &lt;&lt; &quot; - &quot; &lt;&lt; right &lt;&lt; &quot; sum:&quot; &lt;&lt; sum &lt;&lt; &quot;\n&quot;;</span></span><br><span class="line">                <span class="type">int</span> curDiff = right - left + <span class="number">1</span>; <span class="comment">// 当前长度</span></span><br><span class="line">                minRange = <span class="built_in">min</span>(minRange,curDiff);</span><br><span class="line">                sum -= nums[left];</span><br><span class="line">                left ++;<span class="comment">// 左侧缩限</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//cout &lt;&lt; &quot;all: &quot; &lt;&lt; left &lt;&lt; &quot; - &quot; &lt;&lt; right &lt;&lt; &quot; sum:&quot; &lt;&lt; sum &lt;&lt; &quot;\n&quot;;</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果还是最大值，则返回0</span></span><br><span class="line">        <span class="keyword">return</span> minRange == INT32_MAX ? <span class="number">0</span> : minRange;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>说明一下，leetcode&#x2F;牛客网上的代码击败人数是没有参考意义的，这个时间和你的网络状况也有关系。我的题解博客中贴出代码通过截图，是想告诉未来的读者，这个代码在我测试的时候是通过的，以免未来leetcode测试用例变化无法通过时产生误解。</p><blockquote><p>好不容易搜到一个题解，结果它贴了无法通过的代码，谁看了不气？🤣</p></blockquote><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/03/434871f83a804f052d952c3a2e5f9c89.png" alt="image.png"></p><h1 id="题目2-904-水果成篮"><a href="#题目2-904-水果成篮" class="headerlink" title="题目2-904-水果成篮"></a>题目2-904-水果成篮</h1><p><a href="https://leetcode.cn/problems/fruit-into-baskets/submissions/510977160/">904.水果成篮 - 力扣（LeetCode）</a></p><h2 id="题干-1"><a href="#题干-1" class="headerlink" title="题干"></a>题干</h2><p>你正在探访一家农场，农场从左到右种植了一排果树。这些树用一个整数数组 fruits 表示，其中 <code>fruits[i]</code> 是第 i 棵树上的水果 <strong>种类</strong> 。</p><p>你想要尽可能多地收集水果。然而，农场的主人设定了一些严格的规矩，你必须按照要求采摘水果：</p><ol><li>你只有 <strong>两个</strong> 篮子，并且每个篮子只能装 <strong>单一类型</strong> 的水果。每个篮子能够装的水果总量没有限制。</li><li>你可以选择任意一棵树开始采摘，你必须从 <strong>每棵</strong> 树（包括开始采摘的树）上 <strong>恰好摘一个水果</strong> 。采摘的水果应当符合篮子中的水果类型。每采摘一次，你将会向右移动到下一棵树，并继续采摘。</li><li>一旦你走到某棵树前，但水果不符合篮子的水果类型，那么就必须停止采摘。</li></ol><p>给你一个整数数组 fruits ，返回你可以收集的水果的 <strong>最大</strong> 数目。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">示例 1：</span><br><span class="line">输入：fruits = [1,2,1]</span><br><span class="line">输出：3</span><br><span class="line">解释：可以采摘全部 3 棵树。</span><br><span class="line"></span><br><span class="line">示例 2：</span><br><span class="line">输入：fruits = [0,1,2,2]</span><br><span class="line">输出：3</span><br><span class="line">解释：可以采摘 [1,2,2] 这三棵树。</span><br><span class="line">如果从第一棵树开始采摘，则只能采摘 [0,1] 这两棵树。</span><br><span class="line"></span><br><span class="line">示例 3：</span><br><span class="line">输入：fruits = [1,2,3,2,2]</span><br><span class="line">输出：4</span><br><span class="line">解释：可以采摘 [2,3,2,2] 这四棵树。</span><br><span class="line">如果从第一棵树开始采摘，则只能采摘 [1,2] 这两棵树。</span><br><span class="line"></span><br><span class="line">示例 4：</span><br><span class="line">输入：fruits = [3,3,3,1,2,1,1,2,3,3,4]</span><br><span class="line">输出：5</span><br><span class="line">解释：可以采摘 [1,2,1,1,2] 这五棵树。</span><br></pre></td></tr></table></figure><h2 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h2><p>刚开始我都没有读懂这个题目，注意，输入参数中的数组并非每棵树上有几个种类的水果，而是每棵树上的水果是<strong>第几类</strong>。比如<code>fruits[0] = 1</code>代表第0棵树上的水果是种类1，<code>fruits[1] = 2</code>代表第1棵树上的水果是种类2。</p><blockquote><p>我刚开始错误的理解为2代表这棵树上有两种水果，如果这样理解这道题就没法写了……</p></blockquote><p>你的篮子里面一次只能装两个种类的水果，这样这道题就转变成了，给出的数组中只包含两个相同数字的最长子数组。</p><p>比如数组 <code>[3,3,3,1,2,1,1,2,3,3,4]</code>，最长只包含两个数字的子数组是 <code>[1,2,1,1,2]</code>；数组<code>[1,2,3,2,2]</code>最长只包含两个数字的子数组是<code>[3,2,2]</code>；</p><p>同样是用滑动窗口来解题，使用left&#x2F;right左右边界，right作为while循环条件，并设置一个数字种类计数器fruitsCount、数字个数计数器sizeCount和一个set来保存当前的两个数字。另外还需要一个maxSizeCount来保存最长的数字个数，作为题目返回值。</p><ol><li>right遍历，当当前数字不存在set中，且count小于2时，将其加入到set中，并将fruitsCount++，长度sizeCount++，使用sizeCount对比更新maxSizeCount；</li><li>当当前数字存在于set中，长度sizeCount++，使用sizeCount对比更新maxSizeCount；</li><li>当当前数字不存在于set中，且fruitsCount已经为2，说明当前走到了第三个数字的位置，重置set和fruitsCount，使用sizeCount对比更新maxSizeCount后，将sizeCount重置为0；</li><li>left++（滑动窗口左侧缩限），一直加加到和<strong>当前数字不同</strong>的位置（比如left当前处于<code>3,3,3,1,2</code>的3的位置，那么就需要移动到1的位置，过滤重复数据）；</li><li>right重置到left的位置，继续执行上述步骤，直到right走完数组。</li></ol><p>注意，每次sizeCount++之后，都需要和maxSizeCount对比并更新。否则如果给出的数组本来就只有两种数字（比如<code>[1,2,1]</code>这整个数组本身就是答案）的情况，maxSizeCount会没有正常更新。</p><h2 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h2><p>因为本题目的set并不需要排序，所以使用哈希set会优于红黑树的set。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">totalFruit</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; fruits)</span> </span>&#123;</span><br><span class="line">        unordered_set&lt;<span class="type">int</span>&gt; fruitsSet;</span><br><span class="line">        <span class="type">int</span> fruitsCount = <span class="number">0</span>; <span class="comment">// 种类数量</span></span><br><span class="line">        <span class="type">int</span> curCount = <span class="number">0</span>; <span class="comment">// 当前水果计数</span></span><br><span class="line">        <span class="type">int</span> retCount = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> left = <span class="number">0</span>,right = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(right &lt; fruits.<span class="built_in">size</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 水果不在里面，且还没有2个</span></span><br><span class="line">            <span class="keyword">if</span>(fruitsCount &lt; <span class="number">2</span> &amp;&amp; fruitsSet.<span class="built_in">count</span>(fruits[right]) == <span class="number">0</span>)&#123;</span><br><span class="line">                fruitsCount++; <span class="comment">// 种类数量加一</span></span><br><span class="line">                fruitsSet.<span class="built_in">insert</span>(fruits[right]);</span><br><span class="line">                curCount++; <span class="comment">// 水果个数加一</span></span><br><span class="line">                right++;</span><br><span class="line">                retCount = <span class="built_in">max</span>(curCount,retCount);</span><br><span class="line">                <span class="comment">// cout &lt;&lt; right &lt;&lt; &quot; - &quot; &lt;&lt; fruits[right] &lt;&lt; &quot;\n&quot;;</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 水果在里面</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(fruitsCount &lt;= <span class="number">2</span> &amp;&amp; fruitsSet.<span class="built_in">count</span>(fruits[right]) != <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                right++;</span><br><span class="line">                curCount++;</span><br><span class="line">                retCount = <span class="built_in">max</span>(curCount,retCount);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 水果不在里面，且已经有两个了</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(fruitsCount &gt;= <span class="number">2</span> &amp;&amp; fruitsSet.<span class="built_in">count</span>(fruits[right]) == <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                retCount = <span class="built_in">max</span>(curCount,retCount);</span><br><span class="line">                fruitsSet.<span class="built_in">clear</span>(); <span class="comment">// 清空</span></span><br><span class="line">                curCount = <span class="number">0</span>;</span><br><span class="line">                fruitsCount = <span class="number">0</span>;</span><br><span class="line">                <span class="comment">// 找下一个和left当前不同的水果</span></span><br><span class="line">                <span class="keyword">while</span>(left &lt; fruits.<span class="built_in">size</span>() &amp;&amp; fruits[left+<span class="number">1</span>] == fruits[left])&#123;</span><br><span class="line">                    left++;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 还需要再走一步，才是和刚刚不一样的水果</span></span><br><span class="line">                left++;</span><br><span class="line">                right = left; <span class="comment">// 重新开始新一轮计数</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> retCount;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/03/e71c0534a185be79be2606779f304890.png" alt="image.png"></p><h1 id="题目3-76-最小覆盖子串"><a href="#题目3-76-最小覆盖子串" class="headerlink" title="题目3-76-最小覆盖子串"></a>题目3-76-最小覆盖子串</h1><p><a href="https://leetcode.cn/problems/minimum-window-substring/description/">76. 最小覆盖子串 - 力扣（LeetCode）</a></p><h2 id="题干-2"><a href="#题干-2" class="headerlink" title="题干"></a>题干</h2><p>给你一个字符串 s 、一个字符串 t 。返回 s 中涵盖 t 所有字符的最小子串。如果 s 中不存在涵盖 t 所有字符的子串，则返回空字符串 <code>&quot;&quot;</code> 。 </p><p>注意：</p><ul><li>对于 t 中重复字符，我们寻找的子字符串中该字符数量必须不少于 t 中该字符数量。</li><li>如果 s 中存在这样的子串，我们保证它是唯一的答案。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">示例 1：</span><br><span class="line">输入：s = &quot;ADOBECODEBANC&quot;, t = &quot;ABC&quot;</span><br><span class="line">输出：&quot;BANC&quot;</span><br><span class="line">解释：最小覆盖子串 &quot;BANC&quot; 包含来自字符串 t 的 &#x27;A&#x27;、&#x27;B&#x27; 和 &#x27;C&#x27;。</span><br><span class="line"></span><br><span class="line">示例 2：</span><br><span class="line">输入：s = &quot;a&quot;, t = &quot;a&quot;</span><br><span class="line">输出：&quot;a&quot;</span><br><span class="line">解释：整个字符串 s 是最小覆盖子串。</span><br><span class="line"></span><br><span class="line">示例 3:</span><br><span class="line">输入: s = &quot;a&quot;, t = &quot;aa&quot;</span><br><span class="line">输出: &quot;&quot;</span><br><span class="line">解释: t 中两个字符 &#x27;a&#x27; 均应包含在 s 的子串中，</span><br><span class="line">因此没有符合条件的子字符串，返回空字符串。</span><br></pre></td></tr></table></figure><p>s 和 t 由英文字母组成，且可能会重复（未规定大小写）</p><h2 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h2><p>同样是使用滑动窗口，但这一次的缩限需要进行判断。</p><p>首先要明白题目给出的条件</p><ul><li>当t字符串大于s字符串的时候，直接返回空，因为s的子串无法包含t；</li><li>t中的字母可能是大写也可能是小写，而且t中的某个字母可能会重复，所以需要一个map来保存字符及其个数；</li><li>题目要求返回的是子串，所以需要记录子串在s内的起始下标及其长度；</li></ul><p>这里需要用到两个哈希map，一个tMaps用于存放t字符串中的所有字符和个数，另外一个curMaps用来存放当前滑动窗口内包含的t字符串内字符的个数。</p><ol><li>right++，当遇到t字符串内的字符，则将curMaps中对应字符数量加一；</li><li>检查curMaps中的字符个数是否都已经大于tMaps中的字符数量，且没有缺少字符；</li><li>如果符合条件，记录当前的left（作为子串起始位置）和长度len，随后left++开始缩限，并将curMaps中对应字符减一，直到curMaps不符合条件为止；</li><li>right继续加加，重复上述步骤，直到right越界。</li></ol><p>注意，这里建议将用于更新的子串起始地址begin初始化为非法下标<code>-1</code>，并在return的时候进行判断，这样能知道s字符串中是否存在符合条件的子串。如果begin在循环结束后还是<code>-1</code>，则代表s内没有符合条件的子串，此时返回空字符串。</p><h2 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 判断当前map中是否已经包含目标map中需要的所有字符</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">statusCheck</span><span class="params">(<span class="type">const</span> unordered_map&lt;<span class="type">char</span>,<span class="type">int</span>&gt;&amp; tMaps,unordered_map&lt;<span class="type">char</span>,<span class="type">int</span>&gt;&amp; curMaps)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span>&amp;e:tMaps)&#123;</span><br><span class="line">            <span class="comment">// 这里不能用不等于判断，因为curMaps中的计数器大于的时候也是符合条件的</span></span><br><span class="line">            <span class="keyword">if</span>(curMaps.<span class="built_in">count</span>(e.first)!=<span class="number">0</span> &amp;&amp; curMaps[e.first] &lt; e.second)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (curMaps.<span class="built_in">count</span>(e.first)==<span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">string <span class="title">minWindow</span><span class="params">(string s, string t)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(t.<span class="built_in">size</span>() &gt; s.<span class="built_in">size</span>())&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> left = <span class="number">0</span>,right = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> begin = <span class="number">-1</span>, end = <span class="number">-1</span>, len = INT32_MAX; <span class="comment">// 最终用于返回结果的下标区间</span></span><br><span class="line">        <span class="comment">// 记录t中每个字符出现的次数</span></span><br><span class="line">        unordered_map&lt;<span class="type">char</span>,<span class="type">int</span>&gt; tMaps;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span>&amp;e:t)&#123;</span><br><span class="line">            tMaps[e]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 当前出现的tmap中的字符的数量</span></span><br><span class="line">        unordered_map&lt;<span class="type">char</span>,<span class="type">int</span>&gt; curMaps;</span><br><span class="line">        <span class="keyword">while</span>(right &lt; s.<span class="built_in">size</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 如果目标map里面有，则在当前map里面将数量加一</span></span><br><span class="line">            <span class="keyword">if</span>(tMaps.<span class="built_in">count</span>(s[right]) !=<span class="number">0</span>)&#123;</span><br><span class="line">                curMaps[s[right]]++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 如果符合条件，则缩限到不能缩限为止</span></span><br><span class="line">            <span class="keyword">while</span>(<span class="built_in">statusCheck</span>(tMaps,curMaps) &amp;&amp; left &lt;=right)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// 如果长度小于当前记录的长度，则更新</span></span><br><span class="line">                <span class="keyword">if</span>(right - left + <span class="number">1</span> &lt; len)</span><br><span class="line">                &#123;</span><br><span class="line">                    len = right - left + <span class="number">1</span>;</span><br><span class="line">                    begin = left;</span><br><span class="line">                    end = right;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 在目标map里面看是否有这个字符串，有则在当前map中将数量减一</span></span><br><span class="line">                <span class="keyword">if</span>(tMaps.<span class="built_in">count</span>(s[left]) !=<span class="number">0</span>)&#123;</span><br><span class="line">                    curMaps[s[left]]--;</span><br><span class="line">                &#125;</span><br><span class="line">                left++;</span><br><span class="line">            &#125;</span><br><span class="line">            right++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果begin没有被更新，则说明不存在</span></span><br><span class="line">        <span class="keyword">return</span> begin == <span class="number">-1</span> ? <span class="string">&quot;&quot;</span> : s.<span class="built_in">substr</span>(begin,len);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/03/f0da87219c6ebd2175cfdba9633791c5.png" alt="image.png"></p><h1 id="The-end"><a href="#The-end" class="headerlink" title="The end"></a>The end</h1><p>滑动窗口方法同时也是双指针法的一个运用，这三道题目都囊括了这个方法，平时记得加以复习。</p>]]></content>
    
    
    <summary type="html">使用“滑动窗口”思想来解决一些数组的OJ题目</summary>
    
    
    
    <category term="编程学习" scheme="https://blog.musnow.top/categories/%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="把题目都给刷干净" scheme="https://blog.musnow.top/categories/%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0/%E6%8A%8A%E9%A2%98%E7%9B%AE%E9%83%BD%E7%BB%99%E5%88%B7%E5%B9%B2%E5%87%80/"/>
    
    
    <category term="算法" scheme="https://blog.musnow.top/tags/%E7%AE%97%E6%B3%95/"/>
    
    <category term="数组" scheme="https://blog.musnow.top/tags/%E6%95%B0%E7%BB%84/"/>
    
    <category term="leetcode" scheme="https://blog.musnow.top/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>【leetcode】16.最接近的三数之和</title>
    <link href="https://blog.musnow.top/posts/4003189051/"/>
    <id>https://blog.musnow.top/posts/4003189051/</id>
    <published>2024-03-10T08:27:23.000Z</published>
    <updated>2024-03-13T01:28:18.000Z</updated>
    
    <content type="html"><![CDATA[<p>这下真的得好好重头开始学算法了，基于《代码随想录》，今天周日的目标是完成<strong>哈希章节</strong>，并复习字符串章节和KMP算法。争取在四月中旬之前学完《代码随想录》里面的算法，欢迎大家监督我！</p><p><a href="https://gitee.com/musnows/LetsOJ">LetsOJ_多人刷题打卡: 这是一个多人OJ打卡仓库</a></p><p>新建了一个leetcode的进度，OJ刷题打卡仓库中的代码也重新归档。</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/03/2eadb6db523d970c34710e334ed2af18.png" alt="image.png"></p><p>注意：在手机上代码块中的下标位置会因为字体原因偏离，请使用电脑查看本博客。</p><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p><a href="https://leetcode.cn/problems/3sum-closest/">16. 最接近的三数之和 - 力扣（LeetCode）</a></p><p>给你一个长度为 n 的整数数组 nums 和 一个目标值 target。请你从 nums 中选出三个整数，使它们的和与 target 最接近。</p><p>返回这三个数的和。</p><p>假定每组输入只存在恰好一个解。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">示例 1：</span><br><span class="line">输入：nums = [-1,2,1,-4], target = 1</span><br><span class="line">输出：2</span><br><span class="line">解释：与 target 最接近的和是 2 (-1 + 2 + 1 = 2) 。</span><br><span class="line"></span><br><span class="line">示例 2：</span><br><span class="line">输入：nums = [0,0,0], target = 1</span><br><span class="line">输出：0</span><br></pre></td></tr></table></figure><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>这道题和15三数之和的思路很相似，15题中要求是三数和为0，这道题要求是和target越接近越好。其实就是在把目标值从0改成target，并将三数和为target改成接近target，中间会多一个记录差距数的操作。</p><p>使用排序+双指针来实现。排序后的数组已经有序，使用双指针的时候方便控制指针移动</p><ul><li>如果和大于target，则右侧指针–；</li><li>如果和小于target，则左侧指针++；</li></ul><p>这里还会涉及到一些优化，虽然题目中没有15题去重的要求，但跳过重复元素也能提高运行效率。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><h3 id="最简单的方法"><a href="#最简单的方法" class="headerlink" title="最简单的方法"></a>最简单的方法</h3><p>最简单的方式即<strong>不做任何去重</strong>，按照思路写代码就行。sum大于或者等于target的时候就让右侧指针减一，小于target的时候让左侧指针加一。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">threeSumClosest</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> retNum = INT_MAX; <span class="comment">// 差距值</span></span><br><span class="line">        <span class="type">int</span> retSum = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(),nums.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i&lt;nums.<span class="built_in">size</span>();i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> left = i+<span class="number">1</span>,right = nums.<span class="built_in">size</span>()<span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">while</span>(left &lt; right)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="type">int</span> sum = nums[i] + nums[left] + nums[right];</span><br><span class="line"><span class="comment">// 更新结果值</span></span><br><span class="line">                <span class="type">int</span> diff = <span class="built_in">abs</span>(target-sum);</span><br><span class="line">                <span class="keyword">if</span>(diff &lt; retNum)</span><br><span class="line">                &#123;</span><br><span class="line">                    retNum = diff;</span><br><span class="line">                    retSum = sum;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span>(sum &gt;= target)&#123;</span><br><span class="line">                    right --;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(sum &lt; target)&#123;</span><br><span class="line">                    left++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> retSum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这样也能通过</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/03/8cdda259da83a2ac2bdc1d2b5cdc8a84.png" alt="image.png"></p><h3 id="下标i去重"><a href="#下标i去重" class="headerlink" title="下标i去重"></a>下标i去重</h3><p>下标i去重的目的是让i不处理刚刚已经处理过的值。注意，和15题18题中的去重都是相同的思路，要先处理完毕某个值再去重。</p><p>如下所示，假设我们需要对<code>-1</code>这个元素去重（不重复处理），应该先正常对第一个<code>-1</code>进行操作，再让i跳过第二个<code>-1</code>走到2的位置进行下一步操作</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-3 -1 -1 2 3 4</span><br><span class="line">    i</span><br></pre></td></tr></table></figure><p>如果先去重，在三数之和中，假设target&#x3D;0，下面的情况就会被忽略。这里i已经走到了第二个<code>-1</code>的位置了，但<code>(-1) + (-1) +2 = 0</code> ，这种符合题意的结果就直接被跳过了。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 先去重的代码，错误！</span></span><br><span class="line"><span class="keyword">if</span>(nums[i] == nums[i+<span class="number">1</span>])</span><br><span class="line"><span class="keyword">continue</span>;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-3 -1 -1 2 3 4</span><br><span class="line">   i l   r</span><br></pre></td></tr></table></figure><p>如果我们不先执行去重，下标分布如下所示，右侧指针不断减，就能匹配上<code>-1 -1 2</code>这个三元组。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-3 -1 -1 2 3 4</span><br><span class="line">    i  l     r</span><br></pre></td></tr></table></figure><p>匹配上了之后再让i跳过第二个<code>-1</code>才是正确的。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 正确的去重代码</span></span><br><span class="line"><span class="keyword">if</span>(i&gt;<span class="number">0</span> &amp;&amp; nums[i] == nums[i<span class="number">-1</span>])<span class="comment">// 跳过刚刚已经处理过的相同值</span></span><br><span class="line"><span class="keyword">continue</span>;</span><br></pre></td></tr></table></figure><p>对于这道题，加上对i的去重后代码如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">threeSumClosest</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> retNum = INT_MAX; <span class="comment">// 差距值</span></span><br><span class="line">        <span class="type">int</span> retSum = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(),nums.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i&lt;nums.<span class="built_in">size</span>();i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 先匹配再去重</span></span><br><span class="line">            <span class="keyword">if</span>(i&gt;<span class="number">0</span> &amp;&amp; nums[i] == nums[i<span class="number">-1</span>])&#123;</span><br><span class="line">                <span class="keyword">continue</span>; </span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="type">int</span> left = i+<span class="number">1</span>,right = nums.<span class="built_in">size</span>()<span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">while</span>(left &lt; right)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="type">int</span> sum = nums[i] + nums[left] + nums[right];</span><br><span class="line">                <span class="comment">// 更新结果值</span></span><br><span class="line">                <span class="type">int</span> diff = <span class="built_in">abs</span>(target-sum);</span><br><span class="line">                <span class="keyword">if</span>(diff &lt; retNum)</span><br><span class="line">                &#123;</span><br><span class="line">                    retNum = diff;</span><br><span class="line">                    retSum = sum;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span>(sum &gt;= target)&#123;</span><br><span class="line">                    right --;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(sum &lt; target)&#123;</span><br><span class="line">                    left++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> retSum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/03/79d0779bb11dc8a284135570167f8402.png" alt="image.png"></p><h3 id="left-x2F-right去重"><a href="#left-x2F-right去重" class="headerlink" title="left&#x2F;right去重"></a>left&#x2F;right去重</h3><p>在15题三数之和的题解中会对left和right进行去重，同样是遵循先匹配再去重的操作。</p><p>假设当前指针位置如下，当前和为<code>5</code>，假设小于target，此时需要移动left指针</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-3 -1 -1 2 2 2 3 4</span><br><span class="line">    i    l       r</span><br></pre></td></tr></table></figure><p>那么left指针移动的时候，可以直接移动到最后一个2的位置，因为对于求和而言它们没有任何区别。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-3 -1 -1 2 2 2 3 4</span><br><span class="line">    i          l r</span><br></pre></td></tr></table></figure><p>代码如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">threeSumClosest</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> retNum = INT_MAX; <span class="comment">// 差距值</span></span><br><span class="line">        <span class="type">int</span> retSum = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(),nums.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i&lt;nums.<span class="built_in">size</span>();i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 先匹配再去重</span></span><br><span class="line">            <span class="keyword">if</span>(i&gt;<span class="number">0</span> &amp;&amp; nums[i] == nums[i<span class="number">-1</span>])&#123;</span><br><span class="line">                <span class="keyword">continue</span>; </span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="type">int</span> left = i+<span class="number">1</span>,right = nums.<span class="built_in">size</span>()<span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">while</span>(left &lt; right)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="type">int</span> sum = nums[i] + nums[left] + nums[right];</span><br><span class="line">                <span class="keyword">if</span>(sum == target)&#123;</span><br><span class="line">                    <span class="keyword">return</span> target;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 更新结果值</span></span><br><span class="line">                <span class="type">int</span> diff = <span class="built_in">abs</span>(target-sum);</span><br><span class="line">                <span class="keyword">if</span>(diff &lt; retNum)</span><br><span class="line">                &#123;</span><br><span class="line">                    retNum = diff;</span><br><span class="line">                    retSum = sum;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span>(sum &gt;= target)&#123;</span><br><span class="line">                    <span class="keyword">while</span>(left&lt;right &amp;&amp; nums[right] == nums[right<span class="number">-1</span>])&#123;</span><br><span class="line">                        right--;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// 必须要再操作一次才是下一个</span></span><br><span class="line">                    right--;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(sum &lt; target)&#123;</span><br><span class="line">                    <span class="keyword">while</span>(left&lt;right &amp;&amp; nums[left] == nums[left+<span class="number">1</span>])&#123;</span><br><span class="line">                        left++;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// 必须要再操作一次才是下一个</span></span><br><span class="line">                    left++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> retSum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/03/9ce082f0e755255f5e368fd805290888.png" alt="image.png"></p><h3 id="遇到target直接返回"><a href="#遇到target直接返回" class="headerlink" title="遇到target直接返回"></a>遇到target直接返回</h3><p>如果三数和已经等于target，可以直接返回，不需要继续执行。</p><h1 id="The-end"><a href="#The-end" class="headerlink" title="The end"></a>The end</h1><p>leetcode和16题类似的有15题&#x2F;18题&#x2F;454题，具体可以参考代码随想录和我的刷题仓库。</p>]]></content>
    
    
    <summary type="html">leetcode 16.最接近的三数之和</summary>
    
    
    
    <category term="编程学习" scheme="https://blog.musnow.top/categories/%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="把题目都给刷干净" scheme="https://blog.musnow.top/categories/%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0/%E6%8A%8A%E9%A2%98%E7%9B%AE%E9%83%BD%E7%BB%99%E5%88%B7%E5%B9%B2%E5%87%80/"/>
    
    
    <category term="算法" scheme="https://blog.musnow.top/tags/%E7%AE%97%E6%B3%95/"/>
    
    <category term="leetcode" scheme="https://blog.musnow.top/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>【leetcode】11.盛水最多的容器</title>
    <link href="https://blog.musnow.top/posts/62868007/"/>
    <id>https://blog.musnow.top/posts/62868007/</id>
    <published>2024-03-09T07:15:46.000Z</published>
    <updated>2024-03-10T08:29:14.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><a href="https://leetcode.cn/problems/container-with-most-water/description/?envType=study-plan-v2&envId=top-100-liked">11. 盛最多水的容器 - 力扣（LeetCode）</a></p><p>给定一个长度为 n 的整数数组 height 。有 n 条垂线，第 i 条线的两个端点是 <code>(i, 0)</code> 和 <code>(i, height[i])</code> 。</p><p>找出其中的两条线，使得它们与 x 轴共同构成的容器可以容纳最多的水。</p><p>返回容器可以储存的最大水量。</p><p>说明：你不能倾斜容器。</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/03/68a275f35ddd873d91e563b3aa409b40.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：[1,8,6,2,5,4,8,3,7]</span><br><span class="line">输出：49 </span><br><span class="line">解释：图中垂直线代表输入数组 [1,8,6,2,5,4,8,3,7]。在此情况下，容器能够容纳水（表示为蓝色部分）的最大值为 49。</span><br></pre></td></tr></table></figure><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>最开始想的是暴力破解，两个for就能遍历出来。但很明显这个思路是会超时的，两个for的时间复杂度是<code>O(N^2)</code>；</p><p>这道题在leetcode的top100中是双指针法里面的，所以要想使用前后两个指针来遍历，可以让时间复杂度降低为<code>O(N)</code>；这也是官方题解中提到的方式。</p><p>首先是前后指针应该移动谁的问题，先列出这个面积的计算公式，两个下标的插值是x轴的长度，然后是两个数组中元素的较小值，作为柱子的长度。假设index1和index2为两个下标，默认情况一个数组头一个数组尾部。</p><p>$$<br> range &#x3D; abs(index1-index2) * min(arr[index1],arr[index2])<br>$$</p><p>假设index1的数组元素（高度）小于index2，那么这个公式就变成了</p><p>$$<br> range &#x3D; abs(index1-index2) * arr[index1]<br>$$</p><p>注意，此时移动index2下标，这个容器的面积还是不会大于这个值，x轴长度减少了，但高度无论怎么变较小者还是<code>arr[index1]</code>；所以需要移动的下标是<strong>二者高度小的那一个</strong>。</p><p>官方题解中有更详细的演示：<a href="https://leetcode.cn/problems/container-with-most-water/solutions/207215/sheng-zui-duo-shui-de-rong-qi-by-leetcode-solution/?envType=study-plan-v2&envId=top-100-liked">盛最多水的容器. - 力扣（LeetCode）</a></p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxArea</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; height)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> maxRet = <span class="number">0</span> ;</span><br><span class="line">        <span class="type">int</span> left = <span class="number">0</span>,right = height.<span class="built_in">size</span>() <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span>(left &lt; right)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> curMin = <span class="built_in">min</span>(height[right],height[left]);</span><br><span class="line">            maxRet = <span class="built_in">max</span>((right-left)*curMin,maxRet);</span><br><span class="line">            <span class="keyword">if</span>(curMin == height[right])&#123;</span><br><span class="line">                right--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                left++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxRet;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/03/620573c4c3b8234fbcc5dcac2eb0ca81.png" alt="image.png"></p>]]></content>
    
    
    <summary type="html">leetcode11题，盛水最多的容器</summary>
    
    
    
    <category term="编程学习" scheme="https://blog.musnow.top/categories/%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="把题目都给刷干净" scheme="https://blog.musnow.top/categories/%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0/%E6%8A%8A%E9%A2%98%E7%9B%AE%E9%83%BD%E7%BB%99%E5%88%B7%E5%B9%B2%E5%87%80/"/>
    
    
    <category term="默认标签" scheme="https://blog.musnow.top/tags/%E9%BB%98%E8%AE%A4%E6%A0%87%E7%AD%BE/"/>
    
  </entry>
  
  <entry>
    <title>【面试】C++三个线程交替打印1到100</title>
    <link href="https://blog.musnow.top/posts/235113945/"/>
    <id>https://blog.musnow.top/posts/235113945/</id>
    <published>2024-03-09T01:31:10.000Z</published>
    <updated>2024-03-09T01:53:30.000Z</updated>
    
    <content type="html"><![CDATA[<p>昨天面了个大厂，自己太傻逼了，<strong>这么简单的一道题目没写出来</strong>。因为我不太熟悉条件变量，拖了很长时间，面试官估计有点失望，后续的八股也没问什么，意料之中的挂了😭。</p><p>还有个题目是LRU，这个倒是临时抱佛脚复习到了，写出来了。</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/03/7421b5d3ff29ccbb72dfb3efd12d70fd.png"></p><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>问题：线程1打印1，线程2打印2，线程3打印3，线程1打印4，线程2打印5，线程3打印6……一直打印到100。</p><p>其实一点都不难，就是我自己平时压根没做过多少线程同步的练习，对于条件变量之类的玩意基本停留在理论和学习时的简单demo层面，一上战场加上紧张就毛都不会了。</p><h2 id="思路1-直接用线程序号做判断"><a href="#思路1-直接用线程序号做判断" class="headerlink" title="思路1-直接用线程序号做判断"></a>思路1-直接用线程序号做判断</h2><p>最简单的一个思路，因为只有三个线程，每个线程打印的数字是有规律的</p><ul><li>线程一打印的数字%3都等于1</li><li>线程二打印的数字%3都等于2</li><li>线程三打印的数字%3都等于0</li></ul><p>所以我们可以直接写一个函数，提供一个线程编号，通过计算判断当前是否是自己需要打印的数字，不是就睡觉。这个方法是最简单的，只需要一个全局变量加一个锁就能实现。</p><p>两个atomic变量，一个用于主线程通知所有线程当前已经初始化完毕，另外一个用于线程通知主线程当前已经执行完毕。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;atomic&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 线程1打印1，线程2打印2，线程3打印3，线程1打印4，线程2打印5.... 打印到100</span></span><br><span class="line">std::atomic&lt;<span class="type">bool</span>&gt; isRun = <span class="literal">false</span>;</span><br><span class="line">std::atomic&lt;<span class="type">bool</span>&gt; isFinished = <span class="literal">false</span>;</span><br><span class="line">std::mutex gMtx;</span><br><span class="line"><span class="type">int</span> count = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">PrintCountFun</span><span class="params">(<span class="type">int</span> no)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(!isRun)</span><br><span class="line">    &#123;</span><br><span class="line">        std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">microseconds</span>(<span class="number">10</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(!isFinished)</span><br><span class="line">    &#123;</span><br><span class="line">        gMtx.<span class="built_in">lock</span>();</span><br><span class="line">        <span class="keyword">if</span>(count &gt; <span class="number">100</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            isFinished = <span class="literal">true</span>;</span><br><span class="line">            gMtx.<span class="built_in">unlock</span>();</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 1号2号线程</span></span><br><span class="line">        <span class="keyword">if</span>(no!=<span class="number">3</span> &amp;&amp; count % <span class="number">3</span> == no)</span><br><span class="line">        &#123;</span><br><span class="line">            std::cout &lt;&lt; no &lt;&lt; <span class="string">&quot; - &quot;</span> &lt;&lt; std::this_thread::<span class="built_in">get_id</span>() &lt;&lt; <span class="string">&quot; - c: &quot;</span> &lt;&lt; count &lt;&lt; std::endl;</span><br><span class="line">            count ++;</span><br><span class="line">            gMtx.<span class="built_in">unlock</span>();</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 3号线程</span></span><br><span class="line">        <span class="keyword">if</span>(no == <span class="number">3</span> &amp;&amp; count % <span class="number">3</span> == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            std::cout &lt;&lt; no &lt;&lt; <span class="string">&quot; - &quot;</span> &lt;&lt; std::this_thread::<span class="built_in">get_id</span>() &lt;&lt; <span class="string">&quot; - c: &quot;</span> &lt;&lt; count &lt;&lt; std::endl;</span><br><span class="line">            count ++;</span><br><span class="line">            gMtx.<span class="built_in">unlock</span>();</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        gMtx.<span class="built_in">unlock</span>();</span><br><span class="line">        std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">microseconds</span>(<span class="number">10</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">std::thread <span class="title">t1</span><span class="params">(PrintCountFun,<span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="function">std::thread <span class="title">t2</span><span class="params">(PrintCountFun,<span class="number">2</span>)</span></span>;</span><br><span class="line">    <span class="function">std::thread <span class="title">t3</span><span class="params">(PrintCountFun,<span class="number">3</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    t1.<span class="built_in">detach</span>();</span><br><span class="line">    t2.<span class="built_in">detach</span>();</span><br><span class="line">    t3.<span class="built_in">detach</span>();</span><br><span class="line"></span><br><span class="line">    isRun = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">while</span>(!isFinished)</span><br><span class="line">    &#123;</span><br><span class="line">        std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">microseconds</span>(<span class="number">100</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;finished\n&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><details><summary>方法1代码运行结果</summary><p>反正是通过编号判断的，肯定不会错，只不过这样效率其实很低。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td><td class="code"><pre><span class="line">1 - 140173660395072 - c: 1</span><br><span class="line">2 - 140173652002368 - c: 2</span><br><span class="line">3 - 140173643609664 - c: 3</span><br><span class="line">1 - 140173660395072 - c: 4</span><br><span class="line">2 - 140173652002368 - c: 5</span><br><span class="line">3 - 140173643609664 - c: 6</span><br><span class="line">1 - 140173660395072 - c: 7</span><br><span class="line">2 - 140173652002368 - c: 8</span><br><span class="line">3 - 140173643609664 - c: 9</span><br><span class="line">1 - 140173660395072 - c: 10</span><br><span class="line">2 - 140173652002368 - c: 11</span><br><span class="line">3 - 140173643609664 - c: 12</span><br><span class="line">1 - 140173660395072 - c: 13</span><br><span class="line">2 - 140173652002368 - c: 14</span><br><span class="line">3 - 140173643609664 - c: 15</span><br><span class="line">1 - 140173660395072 - c: 16</span><br><span class="line">2 - 140173652002368 - c: 17</span><br><span class="line">3 - 140173643609664 - c: 18</span><br><span class="line">1 - 140173660395072 - c: 19</span><br><span class="line">2 - 140173652002368 - c: 20</span><br><span class="line">3 - 140173643609664 - c: 21</span><br><span class="line">1 - 140173660395072 - c: 22</span><br><span class="line">2 - 140173652002368 - c: 23</span><br><span class="line">3 - 140173643609664 - c: 24</span><br><span class="line">1 - 140173660395072 - c: 25</span><br><span class="line">2 - 140173652002368 - c: 26</span><br><span class="line">3 - 140173643609664 - c: 27</span><br><span class="line">1 - 140173660395072 - c: 28</span><br><span class="line">2 - 140173652002368 - c: 29</span><br><span class="line">3 - 140173643609664 - c: 30</span><br><span class="line">1 - 140173660395072 - c: 31</span><br><span class="line">2 - 140173652002368 - c: 32</span><br><span class="line">3 - 140173643609664 - c: 33</span><br><span class="line">1 - 140173660395072 - c: 34</span><br><span class="line">2 - 140173652002368 - c: 35</span><br><span class="line">3 - 140173643609664 - c: 36</span><br><span class="line">1 - 140173660395072 - c: 37</span><br><span class="line">2 - 140173652002368 - c: 38</span><br><span class="line">3 - 140173643609664 - c: 39</span><br><span class="line">1 - 140173660395072 - c: 40</span><br><span class="line">2 - 140173652002368 - c: 41</span><br><span class="line">3 - 140173643609664 - c: 42</span><br><span class="line">1 - 140173660395072 - c: 43</span><br><span class="line">2 - 140173652002368 - c: 44</span><br><span class="line">3 - 140173643609664 - c: 45</span><br><span class="line">1 - 140173660395072 - c: 46</span><br><span class="line">2 - 140173652002368 - c: 47</span><br><span class="line">3 - 140173643609664 - c: 48</span><br><span class="line">1 - 140173660395072 - c: 49</span><br><span class="line">2 - 140173652002368 - c: 50</span><br><span class="line">3 - 140173643609664 - c: 51</span><br><span class="line">1 - 140173660395072 - c: 52</span><br><span class="line">2 - 140173652002368 - c: 53</span><br><span class="line">3 - 140173643609664 - c: 54</span><br><span class="line">1 - 140173660395072 - c: 55</span><br><span class="line">2 - 140173652002368 - c: 56</span><br><span class="line">3 - 140173643609664 - c: 57</span><br><span class="line">1 - 140173660395072 - c: 58</span><br><span class="line">2 - 140173652002368 - c: 59</span><br><span class="line">3 - 140173643609664 - c: 60</span><br><span class="line">1 - 140173660395072 - c: 61</span><br><span class="line">2 - 140173652002368 - c: 62</span><br><span class="line">3 - 140173643609664 - c: 63</span><br><span class="line">1 - 140173660395072 - c: 64</span><br><span class="line">2 - 140173652002368 - c: 65</span><br><span class="line">3 - 140173643609664 - c: 66</span><br><span class="line">1 - 140173660395072 - c: 67</span><br><span class="line">2 - 140173652002368 - c: 68</span><br><span class="line">3 - 140173643609664 - c: 69</span><br><span class="line">1 - 140173660395072 - c: 70</span><br><span class="line">2 - 140173652002368 - c: 71</span><br><span class="line">3 - 140173643609664 - c: 72</span><br><span class="line">1 - 140173660395072 - c: 73</span><br><span class="line">2 - 140173652002368 - c: 74</span><br><span class="line">3 - 140173643609664 - c: 75</span><br><span class="line">1 - 140173660395072 - c: 76</span><br><span class="line">2 - 140173652002368 - c: 77</span><br><span class="line">3 - 140173643609664 - c: 78</span><br><span class="line">1 - 140173660395072 - c: 79</span><br><span class="line">2 - 140173652002368 - c: 80</span><br><span class="line">3 - 140173643609664 - c: 81</span><br><span class="line">1 - 140173660395072 - c: 82</span><br><span class="line">2 - 140173652002368 - c: 83</span><br><span class="line">3 - 140173643609664 - c: 84</span><br><span class="line">1 - 140173660395072 - c: 85</span><br><span class="line">2 - 140173652002368 - c: 86</span><br><span class="line">3 - 140173643609664 - c: 87</span><br><span class="line">1 - 140173660395072 - c: 88</span><br><span class="line">2 - 140173652002368 - c: 89</span><br><span class="line">3 - 140173643609664 - c: 90</span><br><span class="line">1 - 140173660395072 - c: 91</span><br><span class="line">2 - 140173652002368 - c: 92</span><br><span class="line">3 - 140173643609664 - c: 93</span><br><span class="line">1 - 140173660395072 - c: 94</span><br><span class="line">2 - 140173652002368 - c: 95</span><br><span class="line">3 - 140173643609664 - c: 96</span><br><span class="line">1 - 140173660395072 - c: 97</span><br><span class="line">2 - 140173652002368 - c: 98</span><br><span class="line">3 - 140173643609664 - c: 99</span><br><span class="line">1 - 140173660395072 - c: 100</span><br><span class="line">finished</span><br></pre></td></tr></table></figure></details><p>我刚开始的时候就是想着用条件变量，比如三个条件变量分别用于通知……但这个实在是复杂且没有必要，没做过条件变量练习一时半会完全是写不出来的。后来就换了这个思路，但时间已经来不及了。</p><p>说来惭愧，我写完上面代码的基本框架后编译错误，显示<code>atomic&lt;bool&gt;</code>初始化失败，我找了好久都没有发现是自己<strong>没有引用</strong><code>&lt;atomic&gt;</code>这个头文件导致的，一直在看自己的语法是不是写错了……</p><p>还是自己练习不够，不然也不会怀疑自己语法是否写错😣</p><h1 id="思路2-条件变量"><a href="#思路2-条件变量" class="headerlink" title="思路2-条件变量"></a>思路2-条件变量</h1><p>上述的这个单锁加遍历的思路其实并不是一个好的答案（<strong>但总比没写出来的好</strong>），因为它完全没有涉及到线程同步的机制，<strong>三个线程其实毫无关系</strong>，只是在通过锁竞争和判断来确定自己是否需要打印。面试官想要的答案肯定得包含条件变量。</p><p>下面这个解决方案的思路同样是通过线程编号判断（只不过拆分成了三个不同的函数），每个线程打印完毕自己的，就把另外两个线程唤醒，然后被唤醒的两个线程会通过锁竞争先后进入自己的函数打印区域，判断是否是自己需要打印的部分，如果不是就继续在条件变量里面等待。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;condition_variable&gt;</span></span></span><br><span class="line"></span><br><span class="line">std::mutex gMtx;</span><br><span class="line">std::condition_variable cv;</span><br><span class="line"><span class="type">int</span> count = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func1</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lc</span><span class="params">(gMtx)</span></span>;</span><br><span class="line"><span class="keyword">while</span>(count &lt;= <span class="number">100</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">while</span> (count % <span class="number">3</span> == <span class="number">0</span> &amp;&amp; count &lt;= <span class="number">100</span>)</span><br><span class="line">&#123;</span><br><span class="line">std::cout &lt;&lt; std::this_thread::<span class="built_in">get_id</span>() &lt;&lt; <span class="string">&quot; - c: &quot;</span> &lt;&lt; count &lt;&lt; std::endl;</span><br><span class="line">count++;</span><br><span class="line">cv.<span class="built_in">notify_all</span>();</span><br><span class="line">&#125;</span><br><span class="line">cv.<span class="built_in">wait</span>(lc);</span><br><span class="line">&#125;</span><br><span class="line">cv.<span class="built_in">notify_all</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func2</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lc</span><span class="params">(gMtx)</span></span>;</span><br><span class="line"><span class="keyword">while</span> (count &lt;= <span class="number">100</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">while</span> (count % <span class="number">3</span> == <span class="number">1</span> &amp;&amp; count &lt;= <span class="number">100</span>)</span><br><span class="line">&#123;</span><br><span class="line">std::cout &lt;&lt; std::this_thread::<span class="built_in">get_id</span>() &lt;&lt; <span class="string">&quot; - c: &quot;</span> &lt;&lt; count &lt;&lt; std::endl;</span><br><span class="line">count++; </span><br><span class="line">cv.<span class="built_in">notify_all</span>();</span><br><span class="line">&#125;</span><br><span class="line">cv.<span class="built_in">wait</span>(lc);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func3</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lc</span><span class="params">(gMtx)</span></span>;</span><br><span class="line"><span class="keyword">while</span> (count &lt;= <span class="number">100</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">while</span> (count % <span class="number">3</span> == <span class="number">2</span> &amp;&amp; count &lt;= <span class="number">100</span>)</span><br><span class="line">&#123;</span><br><span class="line">std::cout &lt;&lt; std::this_thread::<span class="built_in">get_id</span>() &lt;&lt; <span class="string">&quot; - c: &quot;</span> &lt;&lt; count &lt;&lt; std::endl;</span><br><span class="line">count++; </span><br><span class="line">cv.<span class="built_in">notify_all</span>();</span><br><span class="line">&#125;</span><br><span class="line">cv.<span class="built_in">wait</span>(lc);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="function">std::thread <span class="title">s1</span><span class="params">(func1)</span></span>;</span><br><span class="line"><span class="function">std::thread <span class="title">s2</span><span class="params">(func2)</span></span>;</span><br><span class="line"><span class="function">std::thread <span class="title">s3</span><span class="params">(func3)</span></span>;</span><br><span class="line"></span><br><span class="line">s1.<span class="built_in">join</span>();</span><br><span class="line">s2.<span class="built_in">join</span>();</span><br><span class="line">s3.<span class="built_in">join</span>();</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;finished\n&quot;</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><details><summary>方法2代码运行结果</summary><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td><td class="code"><pre><span class="line">140713900033600 - c: 1</span><br><span class="line">140713891640896 - c: 2</span><br><span class="line">140713908426304 - c: 3</span><br><span class="line">140713900033600 - c: 4</span><br><span class="line">140713891640896 - c: 5</span><br><span class="line">140713908426304 - c: 6</span><br><span class="line">140713900033600 - c: 7</span><br><span class="line">140713891640896 - c: 8</span><br><span class="line">140713908426304 - c: 9</span><br><span class="line">140713900033600 - c: 10</span><br><span class="line">140713891640896 - c: 11</span><br><span class="line">140713908426304 - c: 12</span><br><span class="line">140713900033600 - c: 13</span><br><span class="line">140713891640896 - c: 14</span><br><span class="line">140713908426304 - c: 15</span><br><span class="line">140713900033600 - c: 16</span><br><span class="line">140713891640896 - c: 17</span><br><span class="line">140713908426304 - c: 18</span><br><span class="line">140713900033600 - c: 19</span><br><span class="line">140713891640896 - c: 20</span><br><span class="line">140713908426304 - c: 21</span><br><span class="line">140713900033600 - c: 22</span><br><span class="line">140713891640896 - c: 23</span><br><span class="line">140713908426304 - c: 24</span><br><span class="line">140713900033600 - c: 25</span><br><span class="line">140713891640896 - c: 26</span><br><span class="line">140713908426304 - c: 27</span><br><span class="line">140713900033600 - c: 28</span><br><span class="line">140713891640896 - c: 29</span><br><span class="line">140713908426304 - c: 30</span><br><span class="line">140713900033600 - c: 31</span><br><span class="line">140713891640896 - c: 32</span><br><span class="line">140713908426304 - c: 33</span><br><span class="line">140713900033600 - c: 34</span><br><span class="line">140713891640896 - c: 35</span><br><span class="line">140713908426304 - c: 36</span><br><span class="line">140713900033600 - c: 37</span><br><span class="line">140713891640896 - c: 38</span><br><span class="line">140713908426304 - c: 39</span><br><span class="line">140713900033600 - c: 40</span><br><span class="line">140713891640896 - c: 41</span><br><span class="line">140713908426304 - c: 42</span><br><span class="line">140713900033600 - c: 43</span><br><span class="line">140713891640896 - c: 44</span><br><span class="line">140713908426304 - c: 45</span><br><span class="line">140713900033600 - c: 46</span><br><span class="line">140713891640896 - c: 47</span><br><span class="line">140713908426304 - c: 48</span><br><span class="line">140713900033600 - c: 49</span><br><span class="line">140713891640896 - c: 50</span><br><span class="line">140713908426304 - c: 51</span><br><span class="line">140713900033600 - c: 52</span><br><span class="line">140713891640896 - c: 53</span><br><span class="line">140713908426304 - c: 54</span><br><span class="line">140713900033600 - c: 55</span><br><span class="line">140713891640896 - c: 56</span><br><span class="line">140713908426304 - c: 57</span><br><span class="line">140713900033600 - c: 58</span><br><span class="line">140713891640896 - c: 59</span><br><span class="line">140713908426304 - c: 60</span><br><span class="line">140713900033600 - c: 61</span><br><span class="line">140713891640896 - c: 62</span><br><span class="line">140713908426304 - c: 63</span><br><span class="line">140713900033600 - c: 64</span><br><span class="line">140713891640896 - c: 65</span><br><span class="line">140713908426304 - c: 66</span><br><span class="line">140713900033600 - c: 67</span><br><span class="line">140713891640896 - c: 68</span><br><span class="line">140713908426304 - c: 69</span><br><span class="line">140713900033600 - c: 70</span><br><span class="line">140713891640896 - c: 71</span><br><span class="line">140713908426304 - c: 72</span><br><span class="line">140713900033600 - c: 73</span><br><span class="line">140713891640896 - c: 74</span><br><span class="line">140713908426304 - c: 75</span><br><span class="line">140713900033600 - c: 76</span><br><span class="line">140713891640896 - c: 77</span><br><span class="line">140713908426304 - c: 78</span><br><span class="line">140713900033600 - c: 79</span><br><span class="line">140713891640896 - c: 80</span><br><span class="line">140713908426304 - c: 81</span><br><span class="line">140713900033600 - c: 82</span><br><span class="line">140713891640896 - c: 83</span><br><span class="line">140713908426304 - c: 84</span><br><span class="line">140713900033600 - c: 85</span><br><span class="line">140713891640896 - c: 86</span><br><span class="line">140713908426304 - c: 87</span><br><span class="line">140713900033600 - c: 88</span><br><span class="line">140713891640896 - c: 89</span><br><span class="line">140713908426304 - c: 90</span><br><span class="line">140713900033600 - c: 91</span><br><span class="line">140713891640896 - c: 92</span><br><span class="line">140713908426304 - c: 93</span><br><span class="line">140713900033600 - c: 94</span><br><span class="line">140713891640896 - c: 95</span><br><span class="line">140713908426304 - c: 96</span><br><span class="line">140713900033600 - c: 97</span><br><span class="line">140713891640896 - c: 98</span><br><span class="line">140713908426304 - c: 99</span><br><span class="line">140713900033600 - c: 100</span><br><span class="line">finished</span><br></pre></td></tr></table></figure></details><h1 id="The-end"><a href="#The-end" class="headerlink" title="The end"></a>The end</h1><p>自己平时不多练习，只能大意失荆州了……</p>]]></content>
    
    
    <summary type="html">使用C++实现三个线程交替打印1到100</summary>
    
    
    
    <category term="求职路上一去不复返" scheme="https://blog.musnow.top/categories/%E6%B1%82%E8%81%8C%E8%B7%AF%E4%B8%8A%E4%B8%80%E5%8E%BB%E4%B8%8D%E5%A4%8D%E8%BF%94/"/>
    
    
    <category term="线程" scheme="https://blog.musnow.top/tags/%E7%BA%BF%E7%A8%8B/"/>
    
    <category term="Cpp" scheme="https://blog.musnow.top/tags/Cpp/"/>
    
  </entry>
  
  <entry>
    <title>【leetcode】146LRU缓存</title>
    <link href="https://blog.musnow.top/posts/1621367479/"/>
    <id>https://blog.musnow.top/posts/1621367479/</id>
    <published>2024-03-08T01:58:17.000Z</published>
    <updated>2024-03-08T01:59:06.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p><a href="https://leetcode.cn/problems/lru-cache/description/?envType=study-plan-v2&envId=top-100-liked">146. LRU 缓存 - 力扣（LeetCode）</a></p><h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p>操作系统中学习过LRU的相关知识，中文是<strong>最长最久未使用</strong>，是页面置换算法的一部分。即页表在置换算法的时候，从当前时刻往前找，找到以载入页面中最长时间没有被使用的哪一个，将其置换出去。</p><p>对于代码而言，可以用list+哈希表的结构来实现。</p><ul><li>哈希表存放key和node的关系</li><li>node中存放key和value</li></ul><p>我们使用list来维护节点被使用的时间，<strong>一个节点被访问就插入到链表头</strong>，这样就能保证链表尾部的就是那个最久没有被使用的节点。需要删除的时候就将尾部的节点删除即可。</p><p>如果一个key已经存在与list中，访问的时候就需要将其先删除，再头插。为了满足题目中<code>O(1)</code>时间复杂度的要求，使用链表才能保证删除的时间复杂度是<code>O(1)</code>。</p><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><p>刚开始用的头删+尾插的方式，结果弄了好久都还有段错误，改成头插+尾删好处理一些。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> _val;</span><br><span class="line">    <span class="type">int</span> _key;</span><br><span class="line">    Node* _prev;</span><br><span class="line">    Node* _next;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Node</span>():_val(<span class="number">0</span>),_key(<span class="number">0</span>),_prev(<span class="literal">nullptr</span>),_next(<span class="literal">nullptr</span>)&#123;&#125;</span><br><span class="line">    <span class="built_in">Node</span>(<span class="type">int</span> key,<span class="type">int</span> val):_val(val),_key(key),_prev(<span class="literal">nullptr</span>),_next(<span class="literal">nullptr</span>)&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">LRUCache</span> &#123;</span><br><span class="line">    Node* _head;</span><br><span class="line">    Node* _tail;</span><br><span class="line">    unordered_map&lt;<span class="type">int</span>,Node*&gt; _map;</span><br><span class="line">    <span class="type">int</span> _size = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> _capa = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">LRUCache</span>(<span class="type">int</span> capacity) &#123;</span><br><span class="line">        _head = <span class="keyword">new</span> <span class="built_in">Node</span>();</span><br><span class="line">        _tail = <span class="keyword">new</span> <span class="built_in">Node</span>();</span><br><span class="line">        _head-&gt;_next = _tail;</span><br><span class="line">        _tail-&gt;_prev = _head;</span><br><span class="line">        _capa = capacity;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">addNodeToHead</span><span class="params">(Node* node)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        node-&gt;_prev = _head;</span><br><span class="line">        node-&gt;_next = _head-&gt;_next;</span><br><span class="line">        _head-&gt;_next-&gt;_prev = node;</span><br><span class="line">        _head-&gt;_next = node;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">removeNode</span><span class="params">(Node* node)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        node-&gt;_prev-&gt;_next = node-&gt;_next;</span><br><span class="line">        node-&gt;_next-&gt;_prev = node-&gt;_prev;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">get</span><span class="params">(<span class="type">int</span> key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(_map.<span class="built_in">count</span>(key))</span><br><span class="line">        &#123;</span><br><span class="line">            Node* node = _map[key];</span><br><span class="line">            <span class="built_in">removeNode</span>(node);</span><br><span class="line">            <span class="built_in">addNodeToHead</span>(node);</span><br><span class="line">            <span class="keyword">return</span> node-&gt;_val;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">put</span><span class="params">(<span class="type">int</span> key, <span class="type">int</span> value)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 存在</span></span><br><span class="line">        <span class="keyword">if</span>(_map.<span class="built_in">count</span>(key))</span><br><span class="line">        &#123;</span><br><span class="line">            Node* node = _map[key];</span><br><span class="line">            node-&gt;_val = value;</span><br><span class="line">            <span class="built_in">removeNode</span>(node);</span><br><span class="line">            <span class="built_in">addNodeToHead</span>(node);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 超长了</span></span><br><span class="line">            <span class="keyword">if</span>(_size == _capa)</span><br><span class="line">            &#123;</span><br><span class="line">                Node* remove = _tail-&gt;_prev;</span><br><span class="line">                _map.<span class="built_in">erase</span>(remove-&gt;_key);</span><br><span class="line">                <span class="built_in">removeNode</span>(remove);</span><br><span class="line">                _size--;</span><br><span class="line">                <span class="comment">// 这里可以不free节点，因为OJ不考虑内存泄漏</span></span><br><span class="line">                <span class="keyword">delete</span> remove;</span><br><span class="line">            &#125;</span><br><span class="line">            Node* node = <span class="keyword">new</span> <span class="built_in">Node</span>(key,value);</span><br><span class="line">            <span class="built_in">addNodeToHead</span>(node);</span><br><span class="line">            _map[key] = node;</span><br><span class="line">            _size++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your LRUCache object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * LRUCache* obj = new LRUCache(capacity);</span></span><br><span class="line"><span class="comment"> * int param_1 = obj-&gt;get(key);</span></span><br><span class="line"><span class="comment"> * obj-&gt;put(key,value);</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/03/44f70ed77f48124bd2b0a1080122d732.png" alt="image.png"></p>]]></content>
    
    
    <summary type="html">使用哈希表和链表实现的LRU缓存</summary>
    
    
    
    <category term="编程学习" scheme="https://blog.musnow.top/categories/%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="把题目都给刷干净" scheme="https://blog.musnow.top/categories/%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0/%E6%8A%8A%E9%A2%98%E7%9B%AE%E9%83%BD%E7%BB%99%E5%88%B7%E5%B9%B2%E5%87%80/"/>
    
    
    <category term="链表" scheme="https://blog.musnow.top/tags/%E9%93%BE%E8%A1%A8/"/>
    
    <category term="leetcode" scheme="https://blog.musnow.top/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>【算法】KMP算法</title>
    <link href="https://blog.musnow.top/posts/1835761968/"/>
    <id>https://blog.musnow.top/posts/1835761968/</id>
    <published>2024-02-29T08:31:48.000Z</published>
    <updated>2024-03-10T06:44:51.000Z</updated>
    
    <content type="html"><![CDATA[<p>参考《代码随想录》。</p><h1 id="1-介绍"><a href="#1-介绍" class="headerlink" title="1.介绍"></a>1.介绍</h1><p>KMP算法是解决字符串问题时比较常用的一个算法，它可以将暴力破解法的时间复杂度<code>O(N^2)</code>降低到<code>O(M+N)</code>，效率有不错的提升。</p><p>KMP算法由Knuth、Morris和Pratt三位学者发明，也因此得名KMP。</p><h2 id="1-1-next-前缀表"><a href="#1-1-next-前缀表" class="headerlink" title="1.1 next 前缀表"></a>1.1 next 前缀表</h2><p>KMP算法的核心是next数组，实际上是一个<strong>前缀表</strong>：记录下标i（包括i）之前的字符串中有多长的相同前后缀。</p><p>首先我们要明确前缀和后缀的概念：除了最后一个字符的字符串其余部分都可称之为前缀；除了第一个字符的字符串其余部分都可以称之为后缀。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">字符串：abba</span><br><span class="line">最长前缀：abb</span><br><span class="line">最长后缀：bba</span><br><span class="line"></span><br><span class="line">字符串：aa</span><br><span class="line">最长前缀：a</span><br><span class="line">最长后缀：a</span><br><span class="line"></span><br><span class="line">字符串：a</span><br><span class="line">没有前缀和后缀</span><br></pre></td></tr></table></figure><p>相同前后缀就是看前缀和后缀的相同部分；比如字符串<code>abba</code>，前缀和后缀中只有字符串a是相同的，所以这个字符串的<strong>最长相同前后缀</strong>只有1。</p><p>而KMP算法中的next数组，就是存放这个最长相同前后缀数量的。以字符串<code>aabaaf</code>为例</p><table><thead><tr><th>下标</th><th>字符串</th><th>最大相同前后缀</th></tr></thead><tbody><tr><td>0</td><td>a</td><td>0</td></tr><tr><td>1</td><td>aa</td><td>1</td></tr><tr><td>2</td><td>aab</td><td>0</td></tr><tr><td>3</td><td>aaba</td><td>1</td></tr><tr><td>4</td><td>aabaa</td><td>2</td></tr><tr><td>5</td><td>aabaaf</td><td>0</td></tr></tbody></table><p>对<code>aabaaf</code>字符串而言，最终得到的KMP算法next数组存放的就是<code>&#123;0,1,0,1,2,0&#125;</code>，这个数组就是该字符串的<strong>前缀表</strong>。</p><h2 id="1-2-next数组的作用"><a href="#1-2-next数组的作用" class="headerlink" title="1.2 next数组的作用"></a>1.2 next数组的作用</h2><p>那么这个next数组有什么作用呢？给出一个示例题目：让你在<code>aabaabaaf</code>中查找是否包含子字符串<code>aabaaf</code>；</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/02/89e406b57e7dc7d1cff721dee001bb7d.png" alt="image.png"></p><p>假设我们使用暴力法，当匹配到最后一个字符不相同时，会将源串下标+1，然后重新匹配子串。</p><p>但仔细观察你会发现，虽然这里源字符串和子串的最后一个字符f不匹配，但前面三个aab是已经匹配上的，我们完全可以从这个已经匹配上的字符串往后找，会发现最终可以找到子字符串<code>aabaaf</code>。</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/02/7d08ccd09b14e5e8a082473d6c3d4965.png" alt="image.png"></p><p>next数组就是用来解决这个问题的。当发现不匹配时，回溯到当前位置前一个的next数组中所对应元素的下标位置。下图中f是<strong>下标5</strong>，那么就需要回溯到<code>next[5-1]</code>的下标处，即回溯到子串中的<strong>下标2</strong>位置，重新开始匹配。</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/02/1759f4d6ba0630f323c5fd1a5898cc3d.png" alt="image.png"></p><p>此时会发现下标2的位置和当前源串的字符相同，继续往后匹配子串，能找到完整的子串。</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/02/e1655433e59d6d266480f4cdc5043b8d.png" alt="image.png"></p><p>通过next数组，把原本需要重新遍历的方式改为从上一个可以被匹配的位置重新开始匹配，就节省了时间。</p><h2 id="1-3-为什么？"><a href="#1-3-为什么？" class="headerlink" title="1.3 为什么？"></a>1.3 为什么？</h2><p>因为前缀表记录了最长相同前后缀的信息，当我们匹配不上的时候，找到前一个下标对应前缀表内的数据，就能得到当前字符以前的字符串是否有相同的前缀。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">下标数 0 1 2 3 4 5</span><br><span class="line">字符串 a a b a a f</span><br><span class="line">前缀表 0 1 0 1 2 0</span><br></pre></td></tr></table></figure><p>当f匹配不上的时候，前一位在前缀表中为2，代表往前一共有2个字符（后缀），和整个字符串的<strong>前2位</strong>是相同的（即aabaa里面后缀的aa和前缀的aa相同，这里的前缀aa也是字符串的起始两个字符）。</p><p>这能告诉我们，刚刚匹配的字符串中，后缀部分匹配成功了2个aa（不然也走不到f这里来），可以把这个后缀的2个aa当作前缀的2个aa来处理，而指针只需要回溯到<strong>前缀aa的下一个字符</strong>重新开始匹配即可，对于数组而言，<strong>下一个字符的下标就是前缀表中的数字</strong>。</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/02/7d08ccd09b14e5e8a082473d6c3d4965.png" alt="image.png"></p><h2 id="1-4-获取一个字符串的next数组"><a href="#1-4-获取一个字符串的next数组" class="headerlink" title="1.4 获取一个字符串的next数组"></a>1.4 获取一个字符串的next数组</h2><p>获取next数组有几种实现方式</p><ul><li>将前缀表中的数据全部减一；</li><li>将前缀表中的数据整体右移一位；</li><li>直接使用前缀表；</li></ul><p>个人更加喜欢直接使用前缀表的方式，因为原理就是这么学的，直接使用前缀表也比较好动懂一些。构造前缀表的代码如下，这个代码的逻辑可能没有那么好懂，<strong>最好是想办法背下来</strong>！</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">getNext</span><span class="params">(<span class="type">int</span>* next,<span class="type">const</span> std::string&amp; s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> j = <span class="number">0</span>;</span><br><span class="line">next[<span class="number">0</span>] = <span class="number">0</span>; <span class="comment">// 初始化next数组第一位（第一位是不存在前缀和后缀，肯定为0）</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;s.<span class="built_in">size</span>();i++) <span class="comment">//遍历要从字符串第二位开始</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 后续需要取j-1作为下标的操作，所以j必须大于0</span></span><br><span class="line"><span class="comment">// 当j和i的字符二者不匹配的时候，就需要往前回溯</span></span><br><span class="line"><span class="keyword">while</span>(j&gt;<span class="number">0</span> &amp;&amp; s[i] != s[j])</span><br><span class="line">&#123;</span><br><span class="line">j = next[j<span class="number">-1</span>]; <span class="comment">// 回溯到前一位下标在next数组中的元素</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 二者匹配，j+1</span></span><br><span class="line"><span class="keyword">if</span>(s[i] == s[j])</span><br><span class="line">&#123;</span><br><span class="line">j++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 赋值next数组</span></span><br><span class="line">next[i] = j;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试一下，成功获得刚刚计算出来的前缀表</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">string test = <span class="string">&quot;aabaaf&quot;</span>;</span><br><span class="line"><span class="type">int</span> next[<span class="number">10</span>];</span><br><span class="line"><span class="built_in">getNext</span>(next, test);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; test.<span class="built_in">size</span>(); i++)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; next[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0 1 0 1 2 0</span><br></pre></td></tr></table></figure><h1 id="2-leetcode-28-找到子串并返回起始下标"><a href="#2-leetcode-28-找到子串并返回起始下标" class="headerlink" title="2.leetcode-28-找到子串并返回起始下标"></a>2.leetcode-28-找到子串并返回起始下标</h1><p><a href="https://leetcode.cn/problems/find-the-index-of-the-first-occurrence-in-a-string/description/">28. 找出字符串中第一个匹配项的下标</a></p><p>题目：给你两个字符串 haystack 和 needle ，请你在 haystack 字符串中找出 needle 字符串的第一个匹配项的下标（下标从 0 开始）。如果 needle 不是 haystack 的一部分，则返回  -1 。</p><p>这道题就是学习KMP算法的经典题目，思路前文已经描述过了，这里只给出代码。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">getNext</span><span class="params">(<span class="type">int</span>* next,<span class="type">const</span> std::string&amp; s)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="type">int</span> j = <span class="number">0</span>;</span><br><span class="line">        next[<span class="number">0</span>] = <span class="number">0</span>; <span class="comment">// 初始化next数组第一位（第一位是不存在前缀和后缀，肯定为0）</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;s.<span class="built_in">size</span>();i++) <span class="comment">//遍历要从字符串第二位开始</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 后续需要取j-1作为下标的操作，所以j必须大于0</span></span><br><span class="line">            <span class="comment">// 当j和i的字符二者不匹配的时候，就需要往前回溯</span></span><br><span class="line">            <span class="keyword">while</span>(j&gt;<span class="number">0</span> &amp;&amp; s[i] != s[j])</span><br><span class="line">            &#123;</span><br><span class="line">                j = next[j<span class="number">-1</span>]; <span class="comment">// 回溯到前一位下标在next数组中的元素</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 二者匹配，j+1</span></span><br><span class="line">            <span class="keyword">if</span>(s[i] == s[j])</span><br><span class="line">            &#123;</span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 赋值next数组</span></span><br><span class="line">            next[i] = j;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">strStr</span><span class="params">(string haystack, string needle)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 子串为空肯定找不到</span></span><br><span class="line">        <span class="keyword">if</span>(needle.<span class="built_in">size</span>() == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> next[needle.<span class="built_in">size</span>()];</span><br><span class="line">        <span class="built_in">getNext</span>(next,needle);</span><br><span class="line">        <span class="type">int</span> j=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;haystack.<span class="built_in">size</span>();i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span>(j&gt;<span class="number">0</span> &amp;&amp; haystack[i] != needle[j])</span><br><span class="line">            &#123;</span><br><span class="line">                j = next[j<span class="number">-1</span>]; <span class="comment">// 往前回溯一位</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(haystack[i] == needle[j])&#123;</span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// j已经超出大小，说明子串完全匹配，成功。</span></span><br><span class="line">            <span class="keyword">if</span>(j&gt;=needle.<span class="built_in">size</span>())</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> (i - needle.<span class="built_in">size</span>() + <span class="number">1</span>); <span class="comment">// 返回子串的起始下标</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;<span class="comment">//没找到</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>题解通过</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/02/52720e7926e1e664422d129534951804.png" alt="image.png"></p><h1 id="3-leetcode-459-重复的子字符串"><a href="#3-leetcode-459-重复的子字符串" class="headerlink" title="3.leetcode-459-重复的子字符串"></a>3.leetcode-459-重复的子字符串</h1><h2 id="3-1-题目"><a href="#3-1-题目" class="headerlink" title="3.1 题目"></a>3.1 题目</h2><p><a href="https://leetcode.cn/problems/repeated-substring-pattern/description/">459. 重复的子字符串</a></p><p>给定一个非空的字符串 s ，检查是否可以通过由它的一个子串重复多次构成。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">示例 1:</span><br><span class="line">输入: s = &quot;abab&quot;</span><br><span class="line">输出: true</span><br><span class="line">解释: 可由子串 &quot;ab&quot; 重复两次构成。</span><br><span class="line"></span><br><span class="line">示例 2:</span><br><span class="line">输入: s = &quot;aba&quot;</span><br><span class="line">输出: false</span><br></pre></td></tr></table></figure><h2 id="3-2-解释"><a href="#3-2-解释" class="headerlink" title="3.2 解释"></a>3.2 解释</h2><p>这道题同样可以用KMP算法来解决，因为前缀表间接包含了当前字符串是否能通过某个子串重复构成的功能。</p><p>假设目标字符串长度为len，前缀表为next数组，那么<code>next[len-1]</code>是前缀表的最后一位，保存了完整字符串的最长相同前后缀的长度。</p><p>$$<br>len % (len - next[len-1])&#x3D;0<br>$$</p><p>如果字符串的长度能 整除 字符串的长度减去<code>next[len-1]</code>，则代表字符串能被重复的子串循环构成！</p><p>观察下面这个字符串和它的前缀表，最后一位的数据是6，整个字符串的长度是9，这代表，整个字符串中，最长相同前缀和后缀有3个字符是重合的部分，且字符串的前缀3个字符和后缀3个字符都和中间这个重复的三个字符相同！</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">字符串 abcabcabc</span><br><span class="line">前缀表 000123456</span><br><span class="line"></span><br><span class="line">源串 abcabcabc</span><br><span class="line">前缀 abcabc</span><br><span class="line">后缀    abcabc</span><br></pre></td></tr></table></figure><p>如下所示，中间三个字符abc是在前后缀中重合的，而前缀第一个abc又能和后缀的前一个abc匹配上，后缀的末尾abc又能和中间重复的部分匹配上，则代表整个字符串就是由abc循环构成的。</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/02/ab8928003a833abad85bb828bc8f0075.png" alt="image.png"></p><p>而依据上述的公式计算，<code>9/(9-6) = 3</code>，可以被整除，即符合循环构成的条件！</p><p>描述的可能有点抽象，估计过几天回头看我自己也看不懂了……🤣</p><h2 id="3-3-代码"><a href="#3-3-代码" class="headerlink" title="3.3 代码"></a>3.3 代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">getNext</span><span class="params">(<span class="type">int</span>* next,<span class="type">const</span> std::string&amp; s)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="type">int</span> j = <span class="number">0</span>;</span><br><span class="line">        next[<span class="number">0</span>] = <span class="number">0</span>; <span class="comment">// 初始化next数组第一位（第一位是不存在前缀和后缀，肯定为0）</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;s.<span class="built_in">size</span>();i++) <span class="comment">//遍历要从字符串第二位开始</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 后续需要取j-1作为下标的操作，所以j必须大于0</span></span><br><span class="line">            <span class="comment">// 当j和i的字符二者不匹配的时候，就需要往前回溯</span></span><br><span class="line">            <span class="keyword">while</span>(j&gt;<span class="number">0</span> &amp;&amp; s[i] != s[j])</span><br><span class="line">            &#123;</span><br><span class="line">                j = next[j<span class="number">-1</span>]; <span class="comment">// 回溯到前一位下标在next数组中的元素</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 二者匹配，j+1</span></span><br><span class="line">            <span class="keyword">if</span>(s[i] == s[j])</span><br><span class="line">            &#123;</span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 赋值next数组</span></span><br><span class="line">            next[i] = j;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">repeatedSubstringPattern</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> next[s.<span class="built_in">size</span>()];</span><br><span class="line">        <span class="built_in">getNext</span>(next,s);</span><br><span class="line">        <span class="type">size_t</span> len = s.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span>(next[len<span class="number">-1</span>] != <span class="number">0</span> &amp;&amp; (len%(len-next[len<span class="number">-1</span>])) == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/02/66abe22355e25713fb484e3fdb3bcb5c.png" alt="image.png"></p><h1 id="The-end"><a href="#The-end" class="headerlink" title="The end"></a>The end</h1><p>KMP算法有点不好理解，把next数组的构建背下来就差不多得了……</p>]]></content>
    
    
    <summary type="html">简单学习一下KMP算法</summary>
    
    
    
    <category term="编程学习" scheme="https://blog.musnow.top/categories/%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="把题目都给刷干净" scheme="https://blog.musnow.top/categories/%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0/%E6%8A%8A%E9%A2%98%E7%9B%AE%E9%83%BD%E7%BB%99%E5%88%B7%E5%B9%B2%E5%87%80/"/>
    
    
    <category term="算法" scheme="https://blog.musnow.top/tags/%E7%AE%97%E6%B3%95/"/>
    
    <category term="Cpp" scheme="https://blog.musnow.top/tags/Cpp/"/>
    
    <category term="KMP" scheme="https://blog.musnow.top/tags/KMP/"/>
    
  </entry>
  
  <entry>
    <title>【Linux】Linux64位环境下编译32位报错的解决办法</title>
    <link href="https://blog.musnow.top/posts/3573352712/"/>
    <id>https://blog.musnow.top/posts/3573352712/</id>
    <published>2024-02-24T03:04:53.000Z</published>
    <updated>2024-02-24T03:09:52.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>如题，当我尝试在wsl2的ubuntu中使用<code>-m32</code>选项编译32位程序的时候，出现了下面的两种报错</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">❯ g++ -m32 test.cpp -o test1 &amp;&amp; ./test1</span><br><span class="line">In file included from test.cpp:1:</span><br><span class="line">/usr/include/stdio.h:27:10: fatal error: bits/libc-header-start.h: No such file or directory</span><br><span class="line">   27 | #include &lt;bits/libc-header-start.h&gt;</span><br><span class="line">      |          ^~~~~~~~~~~~~~~~~~~~~~~~~~</span><br><span class="line">compilation terminated.</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">❯ g++ -m32 test.cpp -o test1 &amp;&amp; ./test1</span><br><span class="line">/usr/bin/ld: skipping incompatible /usr/lib/gcc/x86_64-linux-gnu/11/libstdc++.so when searching for -lstdc++</span><br><span class="line">/usr/bin/ld: skipping incompatible /usr/lib/gcc/x86_64-linux-gnu/11/libstdc++.a when searching for -lstdc++</span><br><span class="line">/usr/bin/ld: cannot find -lstdc++: No such file or directory</span><br><span class="line">/usr/bin/ld: skipping incompatible /usr/lib/gcc/x86_64-linux-gnu/11/libstdc++.so when searching for -lstdc++</span><br><span class="line">collect2: error: ld returned 1 exit status</span><br></pre></td></tr></table></figure><h2 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h2><p>原因是当前缺少32位的开发库，需要安装</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install gcc-multilib g++-multilib libc6-dev-i386 -y</span><br></pre></td></tr></table></figure><p>安装后重试，编译成功。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">❯ g++ -m32  test.cpp -o test1 &amp;&amp; ./test1</span><br><span class="line">4</span><br></pre></td></tr></table></figure><p>代码很简单，是一个打印指针大小的代码，在32位下指针大小是4，64位下指针大小是8；</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">void</span> * ptr= <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,<span class="built_in">sizeof</span>(ptr));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="更多说明"><a href="#更多说明" class="headerlink" title="更多说明"></a>更多说明</h2><p>在linux下可以使用下面的命令查看你的系统位数。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">❯ getconf LONG_BIT</span><br><span class="line">64</span><br></pre></td></tr></table></figure><p>参考文章：<a href="https://stackoverflow.com/questions/60553541/usr-bin-ld-skipping-incompatible-usr-lib-gcc-x86-64-linux-gnu-9-libstdc-a-w">assembly - &#x2F;usr&#x2F;bin&#x2F;ld: skipping incompatible &#x2F;usr&#x2F;lib&#x2F;gcc&#x2F;x86_64-linux-gnu&#x2F;9&#x2F;libstdc++.a when searching for -lstdc++ &#x2F;usr&#x2F;bin&#x2F;ld: cannot find -lstdc++ - Stack Overflow</a></p>]]></content>
    
    
    <summary type="html">64位linu下编译32位程序出错，提示skipping incompatible</summary>
    
    
    
    <category term="编程学习" scheme="https://blog.musnow.top/categories/%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="Linux" scheme="https://blog.musnow.top/categories/%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0/Linux/"/>
    
    
    <category term="Linux" scheme="https://blog.musnow.top/tags/Linux/"/>
    
    <category term="wsl" scheme="https://blog.musnow.top/tags/wsl/"/>
    
    <category term="ubuntu" scheme="https://blog.musnow.top/tags/ubuntu/"/>
    
  </entry>
  
  <entry>
    <title>【项目】高并发内存池项目的学习</title>
    <link href="https://blog.musnow.top/posts/4231483511/"/>
    <id>https://blog.musnow.top/posts/4231483511/</id>
    <published>2024-02-20T13:32:14.000Z</published>
    <updated>2024-03-03T06:03:25.000Z</updated>
    
    <content type="html"><![CDATA[<p>学习一下类似于谷歌tcmalloc的高并发内存池。</p><p>项目代码都在<a href="https://github.com/musnows/MemoryPool">GitHub</a>上了，本文是对项目开发过程中的设计学习以及遇到问题的解决方法。</p><p>备注：当前项目在Linux上运行有些问题（mmap地址对齐没有解决），所以暂时只能在win32上开发！</p><h1 id="1-什么是内存池"><a href="#1-什么是内存池" class="headerlink" title="1.什么是内存池"></a>1.什么是内存池</h1><p>核心思想：内存池预先申请大块内存，当其他代码需要申请堆区内存时，不调用malloc&#x2F;new，而是调用我们自己实现的内存池的接口来申请内存。</p><p>因为内存池里面已经预先申请了很多内存，所以它可以直接分配给其他模块。而分配已经申请的内存会比使用malloc&#x2F;new向操作系统申请内存快非常多！</p><blockquote><p>这就好比在家里屯一点纸巾，当纸巾没了，直接用家里的纸巾，不用去小卖部重新买了，自然会快一些。</p></blockquote><p>而malloc&#x2F;new这些能适配所有场景的内存申请函数，自然会有额外的性能损失，当一个系统对性能要求很高的时候，使用内存池来预先申请+分配内存，就可以节省不少的时间，提高系统运行效率。</p><p>因为我们是自己实现了一个内存池，相当于替代了malloc&#x2F;new的工作，此时就可以使用底层的系统调用接口来直接向操作系统申请内存（malloc&#x2F;new会有额外封装）</p><ul><li>windows: VirtualAlloc</li><li>Linux: BRK或MMAP</li></ul><p>分配内存后，如果是C++的对象，可以通过<code>定位new</code>来调用类的构造函数。</p><h2 id="1-1-什么是高并发内存池"><a href="#1-1-什么是高并发内存池" class="headerlink" title="1.1 什么是高并发内存池"></a>1.1 什么是高并发内存池</h2><p>这个项目想实现的高并发内存池，就是在实现一个内存池的基础上，要满足多线程高并发请求空间申请时的性能和不出错。</p><p>这就涉及到多线程竞争以及加锁机制了，后文会补全。</p><h2 id="1-2-内碎片和外碎片"><a href="#1-2-内碎片和外碎片" class="headerlink" title="1.2 内碎片和外碎片"></a>1.2 内碎片和外碎片</h2><ul><li>内碎片：线程池内部分配了却没有使用的内存</li><li>外碎片：进程地址空间中，分配了多块内存，没有全部回收，导致剩余的内存虽然有足够大小，但不连续，无法实现大内存分配。</li></ul><p>内碎片和外碎片的场景如下图所示</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/02/deb006a52f219b90261c67e6e6b9b35f.png" alt="image-20240224103722887"></p><p>假设一个进程申请了512KB的内存，却始终只使用了400KB，这里就出现了112KB的<strong>内碎片</strong>（申请了但没有完全使用）；</p><p>外碎片就看图吧，文字描述不清楚。</p><h1 id="2-定长内存池的实现"><a href="#2-定长内存池的实现" class="headerlink" title="2.定长内存池的实现"></a>2.定长内存池的实现</h1><h2 id="2-1-思路"><a href="#2-1-思路" class="headerlink" title="2.1 思路"></a>2.1 思路</h2><p>对于定长内存池而言，实现比较简单</p><ul><li>申请大块空间；</li><li>使用链表的方式来链接这些空间；</li><li>当申请的时候，释放链表头部的空间；</li><li>当销毁的时候，使用链表头插将空间复原到链表中；</li><li>当空间不够用的时候（链表为空）重新申请大块空间；</li></ul><p>为了实现链表的结构，定长内存池的单个空间分片的大小应该大于平台中一个指针的大小（不然没有办法实现指向下一块空间的地址）</p><p>因为内存池中的内存已经被分配出去了（会有碎片）所以内存池申请的内存是不能被释放的。如果一直没有模块从内存池中申请内存，就可能会产生内存的浪费。但这和内存池的功能<strong>相悖</strong>：如果系统申请内存的频率很低，那说明不需要内存池的介入。</p><p>只要最终内存池的进程是正常结束的，这些被申请的内存都会被操作系统托管和释放。</p><h2 id="2-2-图解"><a href="#2-2-图解" class="headerlink" title="2.2 图解"></a>2.2 图解</h2><p>初始化线程池时，会先申请大块内存，并用指针指向内存开头。</p><p>当有模块申请内存时，将内存开头的部分分配出去，并向后移动指针（同时还需将内存大小计数器给减小）</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/02/5ee43b02da15875217fe4be4eb44b42f.png" alt="image-20240223130822219"></p><p>当回收内存时，将另外一个指针FREELIST指向被回收内存的开头，并将被回收内存的前4&#x2F;8个字节指向NULLPTR或者另外一个被回收的内存分片。</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/02/55ba510435b21c825e098dfa5ff0e195.png" alt="image-20240223131544965"></p><p>当FREELIST为空，且用于标示预先申请的大块内存剩余容量的size为0的时候，就需要重新申请内存了（代表当前线程池已经没有可分配的内存）</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/02/7224a6c2f4a743dd0098d0fe83f108c8.png" alt="image-20240223132634407"></p><p>定长内存池的思路还是比较简单的。</p><h2 id="2-3-代码实现"><a href="#2-3-代码实现" class="headerlink" title="2.3 代码实现"></a>2.3 代码实现</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">FixMemoryPool</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function">T* <span class="title">New</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">T* obj = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 优先把还回来内存块对象，再次重复利用</span></span><br><span class="line"><span class="keyword">if</span> (_freeList)</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">void</span>* next = *((<span class="type">void</span>**)_freeList);</span><br><span class="line">obj = (T*)_freeList;</span><br><span class="line">_freeList = next;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 剩余内存不够一个对象大小时，则重新开大块空间</span></span><br><span class="line"><span class="keyword">if</span> (_remainBytes &lt; <span class="built_in">sizeof</span>(T))</span><br><span class="line">&#123;</span><br><span class="line">_remainBytes = <span class="number">128</span> * <span class="number">1024</span>;</span><br><span class="line">_memory = (<span class="type">char</span>*)<span class="built_in">malloc</span>(_remainBytes);</span><br><span class="line"><span class="keyword">if</span> (_memory == <span class="literal">nullptr</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">throw</span> std::<span class="built_in">bad_alloc</span>();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">obj = (T*)_memory;</span><br><span class="line"><span class="type">size_t</span> objSize = <span class="built_in">sizeof</span>(T) &lt; <span class="built_in">sizeof</span>(<span class="type">void</span>*) ? <span class="built_in">sizeof</span>(<span class="type">void</span>*) : <span class="built_in">sizeof</span>(T);</span><br><span class="line">_memory += objSize;</span><br><span class="line">_remainBytes -= objSize;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定位new，显示调用T的构造函数初始化</span></span><br><span class="line"><span class="keyword">new</span>(obj)T; <span class="comment">// 即便是POD类型也是有个构造函数的</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> obj;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Delete</span><span class="params">(T* obj)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// 显示调用析构函数</span></span><br><span class="line">obj-&gt;~<span class="built_in">T</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 头插，使用void*强转能保证转换后的空间一定是个指针的大小</span></span><br><span class="line">*(<span class="type">void</span>*)obj = _freeList; <span class="comment">// 指向原本的freelist开头的地址</span></span><br><span class="line">_freeList = obj; <span class="comment">// 更新头节点</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="type">char</span>* _memory = <span class="literal">nullptr</span>; <span class="comment">// 指向大块内存的指针</span></span><br><span class="line"><span class="type">size_t</span> _remainBytes = <span class="number">0</span>; <span class="comment">// 大块内存在切分过程中剩余字节数</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span>* _freeList = <span class="literal">nullptr</span>; <span class="comment">// 还回来过程中链接的自由链表的头指针</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="2-4-性能测试"><a href="#2-4-性能测试" class="headerlink" title="2.4 性能测试"></a>2.4 性能测试</h2><p>下面用循环申请内存的方式来测试一下这个定长内存池的效果。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ctime&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">TreeNode</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> _val;</span><br><span class="line">TreeNode* _left;</span><br><span class="line">TreeNode* _right;</span><br><span class="line"></span><br><span class="line"><span class="built_in">TreeNode</span>()</span><br><span class="line">:_val(<span class="number">0</span>)</span><br><span class="line">, _left(<span class="literal">nullptr</span>)</span><br><span class="line">, _right(<span class="literal">nullptr</span>)</span><br><span class="line">&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">const</span> <span class="type">size_t</span> Rounds = <span class="number">5</span>; <span class="comment">// 申请释放的轮次</span></span><br><span class="line"><span class="type">const</span> <span class="type">size_t</span> N = <span class="number">100000</span>; <span class="comment">// 每轮申请释放多少次</span></span><br><span class="line"></span><br><span class="line">std::vector&lt;TreeNode*&gt; v1;</span><br><span class="line">v1.<span class="built_in">reserve</span>(N);</span><br><span class="line"><span class="comment">// new的耗时测试</span></span><br><span class="line"><span class="type">size_t</span> begin1 = <span class="built_in">clock</span>();</span><br><span class="line"><span class="keyword">for</span> (<span class="type">size_t</span> j = <span class="number">0</span>; j &lt; Rounds; ++j)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; N; ++i)</span><br><span class="line">&#123;</span><br><span class="line">v1.<span class="built_in">push_back</span>(<span class="keyword">new</span> TreeNode);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; N; ++i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">delete</span> v1[i];</span><br><span class="line">&#125;</span><br><span class="line">v1.<span class="built_in">clear</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">size_t</span> end1 = <span class="built_in">clock</span>();</span><br><span class="line"></span><br><span class="line">std::vector&lt;TreeNode*&gt; v2;</span><br><span class="line">v2.<span class="built_in">reserve</span>(N);</span><br><span class="line"><span class="comment">// 定长内存池的耗时测试</span></span><br><span class="line">FixMemoryPool&lt;TreeNode&gt; TNPool;</span><br><span class="line"><span class="type">size_t</span> begin2 = <span class="built_in">clock</span>();</span><br><span class="line"><span class="keyword">for</span> (<span class="type">size_t</span> j = <span class="number">0</span>; j &lt; Rounds; ++j)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; N; ++i)</span><br><span class="line">&#123;</span><br><span class="line">v2.<span class="built_in">push_back</span>(TNPool.<span class="built_in">New</span>());</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; N; ++i)</span><br><span class="line">&#123;</span><br><span class="line">TNPool.<span class="built_in">Delete</span>(v2[i]);</span><br><span class="line">&#125;</span><br><span class="line">v2.<span class="built_in">clear</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">size_t</span> end2 = <span class="built_in">clock</span>();</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;new cost time:&quot;</span> &lt;&lt; end1 - begin1 &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;memory pool cost time:&quot;</span> &lt;&lt; end2 - begin2 &lt;&lt; endl;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用vs2019的x86-debug模式下运行，二者的时间消耗已经对比明显</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">new cost time:195</span><br><span class="line">memory pool cost time:100</span><br></pre></td></tr></table></figure><p>使用x86-release的模式运行，时间消耗差距就更大了</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">new cost time:21</span><br><span class="line">memory pool cost time:1</span><br></pre></td></tr></table></figure><p>这就是线程池存在的意义。</p><h1 id="3-整体框架设计"><a href="#3-整体框架设计" class="headerlink" title="3.整体框架设计"></a>3.整体框架设计</h1><p>简单实现了一个定长的内存池，下面就要学习一下如何实现一个高并发的内存池。谷歌的tcmalloc在多线程环境下会有更好的性能，我们模拟设计时也需要考虑相关的问题：</p><ul><li>性能应该优于malloc&#x2F;new；</li><li>多线程环境下竞争和锁申请问题；</li><li>内存碎片问题；</li></ul><p>最终的设计主要由下面三个部分构成</p><ol><li>ThreadCache：供每个线程独有，用于小于<code>256KB</code>的内存分配，因为每个线程独有一个ThreadCache，线程从这里申请内存时不需要加锁，效率高；</li><li>CentralCache：中心缓存供所有线程共享，ThreadCache按需从CentralCache中获取内存。CentralCache在合适的时候回收分配给线程的ThreadCache，避免某个线程占用太多未使用的内存，达到多个线程均衡调度的目的。CentralCache存在多线程竞争，需要加锁；</li><li>PageCache：以页为单位向操作系统申请内存。当CentralCache没有内存可分配时会向PageCache申请，PageCache会向操作系统申请一定的Page的内存放入<code>span</code>对象，这个大块内存会在<code>span</code>内部切割成多个定长大小的小块内存，最终给CentralCache的是<code>span</code>对象。当一个<code>span</code>的内部小块内存都被回收后，PageCache会回收CentralCache中满足条件的内存<code>span</code>对象，并合并相邻的页，组成更大的页，缓解内存碎片问题；</li></ol><p>下图是这个框架的示意</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/02/c03c4843d4f6b153fc536709b8864c05.png" alt="image-20240223160514186"></p><p>三层设计后，每一层的工作都不一样了</p><ul><li>ThreadCache：为线程分配空间；</li><li>CentralCache：为ThreadCache分配空间并回收部分空间；</li><li>PageCache：分页管理和向操作系统获取空间；</li></ul><p>其中，只有多个ThreadCache同时没内存需要向CentralCache申请的时候，才会出现<strong>加锁</strong>的问题。这种情况其实是不多的，所以CentralCache并不会有特别大的锁竞争问题。</p><p>而且，大部分情况下申请内存大小都不会大于256KB，所以ThreadCache是基本能满足线程申请空间的需求的。上述二者结合，就提高了多线程并发的效率。</p><h1 id="4-ThreadCache设计"><a href="#4-ThreadCache设计" class="headerlink" title="4.ThreadCache设计"></a>4.ThreadCache设计</h1><p>ThreadCache只对一个线程服务，它的设计思路和定长内存池其实是非常相似的。不过ThreadCache需要支持不定长内存的分配，需要对回收内存的FreeList做设计上的更正。</p><h2 id="4-1-哈希桶"><a href="#4-1-哈希桶" class="headerlink" title="4.1 哈希桶"></a>4.1 哈希桶</h2><p>为了更加方便的管理不同大小的内存空间申请，ThreadCache采用了哈希桶的方式，以一定空间为分割，链接不同大小的回收内存，类似多个不同大小的定长自由链表。</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/02/5a0502f4b16d03e0f207c0c4971da9bd.png" alt="image-20240224104548066"></p><p>当线程需要8字节以下空间时，就从8字节的桶里面分配给它；当进程需要8到16字节空间时，就从16字节的桶里面分配，以此类推。</p><p>很明显，这种方式会产生<strong>内碎片</strong>，比如申请5字节空间，ThreadCache还是会从8字节的桶中分配给它，出现了3字节的空间浪费。</p><p>但这个空间浪费是必须接受的，否则就需要用更加复杂的方式来管理回收的空间（比如在内存中记录自己的大小），分配的时候还需要遍历找到合适大小的内存来分配，效率反而会降低。</p><h2 id="4-2-分配映射规则"><a href="#4-2-分配映射规则" class="headerlink" title="4.2 分配映射规则"></a>4.2 分配映射规则</h2><p>但是，如果整个哈希桶都用8字节来做分割，最终整个哈希桶的数组部分就会非常非常长。<br>$$<br>256KB&#x2F;8B &#x3D; 32768<br>$$<br>所以，最终需要采用一个让内碎片尽量保持在10%左右的哈希映射算法。</p><table><thead><tr><th>字节区间</th><th>对齐方式</th><th>哈希桶下标区间</th></tr></thead><tbody><tr><td>[1, 128]</td><td>8B</td><td>[0,16)</td></tr><tr><td>[128+1, 1024]</td><td>16B</td><td>[16,72)</td></tr><tr><td>[1024+1, 8*1024]</td><td>128B</td><td>[72,128)</td></tr><tr><td>[8*1024+1, 64*1024]</td><td>1024B</td><td>[128,184)</td></tr><tr><td>[64*1024+1,256*1024]</td><td>8*1024B</td><td>[184,208)</td></tr></tbody></table><p>这个表的含义是，当字节范围在1到128之间时，哈希桶的每个下标对应的freelist内存大小相差<strong>8字节</strong>；当字节范围在129到1024字之间时，哈希桶每个下标对应的freelist内存大小相差<strong>16字节</strong>……</p><p>这样就可以控制内碎片在10%左右，以129字节到1024字节为例，最终映射的哈希桶如下图所示。</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/02/afba0bd136dbd8bed517f978195b3955.png" alt="image-20240226093850295"></p><p>当申请129到144字节之间的空间时，会分配144字节的内存块给线程。此时最大的空间浪费就是这<strong>144字节中只使用了129字节</strong>。浪费率大概是<code>10.5%</code>；其他区间的内碎片浪费率也是用这个方式计算。</p><p>注意：当我们考虑内碎片时，只考虑线程池设计会造成的内碎片问题，而不考虑线程本身申请了却不用造成的空间浪费（这是不可预期的，且和内存池的设计没有关系）。</p><h2 id="4-3-代码-分配内存大小"><a href="#4-3-代码-分配内存大小" class="headerlink" title="4.3 代码-分配内存大小"></a>4.3 代码-分配内存大小</h2><p>下面是<strong>某个对齐区间内</strong>，计算需要分配的空间大小的函数</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// size: 申请的块大小</span></span><br><span class="line"><span class="comment">// align: 当前对齐大小</span></span><br><span class="line"><span class="type">size_t</span> _RoundUp(<span class="type">size_t</span> size, <span class="type">size_t</span> align)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">size_t</span> returnSize;</span><br><span class="line">    <span class="keyword">if</span>(size % align == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        returnSize = size; <span class="comment">// 能直接模代表就是需要的最大值</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 其他，计算对齐区间内的最大值</span></span><br><span class="line">        returnSize = (size/align + <span class="number">1</span>) * align;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> returnSize;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用这个函数的逻辑计算，当我们需要申请130字节空间时（对齐大小是16字节，应该返回144字节），这个函数计算出来的结果也是144。<br>$$<br>returnSize &#x3D; (130&#x2F;16 +1) * 16 &#x3D; 144<br>$$<br>这个算法还有个更取巧的写法，用到了位运算，不好想不出来。位运算的效率会略高于乘除法，所以采用这种设计能提高一定的效率（已经是很深层的问题了）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">size_t</span> _RoundUp(<span class="type">size_t</span> size, <span class="type">size_t</span> align)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> ((size + align - <span class="number">1</span>) &amp; (~(align - <span class="number">1</span>)));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个算法是怎么实现的呢？以区间9到16为例（都需要分配16字节的空间），假设需要分配10字节空间</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">10 + 8 - 1 = 17</span><br><span class="line">align - 1 = 8-1 = 7</span><br><span class="line"></span><br><span class="line">7的二进制如下</span><br><span class="line">0000 0111</span><br><span class="line">7的二进制取反后</span><br><span class="line">1111 1000</span><br><span class="line">17的二进制</span><br><span class="line">0001 0001</span><br><span class="line"></span><br><span class="line">二者相与，得到的结果就是16</span><br><span class="line">1111 1000</span><br><span class="line">0001 0001</span><br><span class="line">——————————</span><br><span class="line">0001 0000</span><br></pre></td></tr></table></figure><p>这种牛逼的位运算方法我可想不出来……😣</p><p>有了单个对齐区间内计算大小的函数，剩下要做的就是把每个区间和对应的对齐大小给传参进入这个函数就行了</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">size_t</span> <span class="title">RoundUp</span><span class="params">(<span class="type">size_t</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(size &lt;= <span class="number">128</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> _RoundUp(size,<span class="number">8</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(size&lt;=<span class="number">1024</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> _RoundUp(size,<span class="number">16</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(size &lt;= (<span class="number">8</span>*<span class="number">1024</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> _RoundUp(size,<span class="number">128</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(size &lt;= (<span class="number">64</span>*<span class="number">1024</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> _RoundUp(size,<span class="number">1024</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(size &lt;= (<span class="number">256</span>*<span class="number">1024</span>))</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">return</span> _RoundUp(size,<span class="number">8</span>*<span class="number">1024</span>);  </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="comment">// 不是threadCache负责的范围了</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-4-代码-计算哈希下标"><a href="#4-4-代码-计算哈希下标" class="headerlink" title="4.4 代码-计算哈希下标"></a>4.4 代码-计算哈希下标</h2><p>除了计算需要分配的内存大小，还需要计算这个内存应该链接在哈希桶的哪一个下标。</p><ul><li>指定下标的freelist有剩余空间时直接分配；</li><li>如果没有，则从预先申请的大块内存中申请；</li></ul><p>单个区间内计算下标偏移量的方式如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// size: 申请的块大小</span></span><br><span class="line"><span class="comment">// align: 当前对齐大小</span></span><br><span class="line"><span class="type">size_t</span> _Index(<span class="type">size_t</span> size, <span class="type">size_t</span> align)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (size % align == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> size / align - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> size / align;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用位运算时可以采用另外一个巧妙的设计方式。将1左移<code>align_shift</code>位相当于计算2的<code>align_shift</code>次方；</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// align_shift是当前对齐大小是2的几次方，如果对齐大小是8，则传参3</span></span><br><span class="line"><span class="type">size_t</span> _Index(<span class="type">size_t</span> size, <span class="type">size_t</span> align_shift)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> ((size + (<span class="number">1</span> &lt;&lt; align_shift) - <span class="number">1</span>) &gt;&gt; align_shift) - <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用位运算的函数，最终的计算代码如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">size_t</span> <span class="title">Index</span><span class="params">(<span class="type">size_t</span> bytes)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">assert</span>(bytes &lt;= <span class="number">256</span>*<span class="number">1024</span>); <span class="comment">// 不能超出ThreadCache的最大服务范围</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 用数组表示每个区间有多少个链</span></span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> group_array[<span class="number">4</span>] = &#123; <span class="number">16</span>, <span class="number">56</span>, <span class="number">56</span>, <span class="number">56</span> &#125;;</span><br><span class="line">    <span class="keyword">if</span> (bytes &lt;= <span class="number">128</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> _Index(bytes, <span class="number">3</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (bytes &lt;= <span class="number">1024</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> _Index(bytes - <span class="number">128</span>, <span class="number">4</span>) + group_array[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (bytes &lt;= <span class="number">8</span> * <span class="number">1024</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> _Index(bytes - <span class="number">1024</span>, <span class="number">7</span>) + group_array[<span class="number">1</span>] + group_array[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (bytes &lt;= <span class="number">64</span> * <span class="number">1024</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> _Index(bytes - <span class="number">8</span> * <span class="number">1024</span>, <span class="number">10</span>) + group_array[<span class="number">2</span>] + group_array[<span class="number">1</span>] + group_array[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (bytes &lt;= <span class="number">256</span> * <span class="number">1024</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> _Index(bytes - <span class="number">64</span> * <span class="number">1024</span>, <span class="number">13</span>) + group_array[<span class="number">3</span>] + group_array[<span class="number">2</span>] + group_array[<span class="number">1</span>] + group_array[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;<span class="comment">// 不是threadCache负责的范围了</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-5-ThreadCache分配-x2F-回收内存"><a href="#4-5-ThreadCache分配-x2F-回收内存" class="headerlink" title="4.5 ThreadCache分配&#x2F;回收内存"></a>4.5 ThreadCache分配&#x2F;回收内存</h2><p>这部分比较简答，哈希桶对应的FreeList里面有就直接分配，没有就去找CentralCache要。</p><p>这里使用assert进行申请大小的判断，是因为ThreadCache不应该接受超过256KB的请求（如果出现了说明外部调用的代码的处理有问题）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="type">size_t</span> MAX_BYTES = <span class="number">256</span> * <span class="number">1024</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span>* <span class="title">ThreadCache::Allocate</span><span class="params">(<span class="type">size_t</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">assert</span>(size &lt;= MAX_BYTES);</span><br><span class="line"><span class="type">size_t</span> alignSize = <span class="built_in">RoundUp</span>(size); <span class="comment">// 计算大小</span></span><br><span class="line"><span class="type">size_t</span> index = <span class="built_in">Index</span>(size); <span class="comment">// 计算下标</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!_freeLists[index].<span class="built_in">Empty</span>())</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> _freeLists[index].<span class="built_in">Pop</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;<span class="comment">// 向centralcache申请内存</span></span><br><span class="line"><span class="keyword">return</span> <span class="built_in">FetchFromCentralCache</span>(index, alignSize);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ThreadCache::Deallocate</span><span class="params">(<span class="type">void</span>* ptr, <span class="type">size_t</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">assert</span>(ptr);</span><br><span class="line"><span class="built_in">assert</span>(size &lt;= MAX_BYTES);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 找对映射的自由链表桶，插入内存</span></span><br><span class="line"><span class="type">size_t</span> index = <span class="built_in">Index</span>(size); <span class="comment">// 计算下标</span></span><br><span class="line">_freeLists[index].<span class="built_in">Push</span>(ptr);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-6-TLS-线程局部变量"><a href="#4-6-TLS-线程局部变量" class="headerlink" title="4.6 TLS-线程局部变量"></a>4.6 TLS-线程局部变量</h2><h3 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h3><p>TLS的全称是Thread Local Storage，使用特殊的关键字来修饰一个变量，可以让这个变量变成一个只有某个线程可以访问的独立成员，其他线程无法访问。</p><p>比如我有个变量A，那么多个线程都会有一个自己的变量A，他们都可以访问这个A，但访问的并不是同一个，也就不涉及到加锁问题。</p><p>对于线程独有的ThreadCache而言，我们就可以使用这个特性来让每个线程独有一个变量，避免构建ThreadCache的时候还需要辨别当前线程号或加锁操作。</p><h3 id="windows"><a href="#windows" class="headerlink" title="windows"></a>windows</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> _declspec(thread) ThreadCache* TLSThreadCache = <span class="literal">nullptr</span>;</span><br></pre></td></tr></table></figure><p>这里使用<code>_declspec(thread)</code>就是windows平台下声明TLS变量的方式，加上static是为了避免在包含头文件的时候该全局变量声明被复制多次导致重复。</p><blockquote><p>微软官方文档：<a href="https://learn.microsoft.com/en-us/cpp/c-language/thread-local-storage?view=msvc-170&redirectedfrom=MSDN">https://learn.microsoft.com/en-us/cpp/c-language/thread-local-storage?view=msvc-170&amp;redirectedfrom=MSDN</a></p></blockquote><p>用下面的代码对TLS变量做一个简单的测试</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"></span><br><span class="line">_declspec(thread) <span class="type">int</span>* TLStest = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">auto</span> test_func = []() &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;before:%p\n&quot;</span>, TLStest);</span><br><span class="line"><span class="keyword">if</span> (TLStest == <span class="literal">nullptr</span>)</span><br><span class="line">&#123;</span><br><span class="line">TLStest = <span class="keyword">new</span> <span class="built_in">int</span>(<span class="number">10</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;after:%p\n&quot;</span>, TLStest);</span><br><span class="line">         <span class="keyword">delete</span> TLStest;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">std::thread <span class="title">t1</span><span class="params">(test_func)</span></span>;</span><br><span class="line"><span class="function">std::thread <span class="title">t2</span><span class="params">(test_func)</span></span>;</span><br><span class="line">t1.<span class="built_in">detach</span>();</span><br><span class="line">t2.<span class="built_in">join</span>();</span><br><span class="line">std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">seconds</span>(<span class="number">1</span>));</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用VS2019执行，输出结果如下所示，两个线程调用函数中的打印和初始化，能发现最终初始化出来的地址是不同的，而且<code>&amp;TLStest</code>的地址也不一样，说明TLStest变量被每个线程独有。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[before] TLStest:00000000  &amp;TLStest:00ACCEBC</span><br><span class="line">[after] TLStest:00ACE0E0  &amp;TLStest:00ACCEBC</span><br><span class="line">[before] TLStest:00000000  &amp;TLStest:00ACCDE4</span><br><span class="line">[after] TLStest:00ACE1D0  &amp;TLStest:00ACCDE4</span><br></pre></td></tr></table></figure><h3 id="Linux"><a href="#Linux" class="headerlink" title="Linux"></a>Linux</h3><p>在Linux下的线程本地存储可以用<code>__thread</code>关键字声明。但需要注意，这个关键字只能声明POD（内置类型），不能声明自定义的class对象。当然，自定义class的指针类型不在此列，因为<code>myclass*</code>这类指针类型始终是一个指针，属于C&#x2F;C++的内置类型。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">__thread <span class="type">int</span>* TLStest = <span class="literal">nullptr</span>;</span><br></pre></td></tr></table></figure><p>Linux下上述代码的测试结果，和windows下的效果类似。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">❯ g++ test.cpp  -o test1 &amp;&amp; ./test1</span><br><span class="line">[before] TLStest:(nil)  &amp;TLStest:0x7f63315cd638</span><br><span class="line">[after] TLStest:0x7f632c000f80  &amp;TLStest:0x7f63315cd638</span><br><span class="line">[before] TLStest:(nil)  &amp;TLStest:0x7f6330dcc638</span><br><span class="line">[after] TLStest:0x7f632c000f80  &amp;TLStest:0x7f6330dcc638</span><br></pre></td></tr></table></figure><h3 id="备注"><a href="#备注" class="headerlink" title="备注"></a>备注</h3><p>windows和linux下线程局部变量会有自己的存放位置和存放的地址，但有一个问题是，这些<strong>线程局部变量的地址</strong>是全进程共享的。</p><p>假设线程A知道了线程B的局部变量的地址，那么线程A就可以访问并修改它！因为这个地址是在进程地址空间中的，整个进程共享！</p><h1 id="5-CentralCache设计"><a href="#5-CentralCache设计" class="headerlink" title="5.CentralCache设计"></a>5.CentralCache设计</h1><h2 id="5-1-span跨度页"><a href="#5-1-span跨度页" class="headerlink" title="5.1 span跨度页"></a>5.1 span跨度页</h2><p>CentralCache的主体也采用了和ThreadCache类似的哈希桶的数据结构，但是CentralCache的哈希桶下面链接的不是内存碎片，而是包含一个大块内存的span对象（跨度页）。</p><p>在CentralCache的哈希桶中，8字节的桶链接的是<strong>内部内存被拆分成8字节小块</strong>的Span对象。</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/02/cecdd3677b008340b43ad7cdd1c05647.png" alt="image-20240228092725430"></p><p>Span对象的基本成员如下所示，在win32环境下，一个Span对象是32字节。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _WIN64</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> PAGE_ID;</span><br><span class="line"><span class="meta">#<span class="keyword">elif</span> _WIN32</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">size_t</span> PAGE_ID;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Span</span>&#123;</span><br><span class="line">    PAGE_ID _pageId; <span class="comment">//页号</span></span><br><span class="line">    <span class="type">size_t</span> _n; <span class="comment">//页的数量</span></span><br><span class="line">    </span><br><span class="line">    Span* _next = <span class="literal">nullptr</span>;</span><br><span class="line">    Span* _prev = <span class="literal">nullptr</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="type">void</span>* _list = <span class="literal">nullptr</span>; <span class="comment">// 链接span拆分的小块内存</span></span><br><span class="line">    <span class="type">size_t</span> _useCount = <span class="number">0</span>; <span class="comment">// 使用数量，为0代表没有被使用</span></span><br><span class="line">    </span><br><span class="line">    <span class="type">size_t</span> _objSize; <span class="comment">// 拆分的小块内存的大小</span></span><br><span class="line">    </span><br><span class="line">    <span class="type">bool</span> _isUse = <span class="literal">false</span>; <span class="comment">// 是否在占用</span></span><br><span class="line">    <span class="comment">// 当Span被分配给CentralCache后设置为true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对这个对象做一定说明</p><ul><li>假设我们给定一个Span包含512KB的内存（内存是由PageCache申请的）；</li><li>那么8B的Span就是将这个512KB拆分成8B链接在Span对象内部的list中</li><li>256KB的Span就是将512KB拆分成两个256KB链接在Span对象内部的list中</li><li>当ThreadCache申请内存时，会从对应哈希桶下标位置的第一个Span对象中分配内存给它，如果第一个Span对象没有剩余内存了，就往后找第二个Span对象申请内存来分配给ThreadCache；</li><li>当一个Span的useCount为0时，说明这个Span内部的内存都是没有被使用的，它可以被PageCache回收；</li><li>PageCache根据Span中的pageID来确定它的<strong>页号</strong>，可以和相邻页号的Span内存合并成更大的内存，暂为管理或释放给操作系统，一定程度上缓解内存碎片问题。</li></ul><p>你可能会有一个疑问，Span对象中似乎没有用于存放大块内存的指针（内部的list并不是用来存大块内存起始地址的，而需要CentralCache来制作<strong>内存链表</strong>），当PageCache分配给CentralCache的时候，CentralCache要怎么知道这个Span的起始地址呢？</p><ul><li><strong>页号</strong>是直接用内存地址强转成整形，除以8KB来计算的；</li><li>只需要将页号乘以8KB（即<code>8*1024</code>），就能得到这个Span所对应的内存起始地址；</li><li><strong>页号+页的数量</strong>即可得到内存最后一页的起始地址，再加上8KB即为大块内存的末尾；</li></ul><p>用这种方式，我们就节省了一个多余的指针。页号+页的数量也是后续PageCache回收内存时辨别两个Span对象所保存的页是否相邻的重要判据。</p><h2 id="5-2-桶锁"><a href="#5-2-桶锁" class="headerlink" title="5.2 桶锁"></a>5.2 桶锁</h2><p>为了进一步细化锁的粒度，CentralCache采用桶锁的设计，即每个不同大小的哈希桶下标都会有一个对应的锁</p><ul><li>线程A向CentralCache申请16B内存，线程B向CentralCache申请128KB内存，二者不在同一个哈希桶下标位置，所以不存在竞争也不需要加锁；</li><li>线程A和线程B都向CentralCache申请16B内存，此时需要加锁；</li></ul><p>定义桶锁比较简单，因为Span需要一个单独的List来管理（不能使用原本定长内存池里面的freelist对象了），我们在单独实现的SpanList里面加一个mutex，POP和PUSH的时候加锁&#x2F;解锁就可以了。</p><h2 id="5-3-向PageCache申请-x2F-释放内存"><a href="#5-3-向PageCache申请-x2F-释放内存" class="headerlink" title="5.3 向PageCache申请&#x2F;释放内存"></a>5.3 向PageCache申请&#x2F;释放内存</h2><p>当CentralCache中的桶没有指定大小Span的时候，就需要去PageCache中申请内存。申请时需要给定申请的大小，随后PageCache会将包含对应大小内存的Span对象返还给CentralCache，由CentralCache来负责将这块内存切成小块并链接Span内部的list。</p><p>当某个Span对象下useCount为0的时候，CentralCache就可以将其归还给PageCache。</p><h2 id="5-4-申请内存的数量限制"><a href="#5-4-申请内存的数量限制" class="headerlink" title="5.4 申请内存的数量限制"></a>5.4 申请内存的数量限制</h2><p>ThreadCache申请内存的时候会有一个“慢开始”的调节算法。即申请的时候，会略微申请多一些，但也不能一次性申请太多，否则很有可能用不完。</p><ul><li>当申请内存的size大的时候，一次向CentralCache申请的内存数量就越少（多少个size的内存）</li><li>当申请内存的size小的时候，一次向CentralCache申请的内存数量就会多一些</li></ul><p>每申请一次内存，就将对应FreeList的<strong>阈值</strong>调高一些，这样内存池刚启动的时候，申请的内存就会少一些，运行一段时间后，认为系统对内存的需求会更加频繁，一次要的内存就会多一些。</p><h2 id="5-5-回收ThreadCache中的内存"><a href="#5-5-回收ThreadCache中的内存" class="headerlink" title="5.5 回收ThreadCache中的内存"></a>5.5 回收ThreadCache中的内存</h2><p>因为ThreadCache是用freelist来管理内存的，所以CentralCache的回收接口也是以一个链表的区间来回收。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">ReleaseListToSpans</span><span class="params">(<span class="type">void</span>* start, <span class="type">size_t</span> size)</span></span>;</span><br></pre></td></tr></table></figure><p>当ThreadCache检测到当前某个哈希桶对应的freelist长度已经大于一次性会申请的内存长度（上文提到的FreeList<strong>阈值</strong>）时，就会释放一部分内存给CentralCache。这种情况说明ThreadCache保存的内存已经有点多了，可能会用不完。</p><h1 id="6-PageCache设计"><a href="#6-PageCache设计" class="headerlink" title="6.PageCache设计"></a>6.PageCache设计</h1><h2 id="6-1-基本架构"><a href="#6-1-基本架构" class="headerlink" title="6.1 基本架构"></a>6.1 基本架构</h2><p>PageCache的哈希桶和CentralCache基本一致，都是链接的Span对象，只不过PageCache中是通过页面数量作为哈希下标的选址的。</p><p>比如一个Span中有2页，那么它就会被映射到下标为2的哈希桶中（只不过这样会导致下标为0的哈希桶空置，也可以在哈希函数里面将页面数量减一来避免这个浪费）</p><p>除了哈希桶外，PageCache中还有一个<code>unordered_map</code>用于映射页号和Span对象地址，这样能让后续PageCache回收Span的时候，更快地找到这个Span<strong>页号相邻</strong>的其他Span对象的地址。</p><p>注意，这个<code>unordered_map</code>中需要映射<strong>一个Span对应的所有页号</strong>和Span地址的对应关系，不能只保存起始页号和Span地址的关系。</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/02/9bab99b19e081adbb08dbbdc4e2fd414.png" alt="image-20240229104149463"></p><h2 id="6-2-申请内存"><a href="#6-2-申请内存" class="headerlink" title="6.2 申请内存"></a>6.2 申请内存</h2><p>当PageCache的哈希桶中没有剩余Span时，就会向操作系统申请内存。</p><p>PageCache将以8KB为一个页，去向操作系统申请内存。且为了提高申请内存的效率，会直接使用系统底层接口来获取内存（Windows下VirutalAlloc，Linux下btk和mmap）</p><p>申请内存后，PageCache会new一个Span对象，并设置对应的页号和页的起始地址。随后是设置ID和Span对象地址的关系，并将Span返回给CentralCache。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// k是页的个数</span></span><br><span class="line"><span class="type">void</span>* ptr = <span class="built_in">SystemAlloc</span>(k); <span class="comment">// 向系统申请内存</span></span><br><span class="line">Span* span = <span class="keyword">new</span> Span;      <span class="comment">// 获取一个Span对象</span></span><br><span class="line">span-&gt;_pageId = (PAGE_ID)ptr &gt;&gt; <span class="number">13</span>; <span class="comment">// 相当于除以8KB，得到页号</span></span><br><span class="line">span-&gt;_n = k; <span class="comment">//设置页的个数</span></span><br></pre></td></tr></table></figure><h3 id="优化方式"><a href="#优化方式" class="headerlink" title="优化方式"></a>优化方式</h3><p>当然，这里还有一个不太合适的地方。对于一个高并发的内存池而言，我们预期应该是会<strong>有很多个Span对象的构建</strong>的（即便我们最终的测试环境可能达不到这个并发量），所以这里应该将<code>new Span</code>改成使用上文提到的<strong>定长内存池</strong>来处理，可以在PageCache初始化的时候就申请一部分内存，供未来新建Span对象的时候使用。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Span* span = _spanPool.<span class="built_in">New</span>();<span class="comment">// 使用定长内存池来分配内存</span></span><br></pre></td></tr></table></figure><p>只需要在PageCache中包括一个<strong>定长内存池</strong>的对象即可。</p><h2 id="6-3-分配内存"><a href="#6-3-分配内存" class="headerlink" title="6.3 分配内存"></a>6.3 分配内存</h2><p>分配内存的流程如下</p><ol><li>判断哈希桶中对应页面大小的Span是否存在，存在直接分配；</li><li>不存在则向操作系统申请内存，而且每次都会按<strong>最大页面</strong>来申请（最大页128）；</li><li>申请大块内存后，将其拆分成一个CentralCache需要的Span和另外一个剩余的Span；</li><li>将剩余的Span放入哈希表，CentralCache需要的Span返回；</li></ol><p>上述步骤中的第三步就是<strong>拆分大Span对象</strong>的情况，比如当10页的Span没有时，将一个128页的Span拆分成10页和118页的。这时候，一个线程可能会访问PageCache中哈希桶<strong>多个下标位置</strong>的元素，所以PageCache不能采用桶锁，而采用<strong>全局锁</strong>（访问PageCache的时候加锁，访问结束解锁）。</p><p>另外，<strong>拆分Span对象</strong>是一个频率比较高的动作，这也是为什么PageCache中会出现多个可以进行合并的相邻页面的Span对象。</p><p>如果PageCache中不是一次性申请最大页面的内存，而是按需申请，此时操作系统给定的内存很大概率和之前的<strong>并不是相邻</strong>的，那PageCache自然就没有办法“合并相邻页面”，这也会导致操作系统中内存外碎片较多，且难以处理。</p><h2 id="6-4-回收和合并"><a href="#6-4-回收和合并" class="headerlink" title="6.4 回收和合并"></a>6.4 回收和合并</h2><p>回收是CentralCache在Span中useCount为0的时候触发的，会将这个Span归还给PageCache。</p><p>PageCache收到一个Span后，需要进行合并操作</p><ul><li>从<code>unordered_map</code>中查找前一页的Span（当前页号减一），如果存在，判断是否可以进行合并；</li><li>查找后续的Span（当前页号加上页面数量再加一），如果存在，判断是否可以进行合并；</li></ul><p>因为这个<code>unordered_map</code>只在合并的时候需要使用，且每次合并时的查询操作都是当前span的页号减一，和当前span末尾页号+1，所以我们只需要给<code>unoreder_map</code>中设置<strong>当前页号以及末尾页号</strong>对应的span对象地址就行了！节省空间。</p><blockquote><p>为了保险起见和方便理解，项目中我还是采用了<strong>遍历页号范围设置全部</strong>的方式，这样能避免出现问题😂但会有空间浪费和效率损失。</p></blockquote><p>合并Span需要满足下面几个条件：</p><ul><li>Span的isUse为false，即这个Span是处于PageCache中暂未分配的</li><li>Span的页面数量加上当前Span的页面数量不超过128（超过后会超出哈希桶的下标，无法管理，自然不能合并）</li></ul><p>合并操作比较简单</p><ul><li>如果是合并前一个Span，将前一个Span的页面数量加上当前Span的页面数量即可；</li><li>如果是合并后一个Span，将当前Span的页面数量加上后一个Span的页面数量即可；</li><li>合并后要将<strong>被合并的Span对象</strong>释放，并将合并后的Span对象的isUse设置为false；</li><li>将合并后的Span对象更换正确的哈希桶下标位置链接（因为包含的页面数量改变了）；</li><li>修改<code>unodered_map</code>中的页号和Span对象地址的映射表；</li></ul><h2 id="6-5-超出256KB的内存申请"><a href="#6-5-超出256KB的内存申请" class="headerlink" title="6.5 超出256KB的内存申请"></a>6.5 超出256KB的内存申请</h2><p>因为低于256KB的内存都能被ThreadCache来处理，所以256KB也算是个分水岭。而PageCache中哈希桶最大的下标是128，即最大能托管的Span是1MB的内存，超出1MB的内存就得直接向操作系统申请了。</p><p>此时向内存池申请内存的流程会变成下面这样：</p><ul><li>申请低于256KB的调用ThreadCache的接口（包括分配和回收）；</li><li>大于256KB的调用PageCache的接口（包括分配和回收）；</li><li>当PageCache检测到申请的内存大于128Page的时候，直接向系统申请内存并返回；</li><li>当PageCache检测到回收的内存大于128Page的时候，直接释放给操作系统；</li></ul><p>到这里，内存池的主题框架就全部成型了，后续要做的就是性能测试和优化了。</p><h2 id="6-6-SpanList和子类"><a href="#6-6-SpanList和子类" class="headerlink" title="6.6 SpanList和子类"></a>6.6 SpanList和子类</h2><p>因为只有CentralCache需要用到桶锁，而PageCache同意需要使用SpanList，<strong>为了节省一定空间</strong>（PageCache的SpanList中的锁是没用的），CentralCache我使用了继承自父类SpanList的另外一个类型，在里面添加了一个mutex锁。</p><p>在32位windows环境下，mutex类的大小是48字节，128个SpanList，还是能节省一定空间的。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">std::mutex mtx;</span><br><span class="line">cout &lt;&lt; <span class="built_in">sizeof</span>(mtx) &lt;&lt; endl; <span class="comment">// 32位下是48字节</span></span><br></pre></td></tr></table></figure><h1 id="7-测试"><a href="#7-测试" class="headerlink" title="7.测试"></a>7.测试</h1><h2 id="7-1-申请和释放函数"><a href="#7-1-申请和释放函数" class="headerlink" title="7.1 申请和释放函数"></a>7.1 申请和释放函数</h2><p>虽然写了三成的设计，但是申请和释放函数并不能直接调用ThreadCache的函数，还需要另外一个函数来进行ThreadCache的构造，以及大于256KB内存的处理。</p><p>这里有个复用设计，即将PageCache中的页号对应Span对象指针的映射的<code>unordered_map</code>来确定当前申请的内存的<strong>大小</strong>，这样就不需要用户主动传入参数了（主动传入容易出现内存泄漏和处理问题）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span>* <span class="title">ConcurrentAlloc</span><span class="params">(<span class="type">size_t</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (size &gt; MAX_SIZE)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">size_t</span> alignSize = SizeClass::<span class="built_in">RoundUp</span>(size);</span><br><span class="line">        <span class="type">size_t</span> kpage = alignSize &gt;&gt; PAGE_SHIFT;</span><br><span class="line"></span><br><span class="line">        PageCache::<span class="built_in">GetInstance</span>()-&gt;<span class="built_in">Lock</span>();</span><br><span class="line">        Span* span = PageCache::<span class="built_in">GetInstance</span>()-&gt;<span class="built_in">NewSpan</span>(kpage);</span><br><span class="line">        span-&gt;_objSize = size; <span class="comment">// 申请大内存没有拆分</span></span><br><span class="line">        PageCache::<span class="built_in">GetInstance</span>()-&gt;<span class="built_in">Unlock</span>();</span><br><span class="line"></span><br><span class="line">        <span class="type">void</span>* ptr = (<span class="type">void</span>*)(span-&gt;_pageId &lt;&lt; PAGE_SHIFT);</span><br><span class="line">        <span class="keyword">return</span> ptr;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 因为是线程局部变量，所以不需要加锁</span></span><br><span class="line">        <span class="keyword">if</span> (TLSThreadCache == <span class="literal">nullptr</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 这里的static变量是全局可见的</span></span><br><span class="line">            <span class="type">static</span> FixedMemoryPool&lt;ThreadCache&gt; tcPool; </span><br><span class="line">            TLSThreadCache = tcPool.<span class="built_in">New</span>();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> TLSThreadCache-&gt;<span class="built_in">Allocate</span>(size);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">ConcurrentFree</span><span class="params">(<span class="type">void</span>* ptr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Span* span = PageCache::<span class="built_in">GetInstance</span>()-&gt;<span class="built_in">MapObjectToSpan</span>(ptr);</span><br><span class="line">    <span class="type">size_t</span> size = span-&gt;_objSize;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (size &gt; MAX_SIZE)</span><br><span class="line">    &#123;</span><br><span class="line">        PageCache::<span class="built_in">GetInstance</span>()-&gt;<span class="built_in">Lock</span>();</span><br><span class="line">        PageCache::<span class="built_in">GetInstance</span>()-&gt;<span class="built_in">ReleaseSpanToPageCache</span>(span);</span><br><span class="line">        PageCache::<span class="built_in">GetInstance</span>()-&gt;<span class="built_in">Unlock</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">assert</span>(TLSThreadCache);</span><br><span class="line">        TLSThreadCache-&gt;<span class="built_in">Deallocate</span>(ptr, size);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="7-2-单线程申请"><a href="#7-2-单线程申请" class="headerlink" title="7.2 单线程申请"></a>7.2 单线程申请</h2><p>用下面的代码测试，环境是windows x64；</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">TestNormalAlloc</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">void</span>* p1 = <span class="built_in">ConcurrentAlloc</span>(<span class="number">6</span>);</span><br><span class="line"><span class="type">void</span>* p2 = <span class="built_in">ConcurrentAlloc</span>(<span class="number">8</span>);</span><br><span class="line"><span class="type">void</span>* p3 = <span class="built_in">ConcurrentAlloc</span>(<span class="number">12</span>);</span><br><span class="line"><span class="type">void</span>* p4 = <span class="built_in">ConcurrentAlloc</span>(<span class="number">7000</span>);</span><br><span class="line"><span class="type">void</span>* p5 = <span class="built_in">ConcurrentAlloc</span>(<span class="number">10</span>);</span><br><span class="line"><span class="type">void</span>* p6 = <span class="built_in">ConcurrentAlloc</span>(<span class="number">800</span>);</span><br><span class="line"><span class="type">void</span>* p7 = <span class="built_in">ConcurrentAlloc</span>(<span class="number">30</span>);</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; p1 &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; p2 &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; p3 &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; p4 &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; p5 &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; p6 &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; p7 &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="built_in">ConcurrentFree</span>(p1);</span><br><span class="line"><span class="built_in">ConcurrentFree</span>(p2);</span><br><span class="line"><span class="built_in">ConcurrentFree</span>(p3);</span><br><span class="line"><span class="built_in">ConcurrentFree</span>(p4);</span><br><span class="line"><span class="built_in">ConcurrentFree</span>(p5);</span><br><span class="line"><span class="built_in">ConcurrentFree</span>(p6);</span><br><span class="line"><span class="built_in">ConcurrentFree</span>(p7);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试结果如下，释放和申请都没有问题</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">000001A864B20000</span><br><span class="line">000001A864B20008</span><br><span class="line">000001A864B22000</span><br><span class="line">000001A864B24000</span><br><span class="line">000001A864B22010</span><br><span class="line">000001A864B62000</span><br><span class="line">000001A864BA0000</span><br></pre></td></tr></table></figure><h2 id="7-3-多线程申请"><a href="#7-3-多线程申请" class="headerlink" title="7.3 多线程申请"></a>7.3 多线程申请</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">MultiThreadAlloc1</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">std::vector&lt;<span class="type">void</span>*&gt; v;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">50</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">void</span>* ptr = <span class="built_in">ConcurrentAlloc</span>(<span class="number">6</span>);</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;1 - &quot;</span> &lt;&lt; std::this_thread::<span class="built_in">get_id</span>() &lt;&lt; <span class="string">&quot; - &quot;</span> &lt;&lt; ptr &lt;&lt; endl;</span><br><span class="line">v.<span class="built_in">push_back</span>(ptr);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> e : v)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">ConcurrentFree</span>(e);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">catch</span> (...)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;error in MultiThreadAlloc1\n&quot;</span>;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MultiThreadAlloc2</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">std::vector&lt;<span class="type">void</span>*&gt; v;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">50</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">void</span>* ptr = <span class="built_in">ConcurrentAlloc</span>(<span class="number">20</span>);</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;2 - &quot;</span> &lt;&lt; std::this_thread::<span class="built_in">get_id</span>() &lt;&lt; <span class="string">&quot; - &quot;</span> &lt;&lt; ptr &lt;&lt; endl;</span><br><span class="line">v.<span class="built_in">push_back</span>(ptr);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> e : v)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">ConcurrentFree</span>(e);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">catch</span> (...)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;error in MultiThreadAlloc2\n&quot;</span>;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试多线程处理是否有问题</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">TestMultiThread</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="function">std::thread <span class="title">t1</span><span class="params">(MultiThreadAlloc1)</span></span>;</span><br><span class="line"><span class="function">std::thread <span class="title">t2</span><span class="params">(MultiThreadAlloc2)</span></span>;</span><br><span class="line"></span><br><span class="line">t1.<span class="built_in">detach</span>();</span><br><span class="line">t2.<span class="built_in">join</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>也没啥问题</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">1 - 34788 - 0000019E47920000</span><br><span class="line">2 - 14252 - 0000019E47922000</span><br><span class="line">1 - 34788 - 0000019E47920008</span><br><span class="line">1 - 34788 - 0000019E47920010</span><br><span class="line">2 - 14252 - 0000019E47922018</span><br><span class="line">1 - 34788 - 0000019E47920018</span><br><span class="line">2 - 14252 - 0000019E47922030</span><br><span class="line">1 - 34788 - 0000019E47920020</span><br><span class="line">1 - 34788 - 0000019E47920028</span><br><span class="line">1 - 34788 - 0000019E47920030</span><br><span class="line">1 - 34788 - 0000019E47920038</span><br><span class="line">1 - 34788 - 0000019E47920040</span><br><span class="line">1 - 34788 - 0000019E47920048</span><br><span class="line">2 - 14252 - 0000019E47922048</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>注意，进行多线程测试的时候，一定要保证主线程退出时间<strong>晚于子线程</strong>（比如在<code>thread.join()</code>之后加sleep)，避免出现主线程提前退出的情况，这会导致子线程里面的<strong>打印不输出</strong>，或者其他的一些错误。</p><h2 id="7-4-定长内存池段错误解决"><a href="#7-4-定长内存池段错误解决" class="headerlink" title="7.4 定长内存池段错误解决"></a>7.4 定长内存池段错误解决</h2><p>刚开始运行的时候，<strong>多线程经常遇到段错误问题</strong>，而且不是每次都会出现。</p><blockquote><p>一般遇到这种不是每次都会出现的段错误，就可以考虑是否为<strong>多线程并发问题</strong>了。</p></blockquote><p>后来审查了一下，发现问题所在是申请内存函数中的ThreadCache初始化部分</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 通过TLS 每个线程无锁的获取自己的专属的ThreadCache对象</span></span><br><span class="line"><span class="keyword">if</span> (TLSThreadCache == <span class="literal">nullptr</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">static</span> FixedMemoryPool&lt;ThreadCache&gt; tcPool; <span class="comment">// 这里的static变量是全局可见的</span></span><br><span class="line">    TLSThreadCache = tcPool.<span class="built_in">New</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在初始化部分这里，设置了一个static的定长内存池，对于所有线程都是可见的。这时候就会出现多线程并发的问题（两个线程同时访问一个定长内存池）。</p><p>在PageCache中的Span定长内存池，<strong>因为访问PageCache的时候已经加过锁了</strong>，所以不会出现并发问题，但是这里的ThreadCache初始化时并没有加锁，就会出现多线程访问问题。</p><p>解决方案：</p><ol><li>在定长内存池中加上一个mutex成员，并进行加锁解锁操作；</li><li>在申请内存初始化ThreadCache的部分添加一个锁，并进行加锁解锁操作；</li></ol><p>采用第一种方式设置完毕后，连续运行了十几次，都没有再出现段错误问题了。</p><p>后续为了优化性能，我改为了第二种方式。因为PageCache中访问Span对象的定长内存池的加锁是无意义的，会有额外性能损失。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 通过TLS 每个线程无锁的获取自己的专属的ThreadCache对象</span></span><br><span class="line"><span class="keyword">if</span> (TLSThreadCache == <span class="literal">nullptr</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// C++11后static变量初始化时线程安全</span></span><br><span class="line">    <span class="type">static</span> FixedMemoryPool&lt;ThreadCache&gt; tcPool; <span class="comment">// 这里的static变量是全局可见的</span></span><br><span class="line">    <span class="comment">// 在new之前加锁就可以了</span></span><br><span class="line">    <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lockGuard</span><span class="params">(TLSThreadCacheMtx)</span></span>;</span><br><span class="line">    TLSThreadCache = tcPool.<span class="built_in">New</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="8-Linux下接口补全"><a href="#8-Linux下接口补全" class="headerlink" title="8.Linux下接口补全"></a>8.Linux下接口补全</h1><p>前文所述的接口都是在Windows下使用的，下面要对Linux中与Windows不一致的地方进行补全。</p><h2 id="8-1-PageID的typedef"><a href="#8-1-PageID的typedef" class="headerlink" title="8.1 PageID的typedef"></a>8.1 PageID的typedef</h2><p>之前在Windows下是用<code>_WIN32</code>和<code>_WIN64</code>这两个宏来确定平台是32位还是64位的，但是Linux下没有类似的宏。最终采用如下方式来确认Linux下平台的位数</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 因为64位和32位中内存地址的长度不一样，所以对应类型也得不一样</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _WIN64 <span class="comment">// 64位的win才会有这个宏</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> PageID;</span><br><span class="line"><span class="meta">#<span class="keyword">elif</span> _WIN32 <span class="comment">// 32和64位的win都会有这个宏</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">size_t</span> PageID;</span><br><span class="line"><span class="comment">// 后续还需要插入一些Linux的宏</span></span><br><span class="line"><span class="meta">#<span class="keyword">elif</span> __linux__</span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> __WORDSIZE == 64 <span class="comment">// 64位的Linux</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> PageID;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span> <span class="comment">// 32位的Linux</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">size_t</span> PageID;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>这里使用了<code>__WORDSIZE</code>这个宏，它其实比较通用，含义是当前平台下指针的大小（单位是比特），32位平台下指针是32比特4字节，64位平台下指针是64比特8字节。</p><h2 id="8-2-mmap申请和释放内存"><a href="#8-2-mmap申请和释放内存" class="headerlink" title="8.2 mmap申请和释放内存"></a>8.2 mmap申请和释放内存</h2><p>在Linux下使用mmap和munmap两个接口来申请和释放内存，具体使用方式参考man手册。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"> <span class="type">void</span> *<span class="title function_">mmap</span><span class="params">(<span class="type">void</span> *addr, <span class="type">size_t</span> length, <span class="type">int</span> prot, <span class="type">int</span> flags,</span></span><br><span class="line"><span class="params">            <span class="type">int</span> fd, <span class="type">off_t</span> offset)</span>;</span><br><span class="line"> <span class="type">int</span> <span class="title function_">munmap</span><span class="params">(<span class="type">void</span> *addr, <span class="type">size_t</span> length)</span>;</span><br></pre></td></tr></table></figure><p>mmap的参数说明：</p><ul><li>第一个参数addr: 指定需要申请的内存在操作系统中的偏移量，设置为NULL让操作系统自行选择；</li><li>第二个参数length: 指定申请内存的比特数</li><li>第三个参数prot: 指定申请内存的权限（读写）</li><li>第四个参数flags: 指定申请内存的方式</li><li>第五个参数fd: 申请的内存是否需要和某个文件描述符绑定，<code>-1</code>代表不绑定；</li><li>第六个参数offset：指定偏移，对于匿名映射通常设置为0；</li></ul><p>释放内存的munmap接口就比较简单了，传入内存的指针和长度就可以了。</p><p>示例代码如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">size_t</span> bytes = <span class="number">1000</span>;</span><br><span class="line"><span class="comment">// PROT_READ | PROT_WRITE 指定读写权限</span></span><br><span class="line"><span class="comment">// MAP_PRIVATE | MAP_ANONYMOUS 私有和匿名映射</span></span><br><span class="line"><span class="type">void</span> *ptr = <span class="built_in">mmap</span>(<span class="literal">NULL</span>, bytes, PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_ANONYMOUS, <span class="number">-1</span>, <span class="number">0</span>);</span><br><span class="line"><span class="comment">// 释放</span></span><br><span class="line"><span class="built_in">munmap</span>(ptr, bytes);</span><br></pre></td></tr></table></figure><p>因为windows下的VirtualFree并不需要传入长度，所以在Linux中改造内存池的时候，还需要一个map来存放指针其实地址和长度的关系，保证释放的时候能按正确的内存长度进行释放。</p><h2 id="8-3-TLS变量"><a href="#8-3-TLS变量" class="headerlink" title="8.3 TLS变量"></a>8.3 TLS变量</h2><p>这一点前文已经提到过区别，Linux下和Windows的代码有一定差异。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _WIN32</span></span><br><span class="line"><span class="type">static</span> _declspec(thread) ThreadCache *TLSThreadCache = <span class="literal">nullptr</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">elif</span> __linux__</span></span><br><span class="line"><span class="type">static</span> __thread ThreadCache *TLSThreadCache = <span class="literal">nullptr</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><h2 id="8-4-系统内存分配和释放地址不一致问题（未解决）"><a href="#8-4-系统内存分配和释放地址不一致问题（未解决）" class="headerlink" title="8.4 系统内存分配和释放地址不一致问题（未解决）"></a>8.4 系统内存分配和释放地址不一致问题（未解决）</h2><p>当直接申请大块内存（比如2000KB）的时候，PageCache会调用SystemAlloc函数，不使用malloc&#x2F;new而直接调用系统接口来申请大块内存。</p><p>这里就出现了问题，申请内存的时候，操作系统返回的内存并不是严格按我们预定的8KB页来起始的，比如下面的<code>0xf7617000</code>这个地址；</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">alloc ptr: 0xf7617000 - 2048000</span><br><span class="line">2000KB: 0xf7616000</span><br><span class="line">free ptr: 0xf7616000</span><br></pre></td></tr></table></figure><p>将<code>0xf7617000</code>除以8KB再乘以8KB，得到的结果是<code>0xf7616000</code>，和原本分配的内存不一致！因为PageCache中申请内存的时候会将其<strong>按页号</strong>来保存在Span对象里面，但操作系统返回的内存<strong>并不一定是某个页的起始地址</strong>！</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/03/0dcaaceac0ccd22bad9f571d1edfe42c.png" alt="image-20240304130129640"></p><p>而且会发现最终调用方得到的内存是<code>0xf7616000</code>，这个地址小于操作系统分配给我们的<code>0xf7617000</code>，如果直接访问，会访问到并不属于当前已分配内存的部分，直接段错误！</p><p>这个问题大概率是由Windows和Linux下系统调用接口的不同设计导致的，因为windows下不管是用x86和x64都没有复现出这个问题（在Linux下会有60%的几率出现该问题）</p><p>而且该问题影响的不只是超过1MB的大内存申请，PageCache申请内存的时候也有可能会遇到系统调用接口返回的内存并非按8KB对齐的情况，最终导致段错误。</p><p>由于这不是线程池设计中的重点，也和线程池本身的思路没有关系，所以暂时挂起不去深究，<strong>继续在Windows上以32位对线程池进行优化</strong>。</p><h1 id="9-性能问题"><a href="#9-性能问题" class="headerlink" title="9.性能问题"></a>9.性能问题</h1><h2 id="9-1-简单测试"><a href="#9-1-简单测试" class="headerlink" title="9.1 简单测试"></a>9.1 简单测试</h2><p>使用下面的代码，在多线程环境下分别测试线程池申请和malloc申请内存的耗时</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">MultiThreadAlloc2</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">std::vector&lt;<span class="type">void</span>*&gt; v1;</span><br><span class="line">std::vector&lt;<span class="type">void</span>*&gt; v2;</span><br><span class="line"></span><br><span class="line"><span class="type">size_t</span> begin1 = <span class="built_in">clock</span>();</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">void</span>* ptr = <span class="built_in">ConcurrentAlloc</span>(<span class="number">30</span>);</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;21 - &quot;</span> &lt;&lt; std::this_thread::<span class="built_in">get_id</span>() &lt;&lt; <span class="string">&quot; - &quot;</span> &lt;&lt; ptr &lt;&lt; endl;</span><br><span class="line">v1.<span class="built_in">push_back</span>(ptr);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> e : v1)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">ConcurrentFree</span>(e);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">size_t</span> end1 = <span class="built_in">clock</span>();</span><br><span class="line"></span><br><span class="line"><span class="type">size_t</span> begin2 = <span class="built_in">clock</span>();</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">void</span>* ptr = <span class="built_in">malloc</span>(<span class="number">30</span>);</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;22 - &quot;</span> &lt;&lt; std::this_thread::<span class="built_in">get_id</span>() &lt;&lt; <span class="string">&quot; - &quot;</span> &lt;&lt; ptr &lt;&lt; endl;</span><br><span class="line">v2.<span class="built_in">push_back</span>(ptr);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> e : v2)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">free</span>(e);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">size_t</span> end2 = <span class="built_in">clock</span>();</span><br><span class="line"></span><br><span class="line">std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">seconds</span>(<span class="number">2</span>));</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;2 memory pool cost time:&quot;</span> &lt;&lt; end1 - begin1 &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;2 malloc cost time:&quot;</span> &lt;&lt; end2 - begin2 &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">catch</span> (...)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;error in MultiThreadAlloc2\n&quot;</span>;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在vs2019的debug-x86模式，测试结果如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">2 memory pool cost time:98</span><br><span class="line">2 malloc cost time:91</span><br><span class="line">1 memory pool cost time:44</span><br><span class="line">1 malloc cost time:95</span><br></pre></td></tr></table></figure><p>会发现线程2的malloc申请时间小于线程池，而线程1的线程池效率更高。再测试一次，又会发现两个线程malloc的效率都更高了。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">2 memory pool cost time:80</span><br><span class="line">2 malloc cost time:77</span><br><span class="line">1 memory pool cost time:69</span><br><span class="line">1 malloc cost time:61</span><br></pre></td></tr></table></figure><p>这明显不是我们想要的结果，如果一个内存池的效率低于malloc，它存在的意义就不是很大了。所以需要针对当前线程池中的性能瓶颈进行一定分析和优化。</p><h2 id="9-2-VS2019性能查看器"><a href="#9-2-VS2019性能查看器" class="headerlink" title="9.2 VS2019性能查看器"></a>9.2 VS2019性能查看器</h2><p>VS2019的调试选项中有一个性能探查器，它可以帮助我们确定当前项目中哪一个部分最耗时。</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/03/e5741918e40f4f3f998be52e652048d1.png" alt="image-20240306090902495"></p><p>调整到DEBUG模式下，选择检测，点击开始</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/03/e26975b85eb27872042507ca14a725e8.png" alt="image-20240306091010082"></p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/03/0138862a8de2f1ed9c6c46a5936b5751.png" alt="image-20240306091438569"></p><p>最终选择当前项目并等待运行后，会得到一个下面这样的报告。注意使用性能监看器的时候应该把多线程代码内部的打印和sleep给去掉（否则会显示打印和sleep的耗时很长）</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/03/c898dca7428fcf06364e3dccb76439bf.png" alt="image-20240306091039084"></p><p>上图是只有两个线程时的报告，下图是4个线程同时运行时的报告</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/03/5632ea109f2e97504928900d47e5e208.png" alt="image-20240306141404925"></p><p>这里就能看到，ConcurrentFree函数占用了很大的CPU时间</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/03/1d0da72d2acb63ba4235cca495d9667c.png" alt="image-20240306091851440"></p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/03/9c47bb8bb270db12ab4b121d404b1522.png" alt="image-20240306091802354"></p><p>在ConcurrentFree函数中，<code>MapObjectToSpan</code>函数和<code>ThreadCache::Deallocate</code>函数占用的时间比较长。</p><p>进一步查看，在<code>ThreadCache::Deallocate</code>函数中，耗时的也是MapObjectToSpan这个HashMap的查询操作。</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/03/e8611fceb986f9a88665d6546bd3a2e3.png" alt="image-20240306092056267"></p><p>MapObjectToSpan函数中，<strong>占用时间长的是加锁和find的操作</strong>。</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/03/3b85e480b784725724674b6d707717e9.png" alt="image-20240306092009240"></p><p>如果能省去这里的加锁，<strong>那么内存池释放内存的效率就会大大提高</strong>。</p><p>这时候就需要引入另外一种数据结构了：基数树 radix_tree。</p><h2 id="9-3-基数树"><a href="#9-3-基数树" class="headerlink" title="9.3 基数树"></a>9.3 基数树</h2><h3 id="数据结构说明"><a href="#数据结构说明" class="headerlink" title="数据结构说明"></a>数据结构说明</h3><p>在PageCache中的<code>unordered_map</code>是用于映射页号和对应Span对象指针的，这两个本质上都是一个整形。基数树就比较适合这样的场景。</p><ul><li>单层基数树其实就是一个“直接定址法”的哈希数组，用页面数量作为数组长度，每个数组的元素都是一个指针；</li></ul><p>在32位系统下，这个数组的长度是<code>32-PAGE_SHIFT</code>，对于当前项目而言<code>PAGE_SHIFT</code>是13，则最终数组的长度是<code>2^19</code>，每个元素都是一个4字节的指针类型，数组的大小就是2048KB，即2MB。这个大小并不算大，可以接受。</p><p>很明显，使用单层基数树，时间复杂度就直接被压缩到了数组下标直接访问的<code>O(1)</code>，比<code>unordered_map</code>提供的哈希表效率更高（因为单层基数树完全没有哈希碰撞和扩容问题）。</p><ul><li>多层基数树利用页号的比特位来分层</li></ul><p>如下所示，在32位下，页号只有低19位是有意义的。因为页号是由32位地址右移13位得来的。</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/03/77a3771140158154ec2f2d3b4abe7c44.png" alt="image-20240306145039892"></p><p>将低的十九位进一步分为高5位，低13位；这里的高5位就作为第一层的映射，低13位作为第二层的映射</p><ul><li>第一层的长度为2的5次方；</li><li>第二层的长度为2的13次方；</li></ul><p>最终基数树的数组长度是<code>2^5 * 2^13 = 262,144</code>，占用空间大小是1024KB，即1MB。分层不仅节省了空间，而且还避免了一次性申请大块内存（如果是单层基数树需要一次性把数组的空间申请出来）。</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/03/abdc5fcc1f253aad8f44941127644868.png" alt="image-20240306150859855"></p><p>更多层的基数树都是按上述思路往下扩展，如果是六十四位的系统就需要用更多层的基数树。</p><p>基数树因为每一个页号都有一个单独的存储空间，在修改的时候只会修改局部，并不影响整体。而且和红黑树这种数据结构有一点不同，红黑树为了保证key的有序，在插入的时候可能需要进行树结构的旋转，假设查询的时候遇到这种旋转，效率就会变低甚至出现错误，这也是为什么使用<code>map</code>的时候需要<strong>加锁</strong>。<code>unoredered_map</code>也是同理，遇到哈希碰撞和空间不足的时候，都会修改原本数据的存放结构，为了避免多线程问题，就需要加锁才能进行查询。</p><p>而基数树不管是插入还是删除操作都<strong>不会影响整个树的结构</strong>，你可以理解为基数树创建完毕之后整个树的结构就不会动了，这一点就让它在一定程度上是线程安全的。只要多线程<strong>不会同时读写相同页号的数据</strong>，就不会出现并发问题。</p><h3 id="回到项目"><a href="#回到项目" class="headerlink" title="回到项目"></a>回到项目</h3><p>再来看看项目中什么时候需要设置映射，什么时候会查询映射？</p><p>设置页号和Span对象的指针函数为<code>SetMapObjectToSpan</code>，只在PageCache的NewSpan和ReleaseSpanToPageCache函数中被调用。而访问PageCache的时候都会加锁，这里对映射的<strong>写操作</strong>不存在多线程问题。</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/03/5bfcc0a0a5b6a8c682c446851f8c05b0.png" alt="image-20240306152054722"></p><p>查询操作都是在<code>ConcurrentFree</code>和<code>CentralCache::ReleaseListToSpans</code>这两个内存释放函数中。</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/03/f1306727d9c65e996b18a83f5b0b8514.png" alt="image-20240306153145300"></p><p>PageCache中什么时候会修改映射：</p><ul><li>将对应大小Span分配给CentralCache时；</li><li>将大Span拆成小Span，并分配给CentralCache时；</li><li>回收时将小Span与相邻Span合并时；</li></ul><p>而查询操作都是在回收内存的时候出现的，被回收的内存一定<strong>不会是刚刚准备被分配的Span对象</strong>，因为分配内存后的Span对象就会从PageCache的SpanList中删除，PageCache不管是回收合并操作还是拆分操作都不会遇到这个不存在于SpanList中的Span对象。换而言之，当前映射的写操作和读操作<strong>不会同时访问相同页号的位置</strong>！而基数树的特性让这种读写不同下标位置的操作无需加锁！</p><p>去掉了锁竞争，效率就提高了！</p><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><p>单层基数树，其实就是一个数组，给定一个Get和一个Set，就可以了。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 单层基数树，利用模板变量来获取长度</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="type">size_t</span> BITS&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">PageMap1</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="type">size_t</span> LENGTH = <span class="number">1</span> &lt;&lt; BITS; <span class="comment">// 用于确定基数树的长度</span></span><br><span class="line"><span class="type">void</span>** _array; <span class="comment">// 一个数组，数组内的每个元素都是一个void*指针</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">PageMap1</span>()</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">size_t</span> size = <span class="built_in">sizeof</span>(<span class="type">void</span>*) * LENGTH; <span class="comment">// 整个数组的长度</span></span><br><span class="line"><span class="type">size_t</span> alignSize = SizeClass::<span class="built_in">RoundUp</span>(size); <span class="comment">// 调用SystemAlloc申请内存的时候需要按页对齐</span></span><br><span class="line">_array = (<span class="type">void</span>**)<span class="built_in">SystemAlloc</span>(alignSize &gt;&gt; PAGE_SHIFT); <span class="comment">// 为了可移植性，使用C语言的强制转换</span></span><br><span class="line"><span class="built_in">memset</span>(_array, <span class="number">0</span>, size); <span class="comment">// 清零</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 这里采用uintptr_t，保证可以覆盖当前平台上的指针数量</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">uintptr_t</span> Number;</span><br><span class="line"></span><br><span class="line"><span class="comment">// set的时候需要保证key有效</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Set</span><span class="params">(Number key, <span class="type">void</span>* value)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">_array[key] = value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span>* <span class="title">Get</span><span class="params">(Number key)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// 超过当前的允许范围了</span></span><br><span class="line"><span class="keyword">if</span> ((key &gt;&gt; BITS) &gt; <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> _array[key];</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="9-4-再次性能测试"><a href="#9-4-再次性能测试" class="headerlink" title="9.4 再次性能测试"></a>9.4 再次性能测试</h2><p>将PageCache中的<code>unordered_map</code>改为单层基数树，然后再进行测试。这次使用更好的自动创建线程来并发申请的方式进行测试，方便修改测试变量。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// malloc多线程测试</span></span><br><span class="line"><span class="comment">// ntimes 一轮申请和释放内存的次数</span></span><br><span class="line"><span class="comment">// nworks 线程数量</span></span><br><span class="line"><span class="comment">// rounds 轮次</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">BenchmarkMalloc</span><span class="params">(<span class="type">size_t</span> ntimes, <span class="type">size_t</span> nworks, <span class="type">size_t</span> rounds)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="function">std::vector&lt;std::thread&gt; <span class="title">vthread</span><span class="params">(nworks)</span></span>;</span><br><span class="line">std::atomic&lt;<span class="type">size_t</span>&gt; malloc_costtime = <span class="number">0</span>;</span><br><span class="line">std::atomic&lt;<span class="type">size_t</span>&gt; free_costtime = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">size_t</span> k = <span class="number">0</span>; k &lt; nworks; ++k)</span><br><span class="line">&#123;</span><br><span class="line">vthread[k] = std::<span class="built_in">thread</span>([&amp;, k]() &#123;</span><br><span class="line">std::vector&lt;<span class="type">void</span>*&gt; v;</span><br><span class="line">v.<span class="built_in">reserve</span>(ntimes);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">size_t</span> j = <span class="number">0</span>; j &lt; rounds; ++j)</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">size_t</span> begin1 = <span class="built_in">clock</span>();</span><br><span class="line"><span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; ntimes; i++)</span><br><span class="line">&#123;</span><br><span class="line">v.<span class="built_in">push_back</span>(<span class="built_in">malloc</span>(<span class="number">35</span>));</span><br><span class="line"><span class="comment">//v.push_back(malloc((35 + i) % 8192 + 1));</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="type">size_t</span> end1 = <span class="built_in">clock</span>();</span><br><span class="line"></span><br><span class="line"><span class="type">size_t</span> begin2 = <span class="built_in">clock</span>();</span><br><span class="line"><span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; ntimes; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">free</span>(v[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">size_t</span> end2 = <span class="built_in">clock</span>();</span><br><span class="line">v.<span class="built_in">clear</span>();</span><br><span class="line"></span><br><span class="line">malloc_costtime += (end1 - begin1);</span><br><span class="line">free_costtime += (end2 - begin2);</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span>&amp; t : vthread)</span><br><span class="line">&#123;</span><br><span class="line">t.<span class="built_in">join</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%u 个线程并发执行 %u 轮次，每轮 malloc %u 次，耗时：%u ms\n&quot;</span>,</span><br><span class="line">nworks, rounds, ntimes, malloc_costtime.<span class="built_in">load</span>());</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%u 个线程并发执行 %u 轮次，每轮 free %u 次，耗时：%u ms\n&quot;</span>,</span><br><span class="line">nworks, rounds, ntimes, free_costtime.<span class="built_in">load</span>());</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%u 个线程并发执行malloc/free %u 次，总计耗时：%u ms\n&quot;</span>,</span><br><span class="line">nworks, nworks * rounds * ntimes, malloc_costtime.<span class="built_in">load</span>() + free_costtime.<span class="built_in">load</span>());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 内存池多线程测试</span></span><br><span class="line"><span class="comment">// ntimes 一轮申请和释放内存的次数</span></span><br><span class="line"><span class="comment">// nworks 线程数量</span></span><br><span class="line"><span class="comment">// rounds 轮次</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">BenchmarkConcurrentMalloc</span><span class="params">(<span class="type">size_t</span> ntimes, <span class="type">size_t</span> nworks, <span class="type">size_t</span> rounds)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="function">std::vector&lt;std::thread&gt; <span class="title">vthread</span><span class="params">(nworks)</span></span>;</span><br><span class="line">std::atomic&lt;<span class="type">size_t</span>&gt; malloc_costtime = <span class="number">0</span>;</span><br><span class="line">std::atomic&lt;<span class="type">size_t</span>&gt; free_costtime = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">size_t</span> k = <span class="number">0</span>; k &lt; nworks; ++k)</span><br><span class="line">&#123;</span><br><span class="line">vthread[k] = std::<span class="built_in">thread</span>([&amp;]() &#123;</span><br><span class="line">std::vector&lt;<span class="type">void</span>*&gt; v;</span><br><span class="line">v.<span class="built_in">reserve</span>(ntimes);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">size_t</span> j = <span class="number">0</span>; j &lt; rounds; ++j)</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">size_t</span> begin1 = <span class="built_in">clock</span>();</span><br><span class="line"><span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; ntimes; i++)</span><br><span class="line">&#123;</span><br><span class="line">v.<span class="built_in">push_back</span>(<span class="built_in">ConcurrentAlloc</span>(<span class="number">35</span>));</span><br><span class="line"><span class="comment">//v.push_back(ConcurrentAlloc((35 + i) % 8192 + 1));</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="type">size_t</span> end1 = <span class="built_in">clock</span>();</span><br><span class="line"></span><br><span class="line"><span class="type">size_t</span> begin2 = <span class="built_in">clock</span>();</span><br><span class="line"><span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; ntimes; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">ConcurrentFree</span>(v[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">size_t</span> end2 = <span class="built_in">clock</span>();</span><br><span class="line">v.<span class="built_in">clear</span>();</span><br><span class="line"></span><br><span class="line">malloc_costtime += (end1 - begin1);</span><br><span class="line">free_costtime += (end2 - begin2);</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span>&amp; t : vthread)</span><br><span class="line">&#123;</span><br><span class="line">t.<span class="built_in">join</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%u 个线程并发执行 %u 轮次，每轮内存池申请 %u 次，耗时：%u ms\n&quot;</span>,</span><br><span class="line">nworks, rounds, ntimes, malloc_costtime.<span class="built_in">load</span>());</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%u 个线程并发执行 %u 轮次，每轮内存池释放 %u 次，耗时：%u ms\n&quot;</span>,</span><br><span class="line">nworks, rounds, ntimes, free_costtime.<span class="built_in">load</span>());</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%u 个线程并发执行内存池申请和释放 %u 次，总计耗时：%u ms\n&quot;</span>,</span><br><span class="line">nworks, nworks * rounds * ntimes, malloc_costtime.<span class="built_in">load</span>() + free_costtime.<span class="built_in">load</span>());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">BenchMark</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">size_t</span> n = <span class="number">10000</span>;</span><br><span class="line"><span class="built_in">BenchmarkConcurrentMalloc</span>(n, <span class="number">4</span>, <span class="number">10</span>);</span><br><span class="line">cout &lt;&lt; endl &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="built_in">BenchmarkMalloc</span>(n, <span class="number">4</span>, <span class="number">10</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以下是使用<code>uordered_map</code>的测试结果（DEBUG-X86），性能远低于malloc&#x2F;free。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">4 个线程并发执行 10 轮次，每轮内存池申请 100000 次，耗时：4756 ms</span><br><span class="line">4 个线程并发执行 10 轮次，每轮内存池释放 100000 次，耗时：25577 ms</span><br><span class="line">4 个线程并发执行内存池申请和释放 4000000 次，总计耗时：30333 ms</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">4 个线程并发执行 10 轮次，每轮 malloc 100000 次，耗时：6064 ms</span><br><span class="line">4 个线程并发执行 10 轮次，每轮 free 100000 次，耗时：1797 ms</span><br><span class="line">4 个线程并发执行malloc/free 4000000 次，总计耗时：7861 ms</span><br></pre></td></tr></table></figure><p>以下是使用<strong>单层基数树</strong>的测试结果（DEBUG-X86），可以看到此时我们的内存池效率就完美体现出来了。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">4 个线程并发执行 10 轮次，每轮内存池申请 10000 次，耗时：177 ms</span><br><span class="line">4 个线程并发执行 10 轮次，每轮内存池释放 10000 次，耗时：72 ms</span><br><span class="line">4 个线程并发执行内存池申请和释放 400000 次，总计耗时：249 ms</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">4 个线程并发执行 10 轮次，每轮 malloc 10000 次，耗时：644 ms</span><br><span class="line">4 个线程并发执行 10 轮次，每轮 free 10000 次，耗时：181 ms</span><br><span class="line">4 个线程并发执行malloc/free 400000 次，总计耗时：825 ms</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">4 个线程并发执行 10 轮次，每轮内存池申请 100000 次，耗时：1899 ms</span><br><span class="line">4 个线程并发执行 10 轮次，每轮内存池释放 100000 次，耗时：796 ms</span><br><span class="line">4 个线程并发执行内存池申请和释放 4000000 次，总计耗时：2695 ms</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">4 个线程并发执行 10 轮次，每轮 malloc 100000 次，耗时：5947 ms</span><br><span class="line">4 个线程并发执行 10 轮次，每轮 free 100000 次，耗时：2298 ms</span><br><span class="line">4 个线程并发执行malloc/free 4000000 次，总计耗时：8245 ms</span><br></pre></td></tr></table></figure><p>改成Release模式重新测试一下，可见Release模式对malloc操作有一定优化，二者差距没有那么高，不过已经能体现当前内存池的性能还不错了。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">4 个线程并发执行 10 轮次，每轮内存池申请 100000 次，耗时：169 ms</span><br><span class="line">4 个线程并发执行 10 轮次，每轮内存池释放 100000 次，耗时：118 ms</span><br><span class="line">4 个线程并发执行内存池申请和释放 4000000 次，总计耗时：287 ms</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">4 个线程并发执行 10 轮次，每轮 malloc 100000 次，耗时：165 ms</span><br><span class="line">4 个线程并发执行 10 轮次，每轮 free 100000 次，耗时：189 ms</span><br><span class="line">4 个线程并发执行malloc/free 4000000 次，总计耗时：354 ms</span><br></pre></td></tr></table></figure><p>再用性能监视器查看，发现性能消耗最大的已经是vector的push操作了，原先耗时的Map查询操作现在占比已经不高了。</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/03/3a3ced1ce9cbe0818832ab752fd58f17.png" alt="image-20240306214130138"></p><h1 id="The-end"><a href="#The-end" class="headerlink" title="The end"></a>The end</h1><p>内存池的基本学习和项目的实现内容到这里就OVER啦！</p>]]></content>
    
    
    <summary type="html">高并发内存池项目的学习</summary>
    
    
    
    <category term="编程学习" scheme="https://blog.musnow.top/categories/%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="项目开发记录" scheme="https://blog.musnow.top/categories/%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0/%E9%A1%B9%E7%9B%AE%E5%BC%80%E5%8F%91%E8%AE%B0%E5%BD%95/"/>
    
    
    <category term="Linux" scheme="https://blog.musnow.top/tags/Linux/"/>
    
    <category term="Cpp" scheme="https://blog.musnow.top/tags/Cpp/"/>
    
  </entry>
  
  <entry>
    <title>【Redis】04.常用变量类型</title>
    <link href="https://blog.musnow.top/posts/2729830801/"/>
    <id>https://blog.musnow.top/posts/2729830801/</id>
    <published>2024-02-14T12:37:08.000Z</published>
    <updated>2024-03-07T12:42:16.000Z</updated>
    
    <content type="html"><![CDATA[<p>本文是对Redis的变量类型以及和特定数据类型相关命令的介绍。</p><h1 id="1-string"><a href="#1-string" class="headerlink" title="1 string"></a>1 string</h1><p><a href="https://redis.io/docs/data-types/strings/">Redis Strings | Redis</a></p><h2 id="1-1-介绍"><a href="#1-1-介绍" class="headerlink" title="1.1 介绍"></a>1.1 介绍</h2><p>Redis中，所有key都是字符串类型，作为value的字符串有几个特性</p><ul><li>无编码转换（存的是什么取出来就是什么），所以你可以用string来存放二进制文件；</li><li>限制大小为512MB（避免过长的string操作耗时）；</li></ul><p>在MySQL中默认的字符集是拉丁文，此时插入中文内容会直接报错编码无法识别而失败，需要修改MySQL数据库的字符集。而在Redis中（不配置的情况下）插入中文，可以正常存放。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; set key1 你好</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; get key1</span><br><span class="line">&quot;\xe4\xbd\xa0\xe5\xa5\xbd&quot;</span><br></pre></td></tr></table></figure><p>这里get查看的时候显示的是中文编码。此时Redis客户端没有配置字符集转码，所以没能显示中文，但实际上中文就是这么存放的（这就好比英文存放的是对应ASCII码一样）。</p><p>因为Redis服务端没有对编码进行转换，所以它遇到乱码问题（比如烫烫烫）的概率更小。但依旧不建议使用<code>非英文+数字</code>的组合来做Redis的key。</p><p>如果想让redis-cli的终端中<strong>正常显示中文</strong>，可以在启动的时候添加<code>--raw</code>选项。如下所示，添加了该选项后，正常显示出了value的中文值。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">❯ sudo redis-cli --raw</span><br><span class="line">127.0.0.1:6379&gt; get key1</span><br><span class="line">你好</span><br></pre></td></tr></table></figure><blockquote><p>注意：使用该选项会导致Redis中显示的<code>(nil)</code>变成空字符串，极易产生误导！如果不是硬性需要在控制台中显示中文，请不要使用该选项！</p></blockquote><p>另外，在<a href="https://blog.musnow.top/posts/3677820204">Redis基础命令博客</a>中提到，Redis会对不同的string采取不同的存储方式，其中对于纯整数的string采用的是int来存放。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; set key1 100</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; object encoding key1</span><br><span class="line">int</span><br></pre></td></tr></table></figure><p>所以在Redis中如果存放一个<strong>整数数字</strong>（包括负数），虽然对应变量类型是string，但实际上就是一个int数字来存放的，Redis还提供了一系列原子性命令来对整数进行加减操作！</p><h2 id="1-2-相关命令"><a href="#1-2-相关命令" class="headerlink" title="1.2 相关命令"></a>1.2 相关命令</h2><p>set&#x2F;get以及mset&#x2F;mget命令已经在<a href="https://blog.musnow.top/posts/3677820204">Redis基础命令博客</a>中讲解了，这里不再重复。</p><h3 id="1-2-1-setnx-x2F-msetnx"><a href="#1-2-1-setnx-x2F-msetnx" class="headerlink" title="1.2.1 setnx&#x2F;msetnx"></a>1.2.1 setnx&#x2F;msetnx</h3><p>setnx等价于set中添加nx选项，只有在key不存在的时候才能正常设置</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">setnx key value</span><br></pre></td></tr></table></figure><ul><li>当key值已经存在的时候，setnx不会执行任何操作，返回0；</li><li>当key值不存在的时候，setnx等价于set，返回1；</li></ul><p>如下所示，key1存在，设置失败返回0；key2不存在，设置成功返回1。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; setnx key1 value2</span><br><span class="line">0</span><br><span class="line">127.0.0.1:6379&gt; setnx key2 value2</span><br><span class="line">1</span><br></pre></td></tr></table></figure><p>还有一个命令是msetnx（和mset一样），可以原子性地同时setnx多个key。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mset key value [key value ...]</span><br></pre></td></tr></table></figure><ul><li>只要给定的多个key中有一个key存在，msetnx就会失败且什么都不做，返回0；</li><li>只有给定的多个key全部都不存在，msetnx才会成功，返回1；</li></ul><p>如下所示，此时key1和key2已经存在，设置失败返回0；key3和key4都不存在， 设置成功返回1。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; msetnx key1 value1 key2 value2 key3 value3</span><br><span class="line">0</span><br><span class="line">127.0.0.1:6379&gt; msetnx key3 value3 key4 value4</span><br><span class="line">1</span><br></pre></td></tr></table></figure><h3 id="1-2-2-setex-x2F-psetex"><a href="#1-2-2-setex-x2F-psetex" class="headerlink" title="1.2.2 setex&#x2F;psetex"></a>1.2.2 setex&#x2F;psetex</h3><p>setex&#x2F;psetex是在设置key的时候指定过期时间，只是时间单位不一样。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">setex key value second</span><br><span class="line">psetex key value milisecond</span><br></pre></td></tr></table></figure><p>虽然set命令本身已经提供了关于这些功能的选项，但直接使用<strong>特定命令</strong>来设置而不是用命令的参数会更加方便且符合人的直觉，使用门槛也更低！</p><blockquote><p>对于学习过Linux系统使用的开发人员而言，命令参数已经见怪不怪了。但对于初次学习Redis使用而没有接触过Linux系统的萌新而言，使用一个简单的命令来传递单个参数，会比在set后面添加一大堆选项更加简单且不容易犯错。</p></blockquote><h3 id="1-2-3-数字加减命令"><a href="#1-2-3-数字加减命令" class="headerlink" title="1.2.3 数字加减命令"></a>1.2.3 数字加减命令</h3><p>因为Redis中的整数是用int来存放的，所以它提供了一些命令来<strong>原子性</strong>的操作数字。这些命令中如果给定的key不存在，则会将其视作0，新建一个key再加上目标值。</p><table><thead><tr><th>命令</th><th>作用</th><th>备注</th></tr></thead><tbody><tr><td>incr key</td><td>value + 1</td><td>value必须是整数</td></tr><tr><td>incrby key n</td><td>value + n</td><td>value必须是整数，给定的n可以是负数</td></tr><tr><td>decr key</td><td>value - 1</td><td>value必须是整数</td></tr><tr><td>decrby key n</td><td>value - n</td><td>value必须是整数，给定的n可以是负数</td></tr><tr><td>incrbyfloat key n</td><td>value +&#x2F;- 小数</td><td>给定的n可以是负数来实现减法</td></tr></tbody></table><p>注意：<code>decrbyfloat</code>命令是不存在的！</p><p>前四个命令的操作数value必须是一个整数，否则会失败。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; get key1</span><br><span class="line">119.3</span><br><span class="line">127.0.0.1:6379&gt; incr key1</span><br><span class="line">ERR value is not an integer or out of range</span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; decr key1</span><br><span class="line">ERR value is not an integer or out of range</span><br></pre></td></tr></table></figure><p>使用incrbyfloat命令操作一个整数后，它的存放方式就不再是int，而变成embstr了。此时我们依旧可以用incrbyfloat命令来继续添加小数（包括减去小数）。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; set key1 100</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; object encoding key1</span><br><span class="line">int</span><br><span class="line">127.0.0.1:6379&gt; incrbyfloat key1 19.3</span><br><span class="line">119.3</span><br><span class="line">127.0.0.1:6379&gt; get key1</span><br><span class="line">119.3</span><br><span class="line">127.0.0.1:6379&gt; object encoding key1</span><br><span class="line">embstr</span><br><span class="line">127.0.0.1:6379&gt; incrbyfloat key1 0.7</span><br><span class="line">120</span><br><span class="line">127.0.0.1:6379&gt; object encoding key1</span><br><span class="line">embstr</span><br><span class="line">127.0.0.1:6379&gt; incrbyfloat key1 -0.7</span><br><span class="line">119.3</span><br></pre></td></tr></table></figure><h3 id="1-2-4-append"><a href="#1-2-4-append" class="headerlink" title="1.2.4 append"></a>1.2.4 append</h3><p>append命令用于在字符串之后追加字符串。如果给定key不存在，则和set命令等价。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">append key value</span><br></pre></td></tr></table></figure><p>该命令的时间复杂度是<code>O(1)</code>，返回值是追加后的字符串长度。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; set k 123</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; append k 45</span><br><span class="line">5</span><br><span class="line">127.0.0.1:6379&gt; get k</span><br><span class="line">12345</span><br></pre></td></tr></table></figure><p>如果尝试给k追加一个中文，字符串长度会是多少呢？</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; append k 你好</span><br><span class="line">11</span><br><span class="line">127.0.0.1:6379&gt; get k</span><br><span class="line">12345你好</span><br></pre></td></tr></table></figure><p>可以看到，最终长度是11，因为Redis不会对字符串进行转码，中文在UTF8环境下是用三个字节存放的，所以两个中文就是6字节，加上原本的5个字节，最终长度就是11字节。</p><p>不使用<code>--raw</code>启动redis-cli，就能看到这两个中文的原始编码值。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; get k</span><br><span class="line">&quot;12345\xe4\xbd\xa0\xe5\xa5\xbd&quot;</span><br></pre></td></tr></table></figure><h3 id="1-2-5-getrange"><a href="#1-2-5-getrange" class="headerlink" title="1.2.5 getrange"></a>1.2.5 getrange</h3><p>这个命令用于获取字符串的子串，start&#x2F;end指定一个区间（采用下标方式且为闭区间）。该命令的时间复杂度是<code>O(N)</code>；</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">getrange key start end</span><br></pre></td></tr></table></figure><p>测试如下，2代表从第三个字符开始，4代表第五个字符结束。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; set key 123456789</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; getrange key 2 4</span><br><span class="line">&quot;345&quot;</span><br></pre></td></tr></table></figure><p>这里的start&#x2F;end还可以给负数。当end为负数时，代表直接取到末尾。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; getrange key -1 4</span><br><span class="line">&quot;&quot;</span><br><span class="line">127.0.0.1:6379&gt; getrange key 2 -1</span><br><span class="line">&quot;3456789&quot;</span><br></pre></td></tr></table></figure><p>当start小于end时，返回空字符串</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; getrange key 2 0</span><br><span class="line">&quot;&quot;</span><br><span class="line">127.0.0.1:6379&gt; getrange key 2 1</span><br><span class="line">&quot;&quot;</span><br><span class="line">127.0.0.1:6379&gt; getrange key 2 2</span><br><span class="line">&quot;3&quot;</span><br></pre></td></tr></table></figure><p>注意，getrange的切分是严格按照字节切分的，如果是中文，则难以拆分出一个正常的中文字符（要按3个字节的间隙才能拆出一个正常的中文字符）。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">❯ sudo redis-cli</span><br><span class="line">127.0.0.1:6379&gt; get k</span><br><span class="line">&quot;12345\xe4\xbd\xa0\xe5\xa5\xbd&quot;</span><br><span class="line">127.0.0.1:6379&gt; getrange k 5 -1</span><br><span class="line">&quot;\xe4\xbd\xa0\xe5\xa5\xbd&quot;</span><br><span class="line">127.0.0.1:6379&gt; getrange k 5 6</span><br><span class="line">&quot;\xe4\xbd&quot;</span><br><span class="line"></span><br><span class="line">❯ sudo redis-cli --raw</span><br><span class="line">127.0.0.1:6379&gt; get k</span><br><span class="line">12345你好</span><br><span class="line">127.0.0.1:6379&gt; getrange k 5 6</span><br><span class="line">�</span><br><span class="line">127.0.0.1:6379&gt; getrange k 5 7</span><br><span class="line">你</span><br></pre></td></tr></table></figure><h3 id="1-2-6-setrange"><a href="#1-2-6-setrange" class="headerlink" title="1.2.6 setrange"></a>1.2.6 setrange</h3><p>从指定下标开始替换字符串，返回值是替换后字符串的长度。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">setrange key offset value</span><br></pre></td></tr></table></figure><p>示例如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; get key</span><br><span class="line">123456789</span><br><span class="line">127.0.0.1:6379&gt; setrange key 3 hhhh</span><br><span class="line">9</span><br><span class="line">127.0.0.1:6379&gt; get key</span><br><span class="line">123hhhh89</span><br></pre></td></tr></table></figure><h3 id="1-2-7-strlen"><a href="#1-2-7-strlen" class="headerlink" title="1.2.7 strlen"></a>1.2.7 strlen</h3><p>返回字符串的长度，单位是字节</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">strlen key</span><br></pre></td></tr></table></figure><h2 id="1-3-编码介绍"><a href="#1-3-编码介绍" class="headerlink" title="1.3 编码介绍"></a>1.3 编码介绍</h2><p>string有三种编码方式</p><ul><li>embstr：为短字符串优化；</li><li>int：为非负整数优化；</li><li>raw：原始字符串；</li></ul><p>注意，不管是什么编码方式，都不会影响对string的数字加减命令的使用（只要value是一个数字就行，即便小数的编码方式是embstr，也依旧可以使用数字加减命令）</p><h2 id="1-4-应用场景"><a href="#1-4-应用场景" class="headerlink" title="1.4 应用场景"></a>1.4 应用场景</h2><h3 id="1-4-1-用户信息缓存"><a href="#1-4-1-用户信息缓存" class="headerlink" title="1.4.1 用户信息缓存"></a>1.4.1 用户信息缓存</h3><p>绝大部分情况下，我们需要获取的信息都是字符串类型的。比如用户个人信息的JSON字符串。</p><p>此时可以在Redis中用<code>user:平台:用户ID</code>的方式做key，来保存用户基本个人信息的JSON字符串。如果使用Redis+MySQL的组合的话，整个用户信息的请求步骤如下：</p><ul><li>用户浏览器&#x2F;APP中点击个人信息页面，客户端发起请求，假设用户ID为100；</li><li>应用服务器收到请求，先去请求Redis服务器：<code>get user:平台:100</code>；</li><li>Redis中成功查询到用户信息，将Json字符串返回给用户；</li><li>没有在Redis中查询到，使用SQL请求MySQL服务器<code>select 用户个人信息字段 from user where user_id = &#39;100&#39;;</code></li><li>将MySQL返回的相关键值按预定格式制作成JSON字符串，返回给用户；</li><li>将该JSON字符串写入Redis服务器：<code>set user:平台:100 JSON字符串</code>；</li></ul><p>在set的时候还可以设定一定的过期时间，在保证缓存的实时性的基础上，避免Redis中的数据始终增长而导致内存爆满。（当然，内存快满的时候Redis有淘汰策略可供选择，那是后面要学习的内容了）。</p><h3 id="1-4-2-视频播放量计数"><a href="#1-4-2-视频播放量计数" class="headerlink" title="1.4.2 视频播放量计数"></a>1.4.2 视频播放量计数</h3><p>对于视频点赞、播放量这种经常变动的数据，可以使用Redis来做计数。比如使用<code>vedio:hit:视频ID</code>作为key，代表视频的播放量。</p><p>当用户点击一个视频的时候，发起请求给应用服务器，服务器在返回视频相关信息的同时，将播放量加一的信息，使用incr命令传递给Redis服务器。</p><p>但只用Redis肯定是不够的，还会有一个MySQL数据表来存放视频对应的点赞、播放、收藏等全量信息。此时我们可以令起一个服务，<strong>异步</strong>地同步视频播放量、点赞等相关信息到MySQL表中。</p><blockquote><p><strong>异步</strong>同步：并非来一个视频请求就同步到MySQL一次，而是以一定频率（时间间隔）将Redis中的数据同步到MySQL表中。这样能保证Redis中的数据能有备份。</p></blockquote><p>实际场景中，要想开发一个稳定的真实计数系统，还需要考虑防作弊、不同维度计数、避免单点问题以及数据持久化等等方面。这些都需要根据具体的业务逻辑来特殊处理。</p><h3 id="1-4-3-cookie-seesion"><a href="#1-4-3-cookie-seesion" class="headerlink" title="1.4.3 cookie+seesion"></a>1.4.3 cookie+seesion</h3><p>在HTTP网络服务中，cookie是最常用的用于标定客户端信息的方式。有些网站并非每次打卡都需要登录，而是登录了之后能维持一段时间不需要用户每次都重新登录。在这个过程中，就是通过浏览器端的cookie和服务器端的session来实现的。</p><ul><li>cookie：存放在用户的浏览器中，其值是通过HTTP的<code>Set-Cookie</code>响应头由服务器告知用户浏览器的；</li><li>session：存放在服务器端（实际上服务器端应该存放的是cookie-session的键值对），用于标定用户的基本信息；</li></ul><p>当用户登录后，服务器会生成一个<code>session_id</code>，将其和登录的用户信息绑定（键值对），并发送包含<code>Set-Cookie</code>头的HTTP报文给客户端，将<code>session_id</code>告知用户。浏览器在检测到这个响应头后，会将它对应的值保存在本地，下一次向这个网站发起HTTP请求的时候就会带上这个设置的cookie值里面的<code>session_id</code>。</p><p>服务器收到HTTP请求后，检查请求头中的<code>Cookie</code>字段，并与服务器中存放的<code>session_id</code>键值对进行对比，得到对应的用户，则返回用户相关信息，即当前用户已登录。</p><p>实现网页登录在一定时间后过期的功能，只需要在Redis中给这个键值对设置一个<strong>过期时间</strong>就行了。</p><p>使用cookie+session的方式也更加方便多个应用服务器之间的消息共享。因为<strong>负载均衡</strong>的存在，用户的请求可能会被发送到不同的应用服务器。只要这些应用服务器<strong>使用相同的Redis</strong>，它们就都能检索到用户的cookie对应的session信息，也就知道了当前用户的个人信息，可以正常进行服务（其实就是信息在多个应用服务器之中进行共享）。整个过程中用户完全不会发现自己的请求并非是同一个服务器来处理的。</p><h3 id="1-4-4-验证码"><a href="#1-4-4-验证码" class="headerlink" title="1.4.4 验证码"></a>1.4.4 验证码</h3><p>这个场景就很常见了，手机验证码&#x2F;邮箱验证码都是如此，在Redis中设置一个验证码的key，value是对应用户的id，<strong>并给这个key设置一定的过期时间</strong>，就能实现验证码的功能。</p><p>当用户输入验证码后，检查Redis中的key，当value中的id和用户的id相同，则代表验证成功。用户id不同或验证码的key不存在，则验证失败。</p><p>这个过程中可能还会涉及到间隔60s秒才能发送一次验证码（这种限制大概率是前端做的处理）后端自然也可以通过一些缓存的时间值来做检查，避免给同一个用户在较短时间内发送多个验证码（会影响性能）。</p><h1 id="2-Hash"><a href="#2-Hash" class="headerlink" title="2 Hash"></a>2 Hash</h1><h2 id="2-1-介绍"><a href="#2-1-介绍" class="headerlink" title="2.1 介绍"></a>2.1 介绍</h2><p>哈希是比较常见的一种数据结构，Redis本身的key-value结构其实就是通过哈希来实现的。同时，Redis也提供了hash作为value的数据类型，为了和Redis本身的kv进行区分，hash类型内的键值对被称为<code>field-value</code>。</p><p>比如存放一个用户信息，原本我们可以采用如下方式，在key中用冒号作为分隔来保存个人信息。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">user:1:name 李四</span><br><span class="line">user:1:age  20</span><br><span class="line">user:1:sex  男</span><br></pre></td></tr></table></figure><p>现在我们可以直接将value设置为hash类型，然后在其中再设置对应的field和value，看上去就更加明了。</p><table><thead><tr><th>key</th><th>field</th><th>value</th></tr></thead><tbody><tr><td>user:1</td><td>name</td><td>李四</td></tr><tr><td>user:1</td><td>ag</td><td>20</td></tr><tr><td>user:1</td><td>sex</td><td>男</td></tr></tbody></table><h2 id="2-2-相关命令"><a href="#2-2-相关命令" class="headerlink" title="2.2 相关命令"></a>2.2 相关命令</h2><h3 id="2-2-1-HSET-x2F-HGET-x2F-HGETALL"><a href="#2-2-1-HSET-x2F-HGET-x2F-HGETALL" class="headerlink" title="2.2.1 HSET&#x2F;HGET&#x2F;HGETALL"></a>2.2.1 HSET&#x2F;HGET&#x2F;HGETALL</h3><p><a href="https://redis.io/commands/hget/">https://redis.io/commands/hget/</a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">HSET key field value [field value ...]</span><br><span class="line">HGET key field</span><br></pre></td></tr></table></figure><p>经过之前的命令学习，现在这里的命令就很好理解了。</p><ul><li>HSET用于设置hash类型内部的field，可以同时设置多个field；</li><li>HGET用于获取hash类型内部的field。</li></ul><p>HSET命令的返回值是设置成功的field的个数。当HGET命令指定的key或者field不存在时，会返回<code>nil</code>。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; HSET user:1 name 李四 age 20 sex 男</span><br><span class="line">3</span><br><span class="line">127.0.0.1:6379&gt; HGET user:1 name</span><br><span class="line">&quot;\xe6\x9d\x8e\xe5\x9b\x9b&quot;</span><br><span class="line">127.0.0.1:6379&gt; HGET user:1 age</span><br><span class="line">20</span><br><span class="line">127.0.0.1:6379&gt; HGET user:1 info</span><br><span class="line">(nil)</span><br><span class="line">127.0.0.1:6379&gt; HGET user:2 test</span><br><span class="line">(nil)</span><br><span class="line">127.0.0.1:6379&gt;</span><br></pre></td></tr></table></figure><p>与此相关的还有HSETNX和HGETALL两个命令</p><ul><li>HSETNX：当hash中的field不存在时才会设置成功（返回值为1），如果field已经存在则不会做任何操作（返回值为0）；</li><li>HGETALL：返回hash中的所有field-value值</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; HGETALL user:1</span><br><span class="line">1) &quot;name&quot;</span><br><span class="line">2) &quot;\xe6\x9d\x8e\xe5\x9b\x9b&quot;</span><br><span class="line">3) &quot;age&quot;</span><br><span class="line">4) &quot;20&quot;</span><br><span class="line">5) &quot;sex&quot;</span><br><span class="line">6) &quot;\xe7\x94\xb7&quot;</span><br><span class="line">127.0.0.1:6379&gt; HGETALL user:2</span><br><span class="line">(empty array)</span><br></pre></td></tr></table></figure><h3 id="2-2-2-HEXISTS"><a href="#2-2-2-HEXISTS" class="headerlink" title="2.2.2 HEXISTS"></a>2.2.2 HEXISTS</h3><p>该命令用于查询hash中的某个field是否存在。存在返回1，key或者field不存在返回0；</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HEXISTS key field</span><br></pre></td></tr></table></figure><p>测试如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; HEXISTS user:1 name</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; HEXISTS user:1 info</span><br><span class="line">(integer) 0</span><br><span class="line">127.0.0.1:6379&gt; HEXISTS user:2 info</span><br><span class="line">(integer) 0</span><br></pre></td></tr></table></figure><h3 id="2-2-3-HDEL"><a href="#2-2-3-HDEL" class="headerlink" title="2.2.3 HDEL"></a>2.2.3 HDEL</h3><p>删除hash中指定的field，可以一次性给定多个field来删除。返回值是本次成功删除的field个数。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HDEL key field [field ...]</span><br></pre></td></tr></table></figure><p>示例，info字段是不存在的，实际上只成功删除了name字段，所以返回值为1。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; HDEL user:1 name info</span><br><span class="line">(integer) 1</span><br></pre></td></tr></table></figure><p>如果你需要删除整个hash，直接使用Redis的del命令将key给删除就行了。比如<code>del user:1</code>;</p><h3 id="2-2-4-HKEYS"><a href="#2-2-4-HKEYS" class="headerlink" title="2.2.4 HKEYS"></a>2.2.4 HKEYS</h3><p>获取哈希中的所有field（仅获取字段）；该命令的时间复杂度是<code>O(N)</code>，N是hash中的field个数。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HKEYS key</span><br></pre></td></tr></table></figure><p>这个命令和HGETALL命令有所不同，HGETALL命令会获取field和value，但HKEYS只会获取field。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; HGETALL user:1</span><br><span class="line">1) &quot;age&quot;</span><br><span class="line">2) &quot;20&quot;</span><br><span class="line">3) &quot;sex&quot;</span><br><span class="line">4) &quot;\xe7\x94\xb7&quot;</span><br><span class="line">127.0.0.1:6379&gt; HKEYS user:1</span><br><span class="line">1) &quot;age&quot;</span><br><span class="line">2) &quot;sex&quot;</span><br></pre></td></tr></table></figure><p>当然，这个命令和HGETALL命令都需要<strong>谨慎使用</strong>，它们就和<code>keys *</code>一样，需要遍历整个hash对象，而我们在执行命令之前并不知道一个hash里面到底有多少个field。如果查询的hash中field过多，那就会阻塞Redis。</p><h3 id="2-2-5-HVALS"><a href="#2-2-5-HVALS" class="headerlink" title="2.2.5 HVALS"></a>2.2.5 HVALS</h3><p>获取hash中的所有value，和HKEYS的功能对应。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HVALS key</span><br></pre></td></tr></table></figure><p>测试如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; HVALS user:1</span><br><span class="line">1) &quot;20&quot;</span><br><span class="line">2) &quot;\xe7\x94\xb7&quot;</span><br></pre></td></tr></table></figure><h3 id="2-2-6-HMGET"><a href="#2-2-6-HMGET" class="headerlink" title="2.2.6 HMGET"></a>2.2.6 HMGET</h3><p>一次性获取hash中的多个field（一条命令查询优于多条命令查询）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HMGET key field [field ...]</span><br></pre></td></tr></table></figure><p>测试如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; HMGET user:1 age sex</span><br><span class="line">1) &quot;20&quot;</span><br><span class="line">2) &quot;\xe7\x94\xb7&quot;</span><br></pre></td></tr></table></figure><h3 id="2-2-7-HSCAN（仅作介绍）"><a href="#2-2-7-HSCAN（仅作介绍）" class="headerlink" title="2.2.7 HSCAN（仅作介绍）"></a>2.2.7 HSCAN（仅作介绍）</h3><p>和HGETALL&#x2F;HKEYS&#x2F;HVALS这些一次性遍历完毕所有hash内元素的命令不同，HSCAN命令是“渐进式遍历”（就好比过程化SQL和编程中常用的for循环）。</p><p>所谓渐进式遍历，就是敲一次命令遍历一次，这样遍历的过程和速度都是可控的，不会阻塞Redis。当你需要获取一个hash中的所有field&#x2F;value，使用HSCAN会更加安全。</p><p>官网文档：<a href="https://redis.io/commands/hscan/">https://redis.io/commands/hscan/</a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HSCAN key cursor [MATCH pattern] [COUNT count]</span><br></pre></td></tr></table></figure><h3 id="2-2-8-HLEN"><a href="#2-2-8-HLEN" class="headerlink" title="2.2.8 HLEN"></a>2.2.8 HLEN</h3><p>获取一个hash中键值对的个数，该命令时间复杂度是<code>O(1)</code>，因为Redis有使用额外变量来存放hash中元素的个数，无需遍历。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HLEN key</span><br></pre></td></tr></table></figure><p>使用该命令遍历一个不存在的key时，返回值为0</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; HLEN user:1</span><br><span class="line">(integer) 2</span><br><span class="line">127.0.0.1:6379&gt; HLEN user:2</span><br><span class="line">(integer) 0</span><br></pre></td></tr></table></figure><h3 id="2-2-9-HINCRBY-x2F-HINCRYBYFLOAT"><a href="#2-2-9-HINCRBY-x2F-HINCRYBYFLOAT" class="headerlink" title="2.2.9 HINCRBY&#x2F;HINCRYBYFLOAT"></a>2.2.9 HINCRBY&#x2F;HINCRYBYFLOAT</h3><p>这些命令和string中的数字操作命令一致，因为hash中的value也是字符串，也能当作数字来处理。参数可以是负数来左减法。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">HINCRBY key field num</span><br><span class="line">HINCRBYFLOAT key field float</span><br></pre></td></tr></table></figure><p>测试如下，两个命令的返回值都是操作之后的变量值。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; hincrby user:1 age 10</span><br><span class="line">(integer) 30</span><br><span class="line">127.0.0.1:6379&gt; hincrbyfloat user:1 age 10.13</span><br><span class="line">&quot;40.13&quot;</span><br><span class="line">127.0.0.1:6379&gt; hincrbyfloat user:1 age -11.13</span><br><span class="line">&quot;29&quot;</span><br></pre></td></tr></table></figure><h3 id="2-2-10-HSTRLEN"><a href="#2-2-10-HSTRLEN" class="headerlink" title="2.2.10 HSTRLEN"></a>2.2.10 HSTRLEN</h3><p>计算hash中value的字符串长度</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HSTRLEN key field</span><br></pre></td></tr></table></figure><p>测试如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; hget user:1 age</span><br><span class="line">&quot;29&quot;</span><br><span class="line">127.0.0.1:6379&gt; hstrlen user:1 age</span><br><span class="line">(integer) 2</span><br></pre></td></tr></table></figure><h2 id="2-3-编码介绍"><a href="#2-3-编码介绍" class="headerlink" title="2.3 编码介绍"></a>2.3 编码介绍</h2><p>之前在Redis基础命令博客的<code>object encoding</code>中提到，hash有两种编码方式，一个是ziplist，一个是hashtable。</p><p>其中ziplist是在hash中元素较少的情况下使用的，如下所示，刚开始hash中的f1只有3个字节的字符串长度，使用的是ziplist来存放；当我买尝试设置一个非常长的字符串f2，就会切换成hashtable来存放。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; hset key f1 111</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; object encoding key</span><br><span class="line">&quot;ziplist&quot;</span><br><span class="line">127.0.0.1:6379&gt; hset key f2 235xczbjlkq3e5jl123j5ljlbsjlk32j6l5k1hasldg82357989789787124nlahbkasdlj3215897avsalkjl32k51432097zvlmq32j5</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; object encoding key</span><br><span class="line">&quot;hashtable&quot;</span><br></pre></td></tr></table></figure><p>如果你了解hashtable的数据结构，以拉链法为例，它会有一个数组，内部存放链表指针。存放数据时，通过哈希函数计算出key所在下标位置，将value链接到数组下标位置的对应指针上，即为存放完毕。当hash表中的元素较少时，数组可能会空出几个下标的位置没有value链接，这几个下标的空间就算是浪费了。</p><p>而使用ziplist就可以节省这部分空间的浪费，对应的代价是ziplist的读写速度会慢于原生hashtable。</p><p>在Redis中可以通过下面两个配置项来设置hash什么时候使用ziplist，写入<code>/etc/redis/redis.conf</code>即可。</p><table><thead><tr><th>配置</th><th>功能</th><th>备注</th></tr></thead><tbody><tr><td>hash-max-ziplist-entries</td><td>设置field个数为多少以下时使用ziplist</td><td>默认512个</td></tr><tr><td>hash-max-ziplist-value</td><td>设置hash中value字符串的最大长度</td><td>默认为64字节</td></tr></tbody></table><h2 id="2-4-应用场景"><a href="#2-4-应用场景" class="headerlink" title="2.4 应用场景"></a>2.4 应用场景</h2><h3 id="2-4-1-关系数据库缓存"><a href="#2-4-1-关系数据库缓存" class="headerlink" title="2.4.1 关系数据库缓存"></a>2.4.1 关系数据库缓存</h3><p>正如介绍阶段时提到的，hash非常适合用于存放一些结构化的数据。以用户数据为例，可以用uid作为key的标识，内部存放对应的个人信息。有的时候为了方便，还会在hash中再存放一次uid。</p><table><thead><tr><th>key</th><th>field</th><th>value</th></tr></thead><tbody><tr><td>user:1</td><td>uid</td><td>1</td></tr><tr><td></td><td>name</td><td>李四</td></tr><tr><td></td><td>ag</td><td>20</td></tr><tr><td></td><td>sex</td><td>男</td></tr><tr><td>user:2</td><td>uid</td><td>2</td></tr><tr><td></td><td>name</td><td>王五</td></tr><tr><td></td><td>age</td><td>23</td></tr><tr><td></td><td>sex</td><td>男</td></tr></tbody></table><p>这样其实就好比一个MySQL数据库中的表</p><table><thead><tr><th>uid</th><th>name</th><th>age</th><th>sex</th></tr></thead><tbody><tr><td>1</td><td>李四</td><td>20</td><td>男</td></tr><tr><td>2</td><td>王五</td><td>23</td><td>男</td></tr></tbody></table><p>用这种方式，我们可以将MySQL中的表直接缓存在Redis中，提供更加快速的查询。需要修改数据的时候，也可以采用先修改Redis中的数据，再异步同步到MySQL中的方式来提高效率。</p><p>当然，使用string+json的方式也可以存放结构化数据，但在使用的时候就涉及到了<strong>json的序列化和反序列化</strong>，效率会低于直接使用Redis里面的hash来存放，不过使用hash会有更大的空间消耗。</p><p>这里还涉及到了高内聚&#x2F;低内聚的概念：</p><ul><li>高内聚：把有关联的数据存放在一起；</li><li>低内聚：有关联的东西散开存放了；</li></ul><p>使用hash来存放用户数据，就属于高内聚。如果使用<code>user:1:name</code>、<code>user:1:age</code>的key&#x2F;value来存放用户数据，就是低内聚，因为用户信息被拆开存放在了不同的key中。</p><p>同理，上文string中提到的视频播放量信息统计，也可以使用hash来存放一个视频的点击量&#x2F;点赞量，将一个视频的数据存放在一个hash中，而不用string来存放。</p><p>我们在设计的时候都强调<strong>高内聚、低耦合</strong>，就是为了整个系统能有更好的整洁度，维护更加方便。</p><h3 id="2-4-2-hash和关系数据库的区别"><a href="#2-4-2-hash和关系数据库的区别" class="headerlink" title="2.4.2 hash和关系数据库的区别"></a>2.4.2 hash和关系数据库的区别</h3><ul><li>哈希类型是稀疏的，关系数据库是结构化的。比如不同的hash里面的field完全没有关系，可以随意设置，但MySQL中一个表想插入一个数据，就必须依照表的要求设置所有数据；</li><li>关系数据库可以进行复杂的关系查询（比如多表查询），而Redis很难模拟关系查询，维护的复杂度很高且没有必要。</li></ul><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/02/d37409c171aed0f980fdea3322e6a54d.png" alt="image-20240219143844313"></p><h1 id="3-List"><a href="#3-List" class="headerlink" title="3 List"></a>3 List</h1><h2 id="3-1-介绍"><a href="#3-1-介绍" class="headerlink" title="3.1 介绍"></a>3.1 介绍</h2><p>Redis中的list列表类型提供了头插头删&#x2F;尾插尾删的命令，我们可以将它当作顺序表、栈、队列来使用。</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/02/e9f8229179473cd0d3ed2afb034c539d.png" alt="image-20240219144352348"></p><p>列表中的元素是按序存放的，所以我们可以通过下标来访问列表中的元素或获取一个范围中的元素。列表中的元素<strong>允许重复</strong>。</p><h2 id="3-2-相关命令"><a href="#3-2-相关命令" class="headerlink" title="3.2 相关命令"></a>3.2 相关命令</h2><h3 id="3-2-1-LINDEX"><a href="#3-2-1-LINDEX" class="headerlink" title="3.2.1 LINDEX"></a>3.2.1 LINDEX</h3><p>根据下标查看list中的数据，当下标超出范围时返回<code>nil</code>；</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LINDEX key index</span><br></pre></td></tr></table></figure><p>index支持负数下标，从后往前数。比如<code>-1</code>代表从后往前第一个数据（即list末尾数据）。</p><p>注意，该命令的时间复杂度是<code>O(N)</code>，因为Redis中的list并非时刻采用顺序表来实现（会有不同编码方式），不能保证顺序表下标访问那样的快速！</p><h3 id="3-2-2-LPUSH-x2F-RPUSH"><a href="#3-2-2-LPUSH-x2F-RPUSH" class="headerlink" title="3.2.2 LPUSH&#x2F;RPUSH"></a>3.2.2 LPUSH&#x2F;RPUSH</h3><p>头插命令，支持一次插入多个数据。如果指定的key不是list类型则报错。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LPUSH key element [element ...]</span><br></pre></td></tr></table></figure><p>注意，当一次插入多个数据时，最后一个数据会在list的头部（按命令中出现的顺序，从左往右插入）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; clear</span><br><span class="line">127.0.0.1:6379&gt; lpush key 1 2 3 4</span><br><span class="line">(integer) 4</span><br><span class="line">127.0.0.1:6379&gt; lindex key 0</span><br><span class="line">&quot;4&quot;</span><br></pre></td></tr></table></figure><p>尾插也是相同的效果</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">RPUSH key element [element ...]</span><br></pre></td></tr></table></figure><p>一次性插入多个数据的时候，也是最后一个数据在list的末尾。可以用lindex命令指定<code>-1</code>下标来获取末尾的数据（从后往前数第一个值）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; rpush key 5 6 7 8</span><br><span class="line">(integer) 8</span><br><span class="line">127.0.0.1:6379&gt; lindex key -1</span><br><span class="line">&quot;8&quot;</span><br></pre></td></tr></table></figure><h3 id="3-2-3-LPOP-x2F-RPOP"><a href="#3-2-3-LPOP-x2F-RPOP" class="headerlink" title="3.2.3 LPOP&#x2F;RPOP"></a>3.2.3 LPOP&#x2F;RPOP</h3><p>从list的头部或者尾部去除数据</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">LPOP key [count]</span><br><span class="line">RPOP key [count]</span><br></pre></td></tr></table></figure><p>注意，高版本Redis才有可选的count选项，当前我使用的Redis仅可一次pop一个元素，返回值是被删除的元素。</p><blockquote><p>Starting with Redis version 6.2.0: Added the <code>count</code> argument.</p></blockquote><p>测试如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; lpop key</span><br><span class="line">&quot;4&quot;</span><br></pre></td></tr></table></figure><p>如果是高版本，指定count参数后，会返回一个被删除元素的array，效果参考下面这个官网给出的examples。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; RPUSH mylist &quot;one&quot; &quot;two&quot; &quot;three&quot; &quot;four&quot; &quot;five&quot;</span><br><span class="line">(integer) 5</span><br><span class="line">redis&gt; LPOP mylist</span><br><span class="line">&quot;one&quot;</span><br><span class="line">redis&gt; LPOP mylist 2</span><br><span class="line">1) &quot;two&quot;</span><br><span class="line">2) &quot;three&quot;</span><br><span class="line">redis&gt; LRANGE mylist 0 -1</span><br><span class="line">1) &quot;four&quot;</span><br><span class="line">2) &quot;five&quot;</span><br><span class="line">redis&gt; </span><br></pre></td></tr></table></figure><p>如果尝试操作一个空的list或者不存在的key，返回值是<code>nil</code>；如下所示，key1的list中只有1个元素，第一次成功删除元素，但是第二次操作的时候key1是一个空list，操作失败返回<code>nil</code>；</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; lpush key1 1</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; lpop key1</span><br><span class="line">&quot;1&quot;</span><br><span class="line">127.0.0.1:6379&gt; lpop key1</span><br><span class="line">(nil)</span><br></pre></td></tr></table></figure><p>当一个list中不存在元素的时候，Redis会自动将该list的key删除！如下所示，当我们把test键值中的元素全部删除时，这个test键值就直接不存在了。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; keys *</span><br><span class="line">(empty array)</span><br><span class="line">127.0.0.1:6379&gt; lpush key 1 2</span><br><span class="line">(integer) 2</span><br><span class="line">127.0.0.1:6379&gt; lpush test 1</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; keys *</span><br><span class="line">1) &quot;key&quot;</span><br><span class="line">2) &quot;test&quot;</span><br><span class="line">127.0.0.1:6379&gt; lpop test</span><br><span class="line">&quot;1&quot;</span><br><span class="line">127.0.0.1:6379&gt; keys *</span><br><span class="line">1) &quot;key&quot;</span><br><span class="line">127.0.0.1:6379&gt;</span><br></pre></td></tr></table></figure><h3 id="3-2-4-LRANGE"><a href="#3-2-4-LRANGE" class="headerlink" title="3.2.4 LRANGE"></a>3.2.4 LRANGE</h3><p>查看list中指定范围的元素，这里的区间是闭区间（最终结果包含start和stop下标的数据），当start小于stop时返回<code>empty array</code>；</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LRANGE key start stop</span><br></pre></td></tr></table></figure><p>示例如下，指定了<code>0</code>和<code>-1</code>等同于获取list中的全部元素。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; lrange key 0 -1</span><br><span class="line">1) &quot;4&quot;</span><br><span class="line">2) &quot;3&quot;</span><br><span class="line">3) &quot;2&quot;</span><br><span class="line">4) &quot;1&quot;</span><br><span class="line">5) &quot;5&quot;</span><br><span class="line">6) &quot;6&quot;</span><br><span class="line">7) &quot;7&quot;</span><br><span class="line">8) &quot;8&quot;</span><br></pre></td></tr></table></figure><p>注意，此处Redis是用array返回的一个结果集，序号是从1开始的（和list中的下标不一样且无关）</p><h4 id="3-2-4-1-超出下标范围"><a href="#3-2-4-1-超出下标范围" class="headerlink" title="3.2.4.1 超出下标范围"></a>3.2.4.1 超出下标范围</h4><p>另外，使用lrange命令指定下标的时候，如果下标超出范围，也会得到尽可能符合下标结果的数据，这点和lindex不同！</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; lrange key 3 10</span><br><span class="line">1) &quot;1&quot;</span><br><span class="line">2) &quot;5&quot;</span><br><span class="line">3) &quot;6&quot;</span><br><span class="line">4) &quot;7&quot;</span><br><span class="line">5) &quot;8&quot;</span><br></pre></td></tr></table></figure><p>如上所示，我尝试访问3到10的数据，但实际上list中的数据下标到7就结束了（一共八个元素），但Redis并没有报错或返回<code>empty array</code>，而是获取了从下标3开始一直到list末尾的数据。</p><p>同理，当你访问超出范围的负数下标，也能得到类似的结果。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; lrange key -10 -1</span><br><span class="line">1) &quot;4&quot;</span><br><span class="line">2) &quot;3&quot;</span><br><span class="line">3) &quot;2&quot;</span><br><span class="line">4) &quot;1&quot;</span><br><span class="line">5) &quot;5&quot;</span><br><span class="line">6) &quot;6&quot;</span><br><span class="line">7) &quot;7&quot;</span><br><span class="line">8) &quot;8&quot;</span><br></pre></td></tr></table></figure><p>当然，实际业务时正确使用合法肯定是更好的！</p><h3 id="3-2-5-LPUSHX-x2F-RPUSHX"><a href="#3-2-5-LPUSHX-x2F-RPUSHX" class="headerlink" title="3.2.5 LPUSHX&#x2F;RPUSHX"></a>3.2.5 LPUSHX&#x2F;RPUSHX</h3><p>和LPUSH&#x2F;RPUSH作用相同，多了一个对key是否存在的检测，只有key存在时才能插入成功。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">LPUSHX key element [element ...]</span><br><span class="line">RPUSHX key element [element ...]</span><br></pre></td></tr></table></figure><p>返回值是插入成功的元素个数，如果key不存在则返回0；</p><h3 id="3-2-6-LINSERT"><a href="#3-2-6-LINSERT" class="headerlink" title="3.2.6 LINSERT"></a>3.2.6 LINSERT</h3><p>这个命令的作用是在指定pivot元素位置插入一个元素，可以通过参数选择是在指定pivot元素之前插入，还是在指定pivot元素之后插入。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LINSERT key &lt;BEFORE | AFTER&gt; pivot element</span><br></pre></td></tr></table></figure><p>该命令时间复杂度是<code>O(N)</code>，N是pivot元素和list开头的距离，返回值如下：</p><ul><li>成功时返回插入元素后list的元素个数；</li><li>key不存在时返回0；</li><li>pivot元素不存在时返回-1，且什么都不会发生；</li></ul><p>测试如下，这里选择的已有元素是4，before会在4之前插入一个元素，after会在4之后插入一个元素。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; lpush key 1 2 3 4 5 6</span><br><span class="line">(integer) 6</span><br><span class="line">127.0.0.1:6379&gt; linsert key before 4 10</span><br><span class="line">(integer) 7</span><br><span class="line">127.0.0.1:6379&gt; lrange key 0 -1</span><br><span class="line">1) &quot;6&quot;</span><br><span class="line">2) &quot;5&quot;</span><br><span class="line">3) &quot;10&quot;</span><br><span class="line">4) &quot;4&quot;</span><br><span class="line">5) &quot;3&quot;</span><br><span class="line">6) &quot;2&quot;</span><br><span class="line">7) &quot;1&quot;</span><br><span class="line">127.0.0.1:6379&gt; linsert key after 4 11</span><br><span class="line">(integer) 8</span><br><span class="line">127.0.0.1:6379&gt; lrange key 0 -1</span><br><span class="line">1) &quot;6&quot;</span><br><span class="line">2) &quot;5&quot;</span><br><span class="line">3) &quot;10&quot;</span><br><span class="line">4) &quot;4&quot;</span><br><span class="line">5) &quot;11&quot;</span><br><span class="line">6) &quot;3&quot;</span><br><span class="line">7) &quot;2&quot;</span><br><span class="line">8) &quot;1&quot;</span><br></pre></td></tr></table></figure><p>清空key后重新测试，如果list中有多个相同的pivot元素，会在哪里操作呢？可以看到它会在第一个5的位置操作，即pivot会采用第一个找到的元素。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; lpush key 1 2 5 3 4 5 6</span><br><span class="line">(integer) 7</span><br><span class="line">127.0.0.1:6379&gt; linsert key before 5 10</span><br><span class="line">(integer) 8</span><br><span class="line">127.0.0.1:6379&gt; lrange key 0 -1</span><br><span class="line">1) &quot;6&quot;</span><br><span class="line">2) &quot;10&quot;</span><br><span class="line">3) &quot;5&quot;</span><br><span class="line">4) &quot;4&quot;</span><br><span class="line">5) &quot;3&quot;</span><br><span class="line">6) &quot;5&quot;</span><br><span class="line">7) &quot;2&quot;</span><br><span class="line">8) &quot;1&quot;</span><br></pre></td></tr></table></figure><h3 id="3-2-7-LLEN"><a href="#3-2-7-LLEN" class="headerlink" title="3.2.7 LLEN"></a>3.2.7 LLEN</h3><p>获取list的长度，如果key不存在返回0；</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LLEN key</span><br></pre></td></tr></table></figure><h3 id="3-2-8-LREM"><a href="#3-2-8-LREM" class="headerlink" title="3.2.8 LREM"></a>3.2.8 LREM</h3><p>删除list中指定的值，返回值是被删除元素的个数</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LREM key count element</span><br></pre></td></tr></table></figure><p>count参数的可选项如下</p><ul><li>count大于0：从前往后删除count个等于element的元素；</li><li>count小于0：从后往前删除<code>|count|</code>个等于element的元素；</li><li>count等于0：删除所有等于element的元素；</li></ul><p>测试一下，使用rpush可以让list和我们输入的顺序一致。这里指定的count大于0，删除的元素是1，最终删除了从前往后数的两个1。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; rpush key 1 2 3 4 1 2 3 4 1 2 3 4</span><br><span class="line">(integer) 12</span><br><span class="line">127.0.0.1:6379&gt; lrem key 2 1</span><br><span class="line">(integer) 2</span><br><span class="line">127.0.0.1:6379&gt; lrange key 0 -1</span><br><span class="line"> 1) &quot;2&quot;</span><br><span class="line"> 2) &quot;3&quot;</span><br><span class="line"> 3) &quot;4&quot;</span><br><span class="line"> 4) &quot;2&quot;</span><br><span class="line"> 5) &quot;3&quot;</span><br><span class="line"> 6) &quot;4&quot;</span><br><span class="line"> 7) &quot;1&quot;</span><br><span class="line"> 8) &quot;2&quot;</span><br><span class="line"> 9) &quot;3&quot;</span><br><span class="line">10) &quot;4&quot;</span><br></pre></td></tr></table></figure><p>再指定count为-1，删除元素是3，会删除从后往前数的第一个3；</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; lrem key -1 3</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; lrange key 0 -1</span><br><span class="line">1) &quot;2&quot;</span><br><span class="line">2) &quot;3&quot;</span><br><span class="line">3) &quot;4&quot;</span><br><span class="line">4) &quot;2&quot;</span><br><span class="line">5) &quot;3&quot;</span><br><span class="line">6) &quot;4&quot;</span><br><span class="line">7) &quot;1&quot;</span><br><span class="line">8) &quot;2&quot;</span><br><span class="line">9) &quot;4&quot;</span><br></pre></td></tr></table></figure><p>指定count为0，删除元素是4，list中的所有4都会被删除</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; lrem key 0 4</span><br><span class="line">(integer) 3</span><br><span class="line">127.0.0.1:6379&gt; lrange key 0 -1</span><br><span class="line">1) &quot;2&quot;</span><br><span class="line">2) &quot;3&quot;</span><br><span class="line">3) &quot;2&quot;</span><br><span class="line">4) &quot;3&quot;</span><br><span class="line">5) &quot;1&quot;</span><br><span class="line">6) &quot;2&quot;</span><br></pre></td></tr></table></figure><h3 id="3-2-9-LTRIM"><a href="#3-2-9-LTRIM" class="headerlink" title="3.2.9 LTRIM"></a>3.2.9 LTRIM</h3><p>删除list中指定区间<strong>外</strong>的元素（即保留指定的闭区间，其他都删除）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LTRIM key start stop</span><br></pre></td></tr></table></figure><p>示例如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; rpush key 1 2 3 4 5 6</span><br><span class="line">(integer) 6</span><br><span class="line">127.0.0.1:6379&gt; ltrim key 2 3</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; lrange key 0 -1</span><br><span class="line">1) &quot;3&quot;</span><br><span class="line">2) &quot;4&quot;</span><br></pre></td></tr></table></figure><h3 id="3-2-10-LSET"><a href="#3-2-10-LSET" class="headerlink" title="3.2.10 LSET"></a>3.2.10 LSET</h3><p>该命令可以设置某个下标的元素（替换）。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LSET key index element</span><br></pre></td></tr></table></figure><p>该命令的时间复杂度是<code>O(N)</code>，这就和LINDEX的原因一样，因为Redis不总是用顺序表来存放list的数据，所以无法保证<code>O(1)</code>下标访问一样的时间复杂度。</p><h3 id="3-2-11-BLPOP-x2F-BRPOP（阻塞版本）"><a href="#3-2-11-BLPOP-x2F-BRPOP（阻塞版本）" class="headerlink" title="3.2.11 BLPOP&#x2F;BRPOP（阻塞版本）"></a>3.2.11 BLPOP&#x2F;BRPOP（阻塞版本）</h3><h4 id="3-2-11-1-阻塞命令说明"><a href="#3-2-11-1-阻塞命令说明" class="headerlink" title="3.2.11.1 阻塞命令说明"></a>3.2.11.1 阻塞命令说明</h4><p>BLPOP和BRPOP是LPOP&#x2F;RPOP的阻塞版本，命令里面的B就是block阻塞的缩写。这也是我们第一次接触Redis里面的“阻塞命令”。</p><p>使用这两个命令的时候，list就可以当作一个阻塞队列（和Linux的管道也有点相似）了：</p><ul><li>如果队列为空，尝试出队列时会阻塞;</li><li>如果队列已满，尝试入队列时会阻塞;</li></ul><p>对于Redis而言，list一般不存在“满”的情况，我们大多考虑队列为空的情况。而Redis的单线程模型也保证了这个“阻塞队列”是线程安全的。</p><p>另外，Redis提供的阻塞命令<strong>并不会把自己给阻塞</strong>，而类似于阻塞了客户端，使用BLPOP&#x2F;BRPOP的时候需要给定一个timeout参数，在阻塞等待的期间，<strong>Redis可以正常响应其他的命令和请求</strong>。</p><p>而被阻塞的客户端实际上是在等待其他客户端往对应list中插入新元素。</p><h4 id="3-2-11-2-命令参数"><a href="#3-2-11-2-命令参数" class="headerlink" title="3.2.11.2 命令参数"></a>3.2.11.2 命令参数</h4><p><a href="https://redis.io/commands/blpop/">https://redis.io/commands/blpop/</a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">BLPOP key [key ...] timeout</span><br><span class="line">BRPOP key [key ...] timeout</span><br></pre></td></tr></table></figure><p>注意：timeout单位为秒，Redis 6中可以设置为小数，设置为0时代表永久阻塞。</p><p>这两个命令都可以指定多个key，当指定多个key的时候，Redis会进行从左往右的遍历，只要其中一个key对应的list有元素，就会立刻返回。相当于一次等多个list。</p><blockquote><p>如果有多个客户端都需要使用这两个命令来等待<strong>同一个key</strong>，那么先执行命令的客户端会得到弹出的元素。</p></blockquote><p>因为blpop&#x2F;brlpop都支持多个key值等待，为了标定弹出的键属于哪一个key，这两个命令在返回的时候会返回array类型的key+value；</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; blpop key 0</span><br><span class="line">1) &quot;key&quot;</span><br><span class="line">2) &quot;4&quot;</span><br></pre></td></tr></table></figure><p>当超时时间结束时，给定的几个key的list还是为空，则会返回nil；</p><h4 id="3-2-11-3-命令预期行为"><a href="#3-2-11-3-命令预期行为" class="headerlink" title="3.2.11.3 命令预期行为"></a>3.2.11.3 命令预期行为</h4><p>当list不为空时，lpop和blpop的命令行为完全一致。</p><p>当list为空，且blpop指定的timeout时间中没有新元素插入list时：</p><ul><li>lpop会立马得到nil；</li><li>blpop会在等待timeout时间后得到nil；</li><li>此时lpop和brlpop的命令行为就不一致了。</li></ul><p>当list为空，且timeout时间内有新元素插入</p><ul><li>因为原本list是为空的，所以lpop还是会立马得到nil；</li><li>blpop会在新元素插入后返回key和新元素；</li></ul><h4 id="3-2-11-4-阻塞测试"><a href="#3-2-11-4-阻塞测试" class="headerlink" title="3.2.11.4 阻塞测试"></a>3.2.11.4 阻塞测试</h4><p>下面是一个阻塞时的测试，使用0来指定永久阻塞，当右侧终端回车提交插入操作时，左侧的阻塞会立马返回数据。</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/02/2a28441785171abc8b20a27af768dfd9.png" alt="image-20240221211633743"></p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/02/a466d5f993d3a24be07a7dd93037a8c1.png" alt="image-20240221211639797"></p><p>尝试等待多个key，只要有一个key返回了数据，阻塞的终端就会立马返回。虽然说这个等待时遍历的顺序是从左往右的，但由于Redis是单线程模型，不会出现两个key同时新增数据的情况，<strong>总会有个先后顺序</strong>，所以最终还是等待列表中，<strong>哪一个key先有数据插入</strong>，哪一个key就会被blpop返回。</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/02/8156e009dcd7a8ac02ade9b5df20bbed.png" alt="image-20240221212327656"></p><p>如果开始遍历的时候，key没有数据，key1和key2有数据，那么Redis就会按从左往右的原则，返回key1的数据。</p><h2 id="3-3-编码方式"><a href="#3-3-编码方式" class="headerlink" title="3.3 编码方式"></a>3.3 编码方式</h2><p>旧版本Redis中list的编码方式有两个</p><ul><li>ziplist：为短list优化</li><li>linklist：正常的双向链表</li></ul><p>但在新版本（Redis 3.2以后）对list的数据结构进行了改造，使用quicklist替代了ziplist&#x2F;linklist，更多信息可以参考：<a href="https://www.cnblogs.com/hunternet/p/12624691.html">redis数据结构-快速列表</a>；</p><h2 id="3-4-应用场景"><a href="#3-4-应用场景" class="headerlink" title="3.4 应用场景"></a>3.4 应用场景</h2><h3 id="3-4-1-栈和队列"><a href="#3-4-1-栈和队列" class="headerlink" title="3.4.1 栈和队列"></a>3.4.1 栈和队列</h3><p>使用list来模拟栈或者队列的功能</p><ul><li>队列：只使用rpush和lpop命令</li><li>栈：只使用lpush和lpop命令</li></ul><h3 id="3-4-2-班级中有那些学生-x2F-部门中有那些员工"><a href="#3-4-2-班级中有那些学生-x2F-部门中有那些员工" class="headerlink" title="3.4.2 班级中有那些学生&#x2F;部门中有那些员工"></a>3.4.2 班级中有那些学生&#x2F;部门中有那些员工</h3><p>可以使用list将一个班级id作为key，学生id作为list里面的元素。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">class:1  [1,3,4]</span><br><span class="line">class:2  [2,5,6]</span><br></pre></td></tr></table></figure><p>这样我们就可以通过list来得知每个班级对应的学生id编号。部门和员工的关系也是一样的；</p><h3 id="3-4-3-消息队列"><a href="#3-4-3-消息队列" class="headerlink" title="3.4.3 消息队列"></a>3.4.3 消息队列</h3><p>使用BLPOP&#x2F;BRPOP这两个命令就可以让list作为一个简单的消息队列来使用。</p><p>以“生产-消费者模型”为例，生产者往list中插入数据，消费者使用BLPOP等待新数据的插入并进行消费。此时可以有多个生产者进行push，也可以有多个消费者同时使用BLPOP命令等待list中的新数据插入。</p><p>因为Redis不存在多线程竞争的问题，所以新数据插入后只会有一个消费者能拿到数据进行消费。并且多个消费者执行BLPOP命令时也存在一个先后顺序，按123的顺序来说的话，这一次消费者1拿到了数据，下一次就是消费者2，再下一次就是消费者3，不会出现某个消费者<strong>饥饿</strong>的情况。</p><h3 id="3-4-4-视频信息传递"><a href="#3-4-4-视频信息传递" class="headerlink" title="3.4.4 视频信息传递"></a>3.4.4 视频信息传递</h3><p>以一个视频网站为例，使用list作为消息队列时，可以采用一个视频对应多个key的方式来处理</p><ul><li>视频数据</li><li>视频评论</li><li>视频新弹幕</li><li>…</li></ul><p>对应的消费者可以通过BLPOP命令一次性等待多个key，这样不管是新的评论来了，还是新的弹幕来了，都能在第一时间被处理。</p><h3 id="3-4-5-用户的timeline"><a href="#3-4-5-用户的timeline" class="headerlink" title="3.4.5 用户的timeline"></a>3.4.5 用户的timeline</h3><p>因为list里面的元素是有序的，先插入的始终是在list的头部。我们就可以通过list来实现一个时间轴的功能。</p><p>当用户新建一个微博的时候，就将这个微博的id插入用户相关的list，这样用户和他上传的微博就有了一个时间的关系，还可以用lrange命令很方便的获取到用户的前n个微博，或某个区间的微博。</p><p>下面是一个分页获取用户微博的伪代码</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 先获取用户前10个微博</span></span><br><span class="line">key_list = <span class="string">&quot;LRANGE user:1:blog 0 9&quot;</span></span><br><span class="line"><span class="comment"># 遍历每个key获取到微博的详细信息</span></span><br><span class="line"><span class="keyword">for</span> key <span class="keyword">in</span> key_list: </span><br><span class="line">blog_info = <span class="string">&quot;HGETALL key&quot;</span></span><br></pre></td></tr></table></figure><p>这里就会出现一个问题，假设将单个分页需要显示的数据设置为100，那么每次循环中就会多次调用hash类型的HGETALL命令，导致Redis可能被阻塞。</p><blockquote><p>这个问题可以使用pipeline来解决，相当于将多个Redis命令合并成一个网络请求来执行，可以减少网络传输多次导致的延迟。后续将学习相关内容。</p></blockquote><p>另外一个问题是，lrange针对list两头的查询效率还不错（因为可以直接从头或从尾部开始遍历）但对中间的分页获取的效率就有点低了。这个问题可以通过list来解决（有点类似分库分表）。</p><h1 id="4-Set"><a href="#4-Set" class="headerlink" title="4 Set"></a>4 Set</h1><p>set是一个集合，集合中的每个元素都是string类型。它和list的区别主要在于：</p><ul><li>set的元素不可以重复；</li><li>set的元素是无序的；</li></ul><p>所谓无需，是相对于list的有序而言的（注意，list的有序指的是顺序表中元素的顺序，并不是说list会按大小排序）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[1,2,3] 和 [1,3,2] 是两个不同的list</span><br><span class="line">[1,2,3] 和 [1,3,2] 和 [2,3,1] 都是相同的set</span><br></pre></td></tr></table></figure><h2 id="4-1-相关命令"><a href="#4-1-相关命令" class="headerlink" title="4.1 相关命令"></a>4.1 相关命令</h2><h3 id="4-1-1-SADD"><a href="#4-1-1-SADD" class="headerlink" title="4.1.1 SADD"></a>4.1.1 SADD</h3><p>SADD命令用于给set中添加元素，为了和list中的元素作区分，set中的元素被称为member。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SADD key member [member ...]</span><br></pre></td></tr></table></figure><p>返回值表示本次操作添加成功了几个元素，重复的元素只会被添加一次。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; sadd key 1 2 3 4</span><br><span class="line">(integer) 4</span><br><span class="line">127.0.0.1:6379&gt; sadd key1 1 2 3 4 5 4</span><br><span class="line">(integer) 5</span><br></pre></td></tr></table></figure><h3 id="4-1-2-SMEMBERS"><a href="#4-1-2-SMEMBERS" class="headerlink" title="4.1.2 SMEMBERS"></a>4.1.2 SMEMBERS</h3><p>查看set的所有成员</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SMEMBERS key</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; smembers key</span><br><span class="line">1) &quot;1&quot;</span><br><span class="line">2) &quot;2&quot;</span><br><span class="line">3) &quot;3&quot;</span><br><span class="line">4) &quot;4&quot;</span><br></pre></td></tr></table></figure><h3 id="4-1-3-SISMEMBER"><a href="#4-1-3-SISMEMBER" class="headerlink" title="4.1.3 SISMEMBER"></a>4.1.3 SISMEMBER</h3><p>查看某个元素是否在集合中</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SISMEMBER key member</span><br></pre></td></tr></table></figure><p>返回值为1代表存在，返回值为0代表不存在。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; sismember key 1</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; sismember key 120</span><br><span class="line">(integer) 0</span><br></pre></td></tr></table></figure><h3 id="4-1-4-SPOP"><a href="#4-1-4-SPOP" class="headerlink" title="4.1.4 SPOP"></a>4.1.4 SPOP</h3><p>该命令可以弹出set中的元素。但因为set是无序的，所以我们只能指定删除元素的个数，Redis会<strong>随机删除（弹出）</strong>set中的元素，这一点在官方文档中有说明。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SPOP key [count]</span><br></pre></td></tr></table></figure><p>返回值是被删除的元素</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; spop key 2</span><br><span class="line">1) &quot;1&quot;</span><br><span class="line">2) &quot;4&quot;</span><br><span class="line">127.0.0.1:6379&gt; spop key</span><br><span class="line">&quot;2&quot;</span><br></pre></td></tr></table></figure><p>这个命令也能体现出set中元素无序的概念。我们按1234构架两个set，尝试进行spop，能发现每次删除的元素的顺序是不一样的，完全随机。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; sadd key1 1 2 3 4</span><br><span class="line">(integer) 4</span><br><span class="line">127.0.0.1:6379&gt; sadd key2 1 2 3 4</span><br><span class="line">(integer) 4</span><br><span class="line">127.0.0.1:6379&gt; spop key1</span><br><span class="line">&quot;1&quot;</span><br><span class="line">127.0.0.1:6379&gt; spop key1</span><br><span class="line">&quot;2&quot;</span><br><span class="line">127.0.0.1:6379&gt; spop key1</span><br><span class="line">&quot;4&quot;</span><br><span class="line">127.0.0.1:6379&gt; spop key1</span><br><span class="line">&quot;3&quot;</span><br><span class="line">127.0.0.1:6379&gt; spop key2</span><br><span class="line">&quot;2&quot;</span><br><span class="line">127.0.0.1:6379&gt; spop key2</span><br><span class="line">&quot;3&quot;</span><br><span class="line">127.0.0.1:6379&gt; spop key2</span><br><span class="line">&quot;4&quot;</span><br><span class="line">127.0.0.1:6379&gt; spop key2</span><br><span class="line">&quot;1&quot;</span><br></pre></td></tr></table></figure><h3 id="4-1-5-SRANDMEMBER"><a href="#4-1-5-SRANDMEMBER" class="headerlink" title="4.1.5 SRANDMEMBER"></a>4.1.5 SRANDMEMBER</h3><p>这个命令和SPOP功能类似，返回set中的一个或多个随机数据，但不会删除该数据。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SRANDMEMBER key [count]</span><br></pre></td></tr></table></figure><h3 id="4-1-6-SMOVE"><a href="#4-1-6-SMOVE" class="headerlink" title="4.1.6 SMOVE"></a>4.1.6 SMOVE</h3><p>将某个元素从set1移动到set2，或者说是从source中删除，在destination中新增。</p><p>如果destination中已经存在该元素，则只会删除source中的元素。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SMOVE source destination member</span><br></pre></td></tr></table></figure><p>测试如下，该命令成功时返回1，不成功返回0（source中不存在该元素时失败）；</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; sadd key1 1 2 3</span><br><span class="line">(integer) 3</span><br><span class="line">127.0.0.1:6379&gt; sadd key2 5 6</span><br><span class="line">(integer) 2</span><br><span class="line">127.0.0.1:6379&gt; smove key1 key2 3</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; smembers key2</span><br><span class="line">1) &quot;3&quot;</span><br><span class="line">2) &quot;5&quot;</span><br><span class="line">3) &quot;6&quot;</span><br><span class="line">127.0.0.1:6379&gt; smove key1 key2 33</span><br><span class="line">(integer) 0</span><br></pre></td></tr></table></figure><h3 id="4-1-7-SREM"><a href="#4-1-7-SREM" class="headerlink" title="4.1.7 SREM"></a>4.1.7 SREM</h3><p>删除set中的指定元素</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SREM key member [member ...]</span><br></pre></td></tr></table></figure><h3 id="4-1-8-SINTER-x2F-SINTERSTORE"><a href="#4-1-8-SINTER-x2F-SINTERSTORE" class="headerlink" title="4.1.8 SINTER&#x2F;SINTERSTORE"></a>4.1.8 SINTER&#x2F;SINTERSTORE</h3><p>求两个集合的交集，即获取同时出现在两个set中的元素。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SINTER key [key ...]</span><br></pre></td></tr></table></figure><p>这个命令的时间复杂度是<code>O(M*N)</code>，其中M是最小的集合元素个数，N是最大的集合元素个数。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; sadd key1 1 2 3 4</span><br><span class="line">(integer) 4</span><br><span class="line">127.0.0.1:6379&gt; sadd key2 3 4 5 6</span><br><span class="line">(integer) 4</span><br><span class="line">127.0.0.1:6379&gt; sinter key1 key2</span><br><span class="line">1) &quot;3&quot;</span><br><span class="line">2) &quot;4&quot;</span><br></pre></td></tr></table></figure><p>另外一个命令是SINTERSTORE，它多了一个存储功能，求了交集后，存储到destination中。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SINTERSTORE destination key [key ...]</span><br></pre></td></tr></table></figure><p>这个命令的返回值是最终交集的元素个数。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; sinterstore key3 key1 key2</span><br><span class="line">(integer) 2</span><br></pre></td></tr></table></figure><h3 id="4-1-9-SUNION-x2F-SUNIONSTORE"><a href="#4-1-9-SUNION-x2F-SUNIONSTORE" class="headerlink" title="4.1.9 SUNION&#x2F;SUNIONSTORE"></a>4.1.9 SUNION&#x2F;SUNIONSTORE</h3><p>求两个集合的并集</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SUNION key [key ...]</span><br><span class="line">SUNIONSTROE destination key [key ...]</span><br></pre></td></tr></table></figure><p>功能和上面的命令类似，这里就不做演示了</p><h3 id="4-1-10-SDIFF-x2F-SDIFFSTORE"><a href="#4-1-10-SDIFF-x2F-SDIFFSTORE" class="headerlink" title="4.1.10 SDIFF&#x2F;SDIFFSTORE"></a>4.1.10 SDIFF&#x2F;SDIFFSTORE</h3><p>求集合的差集，即存在于第一个key，但是不在第二个key中的值</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SDIFF key [key ...]</span><br><span class="line">SDIFFSTROE destination key [key ...]</span><br></pre></td></tr></table></figure><p>实测如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; sadd key1 1 2 3 4</span><br><span class="line">(integer) 4</span><br><span class="line">127.0.0.1:6379&gt; sadd key2 3 4 5 6</span><br><span class="line">(integer) 4</span><br><span class="line">127.0.0.1:6379&gt; sdiff key1 key2</span><br><span class="line">1) &quot;1&quot;</span><br><span class="line">2) &quot;2&quot;</span><br><span class="line">127.0.0.1:6379&gt; sdiff key2 key1</span><br><span class="line">1) &quot;5&quot;</span><br><span class="line">2) &quot;6&quot;</span><br></pre></td></tr></table></figure><p>如果key的数量不止两个，你可以理解为Redis会进行依次计算。即先计算key1和key2的差集，再将结果和key3进行计算。如下所示，key1和key2的差集包含1和2，但是key3中有1，所以最终的差集结果就只有2了。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; sadd key3 1 3 7 8</span><br><span class="line">(integer) 4</span><br><span class="line">127.0.0.1:6379&gt; sdiff key1 key2 key3</span><br><span class="line">1) &quot;2&quot;</span><br></pre></td></tr></table></figure><h3 id="4-1-11-SCARD"><a href="#4-1-11-SCARD" class="headerlink" title="4.1.11 SCARD"></a>4.1.11 SCARD</h3><p>获取set中元素的个数</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SCARD key</span><br></pre></td></tr></table></figure><p>测试如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; sadd key1 1 2 3 4</span><br><span class="line">(integer) 4</span><br><span class="line">127.0.0.1:6379&gt; scard key1</span><br><span class="line">(integer) 4</span><br></pre></td></tr></table></figure><h2 id="4-2-编码方式"><a href="#4-2-编码方式" class="headerlink" title="4.2 编码方式"></a>4.2 编码方式</h2><p>set有两种编码方式</p><ul><li>intset：如果set中全都是整数，采用这种方式，可以通过<code>set-max-intset-entries</code>来配置元素个数，超过这个数量的会采用hashtable。</li><li>hashtable：当set中有其他非数字类型时，采用这种方式。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; sadd key 1 2 3 4</span><br><span class="line">(integer) 4</span><br><span class="line">127.0.0.1:6379&gt; object encoding key</span><br><span class="line">&quot;intset&quot;</span><br><span class="line">127.0.0.1:6379&gt; sadd key 1afb</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; object encoding key</span><br><span class="line">&quot;hashtable&quot;</span><br></pre></td></tr></table></figure><h2 id="4-3-应用场景"><a href="#4-3-应用场景" class="headerlink" title="4.3 应用场景"></a>4.3 应用场景</h2><h3 id="4-3-1-保存标签"><a href="#4-3-1-保存标签" class="headerlink" title="4.3.1 保存标签"></a>4.3.1 保存标签</h3><p>一个视频会有相关标签，一个用户也会有相关标签，set类型有元素不能重复的特性，比较适合用于保存某个对象的标签。</p><p>比如某个用户的兴趣爱好，这些爱好能帮助刻画一个用户画像，以便更加精确的推送用户喜欢的东西（或则广告）</p><h3 id="4-3-2-公共好友"><a href="#4-3-2-公共好友" class="headerlink" title="4.3.2 公共好友"></a>4.3.2 公共好友</h3><p>通过集合求交集，能很容易得到两个用户的公共好友，或者共同关注了xxx。</p><h3 id="4-3-3-记录站点PV-x2F-UV"><a href="#4-3-3-记录站点PV-x2F-UV" class="headerlink" title="4.3.3 记录站点PV&#x2F;UV"></a>4.3.3 记录站点PV&#x2F;UV</h3><p>站点PV（Page View）指的是站点的访问量，每次点击一个页面，就会产生一个PV。</p><p>站点UV（User View）指的是站点的用户访问量，每个用户只会记录一次。</p><p>因为PV和UV的记录内容不同，在记录的时候需要进行一定的去重。比如UV需要按用户去重，一个用户只能记录一次。这时候用set来去重就比较方便了，当有新用户访问页面的时候，就将这个用户的id插入到对应key的set中，最终记录UV就获取这个set的长度就行。</p><h1 id="5-Zset"><a href="#5-Zset" class="headerlink" title="5.Zset"></a>5.Zset</h1><p>Zset是有序的集合，在集合的基础上，对内容会进行升序排序。</p><p>Zset中的member同时引入了一个<code>score</code>分数的属性，每个member都会有一个自己的分数，排序的时候就是按分数的大小来进行<strong>升序排序</strong>的。Zset中的member必须唯一，但score分数可以重复。</p><p>注意，member&#x2F;score之间的关系并非键值对，score只是member的一个用于排序的属性值！在Zset中既可以通过member查询score，也可以通过score来查询member。</p><p>Zset中的分数可以是小数。如果多个元素有相同的分数，则按元素的字典序排序。</p><h2 id="5-1-相关命令"><a href="#5-1-相关命令" class="headerlink" title="5.1 相关命令"></a>5.1 相关命令</h2><h3 id="5-1-1-ZADD"><a href="#5-1-1-ZADD" class="headerlink" title="5.1.1 ZADD"></a>5.1.1 ZADD</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ZADD key [NX | XX] [GT | LT] [CH] [INCR] score member [score member</span><br><span class="line">  ...]</span><br></pre></td></tr></table></figure><p>ZADD命令有很多选项，其中一些选项之前已经见过了</p><ul><li>XX：只有member存在的时候，才会更新分数；</li><li>NX：插入新的member，如果已存在则不做任何处理；</li><li>LT：只有新的score<strong>小于</strong>当前score时才会更新， 不会阻止添加新元素（不存在的member正常添加）</li><li>GT：同上，但只有新的score<strong>大于</strong>当前score时才会更新；</li><li>CH：一般情况下，ZADD返回新元素被添加的个数。添加CH选项后，会返回新元素被添加的个数+被修改score的元素个数。</li><li>INCR：当指定此选项时，ZADD的作用类似于ZINCRBY。在此模式下只能指定一个score-element对。</li></ul><p>这个命令的时间复杂度<code>O(log(N))</code>，<strong>N是Zset中元素的个数</strong>。因为zset作为有序的结构，需要将新插入的元素放到正确的位置上，这个操作会有耗时。</p><p>插入数据后查看，可以看到数据是按我们预先设置是分数进行升序排序的。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; zadd key 98 lisi 97 zhangsan 99 wangwu</span><br><span class="line">(integer) 3</span><br><span class="line">127.0.0.1:6379&gt; zrange key 0 -1</span><br><span class="line">1) &quot;zhangsan&quot;</span><br><span class="line">2) &quot;lisi&quot;</span><br><span class="line">3) &quot;wangwu&quot;</span><br></pre></td></tr></table></figure><p>测试NX&#x2F;XX选项，如果不带任何选项，则会更新已有member的分数（原本lisi的分数是98），带了NX选项后，lisi的分数没有被修改。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; zadd key 99 lisi</span><br><span class="line">(integer) 0</span><br><span class="line">127.0.0.1:6379&gt;  zrange key 0 -1 withscores</span><br><span class="line">1) &quot;zhangsan&quot;</span><br><span class="line">2) &quot;97&quot;</span><br><span class="line">3) &quot;lisi&quot;</span><br><span class="line">4) &quot;99&quot;</span><br><span class="line">5) &quot;wangwu&quot;</span><br><span class="line">6) &quot;99&quot;</span><br><span class="line">127.0.0.1:6379&gt; zadd key nx 100 lisi</span><br><span class="line">(integer) 0</span><br><span class="line">127.0.0.1:6379&gt;  zrange key 0 -1 withscores</span><br><span class="line">1) &quot;zhangsan&quot;</span><br><span class="line">2) &quot;97&quot;</span><br><span class="line">3) &quot;lisi&quot;</span><br><span class="line">4) &quot;99&quot;</span><br><span class="line">5) &quot;wangwu&quot;</span><br><span class="line">6) &quot;99&quot;</span><br></pre></td></tr></table></figure><p>带xx选项，lisi的分数被修改成功</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; zadd key xx 100 lisi</span><br><span class="line">(integer) 0</span><br><span class="line">127.0.0.1:6379&gt; zrange key 0 -1 withscores</span><br><span class="line">1) &quot;zhangsan&quot;</span><br><span class="line">2) &quot;97&quot;</span><br><span class="line">3) &quot;wangwu&quot;</span><br><span class="line">4) &quot;99&quot;</span><br><span class="line">5) &quot;lisi&quot;</span><br><span class="line">6) &quot;100&quot;</span><br></pre></td></tr></table></figure><p>带xx选项操作一个不存在的member，没有被新增</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; zadd key xx 100 kk</span><br><span class="line">(integer) 0</span><br><span class="line">127.0.0.1:6379&gt;  zrange key 0 -1 withscores</span><br><span class="line">1) &quot;zhangsan&quot;</span><br><span class="line">2) &quot;97&quot;</span><br><span class="line">3) &quot;wangwu&quot;</span><br><span class="line">4) &quot;99&quot;</span><br><span class="line">5) &quot;lisi&quot;</span><br><span class="line">6) &quot;100&quot;</span><br></pre></td></tr></table></figure><p>ch会在返回值中带上被修改分数的个数，如下所示，kk已经存在，将分数修改为110，带ch选项，返回值为1；再次修改kk的分数，不带ch选项，返回值为0，但kk的分数已经被修改为112了。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; zadd key xx ch 110 kk</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; zadd key xx 112 kk</span><br><span class="line">(integer) 0</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"> 9) &quot;kk&quot;</span><br><span class="line">10) &quot;112&quot;</span><br></pre></td></tr></table></figure><h3 id="5-1-2-ZRANGE"><a href="#5-1-2-ZRANGE" class="headerlink" title="5.1.2 ZRANGE"></a>5.1.2 ZRANGE</h3><p>ZRANGE类似于LRANGE，可以用下标的方式来查看Zset中的元素个数。因为Zset中的元素有序，所以它存在“下标”的概念。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ZRANGE key start stop [BYSCORE | BYLEX] [REV] [LIMIT offset count]</span><br><span class="line">  [WITHSCORES]</span><br></pre></td></tr></table></figure><p>这个命令的时间复杂度是<code>O(log(N)+M)</code>，其中N是ZSET中的元素个数，M是需要返回的元素个数。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; zadd key 98 lisi 97 zhangsan 99 wangwu</span><br><span class="line">(integer) 3</span><br><span class="line">127.0.0.1:6379&gt; zrange key 0 -1</span><br><span class="line">1) &quot;zhangsan&quot;</span><br><span class="line">2) &quot;lisi&quot;</span><br><span class="line">3) &quot;wangwu&quot;</span><br></pre></td></tr></table></figure><p>使用WITHSCORES选项，可以让元素和分数一起返回</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; zrange key 0 -1 withscores</span><br><span class="line">1) &quot;zhangsan&quot;</span><br><span class="line">2) &quot;97&quot;</span><br><span class="line">3) &quot;lisi&quot;</span><br><span class="line">4) &quot;98&quot;</span><br><span class="line">5) &quot;wangwu&quot;</span><br><span class="line">6) &quot;99&quot;</span><br></pre></td></tr></table></figure><h3 id="5-1-3-ZCARD"><a href="#5-1-3-ZCARD" class="headerlink" title="5.1.3 ZCARD"></a>5.1.3 ZCARD</h3><p>获取Zset中元素的个数（被称为zset的基数）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ZCARD key</span><br></pre></td></tr></table></figure><p>测试如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt;  zrange key 0 -1</span><br><span class="line">1) &quot;zhangsan&quot;</span><br><span class="line">2) &quot;wangwu&quot;</span><br><span class="line">3) &quot;kk1&quot;</span><br><span class="line">4) &quot;lisi&quot;</span><br><span class="line">5) &quot;kk&quot;</span><br><span class="line">127.0.0.1:6379&gt; zcard key</span><br><span class="line">(integer) 5</span><br></pre></td></tr></table></figure><h3 id="5-1-4-ZCOUNT"><a href="#5-1-4-ZCOUNT" class="headerlink" title="5.1.4 ZCOUNT"></a>5.1.4 ZCOUNT</h3><p>返回分数在min&#x2F;max之间的元素个数，默认是闭区间，包含min和max的值。该命令的时间复杂度是<code>O(log(N))</code>，N是Zset中元素个数。</p><p>zset在存放一个member的时候会保存它的次序（可以简单理解为下标）所以这个命令不是通过min到max的遍历来获取元素的，而是先找到min和max这两个边界值的member，再获取到它们的元素次序，<strong>最终将次序相减，就得到了元素个数</strong>。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ZCOUNT key min max</span><br></pre></td></tr></table></figure><p>可以使用括号来表示开区间，注意括号都是加在前面的。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ZCOUNT key (min (max</span><br></pre></td></tr></table></figure><p>测试如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; zrange key 0 -1 withscores</span><br><span class="line"> 1) &quot;zhangsan&quot;</span><br><span class="line"> 2) &quot;97&quot;</span><br><span class="line"> 3) &quot;wangwu&quot;</span><br><span class="line"> 4) &quot;99&quot;</span><br><span class="line"> 5) &quot;kk1&quot;</span><br><span class="line"> 6) &quot;100&quot;</span><br><span class="line"> 7) &quot;lisi&quot;</span><br><span class="line"> 8) &quot;100&quot;</span><br><span class="line"> 9) &quot;kk&quot;</span><br><span class="line">10) &quot;112&quot;</span><br><span class="line">127.0.0.1:6379&gt; zcount key 97 100</span><br><span class="line">(integer) 4</span><br><span class="line">127.0.0.1:6379&gt; zcount key 97 (100</span><br><span class="line">(integer) 2</span><br></pre></td></tr></table></figure><p>因为zset中的score可以使用浮点数，在Redis中有两个特殊的浮点数，用于表示正无穷大<code>inf</code>和负无穷大<code>-inf</code>，所以在ZCOUNT的min&#x2F;max中也可以用这两个特殊的浮点数来筛选</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; zcount key -inf 100</span><br><span class="line">(integer) 4</span><br></pre></td></tr></table></figure><h3 id="5-1-5-ZREVRANCE"><a href="#5-1-5-ZREVRANCE" class="headerlink" title="5.1.5 ZREVRANCE"></a>5.1.5 ZREVRANCE</h3><p>这个命令的作用和ZRANGE类似，但返回的数据是降序的</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ZREVRANGE key start stop [WITHSCORES]</span><br></pre></td></tr></table></figure><p>测试如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; ZREVRANGE key 0 -1 WITHSCORES</span><br><span class="line"> 1) &quot;kk&quot;</span><br><span class="line"> 2) &quot;112&quot;</span><br><span class="line"> 3) &quot;lisi&quot;</span><br><span class="line"> 4) &quot;100&quot;</span><br><span class="line"> 5) &quot;kk1&quot;</span><br><span class="line"> 6) &quot;100&quot;</span><br><span class="line"> 7) &quot;wangwu&quot;</span><br><span class="line"> 8) &quot;99&quot;</span><br><span class="line"> 9) &quot;zhangsan&quot;</span><br></pre></td></tr></table></figure><p>注意，该命令在Redis6.2中已经**弃用(deprecated)**，在ZRANGE中使用REV选项能实现它的功能。</p><blockquote><p>As of Redis version 6.2.0, this command is regarded as deprecated.</p><p>It can be replaced by <a href="https://redis.io/commands/zrange"><code>ZRANGE</code></a> with the <code>REV</code> argument when migrating or writing new code.</p></blockquote><h3 id="5-1-6-ZPOPMAX-x2F-ZPOPMIN"><a href="#5-1-6-ZPOPMAX-x2F-ZPOPMIN" class="headerlink" title="5.1.6 ZPOPMAX&#x2F;ZPOPMIN"></a>5.1.6 ZPOPMAX&#x2F;ZPOPMIN</h3><p>删除并返回Zset中分数最高的count个元素</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ZPOPMAX key [count]</span><br><span class="line">ZPOPMIN key [count]</span><br></pre></td></tr></table></figure><p>这个命令可以用来解决TopK问题，假设有个10元素的zset，想获得score在前3的元素的一个set，可以使用两种方式</p><ul><li>ZPOPMAX将高三位弹出并存放到另外一个zset中；</li><li>ZPOPMIN将低七位弹出，此时剩下的就是高三位；</li></ul><p>测试如下，pop的时候会将member和score一起弹出。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; zpopmax key 2</span><br><span class="line">1) &quot;kk&quot;</span><br><span class="line">2) &quot;112&quot;</span><br><span class="line">3) &quot;lisi&quot;</span><br><span class="line">4) &quot;100&quot;</span><br></pre></td></tr></table></figure><h3 id="5-1-7-BZPOPMAX"><a href="#5-1-7-BZPOPMAX" class="headerlink" title="5.1.7 BZPOPMAX"></a>5.1.7 BZPOPMAX</h3><p>这个命令是ZPOPMAX的阻塞版本，当key中没有元素时会阻塞</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">BZPOPMAX key [key ...] timeout</span><br></pre></td></tr></table></figure><p>这个和BLPOP&#x2F;BRPOP的效果一样，不做演示了。</p><h3 id="5-1-8-ZRANK"><a href="#5-1-8-ZRANK" class="headerlink" title="5.1.8 ZRANK"></a>5.1.8 ZRANK</h3><p>获取一个Zset中某个成员的排名（返回的是排名序号，以0开始）时间复杂度<code>O(log(N))</code>，N是Zset中元素个数。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ZRANK key member [WITHSCORE]</span><br></pre></td></tr></table></figure><p>测试如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; zrange key 0 -1</span><br><span class="line">1) &quot;zhangsan&quot;</span><br><span class="line">2) &quot;wangwu&quot;</span><br><span class="line">3) &quot;kk1&quot;</span><br><span class="line">127.0.0.1:6379&gt; zrank key wangwu</span><br><span class="line">(integer) 1</span><br></pre></td></tr></table></figure><p>redis7.2后，添加withscore选项，会同时返回这个成员的分数</p><h3 id="5-1-9-ZREVRANK"><a href="#5-1-9-ZREVRANK" class="headerlink" title="5.1.9 ZREVRANK"></a>5.1.9 ZREVRANK</h3><p>返回某个成员的排名，降序排序。时间复杂度<code>O(log(N))</code>，N是Zset中元素个数。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ZREVRANK key member [WITHSCORE]</span><br></pre></td></tr></table></figure><p>redis7.2后，添加withscore选项，会同时返回这个成员的分数</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; zrange key 0 -1</span><br><span class="line">1) &quot;zhangsan&quot;</span><br><span class="line">2) &quot;wangwu&quot;</span><br><span class="line">3) &quot;kk1&quot;</span><br><span class="line">127.0.0.1:6379&gt; zrevrank key wangwu</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; zrevrank key kk1</span><br><span class="line">(integer) 0</span><br><span class="line">127.0.0.1:6379&gt; zrevrank key zhangsan</span><br><span class="line">(integer) 2</span><br></pre></td></tr></table></figure><h3 id="5-1-10-ZSCORE"><a href="#5-1-10-ZSCORE" class="headerlink" title="5.1.10 ZSCORE"></a>5.1.10 ZSCORE</h3><p>返回zset中某个成员的分数，时间复杂度为<code>O(1)</code>；</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ZSCORE key member</span><br></pre></td></tr></table></figure><p>测试如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; zrange key 0 -1 withscores</span><br><span class="line">1) &quot;zhangsan&quot;</span><br><span class="line">2) &quot;97&quot;</span><br><span class="line">3) &quot;wangwu&quot;</span><br><span class="line">4) &quot;99&quot;</span><br><span class="line">5) &quot;kk1&quot;</span><br><span class="line">6) &quot;100&quot;</span><br><span class="line">127.0.0.1:6379&gt; zscore key kk1</span><br><span class="line">&quot;100&quot;</span><br></pre></td></tr></table></figure><h3 id="5-1-11-ZREM"><a href="#5-1-11-ZREM" class="headerlink" title="5.1.11 ZREM"></a>5.1.11 ZREM</h3><p>删除某个zset中的member，可以一次性传入多个。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ZREM key member [member ...]</span><br></pre></td></tr></table></figure><p>时间复杂度<code>O(M*log(N))</code>，N是zset中元素个数，M是需要删除的元素个数。</p><h3 id="5-1-12-ZREMRANGEBYRANK"><a href="#5-1-12-ZREMRANGEBYRANK" class="headerlink" title="5.1.12 ZREMRANGEBYRANK"></a>5.1.12 ZREMRANGEBYRANK</h3><p>删除某个区间的元素，和ZRANGE的start&#x2F;stop相同</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ZREMRANGEBYRANK key start stop</span><br></pre></td></tr></table></figure><p>时间复杂度是<code>O(log(N)+M) </code>，N是zset中元素个数，M是区间内的元素个数。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; zadd key 1 one 2 two 3 three</span><br><span class="line">(integer) 3</span><br><span class="line">127.0.0.1:6379&gt; ZREMRANGEBYRANK key 0 1</span><br><span class="line">(integer) 2</span><br><span class="line">127.0.0.1:6379&gt;  zrange key 0 -1</span><br><span class="line">1) &quot;three&quot;</span><br></pre></td></tr></table></figure><h3 id="5-1-13-ZREMRANGEBYSCORE"><a href="#5-1-13-ZREMRANGEBYSCORE" class="headerlink" title="5.1.13 ZREMRANGEBYSCORE"></a>5.1.13 ZREMRANGEBYSCORE</h3><p>删除某个区间的元素，使用的是min&#x2F;max分数区间，默认闭区间，也可以用左括号表示开区间。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ZREMRANGEBYSCORE key min max</span><br><span class="line">ZREMRANGEBYSCORE key (min (max</span><br></pre></td></tr></table></figure><p>时间复杂度是<code>O(log(N)+M) </code>，N是zset中元素个数，M是区间内的元素个数。 </p><h3 id="5-1-14-ZINCRBY"><a href="#5-1-14-ZINCRBY" class="headerlink" title="5.1.14 ZINCRBY"></a>5.1.14 ZINCRBY</h3><p>给某个zset中的元素<strong>增加分数</strong>，如果元素不存在，则和zadd的作用相同。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ZINCRBY key increment member</span><br></pre></td></tr></table></figure><p>时间复杂度<code>O(log(N))</code>，N为zset中元素个数。</p><h3 id="5-1-15-ZUNIONSTORE"><a href="#5-1-15-ZUNIONSTORE" class="headerlink" title="5.1.15 ZUNIONSTORE"></a>5.1.15 ZUNIONSTORE</h3><p>这个命令会求两个zset的<strong>并集</strong>并存放到的destination中。</p><p>时间复杂度：<code>O(N)+O(M log(M))</code>，N是所有input参数zset中元素的个数总和，M是结果集中的元素个数。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ZUNIONSTORE destination numkeys key [key ...] [WEIGHTS weight</span><br><span class="line">  [weight ...]] [AGGREGATE &lt;SUM | MIN | MAX&gt;]</span><br></pre></td></tr></table></figure><p>命令参数</p><ul><li>destination：目标zset的key，如果这个key已经存在，则会被覆盖。</li><li>numkeys：输入的key的个数</li><li>WEIGHTS：给每个入参的key设定的乘法系数，当求交集的时候，会将最终结果的分值乘以这个乘法系数再交付。不提供的时候默认为1；</li><li>AGGREGATE：该选项可以指定并集运算结果的聚合方式。该选项默认值为 SUM，即将输入中所有存在该元素的集合中对应的分值全部加一起。当选项被设置为 MIN 或 MAX 任意值时，结果集合将保存输入中所有存在该元素的集合中对应的分值的最小或最大值。</li></ul><p>测试如下，先不使用weights，可以看到两个zset中，相同的元素的分数会相加，one的分值变成了2，two的分值变成了4；如果只有一个zset存在的元素则保持不变。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; zadd zset1 1 &quot;one&quot; 2 &quot;two&quot;</span><br><span class="line">(integer) 2</span><br><span class="line">127.0.0.1:6379&gt; zadd zset2 1 &quot;one&quot; 2 &quot;two&quot; 3 &quot;three&quot;</span><br><span class="line">(integer) 3</span><br><span class="line">127.0.0.1:6379&gt; zunionstore out 2 zset1 zset2</span><br><span class="line">(integer) 3</span><br><span class="line">127.0.0.1:6379&gt; zrange out 0 -1 withscores</span><br><span class="line">1) &quot;one&quot;</span><br><span class="line">2) &quot;2&quot;</span><br><span class="line">3) &quot;three&quot;</span><br><span class="line">4) &quot;3&quot;</span><br><span class="line">5) &quot;two&quot;</span><br><span class="line">6) &quot;4&quot;</span><br></pre></td></tr></table></figure><p>使用weight提供乘法系数，zset1中的分值被乘以2，zset2中的分值被乘以3，然后二者再相加起来。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; zunionstore out 2 zset1 zset2 weights 2 3</span><br><span class="line">(integer) 3</span><br><span class="line">127.0.0.1:6379&gt; zrange out 0 -1 withscores</span><br><span class="line">1) &quot;one&quot;</span><br><span class="line">2) &quot;5&quot;</span><br><span class="line">3) &quot;three&quot;</span><br><span class="line">4) &quot;9&quot;</span><br><span class="line">5) &quot;two&quot;</span><br><span class="line">6) &quot;10&quot;</span><br></pre></td></tr></table></figure><p>如果修改AGGREGATE策略，结果又不同，默认sum是相加；指定min是当两个zset都有某个参数的时候，选用分数较小的哪一个。比如zset1中乘法系数是2，所以one&#x2F;two的分数<strong>小于</strong>zset2中的分数，最终的集合out中存放的就是zset1中的元素分数。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; zunionstore out 2 zset1 zset2 weights 2 3 aggregate min</span><br><span class="line">(integer) 3</span><br><span class="line">127.0.0.1:6379&gt; zrange out 0 -1 withscores</span><br><span class="line">1) &quot;one&quot;</span><br><span class="line">2) &quot;2&quot;</span><br><span class="line">3) &quot;two&quot;</span><br><span class="line">4) &quot;4&quot;</span><br><span class="line">5) &quot;three&quot;</span><br><span class="line">6) &quot;9&quot;</span><br></pre></td></tr></table></figure><p>使用<code>AGGREGATE MAX</code>存放的就会是zset2中的分数了。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; zunionstore out 2 zset1 zset2 weights 2 3 aggregate max</span><br><span class="line">(integer) 3</span><br><span class="line">127.0.0.1:6379&gt; zrange out 0 -1 withscores</span><br><span class="line">1) &quot;one&quot;</span><br><span class="line">2) &quot;3&quot;</span><br><span class="line">3) &quot;two&quot;</span><br><span class="line">4) &quot;6&quot;</span><br><span class="line">5) &quot;three&quot;</span><br><span class="line">6) &quot;9&quot;</span><br></pre></td></tr></table></figure><h3 id="5-1-16-ZINTERSTORE"><a href="#5-1-16-ZINTERSTORE" class="headerlink" title="5.1.16 ZINTERSTORE"></a>5.1.16 ZINTERSTORE</h3><p>这个命令存放并集到destination中，相关的命令选项和<code>ZUNIONSTORE</code>一致。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ZINTERSTORE destination numkeys key [key ...] [WEIGHTS weight</span><br><span class="line">  [weight ...]] [AGGREGATE &lt;SUM | MIN | MAX&gt;]</span><br></pre></td></tr></table></figure><p>时间复杂度：最坏情况是<code>O(N*K)+O(M*log(M))</code> ，N是最小的输入zset中的元素个数，K是输入参数中zset的个数，M是结果集中元素个数。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; zadd zset1 1 &quot;one&quot; 2 &quot;two&quot;</span><br><span class="line">(integer) 2</span><br><span class="line">127.0.0.1:6379&gt; zadd zset2 1 &quot;one&quot; 2 &quot;two&quot; 3 &quot;three&quot;</span><br><span class="line">(integer) 3</span><br><span class="line">127.0.0.1:6379&gt; zinterstore out 2 zset1 zset2 weights 2 3</span><br><span class="line">(integer) 2</span><br><span class="line">127.0.0.1:6379&gt; zrange out 0 -1 withscores</span><br><span class="line">1) &quot;one&quot;</span><br><span class="line">2) &quot;5&quot;</span><br><span class="line">3) &quot;two&quot;</span><br><span class="line">4) &quot;10&quot;</span><br></pre></td></tr></table></figure><h2 id="5-2-编码方式"><a href="#5-2-编码方式" class="headerlink" title="5.2 编码方式"></a>5.2 编码方式</h2><p>当zset中元素个数少的时候，会使用ziplist；</p><p>当元素个数较多，或者单个元素的体积较大（字符串长），使用skiplist来存储。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">zset-max-ziplist-entries 元素少于这个数量的时候使用ziplist</span><br><span class="line">zset-max-ziplist-value   元素长度大于这个数字的时候使用skiplist</span><br></pre></td></tr></table></figure><p>测试</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; zadd zset1 1 &quot;one&quot; 2 &quot;two&quot;</span><br><span class="line">(integer) 2</span><br><span class="line">127.0.0.1:6379&gt; object encoding zset1</span><br><span class="line">&quot;ziplist&quot;</span><br><span class="line">127.0.0.1:6379&gt; zadd zset1 20 aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; object encoding zset1</span><br><span class="line">&quot;skiplist&quot;</span><br></pre></td></tr></table></figure><h2 id="5-3-使用场景"><a href="#5-3-使用场景" class="headerlink" title="5.3 使用场景"></a>5.3 使用场景</h2><p>zset比较适合建立排行榜。诸如微博热搜、B站热搜、游戏排行榜这些，都是一个“排行榜”的应用场景。</p><p>游戏玩家的排位会有一个分数，排行榜按这个分数来降序排列的，并展示给用户。且可以使用zrange来进行分页查看。</p><p>微博热搜也可以应用zset，每个话题肯定会有一个热搜的指数，<strong>如果简单来处理</strong>，那么就是用户搜索一次这个话题，它在zset中的分数就加一（zincrby命令），这样被搜索的次数越多的话题，在热搜榜中就越靠前。</p><p>当然，微博实际上用的是一个综合的数值，而不是只看搜索量这个单一指标。这时候可以用zinterstore&#x2F;zunionstore中的weight来实现多个维度数值的计算。比如浏览量、点赞率、转发量、评论量这些数据，在最终结果集合的时候都给他们赋予一个权值再进行计算，最终得到一个热榜的指数。</p><h1 id="6-Steams"><a href="#6-Steams" class="headerlink" title="6.Steams"></a>6.Steams</h1><p>steams数据类型类似一个<code>append-only log</code>，可以让我们把一个事件投放给多个目标。你可以理解为它就是一个队列，比list更加适合作为消息中间件。</p><p>在Redis官网上提到了steams类型的几个应用场景</p><ul><li>事件来源监看</li><li>事件通知</li><li>消息监看（消费者进行阻塞等待）</li></ul><p>所谓事件，就是某个东西满足了某种状态的场景。比如linux多路转接中epoll&#x2F;select就是通过事件来通知进程来处理io请求的，我们在进程中调用接口进行等待的时候，就相当于是在执行“消息监看”这一步骤。</p><h1 id="7-Geospatial"><a href="#7-Geospatial" class="headerlink" title="7.Geospatial"></a>7.Geospatial</h1><p>这个类型就是用来存储坐标（经纬度）的，代表一个地理位置。它存储点了之后，可以进行地理半径进行查找，在导航软件中就很有用。</p><p>基本命令是添加和查询：</p><ul><li>GEOADD将位置添加到给定的地理空间索引（请注意，使用此命令，经度先于纬度）。</li><li>GEOSEARCH返回具有给定半径或<strong>地理边界框</strong>的位置。</li></ul><p>平时肯定用不上这个类型，只有接触了具体的业务才需要了解</p><h1 id="8-HyperLogLog"><a href="#8-HyperLogLog" class="headerlink" title="8.HyperLogLog"></a>8.HyperLogLog</h1><p>这个数据类型的应用场景主要是用于计算（估算）集合中的元素个数。</p><p>比如用set来存放站点的UV的时候，假设set中存放用户id（8字节）一个1亿UV的站点大约会占用800MB的内存。看上去好像不多？毕竟一亿UV的网站哪里有那么多啊？</p><p>但HyperLogLog可以使用最多12KB的空间就实现上述的效果！</p><blockquote><p>The Redis HyperLogLog implementation uses up to 12 KB and provides a standard error of 0.81%.</p></blockquote><p>set占用那么多内存是因为它完整存储了用户的id，但HyperLogLog并不存放元素内容，但可以记录“元素的特征”，新增元素的时候可以判断当前元素是新增的元素还是已经存在的元素。这时候就可以用HyperLogLog来进行<strong>计数</strong>，但不能用于真正存放元素。</p><p>这里的底层肯定很复杂，且HyperLogLog并不能保证百分百精确。官方文档上也提到了，HyperLogLog大概会有<code>0.81%</code>的误差。</p><p>注意：HyperLogLog是一个算法思想，并非Redis专有的。其他工具中也可能提供这个数据结构来实现此类需求。</p><h1 id="9-Bitmaps"><a href="#9-Bitmaps" class="headerlink" title="9.Bitmaps"></a>9.Bitmaps</h1><p>bitmaps是位图结构，本质上还是一个集合，它使用某个比特位来存放某些特定的数据，以此来节省空间。</p><p>比如存放数字10，我们不是直接存放整形，而是将位图中的从右往左数第10位从0改成1，这样就代表10已经存放了。</p><p>和HyperLogLog不存放元素相比，bitmaps虽然是用比特来表示是否存在某个元素，但<strong>实际上它是存放了这个元素的</strong>，因为我们可以通过位图中的数据还原出某个元素是否存在！比如第3个比特位是1，那么集合中就有3。</p><ul><li>不需要知道元素内容，可以使用HyperLogLog；</li><li>想节省空间的同时需要记录整形元素，使用bitmaps</li></ul><h1 id="10-Bitfields"><a href="#10-Bitfields" class="headerlink" title="10.Bitfields"></a>10.Bitfields</h1><p>位域Bitfields，在C语言中<strong>位段</strong>其实就是位域；</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TestBit</span> &#123;</span></span><br><span class="line"><span class="type">int</span> a:<span class="number">8</span>; <span class="comment">// 数字表示某个变量占用几个比特位</span></span><br><span class="line"><span class="type">int</span> b:<span class="number">16</span>;</span><br><span class="line"><span class="type">int</span> c:<span class="number">8</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>Redis中的bitfield和C语言中的位域相似，可以理解位一串二进制序列，并给某个位设置特定的哈衣，并进行读取&#x2F;修改&#x2F;算术运算等相关操作。</p><p>相比于string类型，它的核心目标还是节省空间。比如一把moba游戏中玩家的金币、KDA、补刀等信息，并不需要用大量空间来存储，使用位域可以节省空间。在Redis官网上也有相关的示例命令</p><p><a href="https://redis.io/docs/data-types/bitfields/">https://redis.io/docs/data-types/bitfields/</a></p><h1 id="The-end"><a href="#The-end" class="headerlink" title="The end"></a>The end</h1><p>Redis中最主要使用的数据类型和命令就是这些了，后续相关知识点会继续补充。</p><h3 id=""><a href="#" class="headerlink" title=""></a></h3><h3 id="-1"><a href="#-1" class="headerlink" title=""></a></h3>]]></content>
    
    
    <summary type="html">Redis的常用变量类型以及数据类型相关命令的介绍</summary>
    
    
    
    <category term="编程学习" scheme="https://blog.musnow.top/categories/%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="Redis" scheme="https://blog.musnow.top/categories/%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0/Redis/"/>
    
    
    <category term="Redis" scheme="https://blog.musnow.top/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>【Redis】03.基本命令学习</title>
    <link href="https://blog.musnow.top/posts/3677820204/"/>
    <id>https://blog.musnow.top/posts/3677820204/</id>
    <published>2024-02-10T08:33:30.000Z</published>
    <updated>2024-02-20T02:22:28.000Z</updated>
    
    <content type="html"><![CDATA[<p>学习Redis的命令可以参考官网文档：<a href="https://redis.io/commands">Commands | Redis</a>。我还发现官网的examples里面是可以敲Redis命令的，如果你没有配置Redis环境，应该可以白嫖这里的Redis做个临时的练习。</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/02/ada4c2c766f7d1faabd2a1a7a5a32287.png" alt="image.png"></p><p>本文使用Redis版本：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">❯ sudo redis-server --version</span><br><span class="line">Redis server v=6.0.16 sha=00000000:0 malloc=jemalloc-5.2.1 bits=64 build=a3fdef44459b3ad6</span><br><span class="line">❯ sudo redis-cli --version</span><br><span class="line">redis-cli 6.0.16</span><br></pre></td></tr></table></figure><p>注意，本文并非Redis命令大全，只是对最常用的命令做的记录。</p><h1 id="1-set和get"><a href="#1-set和get" class="headerlink" title="1.set和get"></a>1.set和get</h1><h2 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h2><p>在Redis中，最常用的就是这两个命令。顾名思义，set是用来设置key值的，get是用来获取某个key值的。</p><p>注意set&#x2F;get命令<strong>只能用于设置字符串string变量</strong>，其他类型有对应的设置命令，用get获取一个非string的key会失败。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">set key value</span><br><span class="line">get key</span><br></pre></td></tr></table></figure><p>在redis中不区分命令的大小写（但是区分key和value的大小写），字符串也不需要加引号（如果有<strong>空格</strong>就需要加），set成功会返回<code>OK</code>，失败会返回<code>nil</code>。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; set key1 value1</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; set key2 value2</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; get key2</span><br><span class="line">&quot;value2&quot;</span><br><span class="line">127.0.0.1:6379&gt; get key3</span><br><span class="line">(nil)</span><br><span class="line">127.0.0.1:6379&gt; get KEY2</span><br><span class="line">(nil)</span><br><span class="line">127.0.0.1:6379&gt; set k &quot;100 01&quot;</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; get k</span><br><span class="line">100 01</span><br></pre></td></tr></table></figure><p>最后的key3是一个不存在的键值，Redis返回了<code>(nil)</code>，意思和NULL其实一样，就是没有值。同时大写的KEY2也没有值，因为Redis中的key需要区分大小写。</p><p>如果尝试set一个已经存在的key，会自动覆盖旧数据。覆盖的时候可能会修改key对应value的数据类型。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; get key1</span><br><span class="line">&quot;value1&quot;</span><br><span class="line">127.0.0.1:6379&gt; set key1 value11</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; get key1</span><br><span class="line">&quot;value11&quot;</span><br></pre></td></tr></table></figure><p>如果你需要设置的字符串中有引号，可以用<code>\</code>进行转义，但还必须在外部再套一个引号</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; set k &quot;10&quot;</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; get k</span><br><span class="line">10</span><br><span class="line">127.0.0.1:6379&gt; set k \&quot;10\&quot;</span><br><span class="line">Invalid argument(s)</span><br><span class="line">127.0.0.1:6379&gt; set k &quot;\&quot;10\&quot;&quot;</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; get k</span><br><span class="line">&quot;10&quot;</span><br><span class="line">127.0.0.1:6379&gt; object encoding k</span><br><span class="line">embstr</span><br></pre></td></tr></table></figure><h2 id="进阶选项"><a href="#进阶选项" class="headerlink" title="进阶选项"></a>进阶选项</h2><p>set命令还有一些额外的选项可供选择，具体参考官网文档 <a href="https://redis.io/commands/set/">SET | Redis</a>。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SET key value [NX | XX] [GET] [EX seconds | PX milliseconds |</span><br><span class="line">  EXAT unix-time-seconds | PXAT unix-time-milliseconds | KEEPTTL]</span><br></pre></td></tr></table></figure><p>在Redis官网上，<code>[]</code>代表可选命令参数，<code>|</code>可以理解为“或”，代表每个可选命令参数中的不同设置值；每个<code>[]</code>之间是独立的，可以同时存在。如下是对set命令选项的说明：</p><ul><li>NX：只有key不存在的时候才能set成功;</li><li>XX：只有key存在的时候才能set成功;</li><li>GET：如果key已存在，返回旧值；如果key不存在返回nil（空）；如果key存在但是value不是string，则本次set操作会返回错误并终止；</li><li>EX&#x2F;PX：set的时候指定当前key的过期时间，过期时间到了会自动被删除，EX的单位是秒，PX的单位是毫秒（类似<code>sleep_for</code>）；</li><li>EXAT&#x2F;PXAT：指定过期时间戳，即当前时间到<strong>指定时间戳</strong>后key值过期。EXAT是秒级时间戳，PXAT是毫秒级时间戳（类似<code>sleep_until</code>）；</li><li>KEEPTTL：如果key值已存在且有过期时间，使用KEEPTTL更新当前key的时候会重置过期时间计数器。举例：A的过期时间是100秒，我在A设置后60秒又更新了A，此时新的A的过期计时器会继承原有时间，即为40秒后过期。如果不指定KEEPTTL选项，则会被重置为Redis的默认TTL（如果没有配置，默认是永不过期）。</li></ul><p>注意，一些选项是高版本中才被支持的。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Starting with Redis version 2.6.12: Added the EX, PX, NX and XX options.</span><br><span class="line">Starting with Redis version 6.0.0: Added the KEEPTTL option.</span><br><span class="line">Starting with Redis version 6.2.0: Added the GET, EXAT and PXAT option.</span><br><span class="line">Starting with Redis version 7.0.0: Allowed the NX and GET options to be used together.</span><br></pre></td></tr></table></figure><h3 id="NX和XX"><a href="#NX和XX" class="headerlink" title="NX和XX"></a>NX和XX</h3><p>NX是key值不存在才能正常被设置，XX是key值存在才能被正常设置。如果没有被set成功，则会返回<code>nil</code>，set成功返回的是OK。</p><p>如下所示，a键值不存在时，nx设置a成功返回OK。再次用nx尝试设置，因为此时a已经存在，不符合nx的策略，设置失败，返回<code>nil</code>。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; set a test1 nx</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; set a test1 nx</span><br><span class="line">(nil)</span><br></pre></td></tr></table></figure><p>使用xx测试，因为a存在，所以设置成功。而b不存在，设置失败。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; set a test2 xx</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; set b test1 xx</span><br><span class="line">(nil)</span><br></pre></td></tr></table></figure><h3 id="KEEPTTL"><a href="#KEEPTTL" class="headerlink" title="KEEPTTL"></a>KEEPTTL</h3><p>对KEEPTTL来做个测试，为了更好的展示效果，把一个始终摆在终端旁边。</p><p>我在19秒的时候执行了命令<code>set a test ex 20</code>，即键值a会在20秒后过期。如同预期，在39秒左右，a的键值无法被get了（截图落后了一些）</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/02/00c937e7e04b4440fea45f4dd7a2a638.png" alt="image.png"></p><p>尝试在这20秒中重新给a设置一个新的值，同时不携带KEEPTTL选项。会发现重新设置后的key没有继承原有的过期时间，而是<strong>不过期</strong>了（Redis的默认策略就是永不过期）</p><p>如果携带了KEEPTTL选项，则a还是会在20秒后过期。</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/02/eb367ae0e3b2730146a4ef800c92274a.png" alt="image.png"></p><p>使用TTL命令可以看的更直观一点（关于TTL命令的介绍参考后文），当我们使用KEEPTTL设置了a后，它的过期时间还是继承了原本的10秒，随后被过期删除，TTL显示<code>-2</code>代表键值不存在。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; set a t1 ex 10</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; ttl a</span><br><span class="line">(integer) 8</span><br><span class="line">127.0.0.1:6379&gt; set a t2 keepttl</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; ttl a</span><br><span class="line">(integer) 2</span><br><span class="line">127.0.0.1:6379&gt; get a</span><br><span class="line">(nil)</span><br><span class="line">127.0.0.1:6379&gt; ttl a</span><br><span class="line">(integer) -2</span><br></pre></td></tr></table></figure><p>如果不使用KEEPTTL选项，则过期时间会变成<code>-1</code>代表永不过期。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; set a t1 ex 10</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; get a</span><br><span class="line">&quot;t1&quot;</span><br><span class="line">127.0.0.1:6379&gt; ttl a</span><br><span class="line">(integer) 5</span><br><span class="line">127.0.0.1:6379&gt; set a t2</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; get a</span><br><span class="line">&quot;t2&quot;</span><br><span class="line">127.0.0.1:6379&gt; ttl a</span><br><span class="line">(integer) -1</span><br></pre></td></tr></table></figure><h2 id="mset和mget"><a href="#mset和mget" class="headerlink" title="mset和mget"></a>mset和mget</h2><p>这两个命令是set&#x2F;get的变体，可以用于同时设置&#x2F;获取多个键值的数据。这两个命令的时间复杂度都是<code>O(N)</code>，其中N是命令后跟随的key的个数。</p><p>mset只能单纯的设置key和value，没有set的额外的参数选项。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">MSET key value [key value ...]</span><br><span class="line">MGET key [key ...]</span><br></pre></td></tr></table></figure><p>测试如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; mset key1 t1 key2 t2</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; mget key1 key2</span><br><span class="line">t1</span><br><span class="line">t2</span><br></pre></td></tr></table></figure><p>为什么要提供一个这样的命令呢？还是关于网络请求方面的性能节省。如果我知道我需要一次性设置&#x2F;获取大量键值，那可以一条命令写完的绝对好过多次请求Redis服务器，节省了多次通信的网络延迟。</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/02/a31a19e2b651a86213df25325e42d1d9.png" alt="image.png"></p><p>Redis会保证mset的执行是<strong>原子的</strong>，不会出现mset中的多个键值只观察到其中一个被修改的情况。官网原话：MSET is atomic, so all given keys are set at once. It is not possible for clients to see that some of the keys were updated while others are unchanged.</p><blockquote><p>比如我mset了key1和key2，客户端可以观察到key1和key2都被修改，不会观察到只有key1或只有key2被修改了的情况。</p></blockquote><p>这也是得益于Redis采用的单线程模型，它必须处理完毕mset的所有key后才会去响应其他命令请求，那客户端自然就不可能中断设置多个key的过程，也观察不到只有一部分key被修改了的情况。</p><p>但这也警示我们：如果尝试用mset设置特别大量的key，可能会阻塞Redis服务器导致其无法响应其他请求。</p><h1 id="2-keys"><a href="#2-keys" class="headerlink" title="2.keys"></a>2.keys</h1><p>keys命令用于查询当前Redis中的key值有哪些，如果匹配不上则返回<code>empty array</code>。</p><p>命令格式如下，<a href="https://redis.io/commands/keys/">KEYS | Redis</a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">keys [pattern]</span><br></pre></td></tr></table></figure><p>其中参数pattern是一个字符串，类似于正则表达式，用来匹配Redis中已有的key的名称。</p><p>举个最简单的例子，<code>key*</code>代表匹配以key开头的所有键值，可以看到当前我的Redis有上文set的两个key。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; keys key*</span><br><span class="line">1) &quot;key1&quot;</span><br><span class="line">2) &quot;key2&quot;</span><br></pre></td></tr></table></figure><p>pattern支持的格式如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">h?llo     matches hello, hallo and hxllo</span><br><span class="line">问号只匹配一个字符</span><br><span class="line"></span><br><span class="line">h*llo     matches hllo and heeeello</span><br><span class="line">星号代表匹配0个或者无数个字符</span><br><span class="line"></span><br><span class="line">h[ae]llo  matches hello and hallo, but not hillo</span><br><span class="line">匹配a或者e这两个字符</span><br><span class="line"></span><br><span class="line">h[^e]llo  matches hallo, hbllo, ... but not hello</span><br><span class="line">匹配除了e以外的其他单个字符</span><br><span class="line"></span><br><span class="line">h[a-b]llo matches hallo and hbllo</span><br><span class="line">匹配a到b这个区间中的单个字符</span><br></pre></td></tr></table></figure><p>如果你需要匹配的字符串中包含 <code>[</code>、<code>]</code>、<code>*</code>、<code>?</code> 这些特殊字符，可以用<code>\</code>来转义它们。</p><p>注意：keys的时间复杂度是<code>O(N)</code>（其采用遍历方式来获取结果），所以在生产环境的大数据库中一般都禁止使用keys命令，特别是<code>keys *</code>全部查询。因为Redis是单线程模型，如果用keys的查询把Redis给弄阻塞了，就没有办法提供服务给其他链接了。</p><p>在Redis+MySQL的框架中，如果使用keys命令导致Redis阻塞了，请求就会直接回源到MySQL上，导致MySQL服务器遭受了意料之外的大批量请求，它也容易挂掉。如果Redis和MySQL都挂了，业务就完蛋了🤣。 </p><h1 id="3-exists"><a href="#3-exists" class="headerlink" title="3.exists"></a>3.exists</h1><h2 id="命令介绍"><a href="#命令介绍" class="headerlink" title="命令介绍"></a>命令介绍</h2><p>判断某个key是否存在，返回值是一个数字：返回命令中给出的key中，实际存在的key的个数。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">exists key [key1 key2 ...]</span><br></pre></td></tr></table></figure><p>举个例子，比如我使用如下命令。那么返回值就是这三个key中有几个key是存在的。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">exists key1 key2 key3</span><br></pre></td></tr></table></figure><p>exists命令<strong>检查一个key</strong>的时间复杂度是<code>O(1)</code>，因为Redis底层是用哈希表来管理key的。</p><blockquote><p>Time complexity: O(N) where N is the number of keys to check.</p></blockquote><p>Redis的官方文档说exists命令的时间复杂度是<code>O(N)</code>，不要误解，这里的N是命令中给出key的个数。相当于我们需要检查N个key，每个key都是<code>O(1)</code>，最终的时间复杂度就是<code>O(N)</code>了。</p><blockquote><p>在实际使用时，如果需要查询多个key是否存在，一条命令写完肯定比多次查询更好。因为每一次查询都涉及到了<strong>一次网络请求和响应</strong>，一条命令把需要查询的多个key都告诉Redis，得到一个返回结果是更好的选择。这就和MySQL中的请求一样，一条SQL能解决的事情分成两个SQL就会因为网络通信而增加延迟！</p><p>Redis中的大部分命令都支持一次性给定多个key，就是为了减少网络通信带来的影响。</p></blockquote><p>当然，exists命令的返回结果并没有办法让我们知道给出的key中到底是哪一个不存在，这是要看具体业务来确定的。</p><h2 id="命令测试"><a href="#命令测试" class="headerlink" title="命令测试"></a>命令测试</h2><p>实际测试如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; exists key1 key2</span><br><span class="line">(integer) 2</span><br><span class="line">127.0.0.1:6379&gt; exists key1</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; exists key</span><br><span class="line">(integer) 0</span><br></pre></td></tr></table></figure><p>注意，exists在检查某个key是否存在的时候并不会进行去重操作，如果你尝试检查两个相同的key，返回结果也是2；</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; exists key1 key1</span><br><span class="line">(integer) 2</span><br></pre></td></tr></table></figure><h1 id="4-del"><a href="#4-del" class="headerlink" title="4.del"></a>4.del</h1><p>用于删除指定key，返回值是一个数字，给定key中被成功删除的个数。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">del key [key1 key2 ...]</span><br></pre></td></tr></table></figure><p>删除单个key的时间复杂度是<code>O(1)</code>，多个是<code>O(N)</code>；</p><h1 id="5-expire-x2F-pexpire"><a href="#5-expire-x2F-pexpire" class="headerlink" title="5.expire&#x2F;pexpire"></a>5.expire&#x2F;pexpire</h1><p>用于给某个key设置过期时间（时间到了之后自动被删除）其中expire的单位是秒，pexpire的单位是毫秒。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">expire key second</span><br><span class="line">pexpire key millisecond</span><br></pre></td></tr></table></figure><p>这个功能非常有用，在很多平台上我们都使用过验证码，为了保证一定的安全性，验证码都被设计为有过期时间的。这样系统生成一个验证码后，可以将其set进入Redis，然后使用expire命令给验证码设置过期时间（其实set命令里面就有选项可以设置过期时间了，这里只是举个例子）。还有限时优惠券、限时VIP体验券等等……</p><p>如果不使用Redis的expire功能，就需要在应用层甚至数据库中设计过期操作，相对来说就有些麻烦了。</p><p>还有另外一个场景，是基于Redis实现分布式锁：即在分布式集群中实现锁，以实现同步&#x2F;互斥功能。</p><ul><li>加锁：设置一个特殊的key，并设置过期时间；</li><li>解锁：删除该key；</li><li>判断是否有人占用：exists判断key存在则代表有人已经申请了锁，需要等待到key不存在的时候，则代表锁已经被释放。</li><li>可以在set的时候使用NX选项，保证只有key值不存在的时候才能设置上key（即只有锁没有被获取的时候才能加锁）；</li><li>因为Redis是单线程模型，所以set以及exists的操作是原子性的，不会出现并发访问的问题。</li></ul><p>此时为了<strong>避免申请锁的应用服务器无法正常解锁</strong>（比如申请了锁的服务器突然挂掉了），都会给锁上一个过期时间，避免整个系统陷入死锁状态。这个过期时间应该略大于当前服务器需要访问临界资源的时间（避免还没有访问完毕就因为超时自动解锁了）。</p><h1 id="6-ttl-x2F-pttl"><a href="#6-ttl-x2F-pttl" class="headerlink" title="6.ttl&#x2F;pttl"></a>6.ttl&#x2F;pttl</h1><p>这两个命令和expire&#x2F;pexpire对应，用于命令显示某个键值的过期时间还剩下多少，ttl返回的单位是秒，pttl返回的单位是毫秒。该命令查询的时间复杂度是<code>O(1)</code>；</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ttl key</span><br><span class="line">pttl key</span><br></pre></td></tr></table></figure><p>这两个命令都有两个特殊的返回值</p><ul><li><code>-1</code> 代表当前键值永不过期；</li><li><code>-2</code> 代表当前键值不存在；</li></ul><blockquote><p>Starting with Redis version 2.8.0: Added the -2 reply.</p></blockquote><h2 id="Redis的过期策略"><a href="#Redis的过期策略" class="headerlink" title="Redis的过期策略"></a>Redis的过期策略</h2><p>Redis是怎么知道一个key是否过期需要被删除呢？</p><p>直接遍历肯定不行，当库很大的时候，遍历一次的时间都够喝一壶了，完全达不到过期时间的要求。</p><p>Redis采用了定时删除+惰性删除策略的结合：</p><ul><li>定时删除：Redis定时（默认100ms检查一次）<strong>抽取一部分</strong>key检查TTL过期时间，并将过期的key删除。因为只抽取一部分，所以检查的耗时短；</li><li>惰性删除：用户请求某个key的时候检查TTL过期时间，过期的key被删除，不会返回给用户；</li></ul><p>这两个操作虽然维持了性能，但并不能保证过期键一定能被清理掉。如果某个键值很久没有被使用，且没有被Redis的定期删除策略抽取到，它就会留存在那里。要想保证Redis中不存在过期键，还需使用一些辅助策略来处理。</p><h2 id="定时器方案有哪些？"><a href="#定时器方案有哪些？" class="headerlink" title="定时器方案有哪些？"></a>定时器方案有哪些？</h2><blockquote><p>这里记录的是实现一个定时器可以采取的方式，和Redis采用的策略无关。</p></blockquote><h3 id="新建线程来定时删除"><a href="#新建线程来定时删除" class="headerlink" title="新建线程来定时删除"></a>新建线程来定时删除</h3><p><strong>方式1</strong>：使用线程来实现定时器。当需要定时删除的时候，启动一个线程，休眠指定时间，休眠结束后执行删除操作。但这会大大增加线程数量和系统负载，效率低。</p><h3 id="基于过期时间的优先级队列"><a href="#基于过期时间的优先级队列" class="headerlink" title="基于过期时间的优先级队列"></a>基于过期时间的优先级队列</h3><p><strong>方式2</strong>：使用优先级队列（以TTL剩余时间为key值，小的在前面），有设置过期时间的键值就被插入该队列，队首元素就是最快过期的键值。配置了优先级队列后，只需要一个线程去轮询检查队首来处理过期键值就行了。但是频繁的扫描会大大增加CPU负担。</p><p><strong>方式3</strong>：在方式2的基础上，添加休眠机制，让线程根据队首键值的过期时间进行休眠。休眠结束后删除队首元素。如果有新的键值插入，则唤醒该线程，重新根据队首键值的过期时间设置休眠时间。这可以通过条件变量的<code>wait_for</code>接口加上<code>notify</code>接口来实现。</p><h3 id="时间轮方案"><a href="#时间轮方案" class="headerlink" title="时间轮方案"></a>时间轮方案</h3><p><strong>方式4</strong>：使用时间轮方案，<strong>如下表所示</strong>。左侧代表一个基于现在的时间偏移量，每一个格子对应的100ms时间偏移，右侧是一个链表。从数据结构来看可以是一个顺序表+链表。</p><p>我们只需要将ttl根据范围插入对应的时间偏移量需要删除的key中，线程每次休眠100ms，休眠结束后就从链表里面取走过期的键值进行删除。</p><table><thead><tr><th>时间偏移量</th><th>需要删除的key（链表）</th></tr></thead><tbody><tr><td>100ms</td><td>ttl在<code>[0,100]</code>之间的</td></tr><tr><td>200ms</td><td>ttl在<code>[101,200]</code>之间的</td></tr><tr><td>300ms</td><td>…</td></tr></tbody></table><p>举个例子，现在是0秒，<strong>过期处理线程甲</strong>开始休眠100ms。此时来了几个有过期策略的key，分别是50ms过期key1、150ms过期key2、190ms过期key3、210秒过期key4。那么我们就可以获得下面这张顺序表+链表。</p><table><thead><tr><th>时间偏移量</th><th>需要删除的key（链表）</th></tr></thead><tbody><tr><td>100ms</td><td>key1</td></tr><tr><td>200ms</td><td>key2,key3</td></tr><tr><td>300ms</td><td>key4</td></tr></tbody></table><p>线程甲休眠100ms后，key1的过期时间就已经到了（此时早已过去了50ms）线程甲可以将其删除，然后再休眠100ms后处理key2和key3，再休眠100ms处理key4。</p><p>当然，当key1被删除后（第一个100ms已经休眠过了），表会出现下面的偏移。新来的键值都需要根据距离当前时间的偏移量插入到对应的位置。</p><table><thead><tr><th>时间偏移量</th><th>需要删除的key（链表）</th></tr></thead><tbody><tr><td>100ms</td><td>key2,key3</td></tr><tr><td>200ms</td><td>key4</td></tr></tbody></table><p>实际场景下，我们不可能让这个表格的长度一直增长下去，否则来个30000ms(30s)才过期的key，<strong>就需要300个表格（左侧顺序表）的空间才能存下这个需要30s才过期的键值</strong>，而这之中可能有很多表格项是空的（没有对应的过期键值），存在空间浪费。</p><p>为了节省这部分空间，要采用类似哈希映射的思想，比如1050ms过期的key也会被插入到时间偏移量为100ms的链表中，当线程休眠结束后需要检查链表中的值的过期时间是否真的到了，到了才执行删除操作。</p><p>另外，我们也需要根据具体休眠时间间隔来确定每次应该休眠多久。假设我们的key都是5ms到20ms就过期了，此时设置休眠间隔为100ms就不太合理了。</p><h1 id="7-type"><a href="#7-type" class="headerlink" title="7.type"></a>7.type</h1><p>该命令返回key对应value的类型，时间复杂度为<code>O(1)</code>；</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">type key</span><br></pre></td></tr></table></figure><p>返回值可以是 string, list, set, zset, hash and stream. 如果key不存在则返回none（注意返回的不是nil）。</p><p>在Redis官网文档中可以看到每个数据类型对应的数据结构：<a href="https://redis.io/docs/data-types/#core">Understand Redis data types | Redis</a>，其中当redis作为<strong>消息队列</strong>时类型为stream。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; type key1</span><br><span class="line">string</span><br><span class="line">127.0.0.1:6379&gt; lpush mylist 1 2</span><br><span class="line">(integer) 2</span><br><span class="line">127.0.0.1:6379&gt; type mylist</span><br><span class="line">list</span><br></pre></td></tr></table></figure><h1 id="8-object-encoding-变量编码类型"><a href="#8-object-encoding-变量编码类型" class="headerlink" title="8.object encoding 变量编码类型"></a>8.object encoding 变量编码类型</h1><p>Redis提供了多种数据类型：<a href="https://redis.io/docs/data-types/">Understand Redis data types | Redis</a></p><p>这些类型和我们常见的编程语言中的数据类型基本类似，<strong>但底层实现就不一样了</strong>。</p><p>Redis保证提供的数据类型符合这个数据类型应该有的预期，比如hash类型的插入和查询的效率应该是<code>O(1)</code>，但底层并不一定严格使用哈希表来实现。</p><p>Redis会根据实际场景动态选择更加合适的底层数据结构实现，<strong>来一定程度的提高效率</strong>。一个纯整数数字的string，直接用数字类型来存放会比使用字符串来存放占用更少的存储空间（1字节可以存放无符号数0到255，但255用字符串来存放需要3个字节）。</p><table><thead><tr><th>数据结构</th><th>内部编码</th></tr></thead><tbody><tr><td>string</td><td>raw(原始字符串)&#x2F;int&#x2F;embstr(为短字符串优化)</td></tr><tr><td>hash</td><td>hashtable(哈希表)&#x2F;ziplist(压缩列表,节省空间)</td></tr><tr><td>list</td><td>linkedlist(链表)&#x2F;ziplist&#x2F;quicklist</td></tr><tr><td>set</td><td>hashtable&#x2F;intset(整形集合)</td></tr><tr><td>zset</td><td>skiplist(跳表)&#x2F;ziplist</td></tr></tbody></table><p>ziplist是用来存放小列表的编码方式，使用它相比直接使用链表或哈希表能节省空间占用。当Redis中有很多个很小的list和hash的时候，ziplist就能辅助节省很可观的内存空间了。具体可以参考：<a href="https://blog.csdn.net/qq_31387317/article/details/94578370">Redis ziplist(压缩列表) CSDN博客</a></p><p>在Redis中可以使用object encoding命令来查看一个键值底层实际的编码方式是什么</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">object encoding key</span><br></pre></td></tr></table></figure><p>可以看到，比较短的字符串是embstr，list类型是quicketlist，全数字的字符串是int（包括负整数也是用int存放的）；</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; object encoding key1</span><br><span class="line">&quot;embstr&quot;</span><br><span class="line">127.0.0.1:6379&gt; object encoding mylist</span><br><span class="line">&quot;quicklist&quot;</span><br><span class="line">127.0.0.1:6379&gt; set key3 12345</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; object encoding key3</span><br><span class="line">&quot;int&quot;</span><br><span class="line">127.0.0.1:6379&gt; get a </span><br><span class="line">-1</span><br><span class="line">127.0.0.1:6379&gt; object encoding a</span><br><span class="line">int</span><br></pre></td></tr></table></figure><p>Redis会在键值中数据增加到一定量级后自动切换编码方式，对于用户来说是无感知的，所以我们只需要知道这个思想就行了。</p><h1 id="9-flushall-删库跑路"><a href="#9-flushall-删库跑路" class="headerlink" title="9.flushall 删库跑路"></a>9.flushall 删库跑路</h1><p>MySQL可以删库跑路，Redis自然也可以。这个命令的作用是清除Redis中的<strong>所有键值</strong>。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flushall</span><br></pre></td></tr></table></figure><p>如果采用Redis作为缓存，清空了问题相对来说还没那么大，但如果是作为数据库，那就祝你好运吧……</p><p>请不要在生产环境使用这个命令哦！</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; flushall</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; keys *</span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt;</span><br></pre></td></tr></table></figure><h1 id="The-end"><a href="#The-end" class="headerlink" title="The end"></a>The end</h1><p>以上便是Redis的全局命令了（最常用的命令），关于其他数据类型的命令会单独起文讲解。</p>]]></content>
    
    
    <summary type="html">Redis基本命令学习</summary>
    
    
    
    <category term="编程学习" scheme="https://blog.musnow.top/categories/%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="Redis" scheme="https://blog.musnow.top/categories/%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0/Redis/"/>
    
    
    <category term="Redis" scheme="https://blog.musnow.top/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>【Redis】02.Ubuntu22.04安装Redis</title>
    <link href="https://blog.musnow.top/posts/269089114/"/>
    <id>https://blog.musnow.top/posts/269089114/</id>
    <published>2024-02-10T06:54:05.000Z</published>
    <updated>2024-02-19T04:42:17.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="安装和启动"><a href="#安装和启动" class="headerlink" title="安装和启动"></a>安装和启动</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install -y redis</span><br></pre></td></tr></table></figure><p>安装了之后使用如下方式启动redis</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo systemctl start redis</span><br></pre></td></tr></table></figure><p>看一下6379端口号是否有进程在监听，有代表启动成功了</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">[root:/etc/redis]# systemctl status redis</span><br><span class="line">● redis-server.service - Advanced key-value store</span><br><span class="line">     Loaded: loaded (/lib/systemd/system/redis-server.service; enabled; vendor preset: enabled)</span><br><span class="line">     Active: active (running) since Sat 2024-02-10 14:45:11 CST; 4min 56s ago</span><br><span class="line">       Docs: http://redis.io/documentation,</span><br><span class="line">             man:redis-server(1)</span><br><span class="line">   Main PID: 1350 (redis-server)</span><br><span class="line">     Status: &quot;Ready to accept connections&quot;</span><br><span class="line">      Tasks: 5 (limit: 9527)</span><br><span class="line">     Memory: 7.5M</span><br><span class="line">     CGroup: /system.slice/redis-server.service</span><br><span class="line">             └─1350 &quot;/usr/bin/redis-server 127.0.0.1:6379&quot; &quot;&quot; &quot;&quot; &quot;&quot; &quot;&quot; &quot;&quot; &quot;&quot; &quot;&quot; &quot;&quot; &quot;&quot; &quot;&quot; &quot;&quot; &quot;&quot; &quot;&quot; &quot;&quot; &quot;&quot; &quot;&quot; &quot;&quot; &quot;&quot; &quot;&quot; &quot;&quot; &gt;</span><br><span class="line"></span><br><span class="line">Feb 10 14:45:11 wsl-ubuntu systemd[1]: Starting Advanced key-value store...</span><br><span class="line">Feb 10 14:45:11 wsl-ubuntu systemd[1]: Started Advanced key-value store.</span><br><span class="line">[root:/etc/redis]# netstat -nltp | grep 6379</span><br><span class="line">tcp        0      0 127.0.0.1:6379          0.0.0.0:*               LISTEN      1350/redis-server 1</span><br><span class="line">tcp6       0      0 ::1:6379                :::*                    LISTEN      1350/redis-server 1</span><br></pre></td></tr></table></figure><p>注意，如果你尝试在子用户里用如下命令查看redis是否绑定成功端口，可能查询不到结果。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">netstat -nltp | grep redis</span><br></pre></td></tr></table></figure><p>因为在子用户中，我们看不到当前占用6379端口的进程名字。只有root用户能看到。</p><h1 id="允许远程访问"><a href="#允许远程访问" class="headerlink" title="允许远程访问"></a>允许远程访问</h1><p>默认情况下redis绑定的ip是127.0.0.1，这个ip地址只允许本机访问，即你只能在这台linux主机上访问这个redis。</p><p>如果想实现远程访问，我们需要将绑定的ip改成0.0.0.0，并且关闭远程访问的保护</p><p>使用如下命令切换到root用户</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo su - </span><br></pre></td></tr></table></figure><p>进入redis的配置文件路径</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cd /etc/redis</span><br></pre></td></tr></table></figure><p>这里有一个<code>redis.conf</code>配置文件，我们需要修改的是下面的条目</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">bind 127.0.0.1 ::1</span><br><span class="line">protected-mode yes</span><br></pre></td></tr></table></figure><p>将它们修改为如下所示，即启用了redis允许远程访问的模式。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">bind 0.0.0.0 ::1</span><br><span class="line">protected-mode no</span><br></pre></td></tr></table></figure><p>修改完毕配置文件后，重启服务器即可生效</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo systemctl restart redis</span><br></pre></td></tr></table></figure><h1 id="连接redis"><a href="#连接redis" class="headerlink" title="连接redis"></a>连接redis</h1><p>和MySQL一样，Redis也是客户-服务端架构的软件。在Linux中，使用<code>redis-cli</code>命令即可直接连到当前主机的redis服务器</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root:/etc/redis]# redis-cli</span><br><span class="line">127.0.0.1:6379&gt; ping</span><br><span class="line">PONG</span><br><span class="line">127.0.0.1:6379&gt;</span><br></pre></td></tr></table></figure><p>如果需要链接非本机的redis服务器，使用如下命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis-cli -h IP地址 -p 端口</span><br></pre></td></tr></table></figure><p>如果想让redis-cli中可以正常显示中文，可以添加<code>--raw</code>选项。注意：使用该选项会导致Redis中显示的<code>(nil)</code>变成空字符串，极易产生误导！如果不是硬性需要在控制台中显示中文，请不要使用该选项！</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis-cli --raw</span><br></pre></td></tr></table></figure><p>当然，我们也可以像MySQL一样使用C语言的开发包来链接redis，那是后话了。</p><h1 id="命令学习"><a href="#命令学习" class="headerlink" title="命令学习"></a>命令学习</h1><p>redis的命令学习可以参考官网 <a href="https://redis.io/commands/">Commands | Redis</a></p><p>虽然是英文文档，但是照着翻译读读差不多都能看明白是怎么用的。</p>]]></content>
    
    
    <summary type="html">ubuntu22.04下安装redis</summary>
    
    
    
    <category term="编程学习" scheme="https://blog.musnow.top/categories/%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="Redis" scheme="https://blog.musnow.top/categories/%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0/Redis/"/>
    
    
    <category term="Linux" scheme="https://blog.musnow.top/tags/Linux/"/>
    
    <category term="Redis" scheme="https://blog.musnow.top/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>【vscode】远程主机可能不符合glibc和libstdc++ vscode服务器的先决条件</title>
    <link href="https://blog.musnow.top/posts/1712214675/"/>
    <id>https://blog.musnow.top/posts/1712214675/</id>
    <published>2024-02-09T01:54:24.000Z</published>
    <updated>2024-02-09T02:37:35.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><p>如图，VSCODE 1.86版本突然不支持我的centos7.6服务器了，这可咋办?</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/02/803920d76095f770c24324cfed769f89.png" alt="image.png"></p><p>百度了一下，官网上说是centos7缺少依赖项，已经无法被支持。</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/02/c28bde6edd23e6a5285d42485f810f1a.png" alt="image.png"></p><h1 id="回退版本"><a href="#回退版本" class="headerlink" title="回退版本"></a>回退版本</h1><p>不过并不是没有办法解决，回退到1.85版本就行了。</p><blockquote><p>参考：<a href="https://blog.csdn.net/Xuuuuuuuuuuu/article/details/135991844">vscode的ssh忽然连不上服务器：远程主机可能不符合glibc和libstdc++ VS Code服务器的先决条件-CSDN博客</a></p></blockquote><h2 id="关闭自动更新"><a href="#关闭自动更新" class="headerlink" title="关闭自动更新"></a>关闭自动更新</h2><p>回退之前，你先要把vscode的自动更新关掉，不然你安装了1.85后不用过10秒就会自动更新……</p><p>在vscode的设置里面搜索更新，点击左侧的<code>应用程序-更新</code>，找到更新模式，设置为None即取消自动更新，然后再去掉后台下载新版本的勾。</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/02/1169a49b1d503846a31bdedcbc6c02a9.png" alt="image.png"></p><p>然后去微软官网下载1.85旧版本，位置是vscode官网的update模块，在更新日志<code>November 2023 (version 1.85)</code>里面能找到旧版本。</p><p><a href="https://code.visualstudio.com/updates/v1_85">Visual Studio Code November 2023</a></p><p>windows主机点击这个x64下载就行了。</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/02/9e57878ba739716326425a3c87c80999.png" alt="image.png"></p><h2 id="回退插件版本"><a href="#回退插件版本" class="headerlink" title="回退插件版本"></a>回退插件版本</h2><p>安装1.85后remote-ssh和wsl插件都会显示不可用，会是灰色状态带一个红色感叹号。</p><p>点击插件旁边的齿轮，选择安装另外一个版本，安装4个月前的版本就行了。</p><ul><li>wsl插件：0.81.8</li><li>remote-ssh插件：0.107.0</li></ul><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/02/4f8240bb5ab45cddbfecca7473b5a10e.png" alt="image.png"></p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/02/114aa6786aa0fe8fac26cd5ec48e92d4.png" alt="image.png"></p><h1 id="The-end"><a href="#The-end" class="headerlink" title="The end"></a>The end</h1><p>安装完毕这两个旧版本插件后，就能连上centos7.6的服务器了。</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/02/2945ac9e10cbee3fcfd0a2e2f398c048.png" alt="image.png"></p>]]></content>
    
    
    <summary type="html">远程主机可能不符合glibc和libstdc++ vscode服务器的先决条件的解决办法</summary>
    
    
    
    <category term="差生文具多" scheme="https://blog.musnow.top/categories/%E5%B7%AE%E7%94%9F%E6%96%87%E5%85%B7%E5%A4%9A/"/>
    
    <category term="编程工具" scheme="https://blog.musnow.top/categories/%E5%B7%AE%E7%94%9F%E6%96%87%E5%85%B7%E5%A4%9A/%E7%BC%96%E7%A8%8B%E5%B7%A5%E5%85%B7/"/>
    
    
    <category term="vscode" scheme="https://blog.musnow.top/tags/vscode/"/>
    
  </entry>
  
  <entry>
    <title>【Redis】01.初步认识Redis和分布式系统</title>
    <link href="https://blog.musnow.top/posts/996575798/"/>
    <id>https://blog.musnow.top/posts/996575798/</id>
    <published>2024-02-08T05:02:41.000Z</published>
    <updated>2024-02-14T11:21:14.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-什么是Redis"><a href="#1-什么是Redis" class="headerlink" title="1.什么是Redis"></a>1.什么是Redis</h1><h2 id="1-1-简介"><a href="#1-1-简介" class="headerlink" title="1.1 简介"></a>1.1 简介</h2><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/02/903cf874bef24f120d4a6f89d6f08868.png" alt="image.png"></p><p>Redis是一个开源的，基于键值对key-value的NoSQL数据库。Redis内部存放的值可以是string、hash、list、set、zset、bitmaps、GEO等多种数据结构或算法；除了数据存放，Redis还提供了键值过期、订阅发布、事务、流水线、Lua脚本等附加功能，因此Redis能满足很多应用场景。</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/02/a26a91dc01fb2d631e4199609132f374.png" alt="image.png"></p><p>Redis会将数据存放在<strong>内存</strong>中，所以Redis的检索速率非常快（或者说IO吞吐高）。同时，为了保证数据不丢失，Redis会将内存中的数据用快照或者日志的方式存在硬盘上，实现一定程度上的数据持久化。</p><h2 id="1-2-什么时候用Redis？"><a href="#1-2-什么时候用Redis？" class="headerlink" title="1.2 什么时候用Redis？"></a>1.2 什么时候用Redis？</h2><p>在编程语言中定义变量，也是将数据存放在内存中。Redis的优势是在分布式集群系统中，而单机（单进程）程序里面，直接在编程语言中定义变量&#x2F;数据结构是更好的选择（Redis的快只是相对于MySQL这类数据库而言的）。</p><ul><li>如果未来需要引入分布式架构，使用Redis是一个好选择。否则没有必要。</li></ul><p>如果一个系统需要涉及到多个变量、多台主机时，Redis就能起作用了。它基于TCP，可以将自己内存中的变量分享给多个进程、多个主机来访问，这样分布式系统之间就能进行<strong>数据同步</strong>了。</p><p>又因为Redis是在内存中存放，所以它的检索速度相比MySQL会有更快的查询速度。在互联网应用中对数据库的查询性能要求较高，所以Redis就比MySQL更加适合这种场景。</p><blockquote><p>比如存储浏览器中的用户Cookie和Session的对应关系，这里还有一个特点，就是session并不是必须要永久保存的数据，我们能允许一定的数据丢失，后果无非是用户需要重新登录网页而已。</p></blockquote><p>当然，现在更多的选择是将Redis和MySQL等数据库结合，将热点数据（最常访问的数据）放入Redis，全量数据在MySQL中。此时Redis就好比一个数据的缓存了。</p><ul><li>保证热点数据的查询性能；</li><li>保证全量数据的正确保存；</li><li>但是会出现Redis和MySQL中增删改的数据同步问题；</li><li>使用Redis+MySQL会大大增加系统复杂性。</li></ul><h2 id="1-3-Redis不能做的事情？"><a href="#1-3-Redis不能做的事情？" class="headerlink" title="1.3 Redis不能做的事情？"></a>1.3 Redis不能做的事情？</h2><p>因为Redis是内存存储，所以它不适合存储大规模数据。</p><h1 id="2-分布式"><a href="#2-分布式" class="headerlink" title="2.分布式"></a>2.分布式</h1><p>前面提到，Redis的真正适用场景是分布式系统。那么什么是分布式系统呢？</p><h2 id="2-1-单机架构"><a href="#2-1-单机架构" class="headerlink" title="2.1 单机架构"></a>2.1 单机架构</h2><p>所谓单机架构，就是一个系统的所有服务都在一台服务器中运行。</p><p>如下图所示，假设这是一个简单的电商系统，它的数据库和应用程序都在同一台服务器上。用户访问这个服务器来获取电商服务。</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/02/4b3ddd75cab10fc351e38737b5c18ad7.png" alt="image.png"></p><p>之前我写的小项目<a href="https://blog.musnow.top/posts/4231483510">视频点播系统</a>，也是一个单机架构。采用MySQL作为数据库，C++来提供应用服务。</p><p>如果一台主机的性能能足够满足我们的用户服务需求了，单机架构就是很不错的选择，因为它的维护复杂度不高，且部署成本也较低。</p><h2 id="2-2-分布式"><a href="#2-2-分布式" class="headerlink" title="2.2 分布式"></a>2.2 分布式</h2><p>主机的性能指标包括IO性能（内存和硬盘）、网络吞吐、CPU计算性能等，这些性能都会在用户量增长到某一个量级时顶不住，导致服务的请求耗时较长甚至出现处理错误，用户体验差。</p><p>此时我们可以采取两个措施，开源节流：</p><ul><li>开源：给主机升级硬件</li><li>节流：通过软件debug找到影响系统性能的部分，针对性进行软件优化；</li></ul><p>但是，一台主机的性能，不管再怎么升级硬件，总归是有上限的。如果一个主机都被升级到顶天了还没有办法服务我们的性能，此时就需要<strong>多台主机</strong>来帮忙了。这便是分布式系统的基础。</p><ul><li>引入分布式其实是个万不得已的操作；</li><li>会导致系统复杂度大大提高；</li><li>系统出现BUG的可能性越来越高；</li><li>程序员被“开猿节流”的可能性越来越高……</li></ul><p>2023年年末，各大互联网厂家（阿里、滴滴）旗下的服务挨个boom，正是说明了这一点……</p><p>先来看看一个最简单的分布式系统吧，即将应用服务和数据库服务分离。</p><ul><li>应用服务器：CPU和内存性能，提高处理速度；</li><li>存储服务器：更大更快的硬盘，增加IO吞吐量；</li></ul><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/02/7420a71996b1c3c0a848e644d0419b13.png" alt="image.png"></p><h2 id="2-3-负载均衡"><a href="#2-3-负载均衡" class="headerlink" title="2.3 负载均衡"></a>2.3 负载均衡</h2><p>进一步扩展，就需要更多的主机，以及负载均衡措施了。</p><ul><li>一个负载均衡服务器和两个独立的应用服务器；</li><li>用户请求负载均衡服务器；</li><li>负载均衡服务器根据两个应用服务器当前的负载，选择较低的服务器来处理请求（这里涉及到负载均衡的算法）；</li></ul><p>此时两个应用服务器在一定程度上都干了相同的活，就能减少单个机器的压力。</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/02/fef48f23eed772c5c53a99c5b89f26e2.png" alt="image.png"></p><p>注意，虽然负载均衡服务器看上去会接受所有用户的请求，但它的请求承担能力是远远大于应用服务器的。因为它的工作很简单，只是一个简单的识别和分配工作，并不涉及到具体的功能。</p><p>如果请求量大到负载均衡服务器也顶不住了，那可以添加多个负载均衡服务器（可以采用多地节点的方式）。</p><p>添加上负载均衡措施后，就有了服务集群，这个集群中某个服务器挂掉对整个服务器的影响不高（它的请求可以由其他正常运行的服务器承担）一定程度上提高了可用性。</p><p>另外，负载均衡服务器也需要使用一些算法，比如想办法让同一个用户的请求始终走到同一个应用服务器上，避免在不同应用服务器中进行数据交换。</p><h2 id="2-4-数据库读写分离"><a href="#2-4-数据库读写分离" class="headerlink" title="2.4 数据库读写分离"></a>2.4 数据库读写分离</h2><p>前面提到的措施都是在优化应用服务器的负载，那么数据库服务器的负载应该如何降低呢？</p><p>比较简单的一种办法就是数据库的<code>读写分离</code>。即读数据库的操作和写数据库的操作由不同的服务器来承担。</p><ul><li>应用程序需要写入，请求A服务器</li><li>A服务器处理写入后，定期同步到B服务器</li><li>应用程序需要读取时请求B服务器</li></ul><p>考虑到实际场景中，<strong>读取的频率会远远高于写入</strong>，在这种情况下，读取服务器B大部分情况下只需要处理读请求，压力会降低。而且我们可以提供多个和B一样的读服务器，加上负载均衡，进一步减少读服务器的压力。</p><p>为什么说读的频率远远高于写入？以聊天软件为例：</p><ul><li>当用户打开聊天软件的主界面时，软件需要对当前聊天框里的所有联系人&#x2F;群组里面的消息进行一次查询；</li><li>当用户打开自己的个人信息时，软件需要查询个人信息（当然这个信息可能是本地早就缓存好了的）；</li><li>当用户打开朋友圈的时候，需要查询好友的朋友圈，并把最新的说说推送给当前用户</li><li>……</li></ul><p>上述的这一系列操作都是读查询，完全没有涉及到写。当用户使用聊天软件，没有发出消息时，聊天软件一直在做的都是读操作！以此类推，大部分软件在使用的时候，都是读操作居多，写操作相对较少。</p><h2 id="2-5-热点缓存"><a href="#2-5-热点缓存" class="headerlink" title="2.5 热点缓存"></a>2.5 热点缓存</h2><p>有一个经典的二八原则，在数据库场景也能适用：20%的数据能支撑80%的访问。</p><p>所以我们可以引入针对这20%的热点数据的<strong>缓存</strong>，保证这些热点数据能更快的被查询（读）。Redis可以说就是用来做缓存的。</p><p>缓存需要更快的查询速度，代价就是它存放不了太多的数据。比如Redis需要将数据存入内存中，内存的容量远远小于磁盘，存不了很多数据。所以缓存一定要使用适合场景的算法，保证缓存中的数据有尽可能高的命中率。</p><p>当然，这样会导致缓存服务器会承受较大的查询压力。不过完整数据库的查询压力又被进一步减少了。</p><h2 id="2-6-分库分表"><a href="#2-6-分库分表" class="headerlink" title="2.6 分库分表"></a>2.6 分库分表</h2><p>当一个服务器存储不下当前系统的<strong>全量数据</strong>时，就需要进行分库分表了。即将数据库进行一定的拆分，存放在多个服务器中。</p><p>如下图所示，将原本一个数据库的不同表，放在不同服务器中。这样一个服务器上就只用存放一部分数据，减少了存储容量的同时，也减少了单个服务器在查询方面的压力。同时，我们可以为某个表建立一个存储的集群，这也是依照负载均衡的基本思路来扩展主从。</p><p>如果一个表过大，没有办法放入一台主机，也可以根据表的<strong>主键</strong>来将该表拆分放入不同的服务器。比如服务器A放入主键1到10万，服务器B放入10万零1到20万等等……</p><p>这个拆分可以一直持续下去，直到性能满足了业务的需要。具体的拆分方式也是根据具体业务来进行处理的。</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/02/313e9c3894bd95766643b2d6150946b3.png" alt="image.png"></p><p>分布式的处理其实都是基于具体业务的需要来分析的。业务决定了我们应该选取的技术解决方案。</p><h2 id="2-7-微服务架构"><a href="#2-7-微服务架构" class="headerlink" title="2.7 微服务架构"></a>2.7 微服务架构</h2><p>前面提到的处理都是在服务器拆分、数据库拆分上处理的。我们的应用服务器依旧是一个服务器能完成这个业务的所有任务。这样会导致该应用服务器的代码非常庞大，且难以进行维护。</p><p>我们可以将整个系统根据功能进行拆分，用户管理是一个应用服务器、商品交易是一个应用服务器、交易处理也是一个应用服务器，在不同的服务器之间可以通过消息中间件之类的方式进行数据通信。</p><p>而诸如安全处理等大家都用得上的公共服务，可以单开一个进行处理。</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/02/e46480d91db2ab3edce15e0946c0a14c.png" alt="image.png"></p><p>实际上，微服务是在解决团队协作的问题。单一应用服务器在规模大了之后会非常非常复杂，而使用微服务架构，<strong>可以将团队按照业务拆分成不同的小组</strong>，每个小组只需要维护产品中的一部分服务，这样维护单个服务的难度就降低了，更重要的是，企业的组织架构的分配变得更加方便。</p><h3 id="微服务的优势"><a href="#微服务的优势" class="headerlink" title="微服务的优势"></a>微服务的优势</h3><p>微服务的优势：</p><ul><li>解决了团队组织架构分配的问题</li><li>方便代码功能的复用（比如不同服务它的用户管理模块的代码其实是差别不大的，方便进行复用）</li><li>不同的服务，可以进行针对性的部署（比如某些服务的性能需求不高，就可以部署在配置相对较差的服务器上）</li></ul><h3 id="微服务的缺点"><a href="#微服务的缺点" class="headerlink" title="微服务的缺点"></a>微服务的缺点</h3><p>微服务架构对应用服务的拆分会进一步扩大整个系统的复杂性，反正就是越拆越复杂。缺点如下：</p><ul><li>系统响应速度降低：因为不同的模块是在不同的服务集群上处理，它们之间需要使用网络进行通信，相比于单个完整的应用服务器，整个系统的响应速度降低了。要想保证系统响应速度降低幅度小，就得引入更多的硬件资源来处理（更快的网卡）</li><li>系统出现问题概率提高：因为微服务会引入更多的机器，导致出现问题的概率被提高。需要更多更详细的监控和告警方式来保证多台云服务器的可用性。</li></ul><h1 id="3-分布式中涉及到的相关概念"><a href="#3-分布式中涉及到的相关概念" class="headerlink" title="3.分布式中涉及到的相关概念"></a>3.分布式中涉及到的相关概念</h1><h2 id="3-1-应用Application-x2F-系统System"><a href="#3-1-应用Application-x2F-系统System" class="headerlink" title="3.1 应用Application&#x2F;系统System"></a>3.1 应用Application&#x2F;系统System</h2><p>一个应用（系统）就是一个或者一组服务器程序</p><h2 id="3-2-模块Module-x2F-组件Componet"><a href="#3-2-模块Module-x2F-组件Componet" class="headerlink" title="3.2 模块Module&#x2F;组件Componet"></a>3.2 模块Module&#x2F;组件Componet</h2><p>应用中的不同功能被拆分成不同的模块，共同组成最终的应用程序</p><h2 id="3-3-分布式Distributed"><a href="#3-3-分布式Distributed" class="headerlink" title="3.3 分布式Distributed"></a>3.3 分布式Distributed</h2><p>引入多个服务器&#x2F;主机，协同配合完成一系列工作（物理上的多个主机）</p><h2 id="3-4-集群Cluster"><a href="#3-4-集群Cluster" class="headerlink" title="3.4 集群Cluster"></a>3.4 集群Cluster</h2><p>引入多个服务器&#x2F;主机，协同配合完成一系列工作（逻辑上的多个主机）</p><h2 id="3-5-主Master-x2F-从Slave"><a href="#3-5-主Master-x2F-从Slave" class="headerlink" title="3.5 主Master&#x2F;从Slave"></a>3.5 主Master&#x2F;从Slave</h2><p>多个服务器节点中，一个是主节点，其他是从节点。<code>从节点</code>需要从<code>主节点</code>中同步数据。</p><h2 id="3-6-中间件Middleware"><a href="#3-6-中间件Middleware" class="headerlink" title="3.6 中间件Middleware"></a>3.6 中间件Middleware</h2><p>和具体业务无关，但在系统中需要使用的服务。比如数据库、缓存、消息队列等。</p><h2 id="3-7-可用性Availability"><a href="#3-7-可用性Availability" class="headerlink" title="3.7 可用性Availability"></a>3.7 可用性Availability</h2><p>系统整体可用时间&#x2F;总时间</p><blockquote><p>三个9代表可用性是<code>99.999%</code>；</p></blockquote><h2 id="3-8-响应时间Response-Time-RT"><a href="#3-8-响应时间Response-Time-RT" class="headerlink" title="3.8 响应时间Response Time RT"></a>3.8 响应时间Response Time RT</h2><p>用于衡量服务器的性能，响应时间越快越好</p><h2 id="3-9-吞吐Throughput和并发Concurrent"><a href="#3-9-吞吐Throughput和并发Concurrent" class="headerlink" title="3.9 吞吐Throughput和并发Concurrent"></a>3.9 吞吐Throughput和并发Concurrent</h2><p>衡量系统处理请求的能力，也是衡量性能的方式之一。</p><h1 id="4-Redis的特性"><a href="#4-Redis的特性" class="headerlink" title="4.Redis的特性"></a>4.Redis的特性</h1><p>我们可以在redis的官网上看到redis的特性，一个一个来认识一下吧</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/02/9aec7a8ebddb4dd911e41981cea8d11a.png" alt="image-20240210135822201"></p><h2 id="4-1-In-memory-data-structures"><a href="#4-1-In-memory-data-structures" class="headerlink" title="4.1 In-memory data structures"></a>4.1 In-memory data structures</h2><p>前面已经提到过，Redis是一个KV方式的内存级数据库，它的Key都是string，value可以是string、hash、list、set、zset、bitmaps、GEO等各种数据结构。</p><p>使用Key-Value方式来存放数据的数据库，被称为<code>非关系数据库</code>，NoSQL也是类似的含义。</p><h2 id="4-2-Progarmmability"><a href="#4-2-Progarmmability" class="headerlink" title="4.2 Progarmmability"></a>4.2 Progarmmability</h2><p>针对Redis的操作，可以通过简单的交互式命令来存放数据，也可以通过脚本来批量执行一些操作。</p><h2 id="4-3-Extentsibility"><a href="#4-3-Extentsibility" class="headerlink" title="4.3 Extentsibility"></a>4.3 Extentsibility</h2><p>Redis提供了一系列API，可以在Redis原有功能的基础上配置扩展，比如让Redis支持更多数据结构。支持C&#x2F;C++&#x2F;Rust语言。</p><h2 id="4-4-Persistence"><a href="#4-4-Persistence" class="headerlink" title="4.4 Persistence"></a>4.4 Persistence</h2><p>Redis是将数据存放在内存中的，但也提供了<strong>持久化</strong>方式来保证系统重启时数据不会丢失。</p><h2 id="4-5-Clustering"><a href="#4-5-Clustering" class="headerlink" title="4.5 Clustering"></a>4.5 Clustering</h2><p>Redis作为分布式系统的中间件，原生支持集群部署。</p><p>Horizontal scalability 指的是系统的水平扩展能力，类似于“分库分表”。</p><h2 id="4-6-High-availability"><a href="#4-6-High-availability" class="headerlink" title="4.6 High availability"></a>4.6 High availability</h2><p>Redis原生支持主从结构，从节点相当于主节点的备份，主节点失效时从节点能立马顶上去（替补）。</p><h2 id="4-7-天下武功唯快不破"><a href="#4-7-天下武功唯快不破" class="headerlink" title="4.7 天下武功唯快不破"></a>4.7 天下武功唯快不破</h2><p>Redis能被广泛的使用，最大的原因还是因为它很快！</p><ol><li>Redis数据在内存中，比访问硬盘的数据库快的多；</li><li>Redis的核心功能逻辑较为简单，只是操作内存中的数据结构；</li><li>Redis使用了IO多路复用(epoll)来处理网络请求；</li><li>Redis使用的单线程模型（高版本Redis引入了多线程），减少了线程竞争的不必要的开销。</li></ol><p>这里要补充一点，多线程提高效率的前提是执行的是CPU密集型的操作，多线程才能充分利用CPU的多核心资源。而Redis的核心功能只是操作内存中的数据，对CPU的负载并不高。</p><p>相比MySQL在增删改数据的时候需要关注数据库中的各种约束，这些检查就增加了负担，耗时也会被Redis的简单修改更长。</p><p>另外，IO多路复用是一个很重要的概念，它是操作系统提供的接口（比如Linux提供的C语言接口，而Redis正好就是C语言编写的）让一个线程有办法同时处理多个网络请求。如果没有多路复用，一个线程就只能给一个请求服务，Redis的单线程设计就不好用了。具体可以点击链接查看本站的博客。<a href="https://blog.musnow.top/posts/3390191280">【Linux】高级IO和多路转接 | select&#x2F;poll&#x2F;epoll | 慕雪的寒舍</a></p><h1 id="5-Redis的单线程模型"><a href="#5-Redis的单线程模型" class="headerlink" title="5.Redis的单线程模型"></a>5.Redis的单线程模型</h1><p>上文提到，Redis是采用单线程模型进行设计的，虽然高版本Redis引入了多线程，但只限于网络IO部分（多线程来处理网络请求）实际的存储操作还是使用单线程来处理的。</p><p>复习一下多线程并发可能导致的问题吧：假设两个Redis客户端链接了服务器，都希望对同一个key进行set操作，客户端A希望将key加一，客户端B也希望将key加一，这两个请求几乎同时发送给Redis的服务器，假设Redis服务器采用多线程来处理，那么就有可能出现</p><ul><li>A的请求读取了key的当前值，准备进行加一操作；</li><li>B的请求读取了key的当前值，也准备进行加一操作；</li><li>由于两个读取几乎是同时发生的，A和B的处理线程读取到的key的值一致；</li><li>最终导致key只被加一了（实际需要加二）；</li></ul><p>而实际上，Redis采用单线程模型，A和B的请求肯定会有个先后顺序，最终处理是<strong>串行</strong>（依次执行）的，要么是先处理A的加一，再处理B的加一，最终肯定能得到加二的正确结果。</p><p>Redis在网络IO上引入多线程，但在核心处理保持单线程，可以在提高网络IO处理效率的基础上，保证对数据的操作一定是串行的。</p><blockquote><p>这就好比一个食堂只有一个打饭窗口，中午下课了一堆人去食堂（网络IO多线程），但进了食堂之后还是得排队打饭（串行）。</p></blockquote><p>因为Redis的核心操作对CPU的负载并不高，所以它没有必要使用多线程来提高数据处理方面的效率（因为使用多线程就务必需要加锁&#x2F;解锁以及资源竞争，本来开门取东西只需要一下子就搞定了，现在还多了解锁&#x2F;关门上锁的步骤，效率可能不增反降）。</p><h1 id="The-end"><a href="#The-end" class="headerlink" title="The end"></a>The end</h1>]]></content>
    
    
    <summary type="html">什么是Redis？什么是分布式系统？</summary>
    
    
    
    <category term="编程学习" scheme="https://blog.musnow.top/categories/%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="Redis" scheme="https://blog.musnow.top/categories/%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0/Redis/"/>
    
    
    <category term="Redis" scheme="https://blog.musnow.top/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>【Docker】gitea的ssh容器直通</title>
    <link href="https://blog.musnow.top/posts/1063684344/"/>
    <id>https://blog.musnow.top/posts/1063684344/</id>
    <published>2024-02-07T07:01:43.000Z</published>
    <updated>2024-02-24T03:01:58.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-跟着文档走"><a href="#1-跟着文档走" class="headerlink" title="1.跟着文档走"></a>1.跟着文档走</h1><p>gitea的安装比较简单，直接使用官方文档中的docker-compose文件即可。如果想实现ssh容器直通，需要对这个docker-compose文件做一定修改。</p><blockquote><p>如果你还没有安装docker，参考本站教程 <a href="https://blog.musnow.top/posts/2069190154">linux安装docker</a>；</p></blockquote><p>gitea的官方文档上有关于docker容器ssh直通的教程，但是写的不够清晰，有些问题我没有搞懂。本文基于我的折腾记录和docker安装的gitea 1.21.4文档</p><p><a href="https://docs.gitea.com/zh-cn/next/installation/install-with-docker#ssh-%E5%AE%B9%E5%99%A8%E7%9B%B4%E9%80%9A">使用 Docker 安装 | Gitea Documentation</a></p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/02/4a6a40b4f39a75d32fc7fc45919316ba.png" alt="image.png"></p><p>首先是跟着文章里面的步骤做，先创建一个git子用户。wsl中创建子用户的命令参考本站博客（使用adduser命令），注意创建的git用户的uid和gid是1001，docker-compose中的环境变量需要对应修改。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">environment:</span></span><br><span class="line">     <span class="bullet">-</span> <span class="string">USER_UID=1001</span></span><br><span class="line">     <span class="bullet">-</span> <span class="string">USER_GID=1001</span></span><br></pre></td></tr></table></figure><p>还需要新增一个路径映射</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- /home/git/.ssh/:/data/git/.ssh</span><br></pre></td></tr></table></figure><blockquote><p>注意：为了避免文件读写权限问题，我建议在创建git子用户后，在该子用户中操作docker-compose和新建gitea的映射文件夹，这样能保证1001用户和gitea容器一定能访问到文件夹且具有权限。</p></blockquote><p>在git用户中执行如下命令。出现的提示框全部回车即可。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo -u git ssh-keygen -t rsa -b 4096 -C <span class="string">&quot;Gitea Host Key&quot;</span></span><br></pre></td></tr></table></figure><p>随后执行如下命令，即把<code>/home/git/.ssh/id_rsa.pub</code>写入<code>/home/git/.ssh/authorized_keys</code>文件。执行完毕后请不要再手动修改authorized_keys文件。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">&quot;<span class="subst">$(cat /home/git/.ssh/id_rsa.pub)</span>&quot;</span> &gt;&gt; /home/git/.ssh/authorized_keys</span><br></pre></td></tr></table></figure><p>还需要创建一个脚本来执行ssh信息转发</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo vim /usr/local/bin/gitea</span><br></pre></td></tr></table></figure><p>写入如下内容，可以通过<code>CTRL+SHIFT+V</code>直接粘贴。这里假设你将gitea容器的22端口转发到宿主机的2222端口（如果你的宿主机映射端口不同，可以修改脚本中的端口号）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh -p 2222 -o StrictHostKeyChecking=no git@127.0.0.1 &quot;SSH_ORIGINAL_COMMAND=\&quot;$SSH_ORIGINAL_COMMAND\&quot; $0 $@&quot;</span><br></pre></td></tr></table></figure><p>因为ssh容器直通都是本机处理的操作，所以我们可以在docker-compose中端口映射的时候限制来源IP地址为本地回环地址，这样就能保证只有宿主机中能访问2222端口到gitea中，而2222端口无法直接被外界访问。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">ports:</span></span><br><span class="line">  <span class="comment"># [...]</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">&quot;127.0.0.1:2222:22&quot;</span></span><br></pre></td></tr></table></figure><h2 id="ssh直通流程"><a href="#ssh直通流程" class="headerlink" title="ssh直通流程"></a>ssh直通流程</h2><p>配置完毕ssh直通后，git操作流程如下：</p><ol><li>用户使用<code>git@IP地址</code>访问主机，默认访问22端口；</li><li>主机验证git用户下<code>.ssh/authorized_keys</code>的<code>command</code>开头的公钥中，发现用户公钥；</li><li>主机执行command指定的脚本，将此次请求的信息转发给gitea容器的ssh端口；</li><li>gitea容器执行ssh请求处理；</li></ol><p>如果不使用容器直通，你可以选择用https来进行git操作，或者在ssh使用时添加端口号。二者都会比直接使用ssh麻烦一些。</p><h1 id="2-安装ssh服务"><a href="#2-安装ssh服务" class="headerlink" title="2.安装ssh服务"></a>2.安装ssh服务</h1><p>另外，默认情况下wsl中是没有ssh服务的，你会发现22端口无人使用</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root:~]# netstat -nltp | grep 22</span><br><span class="line">tcp        0      0 127.0.0.1:2222          0.0.0.0:*               LISTEN      2816/docker-proxy</span><br></pre></td></tr></table></figure><p>需要安装一下ssh服务</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install -y openssh-server</span><br><span class="line">sudo systemctl start sshd</span><br></pre></td></tr></table></figure><p>使用如下命令查看服务状态以及是否启用了开机自启</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">[root:~]# systemsystemctl status sshd</span><br><span class="line">● ssh.service - OpenBSD Secure Shell server</span><br><span class="line">     Loaded: loaded (/lib/systemd/system/ssh.service; enabled; vendor preset: enabled)</span><br><span class="line">     Active: active (running) since Wed 2024-02-07 14:59:06 CST; 9min ago</span><br><span class="line">       Docs: man:sshd(8)</span><br><span class="line">             man:sshd_config(5)</span><br><span class="line">   Main PID: 5202 (sshd)</span><br><span class="line">      Tasks: 1 (limit: 9527)</span><br><span class="line">     Memory: 1.7M</span><br><span class="line">     CGroup: /system.slice/ssh.service</span><br><span class="line">             └─5202 &quot;sshd: /usr/sbin/sshd -D [listener] 0 of 10-100 startups&quot;</span><br><span class="line"></span><br><span class="line">Feb 07 14:59:06 wsl-ubuntu systemd[1]: Starting OpenBSD Secure Shell server...</span><br><span class="line">Feb 07 14:59:06 wsl-ubuntu sshd[5202]: Server listening on 0.0.0.0 port 22.</span><br><span class="line">Feb 07 14:59:06 wsl-ubuntu sshd[5202]: Server listening on :: port 22.</span><br><span class="line">Feb 07 14:59:06 wsl-ubuntu systemd[1]: Started OpenBSD Secure Shell server.</span><br><span class="line">[root:~]# sudo systemctl is-enabled sshd</span><br><span class="line">alias</span><br><span class="line">[root:~]# sudo systemctl is-enabled ssh</span><br><span class="line">enabled</span><br></pre></td></tr></table></figure><p>此时再看看22端口，就有人干活了，sshd服务启动成功</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root:~]# netstat -nltp | grep 22</span><br><span class="line">tcp        0      0 0.0.0.0:22              0.0.0.0:*               LISTEN      5202/sshd: /usr/sbi</span><br><span class="line">tcp        0      0 127.0.0.1:2222          0.0.0.0:*               LISTEN      2816/docker-proxy</span><br><span class="line">tcp6       0      0 :::22                   :::*                    LISTEN      5202/sshd: /usr/sbi</span><br></pre></td></tr></table></figure><h1 id="3-web界面添加用户ssh公钥"><a href="#3-web界面添加用户ssh公钥" class="headerlink" title="3.web界面添加用户ssh公钥"></a>3.web界面添加用户ssh公钥</h1><p>随后就是和github一样的操作， 在gitea的web页面添加用户的公钥。</p><p><a href="https://blog.musnow.top/posts/3625274788/">【Linux】如何使用 ssh 密钥配置 git</a></p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/02/4e28dd20b29a4e7ebaabcce3c09ac579.png" alt="image.png"></p><p>添加完毕后，检查一下git用户里面的<code>/home/git/.ssh/authorized_keys</code>文件是否有变动，文件应该如下格式，会有一个<code>command=</code>存放了你刚刚在gitea web页面添加的用户公钥。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ssh-rsa &lt;Gitea Host Key&gt;</span><br><span class="line"></span><br><span class="line"># other keys from users</span><br><span class="line">command=&quot;/usr/local/bin/gitea --config=/data/gitea/conf/app.ini serv key-1&quot;,no-port-forwarding,no-X11-forwarding,no-agent-forwarding,no-pty &lt;user pubkey&gt;</span><br></pre></td></tr></table></figure><p>文档中关于这一块的描述不够清楚（我感觉是机翻的问题）</p><blockquote><p>原文：重要提示：来自 git 用户的公钥需要“按原样”添加，而通过 Gitea 网络界面添加的所有其他公钥将以 <code>command=&quot;/app [...]</code> 作为前缀。</p></blockquote><p>其实这个说明的意思是，默认情况下的<code>authorized_keys</code>文件中应该只有下面的内容（即“按原样”添加），而gitea web页面添加的其他公钥应该都是以<code>command=&quot;</code> 作为前缀，<strong>自动</strong>添加到<code>authorized_keys</code>文件之后的。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-rsa &lt;Gitea Host Key&gt;</span><br></pre></td></tr></table></figure><p>说白了就是，在执行完毕上文提到的将<code>id_rsa.pub</code>文件的内容写入<code>authorized_keys</code>的操作后，<strong>我们就不要手动修改authorized_keys这个文件了</strong>！如果出现问题，再依照文档中的这个提示检查该文件中的公钥格式是否正确。</p><p>官网文档中还提到了下面几个注意事项，我们全都不用管！只要你没有修改过配置文件和gitea容器中的环境，这些配置项都是默认情况下就OK了的。</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/02/4a3b6349ff4e3db039e87550910597d8.png" alt="image.png"></p><h1 id="4-验证是否直通成功"><a href="#4-验证是否直通成功" class="headerlink" title="4.验证是否直通成功"></a>4.验证是否直通成功</h1><p>尝试验证ssh是否成功，这里的ip是wsl的本机ip，可以在wsl中通过ifconfig命令查看。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh -T git@172.26.39.91</span><br></pre></td></tr></table></figure><p>如果出现下面的情况，说明22端口没有被成功开放，请检查:</p><ul><li>宿主机中的22端口是否已经配置了sshd服务，并正常监听22端口；</li><li>在web页面添加的用户公钥是否添加到了<code>/home/git/.ssh/authorized_keys</code>文件中；</li><li><code>/usr/local/bin/gitea</code>脚本中的命令无误。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">PS D:\test-git&gt; git clone git@172.26.39.91:musnows/test-action.git</span><br><span class="line">Cloning into &#x27;test-action&#x27;...</span><br><span class="line">ssh: connect to host 172.26.39.91 port 22: Connection refused</span><br><span class="line">fatal: Could not read from remote repository.</span><br><span class="line"></span><br><span class="line">Please make sure you have the correct access rights</span><br><span class="line">and the repository exists.</span><br></pre></td></tr></table></figure><p>如果看到了下面的内容，可以说明我们wsl中的的ssh服务已经成功启动了，但是没有成功通过脚本验证git用户。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">PS D:\test-git&gt; ssh -T git@172.26.39.91</span><br><span class="line">The authenticity of host &#x27;172.26.39.91 (172.26.39.91)&#x27; can&#x27;t be established.</span><br><span class="line">ED25519 key fingerprint is SHA256:xRPtWVSIsHrqmP3VaBD+ZR24nE6SWmgjWUYENN0IfB8.</span><br><span class="line">This key is not known by any other names</span><br><span class="line">Are you sure you want to continue connecting (yes/no/[fingerprint])? yes</span><br><span class="line">Warning: Permanently added &#x27;172.26.39.91&#x27; (ED25519) to the list of known hosts.</span><br><span class="line">bash: line 1: /usr/local/bin/gitea: Permission denied</span><br></pre></td></tr></table></figure><p>这是因为我们的git用户没有办法执行<code>/usr/local/bin/gitea</code>脚本，还记得吗，这个脚本是通过sudo创建的，默认情况下是一个文本文件，且只有root用户有权限访问</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root:~]# ll /usr/local/bin/gitea</span><br><span class="line">-rw-r--r-- 1 root root 109 Feb  7 14:47 /usr/local/bin/gitea</span><br></pre></td></tr></table></figure><p>解决办法很简单，将其权限改成777即可。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root:~]# chmod 777 /usr/local/bin/gitea</span><br><span class="line">[root:~]# ll /usr/local/bin/gitea</span><br><span class="line">-rwxrwxrwx 1 root root 109 Feb  7 14:47 /usr/local/bin/gitea*</span><br></pre></td></tr></table></figure><p>此时再次测试，发现成功直通gitea容器内ssh！这里会显示你在web页面中添加的ssh密钥的名字<code>user from windows</code>。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">PS D:\test-git&gt; ssh -T git@172.26.39.91</span><br><span class="line">Warning: Permanently added &#x27;[127.0.0.1]:2222&#x27; (ED25519) to the list of known hosts.</span><br><span class="line">Hi there, musnows! You&#x27;ve successfully authenticated with the key named user from windows, but Gitea does not provide shell access.</span><br><span class="line">If this is unexpected, please log in with password and setup Gitea under another user.</span><br></pre></td></tr></table></figure><p>再试试能不能通过ssh克隆仓库，搞定！</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">PS D:\test-git&gt; git clone git@172.26.39.91:musnows/test-action.git</span><br><span class="line">Cloning into &#x27;test-action&#x27;...</span><br><span class="line">remote: Enumerating objects: 80, done.</span><br><span class="line">remote: Counting objects: 100% (80/80), done.</span><br><span class="line">remote: Compressing objects: 100% (58/58), done.</span><br><span class="line">remote: Total 80 (delta 22), reused 0 (delta 0), pack-reused 0</span><br><span class="line">Receiving objects: 100% (80/80), 56.15 KiB | 9.36 MiB/s, done.</span><br><span class="line">Resolving deltas: 100% (22/22), done.</span><br></pre></td></tr></table></figure><h1 id="5-docker-compose文件"><a href="#5-docker-compose文件" class="headerlink" title="5.docker-compose文件"></a>5.docker-compose文件</h1><p>下面给出本文所用的gitea容器docker-compose文件，只在官方文档所提供的版本上做了少量修改。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">&quot;3&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="attr">networks:</span></span><br><span class="line">  <span class="attr">gitea:</span></span><br><span class="line">    <span class="attr">external:</span> <span class="literal">false</span></span><br><span class="line"></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="attr">server:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">gitea/gitea:1.21.4</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">gitea</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">USER_UID=1001</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">USER_GID=1001</span></span><br><span class="line">    <span class="attr">restart:</span> <span class="string">always</span></span><br><span class="line">    <span class="attr">networks:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">gitea</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">/home/git/data:/data</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">/home/git/.ssh/:/data/git/.ssh</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">/etc/timezone:/etc/timezone:ro</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">/etc/localtime:/etc/localtime:ro</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;30000:3000&quot;</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;127.0.0.1:2222:22&quot;</span></span><br></pre></td></tr></table></figure><p>注意，在初始化gitea的时候不要修改web界面和ssh的监听端口（对应的是容器内的端口），否则上文的ssh直通可能会失败！</p><h1 id="The-end"><a href="#The-end" class="headerlink" title="The end"></a>The end</h1><p>如果有疑问，欢迎在评论区交流。</p><p>相关参考：<a href="https://moqiaoduo.cn/310.html">如何通过Docker搭建Gitea并配置SSL和SSH直通 - 莫乔多博客</a></p>]]></content>
    
    
    <summary type="html">docker安装的gitea在wsl2上配置ssh容器直通</summary>
    
    
    
    <category term="编程学习" scheme="https://blog.musnow.top/categories/%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="Docker真好玩" scheme="https://blog.musnow.top/categories/%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0/Docker%E7%9C%9F%E5%A5%BD%E7%8E%A9/"/>
    
    
    <category term="Docker" scheme="https://blog.musnow.top/tags/Docker/"/>
    
    <category term="虚拟机" scheme="https://blog.musnow.top/tags/%E8%99%9A%E6%8B%9F%E6%9C%BA/"/>
    
    <category term="wsl" scheme="https://blog.musnow.top/tags/wsl/"/>
    
    <category term="gitea" scheme="https://blog.musnow.top/tags/gitea/"/>
    
  </entry>
  
  <entry>
    <title>【WSL】wsl中ubuntu无法通过useradd添加用户</title>
    <link href="https://blog.musnow.top/posts/803882566/"/>
    <id>https://blog.musnow.top/posts/803882566/</id>
    <published>2024-02-07T06:59:43.000Z</published>
    <updated>2024-02-16T00:58:23.000Z</updated>
    
    <content type="html"><![CDATA[<p>适用于hexo-butterfly主题的front-matter模板。</p><h1 id="情况说明"><a href="#情况说明" class="headerlink" title="情况说明"></a>情况说明</h1><p>在wsl2中的ubuntu22.04无法使用useradd添加用户，表现为执行命令后，只出现该用户和用户组，但<code>/home</code>目录下没有出现该用户的家目录文件夹，且无法使用<code>su - 用户名</code>成功切换到该用户上。</p><p>如下所示，我先从wsl子用户切换到root用户，然后执行useradd命令，发现用户创建没有完全成功。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">wsl:~$ sudo su - </span><br><span class="line"></span><br><span class="line">root:~# useradd git</span><br><span class="line">root:~# ls /home</span><br><span class="line">wsl</span><br><span class="line">root:~# sudo adduser git</span><br><span class="line">adduser: The user `git&#x27; already exists.</span><br><span class="line">root:~# userdel -r git</span><br><span class="line">userdel: git mail spool (/var/mail/git) not found</span><br><span class="line">userdel: git home directory (/home/git) not found</span><br><span class="line">root:~# userdel -r git</span><br><span class="line">userdel: user &#x27;git&#x27; does not exist</span><br></pre></td></tr></table></figure><h1 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h1><p><del>这是因为wsl2和传统的VMware类型虚拟机有一定区别，其不支持使用useradd直接添加用户</del>，而是提供了adduser命令来处理。准确来说是Ubuntu22.04不支持useradd，而是需要使用adduser。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo adduser &lt;新的用户名&gt;</span><br></pre></td></tr></table></figure><p>使用这个命令则可以正常创建用户，如下所示我创建了一个用户名为git的用户。需要填写用户信息的部分直接回车跳过即可。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">root:~# sudo adduser git</span><br><span class="line">Adding user `git&#x27; ...</span><br><span class="line">Adding new group `git&#x27; (1001) ...</span><br><span class="line">Adding new user `git&#x27; (1001) with group `git&#x27; ...</span><br><span class="line">Creating home directory `/home/git&#x27; ...</span><br><span class="line">Copying files from `/etc/skel&#x27; ...</span><br><span class="line">New password:</span><br><span class="line">Retype new password:</span><br><span class="line">passwd: password updated successfully</span><br><span class="line">Changing the user information for git</span><br><span class="line">Enter the new value, or press ENTER for the default</span><br><span class="line">        Full Name []:</span><br><span class="line">        Room Number []:</span><br><span class="line">        Work Phone []:</span><br><span class="line">        Home Phone []:</span><br><span class="line">        Other []:</span><br><span class="line">Is the information correct? [Y/n] y</span><br><span class="line">root:~# ls /home</span><br><span class="line">git  wsl</span><br></pre></td></tr></table></figure><p>使用id命令可以查看新用户的用户组以及uid等相关信息。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">root:~# id git</span><br><span class="line">uid=1001(git) gid=1001(git) groups=1001(git)</span><br></pre></td></tr></table></figure><p>注意，该新用户不在<code>/etc/sudoers</code>文件中，无法使用sudo命令。需要修改该文件，在如下位置之后添加一行</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">root ALL=(ALL:ALL) ALL</span><br><span class="line"># 新增此行</span><br><span class="line">用户名 ALL=(ALL:ALL) ALL</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">wsl中ubuntu无法通过useradd添加用户,应该使用adduser命令</summary>
    
    
    
    <category term="编程学习" scheme="https://blog.musnow.top/categories/%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="Linux" scheme="https://blog.musnow.top/categories/%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0/Linux/"/>
    
    
    <category term="虚拟机" scheme="https://blog.musnow.top/tags/%E8%99%9A%E6%8B%9F%E6%9C%BA/"/>
    
    <category term="wsl" scheme="https://blog.musnow.top/tags/wsl/"/>
    
  </entry>
  
  <entry>
    <title>【sqlite3】MySQL8转sqlite3需要对sql做的一些处理</title>
    <link href="https://blog.musnow.top/posts/2778694447/"/>
    <id>https://blog.musnow.top/posts/2778694447/</id>
    <published>2024-02-06T03:19:37.000Z</published>
    <updated>2024-02-06T04:07:58.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="问题来源"><a href="#问题来源" class="headerlink" title="问题来源"></a>问题来源</h1><p>最近编写我的kook机器人的时候，发现MySQL对于这种低访问频次的应用并不友好，经常出现断连的问题，具体到python中的报错如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pymysql.err.InterfaceError: (0, &#x27;&#x27;)</span><br></pre></td></tr></table></figure><p>出现这种报错，就可以认为是MySQL那端因为自身策略中断了和你的应用的链接。因为我的机器人和MySQL是在同一台主机上，肯定不是网络本身问题导致的。</p><p>所以我需要将MySQL数据库换成sqlite3数据库。</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/02/701727d98b31f035e72bef4e76b341a1.png"></p><h1 id="MySQL转sqlite3"><a href="#MySQL转sqlite3" class="headerlink" title="MySQL转sqlite3"></a>MySQL转sqlite3</h1><h2 id="导出MySQL中的数据"><a href="#导出MySQL中的数据" class="headerlink" title="导出MySQL中的数据"></a>导出MySQL中的数据</h2><p>好在我的机器人使用的是python的peewee这个ORM库，只需要修改底层的DB引擎就能快速在MySQL和sqlite3之间切换。我们要解决的只是怎么把MySQL8.0.30的数据导入到sqlite3中。</p><blockquote><p>本文测试使用的版本为：<code>MySQL 8.0.30</code> 和 <code>sqlite3 3.44.0</code></p></blockquote><p>首先是从MySQL将数据库里面的所有数据导出为sql文件，因为我安装了1panel服务器面板，所以可以直接使用面板的备份功能，再把备份好的tar下载下来（里面就是sql文件）</p><p>这里给出用命令行来处理的方式，一般使用的工具为mysqldump，在安装MySQL的时候这个工具应该就会连带安装。我的MySQL是用docker安装的，docker容器内的终端也有这个命令工具。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[root@RainYun-8aNbbsmA:~/docker]# docker exec -it mysql /bin/bash</span><br><span class="line">bash-4.4# mysqldump</span><br><span class="line">Usage: mysqldump [OPTIONS] database [tables]</span><br><span class="line">OR     mysqldump [OPTIONS] --databases [OPTIONS] DB1 [DB2 DB3...]</span><br><span class="line">OR     mysqldump [OPTIONS] --all-databases [OPTIONS]</span><br><span class="line">For more options, use mysqldump --help</span><br><span class="line">bash-4.4# </span><br></pre></td></tr></table></figure><p>导出整个数据库的数据到sql的命令如下</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysqldump -u username -ppassword dbname &gt; dbname.sql；</span><br></pre></td></tr></table></figure><p>比如我有个testdb数据库，将其导入testdb.sql的命令如下，这里我直接使用了root用户来处理。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysqldump -uroot -p123456 testdb &gt; testdb.sql</span><br></pre></td></tr></table></figure><p>因为在命令行使用密码被认为是不安全的，所以键入如上命令的时候会有一个警告，可以忽略它。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysqldump: [Warning] Using a password on the command line interface can be insecure.</span><br></pre></td></tr></table></figure><p>ls查看一下，当前路径上已经有我们需要的sql数据文件了。</p><h2 id="docker内文件拷贝到宿主机"><a href="#docker内文件拷贝到宿主机" class="headerlink" title="docker内文件拷贝到宿主机"></a>docker内文件拷贝到宿主机</h2><p>因为我现在的这个操作是在一个docker容器里面，我还需要将其从docker中拷贝出来，方法有两个</p><ol><li>将sql文件拷贝到docker的持久化目录中（即映射到了宿主机的目录中）；</li><li>使用docker copy命令；</li></ol><p>对于1panel安装的MySQL容器而言，你可以在容器的详细设置里面看到映射路径的关系。</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/02/83b63cefa278acce4ddaf80fcbe5fe56.png" alt="image.png"></p><p>如果使用docker cp命令，格式如下</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker <span class="built_in">cp</span> 容器ID:容器内路径 宿主机路径</span><br></pre></td></tr></table></figure><p>这里的容器ID可以是容器的名字，也可以是docker ps命令查看到的容器<code>CONTAINER ID</code>；mysqldump命令弄出来的sql文件是在容器内的根目录上。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># docker cp mysql:/testdb.sql ~/testdb.sql</span></span><br><span class="line">Successfully copied 9.85MB to /root/testdb.sql</span><br></pre></td></tr></table></figure><h2 id="修改sql文件"><a href="#修改sql文件" class="headerlink" title="修改sql文件"></a>修改sql文件</h2><p>MySQL导出的sql文件不能直接被sqlite3识别，在我的机器人数据库中遇到如下几个问题，需要修改sql文件。</p><ul><li>用peewee创建sqlite数据库时生成的create table语句替换MySQL导出的sql文件内部已有的建表语句；</li><li>删除sql文件中的<code>LOCK TABLES </code>和<code>UNLOCK TABLES;</code>，因为sqlite不支持；</li><li>sql文件中的转义字符<code>\&quot;</code>替换成<code>&quot;</code>。因为在sqlite3中不需要进行此转义。如果不修改，那么在sqlite3中list的json字符串中就会留有<code>\&quot;</code>导致无法被<code>json.loads</code>（猜测sqlite3中<code>&#39;</code>的优先级高于<code>&quot;</code>）</li></ul><p>首先是把python中peewee使用的数据库模型改成sqlite，然后启动一下这个机器人，此时peewee就会创建一个db文件。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sqlite3 数据库文件名.db</span><br></pre></td></tr></table></figure><p>进入该db文件后执行如下查询命令，能看到sqlite3的建表语句，将其替换掉MySQL中导出sql里面的建表命令。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT sql FROM sqlite_master WHERE type=&#x27;table&#x27;;</span><br></pre></td></tr></table></figure><p>如果你用的不是peewee这种ORM库，则还需要自行修改建表命令为sqlite3的命令（可以问问gpt让他帮你改一下，或者自己重写一个）。比如在sqlite3中就不支持表后跟随的<code>AUTO_INCREMENT=4728</code>语句。</p><h2 id="文件导入到sqlite3"><a href="#文件导入到sqlite3" class="headerlink" title="文件导入到sqlite3"></a>文件导入到sqlite3</h2><p>sqlite3的导入命令格式如下，左侧是数据库文件名字，右侧是需要导入的源sql文件。为了避免文件名编码问题，建议使用全英文名字。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sqlite3 数据库名字.db &lt; 需要导入的文件.sql</span><br></pre></td></tr></table></figure><p>这个命令成功的时候不会有任何输出，使用如下命令进入导入后生成的db文件中</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sqlite3 数据库名字.db</span><br></pre></td></tr></table></figure><p>不出意外的话，所有数据就已经导入到这个新的数据库文件中了，检查一下和MySQL中的数据库有没有不一样的地方吧！</p><h1 id="The-end"><a href="#The-end" class="headerlink" title="The end"></a>The end</h1><p>有更多问题，欢迎评论留言讨论。</p>]]></content>
    
    
    <summary type="html">MySQL8转sqlite3需要对sql做的一些处理</summary>
    
    
    
    <category term="编程学习" scheme="https://blog.musnow.top/categories/%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="数据库SQL" scheme="https://blog.musnow.top/categories/%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0/%E6%95%B0%E6%8D%AE%E5%BA%93SQL/"/>
    
    
    <category term="mysql" scheme="https://blog.musnow.top/tags/mysql/"/>
    
    <category term="sqlite3" scheme="https://blog.musnow.top/tags/sqlite3/"/>
    
  </entry>
  
</feed>
