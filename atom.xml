<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>慕雪的寒舍</title>
  
  <subtitle>雪下了一夜</subtitle>
  <link href="https://blog.musnow.top/atom.xml" rel="self"/>
  
  <link href="https://blog.musnow.top/"/>
  <updated>2023-12-13T13:29:02.000Z</updated>
  <id>https://blog.musnow.top/</id>
  
  <author>
    <name>慕雪年华</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>【docker】部署minio对象存储并用rclone同步</title>
    <link href="https://blog.musnow.top/posts/1950951389/"/>
    <id>https://blog.musnow.top/posts/1950951389/</id>
    <published>2023-12-13T13:29:02.000Z</published>
    <updated>2023-12-13T13:29:02.000Z</updated>
    
    <content type="html"><![CDATA[<p>docker部署minio对象存储并用rclone同步</p><h1 id="1-什么是minio？"><a href="#1-什么是minio？" class="headerlink" title="1.什么是minio？"></a>1.什么是minio？</h1><p>minio是一个开源的对象存储服务器，兼容S3协议。</p><p>官网：<a href="https://min.io/">https://min.io/</a></p><p>官方在开源的基础上也提供云端S3服务，分为个人和企业，有不同的收费标准。</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2023/12/3dbb54877957d5ede7354a3401dd4cf0.png" alt="5ae0c978272b7ca6732817920adae0f5.png"></p><h2 id="1-1-自建对象存储的好处？"><a href="#1-1-自建对象存储的好处？" class="headerlink" title="1.1 自建对象存储的好处？"></a>1.1 自建对象存储的好处？</h2><p>当然，本文写下来肯定不是让你去买它的对象存储服务的，而是在我们自己的服务器&#x2F;Nas上部署一个minio的docker，来拥有一个我们自己的对象存储服务器！</p><p>对象存储服务器可以用来做图床、静态资源缓存，亦或者是直接当作一个网盘来使用。</p><p>自建的对象存储的好处是所有源文件我们都能亲手管理，且无需为付费的对象存储的奇怪的计价文档感到手足无措，也不需要担心有人恶意刷流把你一套房子给套走。</p><p>缺点就是，自建的稳定性肯定不如已有厂家提供的服务，且自购的服务器&#x2F;Nas上传带宽一般都很低，文件一多，访问速度就很慢了。</p><p>对于我个人而言，自建minio的唯一作用，就是备份七牛云&#x2F;阿里云对象存储中的文件。考虑到2023下半年，各大厂接连boom云服务，国外的谷歌还出现了云盘里面用户的数据回滚到几月前的恶性问题，这可是可能导致用户数据丢失的大问题啊！</p><ul><li><a href="https://www.ithome.com/0/737/538.htm">谷歌公布方案，修复 Drive 云盘文件丢失问题</a></li><li><a href="https://news.zol.com.cn/845/8455073.html">谷歌承认云端硬盘Google Drive存BUG 3月内用户文件可能丢失</a></li></ul><p>所以，将数据在自己本地留一份总是安心一些。数据安全靠的是备份，不是云服务厂家给你提供的<code>99.99999%</code>可用性的一面之词。</p><p>如果你对数据备份这个话题感兴趣，可以看看我的另外一篇博客：<a href="https://blog.musnow.top/posts/3543423459/?f=minio">谈谈如何进行有效数据备份，3+2+1</a></p><blockquote><p>温馨提醒：如果你想在<strong>云服务器</strong>上安装minio来备份已有S3中的文件的话，最好是使用一个和已有S3<strong>不在同一个地域、非同一个服务商</strong>的云服务器，避免某些服务商云服务器和对象存储一起boom的情况……</p></blockquote><h1 id="2-docker安装minio"><a href="#2-docker安装minio" class="headerlink" title="2.docker安装minio"></a>2.docker安装minio</h1><h2 id="2-1-安装docker"><a href="#2-1-安装docker" class="headerlink" title="2.1 安装docker"></a>2.1 安装docker</h2><p>docker安装的教程详见我的另外一篇博客</p><p><a href="https://blog.musnow.top/posts/2069190154/?f=minio">【Docker】deepin&#x2F;centos安装docker | 慕雪的寒舍</a></p><h2 id="2-2-安装minio"><a href="#2-2-安装minio" class="headerlink" title="2.2 安装minio"></a>2.2 安装minio</h2><p>这里推荐使用由VMware维护的minio docker版本<code>bitnami/minio</code>，更新很频繁。</p><p><a href="https://hub.docker.com/r/bitnami/minio">hub.docker.com&#x2F;r&#x2F;bitnami&#x2F;minio</a></p><p>创建容器的命令如下，非常简单</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">docker run -it -d --name minio \</span><br><span class="line">-p 9000:9000 \</span><br><span class="line">-p 9001:9001 \</span><br><span class="line">--restart=always \</span><br><span class="line">-v /minio/data:/bitnami/minio/data \</span><br><span class="line">-e MINIO_ROOT_USER=<span class="string">&quot;minio_root&quot;</span> \</span><br><span class="line">-e MINIO_ROOT_PASSWORD=<span class="string">&quot;minio_123456&quot;</span> \</span><br><span class="line">bitnami/minio:latest</span><br></pre></td></tr></table></figure><p>该创建容器操作基于如下hash的docker镜像（更新于2023-12-12），创建容器的命令后续可能会有变动，请参考docker-hub中的官方文档</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bitnami/minio  latest    552af9bd3d6d   2 days ago     212MB</span><br></pre></td></tr></table></figure><p>对这个docker命令进行解释</p><ul><li><code>-it -d</code>，it提供交互能力，d代表后台运行</li><li><code>--restart=always</code>，始终重启docker（docker服务重启后，镜像会自动启动）</li><li><code>-p 9000:9000</code>，将docker内的9000端口（右侧）映射给宿主机（左侧）的9000端口，端口9001的映射同理。<ul><li>容器内9000端口是minio的api端口（用于S3协议操作）</li><li>容器内9001端口是minio的web管理界面端口</li><li>根据你的需要，修改<strong>冒号左侧</strong>的宿主机端口即可。</li></ul></li><li><code>-v /minio/data:/data</code>，将docker内<code>/data</code>路径映射给主机<code>/minio/data</code>路径，主机上的路径（左侧）请自行修改</li><li>两个<code>-e</code>设置的是环境变量，分别设置的是minio管理员的账户和管理员的密码，请注意，在这里配置了用户名和密码后，<strong>进入minio管理系统的密码无法被修改</strong>。如果你的minio服务需要暴露在公网上，请一定要设置一个高强度的密码！</li><li>最后的<code>bitnami/minio:latest</code>代表我们需要创建<code>bitnami/minio</code>docker的latest版本，如果本地没有这个镜像，则会自动去dockerhub拉取。</li></ul><blockquote><p>顺带一提，在我这边测试发现，如果你错误使用浏览器访问了9000这个api端口，会被自动重定向到9001web管理端口（前提是映射的宿主机端口和docker内端口一致）</p></blockquote><p>如下是我在一个没有安装过minio的云服务上测试的结果，成功安装并启动minio</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">[root:~/docker]# docker run -it -d --name minio \</span><br><span class="line">&gt; -p 19000:9000 \</span><br><span class="line">&gt; -p 19001:9001 \</span><br><span class="line">&gt; --restart=always \</span><br><span class="line">&gt; -v /root/docker/minio:/bitnami/minio/data \</span><br><span class="line">&gt; -e MINIO_ROOT_USER=&quot;minio_root&quot; \</span><br><span class="line">&gt; -e MINIO_ROOT_PASSWORD=&quot;minio_123456&quot; \</span><br><span class="line">&gt; bitnami/minio:latest</span><br><span class="line">Unable to find image &#x27;bitnami/minio:latest&#x27; locally</span><br><span class="line">latest: Pulling from bitnami/minio</span><br><span class="line">ef5975039511: Pull complete </span><br><span class="line">Digest: sha256:3bb81d101dea57a5382a2d01eda6991e75ce69669d2d49c4646d82721b7c258e</span><br><span class="line">Status: Downloaded newer image for bitnami/minio:latest</span><br><span class="line">afefbb9514de0f4a1c02b7f4212b1e05eee5ef342ed4ce27e03de10071914060</span><br></pre></td></tr></table></figure><p>容器正常启动，处于Running状态，STATUS正常！</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">CONTAINER ID   IMAGE                                  COMMAND                  CREATED         STATUS         PORTS                                                                                      NAMES</span><br><span class="line">afefbb9514de   bitnami/minio:latest                   &quot;/opt/bitnami/script…&quot;   3 minutes ago   Up 3 minutes   0.0.0.0:19000-&gt;9000/tcp, :::19000-&gt;9000/tcp, 0.0.0.0:19001-&gt;9001/tcp, :::19001-&gt;9001/tcp   minio</span><br></pre></td></tr></table></figure><p>如果你卡在了pull镜像的步骤，请自行百度如何<a href="https://blog.musnow.top/posts/2069190154/?f=minio">替换docker的镜像源</a>。</p><h2 id="2-3-web管理"><a href="#2-3-web管理" class="headerlink" title="2.3 web管理"></a>2.3 web管理</h2><p>使用 <code>http://IP:端口</code> 打开minio的9001端口对应的宿主机端口，访问minio的web管理页面。输入刚刚创建容器时，在环境变量里面配置的用户名和密码进行登录，即可进入控制台。</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2023/12/8ab832241e5ea9a14713e75fb56c2df0.png" alt="image.png"></p><p>minio的界面比较简单，基本要做的操作只有两个，创建bucket存储桶，和accesskey用于api调用。</p><blockquote><p>更高阶的配置项和操作我没有尝试过，请自行参考minio的文档或者其他教程。</p></blockquote><h3 id="2-3-1-创建bucket"><a href="#2-3-1-创建bucket" class="headerlink" title="2.3.1 创建bucket"></a>2.3.1 创建bucket</h3><p>第一个界面就是大大的bucket存储桶，在这里我们可以创建对应的存储桶</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2023/12/df27f17b80655b3107ef12018f180712.png" alt="image.png"></p><p>点击创建bucket，会进入如下配置项，除了bucket的名字，还有三个选项</p><ul><li>Versioning：版本控制，开启后，该bucket将处于多版本模式下，文件会保留修改的历史记录。</li><li>Object Locking：避免文件被删除，需要支持保留和合法保留（这两个啥意思我不明白），该选项只能在bucket创建时打开。</li><li>Quota：限制容器中文件大小（总容量）</li></ul><p>对于我的备份需求来说，这三个额外选项都不需要，直接创建就行了</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2023/12/c7b5efc573e9e3691f0237a6e9d7357a.png" alt="image.png"></p><p>创建之后，在bucket页面可以看到刚刚创建的test存储桶，这里会统计存储容量和文件数量</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2023/12/01016c16a27570ded8d93a7aa4781a1f.png" alt="image-20231213232421462"></p><h3 id="2-3-2-创建accessKey"><a href="#2-3-2-创建accessKey" class="headerlink" title="2.3.2 创建accessKey"></a>2.3.2 创建accessKey</h3><p>accessKey是用于操作api的token凭证。创建完毕后，他只会显示一次，后续将不会显示出来。</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2023/12/7413b4978a8916f3ba34043afa034e7f.png" alt="image.png"></p><p>如果你不想创建太多个密钥，那就把这个密钥的文件下载下来，免得到时候不知道是什么了。点击右下角的import文件就可以下载，会下载一个<code>json</code>文件，内部包含密钥和其他一些相关信息</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2023/12/c06b9cd5866f9b3d9a2f37e0ded15404.png" alt="image.png"></p><p>因为我这只是做个测试，一会就会把这个minio的docker删除，所以展示密钥无所谓。如果你是在生产环境下使用，请一定不要暴露你的密钥给任何人。</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;url&quot;</span><span class="punctuation">:</span> <span class="string">&quot;http://公网IP:19001/api/v1/service-account-credentials&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;accessKey&quot;</span><span class="punctuation">:</span> <span class="string">&quot;aXpBxrUceV30Id6gOouG&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;secretKey&quot;</span><span class="punctuation">:</span> <span class="string">&quot;dIWl9IFL05UtaI08PZfPXE66zPGu2zWrGFfSTaUm&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;api&quot;</span><span class="punctuation">:</span> <span class="string">&quot;s3v4&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;path&quot;</span><span class="punctuation">:</span> <span class="string">&quot;auto&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>密钥创建完毕，就能在列表看到它。</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2023/12/d70adb75c6ec74a362a065e9afc88092.png" alt="image.png"></p><h1 id="3-rclone备份"><a href="#3-rclone备份" class="headerlink" title="3.rclone备份"></a>3.rclone备份</h1><p>rclone是一个全平台的命令行工具，其可以用于多种云端&#x2F;本地存储之间的数据拷贝、同步、加密同步等功能。详见rclone官网：<a href="https://rclone.org/">rclone.org</a></p><p>因为我的目标就是我的七牛云bucket里面的图床文件备份到本地，rclone绝对是不二之选。</p><h2 id="3-1-进入docker容器内终端"><a href="#3-1-进入docker容器内终端" class="headerlink" title="3.1 进入docker容器内终端"></a>3.1 进入docker容器内终端</h2><p>你可以选择在<strong>宿主机</strong>上安装rclone，也可以选择直接在minio的容器内安装rclone。但是需要注意，如果在minio的容器内安装，那么minio容器被删除后，rclone和它的配置文件自然也不在了。</p><p>参考：<a href="https://www.cnblogs.com/langgeligelang/p/13628821.html">以指定用户启动和进入docker容器 - langyong - 博客园</a> ，使用ssh链接宿主机，然后使用如下docker命令进入minio的容器终端中。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker <span class="built_in">exec</span> -it -u 用户名 容器名 /bin/bash</span><br><span class="line"><span class="comment"># 示例如下</span></span><br><span class="line">docker <span class="built_in">exec</span> -it -u root minio /bin/bash</span><br></pre></td></tr></table></figure><p>如果你使用的是绿联、极空间这类不太方便进入ssh的nas，可以在nas的docker管理页里面操作，如下图所示，选择<code>/bin/bash</code>后点击链接即可进入容器内终端。</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/20231214091932.png" alt="image.png"></p><h2 id="3-2-下载安装rclone"><a href="#3-2-下载安装rclone" class="headerlink" title="3.2 下载安装rclone"></a>3.2 下载安装rclone</h2><p>进入终端后，默认所在路径是docker容器的工作路径<code>/opt/bitnami/minio-client</code>。</p><p>为了避免影响容器运行，我们不要在工作路径里面做操作，请使用如下命令，创建一个新的rclone文件夹，进入root用户的家目录进行操作。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mkdir /root/rclone</span><br><span class="line">cd /root/rclone</span><br></pre></td></tr></table></figure><blockquote><p>你可以在创建minio容器的时候，就把<code>/root/rclone</code>路径给映射到宿主机上，方便后续查看rclone备份的日志。</p></blockquote><p>下载安装rclone的命令如下</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">curl -O https://downloads.rclone.org/rclone-current-linux-amd64.zip</span><br><span class="line">unzip rclone-current-linux-amd64.zip</span><br><span class="line"><span class="built_in">cd</span> rclone-*-linux-amd64</span><br><span class="line"> </span><br><span class="line">sudo <span class="built_in">cp</span> rclone /usr/bin/</span><br><span class="line">sudo <span class="built_in">chown</span> root:root /usr/bin/rclone</span><br><span class="line">sudo <span class="built_in">chmod</span> 755 /usr/bin/rclone</span><br></pre></td></tr></table></figure><p>minio的docker内没有unzip命令，需要安装一下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apt-get update &amp;&amp; apt-get install unzip</span><br></pre></td></tr></table></figure><p>minio的docker内也没有sudo，将上述安装命令中的sudo去掉就可以了。</p><p>完成安装命令后，执行一下<code>rclone</code>，出现rclone命令的使用提示，那就是安装成功了！</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">root@878a0dd03ec4:/root/rclone/rclone-v1.65.0-linux-amd64# rclone</span><br><span class="line">Usage:</span><br><span class="line">  rclone [flags]</span><br><span class="line">  rclone [command]</span><br><span class="line">  ...</span><br></pre></td></tr></table></figure><h2 id="3-3-rclone对象存储配置"><a href="#3-3-rclone对象存储配置" class="headerlink" title="3.3 rclone对象存储配置"></a>3.3 rclone对象存储配置</h2><p>rclone的官网上有不同云端存储协议和不同S3服务商的配置教程，跟着官方的来就可以了。</p><p>执行<code>rclone config</code>命令，工具会自动在<code>/.config/rclone/rclone.conf</code>下创建一个config文件，你可以根据<a href="https://rclone.org/">官方的向导</a>，在此处添加新的remote</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">root@878a0dd03ec4:/root/rclone/rclone-v1.65.0-linux-amd64# rclone config</span><br><span class="line">2023/12/14 04:38:44 NOTICE: Config file &quot;/.config/rclone/rclone.conf&quot; not found - using defaults</span><br><span class="line">No remotes found, make a new one?</span><br><span class="line">n) New remote</span><br><span class="line">s) Set configuration password</span><br><span class="line">q) Quit config</span><br><span class="line">n/s/q&gt; q</span><br></pre></td></tr></table></figure><p>下面给出minio和七牛云的配置文件，你可以直接修改这个配置文件中的内容为你的配置，然后写入<code>/.config/rclone/rclone.conf</code>即可。</p><ul><li><a href="https://rclone.org/s3/#minio">rclone.org&#x2F;s3&#x2F;#minio</a></li><li><a href="https://rclone.org/s3/#qiniu">rclone.org&#x2F;s3&#x2F;#qiniu</a></li></ul><p>其中minio的region在minio的控制台里面可以修改，如果你没有修改过，默认使用的是<code>us-east-1</code>。因为rclone是直接在minio的docker里面执行的，所以endpoint只需要写成<code>127.0.0.1</code>和minio的api端口9000就可以了。</p><p>如果你的minio在公网或者其他设备上，请修改对应的IP地址和端口。</p><p>七牛云的region和endpoint在<strong>七牛云bucket页面</strong>找到<strong>S3域名</strong>就可以看到。</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2023/12/64d88c8052b653bb69edbed3d75fdca5.png" alt="image.png"></p><blockquote><p>请注意，七牛云&#x2F;阿里云这类存储服务商，如果你有多个bucket，且他们的地域不一样，则需要新增对应地域的配置项。通过修改<code>[]</code>里面的<strong>配置名</strong>进行区分。</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">[minio]</span><br><span class="line">type = s3</span><br><span class="line">provider = Minio</span><br><span class="line">env_auth = false</span><br><span class="line">access_key_id = 控制台获取的key_id</span><br><span class="line">secret_access_key = 控制台获取的secret_key</span><br><span class="line">region = us-east-1</span><br><span class="line">endpoint = http://127.0.0.1:9000</span><br><span class="line">location_constraint =</span><br><span class="line">server_side_encryption =</span><br><span class="line"></span><br><span class="line">[qiniu]</span><br><span class="line">type = s3</span><br><span class="line">provider = Qiniu</span><br><span class="line">access_key_id = 七牛云控制台获取key_id</span><br><span class="line">secret_access_key = 七牛云控制台获取secret_key</span><br><span class="line">region = cn-east-1</span><br><span class="line">endpoint = s3-cn-east-1.qiniucs.com</span><br><span class="line">location_constraint = cn-east-1</span><br><span class="line">acl = private</span><br><span class="line">storage_class = STANDARD</span><br></pre></td></tr></table></figure><p>执行如下命令，安装nano编辑器，然后使用nano编辑器打开rclone配置文件进行编辑。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">apt-get update &amp;&amp; apt-get install -y nano</span><br><span class="line">nano /.config/rclone/rclone.conf</span><br></pre></td></tr></table></figure><p>linux下的粘贴命令是<code>CTRL+SHIFT+V</code>或<code>CTRL+INSERT</code>，你可以在本地修改了配置文件后，通过nano编辑器，直接粘贴到docker容器内。编辑完毕后，使用<code>CTRL+X</code>退出nano的编辑模式，并按Y确认保存，随后直接回车，即完成编辑。</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2023/12/f82a30d9349cb55e60bc621dc2264be3.png" alt="image.png"></p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2023/12/283ab6851395ecf722d287aa06a8de0b.png" alt="image.png"></p><h2 id="3-4-rclone基本命令"><a href="#3-4-rclone基本命令" class="headerlink" title="3.4 rclone基本命令"></a>3.4 rclone基本命令</h2><h3 id="copy"><a href="#copy" class="headerlink" title="copy"></a>copy</h3><p>拷贝命令如下，配置名称是在config文件中<code>[]</code>里面的文字，桶名就是你的S3服务里面的对象存储桶，还可以在桶名后面用<code>/</code>来追加指定上传的路径。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">rclone copy 本地文件路径 配置名称:桶名</span><br><span class="line">rclone copy 本地文件路径 配置名称:桶名/桶内目录</span><br></pre></td></tr></table></figure><p>这里我在docker内创建了一个<code>test.txt</code>文件，尝试将其拷贝到minio里面。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">touch test.txt</span><br><span class="line">rclone copy ./test.txt minio:1panel-bak</span><br></pre></td></tr></table></figure><p>命令没有错误输出，即拷贝成功！</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">root@878a0dd03ec4:/root/rclone# touch test.txt</span><br><span class="line">root@878a0dd03ec4:/root/rclone# rclone copy ./test.txt minio:1panel-bak</span><br><span class="line">root@878a0dd03ec4:/root/rclone# </span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2023/12/bcd922882c21dbe6aa3e8aeb67fe08fa.png" alt="image.png"></p><p>尝试在拷贝的时候指定远端仓库内的路径</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rclone copy ./test.txt minio:qiniu-muxue-sy/test</span><br></pre></td></tr></table></figure><p>成功指定，文件被上传到了test文件夹里面。</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/20231214133906.png" alt="image.png"></p><h3 id="sync"><a href="#sync" class="headerlink" title="sync"></a>sync</h3><p>备份命令如下，可以在任意目的地（本地-远端，远端-本地，远端-远端）里面执行这个命令，左侧是源路径，右侧是目标。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">rclone sync 本地源文件路径  目的地配置名称:桶名 </span><br><span class="line">rclone sync 源配置名称:桶名 目的地配置名称:桶名</span><br><span class="line">rclone sync 源配置名称:桶名 目的地的本地文件路径</span><br></pre></td></tr></table></figure><p>rclone sync有两个常用的选项，刚开始使用的时候，建议带上 <code>--dry-run</code> 命令来确认自己的配置没有问题</p><ul><li><code>-P</code> 显示详细同步进度条</li><li><code>--dry-run</code> 用作命令测试，不会真正的执行同步</li></ul><p>指定<code>-P</code>命令后的进度输出如下，可以看到实时网速和文件数量&#x2F;大小。</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/20231214133932.png" alt="image.png"></p><p>目前发现的问题是minio显示的文件总量和数据存储量会有一定滞后，刚开始我还以为是rclone没有跑完呢，sync完毕过了几分钟minio里面才刷出正确的文件数量来。</p><h2 id="3-5-cron定时同步"><a href="#3-5-cron定时同步" class="headerlink" title="3.5 cron定时同步"></a>3.5 cron定时同步</h2><p>部分nas品牌的系统（比如群晖）已经提供了执行定时脚本的功能，这种情况下直接使用系统提供的定时任务来执行<code>rclone sync</code>即可，无需额外安装其。</p><ul><li>群晖官网关于定时任务的说明： <a href="https://kb.synology.cn/zh-cn/DSM/help/DSM/AdminCenter/system_taskscheduler?version=6">https://kb.synology.cn/zh-cn/DSM/help/DSM/AdminCenter/system_taskscheduler?version=6</a></li><li>绿联nas的环境中已有crontab，但我没有试过使用它。考虑到绿联这个nas的系统还是一点都不稳定，还是别动它的系统里面的东西了，不知道绿联官方有没有可能把定时任务加到控制页里面去吧（我估计是没戏，这个系统的限制太多了）。</li></ul><p>在minio的docker里面直接安装crontab服务和nano文本编辑器</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">apt-get update</span><br><span class="line">apt-get install -y cron nano</span><br></pre></td></tr></table></figure><p>安装完毕后，使用<code>crontab -e</code>看看是否能打开crontab的配置编辑页面，如果可以打开如下配置界面，则代表cron安装成功。</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/20231214111457.png" alt="image.png"></p><p>这个配置文件需要写入的格式如下，一行对应一个配置。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">五位cron表达式 需要执行的命令</span><br></pre></td></tr></table></figure><p>cron表达式可以百度搜一下，因为很少用，我也不太了解cron表达式的编写逻辑。</p><p>对于rclone的sync备份而言，写入如下内容即可；</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">0 3 * * 1,5 rclone sync qiniu-e1:muxue-sy  minio:qiniu-muxue-sy &gt;&gt; /root/rclone/rclone-sy.log 2&gt;&amp;1</span><br><span class="line">0 2 * * 1,5 rclone sync qiniu-e2:muxue-img  minio:qiniu-muxue-img &gt;&gt; /root/rclone/rclone-img.log 2&gt;&amp;1</span><br></pre></td></tr></table></figure><p>解析如下</p><ul><li><code>0 3 * * 1,5</code> 代表每周一和周五的凌晨3点执行一次</li><li><code>0 2 * * 1,5</code> 代表每周一和周五的凌晨2点执行一次</li><li><code>&gt;&gt; /root/rclone/rclone-img.log 2&gt;&amp;1</code> 代表将rclone命令的输出结果写入到 <code>/root/rclone/rclone-img.log</code> 文件中。</li></ul><p>写入完毕后，<code>CTRL+X</code>关闭nano编辑模式，按Y和回车即完成nano编辑。编辑完成后会有如下输出。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">root@878a0dd03ec4:/root/rclone# crontab -e</span><br><span class="line">no crontab for root - using an empty one</span><br><span class="line">crontab: installing new crontab</span><br></pre></td></tr></table></figure><p>后续crontab执行的命令结果都会输入到这两个指定的日志文件中。rclone命令只有在出现ERROR的时候才会输出。如果这个文件里面什么都么有，就代表运行没有出错！</p><blockquote><p>请注意，minio的docker中时区是UTC标准时间，所以你定义的cron表达式的执行时间可能和东八区时间不一致。</p></blockquote><p>配置好了之后，使用如下命令启动cron服务</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">service cron start</span><br></pre></td></tr></table></figure><p>执行效果如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">root@878a0dd03ec4:/root/rclone# service cron start</span><br><span class="line">Starting periodic command scheduler: cron.</span><br></pre></td></tr></table></figure><p>可以用如下命令查看cron服务状态</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">root@878a0dd03ec4:/root/rclone# service cron status</span><br><span class="line">cron is running.</span><br></pre></td></tr></table></figure><h3 id="优化日志"><a href="#优化日志" class="headerlink" title="优化日志"></a>优化日志</h3><p>为了让日志更加合理，可以在执行rclone命令之前，打印当前时间，这样可以知道crontab到底有没有正常执行定时任务。</p><p>打印时间的基本命令如下，echo命令会将当前时间和相关的说明信息写入<code>log.txt</code>文件中</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo &quot;$(date &#x27;+%Y-%m-%d %H:%M:%S&#x27;) This is a test command&quot; &gt;&gt; log.txt</span><br></pre></td></tr></table></figure><p>执行效果如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">root@878a0dd03ec4:/root/rclone# echo &quot;$(date &#x27;+%Y-%m-%d %H:%M:%S&#x27;) This is a test command&quot; &gt;&gt; log.txt</span><br><span class="line">root@878a0dd03ec4:/root/rclone# cat log.txt</span><br><span class="line">2023-12-14 03:44:32 This is a test command</span><br></pre></td></tr></table></figure><p>这里有另外一个问题，即docker内部的时区使用的是UTC标准时区，而不是东八区。为了避免影响minio容器的执行，建议不要直接修改docker内系统时区，而是采用临时修改环境变量的方式打印东八区的时间。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo &quot;$(TZ=&#x27;Asia/Shanghai&#x27; date &#x27;+%Y-%m-%d %H:%M:%S&#x27;) 这是东八区&quot; &gt;&gt; log.txt</span><br></pre></td></tr></table></figure><p>执行效果如下，命令直接粘贴到命令行里面，<strong>中文出现了乱码</strong>，不过文件里面的时间和中文都是正常的；这里只是做一个演示，实际执行的时候，建议使用<strong>全英文</strong>的echo输出，避免像这样的乱码问题。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">root@878a0dd03ec4:/root/rclone# echo &quot;$(TZ=&#x27;Asia/Shanghai&#x27; date &#x27;+%Y-%m-%d %H:%M:%S&#x27;) \350\277\231\346\23</span><br><span class="line">0\257\344\270\234\345\205\253\345\214\272&quot; &gt;&gt; log.txt</span><br><span class="line">root@878a0dd03ec4:/root/rclone# cat log.txt</span><br><span class="line">2023-12-14 11:45:31 这是东八区</span><br></pre></td></tr></table></figure><p>将如上的crontab命令改成如下形式，使用<code>&amp;&amp;</code>来链接echo和rclone命令，这样在每次执行rclone之前都会有一个当前时间和sync的是什么内容的的输出，能让我们知道crontab是否正常执行。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">0 3 * * 1,5 echo &quot;$(TZ=&#x27;Asia/Shanghai&#x27; date &#x27;+%Y-%m-%d %H:%M:%S&#x27;) sync muxue-sy&quot; &gt;&gt; /root/rclone/rclone.log &amp;&amp; rclone sync qiniu-e1:muxue-sy  minio:qiniu-muxue-sy &gt;&gt; /root/rclone/rclone.log 2&gt;&amp;1</span><br><span class="line"></span><br><span class="line">0 2 * * 1,5 echo &quot;$(TZ=&#x27;Asia/Shanghai&#x27; date &#x27;+%Y-%m-%d %H:%M:%S&#x27;) sync muxue-img&quot; &gt;&gt; /root/rclone/rclone.log &amp;&amp; rclone sync qiniu-e2:muxue-img  minio:qiniu-muxue-img &gt;&gt; /root/rclone/rclone.log 2&gt;&amp;1</span><br></pre></td></tr></table></figure><p>你可以修改cron表达式的前2位（对应的是分钟和小时），以及第五位的星期几，让crontab表达式立即执行一次，确认一下输出是否正确。</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2023/12/58a95be05439f6186ce18aa17596d417.png" alt="image.png"></p><p>每次修改配置文件后，都需要重启cron服务！</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">service cron restart</span><br></pre></td></tr></table></figure><h1 id="The-end"><a href="#The-end" class="headerlink" title="The end"></a>The end</h1><p>本文的教程结束，有问题欢迎在评论区提出。</p><p>数据无价，多一份备份，多一份安心</p>]]></content>
    
    
    <summary type="html">docker部署minio对象存储并用rclone同步</summary>
    
    
    
    <category term="docker真好玩" scheme="https://blog.musnow.top/categories/docker%E7%9C%9F%E5%A5%BD%E7%8E%A9/"/>
    
    
    <category term="docker" scheme="https://blog.musnow.top/tags/docker/"/>
    
  </entry>
  
  <entry>
    <title>【MySQL】wsl的ubuntu中无法systemctl启动mariadb（已解决）</title>
    <link href="https://blog.musnow.top/posts/1382619221/"/>
    <id>https://blog.musnow.top/posts/1382619221/</id>
    <published>2023-12-13T09:52:14.000Z</published>
    <updated>2023-12-13T09:52:14.000Z</updated>
    
    <content type="html"><![CDATA[<p>这是GPT的答案，实测有效。</p><p>如果您在启动 MariaDB 时遇到 <code>&quot;Failed to start mariadb.service: Interactive authentication required&quot; </code>错误，这是因为在 Ubuntu 22.04 上默认启用了 systemd 的用户会话限制，需要进行一些额外的步骤来解决该问题。以下是解决方法：</p><p>打开终端，并使用以下命令编辑 MariaDB 的服务文件：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo nano /lib/systemd/system/mariadb.service</span><br></pre></td></tr></table></figure><p>在文件的 <code>[Service]</code> 部分中添加一个新的行，内容如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[Service]</span><br><span class="line">...</span><br><span class="line">...</span><br><span class="line">ExecStartPre=/bin/sh -c <span class="string">&#x27;touch /etc/mysql/mariadb.conf.d/.interactive&#x27;</span></span><br></pre></td></tr></table></figure><p>确保在 <code>[Service]</code> 部分内的其他行之后添加此行。</p><p>保存并关闭文件（在 Nano 编辑器中按 Ctrl+X，然后按 Y 确认保存）。</p><p>运行以下命令重新加载 systemd 配置：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo systemctl daemon-reload</span><br></pre></td></tr></table></figure><p>现在，您可以启动 MariaDB 服务：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo systemctl start mariadb</span><br></pre></td></tr></table></figure><p>这次启动应该没有出现 “Interactive authentication required” 错误。</p><p>最后，您可以设置 MariaDB 在系统启动时自动启动：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo systemctl enable mariadb</span><br></pre></td></tr></table></figure><p>现在，您应该能够成功启动和运行 MariaDB 服务了。如果您仍然遇到问题，请确保按照上述步骤操作，并仔细检查所做的更改是否正确。</p>]]></content>
    
    
    <summary type="html">wsl的ubuntu中无法systemctl启动mariadb问题解决</summary>
    
    
    
    <category term="学习sql" scheme="https://blog.musnow.top/categories/%E5%AD%A6%E4%B9%A0sql/"/>
    
    
    <category term="Linux" scheme="https://blog.musnow.top/tags/Linux/"/>
    
    <category term="mysql" scheme="https://blog.musnow.top/tags/mysql/"/>
    
  </entry>
  
  <entry>
    <title>【Linux】wsl虚拟机时间和实际时间不符合</title>
    <link href="https://blog.musnow.top/posts/1339169411/"/>
    <id>https://blog.musnow.top/posts/1339169411/</id>
    <published>2023-12-12T01:30:55.000Z</published>
    <updated>2023-12-12T01:31:55.000Z</updated>
    
    <content type="html"><![CDATA[<p>偶然遇到了这个问题，触发原因是电脑在开启wsl的情况下进入了<code>休眠</code>模式，且在无网络情况下几天不使用。</p><p>然后开启wsl，发现<code>git log</code>显示最新commit的提交时间是明天，给我吓一跳，然后才发现原来是wsl里面的时间不对。</p><p>Linux下看时间的命令是<code>date</code>，本文写于12月12日，但wsl中的时间是12月10日，肯定是不对。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; date</span><br><span class="line">Tue Dec 10 09:51:29 AM CST 2023</span><br></pre></td></tr></table></figure><p>在wsl内部使用如下命令进行时间同步</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo hwclock -s</span><br></pre></td></tr></table></figure><p>执行后，在windows的命令行里面执行如下命令，重启wsl子系统。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wsl --shutdown</span><br></pre></td></tr></table></figure><p>再在wsl里面执行<code>date</code>命令，时间正确。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; date</span><br><span class="line">Tue Dec 12 09:53:21 AM CST 2023</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">wsl虚拟机时间和实际时间不符合</summary>
    
    
    
    <category term="玩上Linux" scheme="https://blog.musnow.top/categories/%E7%8E%A9%E4%B8%8ALinux/"/>
    
    
    <category term="Linux" scheme="https://blog.musnow.top/tags/Linux/"/>
    
    <category term="虚拟机" scheme="https://blog.musnow.top/tags/%E8%99%9A%E6%8B%9F%E6%9C%BA/"/>
    
  </entry>
  
  <entry>
    <title>【Hexo】在中英文之间添加空格</title>
    <link href="https://blog.musnow.top/posts/3894841472/"/>
    <id>https://blog.musnow.top/posts/3894841472/</id>
    <published>2023-12-10T07:32:14.000Z</published>
    <updated>2023-12-10T07:32:14.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="说明和插件安装"><a href="#说明和插件安装" class="headerlink" title="说明和插件安装"></a>说明和插件安装</h1><p>如题，中英文添加空格是比较规范的写法， 但是我个人实在是懒，每次都要这么弄太累了。想找找hexo有没有对应的插件，还是有的</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-filter-auto-spacing --save</span><br></pre></td></tr></table></figure><p>安装了之后，在hexo的<code>_config.yml</code>里面添加配置项</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># hexo 中英文之间自动加空格</span><br><span class="line"># npm install hexo-filter-auto-spacing --save</span><br><span class="line">auto_spacing:</span><br><span class="line">  enable: true</span><br></pre></td></tr></table></figure><p>随后<code>hexo s</code>就能看到插件启用后的结果了</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2023/12/bc23322af55db5caac57603bdc3df125.png" alt="image-20231210153203131"></p><p>请注意，该插件仓库 <a href="https://github.com/hexojs/hexo-filter-auto-spacing">https://github.com/hexojs/hexo-filter-auto-spacing</a> 已经被设置为公共归档，且最后一次代码提交是<strong>2022年6月</strong>。</p><p>2023年12月10日实测该插件依旧有用，但不保证hexo更新后依旧有效。慕雪使用的hexo和主题版本如下。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hexo 6.2.0</span><br><span class="line">hexo-butterfly 4.9.0</span><br></pre></td></tr></table></figure><p>暂时没有搜到其他仍在更新的插件。</p><h1 id="buffterfly主题自带配置"><a href="#buffterfly主题自带配置" class="headerlink" title="buffterfly主题自带配置"></a>buffterfly主题自带配置</h1><p>感谢评论区老哥的提醒，buffterfly主题其实<strong>自带</strong>了这个配置项 <a href="https://butterfly.js.org/posts/ceeb73f/#Pangu">https://butterfly.js.org/posts/ceeb73f/#Pangu</a></p><p>使用如下命令<strong>卸载</strong>上方提到的插件。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm uninstall hexo-filter-auto-spacing --save</span><br></pre></td></tr></table></figure><p>在hexo-butterfly主题中<code>pangu</code>配置项就是中英文之间添加空格的配置。</p><p>其中site是对全站生效，post是只对文章生效（对其他页面不生效）</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># https://github.com/vinta/pangu.js</span></span><br><span class="line"><span class="comment"># Insert a space between Chinese character and English character (中英文之間添加空格)</span></span><br><span class="line"><span class="attr">pangu:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">false</span></span><br><span class="line">  <span class="attr">field:</span> <span class="string">site</span> <span class="comment"># site/post</span></span><br></pre></td></tr></table></figure><p>将enable改成true即可启用，效果也很好，不仅中英文之间会添加空格，数字和中文之间也添加了空格。完美啦！</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2023/12/1ffcfb9e601a003fd9e246a31d833e15.png" alt="image-20231210213203331"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;说明和插件安装&quot;&gt;&lt;a href=&quot;#说明和插件安装&quot; class=&quot;headerlink&quot; title=&quot;说明和插件安装&quot;&gt;&lt;/a&gt;说明和插件安装&lt;/h1&gt;&lt;p&gt;如题，中英文添加空格是比较规范的写法， 但是我个人实在是懒，每次都要这么弄太累了。想找找hexo有没</summary>
      
    
    
    
    <category term="差生文具多" scheme="https://blog.musnow.top/categories/%E5%B7%AE%E7%94%9F%E6%96%87%E5%85%B7%E5%A4%9A/"/>
    
    
    <category term="Hexo" scheme="https://blog.musnow.top/tags/Hexo/"/>
    
  </entry>
  
  <entry>
    <title>【Nginx】NGINX 配置避免 IP 访问时证书暴露域名</title>
    <link href="https://blog.musnow.top/posts/3528013149/"/>
    <id>https://blog.musnow.top/posts/3528013149/</id>
    <published>2023-12-09T09:12:55.000Z</published>
    <updated>2023-12-09T10:12:55.000Z</updated>
    
    <content type="html"><![CDATA[<p>本文转载自：<a href="https://zinglix.xyz/2021/10/04/nginx-ssl-reject-handshake/">https://zinglix.xyz/2021/10/04/nginx-ssl-reject-handshake/</a></p><h1 id="原文"><a href="#原文" class="headerlink" title="原文"></a>原文</h1><h2 id="TL-DR"><a href="#TL-DR" class="headerlink" title="TL;DR"></a>TL;DR</h2><p>NGINX 配置避免 IP 访问时证书暴露域名</p><p>利用 <code>NGINX 1.19.4</code> 后的新特性 <code>ssl_reject_handshake on;</code>，将其置于默认访问时配置中，IP 访问时会终止 TLS 握手，也就不会暴露域名了。</p><p>使用如下命令查看你的nginx版本</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># nginx -v</span><br><span class="line">nginx version: nginx/1.20.1</span><br></pre></td></tr></table></figure><h2 id="细说"><a href="#细说" class="headerlink" title="细说"></a>细说</h2><p>CDN 是建站时常用的工具，在自己的主机外面套一层 CDN 是常见操作，一般这样认为自己的主机就安全了，有人来攻击也会先到 CDN 服务器，攻击者根本无法获取到自己主机的 IP，但事实真的是这样吗？</p><p>我们先来看看一般配置后会出现什么问题。</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">    <span class="attribute">listen</span> <span class="number">80</span> default_server;</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Redirect all HTTP requests to HTTPS.</span></span><br><span class="line">    <span class="attribute">return</span> <span class="number">301</span> https://<span class="variable">$host</span><span class="variable">$request_uri</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">    <span class="attribute">listen</span> <span class="number">443</span> default_server;</span><br><span class="line">    <span class="attribute">server_name</span> _;</span><br><span class="line">    <span class="attribute">include</span> conf.d/ssl.config;</span><br><span class="line">    <span class="attribute">return</span> <span class="number">444</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面是一个很常用的 NGINX 配置，HTTP 访问全部重定向到 HTTPS 的 443 端口上，没有配置过的域名返回 444 终止连接。</p><p>好了，现在尝试用 IP 和 HTTPS 访问你的网站，你应该能够看到预想中访问失败、证书无效等连接失败的提示。</p><p><strong>但是！</strong>注意下浏览器左上角提示的不安全，点开查看证书信息，你就会发现你的域名其实随着证书发送了过来。此时如果你是攻击者，那么其实就可以知道该域名背后的源主机 IP 就是这个。</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2023/12/035ad572d3638bb917c07e53e24c9575.png"></p><p>上图即为用 IP 访问后，依旧能看到证书内容。这是因为返回 444 是 HTTP 层面的事情，意味着到达这一步下层的 TLS 握手已经完成。证书不被信任是一回事，但说明已经拿到了服务器的证书。</p><p>CDN 确实避免了直接 DNS 查询暴露 IP 的问题，但攻击者通过扫描全网 IP，用上述方式依旧可以知道每个 IP 对应的域名是什么，这也是为什么很多站长用了 CDN 后并且反复更换 IP 却依旧被攻击者迅速找到 IP 的原因。</p><blockquote><p><a href="https://search.censys.io/">Censys</a> 就一直在干这件事，全网扫描 IP 并找到其对应的域名</p></blockquote><h2 id="那该怎么办呢？"><a href="#那该怎么办呢？" class="headerlink" title="那该怎么办呢？"></a>那该怎么办呢？</h2><p>问题根源出在 client 在 TLS 握手时发送了 ClientHello 后，NGINX 在 ServerHello 中带着含有域名的默认证书返回了，因为 NGINX 期望可以完成握手，这可能可以算是 NGINX 的一个缺陷。</p><blockquote><p>如果你不熟悉 TLS 握手流程，那么可以看看 <a href="https://zinglix.xyz/2019/05/07/tls-handshake/">这篇文章</a></p></blockquote><h3 id="笨办法"><a href="#笨办法" class="headerlink" title="笨办法"></a>笨办法</h3><p>既然 NGINX 默认提供了带有域名的证书，那么想不暴露也很简单，提供一个不含有正确域名的证书即可。</p><p>NGINX 设置中 HTTPS 访问如果没有设置证书，那么就会报错。但反正 IP 访问也不需要提供服务，那么直接自签一个 IP 证书，或者随便一个域名的证书都可。当然，如果能搞定合法的 IP 证书也不是不行。</p><p>搞定证书后，添加一个配置，让 IP 访问返回错误证书就完事了。</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">    <span class="attribute">listen</span> <span class="number">443</span> ssl default_server;</span><br><span class="line">    <span class="attribute">server_name</span> your_ip;</span><br><span class="line"></span><br><span class="line">    <span class="attribute">ssl_certificate</span>    xxxx.pem;</span><br><span class="line">    // <span class="attribute">and</span> more ssl config ...</span><br><span class="line"></span><br><span class="line">    return <span class="number">444</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="好方法"><a href="#好方法" class="headerlink" title="好方法"></a>好方法</h3><p>这种方法还得自己搞个证书，如果服务器多每个都得这么搞也挺麻烦的，好在这个问题 NGINX 这已经有了很完美的解决方案。</p><p>ClientHello 中是带着 SNI 的，所以其实握手阶段是可以知道访问的域名是否合法的，NGINX 1.19.4 中添加了一个新的配置项 <code>ssl_reject_handshake</code> 用于拒绝握手，也就不会提供证书。</p><p>使用方法也很简单，将原本默认配置中的 <code>return 444</code> 替换成 <code>ssl_reject_handshake on</code> 即可。</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">    <span class="attribute">listen</span> <span class="number">443</span> default_server;</span><br><span class="line">    <span class="attribute">server_name</span> _;</span><br><span class="line">    <span class="attribute">include</span> conf.d/ssl.config;</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 不用返回 444 了，直接拒绝握手</span></span><br><span class="line">    <span class="attribute">ssl_reject_handshake</span> <span class="literal">on</span>;</span><br><span class="line">    <span class="comment"># return 444;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>配置后，再尝试 IP 访问，会发现浏览器报了 <code>ERR_SSL_UNRECOGNIZED_NAME_ALERT</code> 的错误，也看不到证书信息，目标达成！</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2023/12/18ba4a8ac5a7c8d5400ecf4a2a6bb392.png"></p><h2 id="其实还没完"><a href="#其实还没完" class="headerlink" title="其实还没完"></a>其实还没完</h2><p>上述方法是通过 ClientHello 中的 SNI 确定访问是否合法的，那如果 SNI 就是正确的域名呢？</p><p>这种场景发生于攻击者已经确定要攻击某个域名，那么他就可以将带着该域名的握手信息遍历所有 IP，握手成功就找到，这样访问其实与正常访问并无区别，<strong>唯一解决方法</strong>就是白名单只允许 CDN 服务器访问。</p><blockquote><p>例如攻击者用 hosts 直接硬写 IP，<strong>将域名强行指向某个 IP</strong></p><p>或者用这种方式 <code>curl https://example.com --resolve &#39;example.com:443:172.17.54.18&#39;</code></p></blockquote><p>如下，在 nginx 里面的 location 配置添加上 allow 的 IP 段，只允许 CDN 运营商的 IP 访问你的服务，就能避免绕过 CDN 造成的攻击</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">location</span> / &#123;</span><br><span class="line">    <span class="attribute">allow</span>   <span class="number">172.1.2.0</span>/<span class="number">24</span>; <span class="comment"># 允许CDN运营商的IP</span></span><br><span class="line">    <span class="attribute">allow</span>   <span class="number">1.2.3.4</span>/<span class="number">32</span>;</span><br><span class="line">    <span class="attribute">deny</span>    all; <span class="comment"># 阻止其他任何IP</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述 IP 段只能向 CDN 服务提供商询问，一般文档中都是有相关信息的。</p><h1 id="慕雪的测试"><a href="#慕雪的测试" class="headerlink" title="慕雪的测试"></a>慕雪的测试</h1><p>上面这篇文章我第一次看的时候还没有理解他说的是什么内容。后来测试了一下，明白了。</p><h2 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h2><p>以我的服务器举例，我是<code>centos 7.2</code>的服务器，直接用yum安装的nginx，版本<code>nginx/1.20.1</code>，配置路径是<code>/etc/nginx</code>；</p><p>在默认情况下，你会有个<code>nginx.conf</code>，和<code>/etc/nginx/conf.d</code>里面的用户配置文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">/etc/nginx</span><br><span class="line">- nginx.conf</span><br><span class="line">- conf.d</span><br><span class="line">- server1.conf</span><br><span class="line">- server2.conf</span><br></pre></td></tr></table></figure><p>在<code>nginx.conf</code>里面除了加载用户配置文件，还会有一个默认的server，指向一个<strong>静态文件路径</strong>。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"># 用户配置文件</span><br><span class="line">   include /etc/nginx/conf.d/*.conf;</span><br><span class="line"></span><br><span class="line">   server &#123;</span><br><span class="line">       listen       80;</span><br><span class="line">       listen       [::]:80;</span><br><span class="line">       server_name  _;</span><br><span class="line">       root         /usr/share/nginx/html; # 默认的静态文件路径</span><br><span class="line"></span><br><span class="line">       # Load configuration files for the default server block.</span><br><span class="line">       include /etc/nginx/default.d/*.conf;</span><br><span class="line"></span><br><span class="line">       error_page 404 /404.html;</span><br><span class="line">       location = /404.html &#123;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       error_page 500 502 503 504 /50x.html;</span><br><span class="line">       location = /50x.html &#123;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>在我的服务器上，这个路径里面是如下内容</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@bt-7274:/etc/nginx]# ls /usr/share/nginx/html</span><br><span class="line">404.html  50x.html  en-US  icons  img  index.html  nginx-logo.png  poweredby.png</span><br></pre></td></tr></table></figure><p>此时直接在浏览器访问你的ip，会展示这个默认路径里面的<code>index.html</code>，是centos的一个介绍页面。</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2023/12/03207321f1c2ee5a4f77f22d55746121.png" alt="image-20231209173337849"></p><p>但是，这并不代表你当前没有解析到任何<strong>用户自定义文件</strong>！nginx默认情况下会使用第一个用户自定义conf来作为ip访问的结果（这是因为对用户自定义conf的include是在defualt server之前的，你可以理解为用户自定义文件会像C语言的头文件一样在<code>nginx.conf</code>中被展开）</p><p>当前实际上是访问了<code>/etc/nginx/conf.d</code>里面按字典排序的<strong>第一个用户conf配置</strong>！</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">/etc/nginx</span><br><span class="line">- nginx.conf</span><br><span class="line">- conf.d</span><br><span class="line">- server1.conf # 直接访问ip，使用了这个配置文件</span><br><span class="line">- server2.conf</span><br></pre></td></tr></table></figure><p>为什么在我这里依旧展示了<strong>默认的静态文件路径呢</strong>？是因为我的第一个配置文件<code>a.conf</code>中没有配置<code>location /</code>，全都是其他路径（比如<code>/a/</code>）的反代！所以nginx就往后采用了最末尾的default server里面提供的默认静态文件。</p><p>而浏览器链接左侧的红色<code>不安全</code>就告诉我们，当前其实收到了一个ssl证书，这便是上面原文中提到的<code>ip访问会因为ssl证书泄漏域名</code>的问题。</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2023/12/0aff6af71c686835cb262961360442ab.png" alt="image-20231209174001901"></p><p>我们可以点击<code>不安全</code>提示，再点击右上角那个<strong>带徽章的小按钮</strong>，查看当前收到的证书</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2023/12/96fafa7dca660e58ec838fb95350aa05.png" alt="image-20231209174025184"></p><p>如下图，当前收到的这证书，正是我的<code>/etc/nginx/conf.d</code>中第一个用户配置里面的ssl证书；内部包含了该证书对应的域名，我们的域名因此泄漏！</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2023/12/c59ed5779697e2dda320ae46d6b8f7e5.png" alt="image-20231209174102666"></p><h2 id="思路回顾"><a href="#思路回顾" class="headerlink" title="思路回顾"></a>思路回顾</h2><p>再来缕一缕思路</p><ul><li>nginx会先加载用户配置文件，末尾才是默认指向<code>/usr/share/nginx/html</code>静态路径的配置</li><li>当你使用ip访问当前服务器，nginx会给浏览器发送<code>/etc/nginx/conf.d</code>中按<strong>字典序</strong>排在第一位的<strong>用户配置文件</strong>中的ssl证书（即上图所示证书）</li><li>恶意访问人员可以通过遍历访问所有IP地址，当访问你的服务器IP地址时，他拿到一个ssl证书，其中包括了一个域名A；</li><li>假设你的域名A是按<code>域名A-&gt;CDN-&gt;服务器IP</code>来进行解析的，此时恶意访问人员就通过这个ssl证书直接得到了<code>域名A-&gt;服务器IP</code>的对应关系，完全绕过了CDN</li><li>此时他就可以通过修改hosts强制让<code>域名A</code>指向<code>服务器IP</code>，绕过CDN直接攻击你的源站</li></ul><p>套了CDN还暴露源站IP肯定不是我们想要的结果，所以我们需要解决这个问题！</p><h2 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h2><p>在<code>/etc/nginx/conf.d</code>中直接添加一个<code>a.conf</code>，让其排序在<strong>字典序的第一位</strong>，里面写入如下内容，其中<code>server_name _</code>的含义是除了我们配置过的域名外的其他访问</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">    <span class="attribute">listen</span> <span class="number">80</span> default_server;</span><br><span class="line">    <span class="attribute">server_name</span> _;</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Redirect all HTTP requests to HTTPS.</span></span><br><span class="line">    <span class="attribute">return</span> <span class="number">301</span> https://<span class="variable">$host</span><span class="variable">$request_uri</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">    <span class="attribute">listen</span> <span class="number">443</span> default_server;</span><br><span class="line">    <span class="attribute">server_name</span> _;</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 不用返回 444 了，直接拒绝握手</span></span><br><span class="line">    <span class="attribute">ssl_reject_handshake</span> <span class="literal">on</span>;</span><br><span class="line">    <span class="comment"># return 444;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>配置后直接重启nginx，没有报错就是ok了</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@bt-7274:/etc/nginx/conf.d]# systemctl restart nginx</span><br><span class="line">[root@bt-7274:/etc/nginx/conf.d]# ll</span><br><span class="line">total 28</span><br><span class="line">-rw-r--r-- 1 root root  193 Dec  9 17:52 a.conf</span><br></pre></td></tr></table></figure><p>此时直接访问就会报错ssl的alert了，但是edge中估计是因为<strong>缓存的问题</strong>，依旧能看到证书</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2023/12/9c095bed2d740e56c781c10e33212c9d.png" alt="image-20231209175534238"></p><p>换火狐看一下，无法连接，没有证书，目标达成！</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2023/12/20311f168b98f1ebe38157edf25b0c1a.png" alt="image-20231209175736923"></p><p>这里顺带贴一下火狐中一个正常ssl网站会显示成什么样子。在锁的按钮里面能看到证书的颁发者是谷歌，而<strong>上图中</strong>没有看到证书颁发者，即我们的证书并没有泄漏，目的达成。</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2023/12/6b4716321086d0e5ef6978695a52b630.png" alt="image-20231209175834078"></p><p>另外，我试了试我另外一个服务器使用的1panel安装的OpenResty，这个比较好，在默认情况下直接访问IP地址返回的是404，且没有暴露证书。不需要自己额外做配置了。</p>]]></content>
    
    
    <summary type="html">NGINX配置避免IP访问时证书暴露域名</summary>
    
    
    
    <category term="玩上Linux" scheme="https://blog.musnow.top/categories/%E7%8E%A9%E4%B8%8ALinux/"/>
    
    
    <category term="Linux" scheme="https://blog.musnow.top/tags/Linux/"/>
    
    <category term="Nginx" scheme="https://blog.musnow.top/tags/Nginx/"/>
    
  </entry>
  
  <entry>
    <title>【Nginx】nginx通过配置文件阻止海外ip访问</title>
    <link href="https://blog.musnow.top/posts/2029711168/"/>
    <id>https://blog.musnow.top/posts/2029711168/</id>
    <published>2023-12-09T08:12:55.000Z</published>
    <updated>2023-12-09T12:12:55.000Z</updated>
    
    <content type="html"><![CDATA[<p>nginx通过配置文件阻止海外ip访问</p><h1 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h1><p>因为最近发现有不少刷评论的脚本，在nginx请求日志里面看了眼，都是海外的ip，反正我的博客也是全中文。所以干脆把海外ip禁止artalk评论。</p><p>在<code>/etc/nginx/nginx.conf</code>中可以看到默认的日志路径，在里面能找到每一个转发的请求和其源IP。其中artak新增评论的请求是<code>/api/add</code>路径</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">access_log  /var/log/nginx/access.log  main;</span><br></pre></td></tr></table></figure><p>考虑到添加海外ip屏蔽可能会阻止一些真的在国外的朋友，如果你在阅读本站博客时，遇到相关问题无法直接评论与我交流，可以移步github随便找个我的仓库开个issue提问！</p><h1 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h1><h2 id="APNIC介绍"><a href="#APNIC介绍" class="headerlink" title="APNIC介绍"></a>APNIC介绍</h2><p>后文出现的网站是来自<strong>APNIC</strong> (Asia Pacific Network Information Center)，其是IP地址管理机构之一，负责亚洲、太平洋地区。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">APNIC提供了每日更新的亚太地区IPv4，IPv6，AS号分配的信息表：</span><br><span class="line">http://ftp.apnic.net/apnic/stats/apnic/delegated-apnic-latest</span><br><span class="line">该文件的格式与具体内容参见：</span><br><span class="line">http://ftp.apnic.net/pub/apnic/stats/apnic/README.TXT</span><br></pre></td></tr></table></figure><h2 id="脚本获取ip"><a href="#脚本获取ip" class="headerlink" title="脚本获取ip"></a>脚本获取ip</h2><p>初步解决方法参考：<a href="https://www.cnblogs.com/guoyabin/p/14263732.html">https://www.cnblogs.com/guoyabin/p/14263732.html</a></p><p>原博主提供的脚本如下，可以下载所有海外ip列表并生成一个nginx配置，写入<code>/etc/nginx/blackip.conf</code>中</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="built_in">rm</span> -f legacy-apnic-latest black_`<span class="built_in">date</span> +%F`.conf &amp;&amp; wget http://ftp.apnic.net/apnic/stats/apnic/legacy-apnic-latest</span><br><span class="line"></span><br><span class="line">awk -F <span class="string">&#x27;|&#x27;</span> <span class="string">&#x27;&#123;if(NR&gt;2)printf(&quot;%s %s/%d%s\n&quot;,&quot;deny&quot;,$4,24,&quot;;&quot;)&#125;&#x27;</span> legacy-apnic-latest &gt; black_`<span class="built_in">date</span> +%F`.conf &amp;&amp; \</span><br><span class="line"><span class="built_in">rm</span> -f /etc/nginx/blackip.conf &amp;&amp; \</span><br><span class="line"><span class="built_in">ln</span> -s <span class="variable">$PWD</span>/black_`<span class="built_in">date</span> +%F`.conf /etc/nginx/blackip.conf </span><br></pre></td></tr></table></figure><p>脚本执行后的效果如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@bt-7274:/etc/nginx]# ll</span><br><span class="line">total 88</span><br><span class="line">lrwxrwxrwx 1 root root   34 Dec  9 16:03 blackip.conf -&gt; /root/docker/black_2023-12-09.conf</span><br></pre></td></tr></table></figure><p>文件内容如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[root@bt-7274:/etc/nginx/conf.d]# cat ../blackip.conf</span><br><span class="line">deny 128.134.0.0/24;</span><br><span class="line">deny 128.184.0.0/24;</span><br><span class="line">deny 128.250.0.0/24;</span><br><span class="line">deny 129.60.0.0/24;</span><br><span class="line">deny 129.78.0.0/24;</span><br><span class="line">...后面的省略了</span><br></pre></td></tr></table></figure><h2 id="nginx屏蔽海外ip"><a href="#nginx屏蔽海外ip" class="headerlink" title="nginx屏蔽海外ip"></a>nginx屏蔽海外ip</h2><p>参考原博主的做法，你可以将这个<code>blackip.conf</code>在<code>/etc/nginx/nginx.conf</code>中的<strong>http模块</strong>里面include，这样会阻止当前服务器所有反代的海外的请求。</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">include</span> /etc/nginx/blackip.conf;</span><br></pre></td></tr></table></figure><p>还可以在单个配置文件的<a href="https://zinglix.xyz/2021/10/04/nginx-ssl-reject-handshake/">location里面引用</a></p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">  <span class="section">location</span> / &#123;</span><br><span class="line">      <span class="attribute">proxy_redirect</span> <span class="literal">off</span>; <span class="comment"># artalk的nginx配置中必须有这个</span></span><br><span class="line">      <span class="attribute">proxy_set_header</span> X-Real-IP <span class="variable">$remote_addr</span>;</span><br><span class="line">      <span class="attribute">proxy_set_header</span> X-Forwarded-For <span class="variable">$proxy_add_x_forwarded_for</span>;</span><br><span class="line">      <span class="attribute">proxy_set_header</span> Host <span class="variable">$host</span>;</span><br><span class="line">      <span class="attribute">proxy_set_header</span> Upgrade-Insecure-Requests <span class="number">1</span>;</span><br><span class="line">      <span class="attribute">proxy_set_header</span> X-Forwarded-Proto https;</span><br><span class="line"></span><br><span class="line">      <span class="attribute">include</span> /etc/nginx/blackip.conf; <span class="comment"># 引用配置</span></span><br><span class="line"></span><br><span class="line">      <span class="attribute">proxy_pass</span> http://127.0.0.1:14722;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>修改后重启nginx，没有报错就是ok了</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl restart nginx</span><br></pre></td></tr></table></figure><p>用海外的服务器试试能不能请求artalk，用<a href="https://artk.musnow.top/sidebar/#/login">artk.musnow.top&#x2F;sidebar&#x2F;…</a>这个管理员登录页面来进行测试。</p><p>国内服务器请求结果如下，和浏览器打开的结果基本是一样（管理员登录界面）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">[root@bt-7274:/etc/nginx/conf.d]# curl https://artk.musnow.top/sidebar/#/login</span><br><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">  &lt;head&gt;</span><br><span class="line">    &lt;meta charset=&quot;UTF-8&quot; /&gt;</span><br><span class="line">    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot; /&gt;</span><br><span class="line">    &lt;title&gt;Artalk Sidebar&lt;/title&gt;</span><br><span class="line">    &lt;script type=&quot;module&quot; crossorigin src=&quot;./assets/index-5a0b3a93.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">    &lt;link rel=&quot;stylesheet&quot; href=&quot;./assets/index-84fdcf98.css&quot;&gt;</span><br><span class="line">  &lt;/head&gt;</span><br><span class="line">  &lt;body&gt;</span><br><span class="line">    &lt;div id=&quot;app&quot;&gt;&lt;/div&gt;</span><br><span class="line">  </span><br><span class="line">  &lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><p>海外服务器请求结果也是上面这样……然后发现是因为我的海外服务器ip压根不在那个black的deny列表里面</p><p>尝试把ip的网段给加进去，重启nginx再试试。<strong>完美处理</strong>！添加前能正常请求到，添加后就变成403了</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">[root@RainYun-8aNbbsmA:~]# curl https://artk.musnow.top/sidebar/#/login</span><br><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">  &lt;head&gt;</span><br><span class="line">    &lt;meta charset=&quot;UTF-8&quot; /&gt;</span><br><span class="line">    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot; /&gt;</span><br><span class="line">    &lt;title&gt;Artalk Sidebar&lt;/title&gt;</span><br><span class="line">    &lt;script type=&quot;module&quot; crossorigin src=&quot;./assets/index-5a0b3a93.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">    &lt;link rel=&quot;stylesheet&quot; href=&quot;./assets/index-84fdcf98.css&quot;&gt;</span><br><span class="line">  &lt;/head&gt;</span><br><span class="line">  &lt;body&gt;</span><br><span class="line">    &lt;div id=&quot;app&quot;&gt;&lt;/div&gt;</span><br><span class="line">    </span><br><span class="line">  &lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br><span class="line">[root@RainYun-8aNbbsmA:~]# </span><br><span class="line">[root@RainYun-8aNbbsmA:~]# curl https://artk.musnow.top/sidebar/#/login</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;&lt;title&gt;403 Forbidden&lt;/title&gt;&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;center&gt;&lt;h1&gt;403 Forbidden&lt;/h1&gt;&lt;/center&gt;</span><br><span class="line">&lt;hr&gt;&lt;center&gt;nginx/1.20.1&lt;/center&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br><span class="line">[root@RainYun-8aNbbsmA:~]# </span><br></pre></td></tr></table></figure><h2 id="nginx屏蔽非国内ip"><a href="#nginx屏蔽非国内ip" class="headerlink" title="nginx屏蔽非国内ip"></a>nginx屏蔽非国内ip</h2><p>我前文提到了我的海外服务器的ip不在这个deny的ip列表里面，没有被屏蔽。</p><p>考虑到网上搜不到<code>legacy-apnic-latest</code>文件存放的是什么ip的信息，我决定换一个思路：allow国内的ip，拒绝所有非国内的ip</p><blockquote><p>获取国内ip列表 <a href="https://www.cnblogs.com/sentangle/p/13201770.html">https://www.cnblogs.com/sentangle/p/13201770.html</a></p></blockquote><p>下面这个url里面的ip地址标明了地区，我们只需要将其提取出来即可</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://ftp.apnic.net/apnic/stats/apnic/delegated-apnic-latest</span><br></pre></td></tr></table></figure><p>这个文件里面的内容结构如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">等级机构|获得该IP段的国家/组织|资源类型|起始IP|IP段长度|分配日期|分配状态</span><br></pre></td></tr></table></figure><p>我们只需要提取CN的所有IP，然后允许他们，再<code>deny all</code>阻止其他ip就可以了</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="built_in">rm</span> -f delegated-apnic-latest blackcn_`<span class="built_in">date</span> +%F`.conf &amp;&amp; wget http://ftp.apnic.net/apnic/stats/apnic/delegated-apnic-latest</span><br><span class="line"></span><br><span class="line">awk -F\| <span class="string">&#x27;/CN\|ipv4/ &#123; printf(&quot;%s %s/%d%s\n&quot;,&quot;allow&quot;,$4, 32-log($5)/log(2), &quot;;&quot;) &#125;&#x27;</span> delegated-apnic-latest &gt; blackcn_`<span class="built_in">date</span> +%F`.conf &amp;&amp; \</span><br><span class="line"><span class="built_in">rm</span> -f /etc/nginx/blackcn.conf &amp;&amp; \</span><br><span class="line"><span class="built_in">ln</span> -s <span class="variable">$PWD</span>/blackcn_`<span class="built_in">date</span> +%F`.conf /etc/nginx/blackcn.conf</span><br></pre></td></tr></table></figure><p>执行这个脚本后，会生成<code>/etc/nginx/blackcn.conf</code>文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@bt-7274:/etc/nginx]# ll</span><br><span class="line">total 88</span><br><span class="line">lrwxrwxrwx 1 root root   42 Dec  9 16:54 blackcn.conf -&gt; /root/docker/nginx/blackcn_2023-12-09.conf</span><br><span class="line">lrwxrwxrwx 1 root root   40 Dec  9 16:56 blackip.conf -&gt; /root/docker/nginx/black_2023-12-09.conf</span><br></pre></td></tr></table></figure><p>内容如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">allow 223.248.0.0/14;</span><br><span class="line">allow 223.252.128.0/17;</span><br><span class="line">allow 223.254.0.0/16;</span><br><span class="line">allow 223.255.0.0/17;</span><br><span class="line">allow 223.255.236.0/22;</span><br><span class="line">allow 223.255.252.0/23;</span><br><span class="line">....</span><br></pre></td></tr></table></figure><p>还是修改nginx单个站点配置文件的location中的内容</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">  <span class="section">location</span> / &#123;</span><br><span class="line">      <span class="attribute">proxy_redirect</span> <span class="literal">off</span>;</span><br><span class="line">  <span class="attribute">proxy_set_header</span> X-Real-IP <span class="variable">$remote_addr</span>;</span><br><span class="line">      <span class="attribute">proxy_set_header</span> X-Forwarded-For <span class="variable">$proxy_add_x_forwarded_for</span>;</span><br><span class="line">      <span class="attribute">proxy_set_header</span> Host <span class="variable">$host</span>;</span><br><span class="line">      <span class="attribute">proxy_set_header</span> Upgrade-Insecure-Requests <span class="number">1</span>;</span><br><span class="line">      <span class="attribute">proxy_set_header</span> X-Forwarded-Proto https;</span><br><span class="line"><span class="comment"># 允许所有国内ip</span></span><br><span class="line">  <span class="attribute">include</span> /etc/nginx/blackcn.conf;</span><br><span class="line">  <span class="attribute">deny</span> all; <span class="comment"># 阻止其他ip</span></span><br><span class="line"></span><br><span class="line">  <span class="attribute">proxy_pass</span> http://127.0.0.1:14722;</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure><p>先来试试不修改配置文件（不做任何deny和allow操作的情况下）海外ip请求结果</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">[root@RainYun-8aNbbsmA:~]# curl https://artk.musnow.top/sidebar/#/login</span><br><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">  &lt;head&gt;</span><br><span class="line">    &lt;meta charset=&quot;UTF-8&quot; /&gt;</span><br><span class="line">    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot; /&gt;</span><br><span class="line">    &lt;title&gt;Artalk Sidebar&lt;/title&gt;</span><br><span class="line">    &lt;script type=&quot;module&quot; crossorigin src=&quot;./assets/index-5a0b3a93.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">    &lt;link rel=&quot;stylesheet&quot; href=&quot;./assets/index-84fdcf98.css&quot;&gt;</span><br><span class="line">  &lt;/head&gt;</span><br><span class="line">  &lt;body&gt;</span><br><span class="line">    &lt;div id=&quot;app&quot;&gt;&lt;/div&gt;</span><br><span class="line">    </span><br><span class="line">  &lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><p>符合预期，正常请求出了登录页面的html文件。</p><p>添加如上修改后，重启nginx，再次进行测试。这一次已经403阻止了，完美！</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[root@RainYun-8aNbbsmA:~]# curl https://artk.musnow.top/sidebar/#/login</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;&lt;title&gt;403 Forbidden&lt;/title&gt;&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;center&gt;&lt;h1&gt;403 Forbidden&lt;/h1&gt;&lt;/center&gt;</span><br><span class="line">&lt;hr&gt;&lt;center&gt;nginx/1.20.1&lt;/center&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><h1 id="The-end"><a href="#The-end" class="headerlink" title="The end"></a>The end</h1><p>你可以写个crontab让其定时执行脚本并重启nginx，我个人还是选择人工处理了（什么时候想起来就去更新一下ip列表）</p><p>感谢本文中出现的博客的博主。没有他们的帮助，我无法编写出shell脚本。</p>]]></content>
    
    
    <summary type="html">nginx通过配置文件阻止海外ip访问</summary>
    
    
    
    <category term="玩上Linux" scheme="https://blog.musnow.top/categories/%E7%8E%A9%E4%B8%8ALinux/"/>
    
    
    <category term="Linux" scheme="https://blog.musnow.top/tags/Linux/"/>
    
    <category term="Nginx" scheme="https://blog.musnow.top/tags/Nginx/"/>
    
  </entry>
  
  <entry>
    <title>【图床】删除对象存储桶前一定要检查！</title>
    <link href="https://blog.musnow.top/posts/3595872827/"/>
    <id>https://blog.musnow.top/posts/3595872827/</id>
    <published>2023-12-09T02:32:14.000Z</published>
    <updated>2023-12-09T02:32:14.000Z</updated>
    
    <content type="html"><![CDATA[<p>我又干蠢事了！虽然没有很大影响，但是这种问题还是不要发生的好。</p><h2 id="什么情况？"><a href="#什么情况？" class="headerlink" title="什么情况？"></a>什么情况？</h2><p>我在博客尚有引用某个对象存储bucket中图片的情况下，删除了那个bucket（因为这个bucket很久没有用，算是弃用的）</p><p>还好今天看旧笔记的时候，突然发现了这个问题，立马去重新搜索了一下这个旧bucket的图片链接，还好还好，受影响的只有两篇文章</p><ul><li>一篇之前导出过PDF，图片还能找到</li><li>另外一篇文章以文字为主，内部丢失的图片可有可无</li></ul><p>我恢复了第一篇里面的图片，然后修改了第二篇中和图片相关的文字说明，算是解决了这个问题。</p><p>又重写检查了一下笔记目录，算是彻底没有这个被我删除的bucket里面的图片了。</p><p>这一次还好，算是没有丢东西，不然数据不备份就删除的笑料又要多一个了……🤣</p><h2 id="以此为戒"><a href="#以此为戒" class="headerlink" title="以此为戒"></a>以此为戒</h2><p>删除bucket之前一定要检查自己到底还有没有使用这个bucket中的文件或者图片！</p><p>删除图床本地目录前，一定要检查自己还有没有这个本地目录里面的图片！</p><p>最佳方案：不要管那个bucket，将其访问权限改成<strong>私有</strong>后，使用备注功能将其标记为弃用。以后不再使用该bucket即可。</p><p>因为对于我个人使用来说，一个bucket里面不会有太多文件，目前最大的图床bucket也不过2GB而已，把它留在那里花不了几个钱！不然把bucket删了，哪天发现需要去里面找旧文件的时候无从下手就麻烦了！</p><blockquote><p>至于我为什么要删……其实是因为我有点强迫症，不用还留在那里看着有点不爽……</p></blockquote><p>当然还有另外一个解决方案：使用<code>rclone</code>等工具，将s3中的所有文件下载到本地，打包多地备份后，删除云端bucket</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;我又干蠢事了！虽然没有很大影响，但是这种问题还是不要发生的好。&lt;/p&gt;
&lt;h2 id=&quot;什么情况？&quot;&gt;&lt;a href=&quot;#什么情况？&quot; class=&quot;headerlink&quot; title=&quot;什么情况？&quot;&gt;&lt;/a&gt;什么情况？&lt;/h2&gt;&lt;p&gt;我在博客尚有引用某个对象存储bucke</summary>
      
    
    
    
    <category term="差生文具多" scheme="https://blog.musnow.top/categories/%E5%B7%AE%E7%94%9F%E6%96%87%E5%85%B7%E5%A4%9A/"/>
    
    
    <category term="图床" scheme="https://blog.musnow.top/tags/%E5%9B%BE%E5%BA%8A/"/>
    
  </entry>
  
  <entry>
    <title>【博客】hexo配置sitemap和百度|必应|谷歌收录</title>
    <link href="https://blog.musnow.top/posts/3595872826/"/>
    <id>https://blog.musnow.top/posts/3595872826/</id>
    <published>2023-12-08T12:32:14.000Z</published>
    <updated>2023-12-08T12:32:14.000Z</updated>
    
    <content type="html"><![CDATA[<p>最近没事找事，又看了会关于博客主题的东西，之前的sitemap一直没有弄上去，现在有时间就弄一下。</p><h1 id="1-hexo安装sitemap插件"><a href="#1-hexo安装sitemap插件" class="headerlink" title="1.hexo安装sitemap插件"></a>1.hexo安装sitemap插件</h1><p>在你的hexo路径下执行如下命令，安装sitemap生成插件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-generator-baidu-sitemap --save</span><br><span class="line">npm install hexo-generator-sitemap --save</span><br></pre></td></tr></table></figure><p>实测在windows11的<code>node v16.20.2</code>和<code>npm  9.8.1</code>下可以正常安装，但是安装baidu-sitemap插件的时候可能会有警告（不影响使用）</p><p>安装完毕插件后，在你的hexo配置文件<code>_config.yml</code>中添加如下内容，指定站点地图的文件名字即可。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 百度和谷歌的sitemap</span></span><br><span class="line"><span class="comment"># npm install hexo-generator-baidu-sitemap --save</span></span><br><span class="line"><span class="comment"># npm install hexo-generator-sitemap --save</span></span><br><span class="line"><span class="attr">baidusitemap:</span></span><br><span class="line">    <span class="attr">path:</span> <span class="string">baidusitemap.xml</span></span><br><span class="line"><span class="attr">sitemap:</span></span><br><span class="line">    <span class="attr">path:</span> <span class="string">sitemap.xml</span></span><br></pre></td></tr></table></figure><p>请注意，需要修改的是hexo的配置文件，并非主题配置文件！</p><h1 id="2-如何修改hexo主题生成的index-html文件？"><a href="#2-如何修改hexo主题生成的index-html文件？" class="headerlink" title="2.如何修改hexo主题生成的index.html文件？"></a>2.如何修改hexo主题生成的index.html文件？</h1><p>一般情况下，站点平台都会让你在<code>index.html</code>的<code>&lt;head&gt;</code>里面加一个html语句，来验证站点的所有权。比图百度的验证html语句如下</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;baidu-site-verification&quot;</span> <span class="attr">content</span>=<span class="string">&quot;验证码&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure><p>部分hexo主题可能提供了自定义<code>&lt;head&gt;</code>的选项（比如butterfly主题就有）</p><p>如果你使用的主题没有提供自定义<code>&lt;head&gt;</code>，可以尝试在主题文件夹下搜索index或者head关键字，来找到当前主题使用的<code>index.html</code>生成源文件</p><blockquote><p>该方法<strong>仅</strong>适用于将主题文件直接下载到<code>themes</code>文件夹下的情况，因为如果你用的是npm安装的主题，那么修改的主题文件是不会对其他地方的部署生效的，下一次更新主题还会覆盖掉。</p></blockquote><p>比如下图是keep主题<code>v3.6.1</code>版本中的<code>head.ejs</code>，你只需要把提供的meta标签加到这里面，下一次部署的时候的<code>index.html</code>中就会带上这个标头了。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">themes\keep\layout\_partial\head.ejs</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2023/12/c5c020be0607437acbd2d4364edd839b.png" alt="image-20231208205004240"></p><h1 id="3-站长平台添加sitemap"><a href="#3-站长平台添加sitemap" class="headerlink" title="3.站长平台添加sitemap"></a>3.站长平台添加sitemap</h1><h2 id="百度"><a href="#百度" class="headerlink" title="百度"></a>百度</h2><p>百度资源搜索平台 <a href="https://ziyuan.baidu.com/site/index#/">https://ziyuan.baidu.com/site/index#/</a></p><p>百度实在是无语，之前安装了<code>hexo-baidu-url-submit</code>插件，主动调用百度api给他推送url，结果弄了已经快一年了，还没有收录我的站点。</p><blockquote><p>实话说，百度不收录站点，网站看的人就很少。百度我自己博客的关键词，结果是一堆被百度收录的爬虫站点用我的文章赚流量。唉……</p></blockquote><p>在资源搜索平台的站点管理中添加你的站点，用第二点提到的方式进行验证</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2023/12/f5049ad4122b226e6621e3f77bbca406.png" alt="image-20231208205611557"></p><p>添加完毕后，在普通收录中可以找到sitemap提交的区域。但是不知道为什么我这里的提交配额是0，搜索了一下也没有找到原因。</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2023/12/f1271309829d10b946af8dc1834d6530.png" alt="image-20231208205652153"></p><p><a href="https://zmingcx.com/baidu-linksubmit-sitemap.html">百度资源平台提交sitemap是取消了还是我被限制了？</a></p><p>有人说是站点质量太低被百度屏蔽了，但是这个情况也是很多人都遇到过的。估计是百度策略更新什么的，不允许你添加了吧！</p><p>如果你已经添加了sitemap，请不要将其删除，免得到时候又没有办法添加了。</p><h2 id="bing"><a href="#bing" class="headerlink" title="bing"></a>bing</h2><p>bing的站长平台直接搜就行：<a href="https://www.bing.com/webmasters/about?setlang=zh-cn">https://www.bing.com/webmasters/about?setlang=zh-cn</a></p><blockquote><p>国内裸连可能不稳定，需要用点方法。</p><p>不过bing即便不提交sitemap也咔咔收录了我的博客，主打一个主动+来者不拒。</p></blockquote><p>进去之后，用微软账户登录，然后点击新增站点，<strong>输入你博客的域名</strong></p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2023/12/46eaebbcbe275e5719c48c0fa212d482.png" alt="image-20231208203803163"></p><p>bing会让你验证站点所有权，根据下面三种方式的指引，选择一种就行了。如果你不知道如何修改hexo的源文件，使用<strong>CNAME验证</strong>方式是最简单的（只要你有域名有权就行了）。</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2023/12/6decdf248d463e8dcf22c1408d1521a8.png" alt="image-20231208204120311"></p><p>不过估计有很多老哥都是白嫖的github pages或者netlify&#x2F;vercel的<strong>二级域名</strong>，在没有域名所有权的情况下，你可以用前两种方式来验证。</p><ul><li>XML文件方式：将bing提供的XML文件下载，然后放到你hexo源目录的<strong>source</strong>文件夹下，就可以了。</li><li>HTML MATE标记验证：部分hexo主题可能提供了自定义header的选项（比如butterfly主题就有）其他主题可以参考上文第二点操作</li></ul><p>域名验证完毕后，在左侧可以提交网站地图（即sidemap）</p><p>直接点击按钮提交你的站点地图的url就可以了。bing会自动进行处理，如下图我的第一个sitemap已经成功处理出来了383个链接，非常完美。</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2023/12/24f236053b3ebece4028124e987e6c65.png" alt="image-20231208204707769"></p><h2 id="谷歌"><a href="#谷歌" class="headerlink" title="谷歌"></a>谷歌</h2><p>实话说，一个纯中文且面向国内读者的站点，在谷歌上面收录了估计也没多大用处，但是可以没用，但不能没有。也给他弄一下吧。</p><p><a href="https://search.google.com/search-console/welcome">https://search.google.com/search-console/welcome</a></p><p>首先是输入站点网址，因为我不需要验证所有站点，只把博客收录了就行，所以这里我选的是网址前缀。输入站点的时候需要把http也带上</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2023/12/940d735d204146063e8cb6de8db30326.png" alt="image-20231208210159103"></p><p>谷歌的验证方式也有很多种，这里的操作和bing是一样的，把它发给你的文件直接放到hexo的source路径下就可以了，或者采用html标签的方式验证。</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2023/12/6b7aef8d762ec3127bf418fba2257ff7.png" alt="image-20231208210317624"></p><p>验证成功后，选择前往资源界面，即前往当前站点的控制台。</p><p>如果你不小心点了完成，站点资源界面在站长工具的<strong>左侧边栏</strong>里面，在里面可以找到你已经添加了的站点。</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2023/12/2b62fc8c0f4a83a969894d7a97f13007.png" alt="image-20231208210604314"></p><p>在左侧选择站点地图，点击添加即可</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2023/12/f8159f7211dc0f12fc854ae74476f2f8.png" alt="image-20231208210802621"></p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2023/12/d57012975919635230b6bd8f57e9871b.png" alt="image-20231208210849226"></p><h1 id="搞定！"><a href="#搞定！" class="headerlink" title="搞定！"></a>搞定！</h1><p>有什么问题，欢迎评论区提出！</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;最近没事找事，又看了会关于博客主题的东西，之前的sitemap一直没有弄上去，现在有时间就弄一下。&lt;/p&gt;
&lt;h1 id=&quot;1-hexo安装sitemap插件&quot;&gt;&lt;a href=&quot;#1-hexo安装sitemap插件&quot; class=&quot;headerlink&quot; title=&quot;1</summary>
      
    
    
    
    <category term="差生文具多" scheme="https://blog.musnow.top/categories/%E5%B7%AE%E7%94%9F%E6%96%87%E5%85%B7%E5%A4%9A/"/>
    
    
    <category term="Hexo" scheme="https://blog.musnow.top/tags/Hexo/"/>
    
  </entry>
  
  <entry>
    <title>【Linux】lcov2.0安装和perl修改镜像源</title>
    <link href="https://blog.musnow.top/posts/1274282021/"/>
    <id>https://blog.musnow.top/posts/1274282021/</id>
    <published>2023-11-26T12:12:55.000Z</published>
    <updated>2023-11-26T12:12:55.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="安装lcov-2-0"><a href="#安装lcov-2-0" class="headerlink" title="安装lcov 2.0"></a>安装lcov 2.0</h1><p>你可能不知道lcov是什么，简而言之，它是一个代码单元测试覆盖率的显示工具，基于gcov。</p><ul><li>什么是单元测试覆盖率？</li></ul><p>我们需要对项目中的每个函数编写单元测试，其实就是测试函数的功能。通过gcc&#x2F;g++的相关编译选项，可以得到一个gcda文件，内部包含某个cpp文件中相关函数被执行了多少次，以及某些if&#x2F;switch中的多分支是否覆盖上了；</p><p>lcov就可以解析这些gcda文件，得到如下图所示的函数<strong>测试覆盖率</strong>的报告</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2023/11/6115958c076400afbfaf6ace5c1e89b9.png" alt="image-20231126201406666"></p><p>包括单元测试在内，这部分对代码函数测试的操作一般被称之为<code>功能安全</code>，这里就不多说了。</p><p>lcov 2.0的安装命令相对来说很简单，就是下面这些</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">wget https://github.com/linux-test-project/lcov/releases/download/v2.0/lcov-2.0.tar.gz</span><br><span class="line">tar -zxvf lcov-2.0.tar.gz</span><br><span class="line"><span class="built_in">cd</span> lcov-2.0</span><br><span class="line">sudo make install</span><br></pre></td></tr></table></figure><h1 id="perl"><a href="#perl" class="headerlink" title="perl"></a>perl</h1><p>使用lcov的时候需要perl，此时就需要修改镜像源。默认的perl module的源是在国外的，国内基本上是完全用不了。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># centos8 安装perl</span></span><br><span class="line">sudo yum install perl</span><br></pre></td></tr></table></figure><p>如果你的lcov运行的时候遇到下面类似的错误，那么就是因为perl缺少对应module导致的，比如如下报错是因为缺少<code>Capture::Tiny</code>这个module；</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Can&#x27;t locate Capture/Tiny.pm in @INC (you may need to install the Capture::Tiny module) (@INC contains: /usr/local/lib/lcov /usr/local/lib64/perl5 /usr/local/share/perl5 /usr/lib64/perl5/vendor_perl /usr/share/perl5/vendor_perl /usr/lib64/perl5 /usr/share/perl5) at /usr/local/lib/lcov/lcovutil.pm line 14.</span><br><span class="line">BEGIN failed--compilation aborted at /usr/local/lib/lcov/lcovutil.pm line 14.</span><br><span class="line">Compilation failed in require at /usr/local/bin/lcov line 102.</span><br><span class="line">BEGIN failed--compilation aborted at /usr/local/bin/lcov line 102.</span><br><span class="line">make: *** [makefile:6: lcov] Error 2</span><br></pre></td></tr></table></figure><h2 id="perl使用清华源"><a href="#perl使用清华源" class="headerlink" title="perl使用清华源"></a>perl使用清华源</h2><p>使用清华源就行了 <a href="https://mirrors.tuna.tsinghua.edu.cn/help/CPAN/">https://mirrors.tuna.tsinghua.edu.cn/help/CPAN/</a></p><p>因为我用的centos的系统，安装的perl版本很老，<code>v5.26.3</code>，所以这里记录一个手动修改镜像源的办法</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">perl --version</span><br></pre></td></tr></table></figure><p>在root用户下执行如下命令，会进入一个perl的命令行</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">perl -MCPAN -e shell</span><br></pre></td></tr></table></figure><p>在perl的命令行中执行如下命令</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">o conf init</span><br></pre></td></tr></table></figure><p>最终展现的结果应该如下，会自动往当前用户的家目录下创建一个配置文件</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2023/11/fdfb49a8a83aa12789080503070a9a7a.png" alt="image-20231126200126012"></p><p>这里创建的配置文件是在root用户下，输入<code>quit</code>退出perl的命令行后，我们直接vim打开这个配置文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim /root/.cpan/CPAN/MyConfig.pm</span><br></pre></td></tr></table></figure><p>在里面找到urllist选项，根据已有格式添加一个新的镜像路径就可以了</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2023/11/0f2b4af79a73a2f95bb6f6de6b17560b.png" alt="image-20231126200230352"></p><p>我这里添加后的urllist配置项如下，第一项是镜像源就OK</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#x27;urllist&#x27; =&gt; [q[https://mirrors.tuna.tsinghua.edu.cn/CPAN/], q[http://www.cpan.org/]],</span><br></pre></td></tr></table></figure><p>但是要注意一下，在我这边的网络环境中，清华源在perl安装包的时候也容易抽风，我试出来比较稳定的ip如下，将其写入<code>/etc/hosts</code>文件中，这样安装perl包的时候就不会timeout了</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">101.6.15.130 mirrors.tuna.tsinghua.edu.cn</span><br></pre></td></tr></table></figure><p>这个ip后续可能会有变化啊，请以你的实际情况为准！</p><h2 id="perl安装module"><a href="#perl安装module" class="headerlink" title="perl安装module"></a>perl安装module</h2><p>后续安装包的时候，就可以用上镜像源了，安装包的语句如下，请注意这个安装语句最后还有个英文的单引号，一定不要把他删了！</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo perl -MCPAN -e <span class="string">&#x27;install &quot;包名&quot;&#x27;</span></span><br></pre></td></tr></table></figure><p>我需要用perl是因为要用到lcov，在lcov仓库的readme里面提到了lcov需要的perl包，一个一个安装就行了（以下节选自<code>lcov2.0</code>的仓库README）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">These perl packages include:</span><br><span class="line"></span><br><span class="line">  - Capture::Tiny</span><br><span class="line">  - DateTime</span><br><span class="line">  - Devel::Cover</span><br><span class="line">  - Digest::MD5</span><br><span class="line">  - File::Spec</span><br><span class="line">  - at least one flavor of JSON module.</span><br><span class="line">    In order of performance/preference:</span><br><span class="line">       - JSON::XS</span><br><span class="line">       - Cpanel::JSON::XS</span><br><span class="line">       - JSON::PP</span><br><span class="line">       - JSON</span><br><span class="line"> - Memory::Process</span><br><span class="line"> - Module::Load::Conditional</span><br><span class="line"> - Scalar::Util</span><br><span class="line"> - Time::HiRes</span><br><span class="line"></span><br><span class="line">If your system is missing any of these, then you may be able to install them</span><br><span class="line">via:</span><br><span class="line"></span><br><span class="line">   $ perl -MCPAN -e &#x27;install &quot;packageName&quot;&#x27;</span><br></pre></td></tr></table></figure><p>比如我需要安装<code>Capture::Tiny</code>包，就用如下命令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo perl -MCPAN -e <span class="string">&#x27;install &quot;Capture::Tiny&quot;&#x27;</span></span><br></pre></td></tr></table></figure><p>正常安装的命令输出结果如下图所示</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2023/11/566a4438035e393943d353c48b016149.png" alt="image-20231126201023622"></p><h2 id="ubuntu安装perl-module"><a href="#ubuntu安装perl-module" class="headerlink" title="ubuntu安装perl module"></a>ubuntu安装perl module</h2><p>如果是ubuntu，安装perl的包会方便一点，因为apt源里面是有perl的module</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># ubuntu 22.04 可以直接安装下面的依赖项，就可以使用lcov 2.0了</span></span><br><span class="line">sudo apt install -y perl libcapture-tiny-perl libdatetime-perl</span><br></pre></td></tr></table></figure><p>你可以根据perl的包名中的<strong>关键字</strong>，尝试在<code>apt list</code>里面找找有没有对应的包</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt list | grep 包名</span><br></pre></td></tr></table></figure><h1 id="使用lcov"><a href="#使用lcov" class="headerlink" title="使用lcov"></a>使用lcov</h1><p>对于lcov2.0的命令使用，可以参考我的linux仓库中的测试</p><p><a href="https://gitee.com/musnows/raspberry-practice/tree/master/lcov_test">https://gitee.com/musnows/raspberry-practice/tree/master/lcov_test</a></p>]]></content>
    
    
    <summary type="html">lcov2.0安装和perl修改镜像源</summary>
    
    
    
    <category term="玩上Linux" scheme="https://blog.musnow.top/categories/%E7%8E%A9%E4%B8%8ALinux/"/>
    
    
    <category term="Linux" scheme="https://blog.musnow.top/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>【C++】空对象指针也能访问成员函数？</title>
    <link href="https://blog.musnow.top/posts/3858168549/"/>
    <id>https://blog.musnow.top/posts/3858168549/</id>
    <published>2023-11-16T08:40:46.000Z</published>
    <updated>2023-11-16T08:40:46.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-起因"><a href="#1-起因" class="headerlink" title="1.起因"></a>1.起因</h1><p>今天写代码的时候遇到一个bug，一个类中的set函数在设置一个POD类型的时候出现了异常，直接段错误退出了。</p><blockquote><p>小tips，POD类型指的是内置类型。</p></blockquote><p>想了好久，都没发现这里的问题到底是因为什么。后来才知道，原来空的对象指针，也能被解引用访问到函数！</p><h1 id="2-示例"><a href="#2-示例" class="headerlink" title="2.示例"></a>2.示例</h1><p>下面是关于这个情况的示例代码</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">mytest</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">mytest</span>() = <span class="keyword">default</span>;</span><br><span class="line">    <span class="built_in">mytest</span>(<span class="type">int</span> a):_a(<span class="number">0</span>)&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">set_int</span><span class="params">(<span class="type">int</span> a)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;set int to &quot;</span> &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">        _a = a;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(<span class="type">int</span> a)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;just a print&quot;</span> &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> _a = <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    mytest* ptr = <span class="literal">nullptr</span>;</span><br><span class="line">    ptr-&gt;<span class="built_in">print</span>(<span class="number">20</span>);</span><br><span class="line">    ptr-&gt;<span class="built_in">set_int</span>(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行这个程序，会出现段错误。但你会发现这个段错误并不是因为我们的<code>ptr-&gt;</code> 里面出现的，而是成功进入了set_int函数，执行了打印，最终对成员变量<code>_a</code>赋值的时候出现的！</p><p>对象指针为空，代表压根不存在一个实际的对象，也没办法对不存在的成员变量操作。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt; ./test</span><br><span class="line">just a print20</span><br><span class="line">set int to 10</span><br><span class="line">[1]    280362 segmentation fault  ./test</span><br></pre></td></tr></table></figure><p>当代码很多的时候，就会因为忽略这个特性（其实我当时是压根不知道）而误以为错误出现在set_int函数中。</p><p>没有想到是外层的对象指针为空导致的。</p><h1 id="3-为什么？"><a href="#3-为什么？" class="headerlink" title="3.为什么？"></a>3.为什么？</h1><p>在编译过程中，对象就已经绑定了函数地址。一个类的所有对象，使用的函数地址都是一样的。当编译<code>ptr-&gt;set_int(10)</code> 的时候，函数的地址就已经和这个指针绑定了，调用它等价于直接调用 set_int 函数。</p><p>如果这个函数中没有需要用到成员变量的地方，也就不需要解引用this指针，是不会出错的。比如上方代码中的print函数，就没有出现异常。</p><p>但如果函数内访问了内置成员，那么就会出现解引用空指针导致的段错误！</p>]]></content>
    
    
    <summary type="html">真没想到，空对象指针也能访问成员函数啊？</summary>
    
    
    
    <category term="遇见C++" scheme="https://blog.musnow.top/categories/%E9%81%87%E8%A7%81C/"/>
    
    
    <category term="C++" scheme="https://blog.musnow.top/tags/C/"/>
    
    <category term="数据结构" scheme="https://blog.musnow.top/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>【面经】C++面筋记录 (一) 231021</title>
    <link href="https://blog.musnow.top/posts/721187015/"/>
    <id>https://blog.musnow.top/posts/721187015/</id>
    <published>2023-10-21T10:50:14.000Z</published>
    <updated>2023-10-21T10:50:14.000Z</updated>
    
    <content type="html"><![CDATA[<p>记录部分从牛客网上看到的面筋</p><span id="more"></span><h1 id="1-声明一个vector，当vector过大时会栈溢出吗？"><a href="#1-声明一个vector，当vector过大时会栈溢出吗？" class="headerlink" title="1.声明一个vector，当vector过大时会栈溢出吗？"></a>1.声明一个vector，当vector过大时会栈溢出吗？</h1><p>答案是会。</p><p>默认申请的vector是放在栈区的，栈区的大小&lt;&lt;堆区的大小。所以如果我们在栈区中开辟的vector中插入巨量的数据，是会导致栈溢出的。</p><p>解决办法是将数据存放到堆区上（使用new来创建vector，而不是直接创建）</p><h1 id="2-如何实现多次运行程序但只有一个后台进程？"><a href="#2-如何实现多次运行程序但只有一个后台进程？" class="headerlink" title="2.如何实现多次运行程序但只有一个后台进程？"></a>2.如何实现多次运行程序但只有一个后台进程？</h1><p>使用命名互斥锁，程序启动前申请锁。</p><ul><li>如果锁没有被申请，代表是第一个进程，可以正常运行</li><li>如果锁已经被占用，代表已经有进程了，直接退出当前进程（这里要使用try_lock避免阻塞等待）</li></ul><p>在Linux下可以用命名信号量来实现类似进程共享锁的操作。这部分可以去学习进程通信中信号量的部分。</p><p>咨询了发这篇面筋的大佬，说是用文件保存之前进程的PID，读取出来将之前的进程kill掉。</p><h1 id="3-二分法的前提是什么？"><a href="#3-二分法的前提是什么？" class="headerlink" title="3.二分法的前提是什么？"></a>3.二分法的前提是什么？</h1><ul><li>数据有序</li><li>数据结构支持随机访问</li></ul><h1 id="4-互斥锁和自旋锁有什么区别"><a href="#4-互斥锁和自旋锁有什么区别" class="headerlink" title="4.互斥锁和自旋锁有什么区别"></a>4.互斥锁和自旋锁有什么区别</h1><ul><li>互斥锁是在内核态进行阻塞等待</li><li>自旋锁是在用户态不断循环沦陷检测锁的状态</li></ul><p>如果使用场景是较长运行的共享资源，那么就使用互斥锁。避免自旋锁不断沦陷检测消耗大量CPU资源。</p><p>如果使用场景的共享资源访问速度快，那么可以使用自旋锁。避免互斥锁频繁进行用户、内核态的转换而造成消耗（这里指其他需要获取锁的进程得进入内核态阻塞等待）</p><h1 id="5-TCP三次握手除了序列号还发了什么其他东西？"><a href="#5-TCP三次握手除了序列号还发了什么其他东西？" class="headerlink" title="5.TCP三次握手除了序列号还发了什么其他东西？"></a>5.TCP三次握手除了序列号还发了什么其他东西？</h1><ul><li>SYN和ACK这些表记位（具体复习三次握手每个阶段的发送）</li><li>双方服务进程的端口号</li><li>起始序列号和对对方发送的SYN报文的应答序列号</li><li>TCP校验和</li><li>TCP窗口大小</li></ul><p>后续建立连接后，就会根据双方的窗口大小和数据的序列号开始相互通信。</p><h1 id="6-子类重写父类函数，子类中该函数声明为private，能否重写成功？"><a href="#6-子类重写父类函数，子类中该函数声明为private，能否重写成功？" class="headerlink" title="6.子类重写父类函数，子类中该函数声明为private，能否重写成功？"></a>6.子类重写父类函数，子类中该函数声明为private，能否重写成功？</h1><p>用下面这个毛坯房来进行测试，在默认情况下，我们子类的重写函数都和父类有相同的作用域声明符。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">test</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">foo1</span>();</span><br><span class="line"><span class="built_in">foo2</span>();</span><br><span class="line"><span class="built_in">foo3</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">foo1</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;A::foo1&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">foo2</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;A::foo2&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">foo3</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;A::foo3&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> : <span class="keyword">public</span> A</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">foo1</span>();</span><br><span class="line"><span class="built_in">foo2</span>();</span><br><span class="line"><span class="built_in">foo3</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">foo1</span><span class="params">()</span> <span class="keyword">override</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;B::foo1&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">foo2</span><span class="params">()</span> <span class="keyword">override</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;B::foo2&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">foo3</span><span class="params">()</span> <span class="keyword">override</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;B::foo3&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">B b;</span><br><span class="line">b.<span class="built_in">test</span>();</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;----&quot;</span> &lt;&lt; endl;</span><br><span class="line">A *bb = &amp;b;</span><br><span class="line">bb-&gt;<span class="built_in">test</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>直接运行，结果也符合预期，目前调用的是子类重写后的虚函数，所有函数都重写成功。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">B::foo1</span><br><span class="line">B::foo2</span><br><span class="line">B::foo3</span><br><span class="line">----</span><br><span class="line">B::foo1</span><br><span class="line">B::foo2</span><br><span class="line">B::foo3</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> : <span class="keyword">public</span> A</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">foo1</span>();</span><br><span class="line"><span class="built_in">foo2</span>();</span><br><span class="line"><span class="built_in">foo3</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">foo2</span><span class="params">()</span> <span class="keyword">override</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;B::foo2&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">foo3</span><span class="params">()</span> <span class="keyword">override</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;B::foo3&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">foo1</span><span class="params">()</span> <span class="keyword">override</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;B::foo1&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 编译能通过，运行输出和上方没区别</span></span><br></pre></td></tr></table></figure><p>我尝试了各种修改作用域的方式，包括将子类中foo3函数改成公有，foo1函数改成私有，都能正常完成重写。这里的作用域声明符只是会改变<strong>子类外是否能调用这个函数</strong>，和能否完成虚函数重写无关！</p><p>请注意，如果你将<strong>继承方式由public改成private</strong>，那么就无法在类外使用父类指针指向子类对象了</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">╰─ g++ test2.cpp -o test</span><br><span class="line">test2.cpp: In function ‘int main()’:</span><br><span class="line">test2.cpp:316:11: error: ‘A’ is an inaccessible base of ‘B’</span><br><span class="line">  A *bb = &amp;b;</span><br></pre></td></tr></table></figure><p>但这依旧不影响子类函数重写父类函数（我的依据是override关键字没有报错）</p><h1 id="7-pthread-create能传入类成员函数的指针吗"><a href="#7-pthread-create能传入类成员函数的指针吗" class="headerlink" title="7.pthread_create能传入类成员函数的指针吗"></a>7.pthread_create能传入类成员函数的指针吗</h1><p>可以，但是必须是静态成员函数。</p><p>如果是普通成员函数，那就需要用中间函数来处理，比如下面的示例代码。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span>* <span class="title">threadFunc</span><span class="params">(<span class="type">void</span>* arg)</span> </span>&#123;</span><br><span class="line">    std::function&lt;<span class="type">void</span>()&gt; func = *<span class="keyword">reinterpret_cast</span>&lt;std::function&lt;<span class="built_in">void</span>()&gt;*&gt;(arg);</span><br><span class="line">    <span class="built_in">func</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::function&lt;<span class="type">void</span>()&gt; myFunc = []() &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Hello from thread!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="type">pthread_t</span> thread;</span><br><span class="line">    <span class="built_in">pthread_create</span>(&amp;thread, <span class="literal">nullptr</span>, &amp;threadFunc, <span class="built_in">reinterpret_cast</span>&lt;<span class="type">void</span>*&gt;(&amp;myFunc));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 等待线程结束</span></span><br><span class="line">    <span class="built_in">pthread_join</span>(thread, <span class="literal">nullptr</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们可以用<code>std::function</code>包装一个类的成员函数，并用<code>std::bind</code>将对象的this指针绑定到第一个参数上。外层再套上一个用于执行该函数的void函数，就能传给<code>pthread_create</code>。</p><p><code>std::function</code>的对象不能直接传给C语言的函数指针，即便参数对应。会报错。</p><h1 id="8-函数内static变量的作用"><a href="#8-函数内static变量的作用" class="headerlink" title="8.函数内static变量的作用"></a>8.函数内static变量的作用</h1><p>在函数内定义一个static变量，该变量只会在进入这个函数的时候初始化一次。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 计算某一月的1号是一年的第几天(不考虑闰年)</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">DayOfYear</span><span class="params">(<span class="type">int</span> month)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> day_array = &#123;<span class="number">0</span>,<span class="number">31</span>,<span class="number">59</span>,<span class="number">90</span>,<span class="number">120</span>,<span class="number">151</span>,<span class="number">181</span>,<span class="number">212</span>,<span class="number">243</span>,<span class="number">273</span>,<span class="number">304</span>,<span class="number">334</span>&#125;;</span><br><span class="line">    <span class="keyword">return</span> day_array[month];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>比如上面的函数，我们定义的day数组就只会在第一次进入这个函数的时候初始化。之后进入这个函数将不在初始化，就节省了初始化一个数组的消耗。出了这个函数后，该数组变量依旧存在。</p><p>请注意，这个static语句并不只是变量只初始化一次，实际上这一行语句在该函数中都只会进行一次</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="title function_">checkFlag</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">static</span> <span class="type">bool</span> flag = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span>(!flag)&#123;</span><br><span class="line">        <span class="comment">// ..进行对应修改</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>比如上面的代码中，如果用正常思维来理解，你会觉得这个if语句每次都会判断为真而进入其中。但实际上flag的定义只会被定义一次，<strong>只要我们在if中将其改成了true</strong>，那么下一次进入该函数的时候，<strong>flag依旧会是true</strong>，<code>static bool flag = false;</code>语句会被直接跳过，并不会再次执行赋值！</p><p>我之前理解的就是flag变量只会被创建一次，但static后的赋值依旧会执行。这个理解是<strong>错误</strong>的！</p><h1 id="9-私有static成员函数的意义？"><a href="#9-私有static成员函数的意义？" class="headerlink" title="9.私有static成员函数的意义？"></a>9.私有static成员函数的意义？</h1><p>这个问题比较有意思，我们知道static函数属于整个类，可以直接通过类名作用域调用。且static函数中无法访问任何非static的成员变量。</p><p>但是，如果给你个static的私有成员函数，它又有什么意义呢？</p><ul><li>私有static成员是无法通过类名调用的</li><li>他也没有办法访问类中非static成员变量</li></ul><p>可以这么理解：我有一个方法只在这个类里面需要，这个方法不需要使用成员变量，可以通过传参实现（比如计算什么的）</p><p>但是，我又不想它的命名污染父作用域。</p><p>那么，我就可以把它写为类的私有成员函数，并加上static告诉其他人，这个函数是一个单纯的方法类，不需要使用类的成员变量。</p><p>当然，加上static只是一个编程习惯罢了，实际上这种情况不写static也无所谓。</p>]]></content>
    
    
    <summary type="html">C++面筋记录 (一) 231021</summary>
    
    
    
    <category term="求职路上一去不复返" scheme="https://blog.musnow.top/categories/%E6%B1%82%E8%81%8C%E8%B7%AF%E4%B8%8A%E4%B8%80%E5%8E%BB%E4%B8%8D%E5%A4%8D%E8%BF%94/"/>
    
    
    <category term="面经" scheme="https://blog.musnow.top/tags/%E9%9D%A2%E7%BB%8F/"/>
    
  </entry>
  
  <entry>
    <title>【Linux】wsl安装的ubuntu不支持POSIX消息队列 | 已解决</title>
    <link href="https://blog.musnow.top/posts/4006913293/"/>
    <id>https://blog.musnow.top/posts/4006913293/</id>
    <published>2023-10-17T04:30:55.000Z</published>
    <updated>2023-10-17T04:30:55.000Z</updated>
    
    <content type="html"><![CDATA[<p>wsl安装的ubuntu不支持POSIX消息队列的解决办法</p><span id="more"></span><h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2023/10/f317c38d511b44a48ff5dc5df48b1c80.png"></p><p>如题，我的win10上安装了wsl的ubuntu后（微软商店下载的wsl的Ubuntu）这个系统内部不支持POSIX的消息队列，虽然有<code>&lt;mqueue.h&gt;</code>头文件，但是没有实现，会报错。</p><p>如果想找个简单的办法呢，那就是用systemV的消息队列，可这是个<strong>虚拟机本地环境问题</strong>，我用virtualbox安装的虚拟机就能正常使用。所以肯定得解决这个问题，换成systemV的消息队列就有点「掩耳盗铃」的意味了。</p><h1 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h1><p>下面是一个POSIX消息队列的demo</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mqueue.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">mqd_t</span> mqID;</span><br><span class="line">    mqID = <span class="built_in">mq_open</span>(<span class="string">&quot;/testmQueue&quot;</span>, O_RDWR | O_CREAT, <span class="number">0666</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (mqID &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;open message queue error...&quot;</span>&lt;&lt;<span class="built_in">strerror</span>(errno)&lt;&lt;endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mq_attr mqAttr;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">mq_getattr</span>(mqID, &amp;mqAttr) &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;get the message queue attribute error&quot;</span>&lt;&lt;endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;mq_flags:&quot;</span>&lt;&lt;mqAttr.mq_flags&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;mq_maxmsg:&quot;</span>&lt;&lt;mqAttr.mq_maxmsg&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;mq_msgsize:&quot;</span>&lt;&lt;mqAttr.mq_msgsize&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;mq_curmsgs:&quot;</span>&lt;&lt;mqAttr.mq_curmsgs&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果编译后运行出现了下面的报错，代表当前系统不支持POSIX消息队列。当前系统下有mqueue头文件，但并没有函数的实现体</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">root@DESKTOP-5SQO6N0:~# ./test</span><br><span class="line">open message queue error...No such file or directory</span><br><span class="line">open message queue error...Function not implemented</span><br></pre></td></tr></table></figure><h1 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h1><p>需要将wsl版本1改成版本2，否则无完整Linux内核支持，无法使用POSIX消息队列。<strong>这也是WSL版本1和2的重大区别之一</strong>。</p><p>用如下命令将当前虚拟机改成wsl2版本，就可以使用了。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">wsl -l -v # 用这个命令查看当前虚拟机的version是不是1</span><br><span class="line">wsl --update # 更新wsl</span><br><span class="line">wsl --set-version 虚拟机名 2  # 把指定虚拟机改成wsl版本2</span><br></pre></td></tr></table></figure><h2 id="再次测试"><a href="#再次测试" class="headerlink" title="再次测试"></a>再次测试</h2><p>正常情况下，上面的消息队列代码应该输出如下内容</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">root@DESKTOP-5SQO6N0:~# ./test</span><br><span class="line">mq_flags:0</span><br><span class="line">mq_maxmsg:10</span><br><span class="line">mq_msgsize:8192</span><br><span class="line">mq_curmsgs:0</span><br></pre></td></tr></table></figure><h2 id="绑定目录"><a href="#绑定目录" class="headerlink" title="绑定目录"></a>绑定目录</h2><p>除了上面这个问题，在使用消息队列之前还可以monut一下路径，参考man手册中的教程（似乎不是必须要做的，mount了这个路径之后能更好地看到现有的消息队列）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mkdir /dev/mqueue</span><br><span class="line">mount -t mqueue none /dev/mqueue</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">wsl安装的ubuntu不支持POSIX消息队列的解决办法</summary>
    
    
    
    <category term="玩上Linux" scheme="https://blog.musnow.top/categories/%E7%8E%A9%E4%B8%8ALinux/"/>
    
    
    <category term="Linux" scheme="https://blog.musnow.top/tags/Linux/"/>
    
    <category term="虚拟机" scheme="https://blog.musnow.top/tags/%E8%99%9A%E6%8B%9F%E6%9C%BA/"/>
    
  </entry>
  
  <entry>
    <title>【微机】DOSBox在windows上的安装和masm的配置</title>
    <link href="https://blog.musnow.top/posts/2839269095/"/>
    <id>https://blog.musnow.top/posts/2839269095/</id>
    <published>2023-10-16T17:49:13.000Z</published>
    <updated>2023-10-16T17:49:13.000Z</updated>
    
    <content type="html"><![CDATA[<p>最近学校学习微型计算机原理与接口技术，需要用到DOSBox来模拟DOS环境进行汇编编程的学习。</p><p>本文记录了如何在windows11&#x2F;10上安装<code>DOSBox0.74</code>并配置<code>masm5</code></p><h1 id="1-安装"><a href="#1-安装" class="headerlink" title="1.安装"></a>1.安装</h1><p>这两个软件我打包上传到了百度云盘。放心，加起来也就2mb，下载应该不会很久</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">链接: https://pan.baidu.com/s/1vjbSL7iwP8WpMVA9K505ZA</span><br><span class="line">提取码: kr4x</span><br></pre></td></tr></table></figure><h2 id="1-1-DOSBox"><a href="#1-1-DOSBox" class="headerlink" title="1.1 DOSBox"></a>1.1 DOSBox</h2><p>点击<code>DOSBox0.74</code>的安装包，无脑下一步安装即可</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2023/10/4ef1475a8016a019d58a90bd6845e70d.png" alt="image-20231017015458406"></p><p>安装出来的图标如下</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2023/10/cc5f29112bed916bb978c49a9a23636d.png" alt="image-20231017015529621"></p><h2 id="1-2-masm5"><a href="#1-2-masm5" class="headerlink" title="1.2 masm5"></a>1.2 masm5</h2><p>找一个空的文件夹，文件路径中不能包含空格、特殊字符和中文，将<code>masm5.zip</code>中的文件全部解压到这个文件夹中，如下图</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2023/10/21d3adc3a7e767d3aa3d0eba69df75e9.png" alt="image-20231017015700958"></p><p>随后修改DOSBox软件的配置文件，右键桌面上Dosbox软件的快捷图标，选择<code>打开文件所在位置</code>找到DOSBox软件的安装路径，点击<code>DOSBox 0.74 Options.bat</code>文件，稍等片刻，会以记事本的方式打开配置文件。</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2023/10/06f84cbaea8c2c0380807a61e01f1a7d.png" alt="image-20231017015801923"></p><p>拉到配置文件最底下，新增如下配置。你只需要修改<code>D:\GAME\masm</code>为你的masm5文件的解压目录就行了。这个文件路径中不能有空格，也不能有特殊字符和中文！</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">MOUNT C D:\GAME\masm</span><br><span class="line">path=%path%; \masm</span><br><span class="line">C: </span><br><span class="line">cd \asm</span><br></pre></td></tr></table></figure><p>配置完成后，启动DOSbox，查看masm命令是否能正常使用。如图所示，没有报错masm命令不存在，那么就是配置好了。</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2023/10/62cba64fa60c2fd957b5968d4387109b.png" alt="image-20231017020002774"></p><h1 id="2-修改DOSBox窗口大小"><a href="#2-修改DOSBox窗口大小" class="headerlink" title="2.修改DOSBox窗口大小"></a>2.修改DOSBox窗口大小</h1><p>默认情况下DOSBox的命令行窗口是非常非常非常小的，我们需要将其改大。同样是修改DOSBox的配置文件，如何打开配置文件参考上文。</p><p>按下图所示修改</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2023/10/2b5bab3f2fc1dbb0a766659d1eb51130.png" alt="image-20231017020347782"></p><p>请注意，这里的1280和1080中间的是大写的X，并不是乘号</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">windowresolution=1280X1080</span><br><span class="line">output=opengl</span><br></pre></td></tr></table></figure><p>修改了之后保存，再重新打开DOSBox，界面就应该会变大了。如果你觉得还是小了，可以修改这里的分辨率，继续让他变大一点。</p><h1 id="3-编译一个汇编程序"><a href="#3-编译一个汇编程序" class="headerlink" title="3.编译一个汇编程序"></a>3.编译一个汇编程序</h1><p>用下面最简单的汇编程序做测试，将如下内容写入到<code>test.asm</code>中，并放入和masm的同一目录下（必须要是同一目录）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">CODE SEGMENT ;USE16</span><br><span class="line">     ASSUME CS:CODE</span><br><span class="line">BEG: MOV DL,&#x27;H&#x27;</span><br><span class="line">     MOV AH, 2 ; 调用2号DOS系统调用输出字符到屏幕上</span><br><span class="line">     INT 21H</span><br><span class="line">     MOV AH, 4CH</span><br><span class="line">     INT 21H</span><br><span class="line">CODE  ENDS</span><br><span class="line">        END BEG</span><br></pre></td></tr></table></figure><p>打开DOSBox，输入如下命令</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">masm test.asm</span><br><span class="line">link test.obj</span><br></pre></td></tr></table></figure><p>输出如下图所示，第一个命令的作用是编译源文件（注意看有没有编译报错）；第二个命令的作用是链接obj文件，最终会弹出来一个警告，不用管他。</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2023/10/60d8190bb6bda5b544018ce777909c0f.png" alt="image-20231017020903839"></p><p>最终执行test，成功输出字符H到终端上。</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2023/10/8cace87b33fc71a4387afa5d7765e8a4.png" alt="image-20231017020946832"></p><p>能走到这一步，就代表你的masm基本环境已经配置好了。可以用来编译运行汇编代码了</p>]]></content>
    
    
    <summary type="html">DOSBox在windows上的安装和masm的配置</summary>
    
    
    
    <category term="差生文具多" scheme="https://blog.musnow.top/categories/%E5%B7%AE%E7%94%9F%E6%96%87%E5%85%B7%E5%A4%9A/"/>
    
    
    <category term="win" scheme="https://blog.musnow.top/tags/win/"/>
    
  </entry>
  
  <entry>
    <title>【Linux】ubuntu/centos8安装zsh终端</title>
    <link href="https://blog.musnow.top/posts/2565866661/"/>
    <id>https://blog.musnow.top/posts/2565866661/</id>
    <published>2023-10-15T09:12:55.000Z</published>
    <updated>2023-10-15T09:12:55.000Z</updated>
    
    <content type="html"><![CDATA[<p>根据这篇知乎文章进行 <a href="https://zhuanlan.zhihu.com/p/514636147">https://zhuanlan.zhihu.com/p/514636147</a></p><h1 id="1-安装zsh"><a href="#1-安装zsh" class="headerlink" title="1.安装zsh"></a>1.安装zsh</h1><p>先安装zsh并设置为默认的终端</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># ubuntu</span></span><br><span class="line">sudo apt install zsh</span><br><span class="line"><span class="comment"># centos </span></span><br><span class="line">sudo yum install zsh util-linux-user</span><br><span class="line"><span class="comment"># 通用</span></span><br><span class="line">chsh -s /bin/zsh</span><br></pre></td></tr></table></figure><blockquote><p>如果centos下找不到chsh命令，参考此博客：<a href="https://blog.csdn.net/FungLeo/article/details/99448425">https://blog.csdn.net/FungLeo/article/details/99448425</a></p></blockquote><p>然后安装oh-my-zsh，这是一个大佬在github上开源的一个zsh配置项，相对方便点</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget --no-check-certificate https://github.com/robbyrussell/oh-my-zsh/raw/master/tools/install.sh -O - | sh </span><br></pre></td></tr></table></figure><p>如果github连不上就用gitee，如果你用的是子用户，那么<strong>这个命令不要用sudo权限执行</strong>！否则后续子用户会因为权限问题没办法使用。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sh -c <span class="string">&quot;<span class="subst">$(curl -fsSL https://gitee.com/shmhlsy/oh-my-zsh-install.sh/raw/master/install.sh)</span>&quot;</span></span><br></pre></td></tr></table></figure><p>最终出现如图所示的界面就是安装成功了。</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2023/10/5ebc935468a46d95ac77e65dc879c66d.png" alt="image-20231015205326739"></p><h1 id="2-安装zsh插件"><a href="#2-安装zsh插件" class="headerlink" title="2.安装zsh插件"></a>2.安装zsh插件</h1><p>安装这两个最常用的插件就可以了</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># zsh-autosuggestions 命令行命令键入时的历史命令建议</span></span><br><span class="line">git <span class="built_in">clone</span> https://github.com/zsh-users/zsh-autosuggestions <span class="variable">$&#123;ZSH_CUSTOM:-~/.oh-my-zsh/custom&#125;</span>/plugins/zsh-autosuggestions</span><br><span class="line"><span class="comment"># zsh-syntax-highlighting 命令行语法高亮插件</span></span><br><span class="line">git <span class="built_in">clone</span> https://gitee.com/Annihilater/zsh-syntax-highlighting.git <span class="variable">$&#123;ZSH_CUSTOM:-~/.oh-my-zsh/custom&#125;</span>/plugins/zsh-syntax-highlighting</span><br></pre></td></tr></table></figure><p>这个历史命令建议的插件是用方向键👉来进行补全的，不要和我一样傻乎乎按tab。</p><h1 id="3-配置文件和主题"><a href="#3-配置文件和主题" class="headerlink" title="3.配置文件和主题"></a>3.配置文件和主题</h1><p>原文中的配置文件有很多地方都不对劲，需要我们修改；</p><p>首先是<code>oh-my-zsh</code>的安装路径，需要改成你的用户家目录下，然后需要先安装一下<code>powerlevel10k</code>主题，这个主题很好用！</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> --depth=1 https://gitee.com/romkatv/powerlevel10k.git <span class="variable">$&#123;ZSH_CUSTOM:-<span class="variable">$HOME</span>/.oh-my-zsh/custom&#125;</span>/themes/powerlevel10k</span><br></pre></td></tr></table></figure><p>配置文件<code>~/.zshrc</code>改成如下内容（建议将原本的配置文件cp备份一下）其中的zsh安装路径一定要修改，否则无法正常配置！</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 防止中文乱码</span></span><br><span class="line"><span class="built_in">export</span> LC_ALL=en_US.UTF-8</span><br><span class="line"><span class="built_in">export</span> LANG=en_US.UTF-8</span><br><span class="line"><span class="comment"># oh-my-zsh的安装路径（zsh的配置路径）</span></span><br><span class="line">ZSH=<span class="string">&quot;/home/你的用户名/.oh-my-zsh&quot;</span></span><br><span class="line"><span class="comment"># ZSH_THEME=&quot;robbyrussell&quot;</span></span><br><span class="line"><span class="comment"># 设置字体模式以及配置命令行的主题</span></span><br><span class="line">POWERLEVEL9K_MODE=<span class="string">&#x27;nerdfont-complete&#x27;</span></span><br><span class="line"><span class="comment"># ZSH_THEME=&quot;agnoster&quot;</span></span><br><span class="line">ZSH_THEME=<span class="string">&quot;powerlevel10k/powerlevel10k&quot;</span> <span class="comment"># 主题推荐这个，需要进行安装</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 启动错误命令自动更正</span></span><br><span class="line">ENABLE_CORRECTION=<span class="string">&quot;true&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 在命令执行的过程中，使用小红点进行提示</span></span><br><span class="line">COMPLETION_WAITING_DOTS=<span class="string">&quot;true&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 配置要使用的插件</span></span><br><span class="line">plugins=(</span><br><span class="line">        git</span><br><span class="line">        extract</span><br><span class="line">        zsh-autosuggestions</span><br><span class="line">        zsh-syntax-highlighting</span><br><span class="line">)</span><br><span class="line"><span class="built_in">source</span> <span class="variable">$ZSH</span>/oh-my-zsh.sh</span><br><span class="line"><span class="built_in">source</span> <span class="variable">$ZSH_CUSTOM</span>/plugins/zsh-autosuggestions/zsh-autosuggestions.zsh</span><br><span class="line"><span class="comment"># python虚拟环境相关设置</span></span><br><span class="line"><span class="keyword">if</span> [ -f /usr/local/bin/virtualenvwrapper.sh ];</span><br><span class="line"><span class="keyword">then</span></span><br><span class="line">    <span class="built_in">export</span> WORKON_HOME=<span class="variable">$HOME</span>/.virtualenvs</span><br><span class="line">    <span class="built_in">export</span> VIRTUALENVWRAPPER_PYTHON=/usr/bin/python3</span><br><span class="line">    <span class="built_in">source</span> /usr/local/bin/virtualenvwrapper.sh</span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure><p>改好了之后，启用他，然后就可以了；执行下方命令后，就会自动弹出<code>powerlevel10k</code>主题的配置引导过程。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">source ~/.zshrc</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2023/10/684bc428ce3e1369d8d60997845180a8.png" alt="image-20231015205703586"></p><p>如果设置完毕后，你对<code>powerlevel10k/powerlevel10k</code>的配置又不满意了，可以执行如下命令重新配置</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">p10k configure</span><br></pre></td></tr></table></figure><p>你可能也会遇到如下报错，原因未知，但似乎不影响使用</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">❯ ls</span><br><span class="line">_p9k_worker_stop:zle:4: No handler installed for fd 12</span><br><span class="line">_p9k_worker_stop:5: failed to close file descriptor 12: bad file descriptor</span><br></pre></td></tr></table></figure><p>如上报错解决办法参考github的issue内的说明</p><p><a href="https://github.com/romkatv/powerlevel10k/issues/1554">https://github.com/romkatv/powerlevel10k/issues/1554</a></p><p>在配置文件<code>.zshrc</code>的末尾加上下面这一行，然后source让其生效就可以了</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">unset ZSH_AUTOSUGGEST_USE_ASYNC</span><br></pre></td></tr></table></figure><h1 id="4-使用小技巧"><a href="#4-使用小技巧" class="headerlink" title="4.使用小技巧"></a>4.使用小技巧</h1><p>输入命令的时候键入tab，会弹出一些命令的提示</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2023/10/486730657def543552dc7a82163410e9.png" alt="image-20231015210623737"></p><p>输入之前写过的命令的时候，会出现历史命令提示，使用方向键右👉就可以补全这个命令</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2023/10/eb1e448943c27dd0bdeb29267b26d252.png" alt="image-20231015210708230"></p><p>zsh主要就是这一点非常的方便，至于会不会和默认的<code>/bin/bash</code>有性能差异，那就不知道了。</p><p>另外，在zsh终端中直接重定向会卡住，如下命令就会阻塞掉。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt; 文本文件</span><br></pre></td></tr></table></figure><p>所以要用echo（一般我是用来清空某个文本文件）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo &gt; 文本文件</span><br></pre></td></tr></table></figure><h1 id="5-zsh安装后git中文乱码"><a href="#5-zsh安装后git中文乱码" class="headerlink" title="5.zsh安装后git中文乱码"></a>5.zsh安装后git中文乱码</h1><p>安装zsh后用<code>git log</code>查看提交信息的时候发现中文乱码。</p><h2 id="5-1-修改zsh配置文件"><a href="#5-1-修改zsh配置文件" class="headerlink" title="5.1 修改zsh配置文件"></a>5.1 修改zsh配置文件</h2><p>其实上文中提到的配置文件里面已经有这两个配置项了，说明问题不在这里</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># 防止中文乱码</span><br><span class="line">export LC_ALL=en_US.UTF-8</span><br><span class="line">export LANG=en_US.UTF-8</span><br></pre></td></tr></table></figure><h2 id="5-2-执行git配置"><a href="#5-2-执行git配置" class="headerlink" title="5.2 执行git配置"></a>5.2 执行git配置</h2><p>一篇博客说要执行下面的git命令，也没有用</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">git config --global core.quotepath false </span><br><span class="line">git config --global gui.encoding utf-8 </span><br><span class="line">git config --global i18n.commit.encoding utf-8 </span><br><span class="line">git config --global i18n.logoutputencoding utf-8 </span><br><span class="line">set LESSCHARSET=utf-8</span><br></pre></td></tr></table></figure><h2 id="5-3-修改系统字符配置"><a href="#5-3-修改系统字符配置" class="headerlink" title="5.3 修改系统字符配置"></a>5.3 修改系统字符配置</h2><p>另外一篇博客说要修改系统的字符集配置，如下环境变量</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">export LESSCHARSET=utf-8</span><br></pre></td></tr></table></figure><p>执行后确实ok了，可以编辑<code>/etc/profile</code>文件，在该文件末尾追加如下内容让其始终生效</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">export LESSCHARSET=utf-8</span><br></pre></td></tr></table></figure><p>随后用source命令刷新这个配置文件即可。</p><h1 id="6-粘贴文本很慢的问题"><a href="#6-粘贴文本很慢的问题" class="headerlink" title="6.粘贴文本很慢的问题"></a>6.粘贴文本很慢的问题</h1><p>参考 <a href="https://github.com/zsh-users/zsh-autosuggestions/issues/238">zsh-users&#x2F;zsh-autosuggestions&#x2F;issues&#x2F;238</a> 解决这个问题</p><p>在<code>.zshrc</code>之后添加如下配置项</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"># This speeds up pasting w/ autosuggest</span><br><span class="line"># https://github.com/zsh-users/zsh-autosuggestions/issues/238</span><br><span class="line">pasteinit() &#123;</span><br><span class="line">  OLD_SELF_INSERT=$&#123;$&#123;(s.:.)widgets[self-insert]&#125;[2,3]&#125;</span><br><span class="line">  zle -N self-insert url-quote-magic # I wonder if you&#x27;d need `.url-quote-magic`?</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">pastefinish() &#123;</span><br><span class="line">  zle -N self-insert $OLD_SELF_INSERT</span><br><span class="line">&#125;</span><br><span class="line">zstyle :bracketed-paste-magic paste-init pasteinit</span><br><span class="line">zstyle :bracketed-paste-magic paste-finish pastefinish</span><br></pre></td></tr></table></figure><p>配置了之后，source使其生效。</p><p>这时候在终端里面粘贴内容的时候，就不会一个一个字符地打印出来了。那样实在是太慢了。</p>]]></content>
    
    
    <summary type="html">ubuntu/centos8虚拟机安装zsh终端</summary>
    
    
    
    <category term="玩上Linux" scheme="https://blog.musnow.top/categories/%E7%8E%A9%E4%B8%8ALinux/"/>
    
    
    <category term="Linux" scheme="https://blog.musnow.top/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>【虚拟机】WIN11的WSL安装CentOS8Stream虚拟机</title>
    <link href="https://blog.musnow.top/posts/4065446782/"/>
    <id>https://blog.musnow.top/posts/4065446782/</id>
    <published>2023-10-15T03:30:55.000Z</published>
    <updated>2023-10-15T03:30:55.000Z</updated>
    
    <content type="html"><![CDATA[<p>本人所使用的系统是 <code>win11 22H2 家庭版</code>，如果你不是非CentOS不可，强烈建议直接去微软应用商店里面下载Ubuntu，全自动安装到WSL，啥都不用管。(就是好像没办法选择安装路径)</p><h1 id="1-启用WSL"><a href="#1-启用WSL" class="headerlink" title="1.启用WSL"></a>1.启用WSL</h1><p>刚开始安装WSL的时候，参考的是<a href="https://blog.csdn.net/qq_38442140/article/details/120724215">这个博客</a>。说实话，我个人并不喜欢这篇博客。因为里面遗漏了很多东西，并且在不恰当的位置贴出了命令，导致读者会误以为是需要执行这些命令。</p><p>比如我就理解错误，先执行了设置wsl默认版本为2的命令，<strong>这个命令先不要执行</strong>！后文会告诉你为什么。</p><p>这篇博客中对开启wsl的设置的位置描述也不完全，看上去像从网上哪里抄过来的win10的设置逻辑（win11的位置完全不一样）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">该博客原文：在windows设置中打开【启用或关闭Windwos功能】，勾选【适用于Linux的Windwos子系统】，点击确定后会系统会提示重启，选择确认即可</span><br></pre></td></tr></table></figure><p>实际上在win11中，需要多点好几个地方才能找到这个设置的位置</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">右键桌面 - 个性化 - 进入win11设置界面 - 应用 - 可选功能 - (往下滑)更多windows功能</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2023/10/542d2e77f4272f4598629626e44ee2a7.png" alt="image-20231015104701566"></p><blockquote><p>这都是我对一个<strong>不完善博客</strong>的吐槽，但并没有贬低这个教程的意思啊！至少他告诉我基本步骤应该做哪些。</p><p>为什么我要吐槽呢？因为这种写的不全的博客经常会让读者得去重新搜索某些设置的位置，而作者明明是已经走过这个流程的。博客里面作者的截图明显是windows11，但他提供的设置却是win10中的旧位置。多花30秒写清楚位置并带上截图，不知道能节省读者多少时间……如果你体会过查资料的时候阅读这些「断头短尾」的博客，应该也能体会到我的心情。</p></blockquote><p>回到正题。在更多 windows 功能选项框中（win10&#x2F;11的这个选项框基本相同），勾选上下面的几个选项，三个都要勾选上！</p><ul><li>适用于 Linux 的 Windows 子系统</li><li>虚拟机平台</li><li>windows 虚拟机监控程序平台</li></ul><p>点击确定，就成功启用了 WSL。系统会弹出一个进度条，下载一些东西。</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2023/10/61b796407e655ae94c7ff535edaeae69.png" alt="image-20231015104951463"></p><p>处理完毕后，WIN+R输入cmd，打开命令行工具，在命令行工具中输入<code>wsl -l -v</code>命令，有相关输出就是启用成功了！</p><p>初始化情况下，执行这个命令，应该会提示你当前什么虚拟机都没有安装。</p><h1 id="2-安装Centos8"><a href="#2-安装Centos8" class="headerlink" title="2.安装Centos8"></a>2.安装Centos8</h1><h2 id="2-1-下载系统zip"><a href="#2-1-下载系统zip" class="headerlink" title="2.1 下载系统zip"></a>2.1 下载系统zip</h2><p>去 <a href="https://github.com/wsldl-pg/CentWSL/releases/tag/8.1.1911.1">github&#x2F;wsldl-pg&#x2F;CentWSL</a> 上下载适用于wsl的<code>CentOS8</code>系统的zip</p><blockquote><p>这个也可以：<a href="https://github.com/mishamosher/CentOS-WSL">https://github.com/mishamosher/CentOS-WSL</a></p></blockquote><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2023/10/c42449d2875a2e60a296953f2bfcfae8.png" alt="image-20231015104110576"></p><p>把zip解压到你想安装虚拟机的位置（一定要是一个空文件夹），然后右键<code>CentOS8.exe</code>，以管理员身份运行。</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2023/10/a13a0b3e0db1dab54e499c9c7bf5ddc6.png" alt="image-20231015104455537"></p><h2 id="2-2-报错HRESULT-0x80370102解决"><a href="#2-2-报错HRESULT-0x80370102解决" class="headerlink" title="2.2 报错HRESULT:0x80370102解决"></a>2.2 报错HRESULT:0x80370102解决</h2><p>安装CentOS8的时候，就遇到了这个<strong>issue</strong>中的问题👇</p><p><a href="https://github.com/wsldl-pg/CentWSL/issues/36">github.com&#x2F;wsldl-pg&#x2F;CentWSL&#x2F;issues&#x2F;36</a></p><p>用管理员身份运行<code>CentOS8.exe</code>之后，弹出的终端会输出如下内容</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ERROR:Installation Failed!</span><br><span class="line">HRESULT:0x80370102</span><br></pre></td></tr></table></figure><p>根据<a href="https://github.com/wsldl-pg/CentWSL/issues/36">该issue</a> 中最后一个回复的解决办法，我先将wsl版本设置回了1（这就是为什么前文说不要先设置为默认wsl2）</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2023/10/d19e82cbafe8e5eba20d8c6eef64687a.png" alt="image-20231015112649042"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wsl --set-default-version 1</span><br></pre></td></tr></table></figure><p>重复如上安装步骤（以管理员身份运行<code>CentOS8.exe</code>），就成功安装了虚拟机。在win11的文件管理器左侧会多出来一个Linux图标，里面有CentOS8的系统里面的文件。</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2023/10/721c72e099c746ab5f618282dc205e27.png" alt="image-20231015105247440"></p><p>在windows的powershell或者cmd中，输入<code>wsl</code>，就可以进入CentOS8的bash；见下图，我们已经成功安装好了一个CentOS8的虚拟机。内部的文件就是CentOS8系统的默认文件。</p><p>在内部执行<code>exit</code>命令，就可以退出wsl虚拟机，回到windows的终端下。</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2023/10/fa9eb9786e59758af270ae93f120ed51.png" alt="image-20231015105338512"></p><p>而且WSL有个最大的好处，就是它能自动挂载windows下的文件到<code>/mnt</code>目录下，这个目录里面可以看到我的win11宿主机的3个硬盘分区；windows的文件资源管理器里面也可以看到Linux中的文件，<strong>方便我们在windows和linux下互传文件</strong>（就不需要用sftp工具了）</p><p>特别是如果你需要写带Doxygen文档的项目，在生成Doxygen的html后，就能直接从这里在windows的浏览器中打开网页，而不需要用sftp或者其他工具传到windows下再打开了！</p><blockquote><p>当然，你也可以用带GUI的Linux系统来解决这个问题。</p></blockquote><h2 id="2-3-更新为WSL2"><a href="#2-3-更新为WSL2" class="headerlink" title="2.3 更新为WSL2"></a>2.3 更新为WSL2</h2><p>使用<code>wsl -l -v</code>命令，可以看到当前运行的wsl虚拟机，版本是1</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">PS C:\Users\S2522\Desktop&gt; wsl -l -v</span><br><span class="line">  NAME       STATE           VERSION</span><br><span class="line">* CentOS8    Running         1</span><br></pre></td></tr></table></figure><p>我们可以将其升级为WSL2版本，但是这里会告诉你需要更新内核组件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">PS C:\Users\S2522\Desktop&gt; wsl --set-version CentOS8 2</span><br><span class="line">正在进行转换，这可能需要几分钟时间...</span><br><span class="line">有关与 WSL 2 的主要区别的信息，请访问 https://aka.ms/wsl2</span><br><span class="line">WSL 2 需要更新其内核组件。有关信息，请访问 https://aka.ms/wsl2kernel</span><br></pre></td></tr></table></figure><p>那就更新呗！<a href="https://aka.ms/wsl2kernel">微软官方文档</a> 中会告诉你需要 <code>wsl.exe --install</code> 或 <code>wsl.exe --update</code>命令。</p><p>这里我执行了<code>wsl --update</code>命令，执行后会弹窗要你提供管理权限，并出现一个进度条，等他跑完就行。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">PS C:\Users\S2522\Desktop&gt; wsl --update</span><br><span class="line">正在安装: 适用于 Linux 的 Windows 子系统</span><br><span class="line">已安装 适用于 Linux 的 Windows 子系统。</span><br></pre></td></tr></table></figure><p>更新好了，再重新执行<code>wsl --set-version CentOS8 2</code>升级命令，会提示你正在执行转换，需要等待一会。</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2023/10/a870772fe8f185d55935bb2eb1d720d3.png" alt="image-20231015105730332"></p><p>最终成功转换了，使用命令<code>wsl -l -v</code>里面显示的版本也是2了。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">PS C:\Users\S2522\Desktop&gt; wsl --set-version CentOS8 2</span><br><span class="line">有关与 WSL 2 关键区别的信息，请访问 https://aka.ms/wsl2</span><br><span class="line"></span><br><span class="line">正在进行转换，这可能需要几分钟时间。</span><br><span class="line">操作成功完成。</span><br><span class="line">PS C:\Users\S2522\Desktop&gt; wsl -l -v</span><br><span class="line">  NAME       STATE           VERSION</span><br><span class="line">* CentOS8    Stopped         2</span><br></pre></td></tr></table></figure><p>搞定！现在我们就有一个方便的CentOS8的WSL环境啦！</p><p>可以用如下命令，将当前的CentOS8设置为默认的wsl虚拟机。这样在windows命令行中执行wsl或者bash命令，就能直接进入CentOS8中。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wslconfig /setdefault CentOS8</span><br></pre></td></tr></table></figure><p>重启电脑后，在powershell的下拉栏中会自动出现CentOS8的选项，点击它也能进入wsl虚拟机环境中。</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2023/10/e40e68ef976f8ef57c9f73d03a8dc892.png" alt="image-20231015134927313"></p><h1 id="3-解决yum报错问题"><a href="#3-解决yum报错问题" class="headerlink" title="3.解决yum报错问题"></a>3.解决yum报错问题</h1><p>因为这个CentOS的镜像是最小安装版本（类似于Docker安装的CentOS），所以内部的yum源都是坏掉的。执行<code>yum update</code>会出现如下报错。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@7945R9P ~]# yum -y update</span><br><span class="line">Failed to set locale, defaulting to C.UTF-8</span><br><span class="line">CentOS-8 - AppStream                                                                     68  B/s |  38  B     00:00</span><br><span class="line">Failed to download metadata for repo &#x27;AppStream&#x27;</span><br><span class="line">Error: Failed to download metadata for repo &#x27;AppStream&#x27;</span><br></pre></td></tr></table></figure><p>这时候需要进行yum源的重新设置，参考本站博客解决这个问题就行</p><p> <a href="https://blog.musnow.top/posts/1296728696/">【Docker】配置CentOS容器时出现 Error Failed to download metadata for repo ‘appstream’ Cannot prepare internal mirrorlist | 转载</a></p><p>搞定yum之后，就可以正常安装你想要的开发软件了。这个系统很轻量，sudo和passwd等很多完整系统会自带的命令都没有，需要自行安装一些。</p><p>另外，我写过一个CentOS8的初始化脚本，可以自动化安装一些软件，这里安装的软件并不一定是你想要的，请酌情参考：<a href="https://gitee.com/musnows/centos8-init">https://gitee.com/musnows/centos8-init</a></p><hr><p>而且，默认情况下的ls命令也没有颜色输出，需要修改bash配置来设置命令别名</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">alias</span> <span class="built_in">ls</span>=<span class="string">&#x27;ls --color=auto&#x27;</span></span><br></pre></td></tr></table></figure><p>你也可以根据自己的喜好，改成zsh或者其他终端。</p><h1 id="4-vscode连接"><a href="#4-vscode连接" class="headerlink" title="4.vscode连接"></a>4.vscode连接</h1><p>普通的虚拟机我们需要用vscode的remote ssh插件来连接，但是WSL主机我们直接用vsc的<strong>WSL插件</strong>来连接就行了，使用的效果和remote ssh插件是相同的</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2023/10/4211aec9f60b6984a3a680c1a900b5c8.png" alt="image-20231015111412100"></p><p>在左侧这个远程连接控制器中（和Remote ssh是同一个位置），找到上方的下拉条，改成WSL目标，就能看到我们的CentOS8虚拟机。点击连接它就可以了。</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2023/10/344e4ab417ab6246fa14351b211f016c.png" alt="image-20231015111429863"></p><p>但是vscode默认链接的是root用户，一般情况下肯定不会在root下写代码的。所以需要配置一下子用户</p><p>修改虚拟机中的<code>/etc/wsl.conf</code>文件，添加下面两行</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[user]</span><br><span class="line">default=用户名</span><br></pre></td></tr></table></figure><p>然后回到windows的命令行，重启wsl</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wsl --shutdown CentOS8</span><br></pre></td></tr></table></figure><p>再次启动wsl，这样vsc就能默认链接你的子用户了。</p><h1 id="5-修改wsl资源限制"><a href="#5-修改wsl资源限制" class="headerlink" title="5.修改wsl资源限制"></a>5.修改wsl资源限制</h1><p>默认情况下，<strong>wsl2的虚拟机能访问到完整的系统资源</strong>，包括所有CPU核心和内存。</p><p>这就会导致如果Linux下对一些东西进行了缓存而没有及时清理，Windows是没办法回收这部分内存的。<strong>最终就导致我们Windows宿主机没有足够的内存可用了</strong>，这怎么行？</p><blockquote><p>这种情况下，一般windows系统会把wsl直接给干掉，那我们虚拟机里面跑的活也没办法完成了。要知道，Linux可是很喜欢cache内存的，很容易会把宿主机的内存给干没。</p></blockquote><p>为了解决这个问题，我们需要设置wsl的虚拟机内存&#x2F;CPU限制。</p><p>在<strong>Linux下</strong>可以用这两个命令来查看cpu和内存的配置信息，刚开始的时候应该是和你的宿主机的CPU和内存一样。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cat</span> /proc/cpuinfo | grep processor <span class="comment"># 查看cpu核心数量</span></span><br><span class="line"><span class="built_in">cat</span> /proc/meminfo | grep Total     <span class="comment"># 查看内存信息</span></span><br></pre></td></tr></table></figure><p>在windows的<strong>C盘</strong>的<strong>用户文件夹</strong>下，创建一个<code>.wslconfig</code>文件，并在内部写入限制</p><ul><li>processors是cpu核数限制</li><li>memory和swap都是内存限制</li></ul><p>顶多设置为宿主机内存的一半，避免宿主机卡顿。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[wsl2]</span><br><span class="line">processors=8</span><br><span class="line">memory=8GB</span><br><span class="line">swap=8GB</span><br></pre></td></tr></table></figure><p>这个配置文件的路径是（windows下）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">C:\Users\你的用户名\.wslconfig</span><br></pre></td></tr></table></figure><p>随后在windows的终端中使用如下命令，终止这个wsl虚拟机</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">PS C:\Users\S2522\Desktop&gt; wsl --shutdown CentOS8</span><br><span class="line">PS C:\Users\S2522\Desktop&gt; wsl -l -v</span><br><span class="line">  NAME       STATE           VERSION</span><br><span class="line">* CentOS8    Stopped         2</span><br></pre></td></tr></table></figure><p>wsl命令中并没有<code>--start</code>选项，我们直接用wsl命令，就会自动重启并进入这个虚拟机。</p><p>这时候再在虚拟机内部看看CPU和内存信息，就可以看到你刚刚配置的性能限制结果了。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">[root@7945R9P ~]# cat /proc/cpuinfo | grep processor</span><br><span class="line">processor       : 0</span><br><span class="line">processor       : 1</span><br><span class="line">processor       : 2</span><br><span class="line">processor       : 3</span><br><span class="line">processor       : 4</span><br><span class="line">processor       : 5</span><br><span class="line">processor       : 6</span><br><span class="line">processor       : 7</span><br><span class="line">[root@7945R9P ~]# cat /proc/meminfo | grep Total</span><br><span class="line">MemTotal:        8136640 kB</span><br><span class="line">SwapTotal:       8388608 kB</span><br><span class="line">VmallocTotal:   34359738367 kB</span><br><span class="line">HugePages_Total:       0</span><br></pre></td></tr></table></figure><h2 id="删除wsl主机"><a href="#删除wsl主机" class="headerlink" title="删除wsl主机"></a>删除wsl主机</h2><p>删除虚拟机的命令如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wsl --unregister &lt;DistributionName&gt;</span><br></pre></td></tr></table></figure><p>更多命令参考微软官网 <a href="https://learn.microsoft.com/zh-cn/windows/wsl/basic-commands">https://learn.microsoft.com/zh-cn/windows/wsl/basic-commands</a></p><h1 id="6-启用systemctl"><a href="#6-启用systemctl" class="headerlink" title="6.启用systemctl"></a>6.启用systemctl</h1><p>我们的系统里面有systemctl命令，但是没有办法使用。网上有些教程说用service命令来替代，但CentOS中是没有service命令的。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@7945R9P bison-3.8]# systemctl</span><br><span class="line">System has not been booted with systemd as init system (PID 1). Can&#x27;t operate.</span><br><span class="line">Failed to connect to bus: Host is down</span><br></pre></td></tr></table></figure><h2 id="6-1-distrod-第三方工具"><a href="#6-1-distrod-第三方工具" class="headerlink" title="6.1 distrod 第三方工具"></a>6.1 distrod 第三方工具</h2><p>我们需要用distrod来安装systemctl的组件，才能成功启用它。具体教程参考github仓库的README中的介绍。不是很难</p><blockquote><p><a href="https://github.com/nullpo-head/wsl-distrod">https://github.com/nullpo-head/wsl-distrod</a></p></blockquote><p>先下载一个自动安装的脚本（连不上github会报ssl或者timeout错误，请使用其他办法下载这个脚本再丢到虚拟机里面去就行）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">curl -L -O &quot;https://raw.githubusercontent.com/nullpo-head/wsl-distrod/main/install.sh&quot;</span><br><span class="line">chmod +x install.sh</span><br><span class="line">sudo ./install.sh install</span><br></pre></td></tr></table></figure><p>然后用下面两个命令之一来启动（第一个命令是会在windows开机自动启动的）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">/opt/distrod/bin/distrod enable --start-on-windows-boot</span><br><span class="line">/opt/distrod/bin/distrod enable</span><br></pre></td></tr></table></figure><p>更多内容相见<a href="https://github.com/nullpo-head/wsl-distrod">该仓库README</a>；</p><p>请注意，执行第一个自启动命令的时候需要windows的管理员权限，此时需要输入的是系统登录的微软账户的密码（不是你的PIN），看下面，我第一次输入密码输入的就是PIN，显示错误，第二次输入了微软账户的密码才成功。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">[root@7945R9P pkg]# /opt/distrod/bin/distrod enable --start-on-windows-boot</span><br><span class="line">[Distrod] Distrod has been enabled. Now your shell will start under systemd.</span><br><span class="line">[Distrod] Enabling atuomatic startup of Distrod. UAC dialog will appear because scheduling</span><br><span class="line">a task requires the admin privilege. Please hit enter to proceed.</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Error</span><br><span class="line">It seems the task has not been scheduled successfully. You may have typed a wrong password, or you may not have the</span><br><span class="line">necessary administrative privileges. Do you want to retry?</span><br><span class="line">[Y] Yes  [N] No  [?] 帮助 (默认值为“Y”): y</span><br><span class="line">Enabling autostart has succeeded.</span><br><span class="line">[Distrod] Distrod will now start automatically on Windows startup.</span><br></pre></td></tr></table></figure><p>操作完成后，需要重启虚拟机。用如下命令将对应的wsl虚拟机关闭就行了，再次执行wsl就会重启这个虚拟机。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wsl --terminate CentOS8</span><br></pre></td></tr></table></figure><p>如图，我的systemctl命令已经生效。</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2023/10/9340e7964572037fbd3b58f1b379b177.png" alt="image-20231015150251531"></p><p>也能正常通过systemctl命令启动mariadb数据库</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2023/10/6edf311cf4a5dd1749328456a0008255.png" alt="image-20231015150404823"></p><h2 id="6-2-微软官方（推荐）"><a href="#6-2-微软官方（推荐）" class="headerlink" title="6.2 微软官方（推荐）"></a>6.2 微软官方（推荐）</h2><blockquote><p>参考 <a href="https://zhuanlan.zhihu.com/p/569883693">https://zhuanlan.zhihu.com/p/569883693</a></p></blockquote><p>查看wsl版本号命令为： <code>wsl --version</code>，如果此命令未正常回显版本号，或版本号低于<code>0.67.6</code>，那么你安装的wsl还不支持systemd。如下，我的wsl版本已经是支持的了。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">PS C:\Users\S2522\Desktop&gt; wsl --version</span><br><span class="line">WSL 版本： 1.2.5.0</span><br><span class="line">内核版本： 5.15.90.1</span><br><span class="line">WSLg 版本： 1.0.51</span><br><span class="line">MSRDC 版本： 1.2.3770</span><br><span class="line">Direct3D 版本： 1.608.2-61064218</span><br><span class="line">DXCore 版本： 10.0.25131.1002-220531-1700.rs-onecore-base2-hyp</span><br><span class="line">Windows 版本： 10.0.22621.2134</span><br></pre></td></tr></table></figure><p>进入wsl的CentOS虚拟机，执行如下命令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> -e <span class="string">&quot;[boot]\nsystemd=true&quot;</span> | sudo <span class="built_in">tee</span> -a /etc/wsl.conf</span><br></pre></td></tr></table></figure><p>随后exit退出虚拟机，<strong>回到windows终端命令行</strong>，重启wsl</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wsl <span class="literal">--shutdown</span></span><br></pre></td></tr></table></figure><p>随后再次在windows命令行下执行wsl命令，重启这个虚拟机；</p><p>重启wsl虚拟机后，在<strong>虚拟机内部</strong>执行如下命令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ps --no-headers -o <span class="built_in">comm</span> 1</span><br></pre></td></tr></table></figure><ul><li>如果这个命令返回结果是<strong>systemd</strong>，则代表我们的<code>systemctl</code>命令已经可以使用。</li><li>如果返回的是<code>init</code>，则设置失败</li></ul><p>如下图，我已经设置成功了！</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2023/10/a072fdd5b53abc04cf444c1ab0ac9ad2.png" alt="image-20231015204810685"></p><p>微软官方支持的systemd还是有一点是优于distrod的，那就是启用了官方 systemd 的 wsl2 实例，在用户停止操作后，<strong>会自动关闭</strong>，和未启用 systemd 时的特性一样，这有利于节约电脑的计算资源。</p>]]></content>
    
    
    <summary type="html">win11安装wsl和CentOS8Stream虚拟机</summary>
    
    
    
    <category term="玩上Linux" scheme="https://blog.musnow.top/categories/%E7%8E%A9%E4%B8%8ALinux/"/>
    
    
    <category term="Linux" scheme="https://blog.musnow.top/tags/Linux/"/>
    
    <category term="虚拟机" scheme="https://blog.musnow.top/tags/%E8%99%9A%E6%8B%9F%E6%9C%BA/"/>
    
  </entry>
  
  <entry>
    <title>【七牛云】artalk表情遇到跨域访问问题</title>
    <link href="https://blog.musnow.top/posts/489538601/"/>
    <id>https://blog.musnow.top/posts/489538601/</id>
    <published>2023-10-02T04:35:28.000Z</published>
    <updated>2023-10-02T04:35:28.000Z</updated>
    
    <content type="html"><![CDATA[<p>如题，当我在我自己编写的文档站点 <a href="https://khl-py.eu.org/">https://khl-py.eu.org/</a> 访问我的artalk服务时，其中包含一个artalk表情的请求，被浏览器的跨域策略给挡住了。这会导致artalk评论中无法发送表情（虽然无伤大雅）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Access to fetch at &#x27;https://img.musnow.top/i/artalk-emoji.json&#x27; from origin &#x27;https://khl-py.eu.org&#x27; has been blocked by CORS policy: No &#x27;Access-Control-Allow-Origin&#x27; header is present on the requested resource. If an opaque response serves your needs, set the request&#x27;s mode to &#x27;no-cors&#x27; to fetch the resource with CORS disabled.</span><br></pre></td></tr></table></figure><p>百度了一下，我们需要在七牛云的CDN策略中进行配置（我的七牛云KODO是绑定到CDN上，通过CDN进行访问的）</p><p>找到CDN界面中的<strong>HTTP响应头配置</strong></p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2023/10/6e1119859945ce9b07928a2bff2643d8.png" alt="image-20231002222846450"></p><p>点击修改配置，添加如下两点</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2023/10/6b3b5f2bc783ef6bf7cc614d5bc2a1e7.png" alt="image-20231002222920540"></p><p>保存后过一会，就不会出现这个跨域访问问题了。至于这部分设置会不会导致有人盗刷你的CDN流量，仍待更多的观察。</p><p>另外，如果你的CDN还开启了防盗链，还需要把对应域名填入防盗链的白名单中！</p>]]></content>
    
    
    <summary type="html">七牛云存放的artalk表情遇到跨域访问问题</summary>
    
    
    
    <category term="差生文具多" scheme="https://blog.musnow.top/categories/%E5%B7%AE%E7%94%9F%E6%96%87%E5%85%B7%E5%A4%9A/"/>
    
    
    <category term="图床" scheme="https://blog.musnow.top/tags/%E5%9B%BE%E5%BA%8A/"/>
    
  </entry>
  
  <entry>
    <title>【C语言】clock_gettime函数的使用</title>
    <link href="https://blog.musnow.top/posts/107825263/"/>
    <id>https://blog.musnow.top/posts/107825263/</id>
    <published>2023-09-27T12:41:59.000Z</published>
    <updated>2023-09-27T13:29:17.000Z</updated>
    
    <content type="html"><![CDATA[<p>函数的基本信息如下</p><ul><li>其中第一个参数是配置你想获取什么类型的时间</li><li>第二个参数是一个<strong>输出型参数</strong>，会将当前时间存放到一个结构体里面给你返回。</li><li>返回值标识是否获取成功</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//头文件</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;time.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//函数原型</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">clock_gettime</span><span class="params">( <span class="type">clockid_t</span> clock_id,<span class="keyword">struct</span> timespec * tp )</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// timespec 结构体</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">timespec</span> &#123;</span> </span><br><span class="line">    <span class="type">__time_t</span> tv_sec; <span class="comment">/* 秒 */</span> </span><br><span class="line">    __syscall_s <span class="type">long_t</span> tv_nsec; <span class="comment">/* 纳秒 */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>第一个参数有下面几种选项</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">CLOCK_REALTIME: 是指系统时间，随着系统时间的改变而改变。系统时钟会被用户而改变。并非不变的时间戳。</span><br><span class="line">CLOCK_MONOTONIC: 指从系统启动时开始计时。不受系统设置影响，也不会被用户改变。</span><br><span class="line">CLOCK_PROCESS_CPUTIME_ID: 指这个进程运行到当前代码时，CPU花费的时间。</span><br><span class="line">CLOCK_THREAD_CPUTIME_ID: 指这个线程运行到当前代码时，CPU花费的时间。</span><br></pre></td></tr></table></figure><p>使用例子</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;time.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">timespec</span> <span class="title">now</span>;</span></span><br><span class="line"></span><br><span class="line">    clock_gettime(CLOCK_MONOTONIC,&amp;now);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Seconds = %ld \t Nanoseconds = %ld\n&quot;</span>,, now.tv_sec, now.tv_nsec);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Seconds = 29642          Nanoseconds = 751516090</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">clock_gettime函数的使用</summary>
    
    
    
    <category term="初识C语言" scheme="https://blog.musnow.top/categories/%E5%88%9D%E8%AF%86C%E8%AF%AD%E8%A8%80/"/>
    
    
    <category term="C语言" scheme="https://blog.musnow.top/tags/C%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title>【Linux】valgrind检测程序内存泄漏</title>
    <link href="https://blog.musnow.top/posts/565285228/"/>
    <id>https://blog.musnow.top/posts/565285228/</id>
    <published>2023-09-26T10:12:55.000Z</published>
    <updated>2023-09-26T10:12:55.000Z</updated>
    
    <content type="html"><![CDATA[<p>valgrind是一个用于检测debug内存泄漏的命令行工具</p><h1 id="安装遵循如下命令"><a href="#安装遵循如下命令" class="headerlink" title="安装遵循如下命令"></a>安装遵循如下命令</h1><h2 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget https://sourceware.org/pub/valgrind/valgrind-3.21.0.tar.bz2</span><br></pre></td></tr></table></figure><h2 id="解压"><a href="#解压" class="headerlink" title="解压"></a>解压</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">tar -xf valgrind-3.21.0.tar.bz2</span><br><span class="line">cd valgrind-3.21.0</span><br></pre></td></tr></table></figure><h2 id="配置-x2F-安装，需要有root权限"><a href="#配置-x2F-安装，需要有root权限" class="headerlink" title="配置&#x2F;安装，需要有root权限"></a>配置&#x2F;安装，需要有root权限</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo ./configure</span><br><span class="line">sudo make</span><br><span class="line">sudo make install</span><br></pre></td></tr></table></figure><h1 id="使用mencheck"><a href="#使用mencheck" class="headerlink" title="使用mencheck"></a>使用mencheck</h1><p>mencheck是valgrind的一个模块，其还拥有其他功能，但是我们在这里不做使用<br> –tool&#x3D;memcheck  选择memcheck工具<br> –log-file&#x3D;log.txt  指定日志输出文件到 log.txt <br> –leak-check&#x3D;no|summary|full  指定输出日志的详细程度</p><p>基本使用命令的一个示例，最后的 <code>./test</code> 是一个可执行文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">valgrind --tool=memcheck --log-file=log.txt --leak-check=full ./test</span><br></pre></td></tr></table></figure><h2 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h2><p>memcheck模块检测的范围包括 </p><ul><li>使用未初始化的内存</li><li>使用已经被释放的内存</li><li>使用超出malloc分配空间的内存</li><li>对堆栈的非法访问</li><li>是否有释放申请的空间</li><li>memcpy中src和dst的重叠（参数的内存空间有重合部分）</li></ul><p>注意，对于某些new和malloc出来的常驻对象（比如全局的某个对象，单例模式中就会遇到）并不能算作内存泄漏，因为它是需要被使用的。</p><h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><p>整了个最简单的代码 </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstddef&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line">​</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test_leak</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> *p = (<span class="type">int</span> *)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">    *p = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">​</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> *p1 = (<span class="type">int</span> *)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">    *p1 = <span class="number">2</span>;</span><br><span class="line">​</span><br><span class="line">    <span class="type">int</span> *p2 = (<span class="type">int</span> *)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">    *p2 = <span class="number">3</span>;</span><br><span class="line">    <span class="comment">// 只析构一个，看看能不能检查出报错</span></span><br><span class="line">    <span class="built_in">free</span>(p2);</span><br><span class="line">    <span class="built_in">test_leak</span>();<span class="comment">// 只有调用的模块出现内存泄漏才能被检测到</span></span><br><span class="line">    <span class="comment">// 如果不调用这个函数，则不会检测到这里的问题</span></span><br><span class="line">    <span class="comment">// 因为valgrind是操作监看可执行文件的，并不是来扫描代码的</span></span><br><span class="line">​</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里面有3个malloc，其中有两个是没有free的，那么用valgrind可以检测出来吗？</p><p>答案是肯定的:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">==24089== Memcheck, a memory error detector</span><br><span class="line">==24089== Copyright (C) 2002-2022, and GNU GPL&#x27;d, by Julian Seward et al.</span><br><span class="line">==24089== Using Valgrind-3.21.0 and LibVEX; rerun with -h for copyright info</span><br><span class="line">==24089== Command: ./test</span><br><span class="line">==24089== Parent PID: 24056</span><br><span class="line">==24089== </span><br><span class="line">==24089== </span><br><span class="line">==24089== HEAP SUMMARY:</span><br><span class="line">==24089==     in use at exit: 8 bytes in 2 blocks</span><br><span class="line">==24089==   total heap usage: 4 allocs, 2 frees, 72,716 bytes allocated</span><br><span class="line">==24089== </span><br><span class="line">==24089== 4 bytes in 1 blocks are definitely lost in loss record 1 of 2</span><br><span class="line">==24089==    at 0x484880F: malloc (vg_replace_malloc.c:431)</span><br><span class="line">==24089==    by 0x1091F8: main (in /home/lyk/ub-vm/test)</span><br><span class="line">==24089== </span><br><span class="line">==24089== 4 bytes in 1 blocks are definitely lost in loss record 2 of 2</span><br><span class="line">==24089==    at 0x484880F: malloc (vg_replace_malloc.c:431)</span><br><span class="line">==24089==    by 0x1091C1: test_leak() (in /home/lyk/ub-vm/test)</span><br><span class="line">==24089==    by 0x10922C: main (in /home/lyk/ub-vm/test)</span><br><span class="line">==24089== </span><br><span class="line">==24089== LEAK SUMMARY:</span><br><span class="line">==24089==    definitely lost: 8 bytes in 2 blocks</span><br><span class="line">==24089==    indirectly lost: 0 bytes in 0 blocks</span><br><span class="line">==24089==      possibly lost: 0 bytes in 0 blocks</span><br><span class="line">==24089==    still reachable: 0 bytes in 0 blocks</span><br><span class="line">==24089==         suppressed: 0 bytes in 0 blocks</span><br><span class="line">==24089== </span><br><span class="line">==24089== For lists of detected and suppressed errors, rerun with: -s</span><br><span class="line">==24089== ERROR SUMMARY: 2 errors from 2 contexts (suppressed: 0 from 0)</span><br></pre></td></tr></table></figure><p>在最后的summry里面可以看到，这里提示 <code>definitely lost</code> 了8个字节，而且是在两个不同的区块中丢失的。和我们的代码吻合。</p><p>如果你不调用  <code>test_leak()</code>  函数，那么就不会出现第二次的内存泄漏，报告会变成只有  <code>4 bytes in 1 blocks</code> ，因为valgrind是通过可执行文件来检测是否有内存泄漏的，他不会扫描你的代码（那样的成本太高了而且不一定准确！）</p>]]></content>
    
    
    <summary type="html">valgrind是一个用于检测debug内存泄漏的命令行工具</summary>
    
    
    
    <category term="玩上Linux" scheme="https://blog.musnow.top/categories/%E7%8E%A9%E4%B8%8ALinux/"/>
    
    
    <category term="Linux" scheme="https://blog.musnow.top/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>【C++】C++17的那些新特性</title>
    <link href="https://blog.musnow.top/posts/3858168547/"/>
    <id>https://blog.musnow.top/posts/3858168547/</id>
    <published>2023-09-26T04:40:46.000Z</published>
    <updated>2023-09-26T04:40:46.000Z</updated>
    
    <content type="html"><![CDATA[<p>学习C++17的新特性</p><h1 id="1-构造函数模板推导"><a href="#1-构造函数模板推导" class="headerlink" title="1.构造函数模板推导"></a>1.构造函数模板推导</h1><p>在之前，我们如果想用stl容器，都需要用<code>&lt;&gt;</code> 来手动指定参数类型。但在C++17中，我们不需要这么做了。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::vector v1 = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125;;</span><br><span class="line">    std::pair p1  = &#123;<span class="number">1</span>,<span class="number">2.4234</span>&#125;;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">typeid</span>(v1).<span class="built_in">name</span>() &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">typeid</span>(p1).<span class="built_in">name</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用C++11编译，这个代码会报错。报错的意思是让我们指定参数的模板类型。</p><p>比如 <code>std::pair p1  = &#123;1,2.4234&#125;;</code> 在C++11中应该写成 <code>std::pair&lt;int,double&gt; p1  = &#123;1,2.4234&#125;;</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">test.cpp:16:10: error: use of class template &#x27;std::pair&#x27; requires template arguments</span><br><span class="line">    std::pair p1  = &#123;1,2.4234&#125;;</span><br><span class="line">         ^</span><br><span class="line">/usr/bin/../lib/gcc/x86_64-linux-gnu/11/../../../../include/c++/11/bits/stl_pair.h:211:12: note: template is declared here</span><br><span class="line">    struct pair</span><br><span class="line">           ^</span><br><span class="line">3 errors generated.</span><br><span class="line">make: *** [makefile:3: test] Error 1</span><br></pre></td></tr></table></figure><p>在C++17中，这样的写法就是可以被通过的了，也能正常推断出参数的类型，分别是一个int的vector，和一个int+double的pair；</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ make</span><br><span class="line">clang++ test.cpp -o test -std=c++17</span><br><span class="line">$ ./test</span><br><span class="line">St6vectorIiSaIiEE</span><br><span class="line">St4pairIidE</span><br></pre></td></tr></table></figure><h1 id="2-结构化绑定"><a href="#2-结构化绑定" class="headerlink" title="2.结构化绑定"></a>2.结构化绑定</h1><p>我们可以用 <code>auto[变量1,变量2]</code>的方式来接受一个tuple或者pair的返回值，将其绑定到两个不同的变量上。</p><p>tuple是C++11新增的一个数据结构，它和pair的用法类似，不同的是元组支持无数个参数。而pair仅支持两个。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::tuple&lt;<span class="type">int</span>, <span class="type">double</span>&gt; <span class="title">func_tuple</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> std::<span class="built_in">tuple</span>&lt;<span class="type">int</span>,<span class="type">double</span>&gt;(<span class="number">1</span>, <span class="number">2.2</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">std::pair&lt;<span class="type">int</span>, <span class="type">double</span>&gt; <span class="title">func_pair</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;<span class="number">1</span>,<span class="number">2</span>&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> [i, d] = <span class="built_in">func_tuple</span>(); </span><br><span class="line">    cout &lt;&lt; <span class="built_in">typeid</span>(i).<span class="built_in">name</span>() &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">typeid</span>(d).<span class="built_in">name</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> [x,y] = <span class="built_in">func_pair</span>();</span><br><span class="line">    cout &lt;&lt; <span class="built_in">typeid</span>(x).<span class="built_in">name</span>() &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">typeid</span>(y).<span class="built_in">name</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用C++11来编译，编译器会报错，但编译依旧能成功。这是因为我们的编译器是支持C++17的，但又被指定了<code>-std=c++11</code>，所以给用户报了个警告，但没有报错（因为这个语法在C++17里面是正确的）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">clang++ test.cpp -o test -std=c++11</span><br><span class="line">test.cpp:34:10: warning: decomposition declarations are a C++17 extension [-Wc++17-extensions]</span><br><span class="line">    auto [i, d] = func_tuple(); </span><br><span class="line">         ^~~~~~</span><br><span class="line">test.cpp:40:10: warning: decomposition declarations are a C++17 extension [-Wc++17-extensions]</span><br><span class="line">    auto [x,y] = func_pair();</span><br><span class="line">         ^~~~~</span><br><span class="line">2 warnings generated.</span><br></pre></td></tr></table></figure><p>运行输出结果如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ ./test</span><br><span class="line">i</span><br><span class="line">d</span><br><span class="line"></span><br><span class="line">i</span><br><span class="line">d</span><br></pre></td></tr></table></figure><p>注意：结构化绑定不能应用于constexpr！</p><p>结构化绑定不止可以绑定pair和tuple，还可以绑定数组和结构体等。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 注意这里的struct的成员一定要是public的，不然外部无法访问，还怎么绑定？</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Point</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line">    <span class="type">int</span> y;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回值是point的函数</span></span><br><span class="line"><span class="function">Point <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;<span class="number">1</span>, <span class="number">2</span>&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> array[<span class="number">3</span>] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line">    <span class="keyword">auto</span> [a, b, c] = array;</span><br><span class="line">    cout &lt;&lt; a &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; b &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; c &lt;&lt; endl;</span><br><span class="line">    <span class="comment">// 直接推导出两个成员变量并赋值给变量x和y</span></span><br><span class="line">    <span class="type">const</span> <span class="keyword">auto</span> [x, y] = <span class="built_in">func</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>成功编译并输出结果</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ make</span><br><span class="line">clang++ test.cpp -o test -std=c++17</span><br><span class="line">$ ./test</span><br><span class="line">1 2 3</span><br><span class="line">1 2</span><br></pre></td></tr></table></figure><p>自定义类型也能实现结构化绑定，这里从网上扒了一个代码下来，就不自己做测试了</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 需要实现相关的tuple_size和tuple_element和get&lt;N&gt;方法。</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Entry</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        name_ = <span class="string">&quot;name&quot;</span>;</span><br><span class="line">        age_ = <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">std::string <span class="title">GetName</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> name_; &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">GetAge</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> age_; &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::string name_;</span><br><span class="line">    <span class="type">int</span> age_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="type">size_t</span> I&gt;</span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">get</span><span class="params">(<span class="type">const</span> Entry&amp; e)</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">if</span> <span class="title">constexpr</span> <span class="params">(I == <span class="number">0</span>)</span> <span class="keyword">return</span> e.<span class="title">GetName</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> <span class="built_in">constexpr</span> (I == <span class="number">1</span>) <span class="keyword">return</span> e.<span class="built_in">GetAge</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> std &#123;</span><br><span class="line">    <span class="keyword">template</span>&lt;&gt; <span class="keyword">struct</span> <span class="title class_">tuple_size</span>&lt;Entry&gt; : integral_constant&lt;<span class="type">size_t</span>, <span class="number">2</span>&gt; &#123;&#125;;</span><br><span class="line">    <span class="keyword">template</span>&lt;&gt; <span class="keyword">struct</span> <span class="title class_">tuple_element</span>&lt;<span class="number">0</span>, Entry&gt; &#123; <span class="keyword">using</span> type = std::string; &#125;;</span><br><span class="line">    <span class="keyword">template</span>&lt;&gt; <span class="keyword">struct</span> <span class="title class_">tuple_element</span>&lt;<span class="number">1</span>, Entry&gt; &#123; <span class="keyword">using</span> type = <span class="type">int</span>; &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Entry e;</span><br><span class="line">    e.<span class="built_in">Init</span>();</span><br><span class="line">    <span class="keyword">auto</span> [name, age] = e;</span><br><span class="line">    cout &lt;&lt; name &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; age &lt;&lt; endl; <span class="comment">// name 10</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="3-if语句新增初始条件"><a href="#3-if语句新增初始条件" class="headerlink" title="3.if语句新增初始条件"></a>3.if语句新增初始条件</h1><p>在之前我们都是用 <code>if(判断条件)</code> 来使用if语句的，C++17中给if新增了一个类似for循环中第一个参数的相同参数</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">if(初始化条件,判断条件)</span><br></pre></td></tr></table></figure><p>比如</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(<span class="type">int</span> i=<span class="number">20</span>;i&lt;<span class="number">39</span>)&#123;</span><br><span class="line">    cout &lt;&lt;<span class="string">&quot;i&lt;39!&quot;</span>&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行效果如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ ./test</span><br><span class="line">i&lt;39!</span><br></pre></td></tr></table></figure><h1 id="4-内联变量"><a href="#4-内联变量" class="headerlink" title="4.内联变量"></a>4.内联变量</h1><p>在之前我们想初始化一个类中的static变量，需要在类中定义，类外初始化。但如果是const的static变量，就能直接在类中通过缺省值的方式来初始化。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在头文件里面这样是能通过编译的，但是不建议在头文件中初始化static变量，会产生ODR冲突:</span></span><br><span class="line"><span class="comment">// Variable &#x27;value&#x27; defined in a header file; variable definitions in header files can lead to ODR violations</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">A</span> &#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> value;  </span><br><span class="line">    <span class="type">static</span> <span class="type">const</span> <span class="type">int</span> value_c=<span class="number">10</span>;  <span class="comment">// const可以直接初始化</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">int</span> A::value = <span class="number">10</span>;</span><br></pre></td></tr></table></figure><p>在C++17中内联变量引入后，我们就可以直接实现在头文件中初始化static非const变量，或者直接用缺省值来初始化了</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">A</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> value;</span><br><span class="line">    <span class="type">static</span> <span class="type">const</span> <span class="type">int</span> value_c = <span class="number">10</span>;</span><br><span class="line">    <span class="comment">// static int value = 10;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">inline</span> <span class="type">int</span> A::value = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ========= 或者 ========</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">B</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">inline</span> <span class="type">static</span> <span class="type">int</span> value = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">inline</span> <span class="type">static</span> <span class="type">const</span> <span class="type">int</span> value_c = <span class="number">10</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>相比于原本static变量初始化需要放到另外一个cpp源文件中，这种直接在头文件里面声明+初始化的方式能更好的确定变量的初始值。</p><h1 id="5-折叠表达式"><a href="#5-折叠表达式" class="headerlink" title="5.折叠表达式"></a>5.折叠表达式</h1><p>C++17引入了折叠表达式使可变参数模板编程更方便：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> ... Ts&gt;</span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">sum</span><span class="params">(Ts ... ts)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (ts + ...);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> a &#123;<span class="built_in">sum</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>)&#125;; <span class="comment">// 15</span></span><br><span class="line">std::string a&#123;<span class="string">&quot;hello &quot;</span>&#125;;</span><br><span class="line">std::string b&#123;<span class="string">&quot;world&quot;</span>&#125;;</span><br><span class="line">cout &lt;&lt; <span class="built_in">sum</span>(a, b) &lt;&lt; endl; <span class="comment">// hello world</span></span><br></pre></td></tr></table></figure><p>实话说，可变模板参数这部分就没有弄明白过，实际上也没有用过，直接跳过！</p><h1 id="6-constexpr-lambda表达式"><a href="#6-constexpr-lambda表达式" class="headerlink" title="6.constexpr+lambda表达式"></a>6.constexpr+lambda表达式</h1><p>C++17前lambda表达式只能在运行时使用，C++17引入了constexpr lambda表达式，可以用于在编译期进行计算。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">int main() &#123; // c++17可编译</span><br><span class="line">    constexpr auto lamb = [] (int n) &#123; return n * n; &#125;;</span><br><span class="line">    static_assert(lamb(3) == 9, &quot;a&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>规则和普通的constexpr函数相同，参考我的C++11和14的文章。这里做简单说明：</p><p>constexpr修饰的函数体不能包含汇编语句、goto语句、label、try块、静态变量、线程局部存储、没有初始化的普通变量，不能动态分配内存，不能有new delete等，不能虚函数。</p><h1 id="7-嵌套命名空间"><a href="#7-嵌套命名空间" class="headerlink" title="7.嵌套命名空间"></a>7.嵌套命名空间</h1><p>在之前如果需要嵌套命名空间，需要这样写</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> A &#123;</span><br><span class="line">    <span class="keyword">namespace</span> B &#123;</span><br><span class="line">        <span class="keyword">namespace</span> C &#123;</span><br><span class="line">            <span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span></span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>C++17中可以直接用类似访问限定符的方式，前面加一个namespace来标明嵌套的命名空间。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// c++17，方便了，可读性也更好</span></span><br><span class="line"><span class="keyword">namespace</span> A::B::C &#123;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="8-has-include预处理表达式"><a href="#8-has-include预处理表达式" class="headerlink" title="8.__has_include预处理表达式"></a>8.__has_include预处理表达式</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">if</span> defined __has_include <span class="comment">// 判断是否支持这个表达式</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> __has_include(<span class="string">&lt;charconv&gt;</span>) <span class="comment">// 支持，判断是否存在该头文件</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> has_charconv 1 <span class="comment">// 头文件存在，定义一个宏</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;charconv&gt;</span> <span class="comment">// 引用这个头文件</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>如果一个代码会在多个不同的平台下跑，这个功能就很重要。比如我之前写项目的时候需要使用到jsoncpp，在centos和deepin下，安装jsoncpp的include路径是不同的</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//centos</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;json/json.h&gt;</span></span></span><br><span class="line"><span class="comment">//deepin</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;jsoncpp/json/json.h&gt;</span></span></span><br></pre></td></tr></table></figure><p>这种场景下就可以使用上面提到的这个预处理表达式进行判断，来确认你的jsoncpp路径到底在哪里。注意，这只能解决从yum和apt安装的jsoncpp，如果是自己手动安装的，那鬼知道你安装到哪里去了？🤣</p><p>所以很多大型项目如果需要使用jsoncpp这种第三方依赖项目，一般都会采用<code>git submodule</code>的方式，直接将第三方库下载到当前项目路径下，以避免不同平台的依赖项<code>include</code>路径不对而导致无法编译程序的问题。</p><h1 id="9-this指针捕获（lambda）"><a href="#9-this指针捕获（lambda）" class="headerlink" title="9.this指针捕获（lambda）"></a>9.this指针捕获（lambda）</h1><p>在lambda表达式中，采用<code>[this]</code>方式捕获的this指针是<strong>值传递</strong>捕获的，但在一些情况下，会出现访问已经被释放了的空间的行为；比如如下代码</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Foo</span></span><br><span class="line">&#123;</span><br><span class="line">    std::unique_ptr&lt;<span class="type">int</span>&gt; p;</span><br><span class="line"></span><br><span class="line">    <span class="function">std::function&lt;<span class="title">void</span><span class="params">()</span>&gt; <span class="title">f</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        p.<span class="built_in">reset</span>(<span class="keyword">new</span> <span class="built_in">int</span>(<span class="number">10</span>));</span><br><span class="line">        <span class="keyword">return</span> [&amp;]</span><br><span class="line">        &#123;</span><br><span class="line">            cout &lt;&lt; <span class="number">5</span> &lt;&lt; endl;</span><br><span class="line">            cout &lt;&lt; *p &lt;&lt; endl; <span class="comment">// 实际上是这一步报错的</span></span><br><span class="line">            <span class="comment">// 这里对*p的访问可以解析为 *(this-&gt;p)，但实际上this指针已经被销毁了</span></span><br><span class="line">            <span class="comment">// 注意，这里采用了智能指针，不存在内存泄漏，p指针指向的空间也被销毁了</span></span><br><span class="line">            <span class="comment">// 但我们的报错其实是对this指针解引用的时候就抛出了</span></span><br><span class="line">            cout &lt;&lt; <span class="number">6</span> &lt;&lt; endl;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> foo = <span class="keyword">new</span> <span class="built_in">Foo</span>();</span><br><span class="line">    cout &lt;&lt; <span class="number">1</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">auto</span> f = foo-&gt;<span class="built_in">f</span>();  <span class="comment">// 获取了一个类内成员函数</span></span><br><span class="line">    cout &lt;&lt; <span class="number">2</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">delete</span> foo;  <span class="comment">// 销毁这个对象</span></span><br><span class="line">    cout &lt;&lt; <span class="number">3</span> &lt;&lt; endl;</span><br><span class="line">    <span class="comment">// 尝试在销毁后继续使用这个对象，我们是通过lambda中=捕获的this指针来访问对象的</span></span><br><span class="line">    <span class="built_in">f</span>();  <span class="comment">// 这里直接报错了 Segmentation fault (core dumped)</span></span><br><span class="line">    cout &lt;&lt; <span class="number">4</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行这个程序，可以看到是在<code>*p</code>的位置报错退出的；具体的原因参考代码中的注释。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ ./test</span><br><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">5</span><br><span class="line">Segmentation fault (core dumped)</span><br></pre></td></tr></table></figure><p>需要注意，lambda表达式中，使用&#x3D;和&amp;都会默认采用<strong>传值捕获this指针</strong>，因为this指针是存在于函数作用域中的一个隐藏参数，并不是独立在成员函数外的变量，所以是可以被捕捉到的；另外，this指针是不能被传引用捕获的，<code>[&amp;this]</code> 的写法是不允许的；</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">clang++ test.cpp -o test -std=c++17</span><br><span class="line">test.cpp:84:18: error: &#x27;this&#x27; cannot be captured by reference</span><br><span class="line">        return [&amp;this]</span><br><span class="line">                 ^</span><br><span class="line">1 error generated.</span><br></pre></td></tr></table></figure><p>C++17中提供了一个特殊的写法 <code>[*this]</code> 通过传值的方式捕获了当前对象本身，此时lambda表达式中存在的就是一个对象的拷贝，即便当前对象被销毁了，我们依旧可以通过这个拷贝访问到目标；</p><p>代码修改如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Foo</span></span><br><span class="line">&#123;</span><br><span class="line">    std::shared_ptr&lt;<span class="type">int</span>&gt; p; <span class="comment">// 不能用unique_ptr，因为它的拷贝构造函数是被delete禁止使用的</span></span><br><span class="line"></span><br><span class="line">    <span class="function">std::function&lt;<span class="title">void</span><span class="params">()</span>&gt; <span class="title">f</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        p.<span class="built_in">reset</span>(<span class="keyword">new</span> <span class="built_in">int</span>(<span class="number">10</span>));</span><br><span class="line">        <span class="keyword">return</span> [*<span class="keyword">this</span>]</span><br><span class="line">        &#123;</span><br><span class="line">            cout &lt;&lt; <span class="number">5</span> &lt;&lt; endl;</span><br><span class="line">            cout &lt;&lt; *p &lt;&lt; endl;</span><br><span class="line">            cout &lt;&lt; <span class="number">6</span> &lt;&lt; endl;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> foo = <span class="keyword">new</span> <span class="built_in">Foo</span>();</span><br><span class="line">    cout &lt;&lt; <span class="number">1</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">auto</span> f = foo-&gt;<span class="built_in">f</span>();  <span class="comment">// 获取了一个类内成员函数</span></span><br><span class="line">    cout &lt;&lt; <span class="number">2</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">delete</span> foo;  <span class="comment">// 销毁这个对象</span></span><br><span class="line">    cout &lt;&lt; <span class="number">3</span> &lt;&lt; endl;</span><br><span class="line">    <span class="comment">// 尝试在销毁后继续使用这个对象，我们是通过lambda中=捕获的this指针来访问对象的</span></span><br><span class="line">    <span class="built_in">f</span>();  <span class="comment">// 这里直接报错了 Segmentation fault (core dumped)</span></span><br><span class="line">    cout &lt;&lt; <span class="number">4</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时重新编译，就能成功访问到指针p指向的对象了，并不受foo对象已经被delete的影响；</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ ./test</span><br><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">5</span><br><span class="line">10</span><br><span class="line">6</span><br><span class="line">4</span><br></pre></td></tr></table></figure><h1 id="10-字符串转换"><a href="#10-字符串转换" class="headerlink" title="10.字符串转换"></a>10.字符串转换</h1><blockquote><p>没看懂这两个函数是干嘛的，找到的代码连编译都过不去，跳过吧</p></blockquote><p>新增from_chars函数和to_chars函数</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">https://zh.cppreference.com/w/cpp/utility/from_chars</span><br><span class="line">https://blog.csdn.net/defaultbyzt/article/details/120151801</span><br></pre></td></tr></table></figure><h1 id="11-std-variant"><a href="#11-std-variant" class="headerlink" title="11.std::variant"></a>11.std::variant</h1><p>C++17增加<code>std::variant</code>实现类似union的功能，但却比union更高级，举个例子union里面不能有string这种类型，但<code>std::variant</code>却可以，还可以支持更多复杂类型，如map等，看代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123; <span class="comment">// c++17可编译</span></span><br><span class="line">    <span class="function">std::variant&lt;<span class="type">int</span>, std::string&gt; <span class="title">var</span><span class="params">(<span class="string">&quot;hello&quot;</span>)</span></span>;</span><br><span class="line">    cout &lt;&lt; var.<span class="built_in">index</span>() &lt;&lt; endl;</span><br><span class="line">    var = <span class="number">123</span>;</span><br><span class="line">    cout &lt;&lt; var.<span class="built_in">index</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        var = <span class="string">&quot;world&quot;</span>;</span><br><span class="line">        std::string str = std::<span class="built_in">get</span>&lt;std::string&gt;(var); <span class="comment">// 通过类型获取值</span></span><br><span class="line">        var = <span class="number">3</span>;</span><br><span class="line">        <span class="type">int</span> i = std::<span class="built_in">get</span>&lt;<span class="number">0</span>&gt;(var); <span class="comment">// 通过index获取对应值</span></span><br><span class="line">        cout &lt;&lt; str &lt;&lt; endl;</span><br><span class="line">        cout &lt;&lt; i &lt;&lt; endl;</span><br><span class="line">    &#125; <span class="built_in">catch</span>(...) &#123;</span><br><span class="line">        <span class="comment">// xxx;</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意：一般情况下variant的第一个类型一般要有对应的构造函数，否则编译失败：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">A</span> &#123;</span><br><span class="line">    <span class="built_in">A</span>(<span class="type">int</span> i)&#123;&#125;  </span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::variant&lt;A, <span class="type">int</span>&gt; var; <span class="comment">// 编译失败</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如何避免这种情况呢，可以使用<code>std::monostate</code>来打个桩，模拟一个空状态。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">std::variant&lt;std::monostate, A&gt; var; <span class="comment">// 可以编译成功</span></span><br></pre></td></tr></table></figure><h2 id="12-std-optional"><a href="#12-std-optional" class="headerlink" title="12.std::optional"></a>12.std::optional</h2><p><a href="https://en.cppreference.com/w/cpp/utility/optional">https://en.cppreference.com/w/cpp/utility/optional</a></p><p>有的时候，我们想在异常的时候抛出一个异常的对象，亦或者是在出现一些不可预期的错误的时候，返回一个空值。要怎么区分空值和异常的对象呢？</p><p>在python中，我们有一个专门的None对象可以来处理这件事。在MySQL中，我们也有NULL来标识空；但在CPP中，我们只剩下一个<code>nullptr</code>，其本质是个<strong>指针</strong>，与Py中的None和MySQL中的NULL完全不同！如果想用指针来区分空和异常对象，那就需要用到动态内存管理，亦或者是用智能指针来避免内存泄漏。</p><p>说人话就是，在CPP中没有一个类似None的含义为空的对象，来告诉调用这个程序的人，到底是发生了错误，生成了一个错误的对象，还是说压根什么都没有弄出来。</p><p>于是<code>std::optional</code>就出现了，其可以包含一个类型，并有<code>std::nullopt</code>来专门标识“空”这个含义。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;optional&gt;</span></span></span><br><span class="line"><span class="function">std::optional&lt;<span class="type">int</span>&gt; <span class="title">StoI</span><span class="params">(<span class="type">const</span> std::string &amp;s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> std::<span class="built_in">stoi</span>(s);</span><br><span class="line">    &#125; <span class="built_in">catch</span>(...) &#123;</span><br><span class="line">        <span class="keyword">return</span> std::<span class="literal">nullopt</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::string s&#123;<span class="string">&quot;123&quot;</span>&#125;;</span><br><span class="line">    std::optional&lt;<span class="type">int</span>&gt; o = <span class="built_in">StoI</span>(s);</span><br><span class="line">    <span class="keyword">if</span> (o) &#123;</span><br><span class="line">        cout &lt;&lt; *o &lt;&lt; endl;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;error&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里我们进行了if的判断，首先判断变量o本身，为真代表的确返回了一个int值，为假代表返回的是<code>nullopt</code>；</p><p>随后再使用<code>*o</code>来访问到内部托管的成员。</p><p>需要注意这里是两层的逻辑关系，只有optional对象中成功托管了一个指定的参数类型，其本身才是真的。如果想访问它托管的对象，则需要用解引用。</p><p>比如这里，我们的o对象托管的是一个bool类型的假，但假并不代表空，o对象本身的判断是真，内部对<code>*o</code>的判断才是判断托管的bool值到底是真是假。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;optional&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::optional&lt;<span class="type">bool</span>&gt; o = <span class="literal">false</span>;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">typeid</span>(o).<span class="built_in">name</span>() &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">if</span> (o) <span class="comment">// 这里判断的是optional对象是否有托管一个bool值</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(*o)&#123; <span class="comment">// 这里判断的是托管的bool值本身</span></span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;true&quot;</span> &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;false&quot;</span> &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123; <span class="comment">// 这里则代表托管的是nullopt</span></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;error&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最终运行打印的结果是<code>false</code>；</p><h1 id="13-std-any"><a href="#13-std-any" class="headerlink" title="13.std::any"></a>13.std::any</h1><p><a href="https://en.cppreference.com/w/cpp/utility/any">https://en.cppreference.com/w/cpp/utility/any</a></p><p>这个类型可以托管任意类型的值，与之对应的还有一个<code>std::any_cast</code>来将其托管的值转成我们需要的类型。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;any&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123; <span class="comment">// c++17可编译</span></span><br><span class="line">    std::any a = <span class="number">1</span>;</span><br><span class="line">    cout &lt;&lt; a.<span class="built_in">type</span>().<span class="built_in">name</span>() &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; std::<span class="built_in">any_cast</span>&lt;<span class="type">int</span>&gt;(a) &lt;&lt; endl;</span><br><span class="line">    a = <span class="number">2.2f</span>;</span><br><span class="line">    cout &lt;&lt; a.<span class="built_in">type</span>().<span class="built_in">name</span>() &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; std::<span class="built_in">any_cast</span>&lt;<span class="type">float</span>&gt;(a) &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">if</span> (a.<span class="built_in">has_value</span>()) &#123;</span><br><span class="line">        cout &lt;&lt; a.<span class="built_in">type</span>().<span class="built_in">name</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    a.<span class="built_in">reset</span>();</span><br><span class="line">    <span class="keyword">if</span> (a.<span class="built_in">has_value</span>()) &#123;</span><br><span class="line">        cout &lt;&lt; a.<span class="built_in">type</span>().<span class="built_in">name</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    a = std::<span class="built_in">string</span>(<span class="string">&quot;a&quot;</span>);</span><br><span class="line">    cout &lt;&lt; a.<span class="built_in">type</span>().<span class="built_in">name</span>() &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; std::<span class="built_in">any_cast</span>&lt;std::string&gt;(a) &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">i 1</span><br><span class="line">f 2.2</span><br><span class="line">fNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEE a</span><br></pre></td></tr></table></figure><p>虽然any的出现让cpp也在一定程度上能实现“弱类型”变量，但在具体的开发中，明确变量的类型依旧比使用any好得多。特别是在变量的类型并不可以被直接转换的情况下。</p><h1 id="14-std-apply"><a href="#14-std-apply" class="headerlink" title="14.std::apply"></a>14.std::apply</h1><p>使用<code>std::apply</code>可以将tuple展开作为函数的参数传入，见代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;tuple&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">add</span><span class="params">(<span class="type">int</span> first, <span class="type">int</span> second)</span> </span>&#123; <span class="keyword">return</span> first + second; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> add_lambda = [](<span class="keyword">auto</span> first, <span class="keyword">auto</span> second) &#123; <span class="keyword">return</span> first + second; &#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; std::<span class="built_in">apply</span>(add, std::<span class="built_in">pair</span>(<span class="number">1</span>, <span class="number">2</span>)) &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="built_in">add</span>(std::<span class="built_in">pair</span>(<span class="number">1</span>, <span class="number">2</span>)) &lt;&lt; <span class="string">&quot;\n&quot;</span>; <span class="comment">// error</span></span><br><span class="line">    std::cout &lt;&lt; std::<span class="built_in">apply</span>(add_lambda, std::<span class="built_in">tuple</span>(<span class="number">2.0f</span>, <span class="number">3.0f</span>)) &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="15-std-make-from-tuple"><a href="#15-std-make-from-tuple" class="headerlink" title="15.std::make_from_tuple"></a>15.std::make_from_tuple</h1><p>使用make_from_tuple可以将tuple展开作为构造函数参数</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Foo</span> &#123;</span><br><span class="line">    <span class="built_in">Foo</span>(<span class="type">int</span> first, <span class="type">float</span> second, <span class="type">int</span> third) &#123;</span><br><span class="line">        std::cout &lt;&lt; first &lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; second &lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; third &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   <span class="keyword">auto</span> tuple = std::<span class="built_in">make_tuple</span>(<span class="number">42</span>, <span class="number">3.14f</span>, <span class="number">0</span>);</span><br><span class="line">   std::<span class="built_in">make_from_tuple</span>&lt;Foo&gt;(std::<span class="built_in">move</span>(tuple));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="16-std-string-view"><a href="#16-std-string-view" class="headerlink" title="16.std::string_view"></a>16.std::string_view</h1><p><a href="https://zhuanlan.zhihu.com/p/166359481">https://zhuanlan.zhihu.com/p/166359481</a></p><p><a href="https://en.cppreference.com/w/cpp/string/basic_string_view">https://en.cppreference.com/w/cpp/string/basic_string_view</a></p><p>如果我们只需要一个string的只读类型的话，可以用string_view来托管。其内部只包含一个指向目标字符串的指针，以及字符串的长度。</p><p>string_view内部封装了string的所有只读接口，本来就是给你读的。</p><p>需要注意的是，因为内部只有一个指针，所以当string_view托管的string被销毁了，与之关联的所有string_view都会失效！同样是因为内部只有一个指针和字符串的长度两个变量，所以在传值拷贝的时候，string_view的效率会高很多。</p><ul><li>这和<code>const string&amp;</code> 类型的传值又有什么区别呢？传引用不是也没有拷贝消耗吗？</li></ul><p>这个问题很好，我不知道！百度也没有百度出来……</p><p>我能想到的就是用<code>string_view</code>作为参数的时候，如果入参是一个常量字符串，此时不需要构造string，而使用<code>const string&amp;</code> 接受常量字符串的时候依旧需要构造一个string对象。这部分就会有一定的消耗。</p><h1 id="17-as-const"><a href="#17-as-const" class="headerlink" title="17.as_const"></a>17.as_const</h1><p>C++17使用as_const可以将左值转成const类型</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">std::string str = <span class="string">&quot;str&quot;</span>;</span><br><span class="line"><span class="type">const</span> std::string&amp; constStr = std::<span class="built_in">as_const</span>(str);</span><br></pre></td></tr></table></figure><h1 id="18-file-system"><a href="#18-file-system" class="headerlink" title="18.file_system"></a>18.file_system</h1><p>C++17正式将file_system纳入标准中，提供了关于文件的大多数功能，基本上应有尽有，这里简单举几个例子：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> fs = std::filesystem;</span><br><span class="line">fs::<span class="built_in">create_directory</span>(dir_path); <span class="comment">// 创建文件或者路径</span></span><br><span class="line">fs::<span class="built_in">copy_file</span>(src, dst, fs::copy_options::skip_existing); <span class="comment">// 文件cp</span></span><br><span class="line">fs::<span class="built_in">exists</span>(filename); <span class="comment">// 文件是否存在</span></span><br><span class="line">fs::<span class="built_in">current_path</span>(err_code); <span class="comment">// 获取当前路径</span></span><br></pre></td></tr></table></figure><h1 id="19-shared-mutex"><a href="#19-shared-mutex" class="headerlink" title="19.shared_mutex"></a>19.shared_mutex</h1><p>这玩意是个读写锁。简单介绍一下什么是读写锁：</p><ul><li>读者可以有多个，写者只能有一个</li><li>写锁是互斥的，如果A有锁，B想拿锁就得阻塞等待</li><li>读锁是共享的，C有读锁，D也想读，两个人可以一起看</li><li>读写锁是互斥的，有人写的时候不能读，有人读的时候不能写</li></ul><p>换到专业术语上，就是分为独占锁（写锁）和共享锁（读锁）；</p><p>在C++14中其实已经有了一个<code>shared_timed_mutex</code>，C++17中这个锁的操作与其基本一致，只不过多了几个和时间相关的接口</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">try_lock_for</span>(...);</span><br><span class="line"><span class="built_in">try_lock_shared_for</span>(...);</span><br><span class="line"><span class="built_in">try_lock_shared_until</span>(...);</span><br><span class="line"><span class="built_in">try_lock_until</span>(...);</span><br></pre></td></tr></table></figure><p>具体使用可以参考 </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">https://zh.cppreference.com/w/cpp/thread/shared_mutex</span><br><span class="line">https://zhuanlan.zhihu.com/p/610781321</span><br></pre></td></tr></table></figure><h1 id="The-end"><a href="#The-end" class="headerlink" title="The end"></a>The end</h1><p>关于C++17常用的基本就是这些了，后续遇到新的再更新本文。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;学习C++17的新特性&lt;/p&gt;
&lt;h1 id=&quot;1-构造函数模板推导&quot;&gt;&lt;a href=&quot;#1-构造函数模板推导&quot; class=&quot;headerlink&quot; title=&quot;1.构造函数模板推导&quot;&gt;&lt;/a&gt;1.构造函数模板推导&lt;/h1&gt;&lt;p&gt;在之前，我们如果想用stl容器，都需要</summary>
      
    
    
    
    <category term="遇见C++" scheme="https://blog.musnow.top/categories/%E9%81%87%E8%A7%81C/"/>
    
    
    <category term="C++" scheme="https://blog.musnow.top/tags/C/"/>
    
    <category term="数据结构" scheme="https://blog.musnow.top/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    <category term="C++17" scheme="https://blog.musnow.top/tags/C-17/"/>
    
  </entry>
  
  <entry>
    <title>【面经】230915上海戎磐网络科技C/LINUX实习生</title>
    <link href="https://blog.musnow.top/posts/2553205100/"/>
    <id>https://blog.musnow.top/posts/2553205100/</id>
    <published>2023-09-15T06:50:14.000Z</published>
    <updated>2023-09-15T06:50:14.000Z</updated>
    
    <content type="html"><![CDATA[<p>10分钟就面完了，堪称急速，面试官说我答的不错；而且上来自我介绍完毕后就问问题，不多比比🤣</p><span id="more"></span><h1 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h1><h2 id="1-Linux下线程互斥怎么实现"><a href="#1-Linux下线程互斥怎么实现" class="headerlink" title="1.Linux下线程互斥怎么实现"></a>1.Linux下线程互斥怎么实现</h2><p>加锁，pthread，然后我还提到了cpp的原子变量</p><p><a href="https://blog.musnow.top/posts/1309150756/">https://blog.musnow.top/posts/1309150756/</a></p><h2 id="2-CPP多态怎么实现"><a href="#2-CPP多态怎么实现" class="headerlink" title="2.CPP多态怎么实现"></a>2.CPP多态怎么实现</h2><p>虚函数表，巴拉巴拉</p><p><a href="https://blog.musnow.top/posts/3933786088/">https://blog.musnow.top/posts/3933786088/</a></p><h2 id="3-CPP为啥要引入模板"><a href="#3-CPP为啥要引入模板" class="headerlink" title="3.CPP为啥要引入模板"></a>3.CPP为啥要引入模板</h2><p>代码更高复用</p><p><a href="https://blog.musnow.top/posts/2940029419/">https://blog.musnow.top/posts/2940029419/</a></p><h2 id="4-NAT怎么实现的？"><a href="#4-NAT怎么实现的？" class="headerlink" title="4.NAT怎么实现的？"></a>4.NAT怎么实现的？</h2><p>转化表，IP地址替换，巴拉巴拉吧说一大堆</p><p><a href="https://blog.musnow.top/posts/3482559497/">https://blog.musnow.top/posts/3482559497/</a></p><h2 id="5-进程通信"><a href="#5-进程通信" class="headerlink" title="5.进程通信"></a>5.进程通信</h2><p>老问题了</p><h2 id="6-inet-ntoa函数知道吗？连续调用会有什么问题？"><a href="#6-inet-ntoa函数知道吗？连续调用会有什么问题？" class="headerlink" title="6.inet_ntoa函数知道吗？连续调用会有什么问题？"></a>6.inet_ntoa函数知道吗？连续调用会有什么问题？</h2><blockquote><p>这是最后一个问题，面试官说我答的挺好的</p></blockquote><p>我先说了这个函数是用于16位IP地址和字符串的转换的；</p><p>然后面试官这里问了一个业务上的问题</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s %s\n&quot;</span>,<span class="built_in">inet_ntoa</span>(x),<span class="built_in">inet_ntoa</span>(y));<span class="comment">// x和y是两个ip地址</span></span><br></pre></td></tr></table></figure><p>这个函数会不会有什么错误的地方？</p><blockquote><p>请注意，这里是面试时候的描述，面试官肯定只能给你描述个大概的，并不会细致到具体的传参应该传什么类型的变量，所以传参x和y也只是个伪代码，想问的地方不在这里！</p></blockquote><p>这里我说了<code>inet_ntoa</code>是采用static变量来返回ip字符串的，线程不安全，有可能两个调用最终返回了一个相同的IP地址，又明说了我不确定；（肯定有问题，不然问你干嘛？）</p><hr><p>面试结束了，来测试一下到底是啥情况吧！</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">in_addr</span> ip1;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">in_addr</span> ip2;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">inet_aton</span>(<span class="string">&quot;192.168.3.1&quot;</span>,&amp;ip1);</span><br><span class="line">    <span class="built_in">inet_aton</span>(<span class="string">&quot;10.161.33.42&quot;</span>,&amp;ip2);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s %s\n&quot;</span>,<span class="built_in">inet_ntoa</span>(ip1),<span class="built_in">inet_ntoa</span>(ip2));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果如下，两个IP地址返回了同一个，我猜对了；</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ ./test</span><br><span class="line">192.168.3.1 192.168.3.1</span><br></pre></td></tr></table></figure><p>为什么呢？打印一下地址，会得到如下输出，两次调用返回了相同的地址，自然打印出来的结果相同；</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%x %x\n&quot;</span>,<span class="built_in">inet_ntoa</span>(ip1),<span class="built_in">inet_ntoa</span>(ip2));</span><br><span class="line"><span class="comment">//68db1ef0 68db1ef0</span></span><br></pre></td></tr></table></figure><p>对于这个函数而言，它需要给我们返回一个字符串，又必须保证这个字符串能在函数外被正常访问（不能被释放），再加上这是一个C语言接口，那么就只有三种方案了</p><ul><li>函数里面malloc，需要用户手动free</li><li>static变量</li><li>让用户传入一个有效的地址，将数据写入作为输出型参数</li></ul><p>第一个方案肯定是不可行的！这相当于官方提供了一个<strong>极其容易导致内存泄漏</strong>的接口！这不得被开发者喷死？比如本题提到的场景里面就是两次printf而已，除此之外没有保存这个返回值，更别提free了，这里就直接两次内存泄漏了！</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s %s\n&quot;</span>,inet_ntoa(ip1),inet_ntoa(ip2));</span><br><span class="line"><span class="comment">// 如果用malloc后的字符串地址做返回值，这里就是两个内存泄漏</span></span><br></pre></td></tr></table></figure><p>第三个方案也不方便，系统依赖用户传入一个数组的入参，我们知道ipv4的IP地址字符串最长是<code>3*4+3=15</code>位，那么如果用户只传入一个<code>char arr[12]</code>呢？越界访问的问题怎么解决？相当于系统之中依旧会出现参数不匹配而可能导致的地址访问错误！</p><p><strong>而这个函数本身的工作很简单，完全没必要弄那么复杂</strong>；</p><p>最终linux系统采用了static变量的方式，来返回这个IP地址的字符串；man手册里面是这么说的，直接看最后一句，翻译过来的意思是<strong>后续的调用会覆盖掉前面的值</strong>；</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"> The inet_ntoa() function converts the Internet host address in, </span><br><span class="line"> given in network byte order, to a string in IPv4 dotted-decimal notation.  </span><br><span class="line"> The string  is returned in a statically allocated buffer,</span><br><span class="line">which subsequent calls will overwrite.</span><br></pre></td></tr></table></figure><p>所以最终我们看到的结果就是两次打印出了相同的IP地址；</p><p>这里还涉及到第二个知识点，<a href="https://blog.musnow.top/posts/3888883052/">printf的传参顺序</a>;</p><p>简单说来就是printf是从右往左执行的（其实所有函数的传参都是这样，这也是为什么缺省值要从右边往左给）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s %s\n&quot;</span>,<span class="built_in">inet_ntoa</span>(ip1),<span class="built_in">inet_ntoa</span>(ip2));</span><br></pre></td></tr></table></figure><p>这里的执行顺序如下</p><ul><li>ip2结构体传给函数，转成ip地址字符串后存在static变量中</li><li>ip1结构体传给函数，转成ip地址字符串后存在了static变量中，覆盖了ip2的结果</li></ul><p>最终打印出来的两个字符串都是ip1的地址！</p><p>对于<code>inet_aton</code>函数而言，<strong>正确的调用</strong>办法是每次调用后都取走返回的IP地址字符串，可以用<code>std::string</code>接收，也可以用strcmp拷贝到一个自己定义的字符串数组变量中；</p><p>你学会了吗，骚年？</p><blockquote><p><code>inet_aton</code>这个函数最早出现于本站的此博客：<a href="https://blog.musnow.top/posts/368672249/">【Linux】来写一个udp的服务端+客户端</a></p></blockquote><h1 id="项目"><a href="#项目" class="headerlink" title="项目"></a>项目</h1><p>因为是cpp的岗位，所以没有问python的机器人项目问题；</p><h2 id="1-视频点播传一半关闭了怎么解决"><a href="#1-视频点播传一半关闭了怎么解决" class="headerlink" title="1.视频点播传一半关闭了怎么解决"></a>1.视频点播传一半关闭了怎么解决</h2><p>两次面试都问到了这个问题，我提到了将新的文件和本地已有文件进行校验，跳过已有数据</p><h2 id="2-传一半剩下的数据后端怎么处理，什么时候删除？"><a href="#2-传一半剩下的数据后端怎么处理，什么时候删除？" class="headerlink" title="2.传一半剩下的数据后端怎么处理，什么时候删除？"></a>2.传一半剩下的数据后端怎么处理，什么时候删除？</h2><p>我提到了前后端用md5验证来确认视频文件无误，如果有问题，可以设置一个定时器，一小时后删除错误的数据</p><h2 id="3-用户修改了视频后上传怎么处理？"><a href="#3-用户修改了视频后上传怎么处理？" class="headerlink" title="3.用户修改了视频后上传怎么处理？"></a>3.用户修改了视频后上传怎么处理？</h2><p>同第一个，进行一定的数据校验，然后再复写没有的数据；</p><blockquote><p>然而这些功能我一个都没有实现🤣</p></blockquote><h1 id="效率"><a href="#效率" class="headerlink" title="效率"></a>效率</h1><p>面经还没写完，结果已经出啦，过了初试！但是要线下复试；</p>]]></content>
    
    
    <summary type="html">230915上海戎磐网络科技C/LINUX实习生</summary>
    
    
    
    <category term="求职路上一去不复返" scheme="https://blog.musnow.top/categories/%E6%B1%82%E8%81%8C%E8%B7%AF%E4%B8%8A%E4%B8%80%E5%8E%BB%E4%B8%8D%E5%A4%8D%E8%BF%94/"/>
    
    
    <category term="面经" scheme="https://blog.musnow.top/tags/%E9%9D%A2%E7%BB%8F/"/>
    
  </entry>
  
</feed>
