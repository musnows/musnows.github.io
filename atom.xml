<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>慕雪的寒舍</title>
  
  <subtitle>雪下了一夜</subtitle>
  <link href="https://blog.musnow.top/atom.xml" rel="self"/>
  
  <link href="https://blog.musnow.top/"/>
  <updated>2023-12-27T08:45:00.000Z</updated>
  <id>https://blog.musnow.top/</id>
  
  <author>
    <name>慕雪年华</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>【网络】P2P打洞原理</title>
    <link href="https://blog.musnow.top/posts/725561575/"/>
    <id>https://blog.musnow.top/posts/725561575/</id>
    <published>2023-12-27T08:40:00.000Z</published>
    <updated>2023-12-27T08:45:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="引入"><a href="#引入" class="headerlink" title="引入"></a>引入</h1><p>如果你折腾过NAS或者BT下载等等玩意，可能听说过“P2P打洞”这一技术名词。简单来说，P2P打洞可以让我们直接在外网访问内网的设备，从而让没有公网IP的家庭设备也能获得“公网直连”的速度。</p><p>比如绿联、极空间等国产NAS的客户端，在外网访问的时候，都会先尝试P2P打洞让你和你的NAS实现P2P直连，打洞失败的时候才会采用服务器转发的方式；</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">P2P打洞后：你的当前设备和家里的NAS直接通信</span><br><span class="line">采用服务器转发：报文从家里NAS - 服务器 - 你的当前设备</span><br></pre></td></tr></table></figure><p>因为服务器转发的速度直接依赖于服务器的出口带宽，所以使用服务器转发的用户越多，速度也就越慢，有的时候你会发现服务器转发的速度甚至不如没开会员的某度云盘。</p><h1 id="前置技术了解"><a href="#前置技术了解" class="headerlink" title="前置技术了解"></a>前置技术了解</h1><p>在学习P2P打洞之前，你需要了解以下知识点。注意，本文只是对P2P打洞的<strong>简单理解和说明</strong>，深入了解底层原理请自行百度其他更详细的文章！</p><h2 id="什么是P2P？"><a href="#什么是P2P？" class="headerlink" title="什么是P2P？"></a>什么是P2P？</h2><p>P2P即 Peer to Peer，是一种对等连接方式，纯P2P架构包含如下内容</p><ul><li>没有总是在线的服务器</li><li>任意端之间直接通信</li><li>对等方之间可以间断链接，并可以动态改变IP地址</li></ul><p>P2P技术的实际的用例如下：</p><ul><li>文件分发（BT下载）</li><li>流媒体</li><li>VolP</li><li>内网穿透式访问（建立P2P链接，直接和内网主机通信）即本文即将要讲述的P2P打洞。</li></ul><h2 id="NAT"><a href="#NAT" class="headerlink" title="NAT"></a>NAT</h2><p>参考本站 <a href="https://blog.musnow.top/posts/3482559497">IP层和数据链路层</a> 博客中4.3节对NAT技术的解析。</p><h3 id="地址限制锥形NAT"><a href="#地址限制锥形NAT" class="headerlink" title="地址限制锥形NAT"></a>地址限制锥形NAT</h3><p>所谓地址限制锥形NAT，即NAT映射之后的外网端口和IP地址对请求具有一定的限制，体现为它只允许已建立链接的主机与之进行通信。</p><ul><li>局域网主机C需要和公网服务器S1进行通信</li><li>局域网主机C发送请求报文，通过运营商路由器转发，抵达S1服务器</li><li>这个过程中每一层的路由器都建立了一个NAT转发表</li><li>如果是限制锥形NAT，运营商的路由器将会限制该NAT地址的外网访问IP地址：<ul><li>只有S1服务器发来的报文能被正常往内网转发（端口不限制），发送给给局域网主机C；</li><li>其他公网服务器（和S1不同IP地址）如果企图向该NAT地址发送报文，会被运营商路由器拒绝；</li></ul></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">限制锥形NAT下</span><br><span class="line">C请求 1.1.1.1:8080</span><br><span class="line">只有 1.1.1.1 这个IP能发送报文给NAT地址，端口不限制</span><br><span class="line">其他来源IP都会被拒绝</span><br></pre></td></tr></table></figure><h3 id="端口限制锥形NAT"><a href="#端口限制锥形NAT" class="headerlink" title="端口限制锥形NAT"></a>端口限制锥形NAT</h3><p>在限制锥形NAT的基础上，添加了端口的限制，即只有局域网设备C请求过的S1的端口才能发送信息给局域网主机。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">端口限制锥形NAT下</span><br><span class="line">C请求 1.1.1.1:8080</span><br><span class="line">只有 1.1.1.1:8080 能发送报文给NAT地址</span><br><span class="line">其他来源IP或者1.1.1.1上不同的端口发来的报文都会被拒绝</span><br></pre></td></tr></table></figure><h3 id="完全锥形NAT"><a href="#完全锥形NAT" class="headerlink" title="完全锥形NAT"></a>完全锥形NAT</h3><p>完全锥形NAT的映射过程同上，但是不会对外网访问做限制。即NAT地址建立后，<strong>任何外网主机都可以发送信息给这个NAT地址</strong>。</p><h3 id="对称式NAT"><a href="#对称式NAT" class="headerlink" title="对称式NAT"></a>对称式NAT</h3><p>对称式NAT把内网IP和端口到相同目的地址和端口的所有请求，都映射到同一个公网地址和端口；同一个内网主机，用相同的内网IP和端口向另外一个目的地址发送报文，则会用不同的映射（比如映射到不同的端口）。</p><p>和端口限制式NAT不同的是，端口限制式NAT是所有请求映射到相同的公网IP地址和端口，而对称式NAT是<strong>为不同的请求建立不同的映射</strong>。它具有端口受限锥型的受限特性，内部地址每一次请求一个特定的外部地址，都可能会绑定到一个新的端口号。<strong>也就是请求不同的外部地址映射的端口号是可能不同的</strong>，甚至请求同一个主机的不同端口也会映射到不同的NAT地址上。</p><h3 id="NAT类型IP端口映射示意图"><a href="#NAT类型IP端口映射示意图" class="headerlink" title="NAT类型IP端口映射示意图"></a>NAT类型IP端口映射示意图</h3><p>根据NAT类型，可能产生如下映射表，<code>↔</code>符号左表示内网主机IP和端口，<code>↔</code>符号右表示NAT的外网IP和端口，<code>@</code>符号右表示限制条件：外网主机地址IP和端口。</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/20231227171258.png" alt="image.png"></p><p>通过这个表，也能反推出我们应该如何验证一个NAT的类型</p><ul><li>局域网客户端C向服务器S1发起请求，服务器S1能得到一个C的NAT地址和端口</li><li>服务器S1让C向自己的另外几个端口发起请求，如果这些请求的来源IP和端口都一致，则代表C是锥形NAT，如果出现了不同的端口，则代表是<strong>对称NAT</strong>；</li><li>服务器S1将这个地址和端口交给服务器S2，S2向C发送一个报文</li><li>如果C收到了这个S2发来的报文，代表是<strong>完全锥形NAT</strong>，不对外网来源做限制</li><li>如果C没有收到，说明是限制锥形NAT;</li><li>服务器S1换一个端口向C的NAT地址和端口发起请求；</li><li>如果C收到了，则代表是<strong>地址限制锥形NAT</strong>，对端口不做限制</li><li>如果C没有收到，则代表是<strong>端口限制锥形NAT</strong>，对地址和端口都做了限制<h1 id="P2P打洞过程"><a href="#P2P打洞过程" class="headerlink" title="P2P打洞过程"></a>P2P打洞过程</h1></li></ul><p>如果想实现P2P打洞，那么当前局域网内设备必须是在<strong>锥形NAT</strong>下，才能实现直接通信。因为在对称NAT下，NAT的端口地址会经常变化，很难实现稳定的连接。</p><p>对于锥形NAT，比较好打洞的自然是<code>完全锥形NAT</code>了，因为它对外网的来源IP和端口都不做限制，那么就可以用下面的流程来实现打洞</p><ul><li>需要中间服务器S</li><li>客户端C1和C2都是完全锥形NAT</li><li>客户端C1请求和C2实现P2P连接</li><li>客户端C1向中间服务器S发起请求，NAT会为C1维护一个端口和地址</li><li>服务器S收到C1的请求，并对内网客户端C2下发一个通知，让C2也来请求S</li><li>C2也向服务器发起一个请求，NAT为C2也维护了一个地址</li><li>此时服务器S就同时知道C1和C2通过NAT出来的一个公网端口和IP地址</li><li>服务器S将C1&#x2F;C2的<code>IP:端口</code>互相告知对方</li><li>C1和C2都得到了对方的IP和端口，因为是完全锥形NAT，双方可以直接通信</li><li>打洞完成</li></ul><p>这个过程中，中间服务器S是不可或缺的，如果没有这个中间服务器，C1和C2就很难知道对方的NAT公网IP和端口，也就没有办法直接实现通信。 </p><p>理论上来说，只要C1和C2有一方是<strong>完全锥形NAT</strong>，那么P2P打洞就是比较容易实现的，假设C1是完全锥形NAT，C2是有限制的NAT</p><ul><li>服务器S知道了C1的NAT的公网IP地址和端口后，将其告知C2；</li><li>C2重新对C1的完全锥形NAT发送请求，限制锥形NAT会对C2的新请求更新自己的限制表中的白名单，<strong>将C1的IP地址和端口也加入到了这个白名单中</strong>；此时限制锥形NAT的限制就消失了，C1和C2依旧可以点对点发起通信。</li></ul><p>如果打洞失败，C1和C2就得借助中间服务器S的转发来实现通信，此时通信的速度就会出现限制，同时，中间服务器S的带宽资费也比较感人，这也是为什么绿联和极空间虽然提供了中间服务器转发的方式，但依旧会想办法让你和你的NAS能实现P2P直接通信。除了能提高连接速度，更多的是节省它们服务器的带宽和资费。</p><p>P2P打洞的大概原理就是如此，更深层次的就不再研究了~你看明白了吗？</p>]]></content>
    
    
    <summary type="html">简单介绍P2P打洞的基本原理</summary>
    
    
    
    <category term="计算机网络" scheme="https://blog.musnow.top/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
    <category term="P2P" scheme="https://blog.musnow.top/tags/P2P/"/>
    
    <category term="计算机网络" scheme="https://blog.musnow.top/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>【Linux】gcc中__builtin_expect的作用</title>
    <link href="https://blog.musnow.top/posts/3259961914/"/>
    <id>https://blog.musnow.top/posts/3259961914/</id>
    <published>2023-12-26T07:36:00.000Z</published>
    <updated>2023-12-26T10:36:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="引入"><a href="#引入" class="headerlink" title="引入"></a>引入</h1><p>代码学习的时候，遇到了<code>__builtin_expect</code>这个之前从来没有遇到过的东西，网上搜了一下，发现纯C语言实现的GCD（Grand Central Dispatch）中就有定义过这个宏</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _safe_cast_to_long(x) \</span></span><br><span class="line"><span class="meta">        (&#123; _Static_assert(sizeof(typeof(x)) &lt;= sizeof(long), \</span></span><br><span class="line"><span class="meta">                <span class="string">&quot;__builtin_expect doesn&#x27;t support types wider than long&quot;</span>); \</span></span><br><span class="line"><span class="meta">                (long)(x); &#125;)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fastpath(x) ((typeof(x))__builtin_expect(_safe_cast_to_long(x), ~0l))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> slowpath(x) ((typeof(x))__builtin_expect(_safe_cast_to_long(x), 0l))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> likely(x) __builtin_expect(!!(x), 1)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> unlikely(x) __builtin_expect(!!(x), 0)</span></span><br></pre></td></tr></table></figure><p>我遇到的用法类似末尾的likely和unlikely，刚开始我误解了这个宏的所用，以为它会改变判断条件的结果，但实际上并非如此。</p><p>上面源码中的likely和unlikely这两个宏的使用方式如下，其中value是一个判断条件</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(likely(value))  <span class="comment">// 等价于 if(value) 只不过value可能为真的可能性更大。</span></span><br><span class="line"><span class="keyword">if</span>(unlikely(value))  <span class="comment">// 也等价于 if(value) 只不过value可能为假的可能性更大</span></span><br></pre></td></tr></table></figure><p>比如下面的这个代码，其含义是入参PTR这个指针为空的可能性很小，那么编译器就会对这里的分支判断做一定的优化，避免过度的跳转。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(<span class="built_in">unlikey</span>(<span class="literal">nullptr</span>==PTR))</span><br><span class="line">&#123; </span><br><span class="line">   <span class="comment">// 错误处理或者提示 </span></span><br><span class="line">&#125;       </span><br></pre></td></tr></table></figure><p>那这里是怎么个操作的呢？</p><h1 id="指令作用说明"><a href="#指令作用说明" class="headerlink" title="指令作用说明"></a>指令作用说明</h1><blockquote><p>参考：<a href="https://codeleading.com/article/9598651778/">__builtin_expect 总结</a></p></blockquote><p>这个指令是gcc编译器引入的，指令的写法为：<code>__builtin_expect(EXP, N)</code>，意思是：<code>EXP==N</code>的概率很大。</p><p>likely和unlikely这两个宏中使用了<code>!!(x)</code>是为了保证返回的结果一定是0或1，而不是一个其他无法和1&#x2F;0直接比较的表达式。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#define likely(x) __builtin_expect(!!(x), 1)</span><br><span class="line">#define unlikely(x) __builtin_expect(!!(x), 0)</span><br></pre></td></tr></table></figure><h2 id="普通分支的汇编"><a href="#普通分支的汇编" class="headerlink" title="普通分支的汇编"></a>普通分支的汇编</h2><p>比如我们一个判断条件的分支语句如下所示</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdbool.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">function</span><span class="params">(<span class="type">bool</span> flag)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (flag)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;all good!\n&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;this is wrong!\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    function(<span class="literal">true</span>);</span><br><span class="line">    function(<span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么默认情况下，编译器将这个代码编译成汇编的时候，也会按顺序进行处理。使用如下命令将<code>test.c</code>源文件生成出汇编文件<code>test.s</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">test:test.c</span><br><span class="line">gcc -fprofile-arcs -O2 -c test.c</span><br><span class="line">objdump -d test.o</span><br></pre></td></tr></table></figure><p>test.s中的内容如下（省略了一部分，只保留了function部分）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">0000000000000000 &lt;function&gt;:</span><br><span class="line">   0:   48 83 ec 08             sub    $0x8,%rsp</span><br><span class="line">   4:   40 84 ff                test   %dil,%dil</span><br><span class="line">   7:   74 27                   je     30 &lt;function+0x30&gt;</span><br><span class="line">   9:   bf 00 00 00 00          mov    $0x0,%edi</span><br><span class="line">   e:   48 83 05 00 00 00 00    addq   $0x1,0x0(%rip)        # 16 &lt;function+0x16&gt;</span><br><span class="line">  15:   01 </span><br><span class="line">  16:   e8 00 00 00 00          callq  1b &lt;function+0x1b&gt;</span><br><span class="line">  1b:   48 83 05 00 00 00 00    addq   $0x1,0x0(%rip)        # 23 &lt;function+0x23&gt;</span><br><span class="line">  22:   01 </span><br><span class="line">  23:   48 83 c4 08             add    $0x8,%rsp</span><br><span class="line">  27:   c3                      retq   </span><br><span class="line">  28:   0f 1f 84 00 00 00 00    nopl   0x0(%rax,%rax,1)</span><br><span class="line">  2f:   00 </span><br><span class="line">  30:   bf 00 00 00 00          mov    $0x0,%edi</span><br><span class="line">  35:   48 83 05 00 00 00 00    addq   $0x1,0x0(%rip)        # 3d &lt;function+0x3d&gt;</span><br><span class="line">  3c:   01 </span><br><span class="line">  3d:   e8 00 00 00 00          callq  42 &lt;function+0x42&gt;</span><br><span class="line">  42:   48 83 05 00 00 00 00    addq   $0x1,0x0(%rip)        # 4a &lt;function+0x4a&gt;</span><br><span class="line">  49:   01 </span><br><span class="line">  4a:   48 83 c4 08             add    $0x8,%rsp</span><br><span class="line">  4e:   c3                      retq   </span><br><span class="line">  4f:   90                      nop</span><br></pre></td></tr></table></figure><p>可以看到，这里是先通过<code>je     30 &lt;function+0x30&gt;</code>来判断当前flag是否为假，如果为假则跳到<code>30</code>处执行perror，如果不为假则继续执行<code>callq  1b &lt;function+0x1b&gt;</code>，即printf的打印。</p><p>je是一个汇编指令，和jz等价，判断的是运算结果的ZF标记位。对于ZF标记位而言，运算结果不为全0时Z&#x3D;0，运算结果为<strong>全0时Z&#x3D;1</strong>；所以<code>je 30</code>的意思是，如果运算结果为全0，则跳转到30标记处。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">0:   48 83 ec 08             sub    $0x8,%rsp</span><br><span class="line">4:   40 84 ff                test   %dil,%dil</span><br><span class="line">7:   74 27                   je     30 &lt;function+0x30&gt;</span><br></pre></td></tr></table></figure><p>je之前的两个汇编指令操作解析如下：</p><ul><li>sub是相减操作，使用<code>$0x8</code>位置的值<code>-%rsp</code>的结果，即<code>$0x8 -= %rsp</code>；</li><li>test指令和and指令等价，是按位与操作，但test命令不会改变值，只会改变标记位。但是这里的操作是<code>%dil</code>自己和自己按位与，得到的结果还是他自己……没太看明白什么含义</li></ul><p>但是，只从je本身的操作来考虑，这里的流程是这样的</p><ul><li>je 跳转到30，Z&#x3D;1的时候跳转到30，运算结果为全0的时候跳转到30，可以理解为flag为0的时候跳转到30（因为30处是perror的打印）</li><li>Z&#x3D;0，运算结果不为30的时候，不跳转，继续执行printf的打印</li></ul><p>这里为什么说30处是perror的打印呢？因为使用如下汇编命令整理出的<code>test.s</code>文件中可以看到更详细的过程</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">test:test.c</span></span><br><span class="line">gcc -E test.c -o test.i -O2 &amp;&amp; \</span><br><span class="line">gcc -S test.i -o test.s -O2 </span><br></pre></td></tr></table></figure><p>从<code>test.s</code>可以看到，在默认情况下，通过je判断后会跳到<code>.L2</code>处执行perror的调用，或继续往后执行<code>puts</code>即printf的调用。因为它们的顺序和上面获得的汇编一样，所以我认为在上面的汇编中<code>je 30</code>是跳转到执行perror的操作。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">function:</span><br><span class="line">.LFB11:</span><br><span class="line">.cfi_startproc</span><br><span class="line">testb%dil, %dil</span><br><span class="line">je.L2</span><br><span class="line">movl$.LC0, %edi</span><br><span class="line">jmpputs</span><br><span class="line">.p2align 4,,10</span><br><span class="line">.p2align 3</span><br><span class="line">.L2:</span><br><span class="line">movl$.LC1, %edi</span><br><span class="line">jmpperror</span><br><span class="line">.cfi_endproc</span><br><span class="line">.LFE11:</span><br><span class="line">.sizefunction, .-function</span><br><span class="line">.p2align 4,,15</span><br><span class="line">.globlfunction_likely</span><br><span class="line">.typefunction_likely, @function</span><br></pre></td></tr></table></figure><h2 id="添加builtin-expect之后的汇编"><a href="#添加builtin-expect之后的汇编" class="headerlink" title="添加builtin_expect之后的汇编"></a>添加builtin_expect之后的汇编</h2><h3 id="示例1"><a href="#示例1" class="headerlink" title="示例1"></a>示例1</h3><p>上方的代码，在加上<code>__builtin_expect</code>的unlikely和likely之后，新代码如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">function_likely</span><span class="params">(<span class="type">bool</span> flag)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (likely(flag))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;all good!\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;this is wrong!\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">function_unlikely</span><span class="params">(<span class="type">bool</span> flag)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (unlikely(flag))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;all good!\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;this is wrong!\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用相同命令进行编译，得到汇编如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">0000000000000050 &lt;function_likely&gt;:</span><br><span class="line">  50:   48 83 ec 08             sub    $0x8,%rsp</span><br><span class="line">  54:   40 84 ff                test   %dil,%dil</span><br><span class="line">  57:   74 27                   je     80 &lt;function_likely+0x30&gt;</span><br><span class="line">  59:   bf 00 00 00 00          mov    $0x0,%edi</span><br><span class="line">  5e:   48 83 05 00 00 00 00    addq   $0x1,0x0(%rip)        # 66 &lt;function_likely+0x16&gt;</span><br><span class="line">  65:   01 </span><br><span class="line">  66:   e8 00 00 00 00          callq  6b &lt;function_likely+0x1b&gt;</span><br><span class="line">  6b:   48 83 05 00 00 00 00    addq   $0x1,0x0(%rip)        # 73 &lt;function_likely+0x23&gt;</span><br><span class="line">  72:   01 </span><br><span class="line">  73:   48 83 c4 08             add    $0x8,%rsp</span><br><span class="line">  77:   c3                      retq   </span><br><span class="line">  78:   0f 1f 84 00 00 00 00    nopl   0x0(%rax,%rax,1)</span><br><span class="line">  7f:   00 </span><br><span class="line">  80:   bf 00 00 00 00          mov    $0x0,%edi</span><br><span class="line">  85:   48 83 05 00 00 00 00    addq   $0x1,0x0(%rip)        # 8d &lt;function_likely+0x3d&gt;</span><br><span class="line">  8c:   01 </span><br><span class="line">  8d:   e8 00 00 00 00          callq  92 &lt;function_likely+0x42&gt;</span><br><span class="line">  92:   48 83 05 00 00 00 00    addq   $0x1,0x0(%rip)        # 9a &lt;function_likely+0x4a&gt;</span><br><span class="line">  99:   01 </span><br><span class="line">  9a:   eb d7                   jmp    73 &lt;function_likely+0x23&gt;</span><br><span class="line">  9c:   0f 1f 40 00             nopl   0x0(%rax)</span><br><span class="line"></span><br><span class="line">00000000000000a0 &lt;function_unlikely&gt;:</span><br><span class="line">  a0:   48 83 ec 08             sub    $0x8,%rsp</span><br><span class="line">  a4:   40 84 ff                test   %dil,%dil</span><br><span class="line">  a7:   75 27                   jne    d0 &lt;function_unlikely+0x30&gt;</span><br><span class="line">  a9:   bf 00 00 00 00          mov    $0x0,%edi</span><br><span class="line">  ae:   48 83 05 00 00 00 00    addq   $0x1,0x0(%rip)        # b6 &lt;function_unlikely+0x16&gt;</span><br><span class="line">  b5:   01 </span><br><span class="line">  b6:   e8 00 00 00 00          callq  bb &lt;function_unlikely+0x1b&gt;</span><br><span class="line">  bb:   48 83 05 00 00 00 00    addq   $0x1,0x0(%rip)        # c3 &lt;function_unlikely+0x23&gt;</span><br><span class="line">  c2:   01 </span><br><span class="line">  c3:   48 83 c4 08             add    $0x8,%rsp</span><br><span class="line">  c7:   c3                      retq   </span><br><span class="line">  c8:   0f 1f 84 00 00 00 00    nopl   0x0(%rax,%rax,1)</span><br><span class="line">  cf:   00 </span><br><span class="line">  d0:   bf 00 00 00 00          mov    $0x0,%edi</span><br><span class="line">  d5:   48 83 05 00 00 00 00    addq   $0x1,0x0(%rip)        # dd &lt;function_unlikely+0x3d&gt;</span><br><span class="line">  dc:   01 </span><br><span class="line">  dd:   e8 00 00 00 00          callq  e2 &lt;function_unlikely+0x42&gt;</span><br><span class="line">  e2:   48 83 05 00 00 00 00    addq   $0x1,0x0(%rip)        # ea &lt;function_unlikely+0x4a&gt;</span><br><span class="line">  e9:   01 </span><br><span class="line">  ea:   eb d7                   jmp    c3 &lt;function_unlikely+0x23&gt;</span><br></pre></td></tr></table></figure><p>可以看到，对于<code>function_likely</code>中likely括起来的flag判断，是认为flag大概率为真，所以其进行的是je判断；而对于unlikely括起来的操作，认为flag大概率为假，所以用的是jne进行判断</p><p>je和jne功能相反，都是判断ZF标记位</p><ul><li>je：ZF&#x3D;1的时候跳转</li><li>jne：ZF&#x3D;0的时候跳转</li></ul><h3 id="示例2"><a href="#示例2" class="headerlink" title="示例2"></a>示例2</h3><p>上面的例子用的printf和perror库函数，我们不太好观察到二者的差别，改成如下代码再次进行测试，能更明显的看到二者优化后的不同。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdbool.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> likely(x) __builtin_expect(!!(x), 1)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> unlikely(x) __builtin_expect(!!(x), 0)</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">test_likely</span><span class="params">(<span class="type">int</span> x)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(likely(x))</span><br><span class="line">    &#123;</span><br><span class="line">        x = <span class="number">5</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        x = <span class="number">6</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">test_unlikely</span><span class="params">(<span class="type">int</span> x)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(unlikely(x))</span><br><span class="line">    &#123;</span><br><span class="line">        x = <span class="number">5</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        x = <span class="number">6</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    test_likely(<span class="number">1</span>);</span><br><span class="line">    test_likely(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用相同命令进行编译</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">main:main.c</span><br><span class="line">gcc -fprofile-arcs -O2 -c main.c</span><br><span class="line">objdump -d main.o</span><br></pre></td></tr></table></figure><p>得到汇编输出如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">0000000000000000 &lt;test_likely&gt;:</span><br><span class="line">   0:   48 83 05 00 00 00 00    addq   $0x1,0x0(%rip)        # 8 &lt;test_likely+0x8&gt;</span><br><span class="line">   7:   01 </span><br><span class="line">   8:   b8 05 00 00 00          mov    $0x5,%eax</span><br><span class="line">   d:   85 ff                   test   %edi,%edi</span><br><span class="line">   f:   74 07                   je     18 &lt;test_likely+0x18&gt;</span><br><span class="line">  11:   c3                      retq   </span><br><span class="line">  12:   66 0f 1f 44 00 00       nopw   0x0(%rax,%rax,1)</span><br><span class="line">  18:   48 83 05 00 00 00 00    addq   $0x1,0x0(%rip)        # 20 &lt;test_likely+0x20&gt;</span><br><span class="line">  1f:   01 </span><br><span class="line">  20:   b8 06 00 00 00          mov    $0x6,%eax</span><br><span class="line">  25:   c3                      retq   </span><br><span class="line">  26:   66 2e 0f 1f 84 00 00    nopw   %cs:0x0(%rax,%rax,1)</span><br><span class="line">  2d:   00 00 00 </span><br><span class="line"></span><br><span class="line">0000000000000030 &lt;test_unlikely&gt;:</span><br><span class="line">  30:   85 ff                   test   %edi,%edi</span><br><span class="line">  32:   75 14                   jne    48 &lt;test_unlikely+0x18&gt;</span><br><span class="line">  34:   48 83 05 00 00 00 00    addq   $0x1,0x0(%rip)        # 3c &lt;test_unlikely+0xc&gt;</span><br><span class="line">  3b:   01 </span><br><span class="line">  3c:   b8 06 00 00 00          mov    $0x6,%eax</span><br><span class="line">  41:   c3                      retq   </span><br><span class="line">  42:   66 0f 1f 44 00 00       nopw   0x0(%rax,%rax,1)</span><br><span class="line">  48:   48 83 05 00 00 00 00    addq   $0x1,0x0(%rip)        # 50 &lt;test_unlikely+0x20&gt;</span><br><span class="line">  4f:   01 </span><br><span class="line">  50:   b8 05 00 00 00          mov    $0x5,%eax</span><br><span class="line">  55:   c3                      retq   </span><br></pre></td></tr></table></figure><p>在这个例子中可以很明显的观察到，对于likely的函数操作，je后紧跟着的是</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">11:   c3                      retq   </span><br><span class="line">12:   66 0f 1f 44 00 00       nopw   0x0(%rax,%rax,1)</span><br></pre></td></tr></table></figure><p>而对于unlikely操作中，jne后面紧跟着的是</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">34:   48 83 05 00 00 00 00    addq   $0x1,0x0(%rip)        # 3c &lt;test_unlikely+0xc&gt;</span><br><span class="line">3b:   01 </span><br><span class="line">3c:   b8 06 00 00 00          mov    $0x6,%eax</span><br></pre></td></tr></table></figure><p>两个操作的顺序正好倒过来了，符合优化的预期！</p><h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>通过上面的两个例子，<code>__builtin_expect</code>的优化作用就体现出来了</p><ul><li>当我们认为flag<strong>大概率为假</strong>的时候，使用jne判断为真的情况，如果是真才跳转。为假继续往后执行；</li><li>如果我们认为flag<strong>大概率为真</strong>的时候，使用je判断为假的情况，如果是假才进行跳转。为真继续往后执行；</li></ul><p>相比于直接往后执行汇编，跳转是需要一定消耗的！使用该宏进行优化后，编译器会把更有可能执行的操作放在判断语句之后，<strong>避免多次跳转产生的消耗</strong>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(likely(flag))&#123;</span><br><span class="line"><span class="comment">//A</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line"><span class="comment">//B</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再用这个简单的demo来说明一下：</p><ul><li>使用likely进行flag判断的时候，汇编语句中会使用je判断，并把A紧跟着je判断之后；</li><li>使用unlikey进行flag判断的时候，汇编语句中会使用jne判断，并把B紧跟着jne判断之后；</li></ul><p>因为依照更有可能发生的情况来生成不同的汇编代码，<strong>减少了跳转次数</strong>，自然优化了性能！你看明白了吗？</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2023/02/202211021557390.jpg" alt="好得很"></p>]]></content>
    
    
    <summary type="html">gcc中__builtin_expect的作用</summary>
    
    
    
    <category term="玩上Linux" scheme="https://blog.musnow.top/categories/%E7%8E%A9%E4%B8%8ALinux/"/>
    
    
    <category term="Linux" scheme="https://blog.musnow.top/tags/Linux/"/>
    
    <category term="C语言" scheme="https://blog.musnow.top/tags/C%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title>【Linux】Ubuntu下快速切换gcc版本</title>
    <link href="https://blog.musnow.top/posts/1907126934/"/>
    <id>https://blog.musnow.top/posts/1907126934/</id>
    <published>2023-12-26T06:36:00.000Z</published>
    <updated>2023-12-26T06:36:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>本文将介绍如何在Ubuntu22.04版本下实现gcc版本的快速切换。</p><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>有的时候，不同版本的gcc会造成一些细微的差异，导致相关的一些工具不兼容，比如用于单元测试覆盖率生成的gcov&#x2F;lcov工具，在不同的gcc版本下可能会出现不同的结果。</p><p>为了确定是否是gcc编译器版本不同造成的这些差异，有的时候需要在一台主机上装多个版本的gcc，不停的切换以测试问题。</p><p>假设我们的ubuntu主机上安装了gcc 11.4 版本和 gcc 9.5 版本，且当前gcc命令指向的是 11.4 版本，那么你可以使用<code>gcc-9</code>命令来使用9.5版本的gcc。</p><p>但是，对于一些已经写死使用gcc这个命令的脚本或编译工具而言，它们就不是那么好修改gcc为gcc-9的，我们需要做的就是让系统的gcc命令能在11.4版本和9.5版本之间<strong>进行切换</strong>。</p><p>其中一个办法是手动替换gcc和g++的命令软连接，但是这个方法并不方便，ubuntu下有更好的操作，请看下文。</p><h1 id="安装gcc9-5"><a href="#安装gcc9-5" class="headerlink" title="安装gcc9.5"></a>安装gcc9.5</h1><p>默认情况下，ubuntu22.04安装的gcc版本是11.4</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt; gcc --version          </span><br><span class="line">gcc (Ubuntu 11.4.0-1ubuntu1~22.04) 11.4.0</span><br><span class="line">Copyright (C) 2021 Free Software Foundation, Inc.</span><br><span class="line">This is free software; see the source for copying conditions.  There is NO</span><br><span class="line">warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.</span><br></pre></td></tr></table></figure><p>先给你的主机安装上gcc9.4版本</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install gcc-9 g++-9</span><br></pre></td></tr></table></figure><p>安装之后，你应该可以通过<code>gcc-9</code>命令来使用9.5版本的gcc了</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt; g++-9 --version</span><br><span class="line">g++-9 (Ubuntu 9.5.0-1ubuntu1~22.04) 9.5.0</span><br><span class="line">Copyright (C) 2019 Free Software Foundation, Inc.</span><br><span class="line">This is free software; see the source for copying conditions.  There is NO</span><br><span class="line">warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.</span><br></pre></td></tr></table></figure><h1 id="配置update-alternatives"><a href="#配置update-alternatives" class="headerlink" title="配置update-alternatives"></a>配置update-alternatives</h1><p>我们可以将11和9版本添加到update-alternatives工具中，就可以方便的切换，不需要手动设置命令的软连接。</p><h2 id="工具基本使用命令"><a href="#工具基本使用命令" class="headerlink" title="工具基本使用命令"></a>工具基本使用命令</h2><p>如下是工具使用的一个基本示例</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo update-alternatives --install /usr/bin/gcc gcc /usr/bin/gcc-11 20 --slave /usr/bin/g++ g++ /usr/bin/g++-11</span><br></pre></td></tr></table></figure><ol><li><code>--install</code> 代表我们需要注册一个新的服务名</li><li><code>/usr/bin/gcc</code> 代表我们目标的最终地址，切换软链接的时候会切换该地址的软链接</li><li><code>gcc</code>代表我们用于管理服务的名字</li><li><code>/usr/bin/gcc-11</code> 代表被管理的命令的绝对路径（会用这个命令来替换第二个参数的软链接）</li><li><code>20</code> 代表优先级，数字越大优先级越高。</li><li><code>--slave</code> 代表从属命令，参数顺序和前面这几个是一样的，配置的是g++命令</li></ol><p>在update-alternatives命令的帮助中可以看到install和slave的关系，slave命令就是跟着install命令来使用的</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">--install &lt;link&gt; &lt;name&gt; &lt;path&gt; &lt;priority&gt;</span><br><span class="line">   [--slave &lt;link&gt; &lt;name&gt; &lt;path&gt;] ...</span><br><span class="line">                          add a group of alternatives to the system.</span><br></pre></td></tr></table></figure><p>它是什么意思呢？其实就是让主从命令有一个对应关系：当我们把gcc命令切换成11版本后，作为slave的g++命令也会跟着一起变化。</p><p>slave可以添加多个，后文会做演示。</p><h2 id="添加gcc版本配置"><a href="#添加gcc版本配置" class="headerlink" title="添加gcc版本配置"></a>添加gcc版本配置</h2><p>使用如下命令查看当前可以用来直接替换gcc的版本号，会发现么有，因为两个gcc版本都没有加入到这个工具中。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; sudo update-alternatives --config gcc</span><br><span class="line">update-alternatives: error: no alternatives for gcc</span><br></pre></td></tr></table></figure><p>使用如下命令查看一下当前装好的gcc包，可以看到有gcc 11和9。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&gt; dpkg -l | grep gcc</span><br><span class="line">ii  gcc                               4:11.2.0-1ubuntu1                                               amd64        GNU C compiler</span><br><span class="line">ii  gcc-11                            11.4.0-1ubuntu1~22.04                                           amd64        GNU C compiler</span><br><span class="line">ii  gcc-11-base:amd64                 11.4.0-1ubuntu1~22.04                                           amd64        GCC, the GNU Compiler Collection (base package)</span><br><span class="line">ii  gcc-12-base:amd64                 12.3.0-1ubuntu1~22.04                                           amd64        GCC, the GNU Compiler Collection (base package)</span><br><span class="line">ii  gcc-9                             9.5.0-1ubuntu1~22.04                                            amd64        GNU C compiler</span><br><span class="line">ii  gcc-9-base:amd64                  9.5.0-1ubuntu1~22.04                                            amd64        GCC, the GNU Compiler Collection (base package)</span><br><span class="line">ii  lib32gcc-s1                       12.3.0-1ubuntu1~22.04                                           amd64        GCC support library (32 bit Version)</span><br><span class="line">ii  libgcc-11-dev:amd64               11.4.0-1ubuntu1~22.04                                           amd64        GCC support library (development files)</span><br><span class="line">ii  libgcc-9-dev:amd64                9.5.0-1ubuntu1~22.04                                            amd64        GCC support library (development files)</span><br><span class="line">ii  libgcc-s1:amd64                   12.3.0-1ubuntu1~22.04                                           amd64        GCC support library</span><br></pre></td></tr></table></figure><p>执行如下命令将gcc-9添加到update-alternatives工具中，让我们可以通过config来切换gcc版本</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; sudo update-alternatives --install /usr/bin/gcc gcc /usr/bin/gcc-9 20 --slave /usr/bin/g++ g++ /usr/bin/g++-9</span><br><span class="line">update-alternatives: using /usr/bin/gcc-9 to provide /usr/bin/gcc (gcc) in auto mode</span><br></pre></td></tr></table></figure><p>使用如下命令查看可切换的gcc版本，因为当前只给工具里添加了一个gcc-9版本，所以会显示<code>only one alternative</code>，即只有一个可选项的意思，工具会认为没有啥好配置的。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt; sudo update-alternatives --config gcc</span><br><span class="line">There is only one alternative in link group gcc (providing /usr/bin/gcc): /usr/bin/gcc-9</span><br><span class="line">Nothing to configure.</span><br></pre></td></tr></table></figure><p>这时候我们可以把原本安装好的11.4版本的gcc也给添加到这个工具里面。优先级的数字可以根据你的情况自行调整</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo update-alternatives --install /usr/bin/gcc gcc /usr/bin/gcc-11 25 --slave /usr/bin/g++ g++ /usr/bin/g++-11</span><br></pre></td></tr></table></figure><h2 id="切换gcc版本成功"><a href="#切换gcc版本成功" class="headerlink" title="切换gcc版本成功"></a>切换gcc版本成功</h2><p>然后再次执行<code>sudo update-alternatives --config gcc</code>，此时就能看到两个版本的可选项了。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&gt; sudo update-alternatives --config gcc</span><br><span class="line">There are 2 choices for the alternative gcc (providing /usr/bin/gcc).</span><br><span class="line"></span><br><span class="line">  Selection    Path             Priority   Status</span><br><span class="line">------------------------------------------------------------</span><br><span class="line">* 0            /usr/bin/gcc-9    20        auto mode</span><br><span class="line">  1            /usr/bin/gcc-11   20        manual mode</span><br><span class="line">  2            /usr/bin/gcc-9    20        manual mode</span><br><span class="line"></span><br><span class="line">Press &lt;enter&gt; to keep the current choice[*], or type selection number:</span><br></pre></td></tr></table></figure><p>键入序号来选择你需要切换的gcc版本，回车即可</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt; gcc --version</span><br><span class="line">gcc (Ubuntu 9.5.0-1ubuntu1~22.04) 9.5.0</span><br><span class="line">Copyright (C) 2019 Free Software Foundation, Inc.</span><br><span class="line">This is free software; see the source for copying conditions.  There is NO</span><br><span class="line">warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.</span><br></pre></td></tr></table></figure><p>可以看到，当前的系统gcc已经被换成了9.5版本的了，切换成功！而且因为我们通过<code>--slave</code>配置了g++命令的替换操作，所以g++的版本也跟着一起替换成9.5了</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt; g++ --version</span><br><span class="line">g++ (Ubuntu 9.5.0-1ubuntu1~22.04) 9.5.0</span><br><span class="line">Copyright (C) 2019 Free Software Foundation, Inc.</span><br><span class="line">This is free software; see the source for copying conditions.  There is NO</span><br><span class="line">warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.</span><br></pre></td></tr></table></figure><p>将gcc换回gcc 11版本是相同的操作，这里不再赘述。</p><h2 id="添加多个slave"><a href="#添加多个slave" class="headerlink" title="添加多个slave"></a>添加多个slave</h2><p>和gcc捆绑的还有一个用于分支覆盖率检测的gcov命令，我们同样可以通过<code>--slave</code>选项将其绑定到版本中，让gcov的命令版本也会更着gcc版本一同切换</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt; sudo update-alternatives --install /usr/bin/gcc gcc /usr/bin/gcc-11 25 --slave /usr/bin/g++ g++ /usr/bin/g++-11 --slave /usr/bin/gcov gcov /usr/bin/gcov-11</span><br><span class="line">update-alternatives: updating alternative /usr/bin/gcc-11 because link group gcc has changed slave links</span><br><span class="line"></span><br><span class="line">&gt; sudo update-alternatives --install /usr/bin/gcc gcc /usr/bin/gcc-9 20 --slave /usr/bin/g++ g++ /usr/bin/g++-9 --slave /usr/bin/gcov gcov /usr/bin/gcov-9</span><br></pre></td></tr></table></figure><p>此时使用<code>sudo update-alternatives --config gcc</code>切换gcc版本后，gcov命令的版本也会跟着变化。这样我们能保证gcov和gcc版本是一致的，不会出现不一致导致的兼容性问题。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt; gcov --version</span><br><span class="line">gcov (Ubuntu 9.5.0-1ubuntu1~22.04) 9.5.0</span><br><span class="line">Copyright (C) 2019 Free Software Foundation, Inc.</span><br><span class="line">This is free software; see the source for copying conditions.</span><br><span class="line">There is NO warranty; not even for MERCHANTABILITY or </span><br><span class="line">FITNESS FOR A PARTICULAR PURPOSE.</span><br></pre></td></tr></table></figure><h2 id="从工具中删除gcc版本"><a href="#从工具中删除gcc版本" class="headerlink" title="从工具中删除gcc版本"></a>从工具中删除gcc版本</h2><p>如果需要从这个工具中删除某个版本，执行如下命令</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo update-alternatives --remove gcc /usr/bin/gcc-9 </span><br></pre></td></tr></table></figure><p>删除后就无法通过该工具切换gcc版本为9了。</p>]]></content>
    
    
    <summary type="html">Ubuntu22.04下快速切换gcc版本</summary>
    
    
    
    <category term="玩上Linux" scheme="https://blog.musnow.top/categories/%E7%8E%A9%E4%B8%8ALinux/"/>
    
    
    <category term="Linux" scheme="https://blog.musnow.top/tags/Linux/"/>
    
    <category term="C语言" scheme="https://blog.musnow.top/tags/C%E8%AF%AD%E8%A8%80/"/>
    
    <category term="Cpp" scheme="https://blog.musnow.top/tags/Cpp/"/>
    
  </entry>
  
  <entry>
    <title>【Python】Python实现文件分片加密和上传（未实现）</title>
    <link href="https://blog.musnow.top/posts/621478472/"/>
    <id>https://blog.musnow.top/posts/621478472/</id>
    <published>2023-12-18T08:52:00.000Z</published>
    <updated>2023-12-18T08:52:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h1><blockquote><p>项目地址：<a href="https://github.com/musnows/encrypt2bdy">musnows&#x2F;encrypt2bdy</a></p></blockquote><p>之前写的一篇博客提到了我的encrypt2bdy项目中，文件直接整个被读取到内存里面再计算md5，导致内存占用巨大的问题。后续解决方法是用分片的方式挨个读取文件块并计算md5。</p><p>但光是修改md5计算方式还不够，因为项目中还涉及到<strong>上传加密后文件</strong>的问题，且听我细细道来👇</p><h1 id="关于文件加密库"><a href="#关于文件加密库" class="headerlink" title="关于文件加密库"></a>关于文件加密库</h1><h2 id="cryptography-fernet"><a href="#cryptography-fernet" class="headerlink" title="cryptography.fernet"></a>cryptography.fernet</h2><p>我的加密解密操作使用的是Fernet这个库，它会创建一个密钥文件，并借密钥文件对字节流进行加密和解密操作。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">from cryptography.fernet import Fernet</span><br></pre></td></tr></table></figure><p>但是，Fernet框架不适合<strong>进行分片加密和解密</strong>。在我的尝试中，分片加密文件是可以的，但是<strong>解密</strong>的时候会因为密钥对不上而出现异常。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cryptography.fernet.InvalidToken – If the token is in any way invalid, this exception is raised. A token may be invalid for a number of reasons: it is older than the ttl, it is malformed, or it does not have a valid signature.</span><br></pre></td></tr></table></figure><p><a href="https://cryptography.io/en/latest/fernet/">官方文档</a>里面提到了，Fernet只适合用于能<strong>完全加载到内存</strong>里面的数据，不适合用于处理大文件。</p><blockquote><p>Limitations:<br>Fernet is ideal for encrypting data that easily fits in memory. As a design feature it does not expose unauthenticated bytes. This means that the complete message contents must be available in memory, making Fernet generally unsuitable for very large files at this time.</p></blockquote><p>在当前备份文件的这个场景下，将文件全部加载到内存里面是不合理的。所以需要换一个加密&#x2F;解密库</p><h2 id="pyAesCrypt"><a href="#pyAesCrypt" class="headerlink" title="pyAesCrypt"></a>pyAesCrypt</h2><p>改用pyAesCrypt了，加密和解密的处理非常简单，也可以分片加载。如下代码示例中，input_file是待加密文件，output_file是加密后文件，password是用户提供的加密密钥。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pyAesCrypt</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">encrypt_file</span>(<span class="params">input_file, output_file, password, buffer_size=<span class="number">64</span> * <span class="number">1024</span></span>):</span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(input_file, <span class="string">&#x27;rb&#x27;</span>) <span class="keyword">as</span> file_in, <span class="built_in">open</span>(output_file, <span class="string">&#x27;wb&#x27;</span>) <span class="keyword">as</span> file_out:</span><br><span class="line">        pyAesCrypt.encryptStream(file_in, file_out, password, buffer_size)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">decrypt_file</span>(<span class="params">input_file, output_file, password, buffer_size=<span class="number">64</span> * <span class="number">1024</span></span>):</span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(input_file, <span class="string">&#x27;rb&#x27;</span>) <span class="keyword">as</span> file_in, <span class="built_in">open</span>(output_file, <span class="string">&#x27;wb&#x27;</span>) <span class="keyword">as</span> file_out:</span><br><span class="line">        pyAesCrypt.decryptStream(file_in, file_out, password, buffer_size)</span><br></pre></td></tr></table></figure><p>只要用户还记得住自己的加密密钥，那么他就可以用解密函数将文件解密出来。</p><p>AES加密是当前广泛使用的对称加密方式，至于它是怎么实现的，能否被破解都是密码学的范畴了。我了解到的信息是，破解AES加密算法本身的消耗巨大，真要去破解，一般都会采用猜测密钥的方式（即猜测你是用什么密钥加密的这个文件）</p><p>所以当你需要使用AES密钥来加密文件的时候，一定要选用一个强密钥，保证数据不被轻易窃取。</p><p>当然，我的项目中，加密的目的很单纯，就是为了避<strong>免百度云盘扫我的相片和个人文件</strong>。防止文件被窃取只是个附带的功能。</p><p>实测，encrypt2bdy项目中采用pyAesCrypt库后，处理500MB文件的过程中内存占用都不会超过90MB，非常完美。</p><h3 id="密钥泄露问题？"><a href="#密钥泄露问题？" class="headerlink" title="密钥泄露问题？"></a>密钥泄露问题？</h3><p>更新后的项目还是采用环境变量的方式来加载用户密钥，至于环境变量方式是否会导致密钥泄露：别人都能看到你的docker配置了，他还取你的密钥干嘛，直接把本地源文件偷走了好吧……</p><p>就算不用环境变量，在配置文件&#x2F;前端里面填密钥，最终都还是需要一个位置来存放这个密钥 </p><p>除非直接把密钥存内存里面，不写入任何文件，且每次重启docker都<strong>要求用户重新填密钥</strong>。但是这样会导致容器可用性很差，毕竟每次操作docker容器都得重新弄一下配置。不过后续给某些对隐私要求高的老哥提供这个功能也不是不行。（这个功能必须要等前端写出来了之后才有可能实现）</p><h1 id="分片加密上传"><a href="#分片加密上传" class="headerlink" title="分片加密上传"></a>分片加密上传</h1><p>修改了加密库还是不够。来和我一起看看当前项目上传文件的逻辑吧，假设用户选择了加密上传</p><ul><li>分片读取文件，计算文件md5用于本地入库</li><li>分片读取和加密文件，并将<strong>加密后文件</strong>添加<code>.e2bdy</code>后缀写入源目录</li><li><strong>分片读取和上传</strong>加密后文件</li><li>上传完毕，删除加密后文件（只保留源文件）</li><li>循环处理，直到选定目录中所有文件都被处理完毕。</li></ul><p>整个程序逻辑都采用了分片读取文件，内存占用问题是解决了，但还有另外一个问题没有解决：加密后文件需要写入磁盘，上传后又被删除。</p><p>也就是说，假设我需要备份100GB的文件，那么磁盘就会多出100GB的数据擦写……程序也需要累积等待100GB的磁盘写入，如果是机械硬盘……</p><p>而且，磁盘还需要<strong>保留有足量空间</strong>来存放这个临时的加密文件，假设我想备份一个10GB的单个文件，磁盘剩余可用空间只剩5GB了，此时程序<strong>就无法将加密后的文件写入磁盘</strong>（一般加密后的文件会比原始文件略大一些），导致无法处理这个文件了。</p><p>这样肯定不行！所以我换了一个思路，百度云盘要求数据按4MB的分片调用API上传，<strong>那么我们可否每次读取4MB的文件内容，加密它并保存在内存中，随后直接上传这个分片呢</strong>？这样整个的处理流程中，都是分片后在内存中处理，也不会多出来一个临时的加密文件导致的数据擦写，项目可用性提高！</p><p>问了GPT，写了个这样的示例代码</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> io</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> pyAesCrypt</span><br><span class="line"></span><br><span class="line"><span class="comment"># 加密函数</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">encrypt_chunk</span>(<span class="params">chunk_data, password</span>):</span><br><span class="line">    <span class="comment"># 加密数据块</span></span><br><span class="line">    <span class="keyword">with</span> io.BytesIO() <span class="keyword">as</span> block_encrypted:</span><br><span class="line">        pyAesCrypt.encryptStream(</span><br><span class="line">            io.BytesIO(chunk_data),</span><br><span class="line">            block_encrypted,</span><br><span class="line">            password</span><br><span class="line">        )</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 返回加密后的数据</span></span><br><span class="line">        <span class="keyword">return</span> block_encrypted.getvalue()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 上传函数</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">upload_chunk_to_cloud</span>(<span class="params">chunk_data</span>):</span><br><span class="line">    <span class="comment"># 将加密后的数据块上传到云端</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 主程序</span></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    src_path = <span class="string">&#x27;path/to/source/file&#x27;</span></span><br><span class="line">    password = <span class="string">&#x27;your-password&#x27;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(src_path, <span class="string">&#x27;rb&#x27;</span>) <span class="keyword">as</span> src_file:</span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">            <span class="comment"># 读取一个数据块</span></span><br><span class="line">            chunk = src_file.read(<span class="number">4</span> * <span class="number">1024</span> * <span class="number">1024</span>)</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> chunk:</span><br><span class="line">                <span class="comment"># 数据块读取完毕，退出循环</span></span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">            <span class="comment"># 加密数据块</span></span><br><span class="line">            encrypted_chunk = encrypt_chunk(chunk, password)</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 上传加密后的数据块到云端</span></span><br><span class="line">            upload_chunk_to_cloud(encrypted_chunk)</span><br></pre></td></tr></table></figure><p>现在我要做的，就是验证一下这样操作是否能上传成功、是否能解密上传后的文件，然后再看看内存占用多少。</p><h2 id="分片加密和直接加密区别"><a href="#分片加密和直接加密区别" class="headerlink" title="分片加密和直接加密区别"></a>分片加密和直接加密区别</h2><p>然而第一部我就卡住了：百度云盘的API要求上传前先传入文件的完整md5，也就是说，<strong>我得想个办法拿到加密后文件的完整md5</strong>！</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> io</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> hashlib</span><br><span class="line"><span class="keyword">import</span> pyAesCrypt</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 加密函数</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">encrypt_chunk</span>(<span class="params">chunk_data, password</span>):</span><br><span class="line">    <span class="comment"># 加密数据块</span></span><br><span class="line">    <span class="keyword">with</span> io.BytesIO() <span class="keyword">as</span> block_encrypted:</span><br><span class="line">        pyAesCrypt.encryptStream(io.BytesIO(chunk_data), block_encrypted,</span><br><span class="line">                                 password)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 返回加密后的数据</span></span><br><span class="line">        <span class="keyword">return</span> block_encrypted.getvalue()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">encrypt_file</span>(<span class="params">input_file_path: <span class="built_in">str</span>, passwd</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    加密文件，采用分片读取</span></span><br><span class="line"><span class="string">    :param input_file_path： 需要加密的源文件</span></span><br><span class="line"><span class="string">    :return 加密后的文件路径</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    encrypt_file_path = input_file_path + <span class="string">&quot;.ept&quot;</span></span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(input_file_path, <span class="string">&#x27;rb&#x27;</span>) <span class="keyword">as</span> file_in, <span class="built_in">open</span>(encrypt_file_path,</span><br><span class="line">                                                      <span class="string">&#x27;wb&#x27;</span>) <span class="keyword">as</span> file_out:</span><br><span class="line">        pyAesCrypt.encryptStream(file_in, file_out, passwd, <span class="number">4</span> * <span class="number">1024</span> * <span class="number">1024</span>)</span><br><span class="line">    <span class="keyword">return</span> encrypt_file_path</span><br><span class="line"></span><br><span class="line"><span class="comment"># 主程序</span></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    src_path = <span class="string">&#x27;/home/mu/code-wsl/py-wsl/encrypt2bdy/test/CloudDrive2Setup-X64-0.5.14.exe&#x27;</span></span><br><span class="line">    password = <span class="string">&#x27;test&#x27;</span></span><br><span class="line">    ept_file_path = encrypt_file(src_path,password)</span><br><span class="line">    <span class="comment"># 读取加密后文件计算md5</span></span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(ept_file_path, <span class="string">&#x27;rb&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">        file_md5_str = hashlib.md5(f.read()).hexdigest()</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;full encrypt&quot;</span>,file_md5_str)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 分片加密并计算md5</span></span><br><span class="line">    file_md5_str = hashlib.md5()</span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(src_path, <span class="string">&#x27;rb&#x27;</span>) <span class="keyword">as</span> src_file:</span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">            <span class="comment"># 读取一个数据块</span></span><br><span class="line">            chunk = src_file.read(<span class="number">4</span> * <span class="number">1024</span> * <span class="number">1024</span>)</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> chunk:</span><br><span class="line">                <span class="comment"># 数据块读取完毕，退出循环</span></span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">            <span class="comment"># 加密数据块</span></span><br><span class="line">            encrypted_chunk = encrypt_chunk(chunk, password)</span><br><span class="line">            file_md5_str.update(encrypted_chunk)</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;chunk encrypt&quot;</span>,file_md5_str.hexdigest())</span><br></pre></td></tr></table></figure><p>分片加密后的整个文件，和直接加密的文件肯定是不一样的，即便这两个操作都用了相同大小的分片块。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">╰─ python3.10 test.py</span><br><span class="line">full encrypt e994f5c7244fa7d6e9577e2089a029bc</span><br><span class="line">chunk encrypt bdd05213bcafe4f87470c90633d7c2bc</span><br></pre></td></tr></table></figure><p>但如果把分片后的文件写入本地，再计算md5，会发现二者相同</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 分片加密并计算md5</span></span><br><span class="line">file_md5_str = hashlib.md5()</span><br><span class="line">chunk_encrpy_file = src_path + <span class="string">&#x27;.test&#x27;</span></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(chunk_encrpy_file,<span class="string">&#x27;wb&#x27;</span>) <span class="keyword">as</span> ef:</span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(src_path, <span class="string">&#x27;rb&#x27;</span>) <span class="keyword">as</span> src_file:</span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">            <span class="comment"># 读取一个数据块</span></span><br><span class="line">            chunk = src_file.read(<span class="number">4</span> * <span class="number">1024</span> * <span class="number">1024</span>)</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> chunk:</span><br><span class="line">                <span class="comment"># 数据块读取完毕，退出循环</span></span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">            <span class="comment"># 加密数据块</span></span><br><span class="line">            encrypted_chunk = encrypt_chunk(chunk, password)</span><br><span class="line">            file_md5_str.update(encrypted_chunk)</span><br><span class="line">            ef.write(encrypted_chunk)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;chunk encrypt&quot;</span>,file_md5_str.hexdigest())</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;chunk encrypt file:&quot;</span>,file_md5(chunk_encrpy_file))</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">chunk encrypt 843ef6583227592da36e563c1700d0da</span><br><span class="line">chunk encrypt file: 843ef6583227592da36e563c1700d0da</span><br></pre></td></tr></table></figure><p>也就是说，虽然这种方式和直接加密整个文件，<strong>得到的最终文件是不一样的</strong>，但我们依旧可以通过用相同办法进行加密和解密操作，来进行分片加密上传和分片解密文件（吗？）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">raise ValueError(&quot;Bad HMAC (file is corrupted).&quot;)</span><br></pre></td></tr></table></figure><p>无法解密……G！</p><p>要期末了，等放假了再继续研究这个问题</p>]]></content>
    
    
    <summary type="html">Python实现文件分片加密和上传（未实现）</summary>
    
    
    
    <category term="速通Python" scheme="https://blog.musnow.top/categories/%E9%80%9F%E9%80%9APython/"/>
    
    
    <category term="Python" scheme="https://blog.musnow.top/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>【Python】Python分片计算文件md5</title>
    <link href="https://blog.musnow.top/posts/1918073551/"/>
    <id>https://blog.musnow.top/posts/1918073551/</id>
    <published>2023-12-17T11:52:00.000Z</published>
    <updated>2023-12-17T11:52:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="问题说明"><a href="#问题说明" class="headerlink" title="问题说明"></a>问题说明</h1><blockquote><p>项目地址：<a href="https://github.com/musnows/encrypt2bdy">musnows&#x2F;encrypt2bdy</a></p></blockquote><p>之前自己瞎写了一个上传文件到百度云的python程序，提供了docker并部署在了我自己的nas上，但是我限制容器可用内存大小为1GB后，总是会遇到docker因为<strong>内存爆满</strong>直接被系统kill了的情况。</p><p>现在总算有时间看看到底是啥问题了，其实我已经能想到了，上传文件的部分已经是按分片上传的，理论上不是那个地方的问题，另外一个打开文件的地方只有一处，就是计算文件整体md5的操作。</p><p>因为当时没想明白问题在哪里，我还在项目的README里面写了一个不建议用于备份大文件，因为内存会撑爆的提示（</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">## 已知错误</span><br><span class="line"></span><br><span class="line">### 1.docker退出码137</span><br><span class="line"></span><br><span class="line">内存不足时，系统将对应docker容器终止。出现此问题，请确认您要备份的文件中不会出现大于您系统内存或docker容器内存限制的文件。</span><br><span class="line"></span><br><span class="line">正如开头所说，本项目适合于备份照片、图片、文档等小文件，并不建议用于备份录像、电影等资源。</span><br></pre></td></tr></table></figure><h2 id="原有代码读取md5的方式"><a href="#原有代码读取md5的方式" class="headerlink" title="原有代码读取md5的方式"></a>原有代码读取md5的方式</h2><p>在程序中，我计算文件整体md5的操作是这样写的</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 打开文件</span></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(file_path, <span class="string">&#x27;rb&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">file_bytes = f.read()</span><br><span class="line"><span class="comment"># 1.计算文件md5，判断文件是否存在于数据中</span></span><br><span class="line">file_name = os.path.basename(file_path)  <span class="comment"># 文件名</span></span><br><span class="line">file_md5_str = hashlib.md5(file_bytes).hexdigest()</span><br><span class="line">_log.debug(<span class="string">f&quot;<span class="subst">&#123;file_path&#125;</span> | <span class="subst">&#123;file_md5_str&#125;</span>&quot;</span>)</span><br></pre></td></tr></table></figure><p>问题其实很明朗，就是这里的<code>f.read()</code>操作直接将<strong>整个文件加载到内存里面</strong>了！备份的文件稍微大一点，指定要把内存整爆的！</p><h2 id="分片读取md5"><a href="#分片读取md5" class="headerlink" title="分片读取md5"></a>分片读取md5</h2><p>这部分代码应该替换为如下形式，分片读取文件，并将读取的md5给update到<code>hashlib.md5()</code>对象中</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">file_md5</span>(<span class="params">file_path: <span class="built_in">str</span></span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;给定一个文件路径，分片加载文件，计算文件的md5&quot;&quot;&quot;</span></span><br><span class="line">    chunk_size = <span class="number">4096</span>  <span class="comment"># 根据需要调整单块的大小</span></span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(file_path, <span class="string">&#x27;rb&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">        file_md5 = hashlib.md5()</span><br><span class="line">        <span class="keyword">while</span> chunk := f.read(chunk_size):</span><br><span class="line">            file_md5.update(chunk)</span><br><span class="line">    <span class="keyword">return</span> file_md5.hexdigest()</span><br></pre></td></tr></table></figure><p>经过测试，这种办法计算出来的md5和直接<code>f.read()</code>全部计算出的md5完全一致</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">╰─ python3.10 test.py                 </span><br><span class="line">ca60e24bf4dde156a381c8b9d268faf5</span><br><span class="line">ca60e24bf4dde156a381c8b9d268faf5</span><br></pre></td></tr></table></figure><h1 id="内存占用监控线程"><a href="#内存占用监控线程" class="headerlink" title="内存占用监控线程"></a>内存占用监控线程</h1><p>用下面的代码弄个内存占用的监控线程，通过psutil库实时打印内存占用</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> psutil</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">monitor_memory_usage</span>():</span><br><span class="line">    process = psutil.Process(os.getpid())</span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        memory_info = process.memory_info()</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;Memory used: <span class="subst">&#123;memory_info.rss / (<span class="number">1024</span> * <span class="number">1024</span>):<span class="number">.2</span>f&#125;</span> MB&quot;</span>)</span><br><span class="line">        time.sleep(<span class="number">1</span>)  <span class="comment"># 每秒更新一次内存信息</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 启动一个线程来监视内存使用情况</span></span><br><span class="line">memory_monitor_thread = threading.Thread(target=monitor_memory_usage)</span><br><span class="line">memory_monitor_thread.start()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 主线程继续执行其他任务</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 等待监视线程结束（如果需要）</span></span><br><span class="line">memory_monitor_thread.join()</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="内存占用测试"><a href="#内存占用测试" class="headerlink" title="内存占用测试"></a>内存占用测试</h2><p>将项目中上传到百度云的部分注释掉，休眠10秒替代上传操作，模拟原有代码整体打开一个文件，又分片打开文件上传到百度云的流程。</p><p>用两个450MB左右的视频做测试。程序原有思路是遍历需要备份目录中的所有文件，分片上传到百度云。计算整个文件的MD5的操作其实是用来<strong>本地入库</strong>标定文件是否有修改、是否已经上传的。</p><p>不过后续<strong>加密文件</strong>的操作也是无脑<code>f.read()</code>，这部分也需要修改。</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2023/12/f053a510be9127854a6a2102cac8589f.png" alt="image.png"></p><p>日志输出如下，可以看到，开始处理test目录之后，程序直接把视频完整加载到了内存里面，占用内存的大小和视频文件大小基本一致。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">╰─ python3.10 main.py</span><br><span class="line">[23-12-17 20:01:22] INFO:confLoad.py:&lt;module&gt;:68 | [config] loaded config from &#x27;./config/config.yml&#x27;</span><br><span class="line">[23-12-17 20:01:22] INFO:confLoad.py:&lt;module&gt;:89 | [config] loaded config success</span><br><span class="line">[23-12-17 20:01:22] INFO:querySql.py:&lt;module&gt;:72 | [sqlite3] create all tables</span><br><span class="line">[23-12-17 20:01:23] INFO:main.py:&lt;module&gt;:294 | [start] start at 23-12-17 20:01:23</span><br><span class="line">[23-12-17 20:01:23] INFO:encrypt.py:__init__:24 | load key file from &#x27;./config/encrypt.key&#x27;</span><br><span class="line">Memory used: 39.18 MB</span><br><span class="line">[23-12-17 20:01:23] INFO:main.py:upload_task:132 | 上传任务开始：23-12-17 20:01:23</span><br><span class="line">[23-12-17 20:01:23] INFO:main.py:upload_task:139 | 开始处理路径 &#x27;/home/mu/code-wsl/py-wsl/encrypt2bdy/test&#x27; | 文件数量 2</span><br><span class="line">[23-12-17 20:01:23] INFO:main.py:upload_task:144 | [0] 开始处理 &#x27;/home/mu/code-wsl/py-wsl/encrypt2bdy/test/【超丝滑60帧】4K精装字幕版《ILLSHOWYOU》KDA阿狸.mp4&#x27;</span><br><span class="line">Memory used: 483.52 MB</span><br><span class="line">Memory used: 483.52 MB</span><br><span class="line">Memory used: 483.52 MB</span><br><span class="line">Memory used: 483.52 MB</span><br><span class="line">Memory used: 483.52 MB</span><br><span class="line">Memory used: 483.52 MB</span><br><span class="line">Memory used: 483.52 MB</span><br><span class="line">Memory used: 483.52 MB</span><br><span class="line">Memory used: 483.52 MB</span><br><span class="line">Memory used: 483.52 MB</span><br><span class="line">[23-12-17 20:01:33] INFO:main.py:upload_task:237 | [1] 成功上传 &#x27;/home/mu/code-wsl/py-wsl/encrypt2bdy/test/【超丝滑60帧】4K精装字幕版《ILLSHOWYOU》KDA阿狸.mp4&#x27; 文件哈希：7d5735eba55a638a1290ab36e00530ca</span><br><span class="line">[23-12-17 20:01:33] INFO:main.py:upload_task:144 | [1] 开始处理 &#x27;/home/mu/code-wsl/py-wsl/encrypt2bdy/test/【超丝滑60帧】4K精装字幕版《MORE》KDA.mp4&#x27;</span><br><span class="line">Memory used: 517.39 MB</span><br><span class="line">Memory used: 517.39 MB</span><br><span class="line">Memory used: 517.39 MB</span><br><span class="line">Memory used: 517.39 MB</span><br><span class="line">Memory used: 517.39 MB</span><br><span class="line">Memory used: 517.39 MB</span><br><span class="line">Memory used: 517.39 MB</span><br><span class="line">Memory used: 517.39 MB</span><br><span class="line">Memory used: 517.39 MB</span><br><span class="line">Memory used: 517.39 MB</span><br><span class="line">Memory used: 517.39 MB</span><br><span class="line">[23-12-17 20:01:44] INFO:main.py:upload_task:237 | [2] 成功上传 &#x27;/home/mu/code-wsl/py-wsl/encrypt2bdy/test/【超丝滑60帧】4K精装字幕版《MORE》KDA.mp4&#x27; 文件哈希：b7b0cd46e3ac7681a3644d9761ad3e71</span><br><span class="line">[23-12-17 20:01:44] INFO:main.py:upload_task:282 | 本次上传完毕，上传：2，跳过：0，错误：0 | 总计：2</span><br><span class="line">[23-12-17 20:01:44] INFO:main.py:upload_task:283 | 本次上传完毕，平均上传速度：43.143mb/s | 总耗时：21.16s</span><br><span class="line">[23-12-17 20:01:44] INFO:main.py:upload_task:286 | 本次上传完毕，下次处理：2023-12-17 21:00:00</span><br></pre></td></tr></table></figure><p>带上加密之后更加离谱，只是第一个文件就直接把内存占用干到了3.2GB，处理第二个文件的时候，也是直接干到了2.4GB，这种程度的内存消耗谁顶得住？更何况百度云API最大支持10GB的文件上传，如果要加载一个10GB的文件还得了啊？</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">╰─ python3.10 main.py</span><br><span class="line">[23-12-17 19:43:56] INFO:confLoad.py:&lt;module&gt;:68 | [config] loaded config from &#x27;./config/config.yml&#x27;</span><br><span class="line">[23-12-17 19:43:56] INFO:confLoad.py:&lt;module&gt;:89 | [config] loaded config success</span><br><span class="line">[23-12-17 19:43:56] INFO:querySql.py:&lt;module&gt;:72 | [sqlite3] create all tables</span><br><span class="line">[23-12-17 19:43:56] INFO:main.py:&lt;module&gt;:291 | [start] start at 23-12-17 19:43:56</span><br><span class="line">Memory used: 39.31 MB</span><br><span class="line">[23-12-17 19:43:56] INFO:encrypt.py:__init__:24 | load key file from &#x27;./config/encrypt.key&#x27;</span><br><span class="line">[23-12-17 19:43:56] INFO:main.py:upload_task:132 | 上传任务开始：23-12-17 19:43:56</span><br><span class="line">[23-12-17 19:43:56] INFO:main.py:upload_task:139 | 开始处理路径 &#x27;/home/mu/code-wsl/py-wsl/encrypt2bdy/test&#x27; | 文件数量 2</span><br><span class="line">Memory used: 923.04 MB</span><br><span class="line">Memory used: 3267.48 MB</span><br><span class="line">Memory used: 483.71 MB</span><br><span class="line">Memory used: 483.71 MB</span><br><span class="line">Memory used: 483.71 MB</span><br><span class="line">Memory used: 483.71 MB</span><br><span class="line">Memory used: 483.71 MB</span><br><span class="line">Memory used: 483.71 MB</span><br><span class="line">Memory used: 483.71 MB</span><br><span class="line">Memory used: 483.71 MB</span><br><span class="line">Memory used: 483.71 MB</span><br><span class="line">Memory used: 483.71 MB</span><br><span class="line">[23-12-17 19:44:08] INFO:main.py:upload_task:234 | [1] 成功上传 &#x27;/home/mu/code-wsl/py-wsl/encrypt2bdy/test/【超丝滑60帧】4K精装字幕版《ILLSHOWYOU》KDA阿狸.mp4&#x27; 文件哈希：7d5735eba55a638a1290ab36e00530ca</span><br><span class="line">Memory used: 990.96 MB</span><br><span class="line">Memory used: 2410.97 MB</span><br><span class="line">Memory used: 1622.17 MB</span><br><span class="line">Memory used: 517.57 MB</span><br><span class="line">Memory used: 517.57 MB</span><br><span class="line">Memory used: 517.57 MB</span><br><span class="line">Memory used: 517.57 MB</span><br><span class="line">Memory used: 517.57 MB</span><br><span class="line">Memory used: 517.57 MB</span><br><span class="line">Memory used: 517.57 MB</span><br><span class="line">Memory used: 517.57 MB</span><br><span class="line">Memory used: 517.57 MB</span><br><span class="line">Memory used: 517.57 MB</span><br><span class="line">[23-12-17 19:44:22] INFO:main.py:upload_task:234 | [2] 成功上传 &#x27;/home/mu/code-wsl/py-wsl/encrypt2bdy/test/【超丝滑60帧】4K精装字幕版《MORE》KDA.mp4&#x27; 文件哈希：b7b0cd46e3ac7681a3644d9761ad3e71</span><br><span class="line">[23-12-17 19:44:22] INFO:main.py:upload_task:279 | 本次上传完毕，上传：2，跳过：0，错误：0 | 总计：2</span><br><span class="line">[23-12-17 19:44:22] INFO:main.py:upload_task:280 | 本次上传完毕，平均上传速度：35.371mb/s | 总耗时：25.81s</span><br><span class="line">[23-12-17 19:44:22] INFO:main.py:upload_task:283 | 本次上传完毕，下次处理：2023-12-17 21:00:00</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>先将md5计算的函数给修改了，改成分片计算。可以看到，效果显著！内存占用和程序刚开始运行的时候差距只有5MB，这才是正常的内存占用！</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">╰─ python3.10 main.py</span><br><span class="line">[23-12-17 20:03:20] INFO:confLoad.py:&lt;module&gt;:68 | [config] loaded config from &#x27;./config/config.yml&#x27;</span><br><span class="line">[23-12-17 20:03:20] INFO:confLoad.py:&lt;module&gt;:89 | [config] loaded config success</span><br><span class="line">[23-12-17 20:03:20] INFO:querySql.py:&lt;module&gt;:72 | [sqlite3] create all tables</span><br><span class="line">[23-12-17 20:03:20] INFO:main.py:&lt;module&gt;:294 | [start] start at 23-12-17 20:03:20</span><br><span class="line">Memory used: 39.26 MB</span><br><span class="line">[23-12-17 20:03:20] INFO:encrypt.py:__init__:24 | load key file from &#x27;./config/encrypt.key&#x27;</span><br><span class="line">[23-12-17 20:03:20] INFO:main.py:upload_task:132 | 上传任务开始：23-12-17 20:03:20</span><br><span class="line">[23-12-17 20:03:20] INFO:main.py:upload_task:139 | 开始处理路径 &#x27;/home/mu/code-wsl/py-wsl/encrypt2bdy/test&#x27; | 文件数量 2</span><br><span class="line">[23-12-17 20:03:20] INFO:main.py:upload_task:144 | [0] 开始处理 &#x27;/home/mu/code-wsl/py-wsl/encrypt2bdy/test/【超丝滑60帧】4K精装字幕版《ILLSHOWYOU》KDA阿狸.mp4&#x27;</span><br><span class="line">Memory used: 44.08 MB</span><br><span class="line">Memory used: 44.08 MB</span><br><span class="line">Memory used: 44.08 MB</span><br><span class="line">Memory used: 44.08 MB</span><br><span class="line">Memory used: 44.08 MB</span><br><span class="line">Memory used: 44.08 MB</span><br><span class="line">Memory used: 44.08 MB</span><br><span class="line">Memory used: 44.08 MB</span><br><span class="line">Memory used: 44.08 MB</span><br><span class="line">Memory used: 44.08 MB</span><br><span class="line">Memory used: 44.08 MB</span><br><span class="line">[23-12-17 20:03:32] INFO:main.py:upload_task:237 | [1] 成功上传 &#x27;/home/mu/code-wsl/py-wsl/encrypt2bdy/test/【超丝滑60帧】4K精装字幕版《ILLSHOWYOU》KDA阿狸.mp4&#x27; 文件哈希：7d5735eba55a638a1290ab36e00530ca</span><br><span class="line">[23-12-17 20:03:32] INFO:main.py:upload_task:144 | [1] 开始处理 &#x27;/home/mu/code-wsl/py-wsl/encrypt2bdy/test/【超丝滑60帧】4K精装字幕版《MORE》KDA.mp4&#x27;</span><br><span class="line">Memory used: 44.08 MB</span><br><span class="line">Memory used: 44.08 MB</span><br><span class="line">Memory used: 44.08 MB</span><br><span class="line">Memory used: 44.08 MB</span><br><span class="line">Memory used: 44.08 MB</span><br><span class="line">Memory used: 44.08 MB</span><br><span class="line">Memory used: 44.08 MB</span><br><span class="line">Memory used: 44.08 MB</span><br><span class="line">Memory used: 44.08 MB</span><br><span class="line">Memory used: 44.08 MB</span><br><span class="line">Memory used: 44.08 MB</span><br><span class="line">Memory used: 44.08 MB</span><br><span class="line">[23-12-17 20:03:44] INFO:main.py:upload_task:237 | [2] 成功上传 &#x27;/home/mu/code-wsl/py-wsl/encrypt2bdy/test/【超丝滑60帧】4K精装字幕版《MORE》KDA.mp4&#x27; 文件哈希：b7b0cd46e3ac7681a3644d9761ad3e71</span><br><span class="line">[23-12-17 20:03:44] INFO:main.py:upload_task:282 | 本次上传完毕，上传：2，跳过：0，错误：0 | 总计：2</span><br><span class="line">[23-12-17 20:03:44] INFO:main.py:upload_task:283 | 本次上传完毕，平均上传速度：38.689mb/s | 总耗时：23.60s</span><br><span class="line">[23-12-17 20:03:44] INFO:main.py:upload_task:286 | 本次上传完毕，下次处理：2023-12-17 21:00:00</span><br></pre></td></tr></table></figure><h1 id="The-end"><a href="#The-end" class="headerlink" title="The end"></a>The end</h1><p>关于分片计算md5的介绍就这么多，我这个程序里面文件加密的部分也需要修改，不过那就不是本文的范畴了~</p>]]></content>
    
    
    <summary type="html">Python分片计算文件md5</summary>
    
    
    
    <category term="速通Python" scheme="https://blog.musnow.top/categories/%E9%80%9F%E9%80%9APython/"/>
    
    
    <category term="Python" scheme="https://blog.musnow.top/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>【图床】通过Cloudflare的自定义主机名服务代理图床域名</title>
    <link href="https://blog.musnow.top/posts/923376033/"/>
    <id>https://blog.musnow.top/posts/923376033/</id>
    <published>2023-12-16T09:55:00.000Z</published>
    <updated>2023-12-16T11:55:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h1><p>我的目的是，图床的域名，国内依旧使用七牛云CDN，境外的请求使用Cloudflare代理。Cloudflare能帮我们拦截一些高危的IP地址，能避免海外肉鸡刷你的图床服务。</p><p>如果你用过Cloudflare，其在SSL&#x2F;TLS模块提供了一个<code>自定义主机名</code>的服务，可以让用户在<strong>不将域名改成Cloudflare的DNS的情况下</strong>，使用Cloudflare的代理功能。</p><p>这个功能是Cloudflare for SAAS的一部分，你应该能在网上找到很多教程。</p><ul><li><a href="https://vircloud.net/exp/cf-cname-new.html">最新 CloudFlare CNAME 接入玩法详细图文教程 - SaaS·永久免费·官方稳定 - VirCloud’s Blog - Learning&amp;Sharing</a></li><li><a href="https://cloud.tencent.com/developer/article/1970429">Cloudflare Saas 接入CNAME流程-腾讯云开发者社区-腾讯云</a></li><li><a href="https://blog.csdn.net/alex_yangchuansheng/article/details/125986096">Cloudflare CNAME 接入满血复活，一分钱不用花！-CSDN博客</a></li></ul><p>简单说来，想使用这个功能，需要如下几个条件</p><ul><li>实际使用的域名：对于我而言是musnow.top</li><li>用于指定回退源的域名：这是第二个域名，名字无所谓，可以直接去<a href="https://nic.eu.org/arf/en/">EU.org</a>申请一个免费的。该域名需要接入Cloudflare的DNS，这里用example.com举例子</li><li>一个云服务器，IP用1.1.1.1举例子</li></ul><p>当你配置好了之后，请求网站的路径变成了如下模样</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">配置前：域名musnow.top-&gt;A记录-&gt;云服务器1.1.1.1</span><br><span class="line">配置后：域名musnow.top-&gt;CNAME记录-&gt;回退源域名example.com-&gt;Cloudflare-&gt;云服务器1.1.1.1</span><br></pre></td></tr></table></figure><p>使用<code>自定义主机名</code>功能，可以让Cloudflare在请求你源站的时候，使用原有域名（实际使用的域名），而不是回退源域名。假设你需要回源的云服务器是国内的服务器。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">回退源域名example.com没有备案 -&gt; 请求国内服务器会被服务商拦截</span><br><span class="line">配置自定义主机名musnow.top后；</span><br><span class="line">Cloudflare在回源到服务器的时候，采用自定义主机名的域名，即musnow.top；</span><br><span class="line">实际使用的域名musnow.top已备案 -&gt; 请求国内服务器不再被拦截</span><br></pre></td></tr></table></figure><p>整个过程中，回退源域名example.com对于用户是无感知的！我们实现了在原有域名musnow.top的DNS没有接入Cloudflare的情况下，使用了Cloudflare的防护服务。</p><p>目前免费版本的自定义主机名有如下要求</p><ul><li>Cloudflare必须要验证你的支付方式，<strong>不会扣你钱的</strong>（paypal或者银联信用卡，当时为此我还专门去办了个没有额度的学生信用卡，后来发现压根不需要，直接用paypal绑定个银联储蓄卡&#x2F;借记卡就可以了）</li><li>免费版本的回退源只能指定一个，即只能回源到一个IP地址的服务。</li></ul><h1 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h1><h2 id="回退源"><a href="#回退源" class="headerlink" title="回退源"></a>回退源</h2><p>首先是设置回退源域名的DNS，将其接入Cloudflare。随后是在DNS记录中添加一个A记录，指向你的源站服务器IP。</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2023/12/141a4967805f6d4a177f84c9557cc47f.png" alt="image.png"></p><p>这里我使用的名称是<code>back.回退源域名</code>，在SSL&#x2F;TLS模块的自定义主机名中开通Cloudflare SAAS服务，并添加回退源域名</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2023/12/44ad244bf4ee3f94cddb51153ca3d68f.png" alt="image.png"></p><p>添加回退源域名并验证成功后，就可以点击蓝色<code>添加自定义主机名</code>按钮，添加你需要代理的原始域名了。</p><p>这里我添加了我的图床域名<code>img.musnow.top</code>，首先是在腾讯云的DNS中设置CNAME解析，将境外线路设置为回退源的域名，默认线路还是七牛云CDN的CNAME</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2023/12/0257caf29cbdb23c5f99d91474f061f1.png" alt="image.png"></p><p>添加了域名解析之后，你还需要在musnow.top的DNS解析里面添加两个TXT记录来验证回退源，参考Cloudflare给出的txt记录提示就可以。界面类似下图</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2023/12/29ec2ba14997ccf0e5c5d64b8ec34d99.png" alt="image.png"></p><p>添加了之后点击刷新，直到自定义主机名的状态显示为<code>有效</code>，即配置成功。</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2023/12/06877d872e6521102ec83d0805e0bfc9.png" alt="image.png"></p><p>使用海外服务器测试，配置前，解析到七牛云CDN；配置后，解析到回退源域名，即Cloudflare</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2023/12/d900e5b35ddd67f51413e66ab54c822d.png" alt="image.png"></p><h2 id="反向代理"><a href="#反向代理" class="headerlink" title="反向代理"></a>反向代理</h2><p>但这里只是配置好了域名解析而已，还需要用反代才能让境外访问图床域名能访问出图片来。</p><h3 id="反代原有七牛云CDN的CNAME不起作用"><a href="#反代原有七牛云CDN的CNAME不起作用" class="headerlink" title="反代原有七牛云CDN的CNAME不起作用"></a>反代原有七牛云CDN的CNAME不起作用</h3><p>但是这个反代要怎么配置呢？因为只是解析线路不同，直接把img.musnow.top反向代理到img.musnow.top肯定不行，<strong>试试反代到七牛云的CNMAE</strong>？</p><p>测试发现，直接通过七牛云CDN里面的CNAME访问这个图片会403（不管是浏览器访问还是使用curl访问）</p><p>而反代过后，curl和wget的结果都变成了526，<strong>无法访问图片</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">╰─ curl https://img.musnow.top/i/2023/05/647563ddab0fb.gif</span><br><span class="line">error code: 526%    </span><br><span class="line"></span><br><span class="line">╰─ wget https://img.musnow.top/i/2023/05/647563ddab0fb.gif</span><br><span class="line">--2023-12-16 18:48:21--  https://img.musnow.top/i/2023/05/647563ddab0fb.gif</span><br><span class="line">Resolving img.musnow.top (img.musnow.top)... 172.67.157.61, 104.21.56.251, 2606:4700:3035::ac43:9d3d, ...</span><br><span class="line">Connecting to img.musnow.top (img.musnow.top)|172.67.157.61|:443... connected.</span><br><span class="line">HTTP request sent, awaiting response... 526 </span><br><span class="line">2023-12-16 18:48:21 ERROR 526: (no description).</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2023/12/b84073fd201689557c89a39ddf058e05.png" alt="image.png"></p><p>即便在反代里面设置了后端请求的域名为<code>img.musnow.top</code>，访问依旧会是526</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2023/12/6e0441d8096870ebab9dc0f560005aa4.png" alt="image.png"></p><h3 id="未设置Cloudflare时能成功解析"><a href="#未设置Cloudflare时能成功解析" class="headerlink" title="未设置Cloudflare时能成功解析"></a>未设置Cloudflare时能成功解析</h3><p>作为对比，在<strong>没有配置</strong>解析到Cloudflare的时候，使用wget是能访问出图片来的</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2023/12/21bbf4746ffcc740728e4b1df8be6427.png" alt="image.png"></p><p>将wget的这个图片通过sftp下载下来，能看到它是正常的gif，图片访问没有问题。</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2023/12/b29c2c5cbf14669c34f4037322aeeff6.png" alt="image.png"></p><h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><p>我能想到的解决办法，是白嫖一下七牛云免费的10GB HTTP流量，新建一个HTTP回源的CDN，绑定到图床的bucket上即可。</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2023/12/3e6bcea445ba19b11f6c77026ac658de.png" alt="image.png"></p><p>注意，只要你的回源地址是<strong>国内的bucket</strong>，那么域名就必须要备案才能配置CDN。</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2023/12/657d8838998a7.png"></p><p>因为现在是通过云服务器反代来访问这个CDN，此时反代的proxy设置为http，在添加<code>img.musnow.top</code>的cert证书到反代设置里面，就能实现https。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">img.musnow.top 反代 img-cloudflare.musnow.top</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2023/12/0d22fc941aa251767a6d002cf9c587a0.png" alt="image.png"></p><p>注意，反代中的后端域名也需要设置为新的CDN域名，否则访问会因为域名不匹配而403拒绝访问。</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2023/12/342efa096d28d3bdbeb9a33454b14aa4.png" alt="image.png"></p><p>随后就是添加img.musnow.top的SSL证书</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2023/12/d98f69744def3672429c19ae7879a690.png" alt="image.png"></p><p>测试一下，新建的这个cdn域名可以通过http访问到bucket里面的图片</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2023/12/41d0ef29dc9f3da44647b7150b4625f0.png" alt="image.png"></p><p>再测试一下<strong>反代后的域名</strong>，也可以访问到图片了，这里访问的IP地址<code>104.21.56.251</code>也已经是Cloudflare的IP了。配置成功！</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2023/12/ba1eb6f04811dc5e15e62055fdcb0d4a.png" alt="image.png"></p><p>此时海外访问我的图床，解析变成了如下过程</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">img.musnow.top -&gt; CNAME回退源域名 -&gt; cloudflare(https) -&gt; 云服务器反代(https) -&gt; img-cloudflare.musnow.top(http) -&gt; 七牛云bucket</span><br></pre></td></tr></table></figure><p>因为最终访问的CDN是通过HTTP回源bucket的，能白嫖七牛云10G的免费流量！</p><p>当然，如果真有人在海外打你，刷完10G流量也不是不可能……所以在cloudflare里面最好再配置一下单IP访问的频次限制！</p><p>比如下图，我设置访问URL为图床开头<code>/i</code>时进行速率监看，如果单IP访问速率超过60次&#x2F;10秒，那么就会触发cloudflare的速率限制响应，持续10秒。</p><p>因为我的博客已经设置了<strong>懒加载</strong>，所以一次性加载60个图片的场景是不存在的！这种规模的请求肯定是攻击了！再加上我的博客理论上不会有几个海外用户阅读，所以这个配置不会对国内用户产生影响。</p><blockquote><p>如果你使用了代理，请把musnow.top所有子域名加入代理白名单。</p></blockquote><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2023/12/18bbfdad10fe93f2c9b33576946d009c.png" alt="image.png"></p><h3 id="进一步优化"><a href="#进一步优化" class="headerlink" title="进一步优化"></a>进一步优化</h3><p>进一步优化，就是把新创建的这个HTTP CDN里面设置IP白名单，只允许我们设置反代的服务器的那个IP地址访问，这样就保证了其他人不能直接刷我新建的这个HTTP的CDN域名。</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2023/12/0143324cb410b006374f3ae0e2e5da60.png" alt="image.png"></p><p>在七牛云的CDN配置界面可以看到IP黑白名单，添加服务器IP地址为白名单即可</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2023/12/68f0761d01ef17bd69ae3ae390276d43.png" alt="image.png"></p><p>配置后需要过一段时间才会生效，会有个进度条。完成后，再次本地测试一下，发现已经403不允许访问了。</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2023/12/84a0913ebda28e60c4a6dd292e810ce9.png" alt="image.png"></p><p>此时在海外服务器尝试反代域名访问，依旧是OK的，访问的IP地址<code>172.67.157.61</code>也依旧是Cloudflare的IP。</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2023/12/4440fa31b56a35e7c25acc33e37974a1.png" alt="image.png"></p><h1 id="The-end"><a href="#The-end" class="headerlink" title="The end"></a>The end</h1><p>至此，配置完成！</p>]]></content>
    
    
    <summary type="html">通过Cloudflare的SAAS自定义主机名服务代理图床域名</summary>
    
    
    
    <category term="差生文具多" scheme="https://blog.musnow.top/categories/%E5%B7%AE%E7%94%9F%E6%96%87%E5%85%B7%E5%A4%9A/"/>
    
    
    <category term="图床" scheme="https://blog.musnow.top/tags/%E5%9B%BE%E5%BA%8A/"/>
    
  </entry>
  
  <entry>
    <title>【WSL】解决&#39;wsl：检测到localhost代理配置，但未镜像到WSL&#39;问题</title>
    <link href="https://blog.musnow.top/posts/3693584344/"/>
    <id>https://blog.musnow.top/posts/3693584344/</id>
    <published>2023-12-16T09:52:00.000Z</published>
    <updated>2023-12-16T09:52:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>今天使用wsl2的centos的时候遇到了这个问题</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">wsl: 检测到 localhost 代理配置，但未镜像到 WSL。</span><br><span class="line">NAT 模式下的 WSL 不支持 localhost 代理。</span><br></pre></td></tr></table></figure><p>参考 <a href="https://www.cnblogs.com/hg479/p/17869109.html">解决”wsl: 检测到 localhost 代理配置，但未镜像到 WSL。NAT 模式下的 WSL 不支持 localhost 代理” - JustInCase - 博客园</a></p><p>在windows的<code>C:\User\&lt;你的用户名&gt;\</code> 下创建一个<code>.wslconfig</code>，内部写入如下内容</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[experimental]</span><br><span class="line">autoMemoryReclaim=gradual  </span><br><span class="line">networkingMode=mirrored</span><br><span class="line">dnsTunneling=true</span><br><span class="line">firewall=true</span><br><span class="line">autoProxy=true</span><br></pre></td></tr></table></figure><p>写完后保存，重启wsl即可</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wsl --shutdown</span><br></pre></td></tr></table></figure><p>再次启动wsl，不再弹出上述提示</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2023/12/cf8be920995459ca75ed48adc48b4908.png" alt="image.png"></p>]]></content>
    
    
    <summary type="html">解决&#39;wsl：检测到localhost代理配置，但未镜像到WSL&#39;问题</summary>
    
    
    
    <category term="玩上Linux" scheme="https://blog.musnow.top/categories/%E7%8E%A9%E4%B8%8ALinux/"/>
    
    
    <category term="Linux" scheme="https://blog.musnow.top/tags/Linux/"/>
    
    <category term="虚拟机" scheme="https://blog.musnow.top/tags/%E8%99%9A%E6%8B%9F%E6%9C%BA/"/>
    
    <category term="wsl" scheme="https://blog.musnow.top/tags/wsl/"/>
    
  </entry>
  
  <entry>
    <title>【nginx】nginx通过配置文件允许uptimerobot的请求</title>
    <link href="https://blog.musnow.top/posts/1547739098/"/>
    <id>https://blog.musnow.top/posts/1547739098/</id>
    <published>2023-12-15T11:49:00.000Z</published>
    <updated>2023-12-15T11:49:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="问题说明"><a href="#问题说明" class="headerlink" title="问题说明"></a>问题说明</h1><p>前几天，我给我的artalk上了IP屏蔽，只放行国内IP，不允许任何国外的IP地址评论。</p><p><a href="https://blog.musnow.top/posts/2029711168/">【Nginx】nginx通过配置文件阻止海外ip访问 | 慕雪的寒舍</a></p><p>然后就发现了一个问题，我使用的uptimerobot这个在线状态监控程序是国外的，它的请求自然也是通过海外IP发起的，此时就会被我服务器的nginx拦截，导致403，uptimerobot认为403也是无法访问，service down了。</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2023/12/9b7cc2eba613b4a9d0fbd06a003e63b8.png" alt="image.png"></p><h1 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h1><p>之前通过折腾，已经知道了如何使用nginx的配置文件来allow或者deny一系列ip地址，那么uptimerobot的这个问题也很好解决：只要我们知道uptimerobbot的请求来源ip，那么将其写入一个如下类似的nginx配置文件，再在具体的location中include，放行对应ip地址即可。</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">allow</span> uptime-robot-ip1;</span><br><span class="line"><span class="attribute">allow</span> uptime-robot-ip2;</span><br></pre></td></tr></table></figure><p>我在uptimerobot的官网找到了它们的ip地址列表：<a href="https://uptimerobot.com/help/locations/">Locations and IPs | UptimeRobot</a></p><p>txt文件也有的：</p><ul><li>ipv4：<a href="https://uptimerobot.com/inc/files/ips/IPv4.txt">uptimerobot.com&#x2F;inc&#x2F;files&#x2F;ips&#x2F;IPv4.txt</a></li><li>ipv4+ipv6：<a href="https://uptimerobot.com/inc/files/ips/IPv4andIPv6.txt">uptimerobot.com&#x2F;inc&#x2F;files&#x2F;ips&#x2F;IPv4andIPv6.txt</a></li></ul><p>用如下脚本来实现</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line">rm -f IPv4.txt black_uptime_`date +%F`.conf</span><br><span class="line">wget https://uptimerobot.com/inc/files/ips/IPv4.txt</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">删除原有文件每一行的回车符号</span></span><br><span class="line">sed -i &#x27;s/\r//g&#x27; IPv4.txt </span><br><span class="line"></span><br><span class="line">while IFS= read -r line</span><br><span class="line">do</span><br><span class="line">  echo &quot;allow $line;&quot; &gt;&gt; black_uptime_`date +%F`.conf</span><br><span class="line">done &lt; IPv4.txt</span><br><span class="line"></span><br><span class="line">rm -f /etc/nginx/black_uptime.conf &amp;&amp; \</span><br><span class="line">ln -s $PWD/black_uptime_`date +%F`.conf /etc/nginx/black_uptime.conf</span><br></pre></td></tr></table></figure><p>将其写入一个<code>uptimerobot.sh</code>文件，使用如下命令执行它</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sh uptimerobot.sh</span><br></pre></td></tr></table></figure><p>这个脚本会在当前目录里面下载uptimerobot的这个IPv4.txt，并以nginx的形式写为allow，最后在<code>/etc/nginx</code>里面创建一个软连接 <code>/etc/nginx/black_uptime.conf</code> 文件，文件内容如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">allow 18.116.158.121;</span><br><span class="line">allow 18.223.50.16;</span><br><span class="line">allow 54.241.175.147;</span><br></pre></td></tr></table></figure><p>随后我们进入nginx的配置文件，在对应站点配置文件的location里面，include这个配置文件就可以了</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">location</span> / &#123;</span><br><span class="line"><span class="comment"># 允许uptimerobot的请求</span></span><br><span class="line"><span class="attribute">include</span> /etc/nginx/black_uptime.conf;</span><br><span class="line"><span class="attribute">deny</span> all; <span class="comment"># 拒绝其他所有请求</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>添加之后，重启nginx，配置就生效啦</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl restart nginx</span><br></pre></td></tr></table></figure><p>如下图，uptimerobot已经可以正常请求和监看我的artalk评论页面了</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2023/12/80d723cf79673db1f53efb9452baa448.png" alt="image.png"></p><p>使用类似的思路，你可以通过nginx实现让你的站点只允许CDN服务商的IP回源，禁止直接访问。</p>]]></content>
    
    
    <summary type="html">nginx通过配置文件允许uptimerobot的请求，放行uptimerobot的ip</summary>
    
    
    
    <category term="差生文具多" scheme="https://blog.musnow.top/categories/%E5%B7%AE%E7%94%9F%E6%96%87%E5%85%B7%E5%A4%9A/"/>
    
    
    <category term="Linux" scheme="https://blog.musnow.top/tags/Linux/"/>
    
    <category term="nginx" scheme="https://blog.musnow.top/tags/nginx/"/>
    
  </entry>
  
  <entry>
    <title>【docker】部署minio对象存储并用rclone同步</title>
    <link href="https://blog.musnow.top/posts/1950951389/"/>
    <id>https://blog.musnow.top/posts/1950951389/</id>
    <published>2023-12-13T13:29:02.000Z</published>
    <updated>2023-12-13T13:29:02.000Z</updated>
    
    <content type="html"><![CDATA[<p>docker部署minio对象存储并用rclone同步</p><h1 id="1-什么是minio？"><a href="#1-什么是minio？" class="headerlink" title="1.什么是minio？"></a>1.什么是minio？</h1><p>minio是一个开源的对象存储服务器，兼容S3协议。</p><p>官网：<a href="https://min.io/">https://min.io/</a></p><p>官方在开源的基础上也提供云端S3服务，分为个人和企业，有不同的收费标准。</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2023/12/3dbb54877957d5ede7354a3401dd4cf0.png" alt="5ae0c978272b7ca6732817920adae0f5.png"></p><h2 id="1-1-自建对象存储的好处？"><a href="#1-1-自建对象存储的好处？" class="headerlink" title="1.1 自建对象存储的好处？"></a>1.1 自建对象存储的好处？</h2><p>当然，本文写下来肯定不是让你去买它的对象存储服务的，而是在我们自己的服务器&#x2F;Nas上部署一个minio的docker，来拥有一个我们自己的对象存储服务器！</p><p>对象存储服务器可以用来做图床、静态资源缓存，亦或者是直接当作一个网盘来使用。</p><p>自建的对象存储的好处是所有源文件我们都能亲手管理，且无需为付费的对象存储的奇怪的计价文档感到手足无措，也不需要担心有人恶意刷流把你一套房子给套走。</p><p>缺点就是，自建的稳定性肯定不如已有厂家提供的服务，且自购的服务器&#x2F;Nas上传带宽一般都很低，文件一多，访问速度就很慢了。</p><p>对于我个人而言，自建minio的唯一作用，就是备份七牛云&#x2F;阿里云对象存储中的文件。考虑到2023下半年，各大厂接连boom云服务，国外的谷歌还出现了云盘里面用户的数据回滚到几月前的恶性问题，这可是可能导致用户数据丢失的大问题啊！</p><ul><li><a href="https://www.ithome.com/0/737/538.htm">谷歌公布方案，修复 Drive 云盘文件丢失问题</a></li><li><a href="https://news.zol.com.cn/845/8455073.html">谷歌承认云端硬盘Google Drive存在BUG，3月内用户文件可能丢失</a></li></ul><p>所以，将数据在自己本地留一份总是安心一些。数据安全靠的是备份，不是云服务厂家给你提供的<code>99.99999%</code>可用性的一面之词。</p><p>如果你对数据备份这个话题感兴趣，可以看看我的另外一篇博客：<a href="https://blog.musnow.top/posts/3543423459/?f=minio">谈谈如何进行有效数据备份，3+2+1</a></p><blockquote><p>温馨提醒：如果你想在<strong>云服务器</strong>上安装minio来备份已有S3中的文件的话，最好是使用一个和已有S3<strong>不在同一个地域、非同一个服务商</strong>的云服务器，避免某些服务商云服务器和对象存储一起boom的情况……</p></blockquote><h1 id="2-docker安装minio"><a href="#2-docker安装minio" class="headerlink" title="2.docker安装minio"></a>2.docker安装minio</h1><h2 id="2-1-安装docker"><a href="#2-1-安装docker" class="headerlink" title="2.1 安装docker"></a>2.1 安装docker</h2><p>docker安装的教程详见我的另外一篇博客</p><p><a href="https://blog.musnow.top/posts/2069190154/?f=minio">【Docker】deepin&#x2F;centos安装docker | 慕雪的寒舍</a></p><h2 id="2-2-安装minio"><a href="#2-2-安装minio" class="headerlink" title="2.2 安装minio"></a>2.2 安装minio</h2><p>这里推荐使用由VMware维护的minio docker版本<code>bitnami/minio</code>，更新很频繁。</p><p><a href="https://hub.docker.com/r/bitnami/minio">hub.docker.com&#x2F;r&#x2F;bitnami&#x2F;minio</a></p><p>创建容器的命令如下，非常简单</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">docker run -it -d --name minio \</span><br><span class="line">-p 9000:9000 \</span><br><span class="line">-p 9001:9001 \</span><br><span class="line">--restart=always \</span><br><span class="line">-v /minio/data:/bitnami/minio/data \</span><br><span class="line">-e MINIO_ROOT_USER=<span class="string">&quot;minio_root&quot;</span> \</span><br><span class="line">-e MINIO_ROOT_PASSWORD=<span class="string">&quot;minio_123456&quot;</span> \</span><br><span class="line">-e TZ=<span class="string">&#x27;Asia/Shanghai&#x27;</span> \</span><br><span class="line">bitnami/minio:latest</span><br></pre></td></tr></table></figure><p>该创建容器操作基于如下hash的docker镜像（更新于2023-12-12），创建容器的命令后续可能会有变动，请参考docker-hub中的官方文档</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bitnami/minio  latest    552af9bd3d6d   2 days ago     212MB</span><br></pre></td></tr></table></figure><p>对这个docker命令进行解释</p><ul><li><code>-it -d</code>，it提供交互能力，d代表后台运行</li><li><code>--restart=always</code>，始终重启docker（docker服务重启后，镜像会自动启动）</li><li><code>-p 9000:9000</code>，将docker内的9000端口（右侧）映射给宿主机（左侧）的9000端口，端口9001的映射同理。<ul><li>容器内9000端口是minio的api端口（用于S3协议操作）</li><li>容器内9001端口是minio的web管理界面端口</li><li>根据你的需要，修改<strong>冒号左侧</strong>的宿主机端口即可。</li></ul></li><li><code>-v /minio/data:/bitnami/minio/data</code>，将docker内<code>/bitnami/minio/data</code>路径映射给主机<code>/minio/data</code>路径，主机上的路径（左侧）请自行修改；这个路径是bucket和minio配置文件的存储路径。</li><li>两个<code>-e</code>设置的是环境变量，分别设置的是minio管理员的账户和管理员的密码。请注意，在这里配置了管理员用户名和密码后，<strong>进入minio管理系统的密码无法被修改</strong>。如果你的minio服务需要暴露在公网上，请一定要设置一个<strong>高强度</strong>的密码！</li><li><code>-e TZ=&#39;Asia/Shanghai&#39;</code> 设置时区为东八区（后续定时备份需要有正确时区）</li><li>最后的<code>bitnami/minio:latest</code>代表我们需要创建<code>bitnami/minio</code>这个docker镜像的latest版本，如果本地没有这个镜像，则会自动去docker-hub拉取。</li><li>如果你卡在了pull镜像的步骤，请自行百度如何<a href="https://blog.musnow.top/posts/2069190154/?f=minio">替换docker的镜像源</a>。</li></ul><p>如下是我在一个没有安装过minio的云服务上测试的结果，成功安装并启动minio</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">[root:~/docker]# docker run -it -d --name minio \</span><br><span class="line">&gt; -p 19000:9000 \</span><br><span class="line">&gt; -p 19001:9001 \</span><br><span class="line">&gt; --restart=always \</span><br><span class="line">&gt; -v /root/docker/minio:/bitnami/minio/data \</span><br><span class="line">&gt; -e MINIO_ROOT_USER=&quot;minio_root&quot; \</span><br><span class="line">&gt; -e MINIO_ROOT_PASSWORD=&quot;minio_123456&quot; \</span><br><span class="line">&gt; bitnami/minio:latest</span><br><span class="line">Unable to find image &#x27;bitnami/minio:latest&#x27; locally</span><br><span class="line">latest: Pulling from bitnami/minio</span><br><span class="line">ef5975039511: Pull complete </span><br><span class="line">Digest: sha256:3bb81d101dea57a5382a2d01eda6991e75ce69669d2d49c4646d82721b7c258e</span><br><span class="line">Status: Downloaded newer image for bitnami/minio:latest</span><br><span class="line">afefbb9514de0f4a1c02b7f4212b1e05eee5ef342ed4ce27e03de10071914060</span><br></pre></td></tr></table></figure><p>容器正常启动，处于Running状态，STATUS正常！</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">CONTAINER ID   IMAGE                                  COMMAND                  CREATED         STATUS         PORTS                                                                                      NAMES</span><br><span class="line">afefbb9514de   bitnami/minio:latest                   &quot;/opt/bitnami/script…&quot;   3 minutes ago   Up 3 minutes   0.0.0.0:19000-&gt;9000/tcp, :::19000-&gt;9000/tcp, 0.0.0.0:19001-&gt;9001/tcp, :::19001-&gt;9001/tcp   minio</span><br></pre></td></tr></table></figure><p>这样还不够，请在后续创建了bucket并上传测试文件后，查看本地映射的路径中是否有对应文件夹和文件，<strong>避免路径映射失败</strong>！（如果路径没有成功映射到本地，那么你当前创建的minio被删除之后，文件就很难找回来了）</p><blockquote><p>顺带一提，在我这边测试发现，如果你错误使用浏览器访问了9000这个api端口，会被自动重定向到9001 web管理页面端口（前提是映射的宿主机端口和docker内端口一致）</p></blockquote><h2 id="2-3-web管理"><a href="#2-3-web管理" class="headerlink" title="2.3 web管理"></a>2.3 web管理</h2><p>使用 <code>http://IP:端口</code> 打开minio的9001端口对应的宿主机端口，访问minio的web管理页面。输入刚刚创建容器时，在环境变量里面配置的用户名和密码进行登录，即可进入控制台。</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2023/12/8ab832241e5ea9a14713e75fb56c2df0.png" alt="image.png"></p><p>minio的界面比较简单，基本要做的操作只有两个，创建bucket存储桶，和accesskey用于api调用。</p><blockquote><p>更高阶的配置项和操作我没有尝试过，请自行参考minio的文档或者其他教程。</p></blockquote><h3 id="2-3-1-创建bucket"><a href="#2-3-1-创建bucket" class="headerlink" title="2.3.1 创建bucket"></a>2.3.1 创建bucket</h3><p>第一个界面就是大大的Object Browser，在这里我们可以创建存储桶</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2023/12/df27f17b80655b3107ef12018f180712.png" alt="image.png"></p><p>点击创建bucket，会进入如下配置项，除了bucket的名字，还有三个选项</p><ul><li>Versioning：版本控制，开启后，该bucket将处于多版本模式下，文件会保留修改的历史记录。</li><li>Object Locking：避免文件被删除，需要支持保留和合法保留（这两个啥意思我不明白），该选项只能在bucket创建时打开。</li><li>Quota：限制容器中文件大小（总容量）</li></ul><p>对于我的备份需求来说，这三个额外选项都不需要，直接创建就行了</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2023/12/c7b5efc573e9e3691f0237a6e9d7357a.png" alt="image.png"></p><p>创建之后，在bucket页面可以看到刚刚创建的test存储桶，这里会统计存储容量和文件数量</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2023/12/01016c16a27570ded8d93a7aa4781a1f.png" alt="image-20231213232421462"></p><h3 id="2-3-2-创建accessKey"><a href="#2-3-2-创建accessKey" class="headerlink" title="2.3.2 创建accessKey"></a>2.3.2 创建accessKey</h3><p>accessKey是用于操作api的token凭证。创建完毕后，他只会显示一次，后续将不会显示出来。</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2023/12/7413b4978a8916f3ba34043afa034e7f.png" alt="image.png"></p><p>如果你不想创建太多个密钥，那就把这个密钥的文件下载下来，免得到时候不知道是什么了。点击右下角的import文件就可以下载，会下载一个<code>json</code>文件，内部包含密钥和其他一些相关信息</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2023/12/c06b9cd5866f9b3d9a2f37e0ded15404.png" alt="image.png"></p><p>因为我这只是做个测试，一会就会把这个minio的docker删除，所以展示密钥无所谓。如果你是在生产环境下使用，请一定不要暴露你的密钥给任何人。</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;url&quot;</span><span class="punctuation">:</span> <span class="string">&quot;http://公网IP:19001/api/v1/service-account-credentials&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;accessKey&quot;</span><span class="punctuation">:</span> <span class="string">&quot;aXpBxrUceV30Id6gOouG&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;secretKey&quot;</span><span class="punctuation">:</span> <span class="string">&quot;dIWl9IFL05UtaI08PZfPXE66zPGu2zWrGFfSTaUm&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;api&quot;</span><span class="punctuation">:</span> <span class="string">&quot;s3v4&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;path&quot;</span><span class="punctuation">:</span> <span class="string">&quot;auto&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>密钥创建完毕，就能在列表看到它。</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2023/12/d70adb75c6ec74a362a065e9afc88092.png" alt="image.png"></p><h1 id="3-rclone备份"><a href="#3-rclone备份" class="headerlink" title="3.rclone备份"></a>3.rclone备份</h1><p>rclone是一个全平台的命令行工具，其可以用于多种云端&#x2F;本地存储之间的数据拷贝、同步、加密同步等功能。详见rclone官网：<a href="https://rclone.org/">rclone.org</a></p><p>因为我的目标就是我的七牛云bucket里面的图床文件备份到本地，rclone绝对是不二之选。</p><h2 id="3-1-进入docker容器内终端"><a href="#3-1-进入docker容器内终端" class="headerlink" title="3.1 进入docker容器内终端"></a>3.1 进入docker容器内终端</h2><p>你可以选择在<strong>宿主机</strong>上安装rclone，也可以选择直接在minio的容器内安装rclone。</p><p>前排提醒：部分nas品牌的系统（比如群晖）已经提供了<strong>执行定时脚本</strong>的功能，这种情况下直接使用系统提供的定时任务来执行<code>rclone sync</code>即可，<strong>即直接在nas里面安装rclone和使用定时任务</strong>，不要在minio的docker里面安装rclone。</p><p>如你选择了在宿主机上安装rclone，则可以直接<strong>跳过本3.1步骤</strong>，阅读3.2及后续步骤</p><h3 id="docker特权模式"><a href="#docker特权模式" class="headerlink" title="docker特权模式"></a>docker特权模式</h3><p>注意，如果在minio的容器内安装rclone，那么minio容器被删除后，<strong>rclone和它的配置文件自然也不在了</strong>。</p><p><strong>且如果需要用minio的容器进行crontab定时任务</strong>，则必须用<strong>特权模式</strong>安装minio的docker，在minio的docker创建命令里面加如下这条，设置特权模式（不需要定时任务可以不设置）。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">--privileged</span><br></pre></td></tr></table></figure><p>在绿联nas的docker管理界面，创建docker的时候给定所有权限，也是一样的效果。（因为我不太了解这里具体每个权限的作用，干脆全给了）</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2023/12/accf78ec16b7e73aec583e3672291e37.png" alt="image.png"></p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2023/12/e96098feea2769aa014db319b74bff58.png" alt="image.png"></p><h3 id="ssh连接宿主设备"><a href="#ssh连接宿主设备" class="headerlink" title="ssh连接宿主设备"></a>ssh连接宿主设备</h3><p>不同nas机型进入ssh的方式不太一样，请参考你的nas或设备品牌搜索对应类型教程。</p><p><strong>连接到宿主设备的ssh后</strong>，参考：<a href="https://www.cnblogs.com/langgeligelang/p/13628821.html">以指定用户启动和进入docker容器 - langyong - 博客园</a> 一文，使用如下docker命令进入minio的容器终端中。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker <span class="built_in">exec</span> -it -u 用户名 容器名 /bin/bash</span><br><span class="line"><span class="comment"># 示例如下</span></span><br><span class="line">docker <span class="built_in">exec</span> -it -u root minio /bin/bash</span><br></pre></td></tr></table></figure><p>如果你使用的是绿联、极空间这类不太方便进入ssh的nas，可以在nas的docker管理页里面操作，如下图所示，选择<code>/bin/bash</code>后点击链接即可进入容器内终端。</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/20231214091932.png" alt="image.png"></p><h2 id="3-2-下载安装rclone"><a href="#3-2-下载安装rclone" class="headerlink" title="3.2 下载安装rclone"></a>3.2 下载安装rclone</h2><p>进入终端后，默认所在路径是docker容器的工作路径<code>/opt/bitnami/minio-client</code>。</p><p>为了避免影响容器运行，我们不要在工作路径里面做操作，请使用如下命令，创建一个新的rclone文件夹，进入root用户的家目录进行操作。</p><p>如果你是在宿主机上操作，也是一样的道理，为rclone单独创建一个文件夹，来存放它的软件包、配置文件、执行日志。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mkdir /root/rclone</span><br><span class="line">cd /root/rclone</span><br></pre></td></tr></table></figure><blockquote><p>如果是docker内操作，你可以在创建minio容器的时候，就把<code>/root/rclone</code>路径给映射到宿主机上，方便后续查看rclone备份的日志。</p></blockquote><p>下载安装rclone的命令如下</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">curl -O https://downloads.rclone.org/rclone-current-linux-amd64.zip</span><br><span class="line">unzip rclone-current-linux-amd64.zip</span><br><span class="line"><span class="built_in">cd</span> rclone-*-linux-amd64</span><br><span class="line"> </span><br><span class="line">sudo <span class="built_in">cp</span> rclone /usr/bin/</span><br><span class="line">sudo <span class="built_in">chown</span> root:root /usr/bin/rclone</span><br><span class="line">sudo <span class="built_in">chmod</span> 755 /usr/bin/rclone</span><br></pre></td></tr></table></figure><p>minio的docker内没有unzip命令，需要安装一下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apt-get update &amp;&amp; apt-get install -y unzip</span><br></pre></td></tr></table></figure><p>minio的docker内也没有sudo，将上述安装命令中的sudo去掉就可以了。</p><p>完成安装命令后，执行一下<code>rclone</code>，出现rclone命令的使用提示，那就是安装成功了！</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">root@878a0dd03ec4:/root/rclone/rclone-v1.65.0-linux-amd64# rclone</span><br><span class="line">Usage:</span><br><span class="line">  rclone [flags]</span><br><span class="line">  rclone [command]</span><br><span class="line">  ...</span><br></pre></td></tr></table></figure><h2 id="3-3-rclone对象存储配置"><a href="#3-3-rclone对象存储配置" class="headerlink" title="3.3 rclone对象存储配置"></a>3.3 rclone对象存储配置</h2><p>rclone的官网上有不同云端存储协议和不同S3服务商的配置教程，跟着官方的来就可以了。</p><p>执行<code>rclone config</code>命令，工具会自动在<code>/.config/rclone/rclone.conf</code>下创建一个config文件，你可以根据<a href="https://rclone.org/">官方的向导</a>，在此处添加新的remote;</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">root@878a0dd03ec4:/root/rclone/rclone-v1.65.0-linux-amd64# rclone config</span><br><span class="line">2023/12/14 04:38:44 NOTICE: Config file &quot;/.config/rclone/rclone.conf&quot; not found - using defaults</span><br><span class="line">No remotes found, make a new one?</span><br><span class="line">n) New remote</span><br><span class="line">s) Set configuration password</span><br><span class="line">q) Quit config</span><br><span class="line">n/s/q&gt; q</span><br></pre></td></tr></table></figure><p>下面给出minio和七牛云的配置文件，你可以直接修改这个配置文件中的内容为你的配置，然后写入<code>/.config/rclone/rclone.conf</code>即可。</p><ul><li><a href="https://rclone.org/s3/#minio">rclone.org&#x2F;s3&#x2F;#minio</a></li><li><a href="https://rclone.org/s3/#qiniu">rclone.org&#x2F;s3&#x2F;#qiniu</a></li></ul><p>其中minio的region在minio的控制台里面可以修改，如果你没有修改过，默认使用的是<code>us-east-1</code>。因为rclone是直接在minio的docker里面执行的，所以endpoint只需要写成<code>127.0.0.1</code>和minio的api端口9000就可以了。</p><p>如果你的minio在公网或者其他设备上，请修改对应的IP地址和端口。</p><p>七牛云的region和endpoint在<strong>七牛云bucket页面</strong>找到<strong>S3域名</strong>就可以看到。</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2023/12/64d88c8052b653bb69edbed3d75fdca5.png" alt="image.png"></p><blockquote><p>请注意，七牛云&#x2F;阿里云这类存储服务商，如果你有多个bucket，且他们的地域不一样，则需要新增对应地域的配置项。通过修改<code>[]</code>里面的<strong>配置名</strong>进行区分。</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">[minio]</span><br><span class="line">type = s3</span><br><span class="line">provider = Minio</span><br><span class="line">env_auth = false</span><br><span class="line">access_key_id = 控制台获取的key_id</span><br><span class="line">secret_access_key = 控制台获取的secret_key</span><br><span class="line">region = us-east-1</span><br><span class="line">endpoint = http://127.0.0.1:9000</span><br><span class="line">location_constraint =</span><br><span class="line">server_side_encryption =</span><br><span class="line"></span><br><span class="line">[qiniu]</span><br><span class="line">type = s3</span><br><span class="line">provider = Qiniu</span><br><span class="line">access_key_id = 七牛云控制台获取key_id</span><br><span class="line">secret_access_key = 七牛云控制台获取secret_key</span><br><span class="line">region = cn-east-1</span><br><span class="line">endpoint = s3-cn-east-1.qiniucs.com</span><br><span class="line">location_constraint = cn-east-1</span><br><span class="line">acl = private</span><br><span class="line">storage_class = STANDARD</span><br></pre></td></tr></table></figure><p>执行如下命令，安装nano编辑器，然后使用nano编辑器打开rclone配置文件进行编辑。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">apt-get update &amp;&amp; apt-get install -y nano</span><br><span class="line">nano /.config/rclone/rclone.conf</span><br></pre></td></tr></table></figure><p>linux下的粘贴命令是<code>CTRL+SHIFT+V</code>或<code>CTRL+INSERT</code>，你可以在本地修改了配置文件后，通过nano编辑器，直接粘贴到docker容器内。编辑完毕后，使用<code>CTRL+X</code>退出nano的编辑模式，并按Y确认保存，随后直接回车，即完成编辑。</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2023/12/f82a30d9349cb55e60bc621dc2264be3.png" alt="image.png"></p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2023/12/283ab6851395ecf722d287aa06a8de0b.png" alt="image.png"></p><p>这个配置文件建议备份一个，免得每次都得重新弄</p><h2 id="3-4-rclone基本命令"><a href="#3-4-rclone基本命令" class="headerlink" title="3.4 rclone基本命令"></a>3.4 rclone基本命令</h2><h3 id="copy"><a href="#copy" class="headerlink" title="copy"></a>copy</h3><p>拷贝命令如下，配置名称是在config文件中<code>[]</code>里面的文字，桶名就是你的S3服务里面的对象存储桶，还可以在桶名后面用<code>/</code>来追加指定上传的路径。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">rclone copy 本地文件路径 配置名称:桶名</span><br><span class="line">rclone copy 本地文件路径 配置名称:桶名/桶内目录</span><br></pre></td></tr></table></figure><p>这里我在docker内创建了一个<code>test.txt</code>文件，尝试将其拷贝到minio里面。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">touch test.txt</span><br><span class="line">rclone copy ./test.txt minio:1panel-bak</span><br></pre></td></tr></table></figure><p>命令没有错误输出，即拷贝成功！</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">root@878a0dd03ec4:/root/rclone# touch test.txt</span><br><span class="line">root@878a0dd03ec4:/root/rclone# rclone copy ./test.txt minio:1panel-bak</span><br><span class="line">root@878a0dd03ec4:/root/rclone# </span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2023/12/bcd922882c21dbe6aa3e8aeb67fe08fa.png" alt="image.png"></p><p>尝试在拷贝的时候指定远端仓库内的路径</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rclone copy ./test.txt minio:qiniu-muxue-sy/test</span><br></pre></td></tr></table></figure><p>成功指定，文件被上传到了test文件夹里面。</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/20231214133906.png" alt="image.png"></p><h3 id="sync"><a href="#sync" class="headerlink" title="sync"></a>sync</h3><p>备份命令如下，可以在任意目的地（本地-远端，远端-本地，远端-远端）里面执行这个命令，左侧是源路径，右侧是目标。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">rclone sync 本地源文件路径  目的地配置名称:桶名 </span><br><span class="line">rclone sync 源配置名称:桶名 目的地配置名称:桶名</span><br><span class="line">rclone sync 源配置名称:桶名 目的地的本地文件路径</span><br></pre></td></tr></table></figure><p>rclone sync有两个常用的选项，刚开始使用的时候，建议带上 <code>--dry-run</code> 命令来确认自己的配置没有问题</p><ul><li><code>-P</code> 显示详细同步进度条</li><li><code>--dry-run</code> 用作命令测试，不会真正的执行同步</li></ul><p>指定<code>-P</code>命令后的进度输出如下，可以看到实时网速和文件数量&#x2F;大小。</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/20231214133932.png" alt="image.png"></p><p>目前发现的问题是minio显示的文件总量和数据存储量会<strong>有一定滞后</strong>，刚开始我还以为是rclone没有跑完呢，sync完毕过了几分钟minio里面才刷出正确的文件数量来。</p><h2 id="3-5-cron定时同步"><a href="#3-5-cron定时同步" class="headerlink" title="3.5 cron定时同步"></a>3.5 cron定时同步</h2><p>前排提醒：部分nas品牌的系统（比如群晖）已经提供了<strong>执行定时脚本</strong>的功能，这种情况下直接使用系统提供的定时任务来执行<code>rclone sync</code>即可，无序安装其他服务。<strong>即直接在nas里面安装rclone和使用定时任务</strong>，不要在minio的docker里面安装rclone和cron。</p><ul><li>群晖官网关于定时任务的说明： <a href="https://kb.synology.cn/zh-cn/DSM/help/DSM/AdminCenter/system_taskscheduler?version=6">https://kb.synology.cn/zh-cn/DSM/help/DSM/AdminCenter/system_taskscheduler?version=6</a></li><li>绿联nas的环境中已有crontab，但我没有试过使用它。考虑到绿联这个nas的系统还是一点都不稳定，还是别动它的系统里面的东西了，不知道绿联官方有没有可能把定时任务加到控制页里面去吧（我估计是没戏，这个系统的限制太多了）。</li></ul><p>如果你使用的是群晖、威联通等提供了执行定时任务的功能的nas，请在nas内配置好rclone后，自行百度执行定时任务相关教程。</p><h3 id="minio-docker内安装cron服务"><a href="#minio-docker内安装cron服务" class="headerlink" title="minio docker内安装cron服务"></a>minio docker内安装cron服务</h3><p>下面介绍在minio的docker内cron服务的安装和使用。</p><p>在minio的docker里面直接安装crontab服务和nano文本编辑器</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">apt-get update</span><br><span class="line">apt-get install -y cron nano</span><br></pre></td></tr></table></figure><p>但这还不够，cron服务的运行还依赖于其他组件，需要一并安装。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">apt-get install -y rsyslog  postfix</span><br><span class="line">service rsyslog start</span><br></pre></td></tr></table></figure><p>安装postfix的时候会提示让你选择配置文件，键入1选择无配置就够了。</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2023/12/934acd2b8c197729473f9d2a917740ca.png" alt="image.png"></p><p>postfix还需要额外配置，否则可能会遇到如下错误</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Dec 16 01:07:01 878a0dd03ec4 postfix/sendmail[1859]: fatal: open /etc/postfix/main.cf: No such file or directory</span><br><span class="line">Dec 16 01:12:02 878a0dd03ec4 postfix/postdrop[1912]: warning: unable to look up public/pickup: No such file or directory</span><br></pre></td></tr></table></figure><p>配置命令如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">touch /etc/postfix/main.cf</span><br><span class="line">mkfifo /var/spool/postfix/public/pickup</span><br></pre></td></tr></table></figure><h3 id="crontab配置定时任务测试"><a href="#crontab配置定时任务测试" class="headerlink" title="crontab配置定时任务测试"></a>crontab配置定时任务测试</h3><p>安装完毕后，使用<code>crontab -e</code>看看是否能打开crontab的配置编辑页面，如果可以打开如下配置界面，则代表cron安装成功。</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/20231214111457.png" alt="image.png"></p><p>这个配置文件需要写入的格式如下，一行对应一个配置。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">五位cron表达式 需要执行的命令</span><br></pre></td></tr></table></figure><p>cron表达式可以用在线工具<a href="https://tool.lu/crontab/">crontab执行时间计算 - 在线工具</a></p><p>先用如下的配置来检测cron服务是否能正常运行，以及是否能成功输出日志</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">*/1 * * * * echo &quot;$(date) This is a test command&quot; &gt;&gt; /root/rclone/log.txt</span><br></pre></td></tr></table></figure><p>该配置的含义是每分钟执行一次echo命令，打印当前时间和对应内容到<code>/root/rclone/log.txt</code>文件中。</p><p>修改了配置文件后，启动cron服务，测试我们的配置是否有效，cron服务是否能正常运行。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">service cron start </span><br></pre></td></tr></table></figure><p>该命令执行效果如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">root@878a0dd03ec4:/root/rclone# service cron start</span><br><span class="line">Starting periodic command scheduler: cron.</span><br></pre></td></tr></table></figure><p>等待数分钟，看看cron命令是否成功输出内容到指定文件里面了，有内容则代表配置和运行成功！默认情况下，<strong>使用cron执行的echo命令内的date</strong>采用了<strong>UTC时间</strong>的输出，但这并不影响我们的使用，给小时加8就能得到东八区的时间了。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">root@878a0dd03ec4:/root/rclone# cat /root/rclone/log.txt</span><br><span class="line">Sat Dec 16 01:18:01 UTC 2023 This is a test command</span><br><span class="line">Sat Dec 16 01:18:01 UTC 2023 This is a test command</span><br><span class="line">Sat Dec 16 01:19:01 UTC 2023 This is a test command</span><br><span class="line">Sat Dec 16 01:19:01 UTC 2023 This is a test command</span><br></pre></td></tr></table></figure><p>在syslog里面也能看到cron的服务日志，该服务日志组件依赖于先前安装的rsyslog</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat /var/log/syslog</span><br></pre></td></tr></table></figure><p>文件<code>/var/log/syslog</code>内部cron执行日志如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Dec 16 01:25:01 878a0dd03ec4 CRON[2059]: (root) CMD (echo &quot;$(date) This is a test command&quot; &gt;&gt; /root/rclone/log.txt)</span><br><span class="line">Dec 16 01:25:01 878a0dd03ec4 CRON[2058]: (root) CMD (echo &quot;$(date) This is a test command&quot; &gt;&gt; /root/rclone/log.txt)</span><br></pre></td></tr></table></figure><blockquote><p>请注意，默认情况下，minio的docker是<strong>没有时区配置</strong>的，请一定要在创建docker容器的时候，使用<strong>TZ环境变量</strong>来设置时区，否则crontab不会执行！<br>原因也很简单，cron表达式有一个指定时间，比如每周一执行、几点执行，如果没有配置时区，cron没有办法明确你的cron表达式到底应该什么时候跑，干脆就不跑了！</p></blockquote><p>如果你的docker已经创建，不想重新创建，可以通过修改配置文件来设置时区，修改后重启docker容器即可。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">nano /etc/environment</span><br><span class="line"># 在文件末尾写入如下内容</span><br><span class="line">TZ=&#x27;Asia/Shanghai&#x27;</span><br></pre></td></tr></table></figure><h3 id="crontab配置定时rclone-sync"><a href="#crontab配置定时rclone-sync" class="headerlink" title="crontab配置定时rclone sync"></a>crontab配置定时rclone sync</h3><p>确认cron服务可用，就可以来配置rclone sync的自动执行命令了。</p><p>对于rclone的sync备份而言，写入如下内容即可；</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">0 3 * * 1,5 rclone sync qiniu-e1:muxue-sy  minio:qiniu-muxue-sy &gt;&gt; /root/rclone/rclone.log 2&gt;&amp;1</span><br><span class="line">0 2 * * 1,5 rclone sync qiniu-e2:muxue-img  minio:qiniu-muxue-img &gt;&gt; /root/rclone/rclone.log 2&gt;&amp;1</span><br></pre></td></tr></table></figure><p>解析如下</p><ul><li><code>0 3 * * 1,5</code> 代表每周一和周五的凌晨3点执行一次</li><li><code>0 2 * * 1,5</code> 代表每周一和周五的凌晨2点执行一次</li><li><code>&gt;&gt; /root/rclone/rclone.log 2&gt;&amp;1</code> 代表将rclone命令的输出结果写入到 <code>/root/rclone/rclone.log</code> 文件中。</li></ul><p>因为我对备份的频次要求不高，一周备份两次就够了。</p><p>写入完毕后，<code>CTRL+X</code>关闭nano编辑模式，按Y和回车即完成nano编辑。编辑完成后会有如下输出。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">root@878a0dd03ec4:/root/rclone# crontab -e</span><br><span class="line">no crontab for root - using an empty one</span><br><span class="line">crontab: installing new crontab</span><br></pre></td></tr></table></figure><p>后续crontab执行的命令结果都会输入到<code>/root/rclone/rclone.log</code>日志文件中。rclone命令只有在出现ERROR的时候才会输出。如果这个文件里面什么都么有，就代表运行没有出错！</p><p>配置好了之后，使用如下命令重新启动cron服务</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">service cron restart</span><br></pre></td></tr></table></figure><p>用如下命令查看cron服务状态</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">root@878a0dd03ec4:/root/rclone# service cron status</span><br><span class="line">cron is running.</span><br></pre></td></tr></table></figure><h3 id="优化cron日志"><a href="#优化cron日志" class="headerlink" title="优化cron日志"></a>优化cron日志</h3><p>为了让日志更加合理，可以在执行rclone命令之前，打印当前时间，这样可以知道crontab到底有没有正常执行定时任务。</p><p>打印时间的基本命令如下，echo命令会将当前时间和相关的说明信息写入<code>test.txt</code>文件中</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo &quot;$(date) This is a test command&quot; &gt;&gt; test.txt</span><br></pre></td></tr></table></figure><p>执行效果如下，打印了时间和对应的日志信息</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">root@878a0dd03ec4:/root/rclone# echo &quot;$(date) This is a test command&quot; &gt;&gt; test.txt</span><br><span class="line">root@878a0dd03ec4:/root/rclone# cat test.txt</span><br><span class="line">Sat Dec 16 09:36:06 CST 2023 This is a test command</span><br></pre></td></tr></table></figure><blockquote><p>再次提醒，minio的docker内<strong>必须指定TZ环境变量</strong>，否则crontab不会执行！且date命令时区和东八区不符。</p></blockquote><p>echo打印的时候，可以临时指定TZ环境变量来打印不同时区的date</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo &quot;$(TZ=&#x27;Asia/Shanghai&#x27; date) 这是东八区&quot; &gt;&gt; test.txt</span><br></pre></td></tr></table></figure><p>执行效果如下，因为我的docker内已经设置了TZ环境变量为东八区，所以不加这个TZ也是打印的东八区的时间。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">root@878a0dd03ec4:/root/rclone# echo &quot;$(TZ=&#x27;Asia/Shanghai&#x27; date) 这是东八区&quot; &gt;&gt; test.txt</span><br><span class="line">root@878a0dd03ec4:/root/rclone# cat test.txt</span><br><span class="line">Sat Dec 16 09:36:06 CST 2023 This is a test command</span><br><span class="line">Sat Dec 16 09:37:39 CST 2023 这是东八区</span><br></pre></td></tr></table></figure><p>但是需要注意的是，使用cron命令执行的时候，它依旧会打印UTC时间，前文已经提到过了。</p><p>将原本的crontab命令改成如下形式（<code>crontab -e</code>编辑配置文件），使用<code>&amp;&amp;</code>来链接echo和rclone命令，这样在每次执行rclone之前都会有一个当前时间和sync的是什么内容的的输出，能让我们知道crontab是否正常执行。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">0 3 * * 1,5 echo &quot;$(TZ=&#x27;Asia/Shanghai&#x27; date) sync muxue-sy&quot; &gt;&gt; /root/rclone/rclone.log &amp;&amp; rclone sync qiniu-e1:muxue-sy  minio:qiniu-muxue-sy &gt;&gt; /root/rclone/rclone.log 2&gt;&amp;1</span><br><span class="line"></span><br><span class="line">0 2 * * 1,5 echo &quot;$(TZ=&#x27;Asia/Shanghai&#x27; date) sync muxue-img&quot; &gt;&gt; /root/rclone/rclone.log &amp;&amp; rclone sync qiniu-e2:muxue-img  minio:qiniu-muxue-img &gt;&gt; /root/rclone/rclone.log 2&gt;&amp;1</span><br></pre></td></tr></table></figure><p>你可以修改cron表达式为<code>*/1 * * * *</code>，让crontab表达式立即执行一次，确认一下输出是否正确，以及rclone命令是否正常执行。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">*/1 * * * * echo &quot;$(date) sync muxue-img&quot; &gt;&gt; /root/rclone/rclone.log &amp;&amp; rclone sync qiniu-e2:muxue-img  minio:qiniu-muxue-img &gt;&gt; /root/rclone/rclone.log 2&gt;&amp;1</span><br></pre></td></tr></table></figure><p>我的测试结果如下，rclone sync成功被cron执行（这个ERROR是因为我的bucket里面有个无效的文件，正常情况下应该不会有ERROR）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Sat Dec 16 01:45:01 UTC 2023 sync muxue-img</span><br><span class="line">2023/12/16 01:45:02 ERROR : : Entry doesn&#x27;t belong in directory &quot;&quot; (same as directory) - ignoring</span><br></pre></td></tr></table></figure><p>测试结束后，<strong>记得还原配置项</strong>。</p><p>每次修改配置文件后，都需要重启cron服务！</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">root@878a0dd03ec4:/root/rclone# service cron restart</span><br><span class="line">Restarting periodic command scheduler: cronStopping periodic command scheduler: cron.</span><br><span class="line">Starting periodic command scheduler: cron.</span><br></pre></td></tr></table></figure><h3 id="centos安装cron"><a href="#centos安装cron" class="headerlink" title="centos安装cron"></a>centos安装cron</h3><p>在centos中安装cron的命令不同</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">yum install -y vixie-cron </span><br><span class="line">yum install -y crontabs</span><br></pre></td></tr></table></figure><p>启动crontab</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">systemctl start crond <span class="comment"># 启动cron服务</span></span><br><span class="line">systemctl <span class="built_in">enable</span> crond <span class="comment"># 设置开机自启</span></span><br><span class="line">systemctl status crond <span class="comment"># cron服务状态</span></span><br><span class="line">systemctl restart crond <span class="comment"># 重启cron</span></span><br></pre></td></tr></table></figure><p>cron配置的其余操作和上文相同，都是用<code>crontab -e</code>编辑配置文件。</p><p>因为我这个是一个云服务器的完整centos系统，所以也不需要安装<code>rsyslog postfix</code> 这两个包。</p><h1 id="The-end"><a href="#The-end" class="headerlink" title="The end"></a>The end</h1><p>本文的教程结束，有问题欢迎在评论区提出。</p><p>数据无价，多一份备份，多一份安心</p>]]></content>
    
    
    <summary type="html">docker部署minio对象存储并用rclone同步</summary>
    
    
    
    <category term="docker真好玩" scheme="https://blog.musnow.top/categories/docker%E7%9C%9F%E5%A5%BD%E7%8E%A9/"/>
    
    
    <category term="docker" scheme="https://blog.musnow.top/tags/docker/"/>
    
  </entry>
  
  <entry>
    <title>【MySQL】wsl的ubuntu中无法systemctl启动mariadb（已解决）</title>
    <link href="https://blog.musnow.top/posts/1382619221/"/>
    <id>https://blog.musnow.top/posts/1382619221/</id>
    <published>2023-12-13T09:52:14.000Z</published>
    <updated>2023-12-13T09:52:14.000Z</updated>
    
    <content type="html"><![CDATA[<p>这是GPT的答案，实测有效。</p><p>如果您在启动 MariaDB 时遇到 <code>&quot;Failed to start mariadb.service: Interactive authentication required&quot; </code>错误，这是因为在 Ubuntu 22.04 上默认启用了 systemd 的用户会话限制，需要进行一些额外的步骤来解决该问题。以下是解决方法：</p><p>打开终端，并使用以下命令编辑 MariaDB 的服务文件：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo nano /lib/systemd/system/mariadb.service</span><br></pre></td></tr></table></figure><p>在文件的 <code>[Service]</code> 部分中添加一个新的行，内容如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[Service]</span><br><span class="line">...</span><br><span class="line">...</span><br><span class="line">ExecStartPre=/bin/sh -c <span class="string">&#x27;touch /etc/mysql/mariadb.conf.d/.interactive&#x27;</span></span><br></pre></td></tr></table></figure><p>确保在 <code>[Service]</code> 部分内的其他行之后添加此行。</p><p>保存并关闭文件（在 Nano 编辑器中按 Ctrl+X，然后按 Y 确认保存）。</p><p>运行以下命令重新加载 systemd 配置：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo systemctl daemon-reload</span><br></pre></td></tr></table></figure><p>现在，您可以启动 MariaDB 服务：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo systemctl start mariadb</span><br></pre></td></tr></table></figure><p>这次启动应该没有出现 “Interactive authentication required” 错误。</p><p>最后，您可以设置 MariaDB 在系统启动时自动启动：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo systemctl enable mariadb</span><br></pre></td></tr></table></figure><p>现在，您应该能够成功启动和运行 MariaDB 服务了。如果您仍然遇到问题，请确保按照上述步骤操作，并仔细检查所做的更改是否正确。</p>]]></content>
    
    
    <summary type="html">wsl的ubuntu中无法systemctl启动mariadb问题解决</summary>
    
    
    
    <category term="学习sql" scheme="https://blog.musnow.top/categories/%E5%AD%A6%E4%B9%A0sql/"/>
    
    
    <category term="Linux" scheme="https://blog.musnow.top/tags/Linux/"/>
    
    <category term="mysql" scheme="https://blog.musnow.top/tags/mysql/"/>
    
  </entry>
  
  <entry>
    <title>【Linux】wsl虚拟机时间和实际时间不符合</title>
    <link href="https://blog.musnow.top/posts/1339169411/"/>
    <id>https://blog.musnow.top/posts/1339169411/</id>
    <published>2023-12-12T01:30:55.000Z</published>
    <updated>2023-12-12T01:31:55.000Z</updated>
    
    <content type="html"><![CDATA[<p>偶然遇到了这个问题，触发原因是电脑在开启wsl的情况下进入了<code>休眠</code>模式，且在无网络情况下几天不使用。</p><p>然后开启wsl，发现<code>git log</code>显示最新commit的提交时间是明天，给我吓一跳，然后才发现原来是wsl里面的时间不对。</p><p>Linux下看时间的命令是<code>date</code>，本文写于12月12日，但wsl中的时间是12月10日，肯定是不对。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; date</span><br><span class="line">Tue Dec 10 09:51:29 AM CST 2023</span><br></pre></td></tr></table></figure><p>在wsl内部使用如下命令进行时间同步</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo hwclock -s</span><br></pre></td></tr></table></figure><p>执行后，在windows的命令行里面执行如下命令，重启wsl子系统。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wsl --shutdown</span><br></pre></td></tr></table></figure><p>再在wsl里面执行<code>date</code>命令，时间正确。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; date</span><br><span class="line">Tue Dec 12 09:53:21 AM CST 2023</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">wsl虚拟机时间和实际时间不符合</summary>
    
    
    
    <category term="玩上Linux" scheme="https://blog.musnow.top/categories/%E7%8E%A9%E4%B8%8ALinux/"/>
    
    
    <category term="Linux" scheme="https://blog.musnow.top/tags/Linux/"/>
    
    <category term="虚拟机" scheme="https://blog.musnow.top/tags/%E8%99%9A%E6%8B%9F%E6%9C%BA/"/>
    
    <category term="wsl" scheme="https://blog.musnow.top/tags/wsl/"/>
    
  </entry>
  
  <entry>
    <title>【Hexo】在中英文之间添加空格</title>
    <link href="https://blog.musnow.top/posts/3894841472/"/>
    <id>https://blog.musnow.top/posts/3894841472/</id>
    <published>2023-12-10T07:32:14.000Z</published>
    <updated>2023-12-10T07:32:14.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="说明和插件安装"><a href="#说明和插件安装" class="headerlink" title="说明和插件安装"></a>说明和插件安装</h1><p>如题，中英文添加空格是比较规范的写法， 但是我个人实在是懒，每次都要这么弄太累了。想找找hexo有没有对应的插件，还是有的</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-filter-auto-spacing --save</span><br></pre></td></tr></table></figure><p>安装了之后，在hexo的<code>_config.yml</code>里面添加配置项</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># hexo 中英文之间自动加空格</span><br><span class="line"># npm install hexo-filter-auto-spacing --save</span><br><span class="line">auto_spacing:</span><br><span class="line">  enable: true</span><br></pre></td></tr></table></figure><p>随后<code>hexo s</code>就能看到插件启用后的结果了</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2023/12/bc23322af55db5caac57603bdc3df125.png" alt="image-20231210153203131"></p><p>请注意，该插件仓库 <a href="https://github.com/hexojs/hexo-filter-auto-spacing">https://github.com/hexojs/hexo-filter-auto-spacing</a> 已经被设置为公共归档，且最后一次代码提交是<strong>2022年6月</strong>。</p><p>2023年12月10日实测该插件依旧有用，但不保证hexo更新后依旧有效。慕雪使用的hexo和主题版本如下。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hexo 6.2.0</span><br><span class="line">hexo-butterfly 4.9.0</span><br></pre></td></tr></table></figure><p>暂时没有搜到其他仍在更新的插件。</p><h1 id="buffterfly主题自带配置"><a href="#buffterfly主题自带配置" class="headerlink" title="buffterfly主题自带配置"></a>buffterfly主题自带配置</h1><p>感谢评论区老哥的提醒，buffterfly主题其实<strong>自带</strong>了这个配置项 <a href="https://butterfly.js.org/posts/ceeb73f/#Pangu">https://butterfly.js.org/posts/ceeb73f/#Pangu</a></p><p>使用如下命令<strong>卸载</strong>上方提到的插件。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm uninstall hexo-filter-auto-spacing --save</span><br></pre></td></tr></table></figure><p>在hexo-butterfly主题中<code>pangu</code>配置项就是中英文之间添加空格的配置。</p><p>其中site是对全站生效，post是只对文章生效（对其他页面不生效）</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># https://github.com/vinta/pangu.js</span></span><br><span class="line"><span class="comment"># Insert a space between Chinese character and English character (中英文之間添加空格)</span></span><br><span class="line"><span class="attr">pangu:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">false</span></span><br><span class="line">  <span class="attr">field:</span> <span class="string">site</span> <span class="comment"># site/post</span></span><br></pre></td></tr></table></figure><p>将enable改成true即可启用，效果也很好，不仅中英文之间会添加空格，数字和中文之间也添加了空格。完美啦！</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2023/12/1ffcfb9e601a003fd9e246a31d833e15.png" alt="image-20231210213203331"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;说明和插件安装&quot;&gt;&lt;a href=&quot;#说明和插件安装&quot; class=&quot;headerlink&quot; title=&quot;说明和插件安装&quot;&gt;&lt;/a&gt;说明和插件安装&lt;/h1&gt;&lt;p&gt;如题，中英文添加空格是比较规范的写法， 但是我个人实在是懒，每次都要这么弄太累了。想找找hexo有没</summary>
      
    
    
    
    <category term="差生文具多" scheme="https://blog.musnow.top/categories/%E5%B7%AE%E7%94%9F%E6%96%87%E5%85%B7%E5%A4%9A/"/>
    
    
    <category term="Hexo" scheme="https://blog.musnow.top/tags/Hexo/"/>
    
  </entry>
  
  <entry>
    <title>【nginx】nginx 配置避免 IP 访问时证书暴露域名</title>
    <link href="https://blog.musnow.top/posts/3528013149/"/>
    <id>https://blog.musnow.top/posts/3528013149/</id>
    <published>2023-12-09T09:12:55.000Z</published>
    <updated>2023-12-09T10:12:55.000Z</updated>
    
    <content type="html"><![CDATA[<p>本文转载自：<a href="https://zinglix.xyz/2021/10/04/nginx-ssl-reject-handshake/">https://zinglix.xyz/2021/10/04/nginx-ssl-reject-handshake/</a></p><h1 id="原文"><a href="#原文" class="headerlink" title="原文"></a>原文</h1><h2 id="TL-DR"><a href="#TL-DR" class="headerlink" title="TL;DR"></a>TL;DR</h2><p>nginx 配置避免 IP 访问时证书暴露域名</p><p>利用 <code>nginx 1.19.4</code> 后的新特性 <code>ssl_reject_handshake on;</code>，将其置于默认访问时配置中，IP 访问时会终止 TLS 握手，也就不会暴露域名了。</p><p>使用如下命令查看你的nginx版本</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># nginx -v</span><br><span class="line">nginx version: nginx/1.20.1</span><br></pre></td></tr></table></figure><h2 id="细说"><a href="#细说" class="headerlink" title="细说"></a>细说</h2><p>CDN 是建站时常用的工具，在自己的主机外面套一层 CDN 是常见操作，一般这样认为自己的主机就安全了，有人来攻击也会先到 CDN 服务器，攻击者根本无法获取到自己主机的 IP，但事实真的是这样吗？</p><p>我们先来看看一般配置后会出现什么问题。</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">    <span class="attribute">listen</span> <span class="number">80</span> default_server;</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Redirect all HTTP requests to HTTPS.</span></span><br><span class="line">    <span class="attribute">return</span> <span class="number">301</span> https://<span class="variable">$host</span><span class="variable">$request_uri</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">    <span class="attribute">listen</span> <span class="number">443</span> default_server;</span><br><span class="line">    <span class="attribute">server_name</span> _;</span><br><span class="line">    <span class="attribute">include</span> conf.d/ssl.config;</span><br><span class="line">    <span class="attribute">return</span> <span class="number">444</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面是一个很常用的 nginx 配置，HTTP 访问全部重定向到 HTTPS 的 443 端口上，没有配置过的域名返回 444 终止连接。</p><p>好了，现在尝试用 IP 和 HTTPS 访问你的网站，你应该能够看到预想中访问失败、证书无效等连接失败的提示。</p><p><strong>但是！</strong>注意下浏览器左上角提示的不安全，点开查看证书信息，你就会发现你的域名其实随着证书发送了过来。此时如果你是攻击者，那么其实就可以知道该域名背后的源主机 IP 就是这个。</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2023/12/035ad572d3638bb917c07e53e24c9575.png"></p><p>上图即为用 IP 访问后，依旧能看到证书内容。这是因为返回 444 是 HTTP 层面的事情，意味着到达这一步下层的 TLS 握手已经完成。证书不被信任是一回事，但说明已经拿到了服务器的证书。</p><p>CDN 确实避免了直接 DNS 查询暴露 IP 的问题，但攻击者通过扫描全网 IP，用上述方式依旧可以知道每个 IP 对应的域名是什么，这也是为什么很多站长用了 CDN 后并且反复更换 IP 却依旧被攻击者迅速找到 IP 的原因。</p><blockquote><p><a href="https://search.censys.io/">Censys</a> 就一直在干这件事，全网扫描 IP 并找到其对应的域名</p></blockquote><h2 id="那该怎么办呢？"><a href="#那该怎么办呢？" class="headerlink" title="那该怎么办呢？"></a>那该怎么办呢？</h2><p>问题根源出在 client 在 TLS 握手时发送了 ClientHello 后，nginx 在 ServerHello 中带着含有域名的默认证书返回了，因为 nginx 期望可以完成握手，这可能可以算是 nginx 的一个缺陷。</p><blockquote><p>如果你不熟悉 TLS 握手流程，那么可以看看 <a href="https://zinglix.xyz/2019/05/07/tls-handshake/">这篇文章</a></p></blockquote><h3 id="笨办法"><a href="#笨办法" class="headerlink" title="笨办法"></a>笨办法</h3><p>既然 nginx 默认提供了带有域名的证书，那么想不暴露也很简单，提供一个不含有正确域名的证书即可。</p><p>nginx 设置中 HTTPS 访问如果没有设置证书，那么就会报错。但反正 IP 访问也不需要提供服务，那么直接自签一个 IP 证书，或者随便一个域名的证书都可。当然，如果能搞定合法的 IP 证书也不是不行。</p><p>搞定证书后，添加一个配置，让 IP 访问返回错误证书就完事了。</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">    <span class="attribute">listen</span> <span class="number">443</span> ssl default_server;</span><br><span class="line">    <span class="attribute">server_name</span> your_ip;</span><br><span class="line"></span><br><span class="line">    <span class="attribute">ssl_certificate</span>    xxxx.pem;</span><br><span class="line">    // <span class="attribute">and</span> more ssl config ...</span><br><span class="line"></span><br><span class="line">    return <span class="number">444</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="好方法"><a href="#好方法" class="headerlink" title="好方法"></a>好方法</h3><p>这种方法还得自己搞个证书，如果服务器多每个都得这么搞也挺麻烦的，好在这个问题 nginx 这已经有了很完美的解决方案。</p><p>ClientHello 中是带着 SNI 的，所以其实握手阶段是可以知道访问的域名是否合法的，nginx 1.19.4 中添加了一个新的配置项 <code>ssl_reject_handshake</code> 用于拒绝握手，也就不会提供证书。</p><p>使用方法也很简单，将原本默认配置中的 <code>return 444</code> 替换成 <code>ssl_reject_handshake on</code> 即可。</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">    <span class="attribute">listen</span> <span class="number">443</span> default_server;</span><br><span class="line">    <span class="attribute">server_name</span> _;</span><br><span class="line">    <span class="attribute">include</span> conf.d/ssl.config;</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 不用返回 444 了，直接拒绝握手</span></span><br><span class="line">    <span class="attribute">ssl_reject_handshake</span> <span class="literal">on</span>;</span><br><span class="line">    <span class="comment"># return 444;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>配置后，再尝试 IP 访问，会发现浏览器报了 <code>ERR_SSL_UNRECOGNIZED_NAME_ALERT</code> 的错误，也看不到证书信息，目标达成！</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2023/12/18ba4a8ac5a7c8d5400ecf4a2a6bb392.png"></p><h2 id="其实还没完"><a href="#其实还没完" class="headerlink" title="其实还没完"></a>其实还没完</h2><p>上述方法是通过 ClientHello 中的 SNI 确定访问是否合法的，那如果 SNI 就是正确的域名呢？</p><p>这种场景发生于攻击者已经确定要攻击某个域名，那么他就可以将带着该域名的握手信息遍历所有 IP，握手成功就找到，这样访问其实与正常访问并无区别，<strong>唯一解决方法</strong>就是白名单只允许 CDN 服务器访问。</p><blockquote><p>例如攻击者用 hosts 直接硬写 IP，<strong>将域名强行指向某个 IP</strong></p><p>或者用这种方式 <code>curl https://example.com --resolve &#39;example.com:443:172.17.54.18&#39;</code></p></blockquote><p>如下，在 nginx 里面的 location 配置添加上 allow 的 IP 段，只允许 CDN 运营商的 IP 访问你的服务，就能避免绕过 CDN 造成的攻击</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">location</span> / &#123;</span><br><span class="line">    <span class="attribute">allow</span>   <span class="number">172.1.2.0</span>/<span class="number">24</span>; <span class="comment"># 允许CDN运营商的IP</span></span><br><span class="line">    <span class="attribute">allow</span>   <span class="number">1.2.3.4</span>/<span class="number">32</span>;</span><br><span class="line">    <span class="attribute">deny</span>    all; <span class="comment"># 阻止其他任何IP</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述 IP 段只能向 CDN 服务提供商询问，一般文档中都是有相关信息的。</p><h1 id="慕雪的测试"><a href="#慕雪的测试" class="headerlink" title="慕雪的测试"></a>慕雪的测试</h1><p>上面这篇文章我第一次看的时候还没有理解他说的是什么内容。后来测试了一下，明白了。</p><h2 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h2><p>以我的服务器举例，我是<code>centos 7.2</code>的服务器，直接用yum安装的nginx，版本<code>nginx/1.20.1</code>，配置路径是<code>/etc/nginx</code>；</p><p>在默认情况下，你会有个<code>nginx.conf</code>，和<code>/etc/nginx/conf.d</code>里面的用户配置文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">/etc/nginx</span><br><span class="line">- nginx.conf</span><br><span class="line">- conf.d</span><br><span class="line">- server1.conf</span><br><span class="line">- server2.conf</span><br></pre></td></tr></table></figure><p>在<code>nginx.conf</code>里面除了加载用户配置文件，还会有一个默认的server，指向一个<strong>静态文件路径</strong>。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"># 用户配置文件</span><br><span class="line">   include /etc/nginx/conf.d/*.conf;</span><br><span class="line"></span><br><span class="line">   server &#123;</span><br><span class="line">       listen       80;</span><br><span class="line">       listen       [::]:80;</span><br><span class="line">       server_name  _;</span><br><span class="line">       root         /usr/share/nginx/html; # 默认的静态文件路径</span><br><span class="line"></span><br><span class="line">       # Load configuration files for the default server block.</span><br><span class="line">       include /etc/nginx/default.d/*.conf;</span><br><span class="line"></span><br><span class="line">       error_page 404 /404.html;</span><br><span class="line">       location = /404.html &#123;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       error_page 500 502 503 504 /50x.html;</span><br><span class="line">       location = /50x.html &#123;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>在我的服务器上，这个路径里面是如下内容</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@bt-7274:/etc/nginx]# ls /usr/share/nginx/html</span><br><span class="line">404.html  50x.html  en-US  icons  img  index.html  nginx-logo.png  poweredby.png</span><br></pre></td></tr></table></figure><p>此时直接在浏览器访问你的ip，会展示这个默认路径里面的<code>index.html</code>，是centos的一个介绍页面。</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2023/12/03207321f1c2ee5a4f77f22d55746121.png" alt="image-20231209173337849"></p><p>但是，这并不代表你当前没有解析到任何<strong>用户自定义文件</strong>！nginx默认情况下会使用第一个用户自定义conf来作为ip访问的结果（这是因为对用户自定义conf的include是在defualt server之前的，你可以理解为用户自定义文件会像C语言的头文件一样在<code>nginx.conf</code>中被展开）</p><p>当前实际上是访问了<code>/etc/nginx/conf.d</code>里面按字典排序的<strong>第一个用户conf配置</strong>！</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">/etc/nginx</span><br><span class="line">- nginx.conf</span><br><span class="line">- conf.d</span><br><span class="line">- server1.conf # 直接访问ip，使用了这个配置文件</span><br><span class="line">- server2.conf</span><br></pre></td></tr></table></figure><p>为什么在我这里依旧展示了<strong>默认的静态文件路径呢</strong>？是因为我的第一个配置文件<code>a.conf</code>中没有配置<code>location /</code>，全都是其他路径（比如<code>/a/</code>）的反代！所以nginx就往后采用了最末尾的default server里面提供的默认静态文件。</p><p>而浏览器链接左侧的红色<code>不安全</code>就告诉我们，当前其实收到了一个ssl证书，这便是上面原文中提到的<code>ip访问会因为ssl证书泄漏域名</code>的问题。</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2023/12/0aff6af71c686835cb262961360442ab.png" alt="image-20231209174001901"></p><p>我们可以点击<code>不安全</code>提示，再点击右上角那个<strong>带徽章的小按钮</strong>，查看当前收到的证书</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2023/12/96fafa7dca660e58ec838fb95350aa05.png" alt="image-20231209174025184"></p><p>如下图，当前收到的这证书，正是我的<code>/etc/nginx/conf.d</code>中第一个用户配置里面的ssl证书；内部包含了该证书对应的域名，我们的域名因此泄漏！</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2023/12/c59ed5779697e2dda320ae46d6b8f7e5.png" alt="image-20231209174102666"></p><h2 id="思路回顾"><a href="#思路回顾" class="headerlink" title="思路回顾"></a>思路回顾</h2><p>再来缕一缕思路</p><ul><li>nginx会先加载用户配置文件，末尾才是默认指向<code>/usr/share/nginx/html</code>静态路径的配置</li><li>当你使用ip访问当前服务器，nginx会给浏览器发送<code>/etc/nginx/conf.d</code>中按<strong>字典序</strong>排在第一位的<strong>用户配置文件</strong>中的ssl证书（即上图所示证书）</li><li>恶意访问人员可以通过遍历访问所有IP地址，当访问你的服务器IP地址时，他拿到一个ssl证书，其中包括了一个域名A；</li><li>假设你的域名A是按<code>域名A-&gt;CDN-&gt;服务器IP</code>来进行解析的，此时恶意访问人员就通过这个ssl证书直接得到了<code>域名A-&gt;服务器IP</code>的对应关系，完全绕过了CDN</li><li>此时他就可以通过修改hosts强制让<code>域名A</code>指向<code>服务器IP</code>，绕过CDN直接攻击你的源站</li></ul><p>套了CDN还暴露源站IP肯定不是我们想要的结果，所以我们需要解决这个问题！</p><h2 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h2><p>在<code>/etc/nginx/conf.d</code>中直接添加一个<code>a.conf</code>，让其排序在<strong>字典序的第一位</strong>，里面写入如下内容，其中<code>server_name _</code>的含义是除了我们配置过的域名外的其他访问</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">    <span class="attribute">listen</span> <span class="number">80</span> default_server;</span><br><span class="line">    <span class="attribute">server_name</span> _;</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Redirect all HTTP requests to HTTPS.</span></span><br><span class="line">    <span class="attribute">return</span> <span class="number">301</span> https://<span class="variable">$host</span><span class="variable">$request_uri</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">    <span class="attribute">listen</span> <span class="number">443</span> default_server;</span><br><span class="line">    <span class="attribute">server_name</span> _;</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 不用返回 444 了，直接拒绝握手</span></span><br><span class="line">    <span class="attribute">ssl_reject_handshake</span> <span class="literal">on</span>;</span><br><span class="line">    <span class="comment"># return 444;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>配置后直接重启nginx，没有报错就是ok了</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@bt-7274:/etc/nginx/conf.d]# systemctl restart nginx</span><br><span class="line">[root@bt-7274:/etc/nginx/conf.d]# ll</span><br><span class="line">total 28</span><br><span class="line">-rw-r--r-- 1 root root  193 Dec  9 17:52 a.conf</span><br></pre></td></tr></table></figure><p>此时直接访问就会报错ssl的alert了，但是edge中估计是因为<strong>缓存的问题</strong>，依旧能看到证书</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2023/12/9c095bed2d740e56c781c10e33212c9d.png" alt="image-20231209175534238"></p><p>换火狐看一下，无法连接，没有证书，目标达成！</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2023/12/20311f168b98f1ebe38157edf25b0c1a.png" alt="image-20231209175736923"></p><p>这里顺带贴一下火狐中一个正常ssl网站会显示成什么样子。如下是京东官网，在锁的按钮里面能看到证书的颁发者，而<strong>上图修改完毕配置文件后的测试中</strong>没有看到证书颁发者，即我们的证书并没有泄漏，目的达成。</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2023/12/6b4716321086d0e5ef6978695a52b630.png" alt="image-20231209175834078"></p><p>另外，我试了试我另外一个服务器使用的1panel安装的OpenResty，这个比较好，在默认情况下直接访问IP地址返回的是404，且没有暴露证书。不需要自己额外做配置了。</p>]]></content>
    
    
    <summary type="html">nginx配置避免IP访问时证书暴露域名</summary>
    
    
    
    <category term="玩上Linux" scheme="https://blog.musnow.top/categories/%E7%8E%A9%E4%B8%8ALinux/"/>
    
    
    <category term="Linux" scheme="https://blog.musnow.top/tags/Linux/"/>
    
    <category term="nginx" scheme="https://blog.musnow.top/tags/nginx/"/>
    
  </entry>
  
  <entry>
    <title>【nginx】nginx通过配置文件阻止海外ip访问</title>
    <link href="https://blog.musnow.top/posts/2029711168/"/>
    <id>https://blog.musnow.top/posts/2029711168/</id>
    <published>2023-12-09T08:12:55.000Z</published>
    <updated>2023-12-09T12:12:55.000Z</updated>
    
    <content type="html"><![CDATA[<p>nginx通过配置文件阻止海外ip访问</p><h1 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h1><p>因为最近发现有不少刷评论的脚本，在nginx请求日志里面看了眼，都是海外的ip，反正我的博客也是全中文。所以干脆把海外ip禁止artalk评论。</p><p>在<code>/etc/nginx/nginx.conf</code>中可以看到默认的日志路径，在里面能找到每一个转发的请求和其源IP。其中artak新增评论的请求是<code>/api/add</code>路径</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">access_log  /var/log/nginx/access.log  main;</span><br></pre></td></tr></table></figure><p>考虑到添加海外ip屏蔽可能会阻止一些真的在国外的朋友，如果你在阅读本站博客时，遇到相关问题无法直接评论与我交流，可以移步github随便找个我的仓库开个issue提问！</p><h1 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h1><h2 id="APNIC介绍"><a href="#APNIC介绍" class="headerlink" title="APNIC介绍"></a>APNIC介绍</h2><p>后文出现的网站是来自<strong>APNIC</strong> (Asia Pacific Network Information Center)，其是IP地址管理机构之一，负责亚洲、太平洋地区。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">APNIC提供了每日更新的亚太地区IPv4，IPv6，AS号分配的信息表：</span><br><span class="line">http://ftp.apnic.net/apnic/stats/apnic/delegated-apnic-latest</span><br><span class="line">该文件的格式与具体内容参见：</span><br><span class="line">http://ftp.apnic.net/pub/apnic/stats/apnic/README.TXT</span><br></pre></td></tr></table></figure><h2 id="脚本获取ip"><a href="#脚本获取ip" class="headerlink" title="脚本获取ip"></a>脚本获取ip</h2><p>初步解决方法参考：<a href="https://www.cnblogs.com/guoyabin/p/14263732.html">https://www.cnblogs.com/guoyabin/p/14263732.html</a></p><p>原博主提供的脚本如下，可以下载所有海外ip列表并生成一个nginx配置，写入<code>/etc/nginx/blackip.conf</code>中</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="built_in">rm</span> -f legacy-apnic-latest black_`<span class="built_in">date</span> +%F`.conf &amp;&amp; wget http://ftp.apnic.net/apnic/stats/apnic/legacy-apnic-latest</span><br><span class="line"></span><br><span class="line">awk -F <span class="string">&#x27;|&#x27;</span> <span class="string">&#x27;&#123;if(NR&gt;2)printf(&quot;%s %s/%d%s\n&quot;,&quot;deny&quot;,$4,24,&quot;;&quot;)&#125;&#x27;</span> legacy-apnic-latest &gt; black_`<span class="built_in">date</span> +%F`.conf &amp;&amp; \</span><br><span class="line"><span class="built_in">rm</span> -f /etc/nginx/blackip.conf &amp;&amp; \</span><br><span class="line"><span class="built_in">ln</span> -s <span class="variable">$PWD</span>/black_`<span class="built_in">date</span> +%F`.conf /etc/nginx/blackip.conf</span><br></pre></td></tr></table></figure><p>脚本执行后的效果如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@bt-7274:/etc/nginx]# ll</span><br><span class="line">total 88</span><br><span class="line">lrwxrwxrwx 1 root root   34 Dec  9 16:03 blackip.conf -&gt; /root/docker/black_2023-12-09.conf</span><br></pre></td></tr></table></figure><p>文件内容如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[root@bt-7274:/etc/nginx/conf.d]# cat ../blackip.conf</span><br><span class="line">deny 128.134.0.0/24;</span><br><span class="line">deny 128.184.0.0/24;</span><br><span class="line">deny 128.250.0.0/24;</span><br><span class="line">deny 129.60.0.0/24;</span><br><span class="line">deny 129.78.0.0/24;</span><br><span class="line">...后面的省略了</span><br></pre></td></tr></table></figure><h2 id="nginx屏蔽海外ip"><a href="#nginx屏蔽海外ip" class="headerlink" title="nginx屏蔽海外ip"></a>nginx屏蔽海外ip</h2><p>参考原博主的做法，你可以将这个<code>blackip.conf</code>在<code>/etc/nginx/nginx.conf</code>中的<strong>http模块</strong>里面include，这样会阻止当前服务器所有反代的海外的请求。</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">include</span> /etc/nginx/blackip.conf;</span><br></pre></td></tr></table></figure><p>还可以在单个配置文件的<a href="https://zinglix.xyz/2021/10/04/nginx-ssl-reject-handshake/">location里面引用</a></p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">  <span class="section">location</span> / &#123;</span><br><span class="line">      <span class="attribute">proxy_redirect</span> <span class="literal">off</span>; <span class="comment"># artalk的nginx配置中必须有这个</span></span><br><span class="line">      <span class="attribute">proxy_set_header</span> X-Real-IP <span class="variable">$remote_addr</span>;</span><br><span class="line">      <span class="attribute">proxy_set_header</span> X-Forwarded-For <span class="variable">$proxy_add_x_forwarded_for</span>;</span><br><span class="line">      <span class="attribute">proxy_set_header</span> Host <span class="variable">$host</span>;</span><br><span class="line">      <span class="attribute">proxy_set_header</span> Upgrade-Insecure-Requests <span class="number">1</span>;</span><br><span class="line">      <span class="attribute">proxy_set_header</span> X-Forwarded-Proto https;</span><br><span class="line"></span><br><span class="line">      <span class="attribute">include</span> /etc/nginx/blackip.conf; <span class="comment"># 引用配置</span></span><br><span class="line"></span><br><span class="line">      <span class="attribute">proxy_pass</span> http://127.0.0.1:14722;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>修改后重启nginx，没有报错就是ok了</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl restart nginx</span><br></pre></td></tr></table></figure><p>用海外的服务器试试能不能请求artalk，用<a href="https://artk.musnow.top/sidebar/#/login">artk.musnow.top&#x2F;sidebar&#x2F;…</a>这个管理员登录页面来进行测试。</p><p>国内服务器请求结果如下，和浏览器打开的结果基本是一样（管理员登录界面）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">[root@bt-7274:/etc/nginx/conf.d]# curl https://artk.musnow.top/sidebar/#/login</span><br><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">  &lt;head&gt;</span><br><span class="line">    &lt;meta charset=&quot;UTF-8&quot; /&gt;</span><br><span class="line">    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot; /&gt;</span><br><span class="line">    &lt;title&gt;Artalk Sidebar&lt;/title&gt;</span><br><span class="line">    &lt;script type=&quot;module&quot; crossorigin src=&quot;./assets/index-5a0b3a93.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">    &lt;link rel=&quot;stylesheet&quot; href=&quot;./assets/index-84fdcf98.css&quot;&gt;</span><br><span class="line">  &lt;/head&gt;</span><br><span class="line">  &lt;body&gt;</span><br><span class="line">    &lt;div id=&quot;app&quot;&gt;&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">  &lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><p>海外服务器请求结果也是上面这样……然后发现是因为我的海外服务器ip压根不在那个black的deny列表里面</p><p>尝试把ip的网段给加进去，重启nginx再试试。<strong>完美处理</strong>！添加前能正常请求到，添加后就变成403了</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">[root@RainYun-8aNbbsmA:~]# curl https://artk.musnow.top/sidebar/#/login</span><br><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">  &lt;head&gt;</span><br><span class="line">    &lt;meta charset=&quot;UTF-8&quot; /&gt;</span><br><span class="line">    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot; /&gt;</span><br><span class="line">    &lt;title&gt;Artalk Sidebar&lt;/title&gt;</span><br><span class="line">    &lt;script type=&quot;module&quot; crossorigin src=&quot;./assets/index-5a0b3a93.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">    &lt;link rel=&quot;stylesheet&quot; href=&quot;./assets/index-84fdcf98.css&quot;&gt;</span><br><span class="line">  &lt;/head&gt;</span><br><span class="line">  &lt;body&gt;</span><br><span class="line">    &lt;div id=&quot;app&quot;&gt;&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">  &lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br><span class="line">[root@RainYun-8aNbbsmA:~]#</span><br><span class="line">[root@RainYun-8aNbbsmA:~]# curl https://artk.musnow.top/sidebar/#/login</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;&lt;title&gt;403 Forbidden&lt;/title&gt;&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;center&gt;&lt;h1&gt;403 Forbidden&lt;/h1&gt;&lt;/center&gt;</span><br><span class="line">&lt;hr&gt;&lt;center&gt;nginx/1.20.1&lt;/center&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br><span class="line">[root@RainYun-8aNbbsmA:~]#</span><br></pre></td></tr></table></figure><h2 id="nginx屏蔽非国内ip"><a href="#nginx屏蔽非国内ip" class="headerlink" title="nginx屏蔽非国内ip"></a>nginx屏蔽非国内ip</h2><p>我前文提到了我的海外服务器的ip不在这个deny的ip列表里面，没有被屏蔽。</p><p>考虑到网上搜不到<code>legacy-apnic-latest</code>文件存放的是什么ip的信息，我决定换一个思路：allow国内的ip，拒绝所有非国内的ip</p><blockquote><p>获取国内ip列表 <a href="https://www.cnblogs.com/sentangle/p/13201770.html">https://www.cnblogs.com/sentangle/p/13201770.html</a></p></blockquote><p>下面这个url里面的ip地址标明了地区，我们只需要将其提取出来即可</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://ftp.apnic.net/apnic/stats/apnic/delegated-apnic-latest</span><br></pre></td></tr></table></figure><p>这个文件里面的内容结构如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">等级机构|获得该IP段的国家/组织|资源类型|起始IP|IP段长度|分配日期|分配状态</span><br></pre></td></tr></table></figure><p>我们只需要提取CN的所有IP，然后允许他们，再<code>deny all</code>阻止其他ip就可以了</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="built_in">rm</span> -f delegated-apnic-latest blackcn_`<span class="built_in">date</span> +%F`.conf &amp;&amp; wget http://ftp.apnic.net/apnic/stats/apnic/delegated-apnic-latest</span><br><span class="line"></span><br><span class="line">awk -F\| <span class="string">&#x27;/CN\|ipv4/ &#123; printf(&quot;%s %s/%d%s\n&quot;,&quot;allow&quot;,$4, 32-log($5)/log(2), &quot;;&quot;) &#125;&#x27;</span> delegated-apnic-latest &gt; blackcn_`<span class="built_in">date</span> +%F`.conf &amp;&amp; \</span><br><span class="line"><span class="built_in">rm</span> -f /etc/nginx/blackcn.conf &amp;&amp; \</span><br><span class="line"><span class="built_in">ln</span> -s <span class="variable">$PWD</span>/blackcn_`<span class="built_in">date</span> +%F`.conf /etc/nginx/blackcn.conf</span><br></pre></td></tr></table></figure><p>执行这个脚本后，会生成<code>/etc/nginx/blackcn.conf</code>文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@bt-7274:/etc/nginx]# ll</span><br><span class="line">total 88</span><br><span class="line">lrwxrwxrwx 1 root root   42 Dec  9 16:54 blackcn.conf -&gt; /root/docker/nginx/blackcn_2023-12-09.conf</span><br><span class="line">lrwxrwxrwx 1 root root   40 Dec  9 16:56 blackip.conf -&gt; /root/docker/nginx/black_2023-12-09.conf</span><br></pre></td></tr></table></figure><p>内容如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">allow 223.248.0.0/14;</span><br><span class="line">allow 223.252.128.0/17;</span><br><span class="line">allow 223.254.0.0/16;</span><br><span class="line">allow 223.255.0.0/17;</span><br><span class="line">allow 223.255.236.0/22;</span><br><span class="line">allow 223.255.252.0/23;</span><br><span class="line">....</span><br></pre></td></tr></table></figure><p>还是修改nginx单个站点配置文件的location中的内容</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">  <span class="section">location</span> / &#123;</span><br><span class="line">      <span class="attribute">proxy_redirect</span> <span class="literal">off</span>;</span><br><span class="line">  <span class="attribute">proxy_set_header</span> X-Real-IP <span class="variable">$remote_addr</span>;</span><br><span class="line">      <span class="attribute">proxy_set_header</span> X-Forwarded-For <span class="variable">$proxy_add_x_forwarded_for</span>;</span><br><span class="line">      <span class="attribute">proxy_set_header</span> Host <span class="variable">$host</span>;</span><br><span class="line">      <span class="attribute">proxy_set_header</span> Upgrade-Insecure-Requests <span class="number">1</span>;</span><br><span class="line">      <span class="attribute">proxy_set_header</span> X-Forwarded-Proto https;</span><br><span class="line"><span class="comment"># 允许所有国内ip</span></span><br><span class="line">  <span class="attribute">include</span> /etc/nginx/blackcn.conf;</span><br><span class="line">  <span class="attribute">deny</span> all; <span class="comment"># 阻止其他ip</span></span><br><span class="line"></span><br><span class="line">  <span class="attribute">proxy_pass</span> http://127.0.0.1:14722;</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure><p>先来试试不修改配置文件（不做任何deny和allow操作的情况下）海外ip请求结果</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">[root@RainYun-8aNbbsmA:~]# curl https://artk.musnow.top/sidebar/#/login</span><br><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">  &lt;head&gt;</span><br><span class="line">    &lt;meta charset=&quot;UTF-8&quot; /&gt;</span><br><span class="line">    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot; /&gt;</span><br><span class="line">    &lt;title&gt;Artalk Sidebar&lt;/title&gt;</span><br><span class="line">    &lt;script type=&quot;module&quot; crossorigin src=&quot;./assets/index-5a0b3a93.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">    &lt;link rel=&quot;stylesheet&quot; href=&quot;./assets/index-84fdcf98.css&quot;&gt;</span><br><span class="line">  &lt;/head&gt;</span><br><span class="line">  &lt;body&gt;</span><br><span class="line">    &lt;div id=&quot;app&quot;&gt;&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">  &lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><p>符合预期，正常请求出了登录页面的html文件。</p><p>添加如上修改后，重启nginx，再次进行测试。这一次已经403阻止了，完美！</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[root@RainYun-8aNbbsmA:~]# curl https://artk.musnow.top/sidebar/#/login</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;&lt;title&gt;403 Forbidden&lt;/title&gt;&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;center&gt;&lt;h1&gt;403 Forbidden&lt;/h1&gt;&lt;/center&gt;</span><br><span class="line">&lt;hr&gt;&lt;center&gt;nginx/1.20.1&lt;/center&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><h1 id="The-end"><a href="#The-end" class="headerlink" title="The end"></a>The end</h1><p>你可以写个crontab让其定时执行脚本并重启nginx，我个人还是选择人工处理了（什么时候想起来就去更新一下ip列表）</p><p>感谢本文中出现的博客的博主。没有他们的帮助，我无法编写出shell脚本。</p>]]></content>
    
    
    <summary type="html">nginx通过配置文件阻止海外ip访问</summary>
    
    
    
    <category term="玩上Linux" scheme="https://blog.musnow.top/categories/%E7%8E%A9%E4%B8%8ALinux/"/>
    
    
    <category term="Linux" scheme="https://blog.musnow.top/tags/Linux/"/>
    
    <category term="nginx" scheme="https://blog.musnow.top/tags/nginx/"/>
    
  </entry>
  
  <entry>
    <title>【图床】删除对象存储桶前一定要检查！</title>
    <link href="https://blog.musnow.top/posts/3595872827/"/>
    <id>https://blog.musnow.top/posts/3595872827/</id>
    <published>2023-12-09T02:32:14.000Z</published>
    <updated>2023-12-09T02:32:14.000Z</updated>
    
    <content type="html"><![CDATA[<p>我又干蠢事了！虽然没有很大影响，但是这种问题还是不要发生的好。</p><h2 id="什么情况？"><a href="#什么情况？" class="headerlink" title="什么情况？"></a>什么情况？</h2><p>我在博客尚有引用某个对象存储bucket中图片的情况下，删除了那个bucket（因为这个bucket很久没有用，算是弃用的）</p><p>还好今天看旧笔记的时候，突然发现了这个问题，立马去重新搜索了一下这个旧bucket的图片链接，还好还好，受影响的只有两篇文章</p><ul><li>一篇之前导出过PDF，图片还能找到</li><li>另外一篇文章以文字为主，内部丢失的图片可有可无</li></ul><p>我恢复了第一篇里面的图片，然后修改了第二篇中和图片相关的文字说明，算是解决了这个问题。</p><p>又重写检查了一下笔记目录，算是彻底没有这个被我删除的bucket里面的图片了。</p><p>这一次还好，算是没有丢东西，不然数据不备份就删除的笑料又要多一个了……🤣</p><h2 id="以此为戒"><a href="#以此为戒" class="headerlink" title="以此为戒"></a>以此为戒</h2><p>删除bucket之前一定要检查自己到底还有没有使用这个bucket中的文件或者图片！</p><p>删除图床本地目录前，一定要检查自己还有没有这个本地目录里面的图片！</p><p>最佳方案：不要管那个bucket，将其访问权限改成<strong>私有</strong>后，使用备注功能将其标记为弃用。以后不再使用该bucket即可。</p><p>因为对于我个人使用来说，一个bucket里面不会有太多文件，目前最大的图床bucket也不过2GB而已，把它留在那里花不了几个钱！不然把bucket删了，哪天发现需要去里面找旧文件的时候无从下手就麻烦了！</p><blockquote><p>至于我为什么要删……其实是因为我有点强迫症，不用还留在那里看着有点不爽……</p></blockquote><p>当然还有另外一个解决方案：使用<code>rclone</code>等工具，将s3中的所有文件下载到本地，打包多地备份后，删除云端bucket</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;我又干蠢事了！虽然没有很大影响，但是这种问题还是不要发生的好。&lt;/p&gt;
&lt;h2 id=&quot;什么情况？&quot;&gt;&lt;a href=&quot;#什么情况？&quot; class=&quot;headerlink&quot; title=&quot;什么情况？&quot;&gt;&lt;/a&gt;什么情况？&lt;/h2&gt;&lt;p&gt;我在博客尚有引用某个对象存储bucke</summary>
      
    
    
    
    <category term="差生文具多" scheme="https://blog.musnow.top/categories/%E5%B7%AE%E7%94%9F%E6%96%87%E5%85%B7%E5%A4%9A/"/>
    
    
    <category term="图床" scheme="https://blog.musnow.top/tags/%E5%9B%BE%E5%BA%8A/"/>
    
  </entry>
  
  <entry>
    <title>【博客】hexo配置sitemap和百度|必应|谷歌收录</title>
    <link href="https://blog.musnow.top/posts/3595872826/"/>
    <id>https://blog.musnow.top/posts/3595872826/</id>
    <published>2023-12-08T12:32:14.000Z</published>
    <updated>2023-12-08T12:32:14.000Z</updated>
    
    <content type="html"><![CDATA[<p>最近没事找事，又看了会关于博客主题的东西，之前的sitemap一直没有弄上去，现在有时间就弄一下。</p><h1 id="1-hexo安装sitemap插件"><a href="#1-hexo安装sitemap插件" class="headerlink" title="1.hexo安装sitemap插件"></a>1.hexo安装sitemap插件</h1><p>在你的hexo路径下执行如下命令，安装sitemap生成插件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-generator-baidu-sitemap --save</span><br><span class="line">npm install hexo-generator-sitemap --save</span><br></pre></td></tr></table></figure><p>实测在windows11的<code>node v16.20.2</code>和<code>npm  9.8.1</code>下可以正常安装，但是安装baidu-sitemap插件的时候可能会有警告（不影响使用）</p><p>安装完毕插件后，在你的hexo配置文件<code>_config.yml</code>中添加如下内容，指定站点地图的文件名字即可。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 百度和谷歌的sitemap</span></span><br><span class="line"><span class="comment"># npm install hexo-generator-baidu-sitemap --save</span></span><br><span class="line"><span class="comment"># npm install hexo-generator-sitemap --save</span></span><br><span class="line"><span class="attr">baidusitemap:</span></span><br><span class="line">    <span class="attr">path:</span> <span class="string">baidusitemap.xml</span></span><br><span class="line"><span class="attr">sitemap:</span></span><br><span class="line">    <span class="attr">path:</span> <span class="string">sitemap.xml</span></span><br></pre></td></tr></table></figure><p>请注意，需要修改的是hexo的配置文件，并非主题配置文件！</p><h1 id="2-如何修改hexo主题生成的index-html文件？"><a href="#2-如何修改hexo主题生成的index-html文件？" class="headerlink" title="2.如何修改hexo主题生成的index.html文件？"></a>2.如何修改hexo主题生成的index.html文件？</h1><p>一般情况下，站点平台都会让你在<code>index.html</code>的<code>&lt;head&gt;</code>里面加一个html语句，来验证站点的所有权。比图百度的验证html语句如下</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;baidu-site-verification&quot;</span> <span class="attr">content</span>=<span class="string">&quot;验证码&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure><p>部分hexo主题可能提供了自定义<code>&lt;head&gt;</code>的选项（比如butterfly主题就有）</p><p>如果你使用的主题没有提供自定义<code>&lt;head&gt;</code>，可以尝试在主题文件夹下搜索index或者head关键字，来找到当前主题使用的<code>index.html</code>生成源文件</p><blockquote><p>该方法<strong>仅</strong>适用于将主题文件直接下载到<code>themes</code>文件夹下的情况，因为如果你用的是npm安装的主题，那么修改的主题文件是不会对其他地方的部署生效的，下一次更新主题还会覆盖掉。</p></blockquote><p>比如下图是keep主题<code>v3.6.1</code>版本中的<code>head.ejs</code>，你只需要把提供的meta标签加到这里面，下一次部署的时候的<code>index.html</code>中就会带上这个标头了。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">themes\keep\layout\_partial\head.ejs</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2023/12/c5c020be0607437acbd2d4364edd839b.png" alt="image-20231208205004240"></p><h1 id="3-站长平台添加sitemap"><a href="#3-站长平台添加sitemap" class="headerlink" title="3.站长平台添加sitemap"></a>3.站长平台添加sitemap</h1><h2 id="百度"><a href="#百度" class="headerlink" title="百度"></a>百度</h2><p>百度资源搜索平台 <a href="https://ziyuan.baidu.com/site/index#/">https://ziyuan.baidu.com/site/index#/</a></p><p>百度实在是无语，之前安装了<code>hexo-baidu-url-submit</code>插件，主动调用百度api给他推送url，结果弄了已经快一年了，还没有收录我的站点。</p><blockquote><p>实话说，百度不收录站点，网站看的人就很少。百度我自己博客的关键词，结果是一堆被百度收录的爬虫站点用我的文章赚流量。唉……</p></blockquote><p>在资源搜索平台的站点管理中添加你的站点，用第二点提到的方式进行验证</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2023/12/f5049ad4122b226e6621e3f77bbca406.png" alt="image-20231208205611557"></p><p>添加完毕后，在普通收录中可以找到sitemap提交的区域。但是不知道为什么我这里的提交配额是0，搜索了一下也没有找到原因。</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2023/12/f1271309829d10b946af8dc1834d6530.png" alt="image-20231208205652153"></p><p><a href="https://zmingcx.com/baidu-linksubmit-sitemap.html">百度资源平台提交sitemap是取消了还是我被限制了？</a></p><p>有人说是站点质量太低被百度屏蔽了，但是这个情况也是很多人都遇到过的。估计是百度策略更新什么的，不允许你添加了吧！</p><p>如果你已经添加了sitemap，请不要将其删除，免得到时候又没有办法添加了。</p><h2 id="bing"><a href="#bing" class="headerlink" title="bing"></a>bing</h2><p>bing的站长平台直接搜就行：<a href="https://www.bing.com/webmasters/about?setlang=zh-cn">https://www.bing.com/webmasters/about?setlang=zh-cn</a></p><blockquote><p>国内裸连可能不稳定，需要用点方法。</p><p>不过bing即便不提交sitemap也咔咔收录了我的博客，主打一个主动+来者不拒。</p></blockquote><p>进去之后，用微软账户登录，然后点击新增站点，<strong>输入你博客的域名</strong></p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2023/12/46eaebbcbe275e5719c48c0fa212d482.png" alt="image-20231208203803163"></p><p>bing会让你验证站点所有权，根据下面三种方式的指引，选择一种就行了。如果你不知道如何修改hexo的源文件，使用<strong>CNAME验证</strong>方式是最简单的（只要你有域名有权就行了）。</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2023/12/6decdf248d463e8dcf22c1408d1521a8.png" alt="image-20231208204120311"></p><p>不过估计有很多老哥都是白嫖的github pages或者netlify&#x2F;vercel的<strong>二级域名</strong>，在没有域名所有权的情况下，你可以用前两种方式来验证。</p><ul><li>XML文件方式：将bing提供的XML文件下载，然后放到你hexo源目录的<strong>source</strong>文件夹下，就可以了。</li><li>HTML MATE标记验证：部分hexo主题可能提供了自定义header的选项（比如butterfly主题就有）其他主题可以参考上文第二点操作</li></ul><p>域名验证完毕后，在左侧可以提交网站地图（即sidemap）</p><p>直接点击按钮提交你的站点地图的url就可以了。bing会自动进行处理，如下图我的第一个sitemap已经成功处理出来了383个链接，非常完美。</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2023/12/24f236053b3ebece4028124e987e6c65.png" alt="image-20231208204707769"></p><h2 id="谷歌"><a href="#谷歌" class="headerlink" title="谷歌"></a>谷歌</h2><p>实话说，一个纯中文且面向国内读者的站点，在谷歌上面收录了估计也没多大用处，但是可以没用，但不能没有。也给他弄一下吧。</p><p><a href="https://search.google.com/search-console/welcome">https://search.google.com/search-console/welcome</a></p><p>首先是输入站点网址，因为我不需要验证所有站点，只把博客收录了就行，所以这里我选的是网址前缀。输入站点的时候需要把http也带上</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2023/12/940d735d204146063e8cb6de8db30326.png" alt="image-20231208210159103"></p><p>谷歌的验证方式也有很多种，这里的操作和bing是一样的，把它发给你的文件直接放到hexo的source路径下就可以了，或者采用html标签的方式验证。</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2023/12/6b7aef8d762ec3127bf418fba2257ff7.png" alt="image-20231208210317624"></p><p>验证成功后，选择前往资源界面，即前往当前站点的控制台。</p><p>如果你不小心点了完成，站点资源界面在站长工具的<strong>左侧边栏</strong>里面，在里面可以找到你已经添加了的站点。</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2023/12/2b62fc8c0f4a83a969894d7a97f13007.png" alt="image-20231208210604314"></p><p>在左侧选择站点地图，点击添加即可</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2023/12/f8159f7211dc0f12fc854ae74476f2f8.png" alt="image-20231208210802621"></p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2023/12/d57012975919635230b6bd8f57e9871b.png" alt="image-20231208210849226"></p><h1 id="搞定！"><a href="#搞定！" class="headerlink" title="搞定！"></a>搞定！</h1><p>有什么问题，欢迎评论区提出！</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;最近没事找事，又看了会关于博客主题的东西，之前的sitemap一直没有弄上去，现在有时间就弄一下。&lt;/p&gt;
&lt;h1 id=&quot;1-hexo安装sitemap插件&quot;&gt;&lt;a href=&quot;#1-hexo安装sitemap插件&quot; class=&quot;headerlink&quot; title=&quot;1</summary>
      
    
    
    
    <category term="差生文具多" scheme="https://blog.musnow.top/categories/%E5%B7%AE%E7%94%9F%E6%96%87%E5%85%B7%E5%A4%9A/"/>
    
    
    <category term="Hexo" scheme="https://blog.musnow.top/tags/Hexo/"/>
    
  </entry>
  
  <entry>
    <title>【Linux】lcov2.0安装和perl修改镜像源</title>
    <link href="https://blog.musnow.top/posts/1274282021/"/>
    <id>https://blog.musnow.top/posts/1274282021/</id>
    <published>2023-11-26T12:12:55.000Z</published>
    <updated>2023-11-26T12:12:55.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="安装lcov-2-0"><a href="#安装lcov-2-0" class="headerlink" title="安装lcov 2.0"></a>安装lcov 2.0</h1><p>你可能不知道lcov是什么，简而言之，它是一个代码单元测试覆盖率的显示工具，基于gcov。</p><ul><li>什么是单元测试覆盖率？</li></ul><p>我们需要对项目中的每个函数编写单元测试，其实就是测试函数的功能。通过gcc&#x2F;g++的相关编译选项，可以得到一个gcda文件，内部包含某个cpp文件中相关函数被执行了多少次，以及某些if&#x2F;switch中的多分支是否覆盖上了；</p><p>lcov就可以解析这些gcda文件，得到如下图所示的函数<strong>测试覆盖率</strong>的报告</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2023/11/6115958c076400afbfaf6ace5c1e89b9.png" alt="image-20231126201406666"></p><p>包括单元测试在内，这部分对代码函数测试的操作一般被称之为<code>功能安全</code>，这里就不多说了。</p><p>lcov 2.0的安装命令相对来说很简单，就是下面这些</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">wget https://github.com/linux-test-project/lcov/releases/download/v2.0/lcov-2.0.tar.gz</span><br><span class="line">tar -zxvf lcov-2.0.tar.gz</span><br><span class="line"><span class="built_in">cd</span> lcov-2.0</span><br><span class="line">sudo make install</span><br></pre></td></tr></table></figure><h1 id="perl"><a href="#perl" class="headerlink" title="perl"></a>perl</h1><p>使用lcov的时候需要perl，此时就需要修改镜像源。默认的perl module的源是在国外的，国内基本上是完全用不了。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># centos8 安装perl</span></span><br><span class="line">sudo yum install perl</span><br></pre></td></tr></table></figure><p>如果你的lcov运行的时候遇到下面类似的错误，那么就是因为perl缺少对应module导致的，比如如下报错是因为缺少<code>Capture::Tiny</code>这个module；</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Can&#x27;t locate Capture/Tiny.pm in @INC (you may need to install the Capture::Tiny module) (@INC contains: /usr/local/lib/lcov /usr/local/lib64/perl5 /usr/local/share/perl5 /usr/lib64/perl5/vendor_perl /usr/share/perl5/vendor_perl /usr/lib64/perl5 /usr/share/perl5) at /usr/local/lib/lcov/lcovutil.pm line 14.</span><br><span class="line">BEGIN failed--compilation aborted at /usr/local/lib/lcov/lcovutil.pm line 14.</span><br><span class="line">Compilation failed in require at /usr/local/bin/lcov line 102.</span><br><span class="line">BEGIN failed--compilation aborted at /usr/local/bin/lcov line 102.</span><br><span class="line">make: *** [makefile:6: lcov] Error 2</span><br></pre></td></tr></table></figure><h2 id="perl使用清华源"><a href="#perl使用清华源" class="headerlink" title="perl使用清华源"></a>perl使用清华源</h2><p>使用清华源就行了 <a href="https://mirrors.tuna.tsinghua.edu.cn/help/CPAN/">https://mirrors.tuna.tsinghua.edu.cn/help/CPAN/</a></p><p>因为我用的centos的系统，安装的perl版本很老，<code>v5.26.3</code>，所以这里记录一个手动修改镜像源的办法</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">perl --version</span><br></pre></td></tr></table></figure><p>在root用户下执行如下命令，会进入一个perl的命令行</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">perl -MCPAN -e shell</span><br></pre></td></tr></table></figure><p>在perl的命令行中执行如下命令</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">o conf init</span><br></pre></td></tr></table></figure><p>最终展现的结果应该如下，会自动往当前用户的家目录下创建一个配置文件</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2023/11/fdfb49a8a83aa12789080503070a9a7a.png" alt="image-20231126200126012"></p><p>这里创建的配置文件是在root用户下，输入<code>quit</code>退出perl的命令行后，我们直接vim打开这个配置文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim /root/.cpan/CPAN/MyConfig.pm</span><br></pre></td></tr></table></figure><p>在里面找到urllist选项，根据已有格式添加一个新的镜像路径就可以了</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2023/11/0f2b4af79a73a2f95bb6f6de6b17560b.png" alt="image-20231126200230352"></p><p>我这里添加后的urllist配置项如下，第一项是镜像源就OK</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#x27;urllist&#x27; =&gt; [q[https://mirrors.tuna.tsinghua.edu.cn/CPAN/], q[http://www.cpan.org/]],</span><br></pre></td></tr></table></figure><p>但是要注意一下，在我这边的网络环境中，清华源在perl安装包的时候也容易抽风，我试出来比较稳定的ip如下，将其写入<code>/etc/hosts</code>文件中，这样安装perl包的时候就不会timeout了</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">101.6.15.130 mirrors.tuna.tsinghua.edu.cn</span><br></pre></td></tr></table></figure><p>这个ip后续可能会有变化啊，请以你的实际情况为准！</p><h2 id="perl安装module"><a href="#perl安装module" class="headerlink" title="perl安装module"></a>perl安装module</h2><p>后续安装包的时候，就可以用上镜像源了，安装包的语句如下，请注意这个安装语句最后还有个英文的单引号，一定不要把他删了！</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo perl -MCPAN -e <span class="string">&#x27;install &quot;包名&quot;&#x27;</span></span><br></pre></td></tr></table></figure><p>我需要用perl是因为要用到lcov，在lcov仓库的readme里面提到了lcov需要的perl包，一个一个安装就行了（以下节选自<code>lcov2.0</code>的仓库README）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">These perl packages include:</span><br><span class="line"></span><br><span class="line">  - Capture::Tiny</span><br><span class="line">  - DateTime</span><br><span class="line">  - Devel::Cover</span><br><span class="line">  - Digest::MD5</span><br><span class="line">  - File::Spec</span><br><span class="line">  - at least one flavor of JSON module.</span><br><span class="line">    In order of performance/preference:</span><br><span class="line">       - JSON::XS</span><br><span class="line">       - Cpanel::JSON::XS</span><br><span class="line">       - JSON::PP</span><br><span class="line">       - JSON</span><br><span class="line"> - Memory::Process</span><br><span class="line"> - Module::Load::Conditional</span><br><span class="line"> - Scalar::Util</span><br><span class="line"> - Time::HiRes</span><br><span class="line"></span><br><span class="line">If your system is missing any of these, then you may be able to install them</span><br><span class="line">via:</span><br><span class="line"></span><br><span class="line">   $ perl -MCPAN -e &#x27;install &quot;packageName&quot;&#x27;</span><br></pre></td></tr></table></figure><p>比如我需要安装<code>Capture::Tiny</code>包，就用如下命令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo perl -MCPAN -e <span class="string">&#x27;install &quot;Capture::Tiny&quot;&#x27;</span></span><br></pre></td></tr></table></figure><p>正常安装的命令输出结果如下图所示</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2023/11/566a4438035e393943d353c48b016149.png" alt="image-20231126201023622"></p><h2 id="ubuntu安装perl-module"><a href="#ubuntu安装perl-module" class="headerlink" title="ubuntu安装perl module"></a>ubuntu安装perl module</h2><p>如果是ubuntu，安装perl的包会方便一点，因为apt源里面是有perl的module</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># ubuntu 22.04 可以直接安装下面的依赖项，就可以使用lcov 2.0了</span></span><br><span class="line">sudo apt install -y perl libcapture-tiny-perl libdatetime-perl</span><br></pre></td></tr></table></figure><p>你可以根据perl的包名中的<strong>关键字</strong>，尝试在<code>apt list</code>里面找找有没有对应的包</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt list | grep 包名</span><br></pre></td></tr></table></figure><h1 id="使用lcov"><a href="#使用lcov" class="headerlink" title="使用lcov"></a>使用lcov</h1><p>对于lcov2.0的命令使用，可以参考我的linux仓库中的测试</p><p><a href="https://gitee.com/musnows/raspberry-practice/tree/master/lcov_test">https://gitee.com/musnows/raspberry-practice/tree/master/lcov_test</a></p>]]></content>
    
    
    <summary type="html">lcov2.0安装和perl修改镜像源</summary>
    
    
    
    <category term="玩上Linux" scheme="https://blog.musnow.top/categories/%E7%8E%A9%E4%B8%8ALinux/"/>
    
    
    <category term="Linux" scheme="https://blog.musnow.top/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>【C++】空对象指针也能访问成员函数？</title>
    <link href="https://blog.musnow.top/posts/3858168549/"/>
    <id>https://blog.musnow.top/posts/3858168549/</id>
    <published>2023-11-16T08:40:46.000Z</published>
    <updated>2023-11-16T08:40:46.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-起因"><a href="#1-起因" class="headerlink" title="1.起因"></a>1.起因</h1><p>今天写代码的时候遇到一个bug，一个类中的set函数在设置一个POD类型的时候出现了异常，直接段错误退出了。</p><blockquote><p>小tips，POD类型指的是内置类型。</p></blockquote><p>想了好久，都没发现这里的问题到底是因为什么。后来才知道，原来空的对象指针，也能被解引用访问到函数！</p><h1 id="2-示例"><a href="#2-示例" class="headerlink" title="2.示例"></a>2.示例</h1><p>下面是关于这个情况的示例代码</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">mytest</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">mytest</span>() = <span class="keyword">default</span>;</span><br><span class="line">    <span class="built_in">mytest</span>(<span class="type">int</span> a):_a(<span class="number">0</span>)&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">set_int</span><span class="params">(<span class="type">int</span> a)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;set int to &quot;</span> &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">        _a = a;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(<span class="type">int</span> a)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;just a print&quot;</span> &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> _a = <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    mytest* ptr = <span class="literal">nullptr</span>;</span><br><span class="line">    ptr-&gt;<span class="built_in">print</span>(<span class="number">20</span>);</span><br><span class="line">    ptr-&gt;<span class="built_in">set_int</span>(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行这个程序，会出现段错误。但你会发现这个段错误并不是因为我们的<code>ptr-&gt;</code> 里面出现的，而是成功进入了set_int函数，执行了打印，最终对成员变量<code>_a</code>赋值的时候出现的！</p><p>对象指针为空，代表压根不存在一个实际的对象，也没办法对不存在的成员变量操作。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt; ./test</span><br><span class="line">just a print20</span><br><span class="line">set int to 10</span><br><span class="line">[1]    280362 segmentation fault  ./test</span><br></pre></td></tr></table></figure><p>当代码很多的时候，就会因为忽略这个特性（其实我当时是压根不知道）而误以为错误出现在set_int函数中。</p><p>没有想到是外层的对象指针为空导致的。</p><h1 id="3-为什么？"><a href="#3-为什么？" class="headerlink" title="3.为什么？"></a>3.为什么？</h1><p>在编译过程中，对象就已经绑定了函数地址。一个类的所有对象，使用的函数地址都是一样的。当编译<code>ptr-&gt;set_int(10)</code> 的时候，函数的地址就已经和这个指针绑定了，调用它等价于直接调用 set_int 函数。</p><p>如果这个函数中没有需要用到成员变量的地方，也就不需要解引用this指针，是不会出错的。比如上方代码中的print函数，就没有出现异常。</p><p>但如果函数内访问了内置成员，那么就会出现解引用空指针导致的段错误！</p>]]></content>
    
    
    <summary type="html">真没想到，空对象指针也能访问成员函数啊？</summary>
    
    
    
    <category term="遇见C++" scheme="https://blog.musnow.top/categories/%E9%81%87%E8%A7%81C/"/>
    
    
    <category term="Cpp" scheme="https://blog.musnow.top/tags/Cpp/"/>
    
    <category term="数据结构" scheme="https://blog.musnow.top/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>【面经】C++面筋记录 (一) 231021</title>
    <link href="https://blog.musnow.top/posts/721187015/"/>
    <id>https://blog.musnow.top/posts/721187015/</id>
    <published>2023-10-21T10:50:14.000Z</published>
    <updated>2023-10-21T10:50:14.000Z</updated>
    
    <content type="html"><![CDATA[<p>记录部分从牛客网上看到的面筋</p><span id="more"></span><h1 id="1-声明一个vector，当vector过大时会栈溢出吗？"><a href="#1-声明一个vector，当vector过大时会栈溢出吗？" class="headerlink" title="1.声明一个vector，当vector过大时会栈溢出吗？"></a>1.声明一个vector，当vector过大时会栈溢出吗？</h1><p>答案是会。</p><p>默认申请的vector是放在栈区的，栈区的大小&lt;&lt;堆区的大小。所以如果我们在栈区中开辟的vector中插入巨量的数据，是会导致栈溢出的。</p><p>解决办法是将数据存放到堆区上（使用new来创建vector，而不是直接创建）</p><h1 id="2-如何实现多次运行程序但只有一个后台进程？"><a href="#2-如何实现多次运行程序但只有一个后台进程？" class="headerlink" title="2.如何实现多次运行程序但只有一个后台进程？"></a>2.如何实现多次运行程序但只有一个后台进程？</h1><p>使用命名互斥锁，程序启动前申请锁。</p><ul><li>如果锁没有被申请，代表是第一个进程，可以正常运行</li><li>如果锁已经被占用，代表已经有进程了，直接退出当前进程（这里要使用try_lock避免阻塞等待）</li></ul><p>在Linux下可以用命名信号量来实现类似进程共享锁的操作。这部分可以去学习进程通信中信号量的部分。</p><p>咨询了发这篇面筋的大佬，说是用文件保存之前进程的PID，读取出来将之前的进程kill掉。</p><h1 id="3-二分法的前提是什么？"><a href="#3-二分法的前提是什么？" class="headerlink" title="3.二分法的前提是什么？"></a>3.二分法的前提是什么？</h1><ul><li>数据有序</li><li>数据结构支持随机访问</li></ul><h1 id="4-互斥锁和自旋锁有什么区别"><a href="#4-互斥锁和自旋锁有什么区别" class="headerlink" title="4.互斥锁和自旋锁有什么区别"></a>4.互斥锁和自旋锁有什么区别</h1><ul><li>互斥锁是在内核态进行阻塞等待</li><li>自旋锁是在用户态不断循环沦陷检测锁的状态</li></ul><p>如果使用场景是较长运行的共享资源，那么就使用互斥锁。避免自旋锁不断沦陷检测消耗大量CPU资源。</p><p>如果使用场景的共享资源访问速度快，那么可以使用自旋锁。避免互斥锁频繁进行用户、内核态的转换而造成消耗（这里指其他需要获取锁的进程得进入内核态阻塞等待）</p><h1 id="5-TCP三次握手除了序列号还发了什么其他东西？"><a href="#5-TCP三次握手除了序列号还发了什么其他东西？" class="headerlink" title="5.TCP三次握手除了序列号还发了什么其他东西？"></a>5.TCP三次握手除了序列号还发了什么其他东西？</h1><ul><li>SYN和ACK这些表记位（具体复习三次握手每个阶段的发送）</li><li>双方服务进程的端口号</li><li>起始序列号和对对方发送的SYN报文的应答序列号</li><li>TCP校验和</li><li>TCP窗口大小</li></ul><p>后续建立连接后，就会根据双方的窗口大小和数据的序列号开始相互通信。</p><h1 id="6-子类重写父类函数，子类中该函数声明为private，能否重写成功？"><a href="#6-子类重写父类函数，子类中该函数声明为private，能否重写成功？" class="headerlink" title="6.子类重写父类函数，子类中该函数声明为private，能否重写成功？"></a>6.子类重写父类函数，子类中该函数声明为private，能否重写成功？</h1><p>用下面这个毛坯房来进行测试，在默认情况下，我们子类的重写函数都和父类有相同的作用域声明符。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">test</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">foo1</span>();</span><br><span class="line"><span class="built_in">foo2</span>();</span><br><span class="line"><span class="built_in">foo3</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">foo1</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;A::foo1&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">foo2</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;A::foo2&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">foo3</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;A::foo3&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> : <span class="keyword">public</span> A</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">foo1</span>();</span><br><span class="line"><span class="built_in">foo2</span>();</span><br><span class="line"><span class="built_in">foo3</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">foo1</span><span class="params">()</span> <span class="keyword">override</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;B::foo1&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">foo2</span><span class="params">()</span> <span class="keyword">override</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;B::foo2&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">foo3</span><span class="params">()</span> <span class="keyword">override</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;B::foo3&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">B b;</span><br><span class="line">b.<span class="built_in">test</span>();</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;----&quot;</span> &lt;&lt; endl;</span><br><span class="line">A *bb = &amp;b;</span><br><span class="line">bb-&gt;<span class="built_in">test</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>直接运行，结果也符合预期，目前调用的是子类重写后的虚函数，所有函数都重写成功。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">B::foo1</span><br><span class="line">B::foo2</span><br><span class="line">B::foo3</span><br><span class="line">----</span><br><span class="line">B::foo1</span><br><span class="line">B::foo2</span><br><span class="line">B::foo3</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> : <span class="keyword">public</span> A</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">foo1</span>();</span><br><span class="line"><span class="built_in">foo2</span>();</span><br><span class="line"><span class="built_in">foo3</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">foo2</span><span class="params">()</span> <span class="keyword">override</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;B::foo2&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">foo3</span><span class="params">()</span> <span class="keyword">override</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;B::foo3&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">foo1</span><span class="params">()</span> <span class="keyword">override</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;B::foo1&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 编译能通过，运行输出和上方没区别</span></span><br></pre></td></tr></table></figure><p>我尝试了各种修改作用域的方式，包括将子类中foo3函数改成公有，foo1函数改成私有，都能正常完成重写。这里的作用域声明符只是会改变<strong>子类外是否能调用这个函数</strong>，和能否完成虚函数重写无关！</p><p>请注意，如果你将<strong>继承方式由public改成private</strong>，那么就无法在类外使用父类指针指向子类对象了</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">╰─ g++ test2.cpp -o test</span><br><span class="line">test2.cpp: In function ‘int main()’:</span><br><span class="line">test2.cpp:316:11: error: ‘A’ is an inaccessible base of ‘B’</span><br><span class="line">  A *bb = &amp;b;</span><br></pre></td></tr></table></figure><p>但这依旧不影响子类函数重写父类函数（我的依据是override关键字没有报错）</p><h1 id="7-pthread-create能传入类成员函数的指针吗"><a href="#7-pthread-create能传入类成员函数的指针吗" class="headerlink" title="7.pthread_create能传入类成员函数的指针吗"></a>7.pthread_create能传入类成员函数的指针吗</h1><p>可以，但是必须是静态成员函数。</p><p>如果是普通成员函数，那就需要用中间函数来处理，比如下面的示例代码。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span>* <span class="title">threadFunc</span><span class="params">(<span class="type">void</span>* arg)</span> </span>&#123;</span><br><span class="line">    std::function&lt;<span class="type">void</span>()&gt; func = *<span class="keyword">reinterpret_cast</span>&lt;std::function&lt;<span class="built_in">void</span>()&gt;*&gt;(arg);</span><br><span class="line">    <span class="built_in">func</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::function&lt;<span class="type">void</span>()&gt; myFunc = []() &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Hello from thread!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="type">pthread_t</span> thread;</span><br><span class="line">    <span class="built_in">pthread_create</span>(&amp;thread, <span class="literal">nullptr</span>, &amp;threadFunc, <span class="built_in">reinterpret_cast</span>&lt;<span class="type">void</span>*&gt;(&amp;myFunc));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 等待线程结束</span></span><br><span class="line">    <span class="built_in">pthread_join</span>(thread, <span class="literal">nullptr</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们可以用<code>std::function</code>包装一个类的成员函数，并用<code>std::bind</code>将对象的this指针绑定到第一个参数上。外层再套上一个用于执行该函数的void函数，就能传给<code>pthread_create</code>。</p><p><code>std::function</code>的对象不能直接传给C语言的函数指针，即便参数对应。会报错。</p><h1 id="8-函数内static变量的作用"><a href="#8-函数内static变量的作用" class="headerlink" title="8.函数内static变量的作用"></a>8.函数内static变量的作用</h1><p>在函数内定义一个static变量，该变量只会在进入这个函数的时候初始化一次。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 计算某一月的1号是一年的第几天(不考虑闰年)</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">DayOfYear</span><span class="params">(<span class="type">int</span> month)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> day_array = &#123;<span class="number">0</span>,<span class="number">31</span>,<span class="number">59</span>,<span class="number">90</span>,<span class="number">120</span>,<span class="number">151</span>,<span class="number">181</span>,<span class="number">212</span>,<span class="number">243</span>,<span class="number">273</span>,<span class="number">304</span>,<span class="number">334</span>&#125;;</span><br><span class="line">    <span class="keyword">return</span> day_array[month];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>比如上面的函数，我们定义的day数组就只会在第一次进入这个函数的时候初始化。之后进入这个函数将不在初始化，就节省了初始化一个数组的消耗。出了这个函数后，该数组变量依旧存在。</p><p>请注意，这个static语句并不只是变量只初始化一次，实际上这一行语句在该函数中都只会进行一次</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="title function_">checkFlag</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">static</span> <span class="type">bool</span> flag = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span>(!flag)&#123;</span><br><span class="line">        <span class="comment">// ..进行对应修改</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>比如上面的代码中，如果用正常思维来理解，你会觉得这个if语句每次都会判断为真而进入其中。但实际上flag的定义只会被定义一次，<strong>只要我们在if中将其改成了true</strong>，那么下一次进入该函数的时候，<strong>flag依旧会是true</strong>，<code>static bool flag = false;</code>语句会被直接跳过，并不会再次执行赋值！</p><p>我之前理解的就是flag变量只会被创建一次，但static后的赋值依旧会执行。这个理解是<strong>错误</strong>的！</p><h1 id="9-私有static成员函数的意义？"><a href="#9-私有static成员函数的意义？" class="headerlink" title="9.私有static成员函数的意义？"></a>9.私有static成员函数的意义？</h1><p>这个问题比较有意思，我们知道static函数属于整个类，可以直接通过类名作用域调用。且static函数中无法访问任何非static的成员变量。</p><p>但是，如果给你个static的私有成员函数，它又有什么意义呢？</p><ul><li>私有static成员是无法通过类名调用的</li><li>他也没有办法访问类中非static成员变量</li></ul><p>可以这么理解：我有一个方法只在这个类里面需要，这个方法不需要使用成员变量，可以通过传参实现（比如计算什么的）</p><p>但是，我又不想它的命名污染父作用域。</p><p>那么，我就可以把它写为类的私有成员函数，并加上static告诉其他人，这个函数是一个单纯的方法类，不需要使用类的成员变量。</p><p>当然，加上static只是一个编程习惯罢了，实际上这种情况不写static也无所谓。</p>]]></content>
    
    
    <summary type="html">C++面筋记录 (一) 231021</summary>
    
    
    
    <category term="求职路上一去不复返" scheme="https://blog.musnow.top/categories/%E6%B1%82%E8%81%8C%E8%B7%AF%E4%B8%8A%E4%B8%80%E5%8E%BB%E4%B8%8D%E5%A4%8D%E8%BF%94/"/>
    
    
    <category term="面经" scheme="https://blog.musnow.top/tags/%E9%9D%A2%E7%BB%8F/"/>
    
  </entry>
  
  <entry>
    <title>【Linux】wsl安装的ubuntu不支持POSIX消息队列 | 已解决</title>
    <link href="https://blog.musnow.top/posts/4006913293/"/>
    <id>https://blog.musnow.top/posts/4006913293/</id>
    <published>2023-10-17T04:30:55.000Z</published>
    <updated>2023-10-17T04:30:55.000Z</updated>
    
    <content type="html"><![CDATA[<p>wsl安装的ubuntu不支持POSIX消息队列的解决办法</p><span id="more"></span><h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2023/10/f317c38d511b44a48ff5dc5df48b1c80.png"></p><p>如题，我的win10上安装了wsl的ubuntu后（微软商店下载的wsl的Ubuntu）这个系统内部不支持POSIX的消息队列，虽然有<code>&lt;mqueue.h&gt;</code>头文件，但是没有实现，会报错。</p><p>如果想找个简单的办法呢，那就是用systemV的消息队列，可这是个<strong>虚拟机本地环境问题</strong>，我用virtualbox安装的虚拟机就能正常使用。所以肯定得解决这个问题，换成systemV的消息队列就有点「掩耳盗铃」的意味了。</p><h1 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h1><p>下面是一个POSIX消息队列的demo</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mqueue.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">mqd_t</span> mqID;</span><br><span class="line">    mqID = <span class="built_in">mq_open</span>(<span class="string">&quot;/testmQueue&quot;</span>, O_RDWR | O_CREAT, <span class="number">0666</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (mqID &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;open message queue error...&quot;</span>&lt;&lt;<span class="built_in">strerror</span>(errno)&lt;&lt;endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mq_attr mqAttr;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">mq_getattr</span>(mqID, &amp;mqAttr) &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;get the message queue attribute error&quot;</span>&lt;&lt;endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;mq_flags:&quot;</span>&lt;&lt;mqAttr.mq_flags&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;mq_maxmsg:&quot;</span>&lt;&lt;mqAttr.mq_maxmsg&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;mq_msgsize:&quot;</span>&lt;&lt;mqAttr.mq_msgsize&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;mq_curmsgs:&quot;</span>&lt;&lt;mqAttr.mq_curmsgs&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果编译后运行出现了下面的报错，代表当前系统不支持POSIX消息队列。当前系统下有mqueue头文件，但并没有函数的实现体</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">root@DESKTOP-5SQO6N0:~# ./test</span><br><span class="line">open message queue error...No such file or directory</span><br><span class="line">open message queue error...Function not implemented</span><br></pre></td></tr></table></figure><h1 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h1><p>需要将wsl版本1改成版本2，否则无完整Linux内核支持，无法使用POSIX消息队列。<strong>这也是WSL版本1和2的重大区别之一</strong>。</p><p>用如下命令将当前虚拟机改成wsl2版本，就可以使用了。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">wsl -l -v # 用这个命令查看当前虚拟机的version是不是1</span><br><span class="line">wsl --update # 更新wsl</span><br><span class="line">wsl --set-version 虚拟机名 2  # 把指定虚拟机改成wsl版本2</span><br></pre></td></tr></table></figure><h2 id="再次测试"><a href="#再次测试" class="headerlink" title="再次测试"></a>再次测试</h2><p>正常情况下，上面的消息队列代码应该输出如下内容</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">root@DESKTOP-5SQO6N0:~# ./test</span><br><span class="line">mq_flags:0</span><br><span class="line">mq_maxmsg:10</span><br><span class="line">mq_msgsize:8192</span><br><span class="line">mq_curmsgs:0</span><br></pre></td></tr></table></figure><h2 id="绑定目录"><a href="#绑定目录" class="headerlink" title="绑定目录"></a>绑定目录</h2><p>除了上面这个问题，在使用消息队列之前还可以monut一下路径，参考man手册中的教程（似乎不是必须要做的，mount了这个路径之后能更好地看到现有的消息队列）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mkdir /dev/mqueue</span><br><span class="line">mount -t mqueue none /dev/mqueue</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">wsl安装的ubuntu不支持POSIX消息队列的解决办法</summary>
    
    
    
    <category term="玩上Linux" scheme="https://blog.musnow.top/categories/%E7%8E%A9%E4%B8%8ALinux/"/>
    
    
    <category term="Linux" scheme="https://blog.musnow.top/tags/Linux/"/>
    
    <category term="虚拟机" scheme="https://blog.musnow.top/tags/%E8%99%9A%E6%8B%9F%E6%9C%BA/"/>
    
    <category term="wsl" scheme="https://blog.musnow.top/tags/wsl/"/>
    
  </entry>
  
</feed>
