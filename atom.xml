<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>慕雪的寒舍</title>
  
  <subtitle>雪下了一夜</subtitle>
  <link href="https://blog.musnow.top/atom.xml" rel="self"/>
  
  <link href="https://blog.musnow.top/"/>
  <updated>2024-04-18T04:51:59.000Z</updated>
  <id>https://blog.musnow.top/</id>
  
  <author>
    <name>慕雪年华</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>【C语言】static和extern的作用</title>
    <link href="https://blog.musnow.top/posts/3198614716/"/>
    <id>https://blog.musnow.top/posts/3198614716/</id>
    <published>2024-04-18T04:21:36.000Z</published>
    <updated>2024-04-18T04:51:59.000Z</updated>
    
    <content type="html"><![CDATA[<p>简单介绍C&#x2F;C++中static关键字和extern关键字的作用。</p><h1 id="1-简介"><a href="#1-简介" class="headerlink" title="1.简介"></a>1.简介</h1><p>在之前的博客中，提到过static的三个作用，但是没有详细说明这三个作用的场景，现在回过头来记录一下。</p><ol><li>修饰函数</li><li>修饰全局变量</li><li>修饰函数内变量</li></ol><p>在C++的类和对象中，static还多了一个作用，即修饰C++类的成员变量或函数。被修饰的成员属于整个类，可以直接通过类的作用域来访问（前提是公有），这不是本文的重点。</p><h1 id="2-static修饰函数-x2F-变量"><a href="#2-static修饰函数-x2F-变量" class="headerlink" title="2.static修饰函数&#x2F;变量"></a>2.static修饰函数&#x2F;变量</h1><p>对于修饰函数和变量而言，作用基本是一致的，即限制这个函数&#x2F;变量的作用域，让他只对当前文件可见。</p><h2 id="修饰变量"><a href="#修饰变量" class="headerlink" title="修饰变量"></a>修饰变量</h2><p>给定下面两个文件</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// a.cpp</span></span><br><span class="line"><span class="type">int</span> aGlobal = <span class="number">10</span>;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> bGlobal = <span class="number">20</span>;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// b.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 声明文件a.cpp中的全局变量</span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">int</span> aGlobal;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; aGlobal &lt;&lt; endl;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在<code>b.cpp</code>中，使用了extern关键字来声明属于另外一个cpp文件中的全局变量，用如下命令编译成可执行文件test。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">g++ b.cpp a.cpp -o test</span><br></pre></td></tr></table></figure><p>在Ubuntu上进行测试，编译成功，运行能成功打印出10，符合预期。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">❯ g++ a.cpp b.cpp -o test</span><br><span class="line">❯ ./test</span><br><span class="line">10</span><br></pre></td></tr></table></figure><p>而被static修饰过的bGlobal就不能用这种方式被另外一个文件访问了。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// b.cpp 修改后</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 声明文件a.cpp中的全局变量</span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">int</span> bGlobal;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; bGlobal &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用相同的命令进行编译，此时就会报错了。因为static关键字将bGlobal这个全局变量的作用域限制在了<code>a.cpp</code>文件中，其他文件无法访问！</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">❯ g++ a.cpp b.cpp -o test</span><br><span class="line">/usr/bin/ld: /tmp/ccj43Xl9.o: warning: relocation against `bGlobal&#x27; in read-only section `.text&#x27;</span><br><span class="line">/usr/bin/ld: /tmp/ccj43Xl9.o: in function `main&#x27;:</span><br><span class="line">b.cpp:(.text+0xa): undefined reference to `bGlobal&#x27;</span><br><span class="line">/usr/bin/ld: warning: creating DT_TEXTREL in a PIE</span><br><span class="line">collect2: error: ld returned 1 exit status</span><br></pre></td></tr></table></figure><p>这里有个必须要注意的点，我们在<code>b.cpp</code>中并没有<code>#include &quot;a.cpp&quot;</code>，如果添加了include，那么上面的结论就无效了。因为include会在预编译期间被展开，此时<code>a.cpp</code>中的全局变量定义直接被添加在了<code>b.cpp</code>上面，并不属于两个文件的情况。比如下面的代码就可以正常编译通过。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 错误的测试逻辑</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;a.cpp&quot;</span> <span class="comment">// 引用了a.cpp</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 声明文件a.cpp中的全局变量？此时a.cpp都已经被展开了，完全不是另外一个文件了！</span></span><br><span class="line"><span class="comment">// extern int bGlobal; // 这一行加不加没有任何区别</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; bGlobal &lt;&lt; endl;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如下所示，编译成功且打印了bGlobal的值</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">❯ g++ b.cpp -o test</span><br><span class="line">❯ ./test</span><br><span class="line">20</span><br></pre></td></tr></table></figure><p>注意这里编译的时候不能再添加<code>a.cpp</code>了，因为此时已经被展开到了<code>b.cpp</code>之前，如果这样编译就会报错aGlobal重定义。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">❯ g++ a.cpp b.cpp -o test</span><br><span class="line">/usr/bin/ld: /tmp/cckcj9a5.o:(.data+0x0): multiple definition of `aGlobal&#x27;; /tmp/ccsNnuaN.o:(.data+0x0): first defined here</span><br><span class="line">collect2: error: ld returned 1 exit status</span><br></pre></td></tr></table></figure><h2 id="修饰函数"><a href="#修饰函数" class="headerlink" title="修饰函数"></a>修饰函数</h2><p>修饰函数的作用同理，没有修饰的函数可以被另外一个文件extern后调用，修饰后的不可以。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// a.cpp</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Add</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a+b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// b.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 声明文件a.cpp中的函数</span></span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="type">int</span> <span class="title">Add</span><span class="params">(<span class="type">int</span>,<span class="type">int</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="built_in">Add</span>(<span class="number">10</span>,<span class="number">20</span>) &lt;&lt; endl;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译成功，且调用Add函数成功。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">❯ g++ a.cpp b.cpp -o test</span><br><span class="line">❯ ./test</span><br><span class="line">30</span><br></pre></td></tr></table></figure><p>Add函数添加了static后就无法被extern调用了</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">❯ g++ a.cpp b.cpp -o test</span><br><span class="line">/usr/bin/ld: /tmp/ccFe9oSW.o: in function `main&#x27;:</span><br><span class="line">b.cpp:(.text+0x13): undefined reference to `Add(int, int)&#x27;</span><br><span class="line">collect2: error: ld returned 1 exit status</span><br></pre></td></tr></table></figure><h1 id="3-static修饰函数内变量"><a href="#3-static修饰函数内变量" class="headerlink" title="3.static修饰函数内变量"></a>3.static修饰函数内变量</h1><p>你可能见过这样的写法，在函数内定义一个static变量，并作为返回值</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">char</span>* <span class="title">Add</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span></span>&#123;</span><br><span class="line"><span class="type">static</span> <span class="type">char</span> arr[<span class="number">2</span>];</span><br><span class="line">arr[<span class="number">0</span>] = (<span class="type">char</span>)a + <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">arr[<span class="number">1</span>] = (<span class="type">char</span>)b + <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line"><span class="keyword">return</span> arr; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种方式可以避免使用动态内存管理（malloc&#x2F;free）的空间作为返回值，因为那样可能会出现内存泄漏问题。</p><p>使用static修饰函数内的变量后，这个变量的作用域不再是函数体内了，而是扩展到了全局（可以理解为他就是一个全局变量）。</p><p>需要注意的是，<strong>static的这一行定义只会在第一次进入函数的时候执行</strong>，后续不再会执行。比如下面的代码，如果你对static修饰的作用不太了解，你可能会认为isGood这个变量每次进入该函数都会被设置为false，从而只会让他进入if判断体的A区域，搞得这个if判断都没有意义了。</p><p>但实际上，<strong>这个变量只有第一次调用这个函数的时候会被创建且赋值为false</strong>，后续不再会执行static这一行，所以函数体内（A区域和B区域可能会做一些处理再设置isGood变量的值）对isGood值的修改会沿用到下一次调用这个函数！</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">TestFunc</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="type">static</span> <span class="type">bool</span> isGood = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">if</span>(!isGood)&#123;</span><br><span class="line"><span class="comment">// A...</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// B...</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="4-static和编译"><a href="#4-static和编译" class="headerlink" title="4.static和编译"></a>4.static和编译</h1><p>为什么被static修饰的函数&#x2F;变量不会被其他文件看见？</p><p>因为在生成符号表的时候，每一个static变量即便变量名相同，也会<strong>生成不同的符号表项</strong>。所以在链接阶段符号表合并的时候，并不会将两个文件中同名的static变量合并在一起，所以其他文件也就没有办法访问到当前文件中被static修饰的函数&#x2F;变量。</p><p>而extern了一个static变量，<strong>就会因为符号表无法找到，而链接失败</strong>。注意观察G++的报错，都是ld和<code>.o</code>相关字样的，说明这个并不是编译器通过语法检查出来的错误，而是在链接<code>.o</code>目标文件的时候，发现无法链接该变量的时候因为错误而退出编译的。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">❯ g++ a.cpp b.cpp -o test</span><br><span class="line">/usr/bin/ld: /tmp/ccj43Xl9.o: warning: relocation against `bGlobal&#x27; in read-only section `.text&#x27;</span><br><span class="line">/usr/bin/ld: /tmp/ccj43Xl9.o: in function `main&#x27;:</span><br><span class="line">b.cpp:(.text+0xa): undefined reference to `bGlobal&#x27;</span><br><span class="line">/usr/bin/ld: warning: creating DT_TEXTREL in a PIE</span><br><span class="line">collect2: error: ld returned 1 exit status</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">简单介绍C中static关键字和extern关键字的作用。</summary>
    
    
    
    <category term="编程学习" scheme="https://blog.musnow.top/categories/%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="C语言" scheme="https://blog.musnow.top/categories/%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0/C%E8%AF%AD%E8%A8%80/"/>
    
    
    <category term="C语言" scheme="https://blog.musnow.top/tags/C%E8%AF%AD%E8%A8%80/"/>
    
    <category term="Cpp" scheme="https://blog.musnow.top/tags/Cpp/"/>
    
  </entry>
  
  <entry>
    <title>【leetcode】23.合并K个升序链表</title>
    <link href="https://blog.musnow.top/posts/788614935/"/>
    <id>https://blog.musnow.top/posts/788614935/</id>
    <published>2024-04-16T10:36:39.000Z</published>
    <updated>2024-04-17T07:13:29.000Z</updated>
    
    <content type="html"><![CDATA[<p>leetcode刷题笔记-23-合并K个升序链表</p><h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><blockquote><p><a href="https://leetcode.cn/problems/merge-k-sorted-lists/description/">https://leetcode.cn/problems/merge-k-sorted-lists/description/</a></p></blockquote><p>给你一个链表数组，每个链表都已经按升序排列。</p><p>请你将所有链表合并到一个升序链表中，返回合并后的链表。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">示例 1：</span><br><span class="line">输入：lists = [[1,4,5],[1,3,4],[2,6]]</span><br><span class="line">输出：[1,1,2,3,4,4,5,6]</span><br><span class="line">解释：链表数组如下：</span><br><span class="line">[</span><br><span class="line">  1-&gt;4-&gt;5,</span><br><span class="line">  1-&gt;3-&gt;4,</span><br><span class="line">  2-&gt;6</span><br><span class="line">]</span><br><span class="line">将它们合并到一个有序链表中得到。</span><br><span class="line">1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4-&gt;5-&gt;6</span><br><span class="line"></span><br><span class="line">示例 2：</span><br><span class="line">输入：lists = []</span><br><span class="line">输出：[]</span><br><span class="line"></span><br><span class="line">示例 3：</span><br><span class="line">输入：lists = [[]]</span><br><span class="line">输出：[]</span><br></pre></td></tr></table></figure><p>最简单的思路就是用一个数组记录所有链表，再用sort将这个数组重排序，最后连成一个完整的升序链表。</p><h1 id="思路1"><a href="#思路1" class="headerlink" title="思路1"></a>思路1</h1><p>思路1是用小堆来处理。</p><p>因为给出的链表已经是升序的，所以最终的有序链表的头节点，一定是给定的链表中的其中一个的头节点。</p><p>那么第二个节点呢？可能是另外一个链表的头节点，也有可能是当前选中的这个链表的第二个节点。比如下面的例子，第一个节点是2，第二个节点并不是其他链表的头节点，而是这一个链表的第二个节点3。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">10 - 23</span><br><span class="line">5 - 6 </span><br><span class="line">2 - 3 - 7</span><br></pre></td></tr></table></figure><p>所以我们需要用小堆来维护最终的大小关系，首先是遍历给出的链表数组，将所有链表的头节点插入小堆，随后取出堆顶元素，链入最终链表，如果这个节点还有下一个节点，那么就将下一个节点也插入小堆。</p><p>这样才能保证最终的顺序性。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>注意，使用小堆需要用STD提供的<code>priority_queue</code>容器，并自己写一个仿函数来比较两个链表节点的大小。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="comment">// 注意优先级队列的传参是一个仿函数类</span></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">MyCmp</span> &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(ListNode* l, ListNode* r)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> l-&gt;val &gt; r-&gt;val; <span class="comment">// 小堆</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">mergeKLists</span><span class="params">(vector&lt;ListNode*&gt;&amp; lists)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 用最小堆来实现，注意最小堆是大的往上题，cmp中是大于</span></span><br><span class="line">        priority_queue&lt;ListNode*, vector&lt;ListNode*&gt;, MyCmp&gt; que;</span><br><span class="line">        <span class="comment">// 把不为空的链表头节点插入，因为链表本来都是升序的</span></span><br><span class="line">        <span class="comment">// 那么最终的有序链表的第一个节点肯定是某一个链表的头节点</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; i : lists) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">                que.<span class="built_in">push</span>(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 新建一个烧饼节点</span></span><br><span class="line">        ListNode* phead = <span class="keyword">new</span> ListNode;</span><br><span class="line">        ListNode* cur = phead;</span><br><span class="line">        <span class="keyword">while</span> (!que.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="comment">// 取出头节点</span></span><br><span class="line">            ListNode* head = que.<span class="built_in">top</span>();</span><br><span class="line">            que.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="comment">// 如果有下一个节点，插入最小堆</span></span><br><span class="line">            <span class="keyword">if</span> (head-&gt;next != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">                que.<span class="built_in">push</span>(head-&gt;next);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 将其连入链表</span></span><br><span class="line">            cur-&gt;next = head;</span><br><span class="line">            cur = cur-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> phead-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/04/222f9ff8ab3420eed6c464aeb1babcc7.png" alt="image.png"></p><h1 id="思路2"><a href="#思路2" class="headerlink" title="思路2"></a>思路2</h1><p>方法2就是用之前写过的<a href="https://leetcode.cn/problems/merge-two-sorted-lists/description/">21.合并两个有序链表</a>的练习。每次都选中两个链表进行合并，直到最终合并所有链表。</p><p>这里可以采用分治的思路，将链表数组拆分后进行合并。</p><h2 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="function">ListNode* <span class="title">mergeTwoLists</span><span class="params">(ListNode* list1, ListNode* list2)</span> </span>&#123;</span><br><span class="line">        ListNode* head = <span class="keyword">new</span> ListNode;</span><br><span class="line">        ListNode* oldHead = head;</span><br><span class="line">        ListNode *cur1 = list1, *cur2 = list2;</span><br><span class="line">        <span class="keyword">while</span> (cur1 != <span class="literal">nullptr</span> &amp;&amp; cur2 != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (cur1-&gt;val &gt;= cur2-&gt;val) &#123;</span><br><span class="line">                head-&gt;next = cur2;</span><br><span class="line">                head = head-&gt;next;</span><br><span class="line">                cur2 = cur2-&gt;next;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                head-&gt;next = cur1;</span><br><span class="line">                head = head-&gt;next;</span><br><span class="line">                cur1 = cur1-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (cur1 == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            head-&gt;next = cur2;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            head-&gt;next = cur1;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> oldHead-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 合并从 lists[i] 到 lists[j-1] 的链表</span></span><br><span class="line">    <span class="function">ListNode* <span class="title">mergeKLists</span><span class="params">(vector&lt;ListNode*&gt;&amp; lists, <span class="type">int</span> i, <span class="type">int</span> j)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> m = j - i;</span><br><span class="line">        <span class="keyword">if</span> (m == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nullptr</span>; <span class="comment">// 注意输入的 lists 可能是空的</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (m == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> lists[i]; <span class="comment">// 无需合并，直接返回</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">auto</span> left = <span class="built_in">mergeKLists</span>(lists, i, i + m / <span class="number">2</span>);  <span class="comment">// 合并左半部分</span></span><br><span class="line">        <span class="keyword">auto</span> right = <span class="built_in">mergeKLists</span>(lists, i + m / <span class="number">2</span>, j); <span class="comment">// 合并右半部分</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">mergeTwoLists</span>(left, right); <span class="comment">// 最后把左半和右半合并</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">mergeKLists</span><span class="params">(vector&lt;ListNode*&gt;&amp; lists)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">mergeKLists</span>(lists, <span class="number">0</span>, lists.<span class="built_in">size</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">leetcode刷题笔记-23-合并K个升序链表</summary>
    
    
    
    <category term="编程学习" scheme="https://blog.musnow.top/categories/%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="把题目都给刷干净" scheme="https://blog.musnow.top/categories/%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0/%E6%8A%8A%E9%A2%98%E7%9B%AE%E9%83%BD%E7%BB%99%E5%88%B7%E5%B9%B2%E5%87%80/"/>
    
    
    <category term="OJ刷题" scheme="https://blog.musnow.top/tags/OJ%E5%88%B7%E9%A2%98/"/>
    
    <category term="链表" scheme="https://blog.musnow.top/tags/%E9%93%BE%E8%A1%A8/"/>
    
    <category term="堆" scheme="https://blog.musnow.top/tags/%E5%A0%86/"/>
    
    <category term="leetcode" scheme="https://blog.musnow.top/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>【leetcode】2两数相加和989数组数字的相加问题</title>
    <link href="https://blog.musnow.top/posts/1455984707/"/>
    <id>https://blog.musnow.top/posts/1455984707/</id>
    <published>2024-04-14T07:13:00.000Z</published>
    <updated>2024-04-14T07:50:40.000Z</updated>
    
    <content type="html"><![CDATA[<p>leetcode刷题笔记：2和989这类数字一位一位相加的问题</p><h1 id="通用模板"><a href="#通用模板" class="headerlink" title="通用模板"></a>通用模板</h1><p>对于数字一位一位相加的问题，一般就是leetcode第2题链表的形式，和第989题数组的形式。参考leetcode上大佬的题解，会有一个通用的<a href="https://leetcode.cn/problems/add-to-array-form-of-integer/solutions/570659/989-ji-zhu-zhe-ge-jia-fa-mo-ban-miao-sha-8y9r/">加法模板</a>。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">进位carry初始化为0</span><br><span class="line">while ( A 没完 || B 没完 )&#123;</span><br><span class="line">    A 的当前位</span><br><span class="line">    B 的当前位</span><br><span class="line"></span><br><span class="line">    和 = A 的当前位 + B 的当前位 + 进位carry</span><br><span class="line"></span><br><span class="line">    当前位 = 和 % 10;</span><br><span class="line">    进位 = 和 / 10;</span><br><span class="line">&#125;</span><br><span class="line">判断是否还有进位？</span><br></pre></td></tr></table></figure><p>只要依靠这个模板，就能把这两道题很轻松的写出来。</p><h1 id="989-数组形式的整数加法"><a href="#989-数组形式的整数加法" class="headerlink" title="989.数组形式的整数加法"></a>989.数组形式的整数加法</h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><blockquote><p><a href="https://leetcode.cn/problems/add-to-array-form-of-integer/">https://leetcode.cn/problems/add-to-array-form-of-integer/</a></p></blockquote><p>整数的 数组形式  num 是按照从左到右的顺序表示其数字的数组。</p><p>例如，对于 <code>num = 1321</code> ，数组形式是 <code>[1,3,2,1]</code> 。</p><p>给定 num ，整数的 数组形式 ，和整数 k ，返回 整数 num + k 的 数组形式 。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">示例 1：</span><br><span class="line">输入：num = [1,2,0,0], k = 34</span><br><span class="line">输出：[1,2,3,4]</span><br><span class="line">解释：1200 + 34 = 1234</span><br><span class="line"></span><br><span class="line">示例 2：</span><br><span class="line">输入：num = [2,7,4], k = 181</span><br><span class="line">输出：[4,5,5]</span><br><span class="line">解释：274 + 181 = 455</span><br><span class="line"></span><br><span class="line">示例 3：</span><br><span class="line">输入：num = [2,1,5], k = 806</span><br><span class="line">输出：[1,0,2,1]</span><br><span class="line">解释：215 + 806 = 1021</span><br></pre></td></tr></table></figure><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>按上文提供的模板，写这道题是比较容易的，因为数组本身是可以随机访问的，我们从后往前遍历数组，按位与k的当前位相加就可以了。</p><p>注意，使用vector做返回值时，我们应该采用先尾插最后逆置的方式，效率会远高于每次都头插。因为vector的头插涉及到了其他元素的移动。</p><p>当然，你也可以选择链表来进行头插，最终再转成vector返回。</p><p>这里面要注意的是，虽然while的判断条件中已经有了判断，但是两个判断条件是通过<code>||</code>或连接的，可能会出现数组已经结束了，但是k还有位数（或反之）的情况，在操作a和b的时候一定要先进行判断再赋值。</p><p>当然，也可以选择用<code>&amp;&amp;</code>与链接，并在while之后单独处理数组或k剩下的数。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">addToArrayForm</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; num, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; retV;</span><br><span class="line">        <span class="type">int</span> i = num.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> carry = <span class="number">0</span>; <span class="comment">// 进位</span></span><br><span class="line">        <span class="comment">// 有一个不为0就需要继续加</span></span><br><span class="line">        <span class="keyword">while</span> (i &gt;= <span class="number">0</span> || k != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 可能有一个已经结束了，需要判断</span></span><br><span class="line">            <span class="type">int</span> a = i &gt;= <span class="number">0</span> ? num[i] : <span class="number">0</span>;</span><br><span class="line">            <span class="type">int</span> b = k != <span class="number">0</span> ? k % <span class="number">10</span> : <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">            <span class="type">int</span> sum = a + b + carry;</span><br><span class="line">            <span class="type">int</span> cur = sum % <span class="number">10</span>;          <span class="comment">// 当前位</span></span><br><span class="line">            carry = (sum &gt;= <span class="number">10</span>) ? <span class="number">1</span> : <span class="number">0</span>; <span class="comment">// 如果超过10了需要进位</span></span><br><span class="line">            <span class="comment">// 插入数组</span></span><br><span class="line">            retV.<span class="built_in">push_back</span>(cur);</span><br><span class="line">            <span class="comment">// 走下一位去</span></span><br><span class="line">            i--;</span><br><span class="line">            k /= <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 还有进位，需要再插入一个</span></span><br><span class="line">        <span class="keyword">if</span> (carry != <span class="number">0</span>) &#123;</span><br><span class="line">            retV.<span class="built_in">push_back</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 注意，我们插入是尾插（vector头插效率很低），需要逆置</span></span><br><span class="line">        <span class="built_in">reverse</span>(retV.<span class="built_in">begin</span>(), retV.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">return</span> retV;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/04/3dd4d93b32c706b3a81670877ff35a1f.png" alt="image.png"></p><h1 id="2-两数相加"><a href="#2-两数相加" class="headerlink" title="2.两数相加"></a>2.两数相加</h1><blockquote><p><a href="https://leetcode.cn/problems/add-two-numbers/description/">https://leetcode.cn/problems/add-two-numbers/description/</a></p></blockquote><h2 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h2><p>给你两个 非空 的链表，表示两个非负的整数。它们每位数字都是按照 <strong>逆序</strong> 的方式存储的，并且每个节点只能存储 一位 数字。</p><p>请你将两个数相加，并以相同形式返回一个表示和的链表。</p><p>你可以假设除了数字 0 之外，这两个数都不会以 0 开头。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">示例 1：</span><br><span class="line">输入：l1 = [2,4,3], l2 = [5,6,4]</span><br><span class="line">输出：[7,0,8]</span><br><span class="line">解释：342 + 465 = 807.</span><br><span class="line"></span><br><span class="line">示例 2：</span><br><span class="line">输入：l1 = [0], l2 = [0]</span><br><span class="line">输出：[0]</span><br><span class="line"></span><br><span class="line">示例 3：</span><br><span class="line">输入：l1 = [9,9,9,9,9,9,9], l2 = [9,9,9,9]</span><br><span class="line">输出：[8,9,9,9,0,0,0,1]</span><br></pre></td></tr></table></figure><h2 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h2><p>这道题虽然给的是链表，无法随机访问，但是链表是逆序存放的数字，本就符合我们从低位往高位相加的思路。</p><p>基本代码和上文一致，当某个链表结束之后，就将其视作0继续操作。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">addTwoNumbers</span><span class="params">(ListNode* l1, ListNode* l2)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 有一个为空的时候可以直接返回另外一个</span></span><br><span class="line">        <span class="keyword">if</span>(l1 == <span class="literal">nullptr</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> l2;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(l2 == <span class="literal">nullptr</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> l1;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ListNode* phead = <span class="keyword">new</span> ListNode;</span><br><span class="line">        ListNode* cur = phead;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> carry = <span class="number">0</span>; <span class="comment">// 进位制</span></span><br><span class="line">        ListNode* left = l1,*right = l2;</span><br><span class="line">        <span class="comment">// 有一个不为空就需要继续</span></span><br><span class="line">        <span class="keyword">while</span>(left != <span class="literal">nullptr</span> || right !=<span class="literal">nullptr</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> a = left != <span class="literal">nullptr</span>?left-&gt;val:<span class="number">0</span>;</span><br><span class="line">            <span class="type">int</span> b = right != <span class="literal">nullptr</span>?right-&gt;val:<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">            <span class="type">int</span> sum = a+b+carry;</span><br><span class="line">            <span class="type">int</span> val = sum % <span class="number">10</span>; <span class="comment">// 当前值</span></span><br><span class="line">            carry = sum&gt;=<span class="number">10</span>?<span class="number">1</span>:<span class="number">0</span>;</span><br><span class="line">            <span class="comment">// 注意，题目要求的是按相同的方式（数字逆序存放）来返回一个链表</span></span><br><span class="line">            <span class="comment">// 所以我们需要进行尾插操作</span></span><br><span class="line">            cur-&gt;next = <span class="keyword">new</span> <span class="built_in">ListNode</span>(val);</span><br><span class="line">            cur = cur-&gt;next;</span><br><span class="line">            <span class="comment">// 去下一位</span></span><br><span class="line">            <span class="keyword">if</span>(left != <span class="literal">nullptr</span>)&#123;    </span><br><span class="line">                left=left-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(right != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">                right=right-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 还有值，需要再尾插一个。</span></span><br><span class="line">        <span class="keyword">if</span>(carry!=<span class="number">0</span>)&#123;</span><br><span class="line">            cur-&gt;next = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> phead-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>备注：上面的代码中，phead指针出现内存泄漏了，但是写OJ的时候并不关心内存泄漏问题。</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/04/f3c0df34a05e87a15ff126f081a3e91d.png" alt="image.png"></p><h1 id="165-比较版本号"><a href="#165-比较版本号" class="headerlink" title="165.比较版本号"></a>165.比较版本号</h1><h2 id="题目-2"><a href="#题目-2" class="headerlink" title="题目"></a>题目</h2><blockquote><p><a href="https://leetcode.cn/problems/compare-version-numbers/description/">https://leetcode.cn/problems/compare-version-numbers/description/</a></p></blockquote><p>给你两个版本号 version1 和 version2 ，请你比较它们。</p><p>版本号由一个或多个修订号组成，各修订号由一个 <code>&#39;.&#39;</code> 连接。每个修订号由 多位数字 组成，可能包含 前导零 。每个版本号至少包含一个字符。修订号从左到右编号，下标从 0 开始，最左边的修订号下标为 0 ，下一个修订号下标为 1 ，以此类推。例如，<code>2.5.33</code> 和 <code>0.1</code> 都是有效的版本号。</p><p>比较版本号时，请按从左到右的顺序依次比较它们的修订号。比较修订号时，只需比较 忽略任何前导零后的整数值 。也就是说，修订号 1 和修订号 001 相等 。如果版本号没有指定某个下标处的修订号，则该修订号视为 0 。例如，版本 1.0 小于版本 1.1 ，因为它们下标为 0 的修订号相同，而下标为 1 的修订号分别为 0 和 1 ，0 &lt; 1 。</p><p>返回规则如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">如果 version1 &gt; version2 返回 1，</span><br><span class="line">如果 version1 &lt; version2 返回 -1，</span><br><span class="line">除此之外返回 0。</span><br></pre></td></tr></table></figure><p>示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">示例 1：</span><br><span class="line">输入：version1 = &quot;1.01&quot;, version2 = &quot;1.001&quot;</span><br><span class="line">输出：0</span><br><span class="line">解释：忽略前导零，&quot;01&quot; 和 &quot;001&quot; 都表示相同的整数 &quot;1&quot;</span><br><span class="line"></span><br><span class="line">示例 2：</span><br><span class="line">输入：version1 = &quot;1.0&quot;, version2 = &quot;1.0.0&quot;</span><br><span class="line">输出：0</span><br><span class="line">解释：version1 没有指定下标为 2 的修订号，即视为 &quot;0&quot;</span><br><span class="line"></span><br><span class="line">示例 3：</span><br><span class="line">输入：version1 = &quot;0.1&quot;, version2 = &quot;1.1&quot;</span><br><span class="line">输出：-1</span><br><span class="line">解释：version1 中下标为 0 的修订号是 &quot;0&quot;，version2 中下标为 0 的修订号是 &quot;1&quot; 。0 &lt; 1，所以 version1 &lt; version2</span><br></pre></td></tr></table></figure><p>提示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1 &lt;= version1.length, version2.length &lt;= 500</span><br><span class="line">version1 和 version2 仅包含数字和 &#x27;.&#x27;</span><br><span class="line">version1 和 version2 都是 有效版本号</span><br><span class="line">version1 和 version2 的所有修订号都可以存储在 32 位整数 中</span><br></pre></td></tr></table></figure><h2 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h2><p>上文提到的累计相加的思路同样可以扩大到字符串比较的题目中。只要有一个没有结束就继续比较，直到两个字符串都结束或找到结果。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">compareVersion</span><span class="params">(string version1, string version2)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> left = <span class="number">0</span>, right = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (left &lt; version1.<span class="built_in">size</span>() || right &lt; version2.<span class="built_in">size</span>()) &#123;</span><br><span class="line">            <span class="comment">// version1求和</span></span><br><span class="line">            <span class="type">int</span> leftSum = <span class="number">0</span>;</span><br><span class="line">            <span class="comment">// 这里并不需要对前导0做任何判断，因为初始值就是0，前导0操作后还是0</span></span><br><span class="line">            <span class="keyword">for</span> (; left &lt; version1.<span class="built_in">size</span>() &amp;&amp; version1[left] != <span class="string">&#x27;.&#x27;</span>; left++) &#123;</span><br><span class="line">                leftSum = leftSum * <span class="number">10</span> + (version1[left] - <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            left++; <span class="comment">// 跳过点</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// version2求和</span></span><br><span class="line">            <span class="type">int</span> rightSum = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (; right &lt; version2.<span class="built_in">size</span>() &amp;&amp; version2[right] != <span class="string">&#x27;.&#x27;</span>; right++) &#123;</span><br><span class="line">                rightSum = rightSum * <span class="number">10</span> + (version2[right] - <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            right++; <span class="comment">// 跳过点</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 不相同就说明有一个大了，判断一下</span></span><br><span class="line">            <span class="keyword">if</span> (leftSum != rightSum) &#123;</span><br><span class="line">                <span class="keyword">return</span> leftSum &gt; rightSum ? <span class="number">1</span> : <span class="number">-1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/04/004f1d885560d3d71f86d7c8a79314a3.png" alt="image.png"></p><p>这道题的另外一个思路就是通过<code>&#39;.&#39;</code>字符将两个字符串切割出来，再依次比较版本号。但是那样会有更大的时间复杂度消耗，逻辑也不是很清晰，不如直接在循环内处理。</p>]]></content>
    
    
    <summary type="html">leetcode刷题笔记：2和989这类数字一位一位相加的问题</summary>
    
    
    
    <category term="编程学习" scheme="https://blog.musnow.top/categories/%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="把题目都给刷干净" scheme="https://blog.musnow.top/categories/%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0/%E6%8A%8A%E9%A2%98%E7%9B%AE%E9%83%BD%E7%BB%99%E5%88%B7%E5%B9%B2%E5%87%80/"/>
    
    
    <category term="OJ刷题" scheme="https://blog.musnow.top/tags/OJ%E5%88%B7%E9%A2%98/"/>
    
    <category term="leetcode" scheme="https://blog.musnow.top/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>【网络】QUIC协议和HTTP3</title>
    <link href="https://blog.musnow.top/posts/2259793534/"/>
    <id>https://blog.musnow.top/posts/2259793534/</id>
    <published>2024-04-11T03:17:57.000Z</published>
    <updated>2024-04-14T08:50:25.000Z</updated>
    
    <content type="html"><![CDATA[<p>面试常考，临时抱佛脚学一下</p><h1 id="HTTP2的升级"><a href="#HTTP2的升级" class="headerlink" title="HTTP2的升级"></a>HTTP2的升级</h1><p>总结就是：1：steam并发传输、2：哈夫曼编码HPACK压缩header为二进制后传输、3：服务器可以主动推送资源给客户端。</p><p><strong>并发传输</strong>就是在HTTP中添加一个steamID，通过ID来标识不同的HTTP请求报文，这样就能在同一个TCP传输流中并发传输多个HTTP报文。而在HTTP1.1中，虽然可以复用同一个TCP链接，但是HTTP1.1中在某个请求没有收到响应之前，是无法传输给其他</p><p><strong>压缩header</strong>：通过哈夫曼编码在双方建立一个动态表，其中包括61项常用header的静态表，同时可以对静态表进行动态扩展（需要使用但不在61项中的header），最终发送header的时候，会用序号来替代header的字符串，同时对header的value进行压缩，从而减少HTTP包的长度。</p><p><strong>服务器主动推送</strong>：请求一个资源后，服务器可以主动将其他客户端用的上的资源推送给客户端，而不需要等客户端主动请求。比如请求<code>index.html</code>后，将需要的js&#x2F;css也推送给客户端。</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/04/bdf5cbb21a7a3f384e42edc7e5d74c08.png" alt="image.png"></p><h1 id="QUIC可靠性保证"><a href="#QUIC可靠性保证" class="headerlink" title="QUIC可靠性保证"></a>QUIC可靠性保证</h1><p>其实这个问题就是UDP如何保证可靠性（加什么东西？），把TCP可靠性机制往里面加就行了。</p><ol><li>重传机制</li><li>确认机制</li><li>握手机制（快速握手）</li><li>拥塞控制（应用层处理的）</li><li>多路复用（多个stream并发）</li><li>前向纠错（校验码）</li></ol><h1 id="QUIC的特点"><a href="#QUIC的特点" class="headerlink" title="QUIC的特点"></a>QUIC的特点</h1><blockquote><p><a href="https://www.xiaolincoding.com/network/2_http/http3.html#%E6%9B%B4%E5%BF%AB%E7%9A%84%E8%BF%9E%E6%8E%A5%E5%BB%BA%E7%AB%8B">https://www.xiaolincoding.com/network/2_http/http3.html#%E6%9B%B4%E5%BF%AB%E7%9A%84%E8%BF%9E%E6%8E%A5%E5%BB%BA%E7%AB%8B</a></p></blockquote><h2 id="无队头阻塞"><a href="#无队头阻塞" class="headerlink" title="无队头阻塞"></a>无队头阻塞</h2><p>无队头阻塞：HTTP2中用tcp实现多stream并发传输，但是tcp本身需要保证数据到达应用层的有序性。假设有这样的报文到达顺序</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">stream1 tcp1</span><br><span class="line">stream2 tcp2</span><br><span class="line">stream1 tcp3 # 丢包</span><br><span class="line">stream2 tcp4</span><br><span class="line">stream3 tcp5</span><br></pre></td></tr></table></figure><p>此时tcp3出现了丢包，虽然我们客户端已经收到了服务器发送的stream2(tcp4)和stream3(tcp5)，但因为tcp协议栈<strong>需要维护序号有序性</strong>，没有收到tcp3之前，它不会把后序的数据交付给上层，这就导致了stream2&#x2F;3因为stream1的丢包而出现了阻塞，也就是<code>队头阻塞</code>的含义。</p><p>而QUIC基于UDP，因为UDP本身是无连接的，所以它不会出现队头阻塞的问题。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">stream1 udp3 # 丢包</span><br><span class="line">stream2 udp4</span><br><span class="line">stream3 udp5</span><br></pre></td></tr></table></figure><p>即便udp3丢包了，也不会影响udp4&#x2F;5，此时steam2&#x2F;3也能被正常交付给上层供HTTP使用。</p><p>反映到浏览器加载中，有可能这里的udp4&#x2F;5就是steam2&#x2F;3的最后一个分片，交付给上层后就已组成了一个完整的HTTP报文，表现在浏览器上就是某一个模块加载出来了，会让用户的体验更好。</p><h2 id="更快的链接建立"><a href="#更快的链接建立" class="headerlink" title="更快的链接建立"></a>更快的链接建立</h2><p>在通过TCP实现HTTPS的时候，需要涉及到TCP三次握手和TLS&#x2F;SSL握手。其中TCP三次握手和SSL握手都要进行3次数据传输，一共就是6次单向传输了（3RTT）。</p><p>而UDP实现的QUIC也需要握手，这个过程是1RTT。但是QUIC本身就是一个应用层实现的协议，它可以直接在第一次链接的时候就携带TLS&#x2F;SSL的相关信息，第二次链接的时候发送QUIC握手报文+TLS握手报文和数据载荷，同时完成TLS握手的功能，近似实现0RTT的握手。</p><blockquote><p>这里涉及到了TLS1.3，先暂且不去深入了解，知道大概就行。</p></blockquote><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/04/f97be469c526cb19338a066b1120c368.png" alt="image.png"></p><h2 id="链接迁移"><a href="#链接迁移" class="headerlink" title="链接迁移"></a>链接迁移</h2><p>在基于TCP的HTTP中，需要通过IP和TCP端口的四元组来定位客户端和服务端。</p><p>假设我们从WIFI切换成4G&#x2F;5G，此时客户端的ip和端口肯定会发生变化，而在旧版本中，这就需要使用TCP重新和服务器进行三次握手和TLS链接建立，才能重新开始数据传输。</p><p>而QUIC中，除了IP&#x2F;UDP的四元组外，还有个独特的QUIC会话ID来标识两边的传输。</p><p>假设一个客户端从WIFI切换成5G，发生了IP和端口的变化，但它发送的QUIC请求报文中，依旧包含了之前的<strong>QUIC会话ID</strong>，此时服务器可以通过这个会话ID定位之前的传输，并继续传输之前中断的时候的数据。</p><p>再加上前文提到的QUIC握手次数少，这两个相结合，客户端切换IP和端口的时间消耗就更少了！</p><h1 id="HTTP3的QPACK"><a href="#HTTP3的QPACK" class="headerlink" title="HTTP3的QPACK"></a>HTTP3的QPACK</h1><p>在HTTP2中，会用HPACK来将更新后的动态header表发送给对方，但是它的HPACK并没有确认机制。也就是说，如果你发送的一个新的HPACK更新丢包了，对方没有收到，也就不认识某个新的header序号，此时客户端发送的信息就没有办法被正常解码了，此时会出现阻塞。</p><p>而QPACK就是在HPACK的基础上加入了确认机制。有两个链接来进行</p><ul><li>一个叫 QPACK Encoder Stream，用于将一个字典（Key-Value）传递给对方，比如面对不属于静态表的 HTTP 请求头部，客户端可以通过这个 Stream 发送字典；</li><li>一个叫 QPACK Decoder Stream，用于响应对方，告诉它刚发的字典已经更新到自己的本地动态表了，后续就可以使用这个字典来编码了。</li></ul><p>这两个特殊的单向流是用来同步双方的动态表，编码方收到解码方更新确认的通知后，才使用动态表编码 HTTP 头部。</p><p>当A给B发送的动态表没有被收到时，A还不会对这个新的header进行压缩（以原始形式进行发送）。直到收到B对这个动态表的响应了，才会压缩传输。</p><p>这样就避免了HPACK中A会压缩发送一个<strong>B还不知道</strong>的动态表中的header的情况。</p>]]></content>
    
    
    <summary type="html">QUIC协议和HTTP3简介</summary>
    
    
    
    <category term="编程学习" scheme="https://blog.musnow.top/categories/%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="计算机网络" scheme="https://blog.musnow.top/categories/%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
    <category term="计算机网络" scheme="https://blog.musnow.top/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    <category term="面经" scheme="https://blog.musnow.top/tags/%E9%9D%A2%E7%BB%8F/"/>
    
  </entry>
  
  <entry>
    <title>【算法】贪心算法</title>
    <link href="https://blog.musnow.top/posts/3488338229/"/>
    <id>https://blog.musnow.top/posts/3488338229/</id>
    <published>2024-04-07T02:33:18.000Z</published>
    <updated>2024-04-16T01:14:54.000Z</updated>
    
    <content type="html"><![CDATA[<p>贪心算法学习</p><h1 id="基本理论"><a href="#基本理论" class="headerlink" title="基本理论"></a>基本理论</h1><p>贪心算法的基本理论是“从局部最优推出全局最优”。</p><p>每一次小操作都是在选择局部最优，最终得到的结果就是一个全局最优。</p><p>当一个题目能满足这个思路的时候，就可以尝试使用贪心了。</p><h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><h2 id="455-分发饼干"><a href="#455-分发饼干" class="headerlink" title="455 分发饼干"></a>455 分发饼干</h2><blockquote><p><a href="https://leetcode.cn/problems/assign-cookies/">https://leetcode.cn/problems/assign-cookies/</a></p></blockquote><h3 id="题目和思路"><a href="#题目和思路" class="headerlink" title="题目和思路"></a>题目和思路</h3><p>假设你是一位很棒的家长，想要给你的孩子们一些小饼干。但是，每个孩子最多只能给一块饼干。</p><p>对每个孩子 i，都有一个胃口值 <code>g[i]</code>，这是能让孩子们满足胃口的饼干的最小尺寸；并且每块饼干 j，都有一个尺寸 <code>s[j]</code> 。如果 <code>s[j] &gt;= g[i]</code>，我们可以将这个饼干 j 分配给孩子 i ，这个孩子会得到满足。你的目标是尽可能满足越多数量的孩子，并输出这个最大数值。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">示例 1:</span><br><span class="line">输入: g = [1,2,3], s = [1,1]</span><br><span class="line">输出: 1</span><br><span class="line">解释: </span><br><span class="line">你有三个孩子和两块小饼干，3个孩子的胃口值分别是：1,2,3。</span><br><span class="line">虽然你有两块小饼干，由于他们的尺寸都是1，你只能让胃口值是1的孩子满足。</span><br><span class="line">所以你应该输出1。</span><br><span class="line"></span><br><span class="line">示例 2:</span><br><span class="line">输入: g = [1,2], s = [1,2,3]</span><br><span class="line">输出: 2</span><br><span class="line">解释: </span><br><span class="line">你有两个孩子和三块小饼干，2个孩子的胃口值分别是1,2。</span><br><span class="line">你拥有的饼干数量和尺寸都足以让所有孩子满足。</span><br><span class="line">所以你应该输出2.</span><br></pre></td></tr></table></figure><p>这道题的思路其实很简单，即我们每次都应该选择大饼干满足大胃口的人，这样才能让最终可以吃到饼干的小孩最多。</p><p>直接排序两个数组，从右往左遍历，判断当前饼干是否能满足当前胃口的人，如果可以，则消耗一个饼干，并让计数器加一。不可以，则继续往左遍历胃口。</p><p>在这个例子中，局部最优是用大饼干满足大胃口的，全局最优是最终能吃上饼干的孩子最多。</p><h3 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h3><p>代码中需要注意对index的越界检查，特别是数组s为空的情况。当index已经越界的时候，就可以跳出循环了。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">findContentChildren</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; g, vector&lt;<span class="type">int</span>&gt;&amp; s)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">sort</span>(g.<span class="built_in">begin</span>(), g.<span class="built_in">end</span>());</span><br><span class="line">        <span class="built_in">sort</span>(s.<span class="built_in">begin</span>(), s.<span class="built_in">end</span>());</span><br><span class="line">        <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> index = s.<span class="built_in">size</span>() - <span class="number">1</span>; <span class="comment">// 饼干最后一个</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = g.<span class="built_in">size</span>() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="keyword">if</span> (index &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (s[index] &gt;= g[i]) &#123;</span><br><span class="line">                index--;</span><br><span class="line">                count++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="376-摆动序列"><a href="#376-摆动序列" class="headerlink" title="376 摆动序列"></a>376 摆动序列</h2><blockquote><p><a href="https://leetcode.cn/problems/wiggle-subsequence/description/">https://leetcode.cn/problems/wiggle-subsequence/description/</a></p></blockquote><h3 id="题目和思路-1"><a href="#题目和思路-1" class="headerlink" title="题目和思路"></a>题目和思路</h3><p>如果连续数字之间的差严格地在正数和负数之间交替，则数字序列称为 摆动序列 。第一个差（如果存在的话）可能是正数或负数。仅有一个元素或者含两个不等元素的序列也视作摆动序列。</p><p>例如， [1, 7, 4, 9, 2, 5] 是一个 摆动序列 ，因为差值 (6, -3, 5, -7, 3) 是正负交替出现的。</p><p>相反，[1, 4, 7, 2, 5] 和 [1, 7, 4, 5, 5] 不是摆动序列，第一个序列是因为它的前两个差值都是正数，第二个序列是因为它的最后一个差值为零。</p><p><strong>子序列</strong> 可以通过从原始序列中删除一些（也可以不删除）元素来获得，剩下的元素保持其原始顺序。</p><p>给你一个整数数组 nums ，返回 nums 中作为 摆动序列 的 最长子序列的长度 。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">示例 1：</span><br><span class="line">输入：nums = [1,7,4,9,2,5]</span><br><span class="line">输出：6</span><br><span class="line">解释：整个序列均为摆动序列，各元素之间的差值为 (6, -3, 5, -7, 3) 。</span><br><span class="line"></span><br><span class="line">示例 2：</span><br><span class="line">输入：nums = [1,17,5,10,13,15,10,5,16,8]</span><br><span class="line">输出：7</span><br><span class="line">解释：这个序列包含几个长度为 7 摆动序列。</span><br><span class="line">其中一个是 [1, 17, 10, 13, 10, 16, 8] ，各元素之间的差值为 (16, -7, 3, -3, 6, -8) 。</span><br><span class="line"></span><br><span class="line">示例 3：</span><br><span class="line">输入：nums = [1,2,3,4,5,6,7,8,9]</span><br><span class="line">输出：2</span><br></pre></td></tr></table></figure><p>首先需要拆分情况，除了正常的一上一下的折线图，还可能会出现下面的情况，这些情况都必须特别来处理。</p><ul><li>连续的上坡或连续的下坡</li><li>上坡下坡之间有平地</li><li>上坡和上坡之间有平地（下坡和下坡之间有平地）</li></ul><p>先来看第一个，<strong>连续的上坡或者连续的下坡的情况</strong>：这需要我们将连续的上坡只看作一个上坡，比如上坡有3个节点（包括坡底和坡顶），那么最终可以计算的只有一个（坡顶，坡底已经计算过了）。</p><p><strong>上坡下坡之间有平地的情况</strong>：将平地其他节点删除，只计算一个节点。</p><p><strong>上坡和上坡之间有平地</strong>：将平地删除成一个节点，此时就变成了情况1的连续上坡&#x2F;下坡。</p><blockquote><p>具体示意图的可以参考代码随想录：<a href="https://www.programmercarl.com/0376.%E6%91%86%E5%8A%A8%E5%BA%8F%E5%88%97.html#%E6%80%9D%E8%B7%AF">https://www.programmercarl.com/0376.%E6%91%86%E5%8A%A8%E5%BA%8F%E5%88%97.html#%E6%80%9D%E8%B7%AF</a></p></blockquote><h3 id="错误代码"><a href="#错误代码" class="headerlink" title="错误代码"></a>错误代码</h3><p>最开始的时候，我写出了这样一版代码，它的问题在于，只能处理子数组的情况（子数组是连续的），而不能处理子序列（中间可以不连续）。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">wiggleMaxLength</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 判断上一个diff是正数还是负数，正数设置为1，负数设置为-1</span></span><br><span class="line">        <span class="type">int</span> lastDiff = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> maxLength = <span class="number">-1</span>;</span><br><span class="line">        <span class="type">int</span> curLength = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; nums.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="type">int</span> diff = nums[i] - nums[i - <span class="number">1</span>];</span><br><span class="line">            cout &lt;&lt; nums[i] &lt;&lt; <span class="string">&quot; - &quot;</span> &lt;&lt; nums[i - <span class="number">1</span>] &lt;&lt; <span class="string">&quot; = &quot;</span> &lt;&lt; diff &lt;&lt; <span class="string">&quot; : &quot;</span></span><br><span class="line">                 &lt;&lt; curLength &lt;&lt; <span class="string">&quot;  f:&quot;</span> &lt;&lt; lastDiff &lt;&lt; endl;</span><br><span class="line">            <span class="keyword">if</span> (diff &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// 不符合条件，从当前位开始新算一个子数组</span></span><br><span class="line">                <span class="keyword">if</span> (lastDiff == <span class="number">1</span>) &#123;</span><br><span class="line">                    curLength = <span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 符合条件</span></span><br><span class="line">                curLength++;</span><br><span class="line">                maxLength = <span class="built_in">max</span>(curLength, maxLength);</span><br><span class="line">                <span class="comment">// 设置LastDiff</span></span><br><span class="line">                lastDiff = <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 不符合</span></span><br><span class="line">                <span class="keyword">if</span> (lastDiff == <span class="number">-1</span>) &#123;</span><br><span class="line">                    curLength = <span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 符合条件</span></span><br><span class="line">                curLength++;</span><br><span class="line">                maxLength = <span class="built_in">max</span>(curLength, maxLength);</span><br><span class="line">                <span class="comment">// 设置LastDiff</span></span><br><span class="line">                lastDiff = <span class="number">-1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxLength == <span class="number">-1</span> ? <span class="number">0</span> : maxLength;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="正确代码"><a href="#正确代码" class="headerlink" title="正确代码"></a>正确代码</h3><p>这里面，用curDiff记录当前的差值，preDiff记录上一个有变动的差值，result是返回值。</p><p>result初始化为1是因为判断是在<code>nums.size() - 2</code>就结束的（最后一个节点并没有被循环计入其中），而且当数组长度为2的时候，判断只会有一次，如果不置1就会漏掉一个值。</p><p>以下图为例，这是一个<strong>上坡和下坡之中有平坡</strong>的情况，如下的代码在循环中判断的是i和i+1，最终会在<code>nums.size() - 2</code>位置（图中已标注）跳出循环。此时<code>result++</code>是只加入了<code>nums.size() - 2</code>的这个点，而没有加入<code>nums.size() - 1</code>这个同样需要被加入的点，所以需要将result初始化为1来覆盖这种漏掉的情况。</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/04/feb535b0482c5164d16cec60ab748168.png" alt="image.png"></p><p>下面是详细的判断逻辑：</p><ul><li><code>preDiff &lt; 0 &amp;&amp; curDiff &gt; 0</code> 和 <code>preDiff &gt;0 &amp;&amp; curDiff &lt; 0</code> 是最基本的上坡和下坡情况，当前差值和之前的并非同正同负；</li><li><code>preDiff == 0 &amp;&amp; curDiff &gt; 0</code> 和 <code>preDiff == 0 &amp;&amp; curDiff &lt; 0</code> 的情况满足上文所述“上坡下坡之间有平地的情况，此时也需要记录摆动的变化。</li><li>只在摆动变化的时候记录preDiff就可以忽略“上坡和上坡之间有平地”的情况（如果不这么做，就会多记录一次节点）</li></ul><p>最终可以写出下面的代码。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">wiggleMaxLength</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (nums.<span class="built_in">size</span>() &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> nums.<span class="built_in">size</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> curDiff = <span class="number">0</span>; <span class="comment">// 当前一对差值</span></span><br><span class="line">        <span class="type">int</span> preDiff = <span class="number">0</span>; <span class="comment">// 前一对差值</span></span><br><span class="line">        <span class="type">int</span> result = <span class="number">1</span>; <span class="comment">// 记录峰值个数，序列默认序列最右边有一个峰值</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>() - <span class="number">1</span>; i++) &#123;</span><br><span class="line">            curDiff = nums[i + <span class="number">1</span>] - nums[i];</span><br><span class="line">            <span class="comment">// 出现峰值</span></span><br><span class="line">            <span class="keyword">if</span> ((preDiff &lt;= <span class="number">0</span> &amp;&amp; curDiff &gt; <span class="number">0</span>) ||</span><br><span class="line">                (preDiff &gt;= <span class="number">0</span> &amp;&amp; curDiff &lt; <span class="number">0</span>)) &#123;</span><br><span class="line">                result++;</span><br><span class="line">                preDiff = curDiff; <span class="comment">// 注意这里，只在摆动变化的时候更新prediff</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/04/49ffcd1cffbf381e29d94594decc9938.png" alt="image.png"></p><h2 id="122-买卖股票的最佳时机2"><a href="#122-买卖股票的最佳时机2" class="headerlink" title="122 买卖股票的最佳时机2"></a>122 买卖股票的最佳时机2</h2><h3 id="题目和思路-2"><a href="#题目和思路-2" class="headerlink" title="题目和思路"></a>题目和思路</h3><blockquote><p><a href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-ii/description/">https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-ii/description/</a></p></blockquote><p>给你一个整数数组 prices ，其中 <code>prices[i]</code> 表示某支股票第 i 天的价格。</p><p>在每一天，你可以决定是否购买和&#x2F;或出售股票。你在任何时候 最多 只能持有 一股 股票。你也可以先购买，然后在 同一天 出售。</p><p>返回 你能获得的 最大 利润 。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">示例 1：</span><br><span class="line">输入：prices = [7,1,5,3,6,4]</span><br><span class="line">输出：7</span><br><span class="line">解释：在第 2 天（股票价格 = 1）的时候买入，在第 3 天（股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5 - 1 = 4 。</span><br><span class="line">     随后，在第 4 天（股票价格 = 3）的时候买入，在第 5 天（股票价格 = 6）的时候卖出, 这笔交易所能获得利润 = 6 - 3 = 3 。</span><br><span class="line">     总利润为 4 + 3 = 7 。</span><br><span class="line">     </span><br><span class="line">示例 2：</span><br><span class="line">输入：prices = [1,2,3,4,5]</span><br><span class="line">输出：4</span><br><span class="line">解释：在第 1 天（股票价格 = 1）的时候买入，在第 5 天 （股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5 - 1 = 4 。</span><br><span class="line">     总利润为 4 。</span><br><span class="line">     </span><br><span class="line">示例 3：</span><br><span class="line">输入：prices = [7,6,4,3,1]</span><br><span class="line">输出：0</span><br><span class="line">解释：在这种情况下, 交易无法获得正利润，所以不参与交易可以获得最大利润，最大利润为 0 。</span><br></pre></td></tr></table></figure><p>首先需要想明白，这道题的利润是可以被分解的。第0天买，第3天卖的利润是 <code>prices[3]-prices[0]</code>，等价于 <code>(p[3]-p[2]) + (p[2]-p[1]) + (p[1]-p[0])</code>。想明白这一点后，这道题的解法就很明确了。</p><p>与其是动态计算咋样才能获得最高利润，还不如分解成一小块一小块的，<strong>只要昨天买入，今天卖出可以赚钱，那么就加入到最终的利润里面</strong>。因为你0天买3天卖，和每天都卖出昨日买入今日得到的钱是完全一致的。那么我们排除掉昨天买入今天卖出会亏钱的情况，就能计算出最终可以达到的最大利润。</p><h3 id="题目代码"><a href="#题目代码" class="headerlink" title="题目代码"></a>题目代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxProfit</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 第0天买，第3天卖的利润是prices[3]-prices[0]</span></span><br><span class="line">        <span class="comment">// 也等于 p[3]-p[2] + p[2]-p[1] + p[1]-p[0]</span></span><br><span class="line">        <span class="comment">// 所以最大利润其实就是每天利润之和（前提是利润都是正的）</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; prices.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="comment">// 计算昨天买今天卖能获得多少利润</span></span><br><span class="line">            <span class="comment">// 如果大于0就加入进去</span></span><br><span class="line">            count += <span class="built_in">max</span>(prices[i] - prices[i - <span class="number">1</span>], <span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/04/1d61dc355c9977d36978521b023b6129.png" alt="image.png"></p><h2 id="55-跳跃游戏"><a href="#55-跳跃游戏" class="headerlink" title="55 跳跃游戏"></a>55 跳跃游戏</h2><blockquote><p><a href="https://leetcode.cn/problems/jump-game/description/">https://leetcode.cn/problems/jump-game/description/</a></p></blockquote><h3 id="题目和思路-3"><a href="#题目和思路-3" class="headerlink" title="题目和思路"></a>题目和思路</h3><p>给你一个非负整数数组 nums ，你最初位于数组的 第一个下标 。数组中的每个元素代表你在该位置可以跳跃的最大长度。</p><p>判断你是否能够到达最后一个下标，如果可以，返回 true ；否则，返回 false 。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">示例 1：</span><br><span class="line">输入：nums = [2,3,1,1,4]</span><br><span class="line">输出：true</span><br><span class="line">解释：可以先跳 1 步，从下标 0 到达下标 1, 然后再从下标 1 跳 3 步到达最后一个下标。</span><br><span class="line"></span><br><span class="line">示例 2：</span><br><span class="line">输入：nums = [3,2,1,0,4]</span><br><span class="line">输出：false</span><br><span class="line">解释：无论怎样，总会到达下标为 3 的位置。但该下标的最大跳跃长度是 0 ， 所以永远不可能到达最后一个下标。</span><br></pre></td></tr></table></figure><p>这道题的思路主要在于判断当前下标加上可以跳的步数判断是否到了最后一位，到了就肯定能跳到。</p><h3 id="超时代码"><a href="#超时代码" class="headerlink" title="超时代码"></a>超时代码</h3><p>最开始我写出了这样的递归思路，本质是暴力求解。不出意外的超时了。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="type">bool</span> _canJump(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> index) &#123;</span><br><span class="line">        <span class="keyword">if</span> (index &gt;= nums.<span class="built_in">size</span>() - <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 判断当前是否包括了终点</span></span><br><span class="line">        <span class="keyword">if</span> (index + nums[index] &gt;= nums.<span class="built_in">size</span>() - <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>; <span class="comment">// 不需要跳了，肯定可以抵达终点</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 遍历进行递归</span></span><br><span class="line">        <span class="type">int</span> range = <span class="built_in">min</span>(index + nums[index], (<span class="type">int</span>)(nums.<span class="built_in">size</span>() - <span class="number">1</span>));</span><br><span class="line">        <span class="comment">// 要从index下一位开始，不然就死循环了</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = index + <span class="number">1</span>; i &lt;= range; i++) &#123;</span><br><span class="line">            <span class="comment">// 递归看看能不能跳到终点</span></span><br><span class="line">            <span class="keyword">if</span> (_canJump(nums, i)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 不可以，那就是无了</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">canJump</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123; <span class="keyword">return</span> _canJump(nums, <span class="number">0</span>); &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/04/c92d1741e6e228dc5ab4b49d9c1409c2.png" alt="image.png"></p><h3 id="正确代码-1"><a href="#正确代码-1" class="headerlink" title="正确代码"></a>正确代码</h3><p>代码随想录上提供了一个更好的办法，思路其实也是类似的，但是可以压缩在一个循环中。动态的改变当前for循环i的边界cover，直到cover大于等于最后一位下标的时候，就是可以跳到，返回true。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">canJump</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (nums.<span class="built_in">size</span>() == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="comment">// 只有一个元素，本来就是从这里起跳的，肯定可以达到</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>; </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> cover = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 注意这里是小于等于cover，cover是闭区间</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= cover; i++) &#123; </span><br><span class="line">            <span class="comment">// 判断当前能跳的范围和cover谁大</span></span><br><span class="line">            cover = <span class="built_in">max</span>(i + nums[i], cover);</span><br><span class="line">            <span class="keyword">if</span> (cover &gt;= nums.<span class="built_in">size</span>() - <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>; <span class="comment">// 说明可以覆盖到终点了</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/04/b7bf833dd954963861fc740c7c2517db.png" alt="image.png"></p><h2 id="45-跳跃游戏2"><a href="#45-跳跃游戏2" class="headerlink" title="45 跳跃游戏2"></a>45 跳跃游戏2</h2><h3 id="题目和思路-4"><a href="#题目和思路-4" class="headerlink" title="题目和思路"></a>题目和思路</h3><blockquote><p><a href="https://leetcode.cn/problems/jump-game-ii/description/">https://leetcode.cn/problems/jump-game-ii/description/</a></p></blockquote><p>给定一个长度为 n 的 0 索引整数数组 nums。初始位置为 nums[0]。</p><p>每个元素 nums[i] 表示从索引 i 向前跳转的最大长度。换句话说，如果你在 nums[i] 处，你可以跳转到任意 nums[i + j] 处:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">0 &lt;= j &lt;= nums[i] </span><br><span class="line">i + j &lt; n</span><br></pre></td></tr></table></figure><p>返回到达 nums[n - 1] 的最小跳跃次数。生成的测试用例可以到达 nums[n - 1]。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">示例 1:</span><br><span class="line">输入: nums = [2,3,1,1,4]</span><br><span class="line">输出: 2</span><br><span class="line">解释: 跳到最后一个位置的最小跳跃数是 2。</span><br><span class="line">     从下标为 0 跳到下标为 1 的位置，跳 1 步，然后跳 3 步到达数组的最后一个位置。</span><br><span class="line">     </span><br><span class="line">示例 2:</span><br><span class="line">输入: nums = [2,3,0,1,4]</span><br><span class="line">输出: 2</span><br></pre></td></tr></table></figure><p>这道题和上一题就不同了，上一题只是判断能不能跳到最后一个位置，这一题是在已经可以跳到最后一个位置的基础上，计算最小的跳跃次数。</p><p>不过基本思路还是一样的，就是判断cover的范围。</p><ul><li>在当前范围中，找到下一步能抵达的最大范围</li><li>i抵达当前范围的边界了，必须跳一步了<ul><li>步数加一</li><li>更新当前范围为下一步的最大范围</li><li>判断最大范围是否已经到了<code>nums.size()-1</code>，如果到了直接返回步数（只需要再跳一步就可以抵达末尾了）</li></ul></li></ul><p>不管当前怎么跳，当前范围都是可以跳到的，那么我们只需要找到当前范围中，下一步能抵达的最大位置，那么就是最好的选择。直到下一步抵达终点，返回步数。</p><h3 id="完整代码-1"><a href="#完整代码-1" class="headerlink" title="完整代码"></a>完整代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">jump</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (nums.<span class="built_in">size</span>() == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 当前的跳跃范围</span></span><br><span class="line">        <span class="type">int</span> curJump = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> maxJump = <span class="number">0</span>; <span class="comment">// 判断范围内可以跳的最大值</span></span><br><span class="line">        <span class="type">int</span> count = <span class="number">0</span>;   <span class="comment">// 跳了几次</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="comment">// 更新在[i,curJump]范围内下一步可以跳的最大范围</span></span><br><span class="line">            maxJump = <span class="built_in">max</span>(i + nums[i], maxJump);</span><br><span class="line">            <span class="comment">// 到达右边界了，必须再跳一步了。</span></span><br><span class="line">            <span class="keyword">if</span> (i == curJump) &#123;</span><br><span class="line">                count++;</span><br><span class="line">                curJump = maxJump;</span><br><span class="line">                <span class="comment">// 可以跳到下一步（这里提前count++就相当于跳了这一步）</span></span><br><span class="line">                <span class="keyword">if</span> (maxJump &gt;= nums.<span class="built_in">size</span>() - <span class="number">1</span>) &#123;</span><br><span class="line">                    <span class="keyword">return</span> count;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/04/3084162e56bfdd5cc3b6204357509ace.png" alt="image.png"></p><h2 id="1005-k次取反后的最大和"><a href="#1005-k次取反后的最大和" class="headerlink" title="1005 k次取反后的最大和"></a>1005 k次取反后的最大和</h2><blockquote><p><a href="https://leetcode.cn/problems/maximize-sum-of-array-after-k-negations/">https://leetcode.cn/problems/maximize-sum-of-array-after-k-negations/</a></p></blockquote><h3 id="题目和思路-5"><a href="#题目和思路-5" class="headerlink" title="题目和思路"></a>题目和思路</h3><p>给你一个整数数组 nums 和一个整数 k ，按以下方法修改该数组：</p><p>选择某个下标 i 并将 nums[i] 替换为 -nums[i] 。</p><p>重复这个过程恰好 k 次。可以多次选择同一个下标 i 。</p><p>以这种方式修改数组后，返回数组 可能的最大和 。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">示例 1：</span><br><span class="line">输入：nums = [4,2,3], k = 1</span><br><span class="line">输出：5</span><br><span class="line">解释：选择下标 1 ，nums 变为 [4,-2,3] 。</span><br><span class="line"></span><br><span class="line">示例 2：</span><br><span class="line">输入：nums = [3,-1,0,2], k = 3</span><br><span class="line">输出：6</span><br><span class="line">解释：选择下标 (1, 2, 2) ，nums 变为 [3,1,0,2] 。</span><br><span class="line"></span><br><span class="line">示例 3：</span><br><span class="line">输入：nums = [2,-3,-1,5,-4], k = 2</span><br><span class="line">输出：13</span><br><span class="line">解释：选择下标 (1, 4) ，nums 变为 [2,3,-1,5,4] </span><br></pre></td></tr></table></figure><p>这道题的思路很简单，首先我们肯定是先把负数反转成正的，都是正数了之后，再考虑反转最小的数。</p><p>本来我的想法是，反转完毕负数后，重排序，从最小的数开始一直往后反转，但是这样思考就忽略了题目中的一个要求。题目是<strong>允许在某个下标处重复反转</strong>的。</p><p>那么我们就没有必要从最小的数开始把它们都反转成负数了，而是一直操作最小的那个数，直到k用完。上面的示例2就是这样的，先把负数反转成正数，然后重复操作0。</p><h3 id="完整代码-2"><a href="#完整代码-2" class="headerlink" title="完整代码"></a>完整代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="comment">// 按绝对值从大到小排序</span></span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">bool</span> <span class="title">cmp</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123; <span class="keyword">return</span> <span class="built_in">abs</span>(a) &gt; <span class="built_in">abs</span>(b); &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">largestSumAfterKNegations</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 绝对值从大到小排列</span></span><br><span class="line">        <span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>(), cmp);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="comment">// 反转负数</span></span><br><span class="line">            <span class="keyword">if</span> (nums[i] &lt; <span class="number">0</span> &amp;&amp; k &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                nums[i] *= <span class="number">-1</span>;</span><br><span class="line">                k--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果k还没有用完，则反转绝对值最小的那个数，直到用完k</span></span><br><span class="line">        <span class="comment">// 这里直接判断k是奇数还是偶数，如果是奇数会多出来一次反转，只需要做这一次就可以了</span></span><br><span class="line">        <span class="keyword">if</span> (k % <span class="number">2</span> == <span class="number">1</span>) &#123;</span><br><span class="line">            nums[nums.<span class="built_in">size</span>() - <span class="number">1</span>] *= <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 求和</span></span><br><span class="line">        <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; e : nums) &#123;</span><br><span class="line">            sum += e;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="134-加油站"><a href="#134-加油站" class="headerlink" title="134 加油站"></a>134 加油站</h2><h3 id="题目和思路-6"><a href="#题目和思路-6" class="headerlink" title="题目和思路"></a>题目和思路</h3><blockquote><p><a href="https://leetcode.cn/problems/gas-station/">https://leetcode.cn/problems/gas-station/</a></p></blockquote><p>在一条环路上有 n 个加油站，其中第 i 个加油站有汽油 gas[i] 升。</p><p>你有一辆油箱容量无限的的汽车，从第 i 个加油站开往第 i+1 个加油站需要消耗汽油 cost[i] 升。你从其中的一个加油站出发，开始时油箱为空。</p><p>给定两个整数数组 gas 和 cost ，如果你可以按顺序绕环路行驶一周，则返回出发时加油站的编号，否则返回 -1 。如果存在解，则 保证 它是 唯一 的。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">示例 1:</span><br><span class="line">输入: gas = [1,2,3,4,5], cost = [3,4,5,1,2]</span><br><span class="line">输出: 3</span><br><span class="line">解释:</span><br><span class="line">从 3 号加油站(索引为 3 处)出发，可获得 4 升汽油。此时油箱有 = 0 + 4 = 4 升汽油</span><br><span class="line">开往 4 号加油站，此时油箱有 4 - 1 + 5 = 8 升汽油</span><br><span class="line">开往 0 号加油站，此时油箱有 8 - 2 + 1 = 7 升汽油</span><br><span class="line">开往 1 号加油站，此时油箱有 7 - 3 + 2 = 6 升汽油</span><br><span class="line">开往 2 号加油站，此时油箱有 6 - 4 + 3 = 5 升汽油</span><br><span class="line">开往 3 号加油站，你需要消耗 5 升汽油，正好足够你返回到 3 号加油站。</span><br><span class="line">因此，3 可为起始索引。</span><br><span class="line"></span><br><span class="line">示例 2:</span><br><span class="line">输入: gas = [2,3,4], cost = [3,4,3]</span><br><span class="line">输出: -1</span><br><span class="line">解释:</span><br><span class="line">你不能从 0 号或 1 号加油站出发，因为没有足够的汽油可以让你行驶到下一个加油站。</span><br><span class="line">我们从 2 号加油站出发，可以获得 4 升汽油。 此时油箱有 = 0 + 4 = 4 升汽油</span><br><span class="line">开往 0 号加油站，此时油箱有 4 - 3 + 2 = 3 升汽油</span><br><span class="line">开往 1 号加油站，此时油箱有 3 - 3 + 3 = 3 升汽油</span><br><span class="line">你无法返回 2 号加油站，因为返程需要消耗 4 升汽油，但是你的油箱只有 3 升汽油。</span><br><span class="line">因此，无论怎样，你都不可能绕环路行驶一周。</span><br></pre></td></tr></table></figure><p>这道题使用贪心的方式，找到局部最优：假设从start出发每次走一步，计算<code>gas[i]-cost[i]</code>得到剩余的油，如果剩余的油为负数，说明从<code>[start,i]</code>之中的任意位置出发，走到i的时候都会没油。那么就需要从i+1开始走（更新start）。</p><p>最终遍历完毕整个数组的时候，得到的start肯定是能走完整个区间的起始下标。因为其他下标开始走，都没有办法走完某一个区间。</p><h3 id="完整代码-3"><a href="#完整代码-3" class="headerlink" title="完整代码"></a>完整代码</h3><p>这里还有关于<code>start=i+1</code>是否会出现越界情况的说明，参考代码注释。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">canCompleteCircuit</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; gas, vector&lt;<span class="type">int</span>&gt;&amp; cost)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 1.所有油加起来没有距离长，说明永远走不到</span></span><br><span class="line">        <span class="comment">// 2.假设从0开始，走到i，如果剩余油为负数，说明[0,i]区间内，不管从哪里开始，都走不到i；</span></span><br><span class="line">        <span class="comment">//   那么就需要从i+1开始重新走，直到剩余油再次为负数或者走完整个区间</span></span><br><span class="line">        <span class="type">int</span> start = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> totalSum = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> leftGas = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; gas.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            leftGas += gas[i] - cost[i];</span><br><span class="line">            totalSum += gas[i] - cost[i];</span><br><span class="line">            <span class="keyword">if</span> (leftGas &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// 因为[start,i]区间内剩余油是负数，说明从这个区间任意位置开始都走不到i</span></span><br><span class="line">                <span class="comment">// 所以需要从i+1作为一个新的起点，继续往后走。</span></span><br><span class="line">                start = i + <span class="number">1</span>; </span><br><span class="line">                leftGas = <span class="number">0</span>; <span class="comment">// 重置剩余油</span></span><br><span class="line">                <span class="comment">// 会不会出现i+1越界了的情况？这种情况说明i=size-1的时候，leftGas小于0；</span></span><br><span class="line">                <span class="comment">// 同时也说明了[start,sz-1]还是无法走完，反应到全局说明油本来就是不够的；</span></span><br><span class="line">                <span class="comment">// 此时会在后面的totalSum的判断中返回-1，所以不会出现start越界的情况；</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果diff加起来最终是个负数，说明油是不够用的</span></span><br><span class="line">        <span class="keyword">if</span> (totalSum &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> start;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/04/7f32f785c9fdc45f7cb9296f24767696.png" alt="image.png"></p><h2 id="135-分发糖果"><a href="#135-分发糖果" class="headerlink" title="135 分发糖果"></a>135 分发糖果</h2><blockquote><p><a href="https://leetcode.cn/problems/candy/description/">https://leetcode.cn/problems/candy/description/</a></p></blockquote><h3 id="题目和思路-7"><a href="#题目和思路-7" class="headerlink" title="题目和思路"></a>题目和思路</h3><p>n 个孩子站成一排。给你一个整数数组 ratings 表示每个孩子的评分。</p><p>你需要按照以下要求，给这些孩子分发糖果：</p><p>每个孩子至少分配到 1 个糖果。<br>相邻两个孩子评分更高的孩子会获得更多的糖果。</p><p>请你给每个孩子分发糖果，计算并返回需要准备的 最少糖果数目 。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">示例 1：</span><br><span class="line">输入：ratings = [1,0,2]</span><br><span class="line">输出：5</span><br><span class="line">解释：你可以分别给第一个、第二个、第三个孩子分发 2、1、2 颗糖果。</span><br><span class="line"></span><br><span class="line">示例 2：</span><br><span class="line">输入：ratings = [1,2,2]</span><br><span class="line">输出：4</span><br><span class="line">解释：你可以分别给第一个、第二个、第三个孩子分发 1、2、1 颗糖果。</span><br><span class="line">     第三个孩子只得到 1 颗糖果，这满足题面中的两个条件。</span><br></pre></td></tr></table></figure><p>这道题的思路其实不难，但是我们不要一次性考虑某个小孩的两边，而是应该一次只考虑一边。</p><ul><li>初始化数组，每人一个糖果。</li><li>先从左往右遍历，如果当前孩子的分值高于左边，则当前孩子的糖果数量是左边孩子+1；</li><li>然后从右边往左边遍历，如果当前孩子的分值高于右边，则当前孩子的糖果数量是<code>max(右边孩子糖果数量+1,当前孩子糖果数量)</code></li></ul><p>为什么从右往左的时候需要进行max判断呢？因为题目需要的是最小的糖果数量，同时也需要满足条件，max判断能保证当前的孩子糖果大于右边，同时也满足大于左边的条件（如果直接等于右边的孩子糖果数量+1，可能会导致它不再满足高于左边孩子的糖果的情况）</p><h3 id="完整代码-4"><a href="#完整代码-4" class="headerlink" title="完整代码"></a>完整代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">candy</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; ratings)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 先给所有人分一个糖果</span></span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">candyArray</span><span class="params">(ratings.size(), <span class="number">1</span>)</span></span>;</span><br><span class="line">        <span class="comment">// 从左往右遍历，如果当前孩子比左边的孩子分数多，则让当前的孩子多分一个糖果</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; ratings.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (ratings[i] &gt; ratings[i - <span class="number">1</span>]) &#123;</span><br><span class="line">                candyArray[i] = candyArray[i - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 从右往左遍历，如果当前孩子比右边孩子分数多，则让当前孩子多分一个糖果</span></span><br><span class="line">        <span class="comment">// 注意这里我们需要从倒数第二个孩子开始，此时它的下标是sz-2</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = ratings.<span class="built_in">size</span>() - <span class="number">2</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="keyword">if</span> (ratings[i] &gt; ratings[i + <span class="number">1</span>]) &#123;</span><br><span class="line">                <span class="comment">// 因为前面已经操作过一次了，此时可能当前孩子的糖果已经比i+1多了，那么就需要判断</span></span><br><span class="line">                <span class="comment">// 不然右边孩子的糖果数量+1小于当前已有糖果时，直接赋值会导致左侧条件不满足。</span></span><br><span class="line">                candyArray[i] = <span class="built_in">max</span>(candyArray[i + <span class="number">1</span>] + <span class="number">1</span>, candyArray[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 计算糖果数量</span></span><br><span class="line">        <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; c : candyArray) &#123;</span><br><span class="line">            count += c;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/04/4090a2a83a429258083e07de6bae402a.png" alt="image.png"></p><h2 id="860-柠檬水找零"><a href="#860-柠檬水找零" class="headerlink" title="860 柠檬水找零"></a>860 柠檬水找零</h2><h3 id="题目和思路-8"><a href="#题目和思路-8" class="headerlink" title="题目和思路"></a>题目和思路</h3><blockquote><p><a href="https://leetcode.cn/problems/lemonade-change/description/">https://leetcode.cn/problems/lemonade-change/description/</a></p></blockquote><p>在柠檬水摊上，每一杯柠檬水的售价为 5 美元。顾客排队购买你的产品，（按账单 bills 支付的顺序）一次购买一杯。</p><p>每位顾客只买一杯柠檬水，然后向你付 5 美元、10 美元或 20 美元。你必须给每个顾客正确找零，也就是说净交易是每位顾客向你支付 5 美元。</p><p>注意，一开始你手头没有任何零钱。</p><p>给你一个整数数组 bills ，其中 bills[i] 是第 i 位顾客付的账。如果你能给每位顾客正确找零，返回 true ，否则返回 false 。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">示例 1：</span><br><span class="line">输入：bills = [5,5,5,10,20]</span><br><span class="line">输出：true</span><br><span class="line">解释：</span><br><span class="line">前 3 位顾客那里，我们按顺序收取 3 张 5 美元的钞票。</span><br><span class="line">第 4 位顾客那里，我们收取一张 10 美元的钞票，并返还 5 美元。</span><br><span class="line">第 5 位顾客那里，我们找还一张 10 美元的钞票和一张 5 美元的钞票。</span><br><span class="line">由于所有客户都得到了正确的找零，所以我们输出 true。</span><br><span class="line"></span><br><span class="line">示例 2：</span><br><span class="line">输入：bills = [5,5,10,10,20]</span><br><span class="line">输出：false</span><br><span class="line">解释：</span><br><span class="line">前 2 位顾客那里，我们按顺序收取 2 张 5 美元的钞票。</span><br><span class="line">对于接下来的 2 位顾客，我们收取一张 10 美元的钞票，然后返还 5 美元。</span><br><span class="line">对于最后一位顾客，我们无法退回 15 美元，因为我们现在只有两张 10 美元的钞票。</span><br><span class="line">由于不是每位顾客都得到了正确的找零，所以答案是 false。</span><br></pre></td></tr></table></figure><p>这道题其实是一个最最基本的数学问题。用到贪心的地方就是有<code>10+5</code>和<code>3*5</code>的时候应该先用哪一个进行找零。很明显我们需要用<code>10+5</code>来找零，因为10元只有这个地方能用上。如果优先用5元找零，后序有人用10元来买柠檬水的时候，可能零钱就不够了。</p><h3 id="完整代码-5"><a href="#完整代码-5" class="headerlink" title="完整代码"></a>完整代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">lemonadeChange</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; bills)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 剩余零钱初始化</span></span><br><span class="line">        unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; momenyMap;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> i : bills) &#123;</span><br><span class="line">            <span class="comment">// 先计入获得的零钱</span></span><br><span class="line">            momenyMap[i]++;</span><br><span class="line">            i -= <span class="number">5</span>;</span><br><span class="line">            <span class="comment">// 原本是10元</span></span><br><span class="line">            <span class="keyword">if</span> (i == <span class="number">5</span>) &#123;</span><br><span class="line">                <span class="comment">// 给她找5元</span></span><br><span class="line">                momenyMap[<span class="number">5</span>]--;</span><br><span class="line">                <span class="comment">// 没有零钱了，不行</span></span><br><span class="line">                <span class="keyword">if</span> (momenyMap[<span class="number">5</span>] &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 原本是20元</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (i == <span class="number">15</span>) &#123;</span><br><span class="line">                <span class="comment">// 先用10元的零钱，因为10元的零钱只有这时候可以用</span></span><br><span class="line">                <span class="keyword">if</span> (momenyMap[<span class="number">10</span>] &gt; <span class="number">0</span> &amp;&amp; momenyMap[<span class="number">5</span>] &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    momenyMap[<span class="number">5</span>]--;</span><br><span class="line">                    momenyMap[<span class="number">10</span>]--;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 如果没有十元的零钱，就用3个5元的零钱</span></span><br><span class="line">                <span class="comment">// 不够用，返回false</span></span><br><span class="line">                <span class="keyword">if</span> (momenyMap[<span class="number">5</span>] &lt; <span class="number">3</span>) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 扣掉零钱</span></span><br><span class="line">                momenyMap[<span class="number">5</span>] -= <span class="number">3</span>;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="452-用最少的箭引爆气球"><a href="#452-用最少的箭引爆气球" class="headerlink" title="452 用最少的箭引爆气球"></a>452 用最少的箭引爆气球</h2><h3 id="题目和思路-9"><a href="#题目和思路-9" class="headerlink" title="题目和思路"></a>题目和思路</h3><blockquote><p><a href="https://leetcode.cn/problems/minimum-number-of-arrows-to-burst-balloons/">https://leetcode.cn/problems/minimum-number-of-arrows-to-burst-balloons/</a></p></blockquote><p>有一些球形气球贴在一堵用 XY 平面表示的墙面上。墙面上的气球记录在整数数组 points ，其中<code>points[i] = [xstart, xend]</code> 表示水平直径在 xstart 和 xend之间的气球。你不知道气球的确切 y 坐标。</p><p>一支弓箭可以沿着 x 轴从不同点 完全垂直 地射出。在坐标 x 处射出一支箭，若有一个气球的直径的开始和结束坐标为<code> xstart，xend</code>， 且满足  <code>xstart ≤ x ≤ xend</code>，则该气球会被 引爆 。可以射出的弓箭的数量 没有限制 。 弓箭一旦被射出之后，可以无限地前进。</p><p>给你一个数组 points ，返回引爆所有气球所必须射出的 最小 弓箭数 。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">示例 1：</span><br><span class="line">输入：points = [[10,16],[2,8],[1,6],[7,12]]</span><br><span class="line">输出：2</span><br><span class="line">解释：气球可以用2支箭来爆破:</span><br><span class="line">-在x = 6处射出箭，击破气球[2,8]和[1,6]。</span><br><span class="line">-在x = 11处发射箭，击破气球[10,16]和[7,12]。</span><br><span class="line"></span><br><span class="line">示例 2：</span><br><span class="line">输入：points = [[1,2],[3,4],[5,6],[7,8]]</span><br><span class="line">输出：4</span><br><span class="line">解释：每个气球需要射出一支箭，总共需要4支箭。</span><br><span class="line"></span><br><span class="line">示例 3：</span><br><span class="line">输入：points = [[1,2],[2,3],[3,4],[4,5]]</span><br><span class="line">输出：2</span><br><span class="line">解释：气球可以用2支箭来爆破:</span><br><span class="line">- 在x = 2处发射箭，击破气球[1,2]和[2,3]。</span><br><span class="line">- 在x = 4处射出箭，击破气球[3,4]和[4,5]。</span><br></pre></td></tr></table></figure><p>首先我们需要对边界进行排序，这里选用左边界升序。</p><p>然后从左往右遍历，根据当前的左边界和上一个值的右边界，确定两个气球是否挨着。</p><ul><li>如果挨着，说明两个气球可以被一起射爆（注意边界值相等也视为重叠），此时需要更新当前值的右边界为<code>min(当前右边界,上一个气球的右边界)</code>，因为只有这样才能保证下一次遍历判断的时候得到的结果，能把之前的两个气球射爆</li><li>如果不挨着，说明前一个气球需要单独一箭，计数器加一。</li></ul><p>这里的贪心思想就是不断的更新边界值，来确保找到更多符合同一边界情况的气球，减少箭矢的使用。</p><h3 id="完整代码-6"><a href="#完整代码-6" class="headerlink" title="完整代码"></a>完整代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">bool</span> <span class="title">cmp</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; a, vector&lt;<span class="type">int</span>&gt;&amp; b)</span> </span>&#123; <span class="keyword">return</span> a[<span class="number">0</span>] &lt; b[<span class="number">0</span>]; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">findMinArrowShots</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; points)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (points.<span class="built_in">size</span>() == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 首先需要按左边界对区间排升序</span></span><br><span class="line">        <span class="built_in">sort</span>(points.<span class="built_in">begin</span>(), points.<span class="built_in">end</span>(), cmp);</span><br><span class="line">        <span class="type">int</span> arrow = <span class="number">1</span>; <span class="comment">// points 不为空至少需要一支箭</span></span><br><span class="line">        <span class="type">int</span> end = points[<span class="number">0</span>][<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; points.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="comment">// 重叠了，更新最小的子区间</span></span><br><span class="line">            <span class="keyword">if</span> (points[i][<span class="number">0</span>] &lt;= end) &#123;</span><br><span class="line">                end = <span class="built_in">min</span>(points[i][<span class="number">1</span>], end);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 不重叠，需要射箭</span></span><br><span class="line">                end = points[i][<span class="number">1</span>];</span><br><span class="line">                arrow++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> arrow;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/04/8279f8e0698fd1c921bf1eafedbed0a9.png" alt="image.png"></p><h2 id="406-根据身高重建队列"><a href="#406-根据身高重建队列" class="headerlink" title="406 根据身高重建队列"></a>406 根据身高重建队列</h2><blockquote><p><a href="https://leetcode.cn/problems/queue-reconstruction-by-height/description/">https://leetcode.cn/problems/queue-reconstruction-by-height/description/</a></p></blockquote><h3 id="题目和思路-10"><a href="#题目和思路-10" class="headerlink" title="题目和思路"></a>题目和思路</h3><p>假设有打乱顺序的一群人站成一个队列，数组 people 表示队列中一些人的属性（不一定按顺序）。每个 people[i] &#x3D; [hi, ki] 表示第 i 个人的身高为 hi ，前面 正好 有 ki 个身高大于或等于 hi 的人。</p><p>请你重新构造并返回输入数组 people 所表示的队列。返回的队列应该格式化为数组 queue ，其中 queue[j] &#x3D; [hj, kj] 是队列中第 j 个人的属性（queue[0] 是排在队列前面的人）。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">示例 1：</span><br><span class="line">输入：people = [[7,0],[4,4],[7,1],[5,0],[6,1],[5,2]]</span><br><span class="line">输出：[[5,0],[7,0],[5,2],[6,1],[4,4],[7,1]]</span><br><span class="line">解释：</span><br><span class="line">编号为 0 的人身高为 5 ，没有身高更高或者相同的人排在他前面。</span><br><span class="line">编号为 1 的人身高为 7 ，没有身高更高或者相同的人排在他前面。</span><br><span class="line">编号为 2 的人身高为 5 ，有 2 个身高更高或者相同的人排在他前面，即编号为 0 和 1 的人。</span><br><span class="line">编号为 3 的人身高为 6 ，有 1 个身高更高或者相同的人排在他前面，即编号为 1 的人。</span><br><span class="line">编号为 4 的人身高为 4 ，有 4 个身高更高或者相同的人排在他前面，即编号为 0、1、2、3 的人。</span><br><span class="line">编号为 5 的人身高为 7 ，有 1 个身高更高或者相同的人排在他前面，即编号为 1 的人。</span><br><span class="line">因此 [[5,0],[7,0],[5,2],[6,1],[4,4],[7,1]] 是重新构造后的队列。</span><br><span class="line"></span><br><span class="line">示例 2：</span><br><span class="line">输入：people = [[6,0],[5,0],[4,0],[3,2],[2,2],[1,4]]</span><br><span class="line">输出：[[4,0],[5,0],[2,2],[3,2],[1,4],[6,0]]</span><br></pre></td></tr></table></figure><p>这道题目和<code>135分发糖果</code>有一定相似，都需要从两个维度来考虑。但为了避免出错，我们一次只能考虑一个维度。</p><p>首先要做的就是对people进行排序，那么是根据身高排序，还是根据前面有几个人排序？</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">用例 [[7,0],[4,4],[7,1],[5,0],[6,1],[5,2]]</span><br><span class="line">身高 [[7,0],[7,1],[6,1],[5,0],[5,2],[4,4]]</span><br><span class="line">人数 [[7,0],[5,0],[7,1],[6,1],[5,2],[4,4]]</span><br></pre></td></tr></table></figure><p>会发现，如果按前面有几个人排序，最终得到的序列好像并没有用，也不是题目需要的序列。</p><p>但根据身高降序排序，会让这里的序列满足一个特性，即元素i之前的都比i高。</p><p>这时候我们就能直接根据元素i之前有几个比他高的人，将这个值视作下标，来构建出新的队列！前面有几个比他高的人，就往第几位之后插入。</p><h3 id="完整代码-7"><a href="#完整代码-7" class="headerlink" title="完整代码"></a>完整代码</h3><p>注意这里使用链表来进行插入操作，效率会更高。因为vector每次的insert都需要对元素进行移动，甚至会涉及到空间扩容的消耗（所以我提前reserve了），而list不会有这个问题。</p><p>我们可以先用list来进行插入操作，最后再用迭代器构造vector返回。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">bool</span> <span class="title">cmp</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; a, vector&lt;<span class="type">int</span>&gt;&amp; b)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 按身高升序排序</span></span><br><span class="line">        <span class="keyword">if</span> (a[<span class="number">0</span>] &gt; b[<span class="number">0</span>]) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果身高一样，前面的人少的排前面</span></span><br><span class="line">        <span class="keyword">if</span> (a[<span class="number">0</span>] == b[<span class="number">0</span>]) &#123;</span><br><span class="line">            <span class="keyword">return</span> a[<span class="number">1</span>] &lt; b[<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">reconstructQueue</span>(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; people) &#123;</span><br><span class="line">        <span class="comment">// 按身高降序+前面人的个数升序排列</span></span><br><span class="line">        <span class="built_in">sort</span>(people.<span class="built_in">begin</span>(), people.<span class="built_in">end</span>(), cmp);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; v : people) &#123;</span><br><span class="line">            cout &lt;&lt; v[<span class="number">0</span>] &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; v[<span class="number">1</span>] &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; que;</span><br><span class="line">        que.<span class="built_in">reserve</span>(people.<span class="built_in">size</span>()); <span class="comment">// 提前开空间</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; people.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="comment">// 前面有几个人，就往第几位插入</span></span><br><span class="line">            <span class="type">int</span> offset = people[i][<span class="number">1</span>];</span><br><span class="line">            que.<span class="built_in">insert</span>(que.<span class="built_in">begin</span>() + offset, people[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> que;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>链表版本</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">bool</span> <span class="title">cmp</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; a, vector&lt;<span class="type">int</span>&gt;&amp; b)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 按身高升序排序</span></span><br><span class="line">        <span class="keyword">if</span> (a[<span class="number">0</span>] &gt; b[<span class="number">0</span>]) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果身高一样，前面的人少的排前面</span></span><br><span class="line">        <span class="keyword">if</span> (a[<span class="number">0</span>] == b[<span class="number">0</span>]) &#123;</span><br><span class="line">            <span class="keyword">return</span> a[<span class="number">1</span>] &lt; b[<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">reconstructQueue</span>(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; people) &#123;</span><br><span class="line">        <span class="comment">// 按身高降序+前面人的个数升序排列</span></span><br><span class="line">        <span class="built_in">sort</span>(people.<span class="built_in">begin</span>(), people.<span class="built_in">end</span>(), cmp);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; v : people) &#123;</span><br><span class="line">            cout &lt;&lt; v[<span class="number">0</span>] &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; v[<span class="number">1</span>] &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        list&lt;vector&lt;<span class="type">int</span>&gt;&gt; que;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; people.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="comment">// 前面有几个人，就往第几位插入</span></span><br><span class="line">            <span class="type">int</span> offset = people[i][<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">auto</span> itr = que.<span class="built_in">begin</span>();</span><br><span class="line">            <span class="keyword">while</span>(offset--)&#123;</span><br><span class="line">                itr++;</span><br><span class="line">            &#125;</span><br><span class="line">            que.<span class="built_in">insert</span>(itr, people[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;(que.<span class="built_in">begin</span>(),que.<span class="built_in">end</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="435-无重叠区间"><a href="#435-无重叠区间" class="headerlink" title="435 无重叠区间"></a>435 无重叠区间</h2><h3 id="题目和思路-11"><a href="#题目和思路-11" class="headerlink" title="题目和思路"></a>题目和思路</h3><blockquote><p><a href="https://leetcode.cn/problems/non-overlapping-intervals/">https://leetcode.cn/problems/non-overlapping-intervals/</a></p></blockquote><p>给定一个区间的集合 intervals ，其中 <code>intervals[i] = [starti, endi]</code> 。返回 需要移除区间的最小数量，使剩余区间互不重叠 。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">示例 1:</span><br><span class="line">输入: intervals = [[1,2],[2,3],[3,4],[1,3]]</span><br><span class="line">输出: 1</span><br><span class="line">解释: 移除 [1,3] 后，剩下的区间没有重叠。</span><br><span class="line"></span><br><span class="line">示例 2:</span><br><span class="line">输入: intervals = [ [1,2], [1,2], [1,2] ]</span><br><span class="line">输出: 2</span><br><span class="line">解释: 你需要移除两个 [1,2] 来使剩下的区间没有重叠。</span><br><span class="line"></span><br><span class="line">示例 3:</span><br><span class="line">输入: intervals = [ [1,2], [2,3] ]</span><br><span class="line">输出: 0</span><br><span class="line">解释: 你不需要移除任何区间，因为它们已经是无重叠的了。</span><br></pre></td></tr></table></figure><p>这道题和前文射爆气球的题目很相似，但是需要注意，在射爆气球那道题中，边界值相同视作重叠。而本题边界值相同不视作重叠区间。</p><p>还是用左边界升序排序，记录重叠的区间的数量，即需要删除的区间数量。</p><p>判断到重叠区间的时候，也需要将边界值更新为区间最小右边界。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">end = <span class="built_in">min</span>(intervals[i][<span class="number">1</span>],end);</span><br></pre></td></tr></table></figure><p>因为我们发现两个区间重叠的时候，我们应该删除区间范围（只考虑右边界）最大的那个，才能尽可能的避免当前的这个重叠区间进一步和其他节点重叠。</p><p>题目需要求的是最少需要删除的区间数量，贪心的思想也是在此，每次都删除右边界更大的那个区间，才能保证最终删除的区间数量最少。</p><h3 id="完整代码-8"><a href="#完整代码-8" class="headerlink" title="完整代码"></a>完整代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">bool</span> <span class="title">cmp</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; a, vector&lt;<span class="type">int</span>&gt;&amp; b)</span> </span>&#123; <span class="keyword">return</span> a[<span class="number">0</span>] &lt; b[<span class="number">0</span>]; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">eraseOverlapIntervals</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; intervals)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (intervals.<span class="built_in">size</span>() &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 按左边界升序排序</span></span><br><span class="line">        <span class="built_in">sort</span>(intervals.<span class="built_in">begin</span>(), intervals.<span class="built_in">end</span>(), cmp);</span><br><span class="line">        <span class="comment">// 直接统计重叠区间有哪些</span></span><br><span class="line">        <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> end = intervals[<span class="number">0</span>][<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; intervals.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="comment">// 重叠区间</span></span><br><span class="line">            <span class="keyword">if</span> (intervals[i][<span class="number">0</span>] &lt; end) &#123;</span><br><span class="line">                count++;</span><br><span class="line">                <span class="comment">// 重叠的时候，需要更新最小的边界值</span></span><br><span class="line">                <span class="comment">// 因为我们假设移除那个边界值更大的节点，这样就能最大限度的避免重叠</span></span><br><span class="line">                <span class="comment">// 比如[[1,2],[2,3],[3,4],[1,3]]中，1,2和1,3重叠，我们应该移除1,3才是正确的</span></span><br><span class="line">                <span class="comment">// 此时就应该将2作为边界值继续判断，相当于保留1,2节点</span></span><br><span class="line">                end = <span class="built_in">min</span>(intervals[i][<span class="number">1</span>],end);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="comment">// 不重叠，更新边界值</span></span><br><span class="line">            &#123;</span><br><span class="line">                end = intervals[i][<span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/04/51943b3301f8319a3fdf388178a0ddf4.png" alt="image.png"></p><h2 id="763-划分字母区间"><a href="#763-划分字母区间" class="headerlink" title="763 划分字母区间"></a>763 划分字母区间</h2><h3 id="题目和思路-12"><a href="#题目和思路-12" class="headerlink" title="题目和思路"></a>题目和思路</h3><blockquote><p><a href="https://leetcode.cn/problems/partition-labels/description/">https://leetcode.cn/problems/partition-labels/description/</a></p></blockquote><p>给你一个字符串 s 。我们要把这个字符串划分为尽可能多的片段，同一字母最多出现在一个片段中。</p><p>注意，划分结果需要满足：将所有划分结果按顺序连接，得到的字符串仍然是 s 。</p><p>返回一个表示每个字符串片段的长度的列表。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">示例 1：</span><br><span class="line">输入：s = &quot;ababcbacadefegdehijhklij&quot;</span><br><span class="line">输出：[9,7,8]</span><br><span class="line">解释：</span><br><span class="line">划分结果为 &quot;ababcbaca&quot;、&quot;defegde&quot;、&quot;hijhklij&quot; 。</span><br><span class="line">每个字母最多出现在一个片段中。</span><br><span class="line">像 &quot;ababcbacadefegde&quot;, &quot;hijhklij&quot; 这样的划分是错误的，因为划分的片段数较少。 </span><br><span class="line"></span><br><span class="line">示例 2：</span><br><span class="line">输入：s = &quot;eccbbbbdec&quot;</span><br><span class="line">输出：[10]</span><br></pre></td></tr></table></figure><p>这道题的思路是，先遍历一次字符串，维护一个相同长度的字母最远出现位置（下标）的数组。</p><p>以题目给出的示例1为例，按照如上思路可以维护出一个这样的数组。</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/04/98c1a314b0c2c2f8be0f2012f0da26e2.png" alt="image.png"></p><p>再次遍历字符串，最开始start为0，以<code>[start,i]</code>为一个区间，维护一个这个<strong>区间中</strong>字母的<strong>最远出现位置</strong>，当i等于当前的“最远出现位置”时，说明已经得到了一个可分割的子区间，更新start为i+1，继续遍历下一个区间。</p><ul><li>为什么i等于当前最远出现位置时就找到了一个可分割的子序列呢？</li></ul><p>还是看示例1，观察图中被标红的位置，这些都是可以进行分割的位置。当我们遍历<code>[0,8]</code>这个区间时，维护的这个区间中字母最远出现位置就是8，当i等于8的时候，对应字符的最远出现位置也是8，说明在这个区间中，没有其他字符最远出现的位置大于8了，即符合题目中给出的“每个字母只在其中一个区间出现”的要求。</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/04/98c1a314b0c2c2f8be0f2012f0da26e2.png" alt="image.png"></p><p>这里并没有用到贪心思路，而是根据题意进行的一个模拟。</p><h3 id="完整代码-9"><a href="#完整代码-9" class="headerlink" title="完整代码"></a>完整代码</h3><p>注意这道题干说了字符串只包含因英文小写字母，所以使用一个定长的数组，效率会高于<code>unordered_map</code>数据结构。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">partitionLabels</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 统计每个字符最远出现的下标位置</span></span><br><span class="line">        <span class="comment">// unordered_map&lt;char, int&gt; indexMap;</span></span><br><span class="line">        <span class="type">int</span> indexMap[<span class="number">27</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; s.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            indexMap[s[i]-<span class="string">&#x27;a&#x27;</span>] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 遍历下标数组，如果当前数组的元素值和下标值相同，则找到了一个切割点</span></span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; retV;</span><br><span class="line">        <span class="type">int</span> start = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> end = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; s.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="comment">// 每一次都是在start,end范围内，找已经出现过的字符的最远出现位置</span></span><br><span class="line">            <span class="comment">// 如果最终i等于end了，说明当前字符是之前出现过的字符最后出现过的一个位置</span></span><br><span class="line">            <span class="comment">// 在当前字符之后，是不会有其他已经出现过的字符的，不然这里的max就没有意义了</span></span><br><span class="line">            end = <span class="built_in">max</span>(end, indexMap[s[i]-<span class="string">&#x27;a&#x27;</span>]);</span><br><span class="line">            <span class="keyword">if</span> (i == end) &#123;</span><br><span class="line">                retV.<span class="built_in">push_back</span>(i - start + <span class="number">1</span>); <span class="comment">// 插入长度</span></span><br><span class="line">                start = i + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> retV;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/04/591cb30a642d04b6003ca73436a1deb9.png" alt="image.png"></p><h2 id="56-合并区间"><a href="#56-合并区间" class="headerlink" title="56 合并区间"></a>56 合并区间</h2><blockquote><p><a href="https://leetcode.cn/problems/merge-intervals/">https://leetcode.cn/problems/merge-intervals/</a></p></blockquote><h3 id="题目和思路-13"><a href="#题目和思路-13" class="headerlink" title="题目和思路"></a>题目和思路</h3><p>以数组 intervals 表示若干个区间的集合，其中单个区间为 <code>intervals[i] = [starti, endi]</code> 。请你合并所有重叠的区间，并返回 一个不重叠的区间数组，该数组需恰好覆盖输入中的所有区间 。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">示例 1：</span><br><span class="line">输入：intervals = [[1,3],[2,6],[8,10],[15,18]]</span><br><span class="line">输出：[[1,6],[8,10],[15,18]]</span><br><span class="line">解释：区间 [1,3] 和 [2,6] 重叠, 将它们合并为 [1,6].</span><br><span class="line"></span><br><span class="line">示例 2：</span><br><span class="line">输入：intervals = [[1,4],[4,5]]</span><br><span class="line">输出：[[1,5]]</span><br><span class="line">解释：区间 [1,4] 和 [4,5] 可被视为重叠区间。</span><br></pre></td></tr></table></figure><p>这道题和前面遇到的几个区间重叠的问题一致，都是需要先对给出数组按左区间进行排序，再判断重叠区间，最终将重叠的区间进行合并。</p><p>当<code>intervals[i][0] &lt;= intervals[i-1][1]</code>的时候，视作两个区间重叠（相同也是重叠的情况），此时需要扩展原有区间为<code>max(intervals[i][1],intervals[i-1][1])</code>，再继续向后遍历。</p><h3 id="完整代码-10"><a href="#完整代码-10" class="headerlink" title="完整代码"></a>完整代码</h3><p>注意vector是有front&#x2F;back这两个函数来访问第一个&#x2F;最后一个元素的，<strong>且返回的是引用</strong>，写<code>retV.back()</code>的代码可读性会好于<code>retV[retV.size()-1]</code>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="comment">// 注意sort中升序是小于，降序是大于</span></span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">bool</span> <span class="title">cmp</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; a, vector&lt;<span class="type">int</span>&gt;&amp; b)</span> </span>&#123; <span class="keyword">return</span> a[<span class="number">0</span>] &lt; b[<span class="number">0</span>]; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">merge</span>(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; intervals) &#123;</span><br><span class="line">        <span class="keyword">if</span> (intervals.<span class="built_in">size</span>() &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> intervals;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">sort</span>(intervals.<span class="built_in">begin</span>(), intervals.<span class="built_in">end</span>(), cmp);</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; retV; <span class="comment">// 结果集</span></span><br><span class="line">        <span class="comment">// 先直接把第一个元素插入</span></span><br><span class="line">        retV.<span class="built_in">push_back</span>(intervals[<span class="number">0</span>]);</span><br><span class="line">        <span class="comment">// 从第二个元素开始遍历</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; intervals.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="comment">// 判断当前区间是否小于结果集中上一个的边界</span></span><br><span class="line">            <span class="keyword">if</span> (intervals[i][<span class="number">0</span>] &lt;= retV.<span class="built_in">back</span>()[<span class="number">1</span>]) &#123;</span><br><span class="line">                <span class="comment">// 如果小于，更新为两个值中更大的那个</span></span><br><span class="line">                retV.<span class="built_in">back</span>()[<span class="number">1</span>] = <span class="built_in">max</span>(intervals[i][<span class="number">1</span>], retV.<span class="built_in">back</span>()[<span class="number">1</span>]);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="comment">// 不小于，插入结果集</span></span><br><span class="line">            &#123;</span><br><span class="line">                retV.<span class="built_in">push_back</span>(intervals[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> retV;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/04/24f7470bf9f4043065640d9429b85037.png" alt="image.png"></p><h2 id="738-单调递增的数字"><a href="#738-单调递增的数字" class="headerlink" title="738 单调递增的数字"></a>738 单调递增的数字</h2><blockquote><p><a href="https://leetcode.cn/problems/monotone-increasing-digits/description/">https://leetcode.cn/problems/monotone-increasing-digits/description/</a></p></blockquote><h3 id="题目和思路-14"><a href="#题目和思路-14" class="headerlink" title="题目和思路"></a>题目和思路</h3><p>当且仅当每个相邻位数上的数字 x 和 y 满足 x &lt;&#x3D; y 时，我们称这个整数是单调递增的。</p><p>给定一个整数 n ，返回 小于或等于 n 的最大数字，且数字呈 单调递增 。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">示例 1:</span><br><span class="line">输入: n = 10</span><br><span class="line">输出: 9</span><br><span class="line"></span><br><span class="line">示例 2:</span><br><span class="line">输入: n = 1234</span><br><span class="line">输出: 1234</span><br><span class="line"></span><br><span class="line">示例 3:</span><br><span class="line">输入: n = 332</span><br><span class="line">输出: 299</span><br></pre></td></tr></table></figure><p>这道题需要我们<strong>从后往前</strong>遍历一个数字，方便处理，我们可以先把数字转成一个字符串（当然遍历一下写入到数组中也是可以的）。</p><ul><li>当前位大于上一位，不处理</li><li>当前位小于上一位，将上一位减一，当前位可以设置为9</li></ul><p>因为题目中给出的递增数字中，<code>x99999</code>也算做递增的情况，所以第二种情况，可以先记录一下当前的下标，并使用第二个循环从这个下标位置开始往后全部都设置为9。</p><h3 id="完整代码-11"><a href="#完整代码-11" class="headerlink" title="完整代码"></a>完整代码</h3><p>代码如下，不算难写。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">monotoneIncreasingDigits</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        string s = <span class="built_in">to_string</span>(n);</span><br><span class="line">        <span class="comment">// 从后往前遍历</span></span><br><span class="line">        <span class="type">int</span> start = s.<span class="built_in">size</span>() + <span class="number">1</span>; <span class="comment">// 初始化为不会进入第二个循环的值</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = s.<span class="built_in">size</span>() - <span class="number">1</span>; i &gt;= <span class="number">1</span>; i--) &#123;</span><br><span class="line">            <span class="comment">// 对于ascii来说也是增加的，所以可以直接判断</span></span><br><span class="line">            <span class="keyword">if</span> (s[i - <span class="number">1</span>] &gt; s[i]) &#123;</span><br><span class="line">                s[i - <span class="number">1</span>]--;</span><br><span class="line">                start = i; <span class="comment">// 从这一位开始设置9</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 从start开始遍历，设置9，注意x99999也视作递增序列</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = start; i &lt; s.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            s[i] = <span class="string">&#x27;9&#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">atoi</span>(s.<span class="built_in">c_str</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/04/a55a84276ea4632ff6f95b747c348bc0.png" alt="image.png"></p><p>写完这个代码后，我想到了一个问题，有没有可能<code>s[i-1]=&#39;0&#39;</code>，这样减减一下岂不是上一位就不是数字了？</p><p>实际上是不可能出现这个情况的，如果<code>s[i-1]=&#39;0&#39;</code>的情况，当前位<code>s[i]</code>是不可能小于他的，最多是等于的情况（两个都是零），所以不会出现操作0减减，自然不会有问题。</p><h2 id="968-监控二叉树"><a href="#968-监控二叉树" class="headerlink" title="968 监控二叉树"></a>968 监控二叉树</h2><blockquote><p><a href="https://leetcode.cn/problems/binary-tree-cameras/description/">https://leetcode.cn/problems/binary-tree-cameras/description/</a></p></blockquote><h3 id="题目和代码"><a href="#题目和代码" class="headerlink" title="题目和代码"></a>题目和代码</h3><p>给定一个二叉树，我们在树的节点上安装摄像头。</p><p>节点上的每个摄影头都可以监视其父对象、自身及其直接子对象。</p><p>计算监控树的所有节点所需的最小摄像头数量。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">这道题的示例建议看leetcode上给出的图例。</span><br><span class="line"></span><br><span class="line">输入：[0,0,null,0,0]</span><br><span class="line">输出：1</span><br><span class="line">解释：如图所示，一台摄像头足以监控所有节点。</span><br></pre></td></tr></table></figure><p>本题需要我们计算监控所有节点涉及到的最少的摄像头数量，那么一个摄像头最好是能同时监控下层和上层（没有漏掉的层），<strong>才是利用率最大化</strong>。这也是贪心的思想所在。首先可以确定的是，我们需要用<strong>后续遍历</strong>，从最底下开始往上遍历整个树。</p><p>根据这个思路，<strong>叶子节点肯定不能装摄像头</strong>。因为叶子节点没有子树，装摄像头相当于白白浪费了摄像头对下一层子树的监看，最终肯定不能达到最大的监控数量。</p><p>这个思路能帮我们确定递归的终止条件，即在空节点应该返回什么。不过在编写代码之前，我们应该先定义好三个状态值。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">0 没有监控也没有被覆盖上</span><br><span class="line">1 装了监控</span><br><span class="line">2 被覆盖上了（但是没有装监控）</span><br></pre></td></tr></table></figure><p>那么空节点应该返回哪一个状态码呢？先来考虑一下什么时候当前节点需要装摄像头</p><ul><li>左子树和右子树只要有其中一个装了摄像头（返回值为1），当前节点就能被覆盖上，不需要装摄像头；</li><li>右子树和左子树只要有一个没有被覆盖上（返回值为0），那么当前节点就必须装摄像头，<strong>否则会有子树无法被覆盖</strong>；</li></ul><p>由此可见，空节点不能返回1，因为这说明叶子节点被覆盖了，反馈到上一层会认为不需要装摄像头，导致最终叶子节点并没有被覆盖上，不符合题目条件。空节点也不能返回0，因为这说明叶子节点需要装摄像头。</p><p>所以，空节点只能返回2啦！</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(root == <span class="literal">nullptr</span>)&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其他情况就是上文提到的，采用后续遍历，用left&#x2F;right接受左右子树遍历的结果，只要有一个为0，那么就需要装摄像头，摄像头数量加一，函数返回1；</p><p>最后是只要有一个为1，就代表不用装摄像头，返回2；</p><h3 id="完整代码-12"><a href="#完整代码-12" class="headerlink" title="完整代码"></a>完整代码</h3><p>依照上述思路可以写出如下代码。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="comment">// 0代表没有被摄像头覆盖</span></span><br><span class="line">    <span class="comment">// 1代表有摄像头</span></span><br><span class="line">    <span class="comment">// 2代表被摄像头覆盖（但是没有装摄像头）</span></span><br><span class="line">    <span class="type">int</span> _minCameraCoverResult(TreeNode* root, <span class="type">int</span>&amp; result) &#123;</span><br><span class="line">        <span class="comment">// 空节点视作被摄像头覆盖了（题目不需要考虑空节点）</span></span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 后续遍历</span></span><br><span class="line">        <span class="type">int</span> left = _minCameraCoverResult(root-&gt;left, result);</span><br><span class="line">        <span class="type">int</span> right = _minCameraCoverResult(root-&gt;right, result);</span><br><span class="line">        <span class="comment">// 判断当前节点是否需要装摄像头</span></span><br><span class="line">        <span class="comment">// 1.如果两个都是2，代表当前节点不需要装摄像头（不然会损失一层覆盖），返回0</span></span><br><span class="line">        <span class="keyword">if</span> (left == <span class="number">2</span> &amp;&amp; right == <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">// 当前节点不装摄像头也没有被覆盖</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 2.如果两个节点中有一个是0，则代表当前节点必须装摄像头才能覆盖到下一层的节点</span></span><br><span class="line">        <span class="keyword">if</span> (left == <span class="number">0</span> || right == <span class="number">0</span>) &#123;</span><br><span class="line">            result++; <span class="comment">// 当前节点需要装摄像头</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 注意必须先判断两个其中有一个为0的情况，因为这种情况是必须装摄像头的；</span></span><br><span class="line">        <span class="comment">// 比如：一个为1一个为0，虽然此时本层已经被覆盖，但有一个子树没有覆盖上，本层必须装摄像头</span></span><br><span class="line">        <span class="comment">// 3.两个节点中其中一个是1，说明当前节点已经被覆盖上，不需要装摄像头</span></span><br><span class="line">        <span class="keyword">if</span> (left == <span class="number">1</span> || right == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">// 理论上不会走到这里</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">minCameraCover</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> result = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 如果当前位是0（没有覆盖上，即root节点没有被覆盖）</span></span><br><span class="line">        <span class="keyword">if</span> (_minCameraCoverResult(root, result) == <span class="number">0</span>) &#123;</span><br><span class="line">            result++; <span class="comment">// root节点装摄像头</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/04/eeedb0da2db9105ff8ce3ddc422ae219.png" alt="image.png"></p>]]></content>
    
    
    <summary type="html">学习贪心算法</summary>
    
    
    
    <category term="编程学习" scheme="https://blog.musnow.top/categories/%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="默认分组" scheme="https://blog.musnow.top/categories/%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0/%E9%BB%98%E8%AE%A4%E5%88%86%E7%BB%84/"/>
    
    
    <category term="算法" scheme="https://blog.musnow.top/tags/%E7%AE%97%E6%B3%95/"/>
    
    <category term="leetcode" scheme="https://blog.musnow.top/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>【win】windows11让蓝牙耳机不进入通话模式</title>
    <link href="https://blog.musnow.top/posts/137069193/"/>
    <id>https://blog.musnow.top/posts/137069193/</id>
    <published>2024-04-06T01:07:34.000Z</published>
    <updated>2024-04-06T01:16:18.000Z</updated>
    
    <content type="html"><![CDATA[<p>在windows上让蓝牙耳机不进入通话模式。</p><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>如果你在windows上使用过蓝牙耳机打游戏，你会发现在部分游戏中（比如战地2042），耳机会进入<strong>通话模式</strong>，音质巨差无比。</p><p>这是因为该游戏将麦克风设置为了蓝牙耳机，让耳机进入了通话模式。</p><blockquote><p>PS：作为娱乐玩家，蓝牙耳机的延迟对于我来说是无感的。</p></blockquote><p>实际上，win对蓝牙的支持本来就是一坨，即便用耳机麦克风也什么都听不清，还不如用笔记本电脑自己的麦克风。要知道，现在的笔记本（基本上）都有2到4个阵列麦克风，在正常使用场景下，笔记本麦大概率优于windows下使用蓝牙耳机的麦。</p><blockquote><p>如果你是台式，个人建议买带耳麦的有线&#x2F;2.4G游戏耳机或另购麦克风</p></blockquote><p>所以现在要解决的就是，如何让游戏无法使用蓝牙耳机的麦克风，避免蓝牙耳机进入通话模式。</p><h2 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h2><p>解决方法很粗暴：让windows不能将蓝牙耳机识别成音频输入设备，只能作为音频输出设备。</p><p>windows11进入系统<strong>设置-声音</strong>模块，在<code>输入</code>中找到你的蓝牙耳机，点击它，会进入属性页面，勾选不允许windows将设备用于音频（这只会关掉蓝牙耳机的麦克风）</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/04/0b8fcad25c745125217b5927502da036.png" alt="image.png"></p><p>勾选完毕后，回到<code>设置-声音</code>页面，你应该会发现输入设备中已经没有蓝牙耳机了</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/04/81e1f76aecdd6bf9ed90cb9c383af1d7.png" alt="image.png"></p><p>这样就OK了，你的蓝牙耳机再也不会进入通话模式了。</p>]]></content>
    
    
    <summary type="html">windows11让蓝牙耳机不进入通话模式</summary>
    
    
    
    <category term="差生文具多" scheme="https://blog.musnow.top/categories/%E5%B7%AE%E7%94%9F%E6%96%87%E5%85%B7%E5%A4%9A/"/>
    
    <category term="电脑使用小贴士" scheme="https://blog.musnow.top/categories/%E5%B7%AE%E7%94%9F%E6%96%87%E5%85%B7%E5%A4%9A/%E7%94%B5%E8%84%91%E4%BD%BF%E7%94%A8%E5%B0%8F%E8%B4%B4%E5%A3%AB/"/>
    
    
    <category term="windows" scheme="https://blog.musnow.top/tags/windows/"/>
    
  </entry>
  
  <entry>
    <title>【leetcode】295.数据流的中位数</title>
    <link href="https://blog.musnow.top/posts/196461022/"/>
    <id>https://blog.musnow.top/posts/196461022/</id>
    <published>2024-03-30T07:05:54.000Z</published>
    <updated>2024-03-30T07:05:54.000Z</updated>
    
    <content type="html"><![CDATA[<p> leetcode题295.数据流的中位数</p><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><blockquote><p><a href="https://leetcode.cn/problems/find-median-from-data-stream/">295. 数据流的中位数</a></p></blockquote><p><strong>中位数</strong>是有序整数列表中的中间值。如果列表的大小是偶数，则没有中间值，中位数是两个中间值的平均值。</p><ul><li>例如 <code>arr = [2,3,4]</code> 的中位数是 <code>3</code> 。</li><li>例如 <code>arr = [2,3]</code> 的中位数是 <code>(2 + 3) / 2 = 2.5</code> 。</li></ul><p>实现 MedianFinder 类:</p><ul><li><code>MedianFinder() </code>初始化 <code>MedianFinder</code> 对象。</li><li><code>void addNum(int num)</code> 将数据流中的整数 <code>num</code> 添加到数据结构中。</li><li><code>double findMedian()</code> 返回到目前为止所有元素的中位数。与实际答案相差 <code>10^-5</code> 以内的答案将被接受。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">示例 1：</span><br><span class="line">输入</span><br><span class="line">[&quot;MedianFinder&quot;, &quot;addNum&quot;, &quot;addNum&quot;, &quot;findMedian&quot;, &quot;addNum&quot;, &quot;findMedian&quot;]</span><br><span class="line">[[], [1], [2], [], [3], []]</span><br><span class="line">输出</span><br><span class="line">[null, null, null, 1.5, null, 2.0]</span><br><span class="line"></span><br><span class="line">解释</span><br><span class="line">MedianFinder medianFinder = new MedianFinder();</span><br><span class="line">medianFinder.addNum(1);    // arr = [1]</span><br><span class="line">medianFinder.addNum(2);    // arr = [1, 2]</span><br><span class="line">medianFinder.findMedian(); // 返回 1.5 ((1 + 2) / 2)</span><br><span class="line">medianFinder.addNum(3);    // arr[1, 2, 3]</span><br><span class="line">medianFinder.findMedian(); // return 2.0</span><br></pre></td></tr></table></figure><p><strong>提示:</strong></p><ul><li><code>-10^5 &lt;= num &lt;= 10^5</code>;</li><li>在调用 <code>findMedian</code> 之前，数据结构中至少有一个元素;</li><li>最多 <code>5 * 104</code> 次调用 <code>addNum</code> 和 <code>findMedian</code>;</li></ul><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>来自k神的题解 <a href="https://leetcode.cn/problems/find-median-from-data-stream/solutions/2361972/295-shu-ju-liu-de-zhong-wei-shu-dui-qing-gmdo/">https://leetcode.cn/problems/find-median-from-data-stream/solutions/2361972/295-shu-ju-liu-de-zhong-wei-shu-dui-qing-gmdo/</a> ，用两个堆来解决这个问题。</p><p>首要的思想是，我们需要将数组流存入一个有序的数组，再确定中位数。不用堆的情况下，我们可以利用插入排序的思想，将新数据插入到数组中的正确位置。这涉及到<code>O(N)</code>的数组中元素的移动，以及利用二分查找数组的插入位置<code>O(LogN)</code>。总的时间复杂度是<code>O(logN+N)</code></p><p>使用两个堆，就可以将整体的时间复杂度控制在<code>O(logN)</code>上，一定程度上能提高效率。</p><ul><li>小堆A用来存放数组大的那一部分数据（你可以理解为堆内元素是倒序，堆顶是最小的数）</li><li>大堆B用来存放数组小的那一部分的数据（堆内元素是正序，堆顶是最大的数）</li><li>A中的所有数据都必须大于B</li></ul><p>此时小堆A对着大堆B，就构成了一个完整的“有序数组”。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">小堆A [6,5,4]   [3,2,1] 大堆B</span><br><span class="line">   小堆堆顶4    大堆堆顶3</span><br></pre></td></tr></table></figure><p>插入的时候，约定小堆A的元素数量应该大于大堆B，分为奇数和偶数的情况</p><ul><li>A和B的大小相等，说明当前数据流数量是偶数，往A中插入元素<ul><li>需要先将待插入元素num和B的堆顶元素比较（确保A中是数组大的那一部分的数据）</li><li>如果num大于B的堆顶元素，则直接插入A；</li><li>如果num小于B的堆顶元素，则插入B后，往A内插入B的堆顶元素，再弹出B的堆顶元素；</li></ul></li><li>A的元素个数大于B，说明当前数据流数量是奇数，往B中插入元素<ul><li>将插入元素和A的堆顶元素比较</li><li>如果num大于A的堆顶元素，则将A的堆顶元素插入B，弹出A的堆顶元素，再将num插入A；</li><li>如果num小于A的堆顶元素，则将num直接插入B</li></ul></li></ul><p>查询中位数的时候，也分为奇数和偶数的情况，注意题目要求的返回值是double</p><ul><li>A和B的元素个数相等，说明是偶数，中位数为<code>(A堆顶元素+B堆顶元素)/2.0</code>；</li><li>A和B的元素个数不相等（肯定是A的元素多），说明是奇数，中位数为<code>A的堆顶元素*1.0</code>。</li></ul><p>思路会了，写代码就不难了。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>注意cpp中优先级队列默认是大堆，且std库中提供了less和greater作为堆的比较函数</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MedianFinder</span> &#123;</span><br><span class="line">    <span class="comment">// 注意优先级队列C++中默认的比较函数是less，存放的是大堆</span></span><br><span class="line">    priority_queue&lt;<span class="type">int</span>&gt; _queBig; <span class="comment">// 大堆，存放小半边数据</span></span><br><span class="line">    priority_queue&lt;<span class="type">int</span>, vector&lt;<span class="type">int</span>&gt;, std::greater&lt;<span class="type">int</span>&gt;&gt;</span><br><span class="line">        _queSm; <span class="comment">// 小堆，存放大半边数据</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MedianFinder</span>() &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 保证较大的一半数据更多</span></span><br><span class="line">    <span class="comment">// 奇数的时候较大的一半堆顶就是中位数</span></span><br><span class="line">    <span class="comment">// 偶数的时候，较小+较大堆顶/2就是中位数</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">addNum</span><span class="params">(<span class="type">int</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (_queBig.<span class="built_in">size</span>() == _queSm.<span class="built_in">size</span>()) &#123;</span><br><span class="line">            <span class="comment">// 注意sm存放的是大的那一半</span></span><br><span class="line">            <span class="comment">// _queSm.push(num);</span></span><br><span class="line">            <span class="comment">// error！不能直接插入!</span></span><br><span class="line">            <span class="comment">// 先把num插入到big里面，再把big里面最大的那个数插入到sm里面！</span></span><br><span class="line">            <span class="comment">// 因为需要保证有序，如果直接插入，此时num的值可能比big里面的堆顶元素小！</span></span><br><span class="line">            _queBig.<span class="built_in">push</span>(num);</span><br><span class="line">            _queSm.<span class="built_in">push</span>(_queBig.<span class="built_in">top</span>());</span><br><span class="line">            _queBig.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 大的那一半数据更多</span></span><br><span class="line">        <span class="comment">// 注意sm存放的是大的那一半</span></span><br><span class="line">        <span class="keyword">if</span> (_queBig.<span class="built_in">size</span>() &lt; _queSm.<span class="built_in">size</span>()) &#123;</span><br><span class="line">            <span class="comment">// 如果当前数比大堆堆顶的更大，则需要放到大的那一半中</span></span><br><span class="line">            <span class="keyword">if</span> (num &gt; _queSm.<span class="built_in">top</span>()) &#123;</span><br><span class="line">                _queBig.<span class="built_in">push</span>(_queSm.<span class="built_in">top</span>());</span><br><span class="line">                _queSm.<span class="built_in">pop</span>();</span><br><span class="line">                _queSm.<span class="built_in">push</span>(num);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 其他情况都往小的那一半里面插</span></span><br><span class="line">            _queBig.<span class="built_in">push</span>(num);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">double</span> <span class="title">findMedian</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (_queBig.<span class="built_in">size</span>() == _queSm.<span class="built_in">size</span>()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">double</span>((_queBig.<span class="built_in">top</span>() + _queSm.<span class="built_in">top</span>()) / <span class="number">2.0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// sm才是大的那一半</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">double</span>(_queSm.<span class="built_in">top</span>() * <span class="number">1.0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your MedianFinder object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * MedianFinder* obj = new MedianFinder();</span></span><br><span class="line"><span class="comment"> * obj-&gt;addNum(num);</span></span><br><span class="line"><span class="comment"> * double param_2 = obj-&gt;findMedian();</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/03/ab2c48575f9575470fc55b39f21268dc.png" alt="image-20240330163821849"></p>]]></content>
    
    
    <summary type="html">leetcode题295.数据流的中位数</summary>
    
    
    
    <category term="编程学习" scheme="https://blog.musnow.top/categories/%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="把题目都给刷干净" scheme="https://blog.musnow.top/categories/%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0/%E6%8A%8A%E9%A2%98%E7%9B%AE%E9%83%BD%E7%BB%99%E5%88%B7%E5%B9%B2%E5%87%80/"/>
    
    
    <category term="堆" scheme="https://blog.musnow.top/tags/%E5%A0%86/"/>
    
    <category term="leetcode" scheme="https://blog.musnow.top/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>【C++】布隆过滤器（海量数据处理）</title>
    <link href="https://blog.musnow.top/posts/3245288951/"/>
    <id>https://blog.musnow.top/posts/3245288951/</id>
    <published>2024-03-30T01:26:11.000Z</published>
    <updated>2024-04-14T02:31:36.000Z</updated>
    
    <content type="html"><![CDATA[<p>面试的时候可能会考到这种大数据处理的问题，如果不记得布隆过滤器是干嘛的，那就G喽！</p><blockquote><p>本文参考：<a href="https://blog.csdn.net/weixin_58450087/article/details/123512052">https://blog.csdn.net/weixin_58450087/article/details/123512052</a> 编写</p></blockquote><h1 id="1-什么是布隆过滤器？"><a href="#1-什么是布隆过滤器？" class="headerlink" title="1.什么是布隆过滤器？"></a>1.什么是布隆过滤器？</h1><p>布隆过滤器（Bloom Filter）是1970年由布隆提出的。它实际上是一个很长的二进制向量和一系列随机映射函数。它通过多个哈希函数将一个数据映射到位图的结构中（也就是一个数据映射位图的多个位置，这样就可以减少冲突的概率）。布隆过滤器可以用于检索一个元素是否在一个集合中。它的优点是空间效率和查询时间都比一般的算法要好的多，缺点是有一定的误识别率和删除困难。</p><h2 id="1-1-引入"><a href="#1-1-引入" class="headerlink" title="1.1 引入"></a>1.1 引入</h2><p>在认识布隆过滤器之前，我们先要认识一下哈希和位图的思想。</p><ul><li>哈希：通过哈希函数将value映射到数组中的某个key值下标的位置进行存储，方便查询；但对于海量数据来说占用空间大。</li><li>位图：通过比特0和1来代表某一位的状态，极致节省空间；但无法处理哈希冲突问题。</li></ul><p>布隆过滤器就是这两个思想的结合，可以帮助我们处理海量数据！</p><h2 id="1-2-思想"><a href="#1-2-思想" class="headerlink" title="1.2 思想"></a>1.2 思想</h2><p>在哈希中，我们一般只使用一个哈希函数来进行value和key的映射，哈希可以通过拉链法或者线性探测法来解决哈希冲突问题。</p><p>但在布隆过滤器中，因为需要使用<strong>位图</strong>来做底层的数据结构，此时一个哈希函数就不够了，我们需要多个哈希函数，同时针对一个value进行计算，并将计算出来的多个结果位都置1，以此来减少冲突的概率，同时节省空间。</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/03/60313e1ecb3c9654d752958cd39d83d5.png" alt="img"></p><p>比如我有字符串A、B、C和三个哈希函数</p><ul><li>A计算出来是10、29、39；</li><li>B计算出来是29、30、54；</li><li>C计算出来是30、34、44；</li></ul><p>那么就需要将位图中对应的比特置1，当查询B字符串的时候，判断29、30、54位是否为1，有一个不为1则可以确定B不在过滤器中，全为1的时候可以确定B<strong>可能</strong>在布隆过滤器中。</p><h3 id="“可能在”问题"><a href="#“可能在”问题" class="headerlink" title="“可能在”问题"></a>“可能在”问题</h3><p>为什么是<strong>可能在</strong>呢？看看下面的情况</p><ul><li>A计算出来1、2、3；</li><li>B计算出来4、5、6；</li></ul><p>将A和B放入布隆过滤器，假设来了一个C字符串，计算出来2、3、6。这时候问题就出现了，C字符串并不在布隆过滤器中，但它计算出来的对应位都被A和B置为1了，此时我们就只能得出一个<strong>C可能在布隆过滤器</strong>中的结论，没有办法确定C到底在不在。</p><p>如果C计算出来是2、6、9，可以确定C<strong>绝对不在</strong>布隆过滤器中！</p><p>这也是布隆过滤器的得名所在，它只是一个过滤器！并非100%能确定结果的！布隆过滤器只可以确定<strong>绝对不在</strong>和<strong>可能在</strong>。</p><h3 id="无法删除元素"><a href="#无法删除元素" class="headerlink" title="无法删除元素"></a>无法删除元素</h3><p>因为布隆过滤器是用位图记录1和0的，如果我们将一个元素的哈希函数对应的值全都从1置0来删除的话，可能会影响到其他元素。</p><p>比如A是1、2、6，B是5、6、8，删除A的时候将1、2、6置0，这就影响了B（因为B也需要第6位来判断他是否在）</p><p>解决方法是采用计数方式来代替删除：位图的每一位进行一定扩展，比如扩展到3个bit来表示，这样就有了一个最大值为7的计数器，遇到一位映射就加一，删除就减一。</p><p>但这会引出两个问题：</p><ol><li>位图的大小会成倍增加，可能会导致布隆过滤器的内存优势削弱；</li><li>如果计数器溢出了，会出现<strong>计数回绕</strong>问题；</li></ol><p>计数回绕问题：当实际出现次数超过计数器位数后，会导致溢出回归到初始值，无法确定计数器是否正确。比如上文说的用3个bit来计数，假设这一位的出现次数已经是8了，得到的二进制结果是1000，此时低三位变成了全0，下一次判断的时候会发现这一位压根没有值，造成了错误判断。</p><p>所以实际场景中，我们又需要判断到底用几位来做这个计数器，以达到一定的平衡性。不过鉴于布隆过滤器的使用场景大多都是个过滤，避免删除元素反而成了更好的措施。</p><h3 id="如何精确确认？"><a href="#如何精确确认？" class="headerlink" title="如何精确确认？"></a>如何精确确认？</h3><p>前文提到了，布隆过滤器无法100%确认某个元素一定存在。那如果某一个场景一定需要100%确认，咋办？</p><p>举个实际的例子，假设一个游戏，用户注册的时候给自己起个玩家昵称，此时游戏需要保证玩家昵称不能重复，这时候可以怎么做？</p><ul><li>玩家键入一个名字后，客户端发起API请求，向数据服务器申请检查该名字是否已经被使用。</li></ul><p>这是一个很简单的数据库查询（暂时不考虑数据库缓存的问题），但如果一个游戏刚刚开服或者做活动，大量新玩家涌入，一个玩家每输入一个名字的时候就需要发送一个API请求，数据库服务器还能接受的了这么海量的查询请求吗？</p><ul><li>在查询数据库之前设立一个布隆过滤器，将全服玩家昵称映射进去。</li><li>当新玩家注册的时候，访问布隆过滤器，判断玩家昵称是否存在</li><li>如果布隆过滤器判断不存在（百分百可靠），API直接返回结果，允许玩家用该昵称注册；</li><li>如果布隆过滤器判断存在，则回数据库查询到底是否存在，如果存在则要求玩家改昵称，如果不存在（误判）则允许玩家用该昵称注册。</li></ul><p>这时候，布隆过滤器的“过滤”功能就很明显的体现了。而且因为查询的时候都是读操作，这时候就可以用多线程并发的<code>读写锁</code>来对布隆过滤器进行加锁，一定程度上提高查询的并发效率。</p><p>当然，玩家昵称注册的这个功能还有其他的解决办法，比如拳头的瓦洛兰特和暴雪的游戏，玩家昵称后还会带有一个<code>#</code>以及四位数字标识，可以让这四位数字标识由服务端生成，来避免两个玩家完全重名。除非四位标识都用完了（0000到9999），才提示玩家该昵称不可用。这样也一定程度上进行了过滤，减少了对数据库的查询次数。</p><h2 id="1-3-优缺点"><a href="#1-3-优缺点" class="headerlink" title="1.3 优缺点"></a>1.3 优缺点</h2><p>优点</p><ul><li>增加和查询的时间复杂度都为<code>O(K)</code>，K为哈希函数的个数</li><li>多个哈希函数之间没有关系，方便进行并行计算（多线程）</li><li>布隆过滤器并不存储元素本身，所以占用空间小，特别是海量数据处理时</li><li>如果多个布隆过滤器使用的是相同的哈希函数，则可以进行并集\交集\差集的计算</li></ul><p>缺点</p><ul><li>没有办法百分百确定value一定在，只能确定<strong>一定不在</strong>；</li><li>无法从布隆过滤器中直接获得value；</li><li>不能从布隆过滤器中删除元素（用计数方式删除会有<strong>计数回绕</strong>问题）</li></ul><h2 id="1-4-布隆过滤器的位图长度选择"><a href="#1-4-布隆过滤器的位图长度选择" class="headerlink" title="1.4 布隆过滤器的位图长度选择"></a>1.4 布隆过滤器的位图长度选择</h2><p>对于布隆过滤器来说，M（位图长度）和K（哈希函数个数）越多的时候，冲突的概率就越少。可以根据具体场景的需求，选用更大的M和K来解决冲突，让冲突的概率变小，具体需要多小的冲突概率，是由业务需要来确定的。</p><p>布隆过滤器的哈希函数与位图长度的选择关系公式如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">m = - n * ln(p) / (ln(2)^2) </span><br><span class="line">k = m/n * ln(2)</span><br><span class="line"></span><br><span class="line">// k 为哈希函数个数</span><br><span class="line">// m 为布隆过滤器长度</span><br><span class="line">// n 为插入的元素个数</span><br><span class="line">// p 为可接受该容器的误报率（0-1）</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/03/d8dee57696510408455bf30cd55d8c1d.png" alt="img"></p><p>PS：GPT说最终位图的长度还需要<code>K*M</code>，感觉是在瞎说，查了不少资料，应该是不需要进行这一步的。</p><h1 id="2-代码"><a href="#2-代码" class="headerlink" title="2.代码"></a>2.代码</h1><h2 id="2-1-位图"><a href="#2-1-位图" class="headerlink" title="2.1 位图"></a>2.1 位图</h2><p>布隆过滤器的代码基于位图。位图就不单开博客记录了，本质就是一个整形数组，把每一个比特当作位图中的每一位进行处理，对应按位与和按位或操作就OK了，不是很难理解。</p><p>位图的底层可以用vector，也可以用原生的new&#x2F;delete的数组来处理。用原生的可以节省一定的空间消耗。</p><p>位图的优点是可以节省空间，查找和设置的耗时极低，都是<code>O(1)</code>的时间复杂度。缺点是没有办法处理冲突情况，且只支持整数数据。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">BitMaps</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="type">size_t</span> _bitCount; <span class="comment">// 位图中比特的个数</span></span><br><span class="line"><span class="comment">//std::vector&lt;uint32_t&gt; _bitMap; // 使用int32_t来确保长度</span></span><br><span class="line"><span class="type">uint32_t</span>* _bitMap; <span class="comment">// 用动态内存管理来节省一定空间，vector会有额外内存消耗</span></span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="type">uint8_t</span> _weight = <span class="number">32</span>; <span class="comment">// 用的int32，设置为32方便后序修改</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">size_t</span> <span class="title">GetIndex</span><span class="params">(<span class="type">size_t</span> bit)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> bit / _weight;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">size_t</span> <span class="title">GetOffset</span><span class="params">(<span class="type">size_t</span> bit)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> bit % _weight;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="comment">// 需要多少比特的空间</span></span><br><span class="line"><span class="built_in">BitMaps</span>(<span class="type">size_t</span> bitCount):_bitCount(bitCount),_bitMap(<span class="literal">nullptr</span>) &#123;</span><br><span class="line"><span class="comment">// 需要多少个int来存放空间</span></span><br><span class="line"><span class="type">size_t</span> arraySize = bitCount / _weight + <span class="number">1</span>;</span><br><span class="line"><span class="comment">// 用原生数组一定程度上节省空间</span></span><br><span class="line"><span class="comment">// _bitMap.resize(arraySize);</span></span><br><span class="line">_bitMap = <span class="keyword">new</span> <span class="type">uint32_t</span>[arraySize];</span><br><span class="line"><span class="comment">// 遍历初始化为全0</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; arraySize; i++)</span><br><span class="line">&#123;</span><br><span class="line">_bitMap[i] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用动态内存管理，需要delete</span></span><br><span class="line">~<span class="built_in">BitMaps</span>()</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (_bitMap != <span class="literal">nullptr</span>) &#123;</span><br><span class="line"><span class="keyword">delete</span>[] _bitMap;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将第几位的比特设置为1</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Set</span><span class="params">(<span class="type">size_t</span> bit)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// 超出范围的时候报错</span></span><br><span class="line"><span class="built_in">assert</span>(bit &lt;= _bitCount); </span><br><span class="line"></span><br><span class="line"><span class="comment">// 计算下标位置</span></span><br><span class="line"><span class="type">size_t</span> index = <span class="built_in">GetIndex</span>(bit);</span><br><span class="line"><span class="comment">// 计算是这个下标的第几位</span></span><br><span class="line"><span class="type">size_t</span> offset = <span class="built_in">GetOffset</span>(bit); <span class="comment">// 0 到 31</span></span><br><span class="line"><span class="comment">// 设置进位图，按位或（有1为1）</span></span><br><span class="line">_bitMap[index] |= (<span class="number">1</span> &lt;&lt; offset);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 将对应位设置为0</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Reset</span><span class="params">(<span class="type">size_t</span> bit)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// 超出范围的时候报错</span></span><br><span class="line"><span class="built_in">assert</span>(bit &lt;= _bitCount);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 计算下标位置</span></span><br><span class="line"><span class="type">size_t</span> index = <span class="built_in">GetIndex</span>(bit);</span><br><span class="line"><span class="comment">// 计算是这个下标的第几位</span></span><br><span class="line"><span class="type">size_t</span> offset = <span class="built_in">GetOffset</span>(bit); <span class="comment">// 0 到 31</span></span><br><span class="line"><span class="comment">// 设置进位图，按位与，此时对应位为0，与之后肯定是0</span></span><br><span class="line">_bitMap[index] &amp;= ~(<span class="number">1</span> &lt;&lt; offset);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断第几位是否存在</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">Test</span><span class="params">(<span class="type">size_t</span> bit)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// 超出范围，肯定不存在</span></span><br><span class="line"><span class="keyword">if</span> (bit &gt; _bitCount) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 计算下标位置</span></span><br><span class="line"><span class="type">size_t</span> index = <span class="built_in">GetIndex</span>(bit);</span><br><span class="line"><span class="comment">// 计算是这个下标的第几位</span></span><br><span class="line"><span class="type">size_t</span> offset = <span class="built_in">GetOffset</span>(bit); <span class="comment">// 0 到 31</span></span><br><span class="line"><span class="comment">// 判断是否为1，按位与</span></span><br><span class="line"><span class="type">uint32_t</span> num = (<span class="number">1</span> &lt;&lt; offset);</span><br><span class="line"><span class="comment">// 与位图中的值按位与，只有两个都是1，才是1</span></span><br><span class="line">num &amp;= _bitMap[index];</span><br><span class="line"><span class="comment">// 为0代表不存在</span></span><br><span class="line"><span class="keyword">return</span> num != <span class="number">0</span>; </span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="2-2-布隆过滤器"><a href="#2-2-布隆过滤器" class="headerlink" title="2.2 布隆过滤器"></a>2.2 布隆过滤器</h2><h3 id="基本框架"><a href="#基本框架" class="headerlink" title="基本框架"></a>基本框架</h3><p>布隆过滤器需要指定哈希函数，有两种实现方式</p><ul><li>通过模板参数来指定哈希函数（但是只能固定个数）</li><li>通过函数来添加哈希函数（内部可以用一个function的vector来遍历调用）</li></ul><p>这里为了实现方便且以思路实现为主，采用第一种方式来处理。</p><h3 id="常用字符串哈希函数"><a href="#常用字符串哈希函数" class="headerlink" title="常用字符串哈希函数"></a>常用字符串哈希函数</h3><p>下面是三个比较常用的字符串哈希函数，由它们帮我们计算一个子串对应的三个位图下标。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">BKDRHash</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="function"><span class="type">size_t</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">const</span> std::string&amp; str)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">register</span> <span class="type">size_t</span> hash = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; str.<span class="built_in">size</span>(); ++i)</span><br><span class="line">&#123;</span><br><span class="line">hash = hash * <span class="number">131</span> + str[i];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> hash;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">SDBHash</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="function"><span class="type">size_t</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">const</span> std::string&amp; str)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">register</span> <span class="type">size_t</span> hash = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; str.<span class="built_in">size</span>(); ++i)</span><br><span class="line">&#123;</span><br><span class="line">hash = <span class="number">65599</span> * hash + str[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> hash;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">RSHash</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="function"><span class="type">size_t</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">const</span> std::string&amp; str)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">register</span> <span class="type">size_t</span> hash = <span class="number">0</span>;</span><br><span class="line"><span class="type">size_t</span> magic = <span class="number">63689</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; str.<span class="built_in">size</span>(); ++i)</span><br><span class="line">&#123;</span><br><span class="line">hash = hash * magic + str[i];</span><br><span class="line">magic *= <span class="number">378551</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> hash;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="类构造"><a href="#类构造" class="headerlink" title="类构造"></a>类构造</h3><p>布隆过滤器直接复用位图的实现即可，模板参数用缺省值来指定为字符串。如果需要存放其他类型的成员，不仅需要修改T参数，还需要修改三个哈希函数来适配该参数。</p><p>这里为了方便，直接用乘6来替代布隆过滤器的长度计算公式。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>= std::string, <span class="keyword">class</span> Hash1 = BKDRHash, <span class="keyword">class</span> Hash2 = SDBHash, <span class="keyword">class</span> Hash3 = RSHash&gt;</span><br><span class="line"><span class="keyword">class</span> BloomFilter</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="comment">// 长度计算公式 m = - n * ln(p) / (ln(2)^2) </span></span><br><span class="line"><span class="comment">// 为了实现方便，暂时用6来替代</span></span><br><span class="line"><span class="built_in">BloomFilter</span>(<span class="type">size_t</span> size)</span><br><span class="line">:_bs(<span class="number">6</span> * size)</span><br><span class="line">, _bitSize(<span class="number">6</span> * size)</span><br><span class="line">&#123;&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">BitMaps _bs; <span class="comment">// 位图</span></span><br><span class="line"><span class="type">size_t</span> _bitSize;<span class="comment">// 能够映射bit个数 </span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="设置元素"><a href="#设置元素" class="headerlink" title="设置元素"></a>设置元素</h3><p>设置元素的时候，通过三个哈希函数计算不同的下标值，设置进位图里面就行了。注意这里哈希函数的返回结果需要模一下位图的长度，避免越界。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 设置</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Set</span><span class="params">(<span class="type">const</span> T&amp; t)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">size_t</span> hash1 = <span class="built_in">Hash1</span>()(t) % _bitSize;</span><br><span class="line"><span class="type">size_t</span> hash2 = <span class="built_in">Hash2</span>()(t) % _bitSize;</span><br><span class="line"><span class="type">size_t</span> hash3 = <span class="built_in">Hash3</span>()(t) % _bitSize;</span><br><span class="line"></span><br><span class="line">_bs.<span class="built_in">Set</span>(hash1);</span><br><span class="line">_bs.<span class="built_in">Set</span>(hash2);</span><br><span class="line">_bs.<span class="built_in">Set</span>(hash3);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="查找元素"><a href="#查找元素" class="headerlink" title="查找元素"></a>查找元素</h3><p>同样是调用位图的test函数，只有三个都在的时候，才是元素可能在布隆过滤器中。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 判断</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">Test</span><span class="params">(<span class="type">const</span> T&amp; t)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">size_t</span> hash1 = <span class="built_in">Hash1</span>()(t) % _bitSize;</span><br><span class="line"><span class="type">size_t</span> hash2 = <span class="built_in">Hash2</span>()(t) % _bitSize;</span><br><span class="line"><span class="type">size_t</span> hash3 = <span class="built_in">Hash3</span>()(t) % _bitSize;</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> ret1 = _bs.<span class="built_in">Test</span>(hash1);</span><br><span class="line"><span class="type">bool</span> ret2 = _bs.<span class="built_in">Test</span>(hash2);</span><br><span class="line"><span class="type">bool</span> ret2 = _bs.<span class="built_in">Test</span>(hash3);</span><br><span class="line"><span class="comment">// 只有三个都为true才是可能在</span></span><br><span class="line"><span class="keyword">return</span> ret1 &amp;&amp; ret2 &amp;&amp; ret3;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="删除元素"><a href="#删除元素" class="headerlink" title="删除元素"></a>删除元素</h3><p>前文提到了，布隆过滤器的删除可以用计数器的方式来实现，但是会有计数回绕问题。所以这里布隆过滤器的实现先不管删除啦。</p><h2 id="2-3-测试布隆过滤器"><a href="#2-3-测试布隆过滤器" class="headerlink" title="2.3 测试布隆过滤器"></a>2.3 测试布隆过滤器</h2><p>测试一下set和test有么有什么问题。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">TestBloomFilter</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">BloomFilter&lt;&gt; <span class="built_in">bf</span>(<span class="number">100</span>);</span><br><span class="line"></span><br><span class="line">bf.<span class="built_in">Set</span>(<span class="string">&quot;test1&quot;</span>);</span><br><span class="line">bf.<span class="built_in">Set</span>(<span class="string">&quot;test2&quot;</span>);</span><br><span class="line">bf.<span class="built_in">Set</span>(<span class="string">&quot;test3&quot;</span>);</span><br><span class="line">bf.<span class="built_in">Set</span>(<span class="string">&quot;test4&quot;</span>);</span><br><span class="line"></span><br><span class="line">std::cout &lt;&lt; bf.<span class="built_in">Test</span>(<span class="string">&quot;test1&quot;</span>) &lt;&lt; std::endl;</span><br><span class="line">std::cout &lt;&lt; bf.<span class="built_in">Test</span>(<span class="string">&quot;test2&quot;</span>) &lt;&lt; std::endl;</span><br><span class="line">std::cout &lt;&lt; bf.<span class="built_in">Test</span>(<span class="string">&quot;test3&quot;</span>) &lt;&lt; std::endl;</span><br><span class="line">std::cout &lt;&lt; bf.<span class="built_in">Test</span>(<span class="string">&quot;test4&quot;</span>) &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">std::cout &lt;&lt; bf.<span class="built_in">Test</span>(<span class="string">&quot;test6&quot;</span>) &lt;&lt; std::endl;</span><br><span class="line">std::cout &lt;&lt; bf.<span class="built_in">Test</span>(<span class="string">&quot;tsdfaba&quot;</span>) &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出如下，符合预期</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">0</span></span><br><span class="line"><span class="number">0</span></span><br></pre></td></tr></table></figure><p>这里还可以构造一部分海量数据来测试这个布隆过滤器的准确度如何。但是构造海量的字符串用例感觉很是麻烦，暂时不弄了。</p><h1 id="3-实际场景问题"><a href="#3-实际场景问题" class="headerlink" title="3.实际场景问题"></a>3.实际场景问题</h1><h2 id="3-1-给一个巨大的logFile，内部存放IP地址，设计算法找到TOPK的IP或出现频率最多的IP？"><a href="#3-1-给一个巨大的logFile，内部存放IP地址，设计算法找到TOPK的IP或出现频率最多的IP？" class="headerlink" title="3.1 给一个巨大的logFile，内部存放IP地址，设计算法找到TOPK的IP或出现频率最多的IP？"></a>3.1 给一个巨大的logFile，内部存放IP地址，设计算法找到TOPK的IP或出现频率最多的IP？</h2><p>先创建1000个小文件，然后通过一个哈希函数<code>i = hash(IP) % 1000</code>计算出IP地址存放的位置（这样相同的IP地址会存入一个文件），随后依次读取这些小文件，使用一个<code>uordered_map&lt;string,long long&gt;</code>来计算每一个IP地址出现的次数。</p><p>因为相同的IP地址肯定在同一个小文件内，所以每次<code>unordered_map</code>得到的IP计数肯定是准确的。</p><blockquote><p>这里注意内存的消耗，如果1000个小文件后内存还是会爆，则将文件数量进一步扩大到10000个，以此类推。</p></blockquote><p>再用一个<strong>小根堆</strong>来存放整体TopK的IP地址：因为我们需要出现频率最高的IP地址，所以用小堆可以将<strong>堆内</strong>出现频率<strong>最低的放在堆顶</strong>。这样只要得到一个比堆顶出现次数更多的IP地址，就弹出堆顶将其插入。</p><ul><li>使用哈希函数将logFile中的IP地址映射到不同的小文件中（一行一个IP，直接在文件尾部写入即可）；</li><li>遍历小文件，使用<code>uordered_map&lt;string,long long&gt;</code>来计算IP地址出现频次；</li><li>每次遍历一个小文件后，遍历<code>unordered_map</code>，将IP地址出现频次高于堆顶元素的IP插入小根堆（弹出堆顶后插入）；</li><li>遍历完毕一个小文件，清空<code>unordered_map</code>（避免爆内存）；</li></ul><p>遍历完毕所有小文件后，得到的就是TopK出现频率最多的IP地址。此时堆顶元素就是出现频率<strong>从高到低</strong>在第K个的IP地址，堆内元素是出现频次在前K个的IP地址。</p><h2 id="3-2-给出两个50亿行的文件，一行是一个128字节的字符串，如何找到这两个文件中同时出现过的字符串？"><a href="#3-2-给出两个50亿行的文件，一行是一个128字节的字符串，如何找到这两个文件中同时出现过的字符串？" class="headerlink" title="3.2 给出两个50亿行的文件，一行是一个128字节的字符串，如何找到这两个文件中同时出现过的字符串？"></a>3.2 给出两个50亿行的文件，一行是一个128字节的字符串，如何找到这两个文件中同时出现过的字符串？</h2><blockquote><p>面大厂的时候遇到了这个问题，当时忘记布隆过滤器了，没有答出来，哭死。</p></blockquote><h3 id="布隆过滤器"><a href="#布隆过滤器" class="headerlink" title="布隆过滤器"></a>布隆过滤器</h3><p><strong>使用一个布隆过滤器来实现</strong>：</p><ul><li>创建一个布隆过滤器</li><li>按行读取文件A，计算字符串哈希，映射进布隆过滤器中</li><li>按行读取文件B，计算字符处哈希，判断是否在布隆过滤器中，在则存放至交集内。</li></ul><p>注意，因为布隆过滤器不能保证100%的准确性，所以需要根据准确度的要求扩大布隆过滤器的位图长度或增加哈希函数。</p><p>这里可以来计算一下这样做的内存消耗。用下面的python函数来计算位图的长度</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> math</span><br><span class="line"></span><br><span class="line">n = <span class="number">50</span> * <span class="number">10</span>**<span class="number">8</span>  <span class="comment"># 预期的元素数量</span></span><br><span class="line">p = <span class="number">0.005</span>       <span class="comment"># 期望的误判率</span></span><br><span class="line">k = <span class="number">4</span>           <span class="comment"># 哈希函数数量</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># math.log默认的底就是e</span></span><br><span class="line">m = -n * math.log(p) / (math.log(<span class="number">2</span>)**<span class="number">2</span>)  <span class="comment"># 计算位图长度</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;位图长度m：&quot;</span>, m)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;占用内存GB：&quot;</span>,m/(<span class="number">8</span>*<span class="number">1024</span>*<span class="number">1024</span>*<span class="number">1024</span>))</span><br></pre></td></tr></table></figure><p>输出结果如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">位图长度m： 55138767091.28201</span><br><span class="line">占用内存GB： 6.418997316071998</span><br></pre></td></tr></table></figure><p>还可以用这个网站来在线计算，<a href="https://hur.st/bloomfilter/?n=5000M&p=0.0005&m=&k=4">hur.st&#x2F;bloomfilter</a>。这个网站使用的公式和上文不同。</p><p>由图可知，当n为50亿的，哈希函数4个，误报率0.005（千分之5）的时候，需要7.5GB的空间来存放布隆过滤器。</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/03/c7d2deebb836931d50da4fc64fa7fb36.png" alt="image-20240330111317153"></p><p>虽然<code>6.41GB</code>和<code>7.53GB</code>看上去还是一个很大的内存占用，但是对于服务器动则128GB起步的物理内存大小而言，这已经是相对来说可以接受的占用了。哪怕如今一台16GB内存的家用电脑，理论上也能完成这样的工作。</p><p>如果直接将50亿个128字节的字符串加载到内存里面，要多少空间呢？</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(5 * 10^9 * 128) / (8*1024*1024*1024)</span><br><span class="line">结果是 74.506GB</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/03/9fde90ad5414b9f39b5ce62f112689e0.png" alt="image-20240330103449933"></p><p>74.5GB和7.5GB是将近10倍的内存占用差距，更别提这里只是计算了加载字符串的内存占用，还没有计算如果使用哈希或者红黑树来保存这些字符串的额外内存占用呢，如果算上至少奔着80GB+去了。</p><h3 id="精确算法"><a href="#精确算法" class="headerlink" title="精确算法"></a>精确算法</h3><p>精确算法就还是需要使用<strong>哈希切分</strong>加<strong>set对比</strong>的思路了，设定一万个或者十万个小文件，遍历原始文件，通过哈希<code>i = hash(IP) % 小文件数量</code>映射字符串到第i个小文件中，对A和B都做如此操作，得到A1到Ai个和B1到Bi个小文件。</p><p>因为求的是字符串交集，使用相同哈希函数的情况下，A和B的相同字符串肯定会在<strong>同一个i的小文件</strong>中，此时就可以通过对A1小文件建立一个<code>unordered_set</code>，遍历B1小文件判断是否在set中，再处理A2和B2，以此类推，得到最终的交集。</p><p>注意，如果题目给出了内存限制，我们还需要进一步计算切割出来的小文件的大小是否大于了内存的限制。如果大于了，则采用上述思路对这个小文件再进行一次切分，直到切出来的小文件可以完整的在<strong>内存限制之内</strong>即可。</p><h2 id="3-3-给定10亿个int整数，如何设计算法找到只出现了一次的数（不重复的整数）"><a href="#3-3-给定10亿个int整数，如何设计算法找到只出现了一次的数（不重复的整数）" class="headerlink" title="3.3 给定10亿个int整数，如何设计算法找到只出现了一次的数（不重复的整数）"></a>3.3 给定10亿个int整数，如何设计算法找到只出现了一次的数（不重复的整数）</h2><p>10亿个整数肯定没有办法都load到内存里面，这里需要用到位图来实现。</p><p>方法一：扩展位图，使用2个比特来记录一个数，00代表没出现，01代表出现一次，10代表出现2次及以上。最终位图操作完毕后，重新遍历位图即可得到结果。</p><p>方法二：用两个位图同时操作，数字第一次出现的时候，在第一个位图置1，第二次出现的时候，在第二个位图置1。最终只有一个位图中置1的数就是只出现了一次的数。思路同上。</p><p>这两种方法的消耗空间 <code>(2*4*(10^9))/(8*1024*1024*1024) ≈ 0.931GB</code>，足够在内存中处理了。</p><blockquote><p>1个文件有10亿个int，限定1G内存，设计算法找到出现<strong>次数不超过2次</strong>的所有整数。这个问题也能用上述方法来处理。</p></blockquote><h2 id="3-4-给两个文件，分别有100亿个整数，我们只有1G内存，如何找到两个文件交集？"><a href="#3-4-给两个文件，分别有100亿个整数，我们只有1G内存，如何找到两个文件交集？" class="headerlink" title="3.4 给两个文件，分别有100亿个整数，我们只有1G内存，如何找到两个文件交集？"></a>3.4 给两个文件，分别有100亿个整数，我们只有1G内存，如何找到两个文件交集？</h2><p>方案一： 将文件1的整数映射到一个位图中，然后读取文件2中的数据，判断是否在位图中，在就是交集。（位图的长度取决于这些整数的数据范围）</p><p>方案二： 将文件1的整数映射到一个位图中， 将文件2的整数映射到另一个位图中，然后将两个位图进行按位与（遍历按位与），与之后位图中为1的位就是两个文件的交集。</p><h2 id="3-5-已知某个文件内包含一些电话号码，每个号码为-8-位数字，统计不同号码的个数"><a href="#3-5-已知某个文件内包含一些电话号码，每个号码为-8-位数字，统计不同号码的个数" class="headerlink" title="3.5 已知某个文件内包含一些电话号码，每个号码为 8 位数字，统计不同号码的个数"></a>3.5 已知某个文件内包含一些电话号码，每个号码为 8 位数字，统计不同号码的个数</h2><p>每个号码八位数，不考虑电话号码的实际情况，8位最多<code>99,999,999</code>，一共有<code>10^8</code>种情况。也就是需要<code>10^8</code>位bit，大概12.5M内存即可。</p><p>申请一个数组，遍历所有号码，将号码对应的bit置为1，最后统计bit位1的数量即为不同的号码数。</p><h2 id="3-6-5亿个int整数找它们的中位数"><a href="#3-6-5亿个int整数找它们的中位数" class="headerlink" title="3.6 5亿个int整数找它们的中位数"></a>3.6 5亿个int整数找它们的中位数</h2><blockquote><p>参考：<a href="https://www.nowcoder.com/discuss/384700130958602240">https://www.nowcoder.com/discuss/384700130958602240</a></p></blockquote><p><strong>解法一：</strong>当内存不足以存放5亿个int整数时，我们依然使用分而治之的方法，但hash映射分成小文件的时候需要注意，我们要保证把数据分散到不同文件中时仍然保持着顺序，即按数值大小进行分流，这样才能找到正确的中位数。 </p><ul><li>我们遍历这5亿个int整数时，考虑其二进制的最高位，按照最高位（符号位，0表示正数，1表示负数）进行二分，即最高位为1存入文件a，最高位为0存入文件b，这样文件a中的数是一定比文件b中的数小。    </li><li>统计文件a和文件b中的整数个数，如果文件a和文件b中的整数个数相同，那么中位数则是文件a中的最小值和文件b中的最大值的平均值。如果文件a中的整数个数小于文件b，那么中位数肯定在文件b中，反之亦然。    </li><li>如果文件a或文件b中的整数还是无法直接读取进内存中，那么继续使用上个步骤的方法进行分流，并判断中位数所处的位置，直到中位数所在的那部分数据大小可以直接放到内存中，然后对这部分排序，计算出中位数的值。</li></ul><p>解法二：用堆来解决这个问题，前提是整数能被全部加载到内存中。</p><p>思路可以参考leetcode题目 <a href="https://leetcode.cn/problems/find-median-from-data-stream/">295. 数据流的中位数</a>，为了方便后序归档和复习，对这到题单独开一篇题解。思路还是K神的【<a href="https://leetcode.cn/problems/find-median-from-data-stream/solutions/2361972/295-shu-ju-liu-de-zhong-wei-shu-dui-qing-gmdo/">点我看思路</a>】。</p><h2 id="3-7-海量数据进行排序"><a href="#3-7-海量数据进行排序" class="headerlink" title="3.7 海量数据进行排序"></a>3.7 海量数据进行排序</h2><p>这个是涉及到外排序相关的知识了，也算大数据处理，干脆一起记录在这里。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">https://blog.csdn.net/qq_43915356/article/details/106877167</span><br><span class="line">https://blog.csdn.net/ailunlee/article/details/84548950</span><br></pre></td></tr></table></figure><p>问：假设给你8GB数据，内存只有2GB，如何排序？</p><p>首先我们需要将8GB分为4个2GB的小文件，依次读取每个小文件对其进行排序并存入一个排序好的文件中。得到其中一个有序子串。</p><p>随后，同时读取两个2GB的文件（每一次都只从两个文件中读取一个内容），对比，将小的那个输出到目标文件中。直到遍历完毕两个2GB的文件，即得到了一个4GB的有序子串。</p><p>对两个有序的4GB子串做同样的处理，输出成最终的8GB文件。</p><blockquote><p>N个有序子串的归并叫做N路归并。</p></blockquote><p>但是这里会有一个磁盘IO的问题，我们两两归并的时候，会涉及到从两个文件中读取一次，再输出到最终文件中的一次。归并的次数越多，IO的次数也就越多，速度也就越慢。</p><p>所以可以适当的增加归并文件的数量，比如同时读取三个2GB的文件，对三个数进行排序，输出到目标文件中。但是这里需要注意有序性的问题。比如文件A和B中的第一个记录小于C的记录，此时会以A0\B0\C0输出到目标文件中，但有可能会出现A1和B1还是小于C0的情况，这种就比较麻烦了（俺没想出好的解决办法）。</p><h1 id="The-end"><a href="#The-end" class="headerlink" title="The end"></a>The end</h1><p>布隆过滤器和位图，以及哈希分而治之的思想在大数据梳理中非常有用，一定要记住！</p>]]></content>
    
    
    <summary type="html">学习如何使用布隆过滤器来处理海量数据</summary>
    
    
    
    <category term="编程学习" scheme="https://blog.musnow.top/categories/%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="C++" scheme="https://blog.musnow.top/categories/%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0/C/"/>
    
    
    <category term="Cpp" scheme="https://blog.musnow.top/tags/Cpp/"/>
    
    <category term="数据结构" scheme="https://blog.musnow.top/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    <category term="哈希" scheme="https://blog.musnow.top/tags/%E5%93%88%E5%B8%8C/"/>
    
  </entry>
  
  <entry>
    <title>【leetcode】233.数字1的个数</title>
    <link href="https://blog.musnow.top/posts/2123053741/"/>
    <id>https://blog.musnow.top/posts/2123053741/</id>
    <published>2024-03-29T11:06:22.000Z</published>
    <updated>2024-03-30T01:26:06.000Z</updated>
    
    <content type="html"><![CDATA[<p>面tx的时候上来就是这道题，我只想出来暴力的思路，肯定不得分了，赶快学习一下正确的解法。</p><h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><blockquote><p><a href="https://leetcode.cn/problems/number-of-digit-one/description/">https://leetcode.cn/problems/number-of-digit-one/description/</a></p></blockquote><p>给定一个整数 n，计算所有小于等于 n 的非负整数中数字 1 出现的个数。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">示例 1：</span><br><span class="line"></span><br><span class="line">输入：n = 13</span><br><span class="line">输出：6</span><br><span class="line"></span><br><span class="line">示例 2：</span><br><span class="line">输入：n = 0</span><br><span class="line">输出：0</span><br><span class="line"></span><br><span class="line">提示：</span><br><span class="line">0 &lt;= n &lt;= 10^9</span><br></pre></td></tr></table></figure><p>注意题目的意思，比如给定的数字n是13，那么1到13中，1一共出现了6次，分别是1、10、11（两个1）、12、13。</p><p>暴力的办法就是直接两层循环计算每一位是不是1，是1就count++，最终返回count就行；</p><h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><h2 id="基本说明"><a href="#基本说明" class="headerlink" title="基本说明"></a>基本说明</h2><blockquote><p>这里学习一下Krahets大佬的思路：<a href="https://leetcode.cn/problems/number-of-digit-one/solutions/2362053/233-shu-zi-1-de-ge-shu-qing-xi-tu-jie-by-pgb1/">https://leetcode.cn/problems/number-of-digit-one/solutions/2362053/233-shu-zi-1-de-ge-shu-qing-xi-tu-jie-by-pgb1/</a></p></blockquote><p>思路是将每一位置1后，其他的位会有多少种组合，加起来就是总的1的数量。</p><p>比如三位数中，1的个数是：个位数为1时组合的个数+十位数为1时其他数的个数+百位数为1时其他位的组合个数。更多位的数也是这个思路，以此类推。</p><p>假设n&#x3D;22时，1的个数是<code>[1,22]</code>中<code>X1</code>的个数（1、11、21）+<code>[1,22]</code>中<code>1X</code>的个数（10-19，注意这里的11只关注十位数的1）</p><h2 id="实例图"><a href="#实例图" class="headerlink" title="实例图"></a>实例图</h2><p>提供的数是n，一共有k位，我们可以把n当作<code>Nk N(k-1) ... N1 N0</code>（Nk代表每一位的数）；</p><ul><li>cur是当前遍历到的第i个数，<code>Ni</code>（下标）;</li><li>high是当前数高位的数，<code>Nk N(k-1) N(k-2) ... N(i+1)</code>;</li><li>low是当前数低位的数，<code>N(i-1) N(i-2) ... N1 N0</code>;</li><li>dights是当前的权值，为<code>10^i</code>；</li></ul><p>这个权值是<strong>当前位为1时</strong>，<strong>往后</strong>会出现多少个组合，比如cur为<strong>十位</strong>的时候，其他位和这一位能构成的1的组合是10到19，即10个1（注意这里不关注11的个位数的1），和<code>10^1</code>的结果一致。<strong>百位</strong>也是如此，能构成1的组合是100到199，一共100个1，也是<code>10^2</code>的值。</p><p>具体的分为下面三个情况</p><ol><li>cur为0；</li><li>cur为1；</li><li>cur大于1，即2到9；</li></ol><h3 id="1-cur为0"><a href="#1-cur为0" class="headerlink" title="1.cur为0"></a>1.cur为0</h3><p>假设<strong>n&#x3D;3404</strong>，cur为第1位（从右往左数第二个），hight为34，low为4，dights为10^1&#x3D;10；此时1出现的次数只和high和dights有关。公式如下<br>$$<br>high * dights<br>$$<br>你可以把3404想象成一个4位的拨动密码锁，当cur位固定为1了之后，我们需要想办法将这个密码锁拨动到不大于n的最大位置3319。对应high的变动位置是<strong>0到33</strong>（一共有34个），low的变动位置是<strong>0到9</strong>（一共10个）。</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/03/9ba40985cc005b5818b0989cbdac2ffe.png" alt="image-20240330090831427"></p><p>可得，0到33中，每一次high的变化都会出现10个1（<code>xx10~xx19</code>）。所以得出公式 <code>high * dights</code>，本例子中即为<code>34*10 = 340</code>个1。</p><ul><li>cur为0，<strong>所以1的个数只与high有关</strong>，与low位无关，为什么？</li></ul><p>因为十位的cur为0的时候，密码锁不可能拨动到341x的位置（超出范围了），此时不管low位是多少，都不会有更多1的组合，组合被锁定在了低于3404的<code>0010~3319</code>之中。和下文cur为1的情况对照能更好的理解这个情况。</p><h3 id="2-cur为1"><a href="#2-cur为1" class="headerlink" title="2.cur为1"></a>2.cur为1</h3><p>假设n&#x3D;3414。十位的cur为1的时候，密码锁就可以拨动到341x的位置了，此时1的个数和high&#x2F;low都有关系。</p><p>high包括<code>00~33</code>的34个<code>10~19</code>（340个1，和上文一致），low包括<code>3410~341x</code>的1的个数，例子中low为4，低位可决定的1的范围是3410到3414，一共有5个数，对应<code>low+1</code>。</p><p>此时可以得到公式如下<br>$$<br>higt * dights + (low + 1)<br>$$<br>下为这种情况的示意图</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/03/23c25b69ea783cc79f130cc83c650630.png" alt="image-20240330090913430"></p><h3 id="3-cur大于1"><a href="#3-cur大于1" class="headerlink" title="3.cur大于1"></a>3.cur大于1</h3><p>假设n&#x3D;3434，十位的cur大于1了，可选值已经超过了3419。此时密码锁的拨动还是只和high有关系，可以拨动的范围已经包揽了<code>00~34</code>，一共是35个<code>10~19</code>，公式如下<br>$$<br>(high + 1) * dights<br>$$</p><p>下为这种情况的示意图</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/03/cffd5e76633b7fc2873c5f6cac542577.png" alt="image-20240330091149401"></p><p>最终我们只需要遍历每一位的数，将值给加起来，就是题目的和。</p><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><p>有了每一种情况的公式，代码就很容易写出来了。这里需要注意的就是high&#x2F;low&#x2F;cur是如何移动到下一位的，以及什么时候需要跳出循环。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">countDigitOne</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> count = <span class="number">0</span>; <span class="comment">// 结果</span></span><br><span class="line">        <span class="comment">// 不大于10的时候只会有一个</span></span><br><span class="line">        <span class="keyword">if</span> (n &lt; <span class="number">10</span> &amp;&amp; n &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 个位数 dights = 10^0 = 1</span></span><br><span class="line">        <span class="type">long</span> dights = <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// high/cur/low 初始化为个位时的取值</span></span><br><span class="line">        <span class="type">long</span> high = n / <span class="number">10</span>; <span class="comment">// 除去个位的其他值</span></span><br><span class="line">        <span class="type">long</span> cur = n % <span class="number">10</span>;  <span class="comment">// 当前位是个位</span></span><br><span class="line">        <span class="type">long</span> low = <span class="number">0</span>;       <span class="comment">// 个位没有low</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// high和cur同时为0代表遍历结束</span></span><br><span class="line">        <span class="keyword">while</span> (high != <span class="number">0</span> || cur != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (cur == <span class="number">0</span>) &#123;</span><br><span class="line">                count += high * dights;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (cur == <span class="number">1</span>) &#123;</span><br><span class="line">                count += high * dights + low + <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (cur &gt; <span class="number">1</span>) &#123;</span><br><span class="line">                count += (high + <span class="number">1</span>) * dights;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 倍增，dights = 10^i</span></span><br><span class="line">            dights *= <span class="number">10</span>;</span><br><span class="line">            <span class="comment">// 移动到下一位</span></span><br><span class="line">            <span class="comment">// 当cur为十位的时候，high是n/100</span></span><br><span class="line">            <span class="comment">// 当cur为百位的时候，high是n/1000</span></span><br><span class="line">            high = n / (dights * <span class="number">10</span>);</span><br><span class="line">            <span class="comment">// 当cur为十位的时候，cur是(n/10)%10计算出来的</span></span><br><span class="line">            <span class="comment">// 当cur为百位的时候，cur是(n/100)%10计算出来的</span></span><br><span class="line">            cur = (n / dights) % <span class="number">10</span>;</span><br><span class="line">            <span class="comment">// 当cur为十位的时候，low是%10计算出来的</span></span><br><span class="line">            <span class="comment">// 当cur为百位的时候，low是%100计算出来的</span></span><br><span class="line">            low = n % dights;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/03/26e321e14e47ab27b3c3951a1556a98c.png" alt="image-20240330092321043"></p><h1 id="The-end"><a href="#The-end" class="headerlink" title="The end"></a>The end</h1><p>这道题还有数位DP的解法，但是我还没有学习到DP，此时只学一道题还不如不学。所以后续再补充其他思路吧！</p>]]></content>
    
    
    <summary type="html">leetcode刷题笔记-233.数字1的个数</summary>
    
    
    
    <category term="编程学习" scheme="https://blog.musnow.top/categories/%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="把题目都给刷干净" scheme="https://blog.musnow.top/categories/%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0/%E6%8A%8A%E9%A2%98%E7%9B%AE%E9%83%BD%E7%BB%99%E5%88%B7%E5%B9%B2%E5%87%80/"/>
    
    
    <category term="OJ刷题" scheme="https://blog.musnow.top/tags/OJ%E5%88%B7%E9%A2%98/"/>
    
    <category term="leetcode" scheme="https://blog.musnow.top/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>【leetcode】53.最大子数组和</title>
    <link href="https://blog.musnow.top/posts/4261184242/"/>
    <id>https://blog.musnow.top/posts/4261184242/</id>
    <published>2024-03-26T10:15:05.000Z</published>
    <updated>2024-04-07T07:28:31.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><blockquote><p><a href="https://leetcode.cn/problems/maximum-subarray/description/">53. 最大子数组和</a></p></blockquote><p>给你一个整数数组 nums ，请你找出一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。</p><p>子数组 是数组中的一个连续部分。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">示例 1：</span><br><span class="line">输入：nums = [-2,1,-3,4,-1,2,1,-5,4]</span><br><span class="line">输出：6</span><br><span class="line">解释：连续子数组 [4,-1,2,1] 的和最大，为 6 。</span><br><span class="line"></span><br><span class="line">示例 2：</span><br><span class="line">输入：nums = [1]</span><br><span class="line">输出：1</span><br><span class="line"></span><br><span class="line">示例 3：</span><br><span class="line">输入：nums = [5,4,-1,7,8]</span><br><span class="line">输出：23</span><br></pre></td></tr></table></figure><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>最简单的方式可以用一个三层的嵌套遍历找到这个最大值，时间复杂度是<code>O(N^3)</code>。但这样写肯定是不好的。</p><p>题目要求的是一个连续子数组的和，我们可以认为遍历到某一个数的时候，这个子数组的和就是<code>到前一位的子数组和+当前值</code>，这时候就会出现两种情况</p><ul><li><code>前一位的数组和+当前值 &lt; 当前值</code>，这说明前一位的子数组和是一个负数，那还不如当前值自己大，所以直接选用当前值作为新一轮子数组的开始。</li><li><code>前一位的数组和+当前值 &gt;= 当前值</code>，可以将当前值算到前一位的这个子数组中，继续扩张。</li></ul><p>每一次操作之后都需要更新最大和。</p><p>我们可以另外开辟一个数组来存放每一位的最大子数组和，再通过下标访问前一位的数组和。但实际上每一次遍历<strong>只和前一位的子数组和有关</strong>系，所以直接用int来存放前一位的子数组和就够了，不需要额外开辟数组的空间复杂度消耗了。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><h3 id="代码1"><a href="#代码1" class="headerlink" title="代码1"></a>代码1</h3><p>代码比较简单，理解了思路就能写出来</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxSubArray</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> prev = <span class="number">0</span>;         <span class="comment">// 之前的最大子数组和，初始值0</span></span><br><span class="line">        <span class="type">int</span> maxNum = nums[<span class="number">0</span>]; <span class="comment">// 从数组中选一个值</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; i : nums) &#123;</span><br><span class="line">            <span class="comment">// 如果之前的最大子数组和还没有我自己大，则从我自己开始新列一个子数组</span></span><br><span class="line">            prev = <span class="built_in">max</span>(prev + i, i);</span><br><span class="line">            <span class="comment">// 更新最大值</span></span><br><span class="line">            maxNum = <span class="built_in">max</span>(maxNum, prev);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxNum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/03/3e465f2252d1a16767bf00bab2ab4644.png" alt="image.png"></p><p>时间复杂度<code>O(N)</code>，空间复杂度<code>O(1)</code>；</p><h3 id="代码2"><a href="#代码2" class="headerlink" title="代码2"></a>代码2</h3><p>上面这个代码乍一看可能不好理解，我们可以按下面的方式写</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxSubArray</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> ret = INT32_MIN;</span><br><span class="line">        <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; i : nums) &#123;</span><br><span class="line">            sum += i;</span><br><span class="line">            <span class="comment">// 更新最大值</span></span><br><span class="line">            <span class="keyword">if</span> (sum &gt; ret) &#123;</span><br><span class="line">                ret = sum;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 如果当前sum为负数，那么需要重新开子数组了</span></span><br><span class="line">            <span class="comment">// 因为当前的sum加上下一位后，肯定没有下一位本身大！</span></span><br><span class="line">            <span class="keyword">if</span> (sum &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                sum = <span class="number">0</span>; <span class="comment">// 重置为0</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这个思路也是一样，只不过将判断换到了当前位之后就处理了</p><ul><li>维护一个sum，作为当前子数组的和；</li><li>每一次都让<code>sum+=i</code>，并更新最大值；</li><li>如果当前sum小于等于0了，当前<strong>子数组的和+下一位</strong>肯定会<strong>小于下一位本身</strong>，此时置为0，从下一位开始重新计算一个新的子数组和；</li><li>直到遍历完毕返回维护的最大值。</li></ul><p>两个写法都能过，重点还是理解思路啦！</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/04/041b930158ef5066677b199f9b715449.png" alt="image.png"></p><h2 id="The-end"><a href="#The-end" class="headerlink" title="The end"></a>The end</h2><p>这道题还有很多不同的解法，可以参考这个博客：<a href="https://blog.csdn.net/Supreme7/article/details/117398880">https://blog.csdn.net/Supreme7/article/details/117398880</a></p>]]></content>
    
    
    <summary type="html">leetcode刷题笔记-53.最大子数组和</summary>
    
    
    
    <category term="编程学习" scheme="https://blog.musnow.top/categories/%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="把题目都给刷干净" scheme="https://blog.musnow.top/categories/%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0/%E6%8A%8A%E9%A2%98%E7%9B%AE%E9%83%BD%E7%BB%99%E5%88%B7%E5%B9%B2%E5%87%80/"/>
    
    
    <category term="OJ刷题" scheme="https://blog.musnow.top/tags/OJ%E5%88%B7%E9%A2%98/"/>
    
    <category term="leetcode" scheme="https://blog.musnow.top/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>【面试】浏览器输入URL到出现网页的全过程</title>
    <link href="https://blog.musnow.top/posts/2270595544/"/>
    <id>https://blog.musnow.top/posts/2270595544/</id>
    <published>2024-03-26T02:09:43.000Z</published>
    <updated>2024-04-10T04:58:34.000Z</updated>
    
    <content type="html"><![CDATA[<p>面试总是考这个，虽然我能说出个大概，但总是卡壳，还是重新记录一下。</p><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><p>首先要知道这里面会涉及到什么协议，以HTTP的网页为例，会涉及到下面这些协议</p><ul><li>HTTP&#x2F;HTTPS</li><li>TCP</li><li>IP</li><li>ARP</li><li>DNS</li><li>NAT</li></ul><p>当然，更底层的还有路由选择协议OSPF等，但这些一般情况下不会考察到（除非你面试的是网络工程师相关岗位），所以能把上面的这些协议的步骤说清楚就基本够了。</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/03/200e1efb4783410ed6d8dc834e0cc459.png" alt="image.png"></p><h2 id="步骤一：URL解析"><a href="#步骤一：URL解析" class="headerlink" title="步骤一：URL解析"></a>步骤一：URL解析</h2><p>浏览器首先是需要解析你访问的URL，从里面提取当前使用的网络协议（以HTTP协议为例），目标的域名，以及域名后的请求路径与参数。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http(s)://&lt;host&gt;:&lt;port&gt;/&lt;path&gt;?&lt;query&gt;#&lt;frag&gt;</span><br></pre></td></tr></table></figure><p>随后浏览器会将这里面的信息封装成一个HTTP请求报文。因为是在浏览器中输入的URL，所以是GET请求。假设你访问的是某个网页的主页，那么浏览器就会构造一个GET请求报文，去请求根路径下的<code>index.html</code>文件。</p><h2 id="步骤二：DNS解析"><a href="#步骤二：DNS解析" class="headerlink" title="步骤二：DNS解析"></a>步骤二：DNS解析</h2><p>知道了域名，还需要知道这个域名对应的IP地址，才能发起网络请求。<strong>浏览器</strong>会进行DNS查询（基于UDP），来找到域名的IP地址。</p><ul><li>查询浏览器本地缓存；</li><li>查询PC主机本地缓存；</li><li>查询主机HOSTS文件；</li><li>本地缓存找不到，向默认DNS服务器（通常是ISP的DNS服务器）发起<strong>递归</strong>查询；</li><li>ISP的DNS服务器使用<strong>迭代</strong>的方式依次从根域名服务器、顶级域名服务器……直到找到该域名映射的IP地址。</li><li>ISP的DNS服务器向客户端返回IP地址（服务器一般有<strong>负载均衡</strong>，同一个域名每一次查询到的IP地址可能不一样）</li></ul><p>DNS是基于UDP的，底层依旧是IP协议，当前的主机一般是<strong>知道DNS服务器的IP地址的</strong>（可以手动配置公共DNS服务器，或者自动选择时默认ISP的DNS服务器），所以不存在还需要查询DNS服务器的IP地址的情况。</p><ul><li>如果找不到，会返回失败，此时浏览器会显示 <code>DNS_PROBE_FINISHED_NXDOMAIN</code>，提示用户该域名找不到IP地址（没有成功解析）</li><li>如果找到了，浏览器会将这个域名和IP的对应关系放入自己的缓存，方便下一次请求。</li></ul><p>本地的DNS缓存也会有一个过期计时器，避免目标域名和IP的映射关系发生变化。</p><h2 id="步骤三：TCP握手"><a href="#步骤三：TCP握手" class="headerlink" title="步骤三：TCP握手"></a>步骤三：TCP握手</h2><p>现在我们知道目标主机的IP地址了，也知道端口号（HTTP协议是80端口，HTTPS是443端口），现在浏览器会调用系统接口，发起TCP三次握手的请求。下面的工作就是操作系统的网络协议栈来处理的了啦！</p><blockquote><p>这里可能会追问为什么TCP握手是三次：三次握手是<strong>保证双方通信能力的最小握手次数</strong>，同时也一定程度上避免了一次和二次握手中客户端只需要发送一次SYN就能攻击服务器的情况。</p></blockquote><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/03/87c2006ec4c2d6e3394f0e90b99493d0.png" alt="image.png"></p><p>TCP的握手报文向下层IP层交付，IP层封装源IP和目的服务器IP（刚刚通过DNS获得的），并将TCP报文封装到IP报文的数据部分，向下层数据链路层交付。</p><p>数据链路层通过ARP协议查询IP地址对应的MAC地址</p><ul><li>如果是家庭局域网，查询不到目的IP地址，主机会用默认的下一跳（一般是路由器）发送这个报文（后序还涉及到NAT协议）</li><li>如果两个主机都在公网，发送端路由器进行路由查找，查询目标IP地址的目的网络，并转发到下一跳。</li></ul><p>注意，如果面试官没有要求，可以先忽略IP层的处理（只说通过IP协议来传输），这部分是最容易说岔的！</p><h2 id="步骤四：服务器接收请求"><a href="#步骤四：服务器接收请求" class="headerlink" title="步骤四：服务器接收请求"></a>步骤四：服务器接收请求</h2><p>服务器收到客户端发送的报文，从下往上交付，得到HTTP的GET请求，并根据请求中的路径和参数，将客户端需要的资源（html&#x2F;js&#x2F;css）封装并封装在HTTP响应报文中，传回客户端。</p><h2 id="步骤五：客户端接收响应"><a href="#步骤五：客户端接收响应" class="headerlink" title="步骤五：客户端接收响应"></a>步骤五：客户端接收响应</h2><p>客户端收到响应，解析HTTP响应中的数据，并交付<strong>浏览器进行页面渲染</strong>。</p><p>此时根据双方的约定，决定保持链接还是终止TCP链接（终止需要进行四次挥手）</p><h2 id="额外步骤：HTTPS的SSL握手"><a href="#额外步骤：HTTPS的SSL握手" class="headerlink" title="额外步骤：HTTPS的SSL握手"></a>额外步骤：HTTPS的SSL握手</h2><p>如果是HTTPS协议，在正式发送请求之前，还需要进行SSL证书的握手。</p><blockquote><p> 引用：<a href="https://zhuanlan.zhihu.com/p/58955297">https://zhuanlan.zhihu.com/p/58955297</a></p></blockquote><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/03/d2a2828867b502a52ec189aea35994d9.png" alt="image.png"></p><p>需要通过证书握手，确定双方使用的对称加密密钥，再加密进行HTTP请求&#x2F;响应的传输。</p>]]></content>
    
    
    <summary type="html">面试常考-浏览器输入URL到出现网页的全过程</summary>
    
    
    
    <category term="编程学习" scheme="https://blog.musnow.top/categories/%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="默认分组" scheme="https://blog.musnow.top/categories/%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0/%E9%BB%98%E8%AE%A4%E5%88%86%E7%BB%84/"/>
    
    
    <category term="计算机网络" scheme="https://blog.musnow.top/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    <category term="http" scheme="https://blog.musnow.top/tags/http/"/>
    
    <category term="tcp" scheme="https://blog.musnow.top/tags/tcp/"/>
    
  </entry>
  
  <entry>
    <title>【leetcode】221最大正方形</title>
    <link href="https://blog.musnow.top/posts/2287991438/"/>
    <id>https://blog.musnow.top/posts/2287991438/</id>
    <published>2024-03-25T10:13:29.000Z</published>
    <updated>2024-04-16T10:36:31.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><blockquote><p><a href="https://leetcode.cn/problems/maximal-square/description/">221. 最大正方形</a></p></blockquote><p>在一个由 ‘0’ 和 ‘1’ 组成的二维矩阵内，找到只包含 ‘1’ 的最大正方形，并返回其面积。</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/03/8d21cc06d7ecb1b257bc127a35cf0277.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">m == matrix.length</span><br><span class="line">n == matrix[i].length</span><br><span class="line">1 &lt;= m, n &lt;= 300</span><br><span class="line">matrix[i][j] 为 &#x27;0&#x27; 或 &#x27;1&#x27;</span><br></pre></td></tr></table></figure><h2 id="思路1-前缀和"><a href="#思路1-前缀和" class="headerlink" title="思路1-前缀和"></a>思路1-前缀和</h2><h3 id="思路1说明"><a href="#思路1说明" class="headerlink" title="思路1说明"></a>思路1说明</h3><p>面试的时候遇到了这道题，当时只想得出来遍历的办法，后来面试官提示了一下想出来了另外一个思路，不过没时间写了。</p><p>思路是这样的，开另外一个和题目所给矩阵一样的二维数组<code>vector&lt;vector&lt;pair&lt;int, int&gt;&gt;&gt;</code>，用于存放每一位的往前1的个数和往上1的个数（不包括该数自己）。</p><p>以题目给的矩阵为例</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">[&quot;1&quot;,&quot;0&quot;,&quot;1&quot;,&quot;0&quot;,&quot;0&quot;],</span><br><span class="line">[&quot;1&quot;,&quot;0&quot;,&quot;1&quot;,&quot;1&quot;,&quot;1&quot;],</span><br><span class="line">[&quot;1&quot;,&quot;1&quot;,&quot;1&quot;,&quot;1&quot;,&quot;1&quot;],</span><br><span class="line">[&quot;1&quot;,&quot;0&quot;,&quot;0&quot;,&quot;1&quot;,&quot;0&quot;]</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>可以得到下面的前缀和矩阵，每一位的左侧代表该位置行之前的1的个数，右侧代表该位置列往上1的个数（不包括该数自己）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;0,0&#125; &#123;1,0&#125; &#123;1,0&#125; &#123;2,0&#125; &#123;2,0&#125;</span><br><span class="line">&#123;0,1&#125; &#123;1,0&#125; &#123;1,1&#125; &#123;2,0&#125; &#123;3,0&#125;</span><br><span class="line">&#123;0,2&#125; &#123;1,0&#125; &#123;2,2&#125; &#123;3,1&#125; &#123;4,1&#125;</span><br><span class="line">&#123;0,3&#125; &#123;0,1&#125; &#123;1,3&#125; &#123;1,2&#125; &#123;2,2&#125;</span><br></pre></td></tr></table></figure><p>此时要确定一个正方形，以示例图中下标<code>(1,2)</code>到<code>(2,3)</code>的这个2x2的正方形为例，我们只需要判断正方形对角线上的数的前缀和是否符合条件即可。一个符合条件的正方形，假设下标从<code>(0,0)</code>开始，它的对角线上的前缀和应该是这样的，分别代表该位置之前和之上1的数量。</p><table><thead><tr><th>(0,0)</th><th></th><th></th><th></th></tr></thead><tbody><tr><td></td><td>(1,1)</td><td></td><td></td></tr><tr><td></td><td></td><td>(2,2)</td><td></td></tr><tr><td></td><td></td><td></td><td>……</td></tr></tbody></table><p>但我们需要找的下标<code>(1,2)</code>到<code>(2,3)</code>的正方形并不是从<code>(0,0)</code>开始的，所以还需要对这个前缀和矩阵中的值进行一定处理来得到结果。过程如下</p><ul><li>下标<code>(1,2)</code>是1，开始处理（判断从这个坐标开始往左下角的最大正方形）；</li><li>正方形边长初始化为1（因为起始下标位置为1，就是一个1x1的正方形）；</li><li>判断<code>(1+1,2+1)</code>下标处的值是否为1；为1继续判断前缀和，值是<code>&#123;3,1&#125;</code>；</li><li>这里前缀和的3代表这一行前面还有3个1，1代表这一列上面还有1个1；</li><li>行需要和下标<code>(2,2)</code>处的前缀和<code>&#123;2.2&#125;</code>第一位相减；列需要和下标<code>(1,2)</code>处的前缀和<code>&#123;2,0&#125;</code>第二位相减。即<code>&#123;3-2,1-0&#125;</code>，最终得到的结果是<code>1,1</code>，符合正方形对角线上的条件，边长加一为2。</li><li>继续判断<code>(2+1,3+1)</code>下标处的值是否为1，此时发现已不为1，停止匹配；</li><li>得到最大正方形边长2，面积为4；</li></ul><p>如果是下面这样的矩阵（相比上面的矩阵只修改了左下角的两个0为1）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">[&quot;1&quot;,&quot;0&quot;,&quot;1&quot;,&quot;0&quot;,&quot;0&quot;],</span><br><span class="line">[&quot;1&quot;,&quot;0&quot;,&quot;1&quot;,&quot;1&quot;,&quot;1&quot;],</span><br><span class="line">[&quot;1&quot;,&quot;1&quot;,&quot;1&quot;,&quot;1&quot;,&quot;1&quot;],</span><br><span class="line">[&quot;1&quot;,&quot;0&quot;,&quot;1&quot;,&quot;1&quot;,&quot;1&quot;]</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>对应前缀和矩阵如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;0,0&#125; &#123;1,0&#125; &#123;1,0&#125; &#123;2,0&#125; &#123;2,0&#125;</span><br><span class="line">&#123;0,1&#125; &#123;1,0&#125; &#123;1,1&#125; &#123;2,0&#125; &#123;3,0&#125;</span><br><span class="line">&#123;0,2&#125; &#123;1,0&#125; &#123;2,2&#125; &#123;3,1&#125; &#123;4,1&#125;</span><br><span class="line">&#123;0,3&#125; &#123;0,1&#125; &#123;1,3&#125; &#123;2,2&#125; &#123;3,2&#125;</span><br></pre></td></tr></table></figure><p>此时<code>(2+1,3+1)</code>下标处的值为1，继续判断前缀和<code>&#123;3,2&#125;</code>，这时候已经是一个3x3的正方形了，这个对角线的值应为<code>&#123;2,2&#125;</code>才符合条件。所以需要计算当前前缀和与<strong>行的前2个</strong>和<strong>列的前2个</strong>的差值：</p><ul><li>行需要和下标<code>(3,2)</code>处的前缀和<code>&#123;1,3&#125;</code>第一位相减；</li><li>列需要和下标<code>(1,4)</code>处的前缀和<code>&#123;3,0&#125;</code>第二位相减；</li><li>即<code>&#123;3-1,2-0&#125;</code>，最终能得到<code>&#123;2,2&#125;</code>，符合正方形条件；</li><li>边长加一为3，最大正方形面积为9。</li></ul><p>以此类推，直到遍历的下标越界为止，即完成了对矩阵中一个位置的正方形查找。</p><p>这里涉及到两次叠加循环和一个扩张循环，时间复杂度可以认为是<code>O(N^3)</code>或<code>O(M^3)</code>；</p><h3 id="思路1代码"><a href="#思路1代码" class="headerlink" title="思路1代码"></a>思路1代码</h3><p>代码如下，关键部分添加了注释</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maximalSquare</span><span class="params">(vector&lt;vector&lt;<span class="type">char</span>&gt;&gt;&amp; matrix)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (matrix.<span class="built_in">size</span>() == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 用于记录前缀和，下标代表这个数的行之前以及列以上的1的个数（不包括该数本身）</span></span><br><span class="line">        <span class="type">int</span> n = matrix.<span class="built_in">size</span>(), m = matrix[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        vector&lt;vector&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt;&gt; <span class="built_in">oneCount</span>(</span><br><span class="line">            n, vector&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt;(m, &#123;<span class="number">0</span>, <span class="number">0</span>&#125;));</span><br><span class="line">        oneCount[<span class="number">0</span>][<span class="number">0</span>] = &#123;<span class="number">0</span>, <span class="number">0</span>&#125;;</span><br><span class="line">        <span class="comment">// O(M*N)</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; matrix.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="type">int</span> count = <span class="number">0</span>; <span class="comment">// 每一行的1计数器</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; matrix[i].<span class="built_in">size</span>(); j++) &#123;</span><br><span class="line">                <span class="comment">// 第i行，j之前的1的个数（不包括当前值）</span></span><br><span class="line">                oneCount[i][j].first = count; <span class="comment">// 先赋值，因为不包括自己</span></span><br><span class="line">                <span class="comment">// 第i行，第j列往上1的个数（不包括当前值）</span></span><br><span class="line">                <span class="keyword">if</span> (i == <span class="number">0</span>) &#123;</span><br><span class="line">                    oneCount[i][j].second = <span class="number">0</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// 直接拿上一层的值为初值，再判断上一层是否为1</span></span><br><span class="line">                    oneCount[i][j].second = oneCount[i - <span class="number">1</span>][j].second;</span><br><span class="line">                    <span class="keyword">if</span> (matrix[i - <span class="number">1</span>][j] == <span class="string">&#x27;1&#x27;</span>) &#123;</span><br><span class="line">                        oneCount[i][j].second++;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 每一行的1的个数加一</span></span><br><span class="line">                <span class="keyword">if</span> (matrix[i][j] == <span class="string">&#x27;1&#x27;</span>) &#123;</span><br><span class="line">                    count++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 此时可以得到一个矩阵，这样判断是否为正方形只需要判断对角线的数</span></span><br><span class="line">        <span class="type">int</span> maxSquare = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; matrix.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; matrix[i].<span class="built_in">size</span>(); j++) &#123;</span><br><span class="line">                <span class="comment">// 一个位置等于1的时候就是一个1x1的正方形了</span></span><br><span class="line">                <span class="keyword">if</span> (matrix[i][j] == <span class="string">&#x27;1&#x27;</span>) &#123;</span><br><span class="line">                    <span class="comment">// 从2x2的位置开始判断</span></span><br><span class="line">                    <span class="type">int</span> a = i + <span class="number">1</span>, b = j + <span class="number">1</span>;</span><br><span class="line">                    <span class="type">int</span> length = <span class="number">1</span>;      <span class="comment">// 当前正方形边长</span></span><br><span class="line">                    <span class="type">int</span> lengthCheck = <span class="number">1</span>; <span class="comment">// 正方形条件判断计数器</span></span><br><span class="line">                    <span class="comment">// 出现越界的时候停止扩张</span></span><br><span class="line">                    <span class="keyword">while</span> (a &lt; matrix.<span class="built_in">size</span>() &amp;&amp; b &lt; matrix[i].<span class="built_in">size</span>()) &#123;</span><br><span class="line">                    <span class="comment">// 这里不能用引用，避免修改数组里面的原始值</span></span><br><span class="line">                        pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; p = oneCount[a][b];</span><br><span class="line">                        <span class="comment">// 注意这里扩张的时候需要用lengthCheck来相减计算，而不是简单的减一</span></span><br><span class="line">                        <span class="comment">// 因为边长每扩大一次需要减的位置也会扩大一次</span></span><br><span class="line">                        p.first -=</span><br><span class="line">                            oneCount[a][b - lengthCheck].first; <span class="comment">// 行的前一个</span></span><br><span class="line">                        p.second -=</span><br><span class="line">                            oneCount[a - lengthCheck][b].second; <span class="comment">// 列的上一个</span></span><br><span class="line"></span><br><span class="line">                        <span class="comment">// 符合正方形要求</span></span><br><span class="line">                        <span class="keyword">if</span> (matrix[a][b] == <span class="string">&#x27;1&#x27;</span> &amp;&amp; (p.first == lengthCheck &amp;&amp;</span><br><span class="line">                                                    p.second == lengthCheck)) &#123;</span><br><span class="line">                            lengthCheck++;</span><br><span class="line">                            length++;</span><br><span class="line">                        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                            <span class="keyword">break</span>; <span class="comment">// 不符合就跳出</span></span><br><span class="line">                        &#125;</span><br><span class="line">                        a++;</span><br><span class="line">                        b++;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// 计算面积，更新最大值</span></span><br><span class="line">                    <span class="type">int</span> square = length * length;</span><br><span class="line">                    maxSquare = square &gt; maxSquare ? square : maxSquare;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxSquare;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/03/afa2032b4f1a3b38774d638dab2109fb.png"></p><h2 id="思路2-动态递归"><a href="#思路2-动态递归" class="headerlink" title="思路2-动态递归"></a>思路2-动态递归</h2><p>因为我还没有开始学动归的算法，只学一道题其他的还是不会，不如留着到时候一起回顾。</p>]]></content>
    
    
    <summary type="html">leetcode刷题笔记-221最大正方形</summary>
    
    
    
    <category term="编程学习" scheme="https://blog.musnow.top/categories/%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="把题目都给刷干净" scheme="https://blog.musnow.top/categories/%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0/%E6%8A%8A%E9%A2%98%E7%9B%AE%E9%83%BD%E7%BB%99%E5%88%B7%E5%B9%B2%E5%87%80/"/>
    
    
    <category term="OJ刷题" scheme="https://blog.musnow.top/tags/OJ%E5%88%B7%E9%A2%98/"/>
    
    <category term="leetcode" scheme="https://blog.musnow.top/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>【leetcode】33.搜索旋转排序数组</title>
    <link href="https://blog.musnow.top/posts/2415384769/"/>
    <id>https://blog.musnow.top/posts/2415384769/</id>
    <published>2024-03-25T01:34:27.000Z</published>
    <updated>2024-03-25T02:05:18.000Z</updated>
    
    <content type="html"><![CDATA[<p>这道题是快手面经中提到的，在此记录：<a href="https://www.nowcoder.com/feed/main/detail/b17a674ca2ba4327b3105ffacd1f60b4">https://www.nowcoder.com/feed/main/detail/b17a674ca2ba4327b3105ffacd1f60b4</a></p><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><blockquote><p><a href="https://leetcode.cn/problems/search-in-rotated-sorted-array/description/">33. 搜索旋转排序数组</a></p></blockquote><p>整数数组 nums 按升序排列，数组中的值 互不相同 。</p><p>在传递给函数之前，nums 在预先未知的某个下标 k（0 &lt;&#x3D; k &lt; nums.length）上进行了 旋转，使数组变为 <code>[nums[k], nums[k+1], ..., nums[n-1], nums[0], nums[1], ..., nums[k-1]]</code>（下标 从 0 开始 计数）。例如， <code>[0,1,2,4,5,6,7]</code> 在下标 3 处经旋转后可能变为 <code>[4,5,6,7,0,1,2]</code> 。</p><p>给你 旋转后 的数组 nums 和一个整数 target ，如果 nums 中存在这个目标值 target ，则返回它的下标，否则返回 -1 。</p><p>你必须设计一个时间复杂度为 <code>O(log n)</code> 的算法解决此问题。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">示例 1：</span><br><span class="line">输入：nums = [4,5,6,7,0,1,2], target = 0</span><br><span class="line">输出：4</span><br><span class="line"></span><br><span class="line">示例 2：</span><br><span class="line">输入：nums = [4,5,6,7,0,1,2], target = 3</span><br><span class="line">输出：-1</span><br><span class="line"></span><br><span class="line">示例 3：</span><br><span class="line">输入：nums = [1], target = 0</span><br><span class="line">输出：-1</span><br></pre></td></tr></table></figure><p>提示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1 &lt;= nums.length &lt;= 5000</span><br><span class="line">-104 &lt;= nums[i] &lt;= 104</span><br><span class="line">nums 中的每个值都 独一无二</span><br><span class="line">题目数据保证 nums 在预先未知的某个下标上进行了旋转</span><br><span class="line">-104 &lt;= target &lt;= 104</span><br></pre></td></tr></table></figure><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>本题要求用<code>O(log n)</code>的算法解决这个问题，自然没有办法通过暴力遍历来解决了（不然就太简单了）。</p><p>看到log就要想到二分法，同时要想到二分法的前提是遍历的序列已经有序，但这道题并非是一个严格有序的数组，它会进行一定的旋转。</p><p>仔细观察旋转的方式，当选用下标k的时候，会将k和k以后的元素全部移动到数组开头，之前的元素移动到数组末尾。</p><p>可以拿纸笔多试试几次，就能得出来一个结论，不管数组的长度是奇数还是偶数，也不管k选择那一个地方，被旋转的部分（k和k以后）和没有被旋转的部分（k以前）的序列长度肯定<strong>相等</strong>或有一个<strong>更长</strong>！</p><p>这里假设二分法计算mid的公式是<code>left+(right-left)/2</code>，其中left初始值为0，right初始值是<code>nums.size()-1</code>，二者都是闭区间。因为上文提到的特性（被旋转的部分和没有被旋转的部分长度相等或有一个更长），使用这个公式计算出来的第一个mid值肯定是在某个有序序列之中！</p><p>这里举几个具体的例子：</p><ul><li>数组长度7（奇数），k&#x3D;3，即在下标3处旋转，此时k之前还有下标<code>0,1,2</code>三个数字，k和k以后还有<code>3,4,5,6</code>四个数字；k&#x3D;4时同理，k之前有四个数字，k以后有三个数字。<ul><li>此时计算<code>mid=0+(6-0)/2=3</code>，不管k选择什么，下标3肯定是在某个有序序列之中的，这个有序序列要么在下标3之前，要么在下标3之后。</li></ul></li><li>数组长度8（偶数），k&#x3D;4，此时k之前有<code>0,1,2,3</code>四个数字，k和k之后有下标<code>4,5,6,7</code>四个数字，被旋转和没有被旋转的部分一样长；k&#x3D;5时没有被旋转的部分更长，k&#x3D;3时被旋转的部分更长。<ul><li>此时计算<code>mid=0+(7-0)/2=3</code>，不管k选择哪一个，下标3还是肯定在某个有序序列之中！</li></ul></li></ul><p>现在我们能确认这个特性了，也就能用二分法解决这个问题了！思路就是通过判断mid左侧还是右侧有序，来确认left&#x2F;right边界，让下一轮的mid计算在有序序列中进行。</p><ul><li>如果nums[left]小于等于nums[mid]，则说明左侧有序（这里的等于判断是避免mid&#x3D;left的情况）</li><li>其他情况都可以归于右侧有序</li></ul><p>在循环体内，每一次都需要判断mid左侧还是右侧有序的，确认有序序列的位置之后，找target的操作就是在有序数组中通过二分法查找的思想了，时间复杂度是<code>O(log(N))</code>。</p><ul><li>为什么每一次都需要判断？</li></ul><p>因为target可能不在第一次找到的有序序列中，如下示例，第一次计算出来的mid&#x3D;3，虽然能确认mid的左侧是有序的，但target&#x3D;1的时候，我们需要找的目标数是在mid的右侧。此时右侧的序列是<code>[7,0,1,2]</code>，这还不是一个有序序列，我们还是需要通过计算mid判断左侧还是右侧有序，来再次确认第二个有序的子序列位置。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[3,4,5,6,7,0,1,2]</span><br></pre></td></tr></table></figure><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>思路理清楚了，代码就不难写了</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">search</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 旋转后的数组肯定是一部分有序的</span></span><br><span class="line">        <span class="comment">// 这个有序的部分肯定是在mid左侧或者右侧！</span></span><br><span class="line">        <span class="comment">// 题目中的旋转是从k开始（包括k）往后的数字移动到数组的开头</span></span><br><span class="line">        <span class="comment">// 不管k选择哪里都肯定符合上面的这个条件，永远会有一边的数字更多</span></span><br><span class="line">        <span class="comment">// [4,5,6,7,0,1,2] 以mid=3分割</span></span><br><span class="line">        <span class="comment">// [4,5,6,7]       有序</span></span><br><span class="line">        <span class="comment">//       [7,0,1,2] 无序</span></span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> left = <span class="number">0</span>, right = nums.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 如果要使用小于等于，那么left和right应该都是闭区间</span></span><br><span class="line">        <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">            <span class="type">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">            <span class="comment">// 中间能找到</span></span><br><span class="line">            <span class="keyword">if</span> (nums[mid] == target) &#123;</span><br><span class="line">                <span class="keyword">return</span> mid;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 找不到，判断左侧或者右侧是否有序</span></span><br><span class="line">            <span class="keyword">if</span> (nums[left] &lt;= nums[mid]) <span class="comment">// 左侧有序</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// 判断值是否在左侧</span></span><br><span class="line">                <span class="keyword">if</span> (nums[left] &lt;= target &amp;&amp; target &lt; nums[mid]) &#123;</span><br><span class="line">                    right = mid - <span class="number">1</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="comment">// 左侧虽然有序，但是值在右侧</span></span><br><span class="line">                &#123;</span><br><span class="line">                    left = mid + <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 左半部分不是有序，说明右半部分是有序的</span></span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 值在右侧</span></span><br><span class="line">                <span class="keyword">if</span> (nums[right] &gt;= target &amp;&amp; target &gt; nums[mid]) &#123;</span><br><span class="line">                    left = mid + <span class="number">1</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    right = mid - <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/03/aebfd954000d9b32c58a81cfa094adf3.png" alt="image.png"></p>]]></content>
    
    
    <summary type="html">leetcode的33搜索旋转排序数组</summary>
    
    
    
    <category term="编程学习" scheme="https://blog.musnow.top/categories/%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="把题目都给刷干净" scheme="https://blog.musnow.top/categories/%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0/%E6%8A%8A%E9%A2%98%E7%9B%AE%E9%83%BD%E7%BB%99%E5%88%B7%E5%B9%B2%E5%87%80/"/>
    
    
    <category term="OJ刷题" scheme="https://blog.musnow.top/tags/OJ%E5%88%B7%E9%A2%98/"/>
    
    <category term="leetcode" scheme="https://blog.musnow.top/tags/leetcode/"/>
    
    <category term="二分法" scheme="https://blog.musnow.top/tags/%E4%BA%8C%E5%88%86%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>【leetcode】895最大频率栈</title>
    <link href="https://blog.musnow.top/posts/1873646973/"/>
    <id>https://blog.musnow.top/posts/1873646973/</id>
    <published>2024-03-24T03:27:51.000Z</published>
    <updated>2024-03-25T01:33:59.000Z</updated>
    
    <content type="html"><![CDATA[<p>leetcode的895最大频率栈题解，题目来自快手面经：<a href="https://www.nowcoder.com/discuss/493925109460135936">https://www.nowcoder.com/discuss/493925109460135936</a></p><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><blockquote><p><a href="https://leetcode.cn/problems/maximum-frequency-stack/description/">895. 最大频率栈</a></p></blockquote><p>设计一个类似堆栈的数据结构，将元素推入堆栈，并从堆栈中弹出出现频率最高的元素。</p><p>实现 FreqStack 类:</p><ul><li>FreqStack() 构造一个空的堆栈。</li><li>void push(int val) 将一个整数 val 压入栈顶。</li><li>int pop() 删除并返回堆栈中出现频率最高的元素。</li></ul><p>如果出现频率最高的元素不只一个，则移除并返回最接近栈顶的元素。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">示例 1：</span><br><span class="line">输入：</span><br><span class="line">[&quot;FreqStack&quot;,&quot;push&quot;,&quot;push&quot;,&quot;push&quot;,&quot;push&quot;,&quot;push&quot;,&quot;push&quot;,&quot;pop&quot;,&quot;pop&quot;,&quot;pop&quot;,&quot;pop&quot;],</span><br><span class="line">[[],[5],[7],[5],[7],[4],[5],[],[],[],[]]</span><br><span class="line">输出：[null,null,null,null,null,null,null,5,7,5,4]</span><br><span class="line"></span><br><span class="line">解释：</span><br><span class="line">FreqStack = new FreqStack();</span><br><span class="line">freqStack.push (5);//堆栈为 [5]</span><br><span class="line">freqStack.push (7);//堆栈是 [5,7]</span><br><span class="line">freqStack.push (5);//堆栈是 [5,7,5]</span><br><span class="line">freqStack.push (7);//堆栈是 [5,7,5,7]</span><br><span class="line">freqStack.push (4);//堆栈是 [5,7,5,7,4]</span><br><span class="line">freqStack.push (5);//堆栈是 [5,7,5,7,4,5]</span><br><span class="line">freqStack.pop ();//返回 5 ，因为 5 出现频率最高。堆栈变成 [5,7,5,7,4]。</span><br><span class="line">freqStack.pop ();//返回 7 ，因为 5 和 7 出现频率最高，但7最接近顶部。堆栈变成 [5,7,5,4]。</span><br><span class="line">freqStack.pop ();//返回 5 ，因为 5 出现频率最高。堆栈变成 [5,7,4]。</span><br><span class="line">freqStack.pop ();//返回 4 ，因为 4, 5 和 7 出现频率最高，但 4 是最接近顶部的。堆栈变成 [5,7]。</span><br></pre></td></tr></table></figure><p>提示：</p><ul><li><code>0 &lt;= val &lt;= 109</code>;</li><li>push 和 pop 的操作数不大于 <code>2 * 104</code>。</li><li>输入保证在调用 pop 之前堆栈中至少有一个元素。</li></ul><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>看到hard直接害怕，题解一看发现好像没有那么难……就是让我自己想恐怕是想不出来的。</p><p>用哈希表加栈就能解决这个问题，另外还需一个int变量维护当前最高频率是多少。</p><ul><li>一个哈希表用于元素和频率的计数</li><li>一个哈希表用于频率和对应的栈</li></ul><p>当插入元素的时候</p><ul><li>元素出现频率加一</li><li>在对应频率的栈中插入元素（并不需要在之前的栈中删除元素）</li><li>更新当前最高频率</li></ul><p>当弹出元素的时候</p><ul><li>从最高频率的栈中弹出一个元素</li><li>该元素出现频率减一</li><li>如果最高频率的栈为空，则最高频率减一（因为每次都是以1的间隔增加的，所以减一的栈里面肯定会有元素）</li></ul><p>这样就能很巧妙的实现题目需要的栈。</p><ul><li>哈希表中频率从低到高能理解为是一层栈，因为后入的频率高的数在栈顶；</li><li>相同频率中又是一层栈；</li></ul><p>即可以体现每一个数字的频率，又能保证栈的先入先出的特性！</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>思路并不难，代码实现也很简单</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">FreqStack</span> &#123;</span><br><span class="line">    unordered_map&lt;<span class="type">int</span>,stack&lt;<span class="type">int</span>&gt;&gt; stMap; <span class="comment">// 每个频率都有一个栈</span></span><br><span class="line">    unordered_map&lt;<span class="type">int</span>,<span class="type">int</span>&gt; countMap; <span class="comment">// 频率计数</span></span><br><span class="line">    <span class="type">int</span> maxFreq = <span class="number">0</span>; <span class="comment">// 最高频率</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">FreqStack</span>() &#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(<span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 将某个数字的频率加一</span></span><br><span class="line">        countMap[val]++;</span><br><span class="line">        stMap[countMap[val]].<span class="built_in">push</span>(val);</span><br><span class="line">        maxFreq = <span class="built_in">max</span>(maxFreq,countMap[val]);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 从最高频率的栈中pop一个元素即可</span></span><br><span class="line">        <span class="type">int</span> val = stMap[maxFreq].<span class="built_in">top</span>();</span><br><span class="line">        stMap[maxFreq].<span class="built_in">pop</span>();</span><br><span class="line">        <span class="comment">// 频率减一</span></span><br><span class="line">        countMap[val]--;</span><br><span class="line">        <span class="comment">// 如果最大频率栈没有内容，则减一</span></span><br><span class="line">        <span class="keyword">if</span>(stMap[maxFreq].<span class="built_in">empty</span>())&#123;</span><br><span class="line">            maxFreq--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> val;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your FreqStack object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * FreqStack* obj = new FreqStack();</span></span><br><span class="line"><span class="comment"> * obj-&gt;push(val);</span></span><br><span class="line"><span class="comment"> * int param_2 = obj-&gt;pop();</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/03/4ad7ed2196fbbbced588884ca9441c12.png" alt="image.png"></p>]]></content>
    
    
    <summary type="html">leetcode的895最大频率栈题解</summary>
    
    
    
    <category term="编程学习" scheme="https://blog.musnow.top/categories/%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="把题目都给刷干净" scheme="https://blog.musnow.top/categories/%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0/%E6%8A%8A%E9%A2%98%E7%9B%AE%E9%83%BD%E7%BB%99%E5%88%B7%E5%B9%B2%E5%87%80/"/>
    
    
    <category term="OJ刷题" scheme="https://blog.musnow.top/tags/OJ%E5%88%B7%E9%A2%98/"/>
    
    <category term="栈" scheme="https://blog.musnow.top/tags/%E6%A0%88/"/>
    
    <category term="哈希" scheme="https://blog.musnow.top/tags/%E5%93%88%E5%B8%8C/"/>
    
    <category term="leetcode" scheme="https://blog.musnow.top/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>【leetcode】540.有序数组中的单一元素</title>
    <link href="https://blog.musnow.top/posts/3000154357/"/>
    <id>https://blog.musnow.top/posts/3000154357/</id>
    <published>2024-03-24T02:47:49.000Z</published>
    <updated>2024-03-25T02:05:18.000Z</updated>
    
    <content type="html"><![CDATA[<p>这道题是很久以前的快手CPP面经中出现的，在此记录一下咋写</p><blockquote><p><a href="https://www.nowcoder.com/discuss/353156663853129728?sourceSSR=users">https://www.nowcoder.com/discuss/353156663853129728?sourceSSR=users</a></p></blockquote><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><blockquote><p><a href="https://leetcode.cn/problems/single-element-in-a-sorted-array/">540. 有序数组中的单一元素</a></p></blockquote><p>给你一个仅由整数组成的有序数组，其中每个元素都会出现两次，唯有一个数只会出现一次。</p><p>请你找出并返回只出现一次的那个数。</p><p>你设计的解决方案必须满足 <code>O(log n)</code> 时间复杂度和 <code>O(1)</code> 空间复杂度。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">示例 1:</span><br><span class="line">输入: nums = [1,1,2,3,3,4,4,8,8]</span><br><span class="line">输出: 2</span><br><span class="line"></span><br><span class="line">示例 2:</span><br><span class="line">输入: nums =  [3,3,7,7,10,11,11]</span><br><span class="line">输出: 10</span><br></pre></td></tr></table></figure><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>这道题如果用暴力遍历的话，<code>O(N)</code>的时间复杂度很容易搞定，比如遍历一遍用map记录一下每个元素出现的次数，再遍历一遍map就能得到结果。</p><p>但是题目要求是用<code>O(log N)</code>的时间复杂度，这就没有办法直接遍历了。但题目中给出的数组是有序的，再加上<code>O(log N)</code>的时间复杂度，这就需要我们能想到用二分法来解决这道题。</p><p>现在确定是用二分法了，具体怎么二分呢？这又不是比大小找元素！</p><p>先观察一下给出的数组，以示例一为例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[1,1,2,3,3,4,4,8,8]</span><br></pre></td></tr></table></figure><p>将这个数组中的2补全，即所有元素都出现两次</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[1,1,2,2,3,3,4,4,8,8]</span><br><span class="line"> 0 1 2 3 4 5 6 7 8 9</span><br></pre></td></tr></table></figure><p>能发现一个规律：奇数下标上的数和前一个数相同，偶数下标上的数和后一个数相同。</p><p>那么对于不符合条件的数组，我们只需要判断mid（数组中间）的元素</p><ul><li>如果mid是奇数，判断它是否和<strong>前一个数</strong>相同，如果相同，则能确定<strong>只出现一次的数</strong>是在mid的后边，不同则在mid之前；</li><li>如果mid是偶数，判断它是否和<strong>后一个数</strong>相同，如果相同，则能确定<strong>只出现一次的数</strong>是在mid的后边，不同则在mid之前；</li></ul><p>思路确定了，就可以写代码了</p><h2 id="代码1-if-x2F-else"><a href="#代码1-if-x2F-else" class="headerlink" title="代码1-if&#x2F;else"></a>代码1-if&#x2F;else</h2><p>这里用if&#x2F;else实现上述思路比较好理解</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">singleNonDuplicate</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> left = <span class="number">0</span>, right = nums.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">            <span class="type">int</span> mid = (left + right) / <span class="number">2</span>;</span><br><span class="line">            <span class="comment">// cout &lt;&lt; left &lt;&lt; &quot; - &quot; &lt;&lt; right &lt;&lt; &quot; - &quot; &lt;&lt; mid &lt;&lt; &quot;\n&quot;;</span></span><br><span class="line">            <span class="comment">// 偶数</span></span><br><span class="line">            <span class="keyword">if</span> (mid % <span class="number">2</span> == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// 判断下一位是否和当前位相同</span></span><br><span class="line">                <span class="keyword">if</span> (nums[mid] == nums[mid + <span class="number">1</span>]) &#123;</span><br><span class="line">                    left = mid + <span class="number">1</span>; <span class="comment">// 相同，在右边</span></span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;            <span class="comment">// 不相同，在左边</span></span><br><span class="line">                    right = mid;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="comment">// 奇数</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// 判断上一位是否和当前位相同</span></span><br><span class="line">                <span class="keyword">if</span> (nums[mid] == nums[mid - <span class="number">1</span>]) &#123;</span><br><span class="line">                    left = mid + <span class="number">1</span>; <span class="comment">// 相同，在右边</span></span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;            <span class="comment">// 不相同，在左边</span></span><br><span class="line">                    right = mid;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 最终left所在位置就是题目需要的位置</span></span><br><span class="line">        <span class="keyword">return</span> nums[left];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/03/6378e71101d5d91c31187030f33a78ac.png" alt="image-20240324111139325"></p><h2 id="代码2-位运算"><a href="#代码2-位运算" class="headerlink" title="代码2-位运算"></a>代码2-位运算</h2><p>使用位运算可以统一的处理奇数和偶数，代码能更加简洁。使用异或运算（相异为一相同为零）：</p><ul><li>奇数异或1等于奇数减一（奇数末尾为1，异或1后末尾为0，相当于减一）</li><li>偶数异或1等于偶数加一（偶数末尾为0，异或1后末尾为1，相当于加一）</li></ul><p>这样能写出如下代码，直接确定mid应该和谁进行比较</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">singleNonDuplicate</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> left = <span class="number">0</span>, right = nums.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">            <span class="type">int</span> mid = (left + right) / <span class="number">2</span>;</span><br><span class="line">            <span class="comment">// 奇数异或1等于奇数减一，偶数异或1等于偶数加一</span></span><br><span class="line">            <span class="keyword">if</span> (nums[mid] == nums[mid ^ <span class="number">1</span>]) &#123;</span><br><span class="line">                left = mid + <span class="number">1</span>; <span class="comment">// 在右边</span></span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="comment">// 在左边</span></span><br><span class="line">            &#123;</span><br><span class="line">                right = mid;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nums[left];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/03/b9b05e7fefe9f03540a7d457a468192d.png" alt="image-20240324111454584"></p>]]></content>
    
    
    <summary type="html">leetcode 540.有序数组中的单一元素</summary>
    
    
    
    <category term="编程学习" scheme="https://blog.musnow.top/categories/%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="把题目都给刷干净" scheme="https://blog.musnow.top/categories/%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0/%E6%8A%8A%E9%A2%98%E7%9B%AE%E9%83%BD%E7%BB%99%E5%88%B7%E5%B9%B2%E5%87%80/"/>
    
    
    <category term="Cpp" scheme="https://blog.musnow.top/tags/Cpp/"/>
    
    <category term="OJ刷题" scheme="https://blog.musnow.top/tags/OJ%E5%88%B7%E9%A2%98/"/>
    
    <category term="leetcode" scheme="https://blog.musnow.top/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>【算法】回溯算法</title>
    <link href="https://blog.musnow.top/posts/1548282049/"/>
    <id>https://blog.musnow.top/posts/1548282049/</id>
    <published>2024-03-22T02:44:51.000Z</published>
    <updated>2024-04-06T08:38:29.000Z</updated>
    
    <content type="html"><![CDATA[<p>参考《代码随想录》。</p><h1 id="1-什么是回溯？"><a href="#1-什么是回溯？" class="headerlink" title="1.什么是回溯？"></a>1.什么是回溯？</h1><h2 id="1-1-引言"><a href="#1-1-引言" class="headerlink" title="1.1 引言"></a>1.1 引言</h2><p>回溯算法简单说来是通过递归进行遍历，他并不是一个高效的算法，因为整个遍历的过程是在穷举所有可能的结果。</p><p>在二叉树的OJ刷题博客中，就已经遇到了使用了回溯思路的题目。比如<a href="https://leetcode.cn/problems/path-sum/description/">Leetcode 112 路径总和</a>这道题，递归参数中的curSum就是利用回溯的的思路，从上层往下传的。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">traversal</span><span class="params">(TreeNode* cur, <span class="type">int</span> count)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!cur-&gt;left &amp;&amp; !cur-&gt;right &amp;&amp; count == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">true</span>; <span class="comment">// 遇到叶子节点，并且计数为0</span></span><br><span class="line">        <span class="keyword">if</span> (!cur-&gt;left &amp;&amp; !cur-&gt;right) <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">// 遇到叶子节点直接返回</span></span><br><span class="line">   <span class="comment">// 这里体现回溯的思想，先将要遍历的下一层的值添加进去，然后再撤销操作。这样能让下一层先判断自己是否为叶子节点来正确停止递归。</span></span><br><span class="line">        <span class="keyword">if</span> (cur-&gt;left) &#123; <span class="comment">// 左</span></span><br><span class="line">            count -= cur-&gt;left-&gt;val; <span class="comment">// 递归，处理节点;</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">traversal</span>(cur-&gt;left, count)) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            count += cur-&gt;left-&gt;val; <span class="comment">// 回溯，撤销处理结果</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (cur-&gt;right) &#123; <span class="comment">// 右</span></span><br><span class="line">            count -= cur-&gt;right-&gt;val; <span class="comment">// 递归，处理节点;</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">traversal</span>(cur-&gt;right, count)) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            count += cur-&gt;right-&gt;val; <span class="comment">// 回溯，撤销处理结果</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">hasPathSum</span><span class="params">(TreeNode* root, <span class="type">int</span> sum)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">traversal</span>(root, sum - root-&gt;val);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="1-2-什么问题用回溯能解决？"><a href="#1-2-什么问题用回溯能解决？" class="headerlink" title="1.2 什么问题用回溯能解决？"></a>1.2 什么问题用回溯能解决？</h2><p>回溯法，一般可以解决如下几种问题：</p><ul><li>组合问题：N个数里面按一定规则找出k个数的集合</li><li>切割问题：一个字符串按一定规则有几种切割方式</li><li>子集问题：一个N个数的集合里有多少符合条件的子集</li><li>排列问题：N个数按一定规则全排列，有几种排列方式</li><li>棋盘问题：N皇后，解数独等等</li></ul><p>这些问题一般都涉及到了切割和组合，可以把一个大的集合通过一定的选择（当前层）再往下一层切割（缩小范围）来解决。通过这个思路整体看来，回溯法就很类似树形结构，与二叉树的递归遍历类似。</p><h2 id="1-3-回溯法模板"><a href="#1-3-回溯法模板" class="headerlink" title="1.3 回溯法模板"></a>1.3 回溯法模板</h2><p>在代码随想录中Carl大佬总结了一个回溯法的模板，这里引用如下。</p><p>既然回溯法用的大多都是递归，那么就需要明确递归的三部曲</p><ul><li>递归的参数</li><li>递归的末端返回情况（终止条件）</li><li>递归的单层操作逻辑</li></ul><p>对于回溯法也是一样的</p><ul><li>回溯函数（递归函数）的参数</li><li>回溯函数的末端返回情况（终止条件）</li><li>回溯函数单层的选择（通常是遍历）</li></ul><p>所以回溯法的代码模板如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">void fallback(参数)</span><br><span class="line">&#123;</span><br><span class="line">if(终止条件)&#123;</span><br><span class="line">// 一般是存放结果到返回值数组中</span><br><span class="line">        return;</span><br><span class="line">&#125;</span><br><span class="line">// 单层逻辑</span><br><span class="line">for(循环逻辑，一般是树中节点孩子的数量就是当前层的处理数量)</span><br><span class="line">&#123;</span><br><span class="line">// 处理节点</span><br><span class="line">fallback(参数) // 递归下一层</span><br><span class="line">// 撤销操作</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="2-组合问题"><a href="#2-组合问题" class="headerlink" title="2.组合问题"></a>2.组合问题</h1><p>下面的编号都是leetcode的题目号</p><h2 id="77-组合问题"><a href="#77-组合问题" class="headerlink" title="77 组合问题"></a>77 组合问题</h2><h3 id="题目和思路"><a href="#题目和思路" class="headerlink" title="题目和思路"></a>题目和思路</h3><blockquote><p><a href="https://leetcode.cn/problems/combinations/">77. 组合</a></p></blockquote><p>给定两个整数 <code>n</code> 和 <code>k</code>，返回范围 <code>[1, n]</code> 中所有可能的 <code>k</code> 个数的组合。</p><p>你可以按 <strong>任何顺序</strong> 返回答案。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">示例 1：</span><br><span class="line">输入：n = 4, k = 2</span><br><span class="line">输出：</span><br><span class="line">[</span><br><span class="line">  [2,4],</span><br><span class="line">  [3,4],</span><br><span class="line">  [2,3],</span><br><span class="line">  [1,2],</span><br><span class="line">  [1,3],</span><br><span class="line">  [1,4],</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">示例 2：</span><br><span class="line">输入：n = 1, k = 1</span><br><span class="line">输出：[[1]]</span><br></pre></td></tr></table></figure><p>这道题用循环暴力也不是不能写，但是一层K就需要多写一层循环，很难实现一个通用的暴力算法。所以需要用到递归的回溯算法来解决这道题。</p><p>这里直接借用一下代码随想录的图，每一层遍历就选择一个数字，再往下一层从这个值往后选择，直到长度为K或循环超出边界。</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/03/e2aecbc992ef998255f12b7dc1deab95.png" alt="image-20240322105026000"></p><p>根据这个思路，递归函数的参数如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// n 和 k 是题目的参数</span></span><br><span class="line"><span class="comment">// start 是本层循环中开始循环的值（左边界）</span></span><br><span class="line"><span class="comment">// curV 保存当前递归的集合，这里不能采用引用传参，因为上一层会进行回溯撤销</span></span><br><span class="line"><span class="comment">// retV 保存最终的结果，使用引用传参；</span></span><br><span class="line"><span class="type">void</span> _combine(<span class="type">int</span> n,<span class="type">int</span> k,<span class="type">int</span> start,<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt; curV,<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;&gt;&amp; retV)</span><br></pre></td></tr></table></figure><p>递归的终止条件是curV中的元素个数等于K了（找到了一个符合条件的集合），就将curV插入到retV中。因为这里的curV传的不是引用，所以也不存在需要清空curV的操作。</p><blockquote><p>因为我们是通过递归来进行curV的插入操作的，所以同一个元素不会在一个集合中被多次插入，不需要考虑去重的问题。</p></blockquote><p>另外，还有一个隐含的终止条件是start大于n了，这在for循环的条件中就能体现出来，不需要单独处理。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = start;i&lt;=n;i++)</span><br></pre></td></tr></table></figure><p>每一层要做的事情就是从这个数字序列中选一个数出来插入当前数组curV，然后递归遍历下一层。调用完毕递归函数后，需要撤销当前选择的数，避免影响下一轮循环。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将当前值插入，然后递归进行下一次处理</span></span><br><span class="line">curV.push_back(i);</span><br><span class="line"><span class="comment">// 这里应该从当前遍历值的下一个开始继续操作</span></span><br><span class="line">_combine(n,k,i+<span class="number">1</span>,curV,retV);</span><br><span class="line">curV.pop_back(); <span class="comment">// 回溯，撤销这一次操作</span></span><br></pre></td></tr></table></figure><h3 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h3><p>代码如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// curV不需要加引用，因为是回溯算法</span></span><br><span class="line">    <span class="type">void</span> _combine(<span class="type">int</span> n,<span class="type">int</span> k,<span class="type">int</span> start,vector&lt;<span class="type">int</span>&gt; curV,vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; retV)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 数量足够，插入结果集</span></span><br><span class="line">        <span class="keyword">if</span>(curV.<span class="built_in">size</span>() == k)&#123;</span><br><span class="line">            retV.<span class="built_in">push_back</span>(curV);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 遍历进行回溯</span></span><br><span class="line">        <span class="comment">// for(int i = start;i&lt;=n;i++) // 正常遍历</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 剪枝操作，如果下一层剩下的都不足k个了，那就不需要继续了</span></span><br><span class="line">        <span class="comment">// 比如这一层是1 2 3 4，选择了3后只剩4，但k=4，此时完全不够长度，这次遍历是没有意义的</span></span><br><span class="line">        <span class="comment">// 计算n减去k还需要多少个，就能削减掉下一层不够用的情况</span></span><br><span class="line">        <span class="comment">// https://www.programmercarl.com/0077.%E7%BB%84%E5%90%88.html#%E6%80%9D%E8%B7%AF</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = start;i&lt;=n -(k-curV.<span class="built_in">size</span>()<span class="number">-1</span>);i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 将当前值插入，然后递归进行下一次处理</span></span><br><span class="line">            curV.<span class="built_in">push_back</span>(i);</span><br><span class="line">            <span class="comment">// 这里应该从当前遍历值的下一个开始继续操作</span></span><br><span class="line">            _combine(n,k,i+<span class="number">1</span>,curV,retV);</span><br><span class="line">            curV.<span class="built_in">pop_back</span>(); <span class="comment">// 回溯，撤销这一次操作</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">combine</span>(<span class="type">int</span> n, <span class="type">int</span> k) &#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; retV;</span><br><span class="line">        <span class="comment">// 注意，题目给的范围是1到n</span></span><br><span class="line">        _combine(n,k,<span class="number">1</span>,<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(),retV);</span><br><span class="line">        <span class="keyword">return</span> retV;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/03/c5811aab6d8e76c042df2c650c64a57a.png" alt="image-20240322112408032"></p><h3 id="剪枝操作"><a href="#剪枝操作" class="headerlink" title="剪枝操作"></a>剪枝操作</h3><p>这里对如下for循环的<strong>剪枝操作</strong>做说明</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = start;i &lt;= n-(k-curV.size()<span class="number">-1</span>);i++)</span><br></pre></td></tr></table></figure><p>题目要求的是k个数的组合，当前还需要的数字的个数是<code>k-curV.size()</code>，<strong>除去当前层以外</strong>（这里确定的是循环边界，进循环后就会处理当前层），还需要<code>k-curV.size()-1</code>个数字。</p><p>也就是说，我们需要保证递归处理的<strong>下一层</strong>还能有<code>k-curV.size()-1</code>个数字供处理，如果没有，那么<strong>下一层就不需要进去了</strong>，因为下一层是没有意义的递归，会浪费时间和压栈消耗。</p><p>这个思路可以参考下图，当<code>N=4, K=3</code>的时候，选择3时下一层只剩一个数字4了，肯定找不到符合条件的K&#x3D;3长度的集合，所以在第一层遍历的时候，就可以直接跳过3和3之后的数字，不进行遍历回溯。</p><p>这个计算也比较简单，下一层还需要2个，那就N-2就行了；下一层还需要3个就是N-3（留了最后三个不用）。题目给的N是一个闭区间，不需要额外处理。</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/03/75a031ea3bd57221f044a733a474815c.png" alt="image-20240322103240017"></p><p>反应到代码上，for循环的边界值就成了<code>n-(k-curV.size()-1)</code>，这样就能保证无论如何往下的递归一定能找到至少一个符合长度为K的集合。</p><p>在代码随想录网站上，描述的是用<code> n - (k - path.size()) + 1</code>这个边界进行剪枝，这个公式和上面我提供的公式是一致的，个人感觉我的那个公式的思路更好理解一些。</p><h2 id="216-组合总和3"><a href="#216-组合总和3" class="headerlink" title="216 组合总和3"></a>216 组合总和3</h2><h3 id="题目和思路-1"><a href="#题目和思路-1" class="headerlink" title="题目和思路"></a>题目和思路</h3><blockquote><p><a href="https://leetcode.cn/problems/combination-sum-iii/">216. 组合总和 III</a></p></blockquote><p>找出所有相加之和为 <code>n</code> 的 <code>k</code> 个数的组合，且满足下列条件：</p><ul><li>只使用数字1到9</li><li>每个数字 <strong>最多使用一次</strong></li></ul><p>返回 <em>所有可能的有效组合的列表</em> 。该列表不能包含相同的组合两次，组合可以以任何顺序返回。</p><hr><p>这道题和上一题基本一致，上一题给出的n是1到n的边界，这道题锁定了边界是1到9，额外多了一个要求是k个数的和要为n。</p><p>题目中还有个要求是每个数组最多使用一次，这也和我们回溯算法的思路一致，因为是从上层往下每次选用一个数进行递归的，并不会出现同一个数使用多次的情况。</p><h3 id="代码模板"><a href="#代码模板" class="headerlink" title="代码模板"></a>代码模板</h3><p>递归函数的参数和上一道题目一致，多了一个sum用于保存当前数组内元素的和</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// n 和 k 是题目的参数</span></span><br><span class="line"><span class="comment">// start 是本层循环中开始循环的值（左边界）</span></span><br><span class="line"><span class="comment">// sum  当前curV数组内元素的和</span></span><br><span class="line"><span class="comment">// curV 保存当前递归的集合，这里不能采用引用传参，因为上一层会进行回溯撤销</span></span><br><span class="line"><span class="comment">// retV 保存最终的结果，使用引用传参；</span></span><br><span class="line"><span class="type">void</span> _combinationSum3(<span class="type">int</span> k, <span class="type">int</span> n,<span class="type">int</span> start,<span class="type">int</span> sum, vector&lt;<span class="type">int</span>&gt; curV,vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; retV )</span><br></pre></td></tr></table></figure><p>递归的终止条件是curV中的元素大小等于k，然后判断成员的和是否为n，如果为n才插入返回值数组retV。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(curV.<span class="built_in">size</span>() == k)&#123;</span><br><span class="line">    <span class="keyword">if</span>(sum == n)&#123;</span><br><span class="line">        retV.<span class="built_in">push_back</span>(curV);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一行的遍历也是一样的，将当前值插入数组，然后递归道下一层，并将当前层的操作撤销</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = start;i&lt;=<span class="number">9</span>;i++)</span><br><span class="line">      &#123;</span><br><span class="line">          <span class="comment">// 单层操作</span></span><br><span class="line">          curV.<span class="built_in">push_back</span>(i);</span><br><span class="line">          sum += i; </span><br><span class="line">          <span class="comment">// 递归下一层</span></span><br><span class="line">          _combinationSum3(k,n,i+<span class="number">1</span>,sum,curV,retV);</span><br><span class="line">          <span class="comment">// 撤销</span></span><br><span class="line">          curV.<span class="built_in">pop_back</span>();</span><br><span class="line">          sum -= i;</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure><p>上述代码可以进行简化，对sum的操作改为直接在传值的时候加一下i；</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = start;i&lt;=<span class="number">9</span>;i++)</span><br><span class="line">&#123;</span><br><span class="line">    curV.<span class="built_in">push_back</span>(i);</span><br><span class="line">    _combinationSum3(k,n,i+<span class="number">1</span>,sum+i,curV,retV);</span><br><span class="line">    curV.<span class="built_in">pop_back</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="完整代码-1"><a href="#完整代码-1" class="headerlink" title="完整代码"></a>完整代码</h3><p>完整代码如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="type">void</span> _combinationSum3(<span class="type">int</span> k, <span class="type">int</span> n,<span class="type">int</span> start,<span class="type">int</span> sum, vector&lt;<span class="type">int</span>&gt; curV,vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; retV ) &#123; </span><br><span class="line">        <span class="keyword">if</span>(curV.<span class="built_in">size</span>() == k)&#123;</span><br><span class="line">            <span class="keyword">if</span>(sum == n)&#123;</span><br><span class="line">                retV.<span class="built_in">push_back</span>(curV);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 一次遍历</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = start;i&lt;=<span class="number">9</span>;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            curV.<span class="built_in">push_back</span>(i);</span><br><span class="line">            _combinationSum3(k,n,i+<span class="number">1</span>,sum+i,curV,retV);</span><br><span class="line">            curV.<span class="built_in">pop_back</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">combinationSum3</span>(<span class="type">int</span> k, <span class="type">int</span> n) &#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; retV;</span><br><span class="line">        _combinationSum3(k,n,<span class="number">1</span>,<span class="number">0</span>,<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(),retV);</span><br><span class="line">        <span class="keyword">return</span> retV;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/03/5647647f20a4d1f98bbdec6206e98f4d.png" alt="image-20240322145222332"></p><h3 id="剪枝操作-1"><a href="#剪枝操作-1" class="headerlink" title="剪枝操作"></a>剪枝操作</h3><p>和77题一样，上述的代码也能进行剪枝操作。分别针对的是k个数字和n的值</p><ul><li>下一层不够<code>k-curV.size()</code>个数字的时候就不需要递归下一层了。</li><li>当前加上i之后已经超过sum了就不需要递归下一层了。</li></ul><p>优化后的代码如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="type">void</span> _combinationSum3(<span class="type">int</span> k, <span class="type">int</span> n,<span class="type">int</span> start,<span class="type">int</span> sum, vector&lt;<span class="type">int</span>&gt; curV,vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; retV ) &#123; </span><br><span class="line">        <span class="keyword">if</span>(curV.<span class="built_in">size</span>() == k)&#123;</span><br><span class="line">            <span class="keyword">if</span>(sum == n)&#123;</span><br><span class="line">                retV.<span class="built_in">push_back</span>(curV);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 已经不符合条件，不进入循环</span></span><br><span class="line">        <span class="keyword">if</span>(sum &gt; n)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 一次遍历</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = start;i&lt;=<span class="number">9</span> -(k-curV.<span class="built_in">size</span>()<span class="number">-1</span>);i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 已经不符合条件，进入下一层</span></span><br><span class="line">            <span class="keyword">if</span>(sum + i &gt; n)&#123;</span><br><span class="line">                <span class="keyword">return</span>; <span class="comment">// 加i都已经超过n了，下一个数也没有必要遍历了</span></span><br><span class="line">            &#125;</span><br><span class="line">         </span><br><span class="line">            curV.<span class="built_in">push_back</span>(i);</span><br><span class="line">            _combinationSum3(k,n,i+<span class="number">1</span>,sum+i,curV,retV);</span><br><span class="line">            curV.<span class="built_in">pop_back</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">combinationSum3</span>(<span class="type">int</span> k, <span class="type">int</span> n) &#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; retV;</span><br><span class="line">        _combinationSum3(k,n,<span class="number">1</span>,<span class="number">0</span>,<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(),retV);</span><br><span class="line">        <span class="keyword">return</span> retV;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="17-电话号码的数字组合"><a href="#17-电话号码的数字组合" class="headerlink" title="17 电话号码的数字组合"></a>17 电话号码的数字组合</h2><h3 id="题目和思路-2"><a href="#题目和思路-2" class="headerlink" title="题目和思路"></a>题目和思路</h3><blockquote><p><a href="https://leetcode.cn/problems/letter-combinations-of-a-phone-number/">17. 电话号码的字母组合</a></p></blockquote><p>给定一个仅包含数字 <code>2-9</code> 的字符串，返回所有它能表示的字母组合。答案可以按 <strong>任意顺序</strong> 返回。</p><p>给出数字到字母的映射如下（与电话按键相同）。注意 1 不对应任何字母。</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/03/908402445c0fbd05c009b3852bcb0e18.png" alt="image-20240322145712851"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">示例 1：</span><br><span class="line">输入：digits = &quot;23&quot;</span><br><span class="line">输出：[&quot;ad&quot;,&quot;ae&quot;,&quot;af&quot;,&quot;bd&quot;,&quot;be&quot;,&quot;bf&quot;,&quot;cd&quot;,&quot;ce&quot;,&quot;cf&quot;]</span><br><span class="line"></span><br><span class="line">示例 2：</span><br><span class="line">输入：digits = &quot;&quot;</span><br><span class="line">输出：[]</span><br><span class="line"></span><br><span class="line">示例 3：</span><br><span class="line">输入：digits = &quot;2&quot;</span><br><span class="line">输出：[&quot;a&quot;,&quot;b&quot;,&quot;c&quot;]</span><br></pre></td></tr></table></figure><ul><li><code>0 &lt;= digits.length &lt;= 4</code></li><li><code>digits[i]</code> 是范围 <code>[&#39;2&#39;, &#39;9&#39;]</code> 的一个数字。</li></ul><hr><p>在早些年没有只能手机的时候，功能机一般都是九键的键盘（如上图所示），当时如果想在上面打字发短信，就需要按一个键来代表它下面的英文字母。比如你想打出字母h，就需要按4号键两次（第一次选中的是g，第二次是h）才能打出来。现在智能手机的九键键盘也是从这个设计思路衍生出来的，主要目的是增大屏幕上每个按键的大小，减少误触。</p><blockquote><p>题外话：作为00后还算是用过这种东西，在我高中之前用的都是功能机，当时父母为了不让我玩游戏没给我买智能手机。不过这不影响我在功能机上玩贪吃蛇和五子棋，哈哈。</p></blockquote><p>这道题就是让你算出来按下某个数字按键，他能打出什么字母组合的。</p><p>还是用回溯的思想，首先需要一个字符串数组来记录每一个按键对应的字母值。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;string&gt; num2str = &#123;</span><br><span class="line">        <span class="string">&quot;&quot;</span>, <span class="comment">/* 0 */</span></span><br><span class="line">        <span class="string">&quot;&quot;</span>, <span class="comment">/* 1 */</span></span><br><span class="line">        <span class="string">&quot;abc&quot;</span>,</span><br><span class="line">        <span class="string">&quot;def&quot;</span>,</span><br><span class="line">        <span class="string">&quot;ghi&quot;</span>,</span><br><span class="line">        <span class="string">&quot;jkl&quot;</span>,</span><br><span class="line">        <span class="string">&quot;mno&quot;</span>,</span><br><span class="line">        <span class="string">&quot;pqrs&quot;</span>,</span><br><span class="line">        <span class="string">&quot;tuv&quot;</span>,</span><br><span class="line">        <span class="string">&quot;wxyz&quot;</span></span><br><span class="line">    &#125;;</span><br></pre></td></tr></table></figure><p>对于这道题而言，每一次需要遍历的数组是对应数字的字符串，在这个字符串中选择一个字符后，往下一层遍历就行了。</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/03/03f0b9f54b359f787fa65db16b1aad7b.png" alt="image-20240322150726967"></p><h3 id="代码模板-1"><a href="#代码模板-1" class="headerlink" title="代码模板"></a>代码模板</h3><p>首先是递归函数的参数，包括题目传入的字符串（理解为char的数组就行），当前遍历的下标（题目给出的字符串内的下标），当前的字符串（不能用引用传参），以及最终的返回值数组</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> _letterCombinations(<span class="type">const</span> string&amp; digits,<span class="type">int</span> index,string str,vector&lt;string&gt;&amp; retV)</span><br></pre></td></tr></table></figure><p>因为leetcode的c++题解都是有一个solution类的，所以retV这类返回值完全可以用一个类的成员变量来替代，可以节省一个递归的参数（虽然没有太大区别）</p><p>递归函数的终止条件是index大于digits的长度（下标越界）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(index &gt;= digits.<span class="built_in">size</span>())&#123;</span><br><span class="line">    retV.<span class="built_in">push_back</span>(str);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一层遍历中的处理如下，这里我单独判断处理了1（但题目给出的用例中其实不包含0和1），注意每一层遍历的字符串并不是digits，而是当前数字在键盘中对应的字母字符串。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 通过ascii的计算得出当前数字，并找到curStr中映射的字符串</span></span><br><span class="line"><span class="type">int</span> num = digits[index] - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line"><span class="keyword">if</span>(num &lt; <span class="number">2</span>) <span class="comment">// 没有对应的</span></span><br><span class="line">&#123;</span><br><span class="line">    retV.<span class="built_in">push_back</span>(str);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 一层的遍历</span></span><br><span class="line">string&amp; curStr = num2str[num];</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i&lt;curStr.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">    str.<span class="built_in">push_back</span>(curStr[i]);</span><br><span class="line">    _letterCombinations(digits,index+<span class="number">1</span>,str,retV);</span><br><span class="line">    str.<span class="built_in">pop_back</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="完整代码-2"><a href="#完整代码-2" class="headerlink" title="完整代码"></a>完整代码</h3><p>完整代码如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    vector&lt;string&gt; num2str = &#123;</span><br><span class="line">        <span class="string">&quot;&quot;</span>, <span class="comment">/* 0 */</span></span><br><span class="line">        <span class="string">&quot;&quot;</span>, <span class="comment">/* 1 */</span></span><br><span class="line">        <span class="string">&quot;abc&quot;</span>,</span><br><span class="line">        <span class="string">&quot;def&quot;</span>,</span><br><span class="line">        <span class="string">&quot;ghi&quot;</span>,</span><br><span class="line">        <span class="string">&quot;jkl&quot;</span>,</span><br><span class="line">        <span class="string">&quot;mno&quot;</span>,</span><br><span class="line">        <span class="string">&quot;pqrs&quot;</span>,</span><br><span class="line">        <span class="string">&quot;tuv&quot;</span>,</span><br><span class="line">        <span class="string">&quot;wxyz&quot;</span></span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="type">void</span> _letterCombinations(<span class="type">const</span> string&amp; digits,<span class="type">int</span> index,string str,vector&lt;string&gt;&amp; retV) &#123;</span><br><span class="line">        <span class="keyword">if</span>(index &gt;= digits.<span class="built_in">size</span>())&#123;</span><br><span class="line">            retV.<span class="built_in">push_back</span>(str);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 通过ascii的计算得出当前数字，并找到curStr中映射的字符串</span></span><br><span class="line">        <span class="type">int</span> num = digits[index] - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">        <span class="keyword">if</span>(num &lt; <span class="number">2</span>) <span class="comment">// 没有对应的</span></span><br><span class="line">        &#123;</span><br><span class="line">            retV.<span class="built_in">push_back</span>(str);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 一层的遍历</span></span><br><span class="line">        string&amp; curStr = num2str[num];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i&lt;curStr.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            str.<span class="built_in">push_back</span>(curStr[i]);</span><br><span class="line">            _letterCombinations(digits,index+<span class="number">1</span>,str,retV);</span><br><span class="line">            str.<span class="built_in">pop_back</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;string&gt; <span class="title">letterCombinations</span><span class="params">(string digits)</span> </span>&#123;</span><br><span class="line">        vector&lt;string&gt; retV;</span><br><span class="line">        <span class="comment">// 单独判断一下空字符串</span></span><br><span class="line">        <span class="keyword">if</span>(digits == <span class="string">&quot;&quot;</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> retV;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        _letterCombinations(digits,<span class="number">0</span>,<span class="string">&quot;&quot;</span>,retV);</span><br><span class="line">        <span class="keyword">return</span> retV;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/03/c92703d3a59494e906d3abb632f557bf.png" alt="image-20240322151941756"></p><p>因为这道题每一次遍历的都不一定是同一个字符串，所以不存在剪枝操作，只能通过递归遍历完毕整个digits字符串。</p><h2 id="39-组合总和"><a href="#39-组合总和" class="headerlink" title="39 组合总和"></a>39 组合总和</h2><h3 id="题目和思路-3"><a href="#题目和思路-3" class="headerlink" title="题目和思路"></a>题目和思路</h3><blockquote><p><a href="https://leetcode.cn/problems/combination-sum/">39. 组合总和</a></p></blockquote><p>给你一个 <strong>无重复元素</strong> 的整数数组 <code>candidates</code> 和一个目标整数 <code>target</code> ，找出 <code>candidates</code> 中可以使数字和为目标数 <code>target</code> 的 所有 <strong>不同组合</strong> ，并以列表形式返回。你可以按 <strong>任意顺序</strong> 返回这些组合。</p><p><code>candidates</code> 中的 <strong>同一个</strong> 数字可以 <strong>无限制重复被选取</strong> 。如果至少一个数字的被选数量不同，则两种组合是不同的。 </p><p>对于给定的输入，保证和为 <code>target</code> 的不同组合数少于 <code>150</code> 个。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">示例 1：</span><br><span class="line">输入：candidates = [2,3,6,7], target = 7</span><br><span class="line">输出：[[2,2,3],[7]]</span><br><span class="line">解释：</span><br><span class="line">2 和 3 可以形成一组候选，2 + 2 + 3 = 7 。注意 2 可以使用多次。</span><br><span class="line">7 也是一个候选， 7 = 7 。</span><br><span class="line">仅有这两种组合。</span><br><span class="line"></span><br><span class="line">示例 2：</span><br><span class="line">输入: candidates = [2,3,5], target = 8</span><br><span class="line">输出: [[2,2,2,2],[2,3,3],[3,5]]</span><br><span class="line"></span><br><span class="line">示例 3：</span><br><span class="line">输入: candidates = [2], target = 1</span><br><span class="line">输出: []</span><br></pre></td></tr></table></figure><h3 id="错误代码"><a href="#错误代码" class="headerlink" title="错误代码"></a>错误代码</h3><p>这道题还是用回溯，和上面的组合问题的代码基本一致。</p><ul><li>和等于target的时候终止递归</li><li>每一层都遍历数组，而且可以选择上一层已经选过的数。</li><li>注意本题需要加的是<strong>数组元素</strong>的值，不是for循环里面的<code>i</code>；</li></ul><p>刚开始我写出来了一个错误的代码，主要是看循环部分，我这里选用了每一层都直接重新遍历整个数组，这是不对的！</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="type">void</span> _combinationSum(vector&lt;<span class="type">int</span>&gt;&amp; candidates, <span class="type">int</span> target, <span class="type">int</span> sum,</span><br><span class="line">                         vector&lt;<span class="type">int</span>&gt; curV, vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; retV) &#123;</span><br><span class="line">        <span class="comment">// 值相等，插入</span></span><br><span class="line">        <span class="keyword">if</span> (sum == target) &#123;</span><br><span class="line">            retV.<span class="built_in">push_back</span>(curV);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 值已经大于了，不进入</span></span><br><span class="line">        <span class="keyword">if</span> (sum &gt; target) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 每一层都是直接重新遍历整个数组</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; candidates.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="comment">// 值已经大于了，不进入</span></span><br><span class="line">            <span class="keyword">if</span> (sum + candidates[i] &gt; target) &#123;</span><br><span class="line">                <span class="keyword">continue</span>; <span class="comment">// 数组不一定是升序排列的，所以还需要往后走</span></span><br><span class="line">            &#125;</span><br><span class="line">            curV.<span class="built_in">push_back</span>(candidates[i]);</span><br><span class="line">            _combinationSum(candidates, target, sum + candidates[i], curV, retV);</span><br><span class="line">            curV.<span class="built_in">pop_back</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">combinationSum</span>(vector&lt;<span class="type">int</span>&gt;&amp; candidates, <span class="type">int</span> target) &#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; retV;</span><br><span class="line">        <span class="keyword">if</span> (candidates.<span class="built_in">size</span>() == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> retV;</span><br><span class="line">        &#125;</span><br><span class="line">        _combinationSum(candidates, target, <span class="number">0</span>, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(), retV);</span><br><span class="line">        <span class="keyword">return</span> retV;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>哪怕是最简单的用例都错误了，肯定是有问题。</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/03/95abe26e517ae6b3f08db67377046257.png" alt="image-20240322153818632"></p><p>问题出在哪儿呢？先不说会有很多无效的递归。以上图用例举例，如果这一层选择了3，下一层还是从最开始选取，那么就会出现<code>3,2,...</code>这种选取方式，但这个选取如果有结果的话，那么这个结果在当时选择从2开始时<strong>就已经得到过一次</strong>了。</p><p>注意题目要求如果一个结果集中数字出现的次数相同则视为一个，即<code>[3,2,3]</code>和<code>[3,3,2]</code>是同一个结果，这两个结果在返回值数组中只能出现一次。上图的输出中就出现了这种重复的结果集，<strong>不符合题目的条件</strong>。</p><h3 id="正确代码"><a href="#正确代码" class="headerlink" title="正确代码"></a>正确代码</h3><p>这就要求我们修改思路了，上面的代码最大的问题是没有进行切分，每一层都还是一个完整的数组。只需要按之前的思路对每一层进行切分，就能解决。</p><p>首先是递归函数的参数中需要多一个starti，用来记录上一层是从哪一个数开始的</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> _combinationSum(vector&lt;<span class="type">int</span>&gt;&amp; candidates, <span class="type">int</span> target, <span class="type">int</span> sum,</span><br><span class="line">                     <span class="type">int</span> starti,vector&lt;<span class="type">int</span>&gt; curV, </span><br><span class="line">                     vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; retV)</span><br></pre></td></tr></table></figure><p>for循环中也需要修改，因为题目允许同一个数被选用多次，这里我们直接从starti开始选则，并且传参给下一层的时候，也不需要对i进行加一操作（这样下一层可以选择和上层相同的数字，也不会往前选择），就是正确的思路了！</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 每一层都是直接重新遍历整个数组</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = starti; i &lt; candidates.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">    <span class="comment">// 值已经大于了，不进入</span></span><br><span class="line">    <span class="keyword">if</span> (sum + candidates[i] &gt; target) &#123;</span><br><span class="line">        <span class="keyword">continue</span>; <span class="comment">// 数组不一定是升序排列的，所以还需要往后走</span></span><br><span class="line">    &#125;</span><br><span class="line">    curV.<span class="built_in">push_back</span>(candidates[i]);</span><br><span class="line">    _combinationSum(candidates, target, sum + candidates[i], i, curV,</span><br><span class="line">                    retV);</span><br><span class="line">    curV.<span class="built_in">pop_back</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最终完整的代码如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="type">void</span> _combinationSum(vector&lt;<span class="type">int</span>&gt;&amp; candidates, <span class="type">int</span> target, <span class="type">int</span> sum,</span><br><span class="line">                         <span class="type">int</span> starti, vector&lt;<span class="type">int</span>&gt; curV,</span><br><span class="line">                         vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; retV) &#123;</span><br><span class="line">        <span class="comment">// 值相等，插入</span></span><br><span class="line">        <span class="keyword">if</span> (sum == target) &#123;</span><br><span class="line">            retV.<span class="built_in">push_back</span>(curV);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 值已经大于了，不进入</span></span><br><span class="line">        <span class="keyword">if</span> (sum &gt; target) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 每一层都是直接重新遍历整个数组</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = starti; i &lt; candidates.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="comment">// 值已经大于了，不进入</span></span><br><span class="line">            <span class="keyword">if</span> (sum + candidates[i] &gt; target) &#123;</span><br><span class="line">                <span class="keyword">continue</span>; <span class="comment">// 数组不一定是升序排列的，所以还需要往后走</span></span><br><span class="line">            &#125;</span><br><span class="line">            curV.<span class="built_in">push_back</span>(candidates[i]);</span><br><span class="line">            _combinationSum(candidates, target, sum + candidates[i], i, curV,</span><br><span class="line">                            retV);</span><br><span class="line">            curV.<span class="built_in">pop_back</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">combinationSum</span>(vector&lt;<span class="type">int</span>&gt;&amp; candidates, <span class="type">int</span> target) &#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; retV;</span><br><span class="line">        <span class="keyword">if</span> (candidates.<span class="built_in">size</span>() == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> retV;</span><br><span class="line">        &#125;</span><br><span class="line">        _combinationSum(candidates, target, <span class="number">0</span>, <span class="number">0</span>, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(), retV);</span><br><span class="line">        <span class="keyword">return</span> retV;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/03/e3c8e0fd8756bbe9b90963fb7c27ba8e.png" alt="image-20240322154233646"></p><p>这道题的剪枝思路在上述代码中已经体现了，即当前值已经大于target了，就不需要进入下一次递归了。注意这里要用continue而不是直接return，因为题目给定的数组不一定是升序排列的，如果直接return可能会错过结果集。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 值已经大于了，不进入</span></span><br><span class="line"><span class="keyword">if</span> (sum + candidates[i] &gt; target) &#123;</span><br><span class="line"><span class="keyword">continue</span>; <span class="comment">// 数组不一定是升序排列的，所以还需要往后走</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="40-组合总和2"><a href="#40-组合总和2" class="headerlink" title="40 组合总和2"></a>40 组合总和2</h2><h3 id="题目和思路-4"><a href="#题目和思路-4" class="headerlink" title="题目和思路"></a>题目和思路</h3><blockquote><p><a href="https://leetcode.cn/problems/combination-sum-ii/">40. 组合总和 II</a></p></blockquote><p>给定一个候选人编号的集合 <code>candidates</code> 和一个目标数 <code>target</code> ，找出 <code>candidates</code> 中所有可以使数字和为 <code>target</code> 的组合。</p><p><code>candidates</code> 中的每个数字在每个组合中只能使用 <strong>一次</strong> 。</p><p><strong>注意：</strong>解集不能包含重复的组合。 </p><hr><p>这道题并不能简单的从上道39题目修改而来，因为题目给出的candidates数组有不同，在39题中，candidates数组是没有重复元素的，但这道题中有重复元素，组合内也允许出现重复元素，但最终返回值内的<strong>组合不能重复</strong>，这就在<strong>去重</strong>方面给了我们更多的要求。</p><ul><li>candidates数组中可能会有重复的元素；</li><li>下一层不能再选取相同的元素（对应代码中的i需要加一后传入下一层）；</li><li>返回值中的每个组合中可以出现重复元素；</li><li>返回值中<strong>相同的组合</strong>不能出现多次；</li></ul><p>一个比较简单的思路是用map或者set对最终的组合进行一次去重。在用例简单的时候，这样做不会超时，但用例多一点，再多来一次单独的去重操作就很容易超时了，所以最好是在遍历的时候就解决这个问题。</p><p>下图是代码随想录中的图（我自己画了老半天感觉画的很烂，还是借用一下老哥的图吧），主要的去重思路是，<strong>每一层选用的数需要进行去重</strong>，但下一层和上一层之间不需要去重。</p><p>比如第一层选用了第一个1后，第二层需要在<code>[1,2]</code>中选用，此时第二层依旧可以选用1；但是第一层往后的遍历中，数组的第二个1就不能选用了，应跳过。</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/03/47894f830f881ab3283894df07ba1ad0.png" alt="image-20240324100837881"></p><p>代码随想录中讲述到的思路是使用一个bool类型的used数组来实现这个功能，我觉得实在是麻烦且不是很好理解。</p><p>当然代码随想录后面还有一个比较简单的思路，也是我能想到的，即在for循环中直接判断<strong>当前数和上一个数是否相等</strong>来去重（跳过相等的情况）。对于回溯算法而言，每一次的for循环就是每一层了，符合题目需要的去重条件。</p><p>注意，使用这个办法需要将题目给出的数组进行<strong>排序</strong>（题目并没有保证给出的数组是有序的）。</p><h3 id="完整代码-3"><a href="#完整代码-3" class="headerlink" title="完整代码"></a>完整代码</h3><p>回溯递归的代码如下，在for循环中判断一下当前选用的元素和上一个是否相等就可以了。注意这里需要判断的是<code>i&gt;starti</code>而不是<code>i&gt;0</code>，因为<code>i&gt;starti</code>才能保证去重是在同一层上，<code>i&gt;0</code>虽然能保证不越界，但是下一层就无法选择和上一层的前一个相同的元素，不符合题目条件。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="type">void</span> _combinationSum2(vector&lt;<span class="type">int</span>&gt;&amp; candidates, <span class="type">int</span> target, <span class="type">int</span> sum,</span><br><span class="line">                          <span class="type">int</span> starti, vector&lt;<span class="type">int</span>&gt; curV,</span><br><span class="line">                          vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; retV) &#123;</span><br><span class="line">        <span class="comment">// 值相等，插入</span></span><br><span class="line">        <span class="keyword">if</span> (sum == target) &#123;</span><br><span class="line">            retV.<span class="built_in">push_back</span>(curV);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 值已经大于了，不进入</span></span><br><span class="line">        <span class="keyword">if</span> (sum &gt; target) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 每一层都是直接重新遍历整个数组</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = starti; i &lt; candidates.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="comment">// 当前值和上一次相同，跳过</span></span><br><span class="line">            <span class="comment">// i &gt; starti 保证是同一层的去重</span></span><br><span class="line">            <span class="keyword">if</span>(i &gt; starti &amp;&amp; candidates[i] == candidates[i<span class="number">-1</span>])&#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 值已经大于了，不进入</span></span><br><span class="line">            <span class="keyword">if</span> (sum + candidates[i] &gt; target) &#123;</span><br><span class="line">                <span class="keyword">return</span>; <span class="comment">// 已经对数组进行排序了，可以直接返回</span></span><br><span class="line">            &#125;</span><br><span class="line">            curV.<span class="built_in">push_back</span>(candidates[i]);</span><br><span class="line">            <span class="comment">// 这道题就需要对i加一了，因为下一层不能选择下标相同的数字；</span></span><br><span class="line">            _combinationSum2(candidates, target, sum + candidates[i], i + <span class="number">1</span>,</span><br><span class="line">                             curV, retV);</span><br><span class="line">            curV.<span class="built_in">pop_back</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">combinationSum2</span>(vector&lt;<span class="type">int</span>&gt;&amp; candidates, <span class="type">int</span> target) &#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; retV;</span><br><span class="line">        <span class="keyword">if</span> (candidates.<span class="built_in">size</span>() == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> retV;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">sort</span>(candidates.<span class="built_in">begin</span>(),candidates.<span class="built_in">end</span>());</span><br><span class="line">        _combinationSum2(candidates, target, <span class="number">0</span>, <span class="number">0</span>, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(), retV);</span><br><span class="line">        <span class="keyword">return</span> retV;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/03/2be650c1805cb352d63a7abf5c2bad89.png" alt="image-20240324101552367"></p><h1 id="3-切割问题"><a href="#3-切割问题" class="headerlink" title="3.切割问题"></a>3.切割问题</h1><p>切割问题的基本思路</p><ul><li>编写切割区间是否符合条件的判断函数</li><li>确定切割区间终止条件（递归终止条件）</li><li>确定单层循环如何指定切割区间。</li></ul><h2 id="131-分割回文串"><a href="#131-分割回文串" class="headerlink" title="131 分割回文串"></a>131 分割回文串</h2><h3 id="题目和思路-5"><a href="#题目和思路-5" class="headerlink" title="题目和思路"></a>题目和思路</h3><p>给你一个字符串 s，请你将 s 分割成一些子串，使每个子串都是 <strong>回文串</strong>。返回 s 所有可能的分割方案。</p><p>回文串是从从左往右读和从右往左读都完全一致的字符串。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">示例 1：</span><br><span class="line">输入：s = &quot;aab&quot;</span><br><span class="line">输出：[[&quot;a&quot;,&quot;a&quot;,&quot;b&quot;],[&quot;aa&quot;,&quot;b&quot;]]</span><br><span class="line"></span><br><span class="line">示例 2：</span><br><span class="line">输入：s = &quot;a&quot;</span><br><span class="line">输出：[[&quot;a&quot;]]</span><br></pre></td></tr></table></figure><p>提示</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1 &lt;= s.length &lt;= 16</span><br><span class="line">s 仅由小写英文字母组成</span><br></pre></td></tr></table></figure><p>思路依旧是用回溯，这是第一次遇到切割问题，我们主要是想办法通过下标区间“模拟”出来一个切割线。根据代码随想录提供的回溯模板，我们知道每一层都是一个for循环，此时就需要通过for循环的变量i来模拟一个切割线。</p><ul><li>当遍历到i时，认为<code>s[i]</code>和<code>s[i+1]</code>之间有一个切割线。</li></ul><p>和前文的组合问题一样，我们也需要一个startIndex来标识每一层for的起点。本题需要跳过之前已经选过的子串。</p><ul><li>可以认为<code>s[startIndex]</code>和上一位字符之间有另外一个切割线</li><li>这是上一层选中的切割线；</li><li>刚开始的时候，startIndex为0，<strong>切割线在字符串开头</strong>；</li></ul><p>for循环中什么时候需要递归到下一层呢？</p><ul><li>只有本层<code>[startIndex,i]</code>区域的字符串是一个回文串的时候，才需要递归下一层；</li><li>否则本层已经不满足条件，递归到下一层也是没有意义的！</li><li>本层区间已经是回文串，递归传入<code>startIndex+1</code>，从下一位开始选择新的回文子串；</li></ul><p>递归的终止条件是什么？</p><ul><li>前文提到，“当遍历到i时，认为<code>s[i]</code>和<code>s[i+1]</code>之间有一个切割线。”</li></ul><p>所以，当传入的startIndex为字符串size的时候，认为上一层的i已经走到了字符串末尾了，已经在字符串末尾处添加了一个切割线了，这时候就可以将结果插入数组了。</p><p>这里不需要做任何额外的判断，因为之前做的递归的判断条件已经决定了，能走到这里就说明所有子串已经满足回文条件。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (startIndex &gt;= s.<span class="built_in">size</span>()) &#123;</span><br><span class="line">    retV.<span class="built_in">push_back</span>(curV);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面是一个切割的示意图，方便理解。</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/04/306d6e19ed779dbd689f8e6c772c85ad.png" alt="image.png"></p><h3 id="完整代码-4"><a href="#完整代码-4" class="headerlink" title="完整代码"></a>完整代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    vector&lt;vector&lt;string&gt;&gt; retV; <span class="comment">// 返回值数组</span></span><br><span class="line">    vector&lt;string&gt; curV;         <span class="comment">// 当前的回文子串</span></span><br><span class="line"></span><br><span class="line">    <span class="type">void</span> _partition(string s, <span class="type">int</span> startIndex) &#123;</span><br><span class="line">        <span class="comment">// 越界，说明上一层i已经是s.size()-1，此时分割线是在字符串末尾；</span></span><br><span class="line">        <span class="comment">// 已经是最后一个分割线了，说明找到了符合条件的切割（没找到是走不到这里来的）</span></span><br><span class="line">        <span class="keyword">if</span> (startIndex &gt;= s.<span class="built_in">size</span>()) &#123;</span><br><span class="line">            retV.<span class="built_in">push_back</span>(curV);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 遍历，将下标当作子串</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = startIndex; i &lt; s.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="comment">// 如果是，将这里作为一个子串切割，递归到下一层找其他子串</span></span><br><span class="line">            <span class="comment">// 子串区间一直都是闭区间 [startIndex,i]</span></span><br><span class="line">            <span class="comment">// 此时i和i+1之间可以想象成有一个分割线</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">isReverseString</span>(s, startIndex, i)) &#123;</span><br><span class="line">            <span class="comment">// 插入当前选择的子串</span></span><br><span class="line">                string temp = s.<span class="built_in">substr</span>(startIndex, i - startIndex + <span class="number">1</span>);</span><br><span class="line">                curV.<span class="built_in">push_back</span>(temp);</span><br><span class="line">                <span class="comment">// 递归下一层</span></span><br><span class="line">                <span class="comment">// _partition(s, startIndex + 1); // 错误，i才是分割线位置</span></span><br><span class="line">                _partition(s, i + <span class="number">1</span>);</span><br><span class="line">                </span><br><span class="line">                <span class="comment">// 弹出当前选择的子串</span></span><br><span class="line">                curV.<span class="built_in">pop_back</span>(); <span class="comment">// 回溯</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 如果不是，这一次的切割已经无效了，直接跳过</span></span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 注意不能break，因为后序可能还会有回文的情况</span></span><br><span class="line">                <span class="comment">// 比如ab和aba</span></span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 判断是否为回文子串，双指针法</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isReverseString</span><span class="params">(<span class="type">const</span> string&amp; str, <span class="type">int</span> begin, <span class="type">int</span> end)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = begin, j = end; i &lt; j; i++, j--) &#123;</span><br><span class="line">            <span class="keyword">if</span> (str[i] != str[j]) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;string&gt;&gt; <span class="built_in">partition</span>(string s) &#123;</span><br><span class="line">        _partition(s, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> retV;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/04/8ecd5435bbc64b90bf69a31229a408b1.png" alt="image.png"></p><h2 id="93-复原IP地址"><a href="#93-复原IP地址" class="headerlink" title="93 复原IP地址"></a>93 复原IP地址</h2><blockquote><p><a href="https://leetcode.cn/problems/restore-ip-addresses/">https://leetcode.cn/problems/restore-ip-addresses/</a></p></blockquote><h3 id="题目和思路-6"><a href="#题目和思路-6" class="headerlink" title="题目和思路"></a>题目和思路</h3><p>有效 IP 地址 正好由四个整数（每个整数位于 0 到 255 之间组成，且不能含有前导 0），整数之间用 <code>&#39;.&#39;</code> 分隔。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">例如：&quot;0.1.2.201&quot; 和 &quot;192.168.1.1&quot; 是 有效 IP 地址，但是 &quot;0.011.255.245&quot;、&quot;192.168.1.312&quot; 和 &quot;192.168@1.1&quot; 是 无效 IP 地址。</span><br></pre></td></tr></table></figure><p>给定一个只包含数字的字符串 s ，用以表示一个 IP 地址，返回所有可能的有效 IP 地址，这些地址可以通过在 s 中插入 <code>&#39;.&#39;</code> 来形成。你 <strong>不能</strong> 重新排序或删除 s 中的任何数字。你可以按 任何 顺序返回答案。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">示例 1：</span><br><span class="line">输入：s = &quot;25525511135&quot;</span><br><span class="line">输出：[&quot;255.255.11.135&quot;,&quot;255.255.111.35&quot;]</span><br><span class="line"></span><br><span class="line">示例 2：</span><br><span class="line">输入：s = &quot;0000&quot;</span><br><span class="line">输出：[&quot;0.0.0.0&quot;]</span><br><span class="line"></span><br><span class="line">示例 3：</span><br><span class="line">输入：s = &quot;101023&quot;</span><br><span class="line">输出：[&quot;1.0.10.23&quot;,&quot;1.0.102.3&quot;,&quot;10.1.0.23&quot;,&quot;10.10.2.3&quot;,&quot;101.0.2.3&quot;</span><br></pre></td></tr></table></figure><p>提示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1 &lt;= s.length &lt;= 20</span><br><span class="line">s 仅由数字组成</span><br></pre></td></tr></table></figure><p>这道题和上一题131的切割基本一致，只不过我们需要在虚拟的切割线的基础上做额外的处理，即把<code>&#39;.&#39;</code>字符当作切割线，插入到字符串中。因为题目最终返回的的字符串需要是带IP地址的<code>&#39;.&#39;</code>的，我们这样做就相当于提前处理了最终IP地址的字符串。</p><p>先来确定最终的递归终止条件吧，这里不再用startIndex大于size的判断方式，因为IP地址大概率是走不到这里就已经找到符合条件的子串了。我们应该利用IP地址中有3个<code>&#39;.&#39;</code>的特性来做递归的终止条件，即加了点的数量为3的时候，就已经不能继续执行本层了，需要退出了。</p><p>插入返回值之前，还需要判断最后一个点到字符串末尾的区间是否符合IP地址的条件。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (pointNum == <span class="number">3</span>) &#123;</span><br><span class="line">    <span class="comment">// 判断最后一部分是否符合ip的条件</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">checkIpStr</span>(s, startIndex, s.<span class="built_in">size</span>() - <span class="number">1</span>)) &#123;</span><br><span class="line">        retV.<span class="built_in">push_back</span>(s);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>IP地址的判断函数如下，保证区间的字符串对应的数字是0到255，且不能有前导0；</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 判断这个区间是否是合法的ip地址</span></span><br><span class="line">   <span class="function"><span class="type">bool</span> <span class="title">checkIpStr</span><span class="params">(<span class="type">const</span> string&amp; s, <span class="type">int</span> start, <span class="type">int</span> end)</span> </span>&#123;</span><br><span class="line">       <span class="comment">// 区间合法（不能等于，start==end时是一个数字的情况）</span></span><br><span class="line">       <span class="keyword">if</span> (start &gt; end) &#123;</span><br><span class="line">           <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">// 以0开始的不合法（除非只有一个0）</span></span><br><span class="line">       <span class="keyword">if</span> (s[start] == <span class="string">&#x27;0&#x27;</span> &amp;&amp; start != end) &#123;</span><br><span class="line">           <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">       <span class="keyword">for</span> (<span class="type">int</span> i = start; i &lt;= end; i++) &#123;</span><br><span class="line">           <span class="comment">// 不是数字，不符合</span></span><br><span class="line">           <span class="keyword">if</span> (s[i] &lt; <span class="string">&#x27;0&#x27;</span> || s[i] &gt; <span class="string">&#x27;9&#x27;</span>) &#123;</span><br><span class="line">               <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="comment">// 加到sum里面</span></span><br><span class="line">           sum = sum * <span class="number">10</span> + (s[i] - <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">           <span class="comment">// 如果超过255，不符合</span></span><br><span class="line">           <span class="keyword">if</span> (sum &gt; <span class="number">255</span>) &#123;</span><br><span class="line">               <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>最终回溯函数的步骤如下：</p><ul><li>当遍历到i的时候，假设<code>s[i]</code>和<code>s[i+1]</code>之间有一个点；</li><li>判断<code>[startIndex,i]</code>区间是否符合IP地址的规定（0到255）；</li><li>符合条件，在i和i+1之间插入一个点；</li><li>点的数量加一；</li><li>递归下一层，其中startIndex应该传入<code>i+2</code>（跳过刚刚插入的点）；</li><li>回溯，点的数量减一，删除刚刚添加的点；</li></ul><h3 id="完整代码-5"><a href="#完整代码-5" class="headerlink" title="完整代码"></a>完整代码</h3><p>完整代码如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    vector&lt;string&gt; retV;</span><br><span class="line"></span><br><span class="line">    <span class="type">void</span> _restoreIpAddresses(string s, <span class="type">int</span> startIndex, <span class="type">int</span> pointNum) &#123;</span><br><span class="line">        <span class="comment">// IP地址需要打三个点，有三个点了之后就不需要继续for了</span></span><br><span class="line">        <span class="keyword">if</span> (pointNum == <span class="number">3</span>) &#123;</span><br><span class="line">            <span class="comment">// 判断最后一部分是否符合ip的条件</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">checkIpStr</span>(s, startIndex, s.<span class="built_in">size</span>() - <span class="number">1</span>)) &#123;</span><br><span class="line">                retV.<span class="built_in">push_back</span>(s);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = startIndex; i &lt; s.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="comment">// 判断[start,i]区间是否是合法的ip地址组成</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">checkIpStr</span>(s, startIndex, i)) &#123;</span><br><span class="line">                <span class="comment">// 是，加点（注意insert是在选中位置之前插入）</span></span><br><span class="line">                <span class="comment">// 加点是为了方便最后直接插入返回值</span></span><br><span class="line">                s.<span class="built_in">insert</span>(s.<span class="built_in">begin</span>() + i + <span class="number">1</span>, <span class="string">&#x27;.&#x27;</span>);</span><br><span class="line">                pointNum++;</span><br><span class="line">                <span class="comment">// 这里加2是为了跳过插入的点，走到下一位</span></span><br><span class="line">                _restoreIpAddresses(s, i + <span class="number">2</span>, pointNum);</span><br><span class="line">                <span class="comment">// 回溯本层操作</span></span><br><span class="line">                pointNum--;</span><br><span class="line">                s.<span class="built_in">erase</span>(s.<span class="built_in">begin</span>() + i + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 如果已经不符合条件了，说明这一层都不符合条件了</span></span><br><span class="line">            <span class="comment">// 比如515已经不符合条件了，再往后走更不符合（这一层符合条件的组合已经在之前走过了）</span></span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">break</span>; <span class="comment">// 跳出本层</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断这个区间是否是合法的ip地址</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">checkIpStr</span><span class="params">(<span class="type">const</span> string&amp; s, <span class="type">int</span> start, <span class="type">int</span> end)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 区间合法（不能等于，start==end时是一个数字的情况）</span></span><br><span class="line">        <span class="keyword">if</span> (start &gt; end) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 以0开始的不合法（除非只有一个0）</span></span><br><span class="line">        <span class="keyword">if</span> (s[start] == <span class="string">&#x27;0&#x27;</span> &amp;&amp; start != end) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = start; i &lt;= end; i++) &#123;</span><br><span class="line">            <span class="comment">// 不是数字，不符合</span></span><br><span class="line">            <span class="keyword">if</span> (s[i] &lt; <span class="string">&#x27;0&#x27;</span> || s[i] &gt; <span class="string">&#x27;9&#x27;</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 加到sum里面</span></span><br><span class="line">            sum = sum * <span class="number">10</span> + (s[i] - <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">            <span class="comment">// 如果超过255，不符合</span></span><br><span class="line">            <span class="keyword">if</span> (sum &gt; <span class="number">255</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;string&gt; <span class="title">restoreIpAddresses</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        _restoreIpAddresses(s, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> retV;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/04/05ea0b8be513ac4fdb8848948a5d301c.png" alt="image.png"></p><h1 id="4-子集问题"><a href="#4-子集问题" class="headerlink" title="4.子集问题"></a>4.子集问题</h1><h2 id="78-子集"><a href="#78-子集" class="headerlink" title="78 子集"></a>78 子集</h2><blockquote><p><a href="https://leetcode.cn/problems/subsets/description/">https://leetcode.cn/problems/subsets/description/</a></p></blockquote><h3 id="题目和思路-7"><a href="#题目和思路-7" class="headerlink" title="题目和思路"></a>题目和思路</h3><p>给你一个整数数组 nums ，数组中的元素 <strong>互不相同</strong> 。返回该数组所有可能的子集（幂集）。</p><p>解集 不能 包含重复的子集。你可以按 任意顺序 返回解集。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">示例 1：</span><br><span class="line">输入：nums = [1,2,3]</span><br><span class="line">输出：[[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]]</span><br><span class="line"></span><br><span class="line">示例 2：</span><br><span class="line">输入：nums = [0]</span><br><span class="line">输出：[[],[0]]</span><br></pre></td></tr></table></figure><p>这道题的思路就不是很难了，属于是回溯算法的一个最基础的思路。</p><p>首先要根据题目需要的子集来确定什么时候插入返回值数组和递归的终止条件，最开始我的想法是单独处理每个元素构成的数组（比如<code>[1],[2],[3]</code>）和空数组<code>[]</code>；在递归终止条件中插入其他数组到返回值。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(startIndex&gt;=nums.<span class="built_in">size</span>())&#123;</span><br><span class="line"> retV.<span class="built_in">push_back</span>(curV);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是这样会多出额外的一次遍历，虽然整体的时间复杂度没有变化，但多了一个遍历总归会浪费一些时间。</p><p>实际上也不需要这么麻烦，根据回溯算法的思路，其实第二层递归的时候，curV就是<code>[1],[2],[3]</code>这些由单个元素构成的数组了，也就是说，我们只要每一次递归调用函数的时候就把curV插入返回值，就能满足条件了！同时，第一次调用递归函数时，也正好会把空的curV给插入，空集也不需要额外处理了！</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 因为子集包括每一个数单独组成的数组和空数组，所以可以先直接把数组插入</span></span><br><span class="line"><span class="comment">// 第一次进入函数是插入空数组，第二层递归是插入每个数单独组成的数组</span></span><br><span class="line">retV.<span class="built_in">push_back</span>(curV);</span><br><span class="line"><span class="keyword">if</span>(startIndex&gt;=nums.<span class="built_in">size</span>())&#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>剩余的部分其实就是单层回溯了，题目要求不能有重复的子集（数组每个元素都不相同），所以下一层递归的时候，传给startIndex的是<code>i+1</code>，从下一位开始选择数插入数组就OK了。</p><h3 id="完整代码-6"><a href="#完整代码-6" class="headerlink" title="完整代码"></a>完整代码</h3><p>学过了前几题的回溯思路，这道题相对来说没有那么困难了。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; retV;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; curV;</span><br><span class="line">    <span class="comment">// 求子集的回溯函数</span></span><br><span class="line">    <span class="type">void</span> _subsets(vector&lt;<span class="type">int</span>&gt;&amp; nums,<span class="type">int</span> startIndex)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 因为子集包括每一个数单独组成的数组和空数组，所以可以先直接把数组插入</span></span><br><span class="line">        <span class="comment">// 第一次进入函数是插入空数组，第二层递归是插入每个数单独组成的数组</span></span><br><span class="line">        retV.<span class="built_in">push_back</span>(curV);</span><br><span class="line">        <span class="keyword">if</span>(startIndex&gt;=nums.<span class="built_in">size</span>())&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 回溯的循环</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = startIndex;i&lt;nums.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            <span class="comment">// 插入当前数</span></span><br><span class="line">            curV.<span class="built_in">push_back</span>(nums[i]);</span><br><span class="line">            <span class="comment">// 递归下一层，不能选择相同下标的数</span></span><br><span class="line">            _subsets(nums,i+<span class="number">1</span>);</span><br><span class="line">            <span class="comment">// 回溯当前操作</span></span><br><span class="line">            curV.<span class="built_in">pop_back</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">subsets</span>(vector&lt;<span class="type">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        _subsets(nums,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> retV;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/04/489dc2b8a3021e05a4564c670c11bd0a.png" alt="image.png"></p><h2 id="90-子集2"><a href="#90-子集2" class="headerlink" title="90 子集2"></a>90 子集2</h2><blockquote><p><a href="https://leetcode.cn/problems/subsets-ii/description/">https://leetcode.cn/problems/subsets-ii/description/</a></p></blockquote><h3 id="题目和思路-8"><a href="#题目和思路-8" class="headerlink" title="题目和思路"></a>题目和思路</h3><p>给你一个整数数组 nums ，<strong>其中可能包含重复元素</strong>，请你返回该数组所有可能的 子集（幂集）。</p><p>解集 不能 包含重复的子集。返回的解集中，子集可以按 任意顺序 排列。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">示例 1：</span><br><span class="line">输入：nums = [1,2,2]</span><br><span class="line">输出：[[],[1],[1,2],[1,2,2],[2],[2,2]]</span><br><span class="line"></span><br><span class="line">示例 2：</span><br><span class="line">输入：nums = [0]</span><br><span class="line">输出：[[],[0]]</span><br></pre></td></tr></table></figure><p>这道题和78题的关系好比39和40题的关系一样，由78题的数组中不包括重复元素，变成了数组中有重复元素，且结果集不能有重复的子集。</p><p>如果还按照78题的思路来写，此时就会出现两个<code>[1,2]</code>子集的情况（一个是1和第一个2匹配的子集，另外一个是1和第二个2匹配的子集）。</p><p>实际上，每一层的处理都不能处理相同的数，包括进入下一层的递归也是。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[1,2,2,3]</span><br><span class="line">当前 i = 1，选中第一个2</span><br><span class="line">往下递归，可得到集合[2,2]、[2,3]、[2,2,3]</span><br><span class="line"></span><br><span class="line">如果for循环不做去重，i = 2选中第二个2</span><br><span class="line">往下递归，会重复得到集合[2,3]</span><br></pre></td></tr></table></figure><p>这里的去重思路并不难实现，和40题的去重基本一致：在<strong>单层</strong>for中，如果上一位和当前位相等，则跳过当前位（重复了）。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (i &gt; startIndex &amp;&amp; nums[i] == nums[i - <span class="number">1</span>]) &#123;</span><br><span class="line"><span class="keyword">continue</span>; <span class="comment">// 跳过相同数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样不仅解决了多个数的子集的重复问题，还解决了单个数的子集的重复问题，<code>[1,2,2]</code>在第一层for中，只会有1和第一个2进入下一层，<strong>最后一个2会被去重跳过</strong>，也就不会重复插入子集<code>[2]</code>。</p><h3 id="完整代码-7"><a href="#完整代码-7" class="headerlink" title="完整代码"></a>完整代码</h3><p>注意，这个判断上一位的去重思路是基于数组有序的，但题目并没有保证输入数组有序，所以调用递归函数之前，需要对数组排序。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; retV;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; curV;</span><br><span class="line">    <span class="comment">// 求子集的回溯函数</span></span><br><span class="line">    <span class="type">void</span> _subsetsWithDup(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> startIndex) &#123;</span><br><span class="line">        <span class="comment">// 因为子集包括每一个数单独组成的数组和空数组，所以可以先直接把数组插入</span></span><br><span class="line">        <span class="comment">// 第一次进入函数是插入空数组，第二层递归是插入每个数单独组成的数组</span></span><br><span class="line">        retV.<span class="built_in">push_back</span>(curV);</span><br><span class="line">        <span class="keyword">if</span> (startIndex &gt;= nums.<span class="built_in">size</span>()) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 回溯的循环</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = startIndex; i &lt; nums.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="comment">// 单层的去重</span></span><br><span class="line">            <span class="keyword">if</span> (i &gt; startIndex &amp;&amp; nums[i] == nums[i - <span class="number">1</span>]) &#123;</span><br><span class="line">                <span class="keyword">continue</span>; <span class="comment">// 跳过相同数</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 插入当前数</span></span><br><span class="line">            curV.<span class="built_in">push_back</span>(nums[i]);</span><br><span class="line">            <span class="comment">// 递归下一层</span></span><br><span class="line">            _subsetsWithDup(nums, i + <span class="number">1</span>);</span><br><span class="line">            <span class="comment">// 回溯当前操作</span></span><br><span class="line">            curV.<span class="built_in">pop_back</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">subsetsWithDup</span>(vector&lt;<span class="type">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        <span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>()); <span class="comment">// 排序</span></span><br><span class="line">        _subsetsWithDup(nums, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> retV;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/04/abc05725c7808521ecda379be843cea7.png" alt="image.png"></p><h2 id="491-非递减子序列"><a href="#491-非递减子序列" class="headerlink" title="491 非递减子序列"></a>491 非递减子序列</h2><blockquote><p><a href="https://leetcode.cn/problems/non-decreasing-subsequences/description/">https://leetcode.cn/problems/non-decreasing-subsequences/description/</a></p></blockquote><h3 id="题目和思路-9"><a href="#题目和思路-9" class="headerlink" title="题目和思路"></a>题目和思路</h3><p>给你一个整数数组 nums ，找出并返回所有该数组中不同的递增子序列，递增子序列中 至少有两个元素 。你可以按 任意顺序 返回答案。</p><p>数组中可能含有重复元素，<strong>如出现两个整数相等，也可以视作递增序列的一种特殊情况</strong>。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">示例 1：</span><br><span class="line">输入：nums = [4,6,7,7]</span><br><span class="line">输出：[[4,6],[4,6,7],[4,6,7,7],[4,7],[4,7,7],[6,7],[6,7,7],[7,7]]</span><br><span class="line"></span><br><span class="line">示例 2：</span><br><span class="line">输入：nums = [4,4,3,2,1]</span><br><span class="line">输出：[[4,4]]</span><br></pre></td></tr></table></figure><p>提示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1 &lt;= nums.length &lt;= 15</span><br><span class="line">-100 &lt;= nums[i] &lt;= 100</span><br></pre></td></tr></table></figure><p>首先注意这道题的要求，需要我们找到所有的递增子序列。这里包含了一个隐含的要求，即我们<strong>不可以对原数组进行重排序</strong>（否则找到的递增子序列不一定符合条件）。</p><ul><li>怎么判断当前找到的子序列是递增的？</li></ul><p>通过startIndex来判断，我们需要保证当前层添加的数比上一层的数更大或相等，就是一个递增的子序列。第一层curV为空，不需要判断。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 因为在for中每次都只会往curV插入一个数，所以可以直接判断</span></span><br><span class="line"><span class="comment">// 如果当前位小于startIndex-1，跳过</span></span><br><span class="line"><span class="keyword">if</span> (startIndex - <span class="number">1</span> &gt;= <span class="number">0</span> &amp;&amp; i &gt; startIndex - <span class="number">1</span> &amp;&amp;</span><br><span class="line">nums[i] &lt; nums[startIndex - <span class="number">1</span>]) &#123;</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>什么时候插入返回值？</li></ul><p>题目需要的是<strong>所有递增的子序列</strong>。</p><p>此时既不能在越界终止条件中插入返回值，也不能直接在函数开始插入返回值。前者会导致结果集<strong>只包含叶子节点的子集</strong>（中途节点符合条件的子集未被加入），后者会导致<strong>只包含单个元素的子集被错误插入</strong>（题目要求子集必须至少有2个元素）。</p><p>正确的插入情况是curV的长度大于1的时候插入，这时候每一次递归都会把符合条件的子集插入其中。配合for循环内的去重逻辑避免重复子集被插入。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (curV.<span class="built_in">size</span>() &gt; <span class="number">1</span>) &#123;</span><br><span class="line">          retV.<span class="built_in">push_back</span>(curV);</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure><p>递归的终止条件依旧是startIndex大于数组长度</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 越界终止</span></span><br><span class="line"><span class="keyword">if</span> (startIndex &gt;= nums.<span class="built_in">size</span>()) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>需要去重吗？</li></ul><p>注意，本题也是需要去重的</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[4,6,7,7]</span><br><span class="line">第一层选择4，进入第二层，在[6,7,7]中选</span><br><span class="line">如果不去重，就会出现两个[4,7]子集</span><br><span class="line"></span><br><span class="line">第二层选择6，进入第三层，在[7,7]中选</span><br><span class="line">如果不去重，就会出现两个[4,6,7]子集</span><br></pre></td></tr></table></figure><ul><li>单层怎么去重？</li></ul><p>之前的函数中，我们直接判断i不等于i-1来去重，但那是基于数组已经有序的情况下使用的了。</p><p>现在因为<strong>不能对原始数组做重排序</strong>，我们应该使用一个哈希表来对数组中元素去重。单层被选用过的元素不能再被使用。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// for循环之前定义去重集合</span></span><br><span class="line">unordered_set&lt;<span class="type">int</span>&gt; used; </span><br><span class="line"></span><br><span class="line"><span class="comment">// for循环中，判断某个数是否已被使用过</span></span><br><span class="line"><span class="keyword">if</span> (used.<span class="built_in">count</span>(nums[i]) != <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line">used.<span class="built_in">insert</span>(nums[i]);<span class="comment">// 没有使用过则插入</span></span><br></pre></td></tr></table></figure><p>此时的代码已经可以通过了。但针对本题，去重还有可优化之处：注意题目给的提示，数组中元素的大小区间是<code>[-100,100]</code>，这并不是一个很大的区间，我们完全可以使用一个201个元素的数组来替代<code>unordered_set</code>做去重的操作。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// for循环之前定义</span></span><br><span class="line"><span class="function">vector&lt;<span class="type">bool</span>&gt; <span class="title">usedArray</span><span class="params">(<span class="number">201</span>, <span class="literal">false</span>)</span></span>; <span class="comment">// num[i] + 100 作为下标</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// for循环内直接判断对应下标位置即可</span></span><br><span class="line"><span class="keyword">if</span> (usedArray[nums[i] + <span class="number">100</span>] != <span class="literal">false</span>) &#123;</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line">usedArray[nums[i] + <span class="number">100</span>] = <span class="literal">true</span>; <span class="comment">// 标记已经使用过了</span></span><br></pre></td></tr></table></figure><p>虽然<code>unordered_set</code>能提供<code>O(1)</code>级别的查找，但它并非严格的<code>O(1)</code>，同时插入的操作也会有更多的耗时。使用数组能保证不管是查询还是插入都只需要做1个操作。</p><p>针对这种哈希的情形，如果能确定数值的范围不大（比如本题或映射仅小写英文字母的情况），那么使用一个定长数组会优于使用哈希表。</p><h3 id="完整代码-8"><a href="#完整代码-8" class="headerlink" title="完整代码"></a>完整代码</h3><p>代码如下，本题主要是去重思路和其他题目不一样。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; retV;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; curV;</span><br><span class="line">    <span class="type">void</span> _findSubsequences(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> startIndex) &#123;</span><br><span class="line">        <span class="comment">// 题目要求子序列必须有两个元素</span></span><br><span class="line">        <span class="keyword">if</span> (curV.<span class="built_in">size</span>() &gt; <span class="number">1</span>) &#123;</span><br><span class="line">            retV.<span class="built_in">push_back</span>(curV);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 越界终止</span></span><br><span class="line">        <span class="keyword">if</span> (startIndex &gt;= nums.<span class="built_in">size</span>()) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 单层for中不能选择已经选过的数</span></span><br><span class="line">        <span class="comment">// unordered_set&lt;int&gt; used; // 去重集合</span></span><br><span class="line">        <span class="comment">// 因为题目给出了数字的区间是-100到100，可以直接用一个201长度的数组做哈希，提高效率</span></span><br><span class="line">        <span class="function">vector&lt;<span class="type">bool</span>&gt; <span class="title">usedArray</span><span class="params">(<span class="number">201</span>, <span class="literal">false</span>)</span></span>; <span class="comment">// num[i] + 100 作为下标</span></span><br><span class="line">        <span class="comment">// 单层for</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = startIndex; i &lt; nums.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="comment">// 因为在for中每次都只会往curV插入一个数，所以可以直接判断</span></span><br><span class="line">            <span class="comment">// 如果当前位小于startIndex-1，跳过</span></span><br><span class="line">            <span class="keyword">if</span> (startIndex - <span class="number">1</span> &gt;= <span class="number">0</span> &amp;&amp; i &gt; startIndex - <span class="number">1</span> &amp;&amp;</span><br><span class="line">                nums[i] &lt; nums[startIndex - <span class="number">1</span>]) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 单层for中不能选择已经选过的数</span></span><br><span class="line">            <span class="comment">// if (used.count(nums[i]) != 0)</span></span><br><span class="line">            <span class="keyword">if</span> (usedArray[nums[i] + <span class="number">100</span>] != <span class="literal">false</span>) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 插入本层</span></span><br><span class="line">            <span class="comment">// used.insert(nums[i]);</span></span><br><span class="line">            usedArray[nums[i] + <span class="number">100</span>] = <span class="literal">true</span>; <span class="comment">// 标记已经使用过了</span></span><br><span class="line">            curV.<span class="built_in">push_back</span>(nums[i]);</span><br><span class="line">            <span class="comment">// 递归下一层</span></span><br><span class="line">            _findSubsequences(nums, i + <span class="number">1</span>);</span><br><span class="line">            <span class="comment">// 回溯</span></span><br><span class="line">            curV.<span class="built_in">pop_back</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">findSubsequences</span>(vector&lt;<span class="type">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        _findSubsequences(nums, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> retV;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/04/787201c7664cacc5753ef66e8fbfbf57.png" alt="image.png"></p><h1 id="5-排列问题"><a href="#5-排列问题" class="headerlink" title="5.排列问题"></a>5.排列问题</h1><h2 id="46-全排列"><a href="#46-全排列" class="headerlink" title="46 全排列"></a>46 全排列</h2><blockquote><p><a href="https://leetcode.cn/problems/permutations/">https://leetcode.cn/problems/permutations/</a></p></blockquote><h3 id="题目和思路-10"><a href="#题目和思路-10" class="headerlink" title="题目和思路"></a>题目和思路</h3><p>给定一个<strong>不含重复数字</strong>的数组 nums ，返回其 所有可能的全排列 。你可以 按任意顺序 返回答案。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">示例 1：</span><br><span class="line">输入：nums = [1,2,3]</span><br><span class="line">输出：[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]</span><br><span class="line"></span><br><span class="line">示例 2：</span><br><span class="line">输入：nums = [0,1]</span><br><span class="line">输出：[[0,1],[1,0]]</span><br><span class="line"></span><br><span class="line">示例 3：</span><br><span class="line">输入：nums = [1]</span><br><span class="line">输出：[[1]]</span><br></pre></td></tr></table></figure><p>这道题和前文的子集问题都不同，这道题是希望我们将数组随便重新排列，并把所有可能重新排列的情况返回。</p><p>此时for循环就不需要使用startIndex了，因为每一次都需要从0开始遍历。比如当前选中了<code>[1,2,3]</code>中的2，还是需要从0开始遍历，加上1，再加上3；为此需要一个used数组来标记数组中哪一个元素已经被使用过了，跳过已经被使用的元素。</p><p>递归的终止条件也很简单，只要当前的curV和nums长度一致，就说明我们找到了一个全排列。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 长度相等代表找到了一个全排列</span></span><br><span class="line"><span class="keyword">if</span> (curV.<span class="built_in">size</span>() == nums.<span class="built_in">size</span>()) &#123;</span><br><span class="line">    retV.<span class="built_in">push_back</span>(curV);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>本质上这道题就是一个暴力破解的过程，用回溯的思路模拟了一层循环。</p><h3 id="完整代码-9"><a href="#完整代码-9" class="headerlink" title="完整代码"></a>完整代码</h3><p>注意，我在主函数中使用resize初始化了used数组，因为需要保证刚开始的时候，所有下标都是false（未被使用）。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; retV;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; curV;</span><br><span class="line">    vector&lt;<span class="type">bool</span>&gt; used;</span><br><span class="line">    <span class="comment">// 因为全排列每次都需要从0开始，所以不需要startIndex</span></span><br><span class="line">    <span class="type">void</span> _permute(vector&lt;<span class="type">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        <span class="comment">// 长度相等代表找到了一个全排列</span></span><br><span class="line">        <span class="keyword">if</span> (curV.<span class="built_in">size</span>() == nums.<span class="built_in">size</span>()) &#123;</span><br><span class="line">            retV.<span class="built_in">push_back</span>(curV);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (used[i] == <span class="literal">true</span>) &#123;</span><br><span class="line">                <span class="keyword">continue</span>; <span class="comment">// 跳过已经被选择了的</span></span><br><span class="line">            &#125;</span><br><span class="line">            curV.<span class="built_in">push_back</span>(nums[i]);</span><br><span class="line">            used[i] = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">            _permute(nums);</span><br><span class="line"></span><br><span class="line">            used[i] = <span class="literal">false</span>;</span><br><span class="line">            curV.<span class="built_in">pop_back</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">permute</span>(vector&lt;<span class="type">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        used.<span class="built_in">resize</span>(nums.<span class="built_in">size</span>(), <span class="literal">false</span>); <span class="comment">// 注意初始化</span></span><br><span class="line">        _permute(nums);</span><br><span class="line">        <span class="keyword">return</span> retV;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/04/7999ae3a336b9c34f97ce1f6dd684b5e.png" alt="image.png"></p><h2 id="47-全排列2"><a href="#47-全排列2" class="headerlink" title="47 全排列2"></a>47 全排列2</h2><blockquote><p><a href="https://leetcode.cn/problems/permutations-ii/">https://leetcode.cn/problems/permutations-ii/</a></p></blockquote><h3 id="题目和思路-11"><a href="#题目和思路-11" class="headerlink" title="题目和思路"></a>题目和思路</h3><p>给定一个<strong>可包含重复数字</strong>的序列 nums ，按任意顺序 返回所有不重复的全排列。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">示例 1：</span><br><span class="line">输入：nums = [1,1,2]</span><br><span class="line">输出：</span><br><span class="line">[[1,1,2],</span><br><span class="line"> [1,2,1],</span><br><span class="line"> [2,1,1]]</span><br><span class="line"> </span><br><span class="line">示例 2：</span><br><span class="line">输入：nums = [1,2,3]</span><br><span class="line">输出：[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]</span><br></pre></td></tr></table></figure><p>这道题和46题的区别在于给定数组内部元素可能重复，不过也不是第一次遇到这样的情况了。</p><blockquote><p>以<code>[1,1,2]</code>为例，从第一个1开始回溯的时候，就可以得到<code>[1,1,2]</code>和<code>[1,2,1]</code>这两个排列。如果不去重，直接走到第二个1时，它还是会得到<code>[1,1,2]</code>和<code>[1,2,1]</code>这两个排列，此时<strong>排列重复</strong>！</p></blockquote><p>因为本题并不在乎子集的顺序，所以我们直接通过<strong>排序</strong>，再加上if判断相邻节点的方式来去重，就可以了。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (i &gt; <span class="number">0</span> &amp;&amp; nums[i] == nums[i - <span class="number">1</span>]) &#123;</span><br><span class="line">    <span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>加了这个代码发现，完全通过不了，输出结果为空，这是为什么呢？</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/04/c16565842d52f6e880e24e67680ceccc.png" alt="image.png"></p><p>以图中的用例<code>[1,1,2]</code>为例，<strong>这里无论什么情况都跳过了第二个1</strong>，第二层的时候也不会使用第二个1（这并不是我们预期的结果），这会导致curV永远无法达到nums的长度，也就没有结果被插入retV数组中。</p><p>正确的去重逻辑应该是：如果上一位被选用过且上一位的值和当前相同，那么就跳过当前位。在if判断中新增一个条件就可以了。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 跳过相同的（前提是上一位已经被选择过了）</span></span><br><span class="line"><span class="keyword">if</span> (i &gt; <span class="number">0</span> &amp;&amp; nums[i] == nums[i - <span class="number">1</span>] &amp;&amp; used[i - <span class="number">1</span>] == <span class="literal">false</span>) &#123;</span><br><span class="line">    <span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意，这里需要判断的是<code>used[i - 1] == false</code>而不是为true的情况，因为在回溯过程中，我们会先把<code>used[i]</code>设置为true，然后又重置为false。在同一层里面，其实不会出现<code>used[i-1]==true</code>的情况（已经被回溯undo了）</p><p>既然不会出现<code>used[i-1]==true</code>的情况，为什么还需添加这个判断条件呢？原因前文已经提到过，如果删除这个判断，那么就会导致去重变成了<strong>多层之间都不会选择相同的数</strong>，这是不符合题目逻辑的！</p><blockquote><p>在代码随想录上有关于这个去重逻辑更详细的解释：<a href="https://www.programmercarl.com/0047.%E5%85%A8%E6%8E%92%E5%88%97II.html#%E6%8B%93%E5%B1%95">点我查看</a></p></blockquote><p>当然，因为去重是基于同一层的，那么完全可以使用<code>unordered_set</code>来去重，效果也是一样的。不过使用set也不能去掉used数组，那还不如直接通过used数组来去重，效率更高。</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/04/0d2a0de90ba7a27ed5797404fac82a53.png" alt="image.png"></p><p>注意，每一层递归都额外定义一个<code>unordered_set</code>会让整体空间复杂度由<code>O(N)</code>变成<code>O(N^2)</code>，所以除非必须的时候，不额外定义set才是更好的做法。</p><h3 id="完整代码-10"><a href="#完整代码-10" class="headerlink" title="完整代码"></a>完整代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; retV;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; curV;</span><br><span class="line">    vector&lt;<span class="type">bool</span>&gt; used;</span><br><span class="line">    <span class="comment">// 同样每一次都是从0开始，但是需要跳过单层已经被选择过的元素</span></span><br><span class="line">    <span class="type">void</span> _permuteUnique(vector&lt;<span class="type">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        <span class="comment">// 长度相等代表找到了一个全排列</span></span><br><span class="line">        <span class="keyword">if</span> (curV.<span class="built_in">size</span>() == nums.<span class="built_in">size</span>()) &#123;</span><br><span class="line">            retV.<span class="built_in">push_back</span>(curV);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="comment">// 跳过相同的（前提是同层上一位已经被选择过了）</span></span><br><span class="line">            <span class="keyword">if</span> (i &gt; <span class="number">0</span> &amp;&amp; nums[i] == nums[i - <span class="number">1</span>] &amp;&amp; used[i - <span class="number">1</span>] == <span class="literal">false</span>) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 正常情况下也需要跳过被选用了的</span></span><br><span class="line">            <span class="keyword">if</span> (used[i] == <span class="literal">true</span>) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            curV.<span class="built_in">push_back</span>(nums[i]);</span><br><span class="line">            used[i] = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">            _permuteUnique(nums);</span><br><span class="line"></span><br><span class="line">            used[i] = <span class="literal">false</span>;</span><br><span class="line">            curV.<span class="built_in">pop_back</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">permuteUnique</span>(vector&lt;<span class="type">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        used.<span class="built_in">resize</span>(nums.<span class="built_in">size</span>(), <span class="literal">false</span>);</span><br><span class="line">        <span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>());</span><br><span class="line"></span><br><span class="line">        _permuteUnique(nums);</span><br><span class="line">        <span class="keyword">return</span> retV;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/04/159a19cdeb90bc479b14da8d8d0d4142.png" alt="image.png"></p><h1 id="6-其他问题"><a href="#6-其他问题" class="headerlink" title="6.其他问题"></a>6.其他问题</h1><h2 id="332-重新安排行程"><a href="#332-重新安排行程" class="headerlink" title="332 重新安排行程"></a>332 重新安排行程</h2><blockquote><p><a href="https://leetcode.cn/problems/reconstruct-itinerary/description/">https://leetcode.cn/problems/reconstruct-itinerary/description/</a></p></blockquote><h3 id="题目和思路-12"><a href="#题目和思路-12" class="headerlink" title="题目和思路"></a>题目和思路</h3><p>给你一份航线列表 tickets ，其中 <code>tickets[i] = [fromi, toi]</code> 表示飞机出发和降落的机场地点。请你对该行程进行重新规划排序。</p><ul><li>所有这些机票都属于一个从 JFK（肯尼迪国际机场）出发的先生，所以该行程必须从 JFK 开始。如果存在多种有效的行程，请你按<strong>字典排序</strong>返回最小的行程组合。</li></ul><p>例如，行程 <code>[&quot;JFK&quot;, &quot;LGA&quot;]</code> 与 <code>[&quot;JFK&quot;, &quot;LGB&quot;]</code> 相比就更小，排序更靠前。</p><p>假定所有机票至少存在一种合理的行程。且所有的机票 必须都用一次 且 只能用一次。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">示例1：</span><br><span class="line">输入：tickets = [[&quot;MUC&quot;,&quot;LHR&quot;],[&quot;JFK&quot;,&quot;MUC&quot;],[&quot;SFO&quot;,&quot;SJC&quot;],[&quot;LHR&quot;,&quot;SFO&quot;]]</span><br><span class="line">输出：[&quot;JFK&quot;,&quot;MUC&quot;,&quot;LHR&quot;,&quot;SFO&quot;,&quot;SJC&quot;]</span><br><span class="line"></span><br><span class="line">示例2：</span><br><span class="line">输入：tickets = [[&quot;JFK&quot;,&quot;SFO&quot;],[&quot;JFK&quot;,&quot;ATL&quot;],[&quot;SFO&quot;,&quot;ATL&quot;],[&quot;ATL&quot;,&quot;JFK&quot;],[&quot;ATL&quot;,&quot;SFO&quot;]]</span><br><span class="line">输出：[&quot;JFK&quot;,&quot;ATL&quot;,&quot;JFK&quot;,&quot;SFO&quot;,&quot;ATL&quot;,&quot;SFO&quot;]</span><br><span class="line">解释：另一种有效的行程是 [&quot;JFK&quot;,&quot;SFO&quot;,&quot;ATL&quot;,&quot;JFK&quot;,&quot;ATL&quot;,&quot;SFO&quot;] ，但是它字典排序更大更靠后。</span><br></pre></td></tr></table></figure><p>提示</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1 &lt;= tickets.length &lt;= 300</span><br><span class="line">tickets[i].length == 2</span><br><span class="line">fromi.length == 3</span><br><span class="line">toi.length == 3</span><br><span class="line">fromi 和 toi 由大写英文字母组成</span><br><span class="line">fromi != toi</span><br></pre></td></tr></table></figure><p>这道题其实更偏向于图论的深搜（还没学），但是它也可以通过回溯的思想来解决。</p><p>首先需要确定如何记录机票，最好的办法自然是用一个unordered_map来记录起始机场和目的机场的关系，且目的机场使用multiset而不是unordered_set，可以自然实现字典排序（set&#x2F;map基于红黑树，是有序的）。使用multiset是为了避免<strong>有多张从A到B</strong>的机票的情况，此时目的地会重复出现。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 起始机场,目的机场集合</span></span><br><span class="line">unordered_map&lt;string,multiset&lt;string&gt;&gt; ticketsMap;</span><br></pre></td></tr></table></figure><p>记录了之后，就可以实现回溯的单层遍历了。这里还需要一个计数器来整体记录当前选了多少个机票，机票数量够了就可以return了。</p><ul><li>参数startAp记录起始机场；</li><li>遍历起始机场的目的地集合<code>ticketsMap[startAp]</code>，每次选择一个，继续往下递归；<ul><li>递归之前需要将选择的目的机场从set中删除，并插入retV返回值数组；</li><li>递归结束之后将选择的目的机场重新插入set，并从retV返回值数组中删除；</li></ul></li><li>当遍历到某个机场的目的地集合为空的时候，说明走到了叶子节点，返回；</li><li>当当前已经选择机票达到上限（注意每个机票必须且只能使用一次），返回；</li></ul><p>这里就出现了一个问题：因为我们需要从set中删除数据，但删除的同时我们又需要继续遍历set，这便是一个经典的<code>迭代器失效</code>问题。因为set是基于红黑树的，当前节点被删除后，它就和其他节点没有链接关系了，迭代器无法继续往下走。不过我们可以先获取下一个迭代器的值，再删除，但那样对于for循环而言就有些麻烦了。</p><p>所以，我们可以将multiset改成另外一个map，用计数器来替代删除。当计数器为0的时候，可以认为这个机票已经不可用了（等价于被删除）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// &lt;起始机场,&lt;目的机场,票数&gt;&gt;</span></span><br><span class="line">unordered_map&lt;string,map&lt;string,<span class="type">int</span>&gt;&gt; ticketsMap;</span><br></pre></td></tr></table></figure><p>用下面的循环对这个map进行初始化</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span>&amp; v : tickets) &#123;</span><br><span class="line">ticketsMap[v[<span class="number">0</span>]][v[<span class="number">1</span>]]++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样，每一层for的时候，直接将对应票数减一即可。循环的时候跳过票数为0的机场即可。当一个机场的所有目的地机票都为0，则说明这个机场不能继续往下飞了。</p><h3 id="错误代码-1"><a href="#错误代码-1" class="headerlink" title="错误代码"></a>错误代码</h3><p>根据上面的思路，可以写出这样的第一版代码。注意代码中<strong>范围循环</strong>中auto一定要写引用<code>auto&amp;</code>，因为我们需要通过<code>p.second</code>直接修改ticket的计数器。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    vector&lt;string&gt; retV;</span><br><span class="line">    <span class="comment">// 判断是否所有机票都用完了</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">checkTicketsEmpty</span><span class="params">(map&lt;string, <span class="type">int</span>&gt;&amp; tickets)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; p : tickets) &#123;</span><br><span class="line">            <span class="keyword">if</span> (p.second != <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 回溯法，每一次都找一个机场走，注意起点机场是JFK</span></span><br><span class="line">    <span class="comment">// ticketSum是总共的机票数量，ticketNum是当前已经被使用过的机票数量</span></span><br><span class="line">    <span class="type">void</span> _findItinerary(unordered_map&lt;string, map&lt;string, <span class="type">int</span>&gt;&gt;&amp; ticketsMap,</span><br><span class="line">                        <span class="type">const</span> <span class="type">int</span> ticketsSum, <span class="type">int</span> ticketsNum,</span><br><span class="line">                        <span class="type">const</span> string&amp; startAp) &#123;</span><br><span class="line">        <span class="comment">// 如果ticket被用完了，也可以返回</span></span><br><span class="line">        <span class="keyword">if</span> (ticketsNum == ticketsSum) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果map里面对应的目的机场机票都用完了，这一层没有办法往下走了</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">checkTicketsEmpty</span>(ticketsMap[startAp])) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果不是，随机选择一个机场往下走</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; p : ticketsMap[startAp]) &#123;</span><br><span class="line">            <span class="comment">// 跳过已经选择了的机场</span></span><br><span class="line">            <span class="keyword">if</span> (p.second == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 没有选择过，可以走</span></span><br><span class="line">            retV.<span class="built_in">push_back</span>(p.first);</span><br><span class="line">            p.second--;   <span class="comment">// 机票数量减一</span></span><br><span class="line">            ticketsNum++; <span class="comment">// 已选机票数量加一</span></span><br><span class="line">            cout &lt;&lt; startAp &lt;&lt; <span class="string">&quot;-&gt;&quot;</span> &lt;&lt; p.first &lt;&lt; <span class="string">&quot;:&quot;</span> &lt;&lt; p.second</span><br><span class="line">                 &lt;&lt; <span class="string">&quot; num:&quot;</span> &lt;&lt; ticketsNum &lt;&lt; endl;</span><br><span class="line">            _findItinerary(ticketsMap, ticketsSum, ticketsNum, p.first);</span><br><span class="line">            <span class="comment">// 回溯操作</span></span><br><span class="line">            p.second++;</span><br><span class="line">            ticketsNum--;</span><br><span class="line">            retV.<span class="built_in">pop_back</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;string&gt; <span class="title">findItinerary</span><span class="params">(vector&lt;vector&lt;string&gt;&gt;&amp; tickets)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 存放&lt;起点机场,&lt;目的机场,票数&gt;&gt;</span></span><br><span class="line">        <span class="comment">// 两个机场之间单向只会有一个票，所以不需要用multimap</span></span><br><span class="line">        unordered_map&lt;string, map&lt;string, <span class="type">int</span>&gt;&gt; ticketsMap;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; v : tickets) &#123;</span><br><span class="line">            ticketsMap[v[<span class="number">0</span>]][v[<span class="number">1</span>]]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 因为是从JFK开始的，所以需要先把第一个值插入</span></span><br><span class="line">        retV.<span class="built_in">push_back</span>(<span class="string">&quot;JFK&quot;</span>);</span><br><span class="line">        _findItinerary(ticketsMap, tickets.<span class="built_in">size</span>(), <span class="number">0</span>, <span class="string">&quot;JFK&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> retV;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>但是这一版代码有问题，会发现结果集里面只有JFK被插入了</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/04/da1d1929064a8726263cbe4a56fad97e.png" alt="image.png"></p><p>这是因为当前用例中，for循环内并没有进行条件判断，这就导致retV一直在被<code>插入-&gt;递归-&gt;删除</code>，最终retV里面的值还是空的。</p><p>添加一个cout打印，可以看到如下输出，其中ticketsNum已经打印到4了，说明我们期待的结果起始已经出现了，但因为回溯的<code>pop_back</code>又被删除了。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">JFK-&gt;MUC:0 num:1</span><br><span class="line">MUC-&gt;LHR:0 num:2</span><br><span class="line">LHR-&gt;SFO:0 num:3</span><br><span class="line">SFO-&gt;SJC:0 num:4</span><br></pre></td></tr></table></figure><p>所以，我们需要在for循环中添加一个判断，当当前递归的返回值retV已经符合条件的时候，直接跳过pop_back回溯步骤，提前返回。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">_findItinerary(ticketsMap, ticketsSum, ticketsNum, p.first);</span><br><span class="line">         <span class="comment">// 符合条件了，直接跳出</span></span><br><span class="line">         <span class="keyword">if</span> (retV.<span class="built_in">size</span>() == ticketsSum) &#123;</span><br><span class="line">             <span class="keyword">return</span>;</span><br><span class="line">         &#125;</span><br></pre></td></tr></table></figure><p>这里的判断是错误的，因为传入的ticketsSum是机票的总数量，而retV中的结果集是存放路途中经过地点的，经过的地点应该比机票数量多一张！</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 符合条件了，直接跳出，地点比机票数量多一个</span></span><br><span class="line"><span class="keyword">if</span> (retV.<span class="built_in">size</span>() == ticketsSum+<span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="完整代码-11"><a href="#完整代码-11" class="headerlink" title="完整代码"></a>完整代码</h3><p>下面是正确的代码</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    vector&lt;string&gt; retV;</span><br><span class="line">    <span class="comment">// 判断是否所有机票都用完了</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">checkTicketsEmpty</span><span class="params">(map&lt;string, <span class="type">int</span>&gt;&amp; tickets)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; p : tickets) &#123;</span><br><span class="line">            <span class="keyword">if</span> (p.second != <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 回溯法，每一次都找一个机场走，注意起点机场是JFK</span></span><br><span class="line">    <span class="comment">// ticketSum是总共的机票数量，ticketNum是当前已经被使用过的机票数量</span></span><br><span class="line">    <span class="type">void</span> _findItinerary(unordered_map&lt;string, map&lt;string, <span class="type">int</span>&gt;&gt;&amp; ticketsMap,</span><br><span class="line">                        <span class="type">const</span> <span class="type">int</span> ticketsSum, <span class="type">int</span> ticketsNum,</span><br><span class="line">                        <span class="type">const</span> string&amp; startAp) &#123;</span><br><span class="line">        <span class="comment">// 如果ticket被用完了，也可以返回</span></span><br><span class="line">        <span class="keyword">if</span> (ticketsNum == ticketsSum) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果map里面对应的目的机场机票都用完了，这一层没有办法往下走了</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">checkTicketsEmpty</span>(ticketsMap[startAp])) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果不是，随机选择一个机场往下走</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; p : ticketsMap[startAp]) &#123;</span><br><span class="line">            <span class="comment">// 跳过已经选择了的机场</span></span><br><span class="line">            <span class="keyword">if</span> (p.second == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 没有选择过，可以走</span></span><br><span class="line">            retV.<span class="built_in">push_back</span>(p.first);</span><br><span class="line">            p.second--;   <span class="comment">// 机票数量减一</span></span><br><span class="line">            ticketsNum++; <span class="comment">// 已选机票数量加一</span></span><br><span class="line">            <span class="comment">// cout &lt;&lt; startAp &lt;&lt; &quot;-&gt;&quot; &lt;&lt; p.first &lt;&lt; &quot;:&quot; &lt;&lt; p.second</span></span><br><span class="line">            <span class="comment">//      &lt;&lt; &quot; num:&quot; &lt;&lt; ticketsNum &lt;&lt; endl;</span></span><br><span class="line">            _findItinerary(ticketsMap, ticketsSum, ticketsNum, p.first);</span><br><span class="line">            <span class="comment">// 符合条件了，直接跳出，地点比机票数量多一个</span></span><br><span class="line">            <span class="keyword">if</span> (retV.<span class="built_in">size</span>() == ticketsSum + <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 回溯操作</span></span><br><span class="line">            p.second++;</span><br><span class="line">            ticketsNum--;</span><br><span class="line">            retV.<span class="built_in">pop_back</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;string&gt; <span class="title">findItinerary</span><span class="params">(vector&lt;vector&lt;string&gt;&gt;&amp; tickets)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 存放&lt;起点机场,&lt;目的机场,票数&gt;&gt;</span></span><br><span class="line">        <span class="comment">// 两个机场之间单向只会有一个票，所以不需要用multimap</span></span><br><span class="line">        unordered_map&lt;string, map&lt;string, <span class="type">int</span>&gt;&gt; ticketsMap;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; v : tickets) &#123;</span><br><span class="line">            ticketsMap[v[<span class="number">0</span>]][v[<span class="number">1</span>]]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 因为是从JFK开始的，所以需要先把第一个值插入</span></span><br><span class="line">        retV.<span class="built_in">push_back</span>(<span class="string">&quot;JFK&quot;</span>);</span><br><span class="line">        _findItinerary(ticketsMap, tickets.<span class="built_in">size</span>(), <span class="number">0</span>, <span class="string">&quot;JFK&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> retV;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/04/ddda44cea08f7d0f079120b8fa5efe7f.png" alt="image.png"></p><p>这个代码还有可优化之处，比如<code>checkTicketsEmpty</code>函数中做的判断就没有意义了，因为for循环中本来也会判断票数是否为0。加上这个函数会让每一层递归的时间复杂度多一个<code>O(N)</code>。把它删除，代码也能通过。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    vector&lt;string&gt; retV;</span><br><span class="line">    <span class="comment">// 回溯法，每一次都找一个机场走，注意起点机场是JFK</span></span><br><span class="line">    <span class="comment">// ticketSum是总共的机票数量，ticketNum是当前已经被使用过的机票数量</span></span><br><span class="line">    <span class="type">void</span> _findItinerary(unordered_map&lt;string, map&lt;string, <span class="type">int</span>&gt;&gt;&amp; ticketsMap,</span><br><span class="line">                        <span class="type">const</span> <span class="type">int</span> ticketsSum, <span class="type">int</span> ticketsNum,</span><br><span class="line">                        <span class="type">const</span> string&amp; startAp) &#123;</span><br><span class="line">        <span class="comment">// 如果ticket被用完了，也可以返回</span></span><br><span class="line">        <span class="keyword">if</span> (ticketsNum == ticketsSum) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果不是，随机选择一个机场往下走</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; p : ticketsMap[startAp]) &#123;</span><br><span class="line">            <span class="comment">// 跳过已经选择了的机场</span></span><br><span class="line">            <span class="keyword">if</span> (p.second == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 没有选择过，可以走</span></span><br><span class="line">            retV.<span class="built_in">push_back</span>(p.first);</span><br><span class="line">            p.second--;   <span class="comment">// 机票数量减一</span></span><br><span class="line">            ticketsNum++; <span class="comment">// 已选机票数量加一</span></span><br><span class="line"><span class="comment">// 递归下一层</span></span><br><span class="line">            _findItinerary(ticketsMap, ticketsSum, ticketsNum, p.first);</span><br><span class="line">            <span class="comment">// 符合条件了，直接跳出，地点数量比机票数量多一个</span></span><br><span class="line">            <span class="keyword">if</span> (retV.<span class="built_in">size</span>() == ticketsSum + <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 回溯操作</span></span><br><span class="line">            p.second++;</span><br><span class="line">            ticketsNum--;</span><br><span class="line">            retV.<span class="built_in">pop_back</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;string&gt; <span class="title">findItinerary</span><span class="params">(vector&lt;vector&lt;string&gt;&gt;&amp; tickets)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 存放&lt;起点机场,&lt;目的机场,票数&gt;&gt;</span></span><br><span class="line">        <span class="comment">// 两个机场之间单向只会有一个票，所以不需要用multimap</span></span><br><span class="line">        unordered_map&lt;string, map&lt;string, <span class="type">int</span>&gt;&gt; ticketsMap;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; v : tickets) &#123;</span><br><span class="line">            ticketsMap[v[<span class="number">0</span>]][v[<span class="number">1</span>]]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 因为是从JFK开始的，所以需要先把第一个值插入</span></span><br><span class="line">        retV.<span class="built_in">push_back</span>(<span class="string">&quot;JFK&quot;</span>);</span><br><span class="line">        _findItinerary(ticketsMap, tickets.<span class="built_in">size</span>(), <span class="number">0</span>, <span class="string">&quot;JFK&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> retV;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>耗时也变短了（虽然这个耗时没有参考价值）。</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/04/9532e24a5566b8086b9d11f7d70c9b70.png" alt="image.png"></p><h3 id="代码随想录版本"><a href="#代码随想录版本" class="headerlink" title="代码随想录版本"></a>代码随想录版本</h3><p>下面的代码是《代码随想录》上的版本，大佬将递归函数的返回值改成了bool，以此来标识是否符合条件，true代表可以提前退出。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="comment">// unordered_map&lt;出发机场, map&lt;到达机场, 航班次数&gt;&gt; targets</span></span><br><span class="line">unordered_map&lt;string, map&lt;string, <span class="type">int</span>&gt;&gt; targets;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">backtracking</span><span class="params">(<span class="type">int</span> ticketNum, vector&lt;string&gt;&amp; result)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (result.<span class="built_in">size</span>() == ticketNum + <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (pair&lt;<span class="type">const</span> string, <span class="type">int</span>&gt;&amp; target : targets[result[result.<span class="built_in">size</span>() - <span class="number">1</span>]]) &#123;</span><br><span class="line">        <span class="keyword">if</span> (target.second &gt; <span class="number">0</span> ) &#123; <span class="comment">// 记录到达机场是否飞过了</span></span><br><span class="line">            result.<span class="built_in">push_back</span>(target.first);</span><br><span class="line">            target.second--;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">backtracking</span>(ticketNum, result)) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            result.<span class="built_in">pop_back</span>();</span><br><span class="line">            target.second++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;string&gt; <span class="title">findItinerary</span><span class="params">(vector&lt;vector&lt;string&gt;&gt;&amp; tickets)</span> </span>&#123;</span><br><span class="line">        targets.<span class="built_in">clear</span>();</span><br><span class="line">        vector&lt;string&gt; result;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">const</span> vector&lt;string&gt;&amp; vec : tickets) &#123;</span><br><span class="line">            targets[vec[<span class="number">0</span>]][vec[<span class="number">1</span>]]++; <span class="comment">// 记录映射关系</span></span><br><span class="line">        &#125;</span><br><span class="line">        result.<span class="built_in">push_back</span>(<span class="string">&quot;JFK&quot;</span>); <span class="comment">// 起始机场</span></span><br><span class="line">        <span class="built_in">backtracking</span>(tickets.<span class="built_in">size</span>(), result);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="51-N皇后"><a href="#51-N皇后" class="headerlink" title="51 N皇后"></a>51 N皇后</h2><blockquote><p><a href="https://leetcode.cn/problems/n-queens/description/">https://leetcode.cn/problems/n-queens/description/</a></p></blockquote><h3 id="题目和思路-13"><a href="#题目和思路-13" class="headerlink" title="题目和思路"></a>题目和思路</h3><p>按照国际象棋的规则，皇后可以攻击与之处在同一行或同一列或同一斜线上的棋子。</p><p>n 皇后问题 研究的是如何将 n 个皇后放置在 n×n 的棋盘上，并且使皇后彼此之间不能相互攻击。</p><p>给你一个整数 n ，返回所有不同的 n 皇后问题 的解决方案。</p><p>每一种解法包含一个不同的 n 皇后问题 的棋子放置方案，该方案中 ‘Q’ 和 ‘.’ 分别代表了皇后和空位。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">示例 1：</span><br><span class="line">输入：n = 4</span><br><span class="line">输出：[[&quot;.Q..&quot;,&quot;...Q&quot;,&quot;Q...&quot;,&quot;..Q.&quot;],[&quot;..Q.&quot;,&quot;Q...&quot;,&quot;...Q&quot;,&quot;.Q..&quot;]]</span><br><span class="line">解释：如上图所示，4 皇后问题存在两个不同的解法。</span><br><span class="line"></span><br><span class="line">示例 2：</span><br><span class="line">输入：n = 1</span><br><span class="line">输出：[[&quot;Q&quot;]]</span><br></pre></td></tr></table></figure><p>这道题是回溯的经典题目：</p><ul><li>回溯每一层模拟每一列的遍历（横向）</li><li>多层递归模拟每一行行的遍历（纵向）</li></ul><p>整体的思路如下：</p><ul><li>每一层的for在当前行选择一个位置设置为Q</li><li>判断该位置是否符合N皇后的条件</li><li>符合，递归下一层，行号加一</li><li>当行号等于N时，代表越界，插入结果集并终止递归。</li></ul><p>主要是写出判断每一层是否符合皇后占位的代码，回溯的思路不难。</p><ul><li>皇后所在的行和列，斜线上都不能有其他皇后。</li></ul><p>对于我们的回溯而言，因为每一层都是for在当前行选择一个作为皇后，所以同行不会有多个皇后，不需要判断当前行。</p><p>而回溯的每一层是模拟从上往下的纵向遍历，所以纵向上也只需要判断<strong>当前列</strong>在当前行之前是否有其他皇后（当前行之后都还没有被操作）。</p><p>其次就是斜线上的判断了，这里主要涉及到行和列下标如何操作，注意我们是从当前位置沿着斜线往上遍历</p><ul><li>135°斜线（右上到左下）：行号和列号每次都减一；</li><li>45°斜线（左下到右上）：行号减一，列号加一；</li></ul><p>如下就是判断当前位置是否可以放皇后的代码。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">checkQueen</span><span class="params">(<span class="type">const</span> vector&lt;string&gt;&amp; curV, <span class="type">int</span> n, <span class="type">int</span> row, <span class="type">int</span> col)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 因为在回溯每一层的时候都只会选择一行进行处理，一行只会有一个Q，不需要遍历</span></span><br><span class="line">    <span class="comment">// 遍历列（这里小于row就行了，因为回溯才走到这里，更大的行是没有数据的）</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; row; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (curV[i][col] == <span class="string">&#x27;Q&#x27;</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 遍历右边斜线（从右上到左下的斜线,135°）</span></span><br><span class="line">    <span class="comment">// 减一开始往回遍历</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = row - <span class="number">1</span>, j = col - <span class="number">1</span>; i &gt;= <span class="number">0</span> &amp;&amp; j &gt;= <span class="number">0</span>; i--, j--) &#123;</span><br><span class="line">        <span class="keyword">if</span> (curV[i][j] == <span class="string">&#x27;Q&#x27;</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 遍历左边斜线，45°</span></span><br><span class="line">    <span class="comment">// 这里应该是列加一行减一，然后每一次都是行减一列加一</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = row - <span class="number">1</span>, j = col + <span class="number">1</span>; i &gt;= <span class="number">0</span> &amp;&amp; j &lt; n; i--, j++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (curV[i][j] == <span class="string">&#x27;Q&#x27;</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="错误代码-2"><a href="#错误代码-2" class="headerlink" title="错误代码"></a>错误代码</h3><p>刚开始我写出了这样的代码</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> col = <span class="number">0</span>; col &lt; n; col++) &#123;</span><br><span class="line">          <span class="comment">// 判断是否符合条件，不符合直接返回</span></span><br><span class="line">          <span class="keyword">if</span> (<span class="built_in">checkQueen</span>(curV, n, row, col) == <span class="literal">false</span>) &#123;</span><br><span class="line">              <span class="keyword">continue</span>; <span class="comment">// 后面可能有符合条件的，不能return</span></span><br><span class="line">          &#125;</span><br><span class="line">          curV[row][col] = <span class="string">&#x27;Q&#x27;</span>; <span class="comment">// 假设为皇后</span></span><br><span class="line">          row++;                <span class="comment">// 下一行</span></span><br><span class="line">          <span class="comment">// 递归</span></span><br><span class="line">          _solveNQueens(n, row, curV);</span><br><span class="line">          <span class="comment">// 回溯</span></span><br><span class="line">          curV[row][col] = <span class="string">&#x27;.&#x27;</span>; <span class="comment">// 重置</span></span><br><span class="line">          row--; </span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure><p>但是提交发现retV始终为空，想不明白为什么。最终加了一堆打印之后，发现了问题所在。如下所示，这是正确的一个结果集内的回溯过程，选中了<code>(0,1)</code>和<code>(1,3)</code>后，理论上<code>(2,0)</code>应该要被选中，但是<code>(2,0)</code>在判断中却因为<code>(0,0)</code>处是Q而退出了。打印出第0行的字符串，发现这里就有两个Q，很明显是第一波的操作没有被成功回溯。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">good: 0 1</span><br><span class="line">1 0</span><br><span class="line">1 1</span><br><span class="line">1 2</span><br><span class="line">1 3</span><br><span class="line">good: 1 3</span><br><span class="line">2 0</span><br><span class="line">2,0 exit here1： 0 0</span><br><span class="line">string: QQ..</span><br></pre></td></tr></table></figure><p>检查回溯部分的代码，会发现这两行有问题</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 回溯</span></span><br><span class="line">curV[row][col] = <span class="string">&#x27;.&#x27;</span>; <span class="comment">// 重置</span></span><br><span class="line">row--; </span><br></pre></td></tr></table></figure><p>在调用递归函数之前，将row++了，此时回溯却先重置点再row–，问题就出现了：被重置的是下一行的col位置，和当前应该回溯的不是同一个位置！<strong>正确代码是先修复row再重置数组中的值</strong>！</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 回溯</span></span><br><span class="line">row--; </span><br><span class="line">curV[row][col] = <span class="string">&#x27;.&#x27;</span>; <span class="comment">// 重置</span></span><br><span class="line"><span class="comment">// row--; // error，应该先减减再重置数组中的值</span></span><br></pre></td></tr></table></figure><h3 id="完整代码-12"><a href="#完整代码-12" class="headerlink" title="完整代码"></a>完整代码</h3><p>正确的代码如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    vector&lt;vector&lt;string&gt;&gt; retV;</span><br><span class="line">    <span class="comment">// n是皇后数量（同时也是棋盘的边长），row是行号</span></span><br><span class="line">    <span class="type">void</span> _solveNQueens(<span class="type">int</span> n, <span class="type">int</span> row, vector&lt;string&gt;&amp; curV) &#123;</span><br><span class="line">        <span class="comment">// 行号是下标，当下标row等于n的时候代表越界，找到了一个解</span></span><br><span class="line">        <span class="keyword">if</span> (n == row) &#123;</span><br><span class="line">            retV.<span class="built_in">push_back</span>(curV);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 列号，每一位都尝试使用</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> col = <span class="number">0</span>; col &lt; n; col++) &#123;</span><br><span class="line">            <span class="comment">// 判断是否符合条件，不符合直接返回</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">checkQueen</span>(curV, n, row, col) == <span class="literal">false</span>) &#123;</span><br><span class="line">                <span class="keyword">continue</span>; <span class="comment">// 后面可能有符合条件的，不能return</span></span><br><span class="line">            &#125;</span><br><span class="line">            curV[row][col] = <span class="string">&#x27;Q&#x27;</span>; <span class="comment">// 假设为皇后</span></span><br><span class="line">            row++;                <span class="comment">// 下一行</span></span><br><span class="line">            <span class="comment">// 递归</span></span><br><span class="line">            _solveNQueens(n, row, curV);</span><br><span class="line">            <span class="comment">// 回溯</span></span><br><span class="line">            row--;</span><br><span class="line">            curV[row][col] = <span class="string">&#x27;.&#x27;</span>; <span class="comment">// 重置</span></span><br><span class="line">            <span class="comment">// row--; // error，应该先减减再重置数组中的值</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 注意，每一次选择都需要做检查，判断同一行，同一列，斜线上是否有其他皇后</span></span><br><span class="line">    <span class="comment">// 入参是当前插入皇后的位置</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">checkQueen</span><span class="params">(<span class="type">const</span> vector&lt;string&gt;&amp; curV, <span class="type">int</span> n, <span class="type">int</span> row, <span class="type">int</span> col)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 因为在回溯每一层的时候都只会选择一行进行处理，一行只会有一个Q，不需要遍历</span></span><br><span class="line">        <span class="comment">// 遍历列（这里小于row就行了，因为回溯才走到这里，更大的行是没有数据的）</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; row; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (curV[i][col] == <span class="string">&#x27;Q&#x27;</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 遍历右边斜线（从右上到左下的斜线,135°）</span></span><br><span class="line">        <span class="comment">// 减一开始往回遍历</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = row - <span class="number">1</span>, j = col - <span class="number">1</span>; i &gt;= <span class="number">0</span> &amp;&amp; j &gt;= <span class="number">0</span>; i--, j--) &#123;</span><br><span class="line">            <span class="keyword">if</span> (curV[i][j] == <span class="string">&#x27;Q&#x27;</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 遍历左边斜线，45°</span></span><br><span class="line">        <span class="comment">// 这里应该是列加一行减一，然后每一次都是行减一列加一</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = row - <span class="number">1</span>, j = col + <span class="number">1</span>; i &gt;= <span class="number">0</span> &amp;&amp; j &lt; n; i--, j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (curV[i][j] == <span class="string">&#x27;Q&#x27;</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;string&gt;&gt; <span class="built_in">solveNQueens</span>(<span class="type">int</span> n) &#123;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">1</span>) &#123;</span><br><span class="line">            retV.<span class="built_in">push_back</span>(vector&lt;string&gt;&#123;<span class="string">&quot;Q&quot;</span>&#125;);</span><br><span class="line">            <span class="keyword">return</span> retV;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 注意vector需要初始化，不然没有办法直接下标操作</span></span><br><span class="line">        <span class="function">vector&lt;string&gt; <span class="title">curV</span><span class="params">(n, string(n, <span class="string">&#x27;.&#x27;</span>))</span></span>;</span><br><span class="line">        _solveNQueens(n, <span class="number">0</span>, curV);</span><br><span class="line">        <span class="keyword">return</span> retV;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/04/8ce3959a7b61554f8450dfbe341bb492.png" alt="image.png"></p>]]></content>
    
    
    <summary type="html">学习回溯算法并练习</summary>
    
    
    
    <category term="编程学习" scheme="https://blog.musnow.top/categories/%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="把题目都给刷干净" scheme="https://blog.musnow.top/categories/%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0/%E6%8A%8A%E9%A2%98%E7%9B%AE%E9%83%BD%E7%BB%99%E5%88%B7%E5%B9%B2%E5%87%80/"/>
    
    
    <category term="算法" scheme="https://blog.musnow.top/tags/%E7%AE%97%E6%B3%95/"/>
    
    <category term="Cpp" scheme="https://blog.musnow.top/tags/Cpp/"/>
    
    <category term="回溯" scheme="https://blog.musnow.top/tags/%E5%9B%9E%E6%BA%AF/"/>
    
  </entry>
  
  <entry>
    <title>【leetcode】哈希OJ题，383赎金信/202快乐数/242有效的字母异位词</title>
    <link href="https://blog.musnow.top/posts/4214339491/"/>
    <id>https://blog.musnow.top/posts/4214339491/</id>
    <published>2024-03-18T08:18:13.000Z</published>
    <updated>2024-03-19T04:47:49.000Z</updated>
    
    <content type="html"><![CDATA[<p>这几道哈希的题目，其用到的思想适用于很多可以用哈希来解决的题目。</p><h1 id="383-赎金信"><a href="#383-赎金信" class="headerlink" title="383. 赎金信"></a>383. 赎金信</h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><blockquote><p><a href="https://leetcode.cn/problems/ransom-note/">383. 赎金信</a></p></blockquote><p>给你两个字符串：<code>ransomNote</code> 和 <code>magazine</code> ，判断 <code>ransomNote</code> 能不能由 <code>magazine</code> 里面的字符构成。</p><p>如果可以，返回 <code>true</code> ；否则返回 <code>false</code> 。</p><p><code>magazine</code> 中的每个字符只能在 <code>ransomNote</code> 中使用一次。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">示例 1：</span><br><span class="line">输入：ransomNote = &quot;a&quot;, magazine = &quot;b&quot;</span><br><span class="line">输出：false</span><br><span class="line"></span><br><span class="line">示例 2：</span><br><span class="line">输入：ransomNote = &quot;aa&quot;, magazine = &quot;ab&quot;</span><br><span class="line">输出：false</span><br><span class="line"></span><br><span class="line">示例 3：</span><br><span class="line">输入：ransomNote = &quot;aa&quot;, magazine = &quot;aab&quot;</span><br><span class="line">输出：true</span><br></pre></td></tr></table></figure><ul><li><code>1 &lt;= ransomNote.length, magazine.length &lt;= 105</code></li><li><code>ransomNote</code> 和 <code>magazine</code> 由小写英文字母组成</li></ul><h2 id="思路和代码"><a href="#思路和代码" class="headerlink" title="思路和代码"></a>思路和代码</h2><p>因为给出的两个字符串里面都只包含小写的英文字母，所以我们用不上<code>unordered_map</code>，只需要用一个26长度的int数组就可以了。</p><ul><li>26长度的int数组，全部初始化为0；</li><li>遍历，记录magazine中每一个字符出现的次数；</li><li>遍历ransomNote字符串，将magazine中对应字符计数器减一；</li><li>如果某个计数器减至负数，则说明magazine中的字符不够用，返回false；</li><li>如果遍历完毕没有出现问题，则返回true；</li></ul><p>代码如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">canConstruct</span><span class="params">(string ransomNote, string magazine)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(ransomNote.<span class="built_in">size</span>() &gt; magazine.<span class="built_in">size</span>())&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">// 因为已经超过了字符大小，所以肯定不符合条件</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> arr[<span class="number">26</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i&lt;magazine.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            arr[magazine[i] -<span class="string">&#x27;a&#x27;</span>] ++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i&lt;ransomNote.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            arr[ransomNote[i] -<span class="string">&#x27;a&#x27;</span>] --;</span><br><span class="line">            <span class="keyword">if</span>(arr[ransomNote[i] -<span class="string">&#x27;a&#x27;</span>] &lt; <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/03/8a3bc3b098bf98a6b3b28842d6ef6436.png" alt="image-20240318180705925"></p><h1 id="202-快乐数"><a href="#202-快乐数" class="headerlink" title="202. 快乐数"></a>202. 快乐数</h1><h2 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h2><blockquote><p><a href="https://leetcode.cn/problems/happy-number/">202. 快乐数</a></p></blockquote><p>编写一个算法来判断一个数 <code>n</code> 是不是快乐数。</p><p><strong>「快乐数」</strong> 定义为：</p><ul><li>对于一个正整数，每一次将该数替换为它每个位置上的数字的平方和。</li><li>然后重复这个过程直到这个数变为 1，也可能是 <strong>无限循环</strong> 但始终变不到 1。</li><li>如果这个过程 <strong>结果为</strong> 1，那么这个数就是快乐数。</li></ul><p>如果 <code>n</code> 是 <em>快乐数</em> 就返回 <code>true</code> ；不是，则返回 <code>false</code> 。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">示例 1：</span><br><span class="line">输入：n = 19</span><br><span class="line">输出：true</span><br><span class="line">解释：</span><br><span class="line">12 + 92 = 82</span><br><span class="line">82 + 22 = 68</span><br><span class="line">62 + 82 = 100</span><br><span class="line">12 + 02 + 02 = 1</span><br><span class="line"></span><br><span class="line">示例 2：</span><br><span class="line">输入：n = 2</span><br><span class="line">输出：false</span><br></pre></td></tr></table></figure><ul><li><code>1 &lt;= n &lt;= 231 - 1</code></li></ul><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>这道题其实是个数学题，用到哈希的地方是判断之前出现的结果是否已经出现过了。题目中提到“然后重复这个过程直到这个数变为 1，也可能是 <strong>无限循环</strong> 但始终变不到 1”，即可能会有用例，到最后计算的结果出现无限循环。</p><p>此时就需要用哈希来判断某一个结果是否已经出现过，如果出现过，第二次出现的时候就说明重复了，返回false退出循环计算即可。</p><p>代码如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="comment">// 每一次的计算</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getSum</span><span class="params">(<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="type">int</span> sum = <span class="number">0</span>; <span class="comment">// 这里必须赋值为0</span></span><br><span class="line">        <span class="keyword">while</span>(n &gt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            sum += (n%<span class="number">10</span>)*(n%<span class="number">10</span>);</span><br><span class="line">            n/=<span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isHappy</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        unordered_set&lt;<span class="type">int</span>&gt; sets;</span><br><span class="line">        <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            sum = <span class="built_in">getSum</span>(n);</span><br><span class="line">            cout &lt;&lt; sum &lt;&lt; endl;</span><br><span class="line">            <span class="keyword">if</span>(sum == <span class="number">1</span>)&#123; <span class="comment">// 符合题目条件</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(sets.<span class="built_in">count</span>(sum) != <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">// 出现重复了</span></span><br><span class="line">            &#125;</span><br><span class="line">            sets.<span class="built_in">insert</span>(sum);</span><br><span class="line">            n = sum;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/03/839bd09fa76c380a299c5e0c319ad1b9.png" alt="image-20240318181637436"></p><h1 id="242-有效的字母异位词"><a href="#242-有效的字母异位词" class="headerlink" title="242. 有效的字母异位词"></a>242. 有效的字母异位词</h1><h2 id="题目-2"><a href="#题目-2" class="headerlink" title="题目"></a>题目</h2><blockquote><p><a href="https://leetcode.cn/problems/valid-anagram/">242. 有效的字母异位词</a></p></blockquote><p>给定两个字符串 <code>*s*</code> 和 <code>*t*</code> ，编写一个函数来判断 <code>*t*</code> 是否是 <code>*s*</code> 的字母异位词。</p><p><strong>注意：</strong>若 <code>*s*</code> 和 <code>*t*</code> 中每个字符出现的次数都相同，则称 <code>*s*</code> 和 <code>*t*</code> 互为字母异位词。</p><p><strong>示例 1:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: s = &quot;anagram&quot;, t = &quot;nagaram&quot;</span><br><span class="line">输出: true</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: s = &quot;rat&quot;, t = &quot;car&quot;</span><br><span class="line">输出: false</span><br></pre></td></tr></table></figure><p><strong>提示:</strong></p><ul><li><code>1 &lt;= s.length, t.length &lt;= 5 * 104</code></li><li><code>s</code> 和 <code>t</code> 仅包含小写字母</li></ul><h2 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h2><p>字母异位词就是两个字符串中所有字符出现的次数都相同，如果有不同的就不是字母异位词。</p><p>可以用两种思路来解决</p><ul><li>对字符串排序，字母异位词排序后的结果肯定相同</li><li>使用哈希计算每个字符出现的次数，比较两个字符串中每个字符出现的次数是否相同，不相同则出现错误</li></ul><p>这里采用哈希的思路，代码如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isAnagram</span><span class="params">(string s, string t)</span> </span>&#123;</span><br><span class="line">        unordered_map&lt;<span class="type">char</span>,<span class="type">int</span>&gt; maps;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span>&amp;e:s)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(!maps.<span class="built_in">count</span>(e))</span><br><span class="line">            &#123;</span><br><span class="line">                maps[e] = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                maps[e]++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span>&amp;e:t)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(!maps.<span class="built_in">count</span>(e))&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            maps[e]--;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span>&amp;e:maps)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(e.second != <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/03/092cbf9c367cf0a04561d745cb40624d.png" alt="image-20240318181945788"></p>]]></content>
    
    
    <summary type="html">哈希OJ题，383赎金信/202快乐数/242有效的字母异位词</summary>
    
    
    
    <category term="编程学习" scheme="https://blog.musnow.top/categories/%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="把题目都给刷干净" scheme="https://blog.musnow.top/categories/%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0/%E6%8A%8A%E9%A2%98%E7%9B%AE%E9%83%BD%E7%BB%99%E5%88%B7%E5%B9%B2%E5%87%80/"/>
    
    
    <category term="Cpp" scheme="https://blog.musnow.top/tags/Cpp/"/>
    
    <category term="OJ刷题" scheme="https://blog.musnow.top/tags/OJ%E5%88%B7%E9%A2%98/"/>
    
    <category term="leetcode" scheme="https://blog.musnow.top/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>【C语言】带你用偷懒的方式刷爆二叉树OJ题</title>
    <link href="https://blog.musnow.top/posts/4165981723/"/>
    <id>https://blog.musnow.top/posts/4165981723/</id>
    <published>2024-03-15T08:25:30.000Z</published>
    <updated>2024-04-16T04:33:24.000Z</updated>
    
    <content type="html"><![CDATA[<p>本文首发于<code>2022-04-20</code>，2024年重新刷题，对本文做了较大更新，所以重新发布。</p><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>上篇博客我带大家领略了一番链式二叉树的操作，现在让我们来看看二叉树的相关题目，一起来巩固一下知识点吧！</p><p>点我复习上一篇博客的内容！👉 <a href="https://blog.csdn.net/muxuen/article/details/124212851?spm=1001.2014.3001.5501">传送门</a>；</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2023/02/202204161641683.gif" alt="QQ图片20220416140203"></p><h1 id="1-一些选择题"><a href="#1-一些选择题" class="headerlink" title="1.一些选择题"></a>1.一些选择题</h1><h2 id="1-1"><a href="#1-1" class="headerlink" title="1.1"></a>1.1</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">设一棵二叉树中有3个叶子结点，有8个度为1的结点，则该二叉树中总的结点数为（ ）个</span><br><span class="line">A.11</span><br><span class="line">B.12</span><br><span class="line">C.13  √</span><br><span class="line">D.14</span><br></pre></td></tr></table></figure><blockquote><p>设Ni表示度为i的节点个数，则节点总数 N &#x3D; N0 + N1 + N2</p><p>节点个数于节点边的关系： <strong>N个节点的树有N-1个边</strong></p><p>边与度的关系：N - 1 &#x3D; N1 + 2 * N2</p><p>故：N0 + N1 + N2 - 1 &#x3D; N1 + 2 * N2</p><p>因此，得：N0 &#x3D; N2 + 1</p><p>回到原题，N0 &#x3D; 3，N1 &#x3D; 8，可得N2 &#x3D; 2</p><p>因此答案是 3 + 8 + 2 &#x3D; 13</p></blockquote><h2 id="1-2"><a href="#1-2" class="headerlink" title="1.2"></a>1.2</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">有N个元素的完全二叉树的深度是()</span><br><span class="line">答案：logN+1</span><br></pre></td></tr></table></figure><p>高度为h的完全二叉树，节点个数在： <code>2^(h - 1) - 1 &lt; n &lt;= 2^h - 1</code></p><p>即<code>log(n + 1) &lt;= h &lt; log(n + 1) + 1</code></p><p>这里需要注意的是n左右区间的开闭问题</p><p>完全二叉树最少的节点个数是<code>2^(h - 1)-1+1</code>个，所以是<code>n&gt;2^(h - 1) - 1</code></p><hr><h2 id="1-3-由已知遍历序列画出原本树的结构"><a href="#1-3-由已知遍历序列画出原本树的结构" class="headerlink" title="1.3 由已知遍历序列画出原本树的结构"></a>1.3 由已知遍历序列画出原本树的结构</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">已知某二叉树的中序遍历序列为JGDHKBAELIMCF，后序遍历序列为JGKHDBLMIEFCA，则其前序遍历序列为（ ）</span><br><span class="line">A.ABDGHJKCEFILM</span><br><span class="line">B.ABDGJHKCEILMF   √</span><br><span class="line">C.ABDHKGJCEILMF</span><br><span class="line">D.ABDGJHKCEIMLF</span><br></pre></td></tr></table></figure><p>这道题我刚开始的思路是错的，因为我把它当作完全二叉树来看待，但题目并没有说它是完全二叉树</p><blockquote><p>主要思路：可以从后续遍历确定根节点为A，中序遍历可以确定A的左右子树。再继续从后序遍历中确定A左右子树的根节点，依次往下判断</p></blockquote><p>所以我画了一个分析图，如下👇</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2023/02/202204161628643.jpg" alt="IMG_20220415_103954"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">已知某二叉树的前序遍历序列为ABDEC，中序遍历序列为BDEAC，则该二叉树（ ）</span><br><span class="line">A.是满二叉树</span><br><span class="line">B.是完全二叉树，不是满二叉树</span><br><span class="line">C.不是完全二叉树   √</span><br><span class="line">D.是所有的结点都没有右子树的二叉树</span><br></pre></td></tr></table></figure><p>这道题的思路和上一道题是一样的</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2023/02/202204161631511.png" alt="image-20220416163152483"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">已知某二叉树的前序遍历序列为5 7 4 9 6 2 1，中序遍历序列为4 7 5 6 9 1 2，则其后序遍历序列为（ ）</span><br><span class="line">A.4 2 5 7 6 9 1</span><br><span class="line">B.4 2 7 5 6 9 1</span><br><span class="line">C.4 7 6 1 2 9 5  √</span><br><span class="line">D.4 7 2 9 5 6 1</span><br></pre></td></tr></table></figure><p>本题依旧和上面两道题思路相同！</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2023/02/202204161632859.jpg" alt="IMG_20220415_105012"></p><h2 id="1-4-单边树"><a href="#1-4-单边树" class="headerlink" title="1.4 单边树"></a>1.4 单边树</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">一棵非空的二叉树的先序遍历序列与后序遍历序列正好相反，则该二叉树一定满足（ ）</span><br><span class="line">A.所有的结点均无左孩子</span><br><span class="line">B.所有的结点均无右孩子</span><br><span class="line">C.只有一个叶子结点</span><br><span class="line">D.至多只有一个结点</span><br></pre></td></tr></table></figure><p>如果前序遍历和后序遍历序列正好相反，说明它是一个单边树，比如下面这前序和中序序列所构成的树的结构:</p><p>12345（纵向）</p><p>54321</p><p>对于单边树，只有一个叶子节点</p><hr><h2 id="1-5"><a href="#1-5" class="headerlink" title="1.5"></a>1.5</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">20.如果一颗二叉树的前序遍历的结果是ABCD，则满足条件的不同的二叉树有（ ）种</span><br><span class="line"></span><br><span class="line">A.13</span><br><span class="line">B.14 √</span><br><span class="line">C.15</span><br><span class="line">D.16</span><br></pre></td></tr></table></figure><blockquote><p>首先这棵二叉树的高度一定在3~4层之间:</p><p>三层：</p><p>A(B(C,D),()), A((),B(C,D)), A(B(C,()),D), A(B((),C),D),</p><p>A(B,C(D,())), A(B,C((),D))</p><p>四层：</p><p>如果为四层，就是单边树，每一层只有一个节点，除过根节点，其他节点都有两种选择，在上层节点的左边还是右边，所以<code>2*2*2</code>共8种</p><p>总共为14种。</p></blockquote><hr><h1 id="2-OJ题刷起来！"><a href="#2-OJ题刷起来！" class="headerlink" title="2.OJ题刷起来！"></a>2.OJ题刷起来！</h1><h2 id="KY11-二叉树遍历"><a href="#KY11-二叉树遍历" class="headerlink" title="KY11 二叉树遍历"></a>KY11 二叉树遍历</h2><blockquote><p>牛客网 KY11 二叉树遍历 👉<a href="https://www.nowcoder.com/practice/4b91205483694f449f94c179883c1fef?tpId=60&&tqId=29483&rp=1&ru=/activity/oj&qru=/ta/tsing-kaoyan/question-ranking">传送门</a></p></blockquote><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2023/02/202204161645079.png" alt="image-20220416164513012"></p><p>这道题要求我们用先序遍历的操作从<strong>一个数组中读出一个树</strong>，并构建出树的基本结构，再用中序遍历的方式打印出这颗树</p><p>之前我们学习了前序遍历的操作，这里只需要把前序遍历中的printf操作改成构建新树即可</p><ul><li>因为涉及道i的多次调用，所以函数中的i需要取地址，必须保证多次调用的i会同步++</li><li>构建完树的节点，并赋值后，需要递归构建左右子树，最后返回节点的地址</li><li>题目中的#代表NULL，直接return空即可</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdbool.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">char</span> BTDataType;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">BTreeNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">BTDataType data;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">BTreeNode</span>* <span class="title">left</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">BTreeNode</span>* <span class="title">right</span>;</span></span><br><span class="line">&#125;BTNode;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 二叉树中序遍历 </span></span><br><span class="line"><span class="type">void</span> <span class="title function_">BTreeInOrder</span><span class="params">(BTNode* root)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (root == <span class="literal">NULL</span>)&#123;</span><br><span class="line"><span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">BTreeInOrder(root-&gt;left);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%c &quot;</span>, root-&gt;data);</span><br><span class="line">BTreeInOrder(root-&gt;right);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">BTNode* <span class="title function_">CreatTree</span><span class="params">(<span class="type">char</span> *arr,<span class="type">int</span>*i)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (arr[*i] == <span class="string">&#x27;#&#x27;</span>)&#123;</span><br><span class="line">        (*i)++;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">    BTNode* newnode=(BTNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(BTNode));</span><br><span class="line">    </span><br><span class="line">    newnode-&gt;data=arr[(*i)++];<span class="comment">//i必须取地址</span></span><br><span class="line">    newnode-&gt;left=CreatTree(arr,i);<span class="comment">//递归构建左子树</span></span><br><span class="line">    newnode-&gt;right=CreatTree(arr,i);<span class="comment">//递归构建右子树</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> newnode;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> arr[<span class="number">100</span>];</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,arr);</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> i=<span class="number">0</span>;</span><br><span class="line">    BTNode* root=CreatTree(arr,&amp;i);</span><br><span class="line">    BTreeInOrder(root);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="100-相同的树"><a href="#100-相同的树" class="headerlink" title="100 相同的树"></a>100 相同的树</h2><blockquote><p>leetcode：<a href="https://leetcode-cn.com/problems/same-tree/">100. 相同的树</a></p></blockquote><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2023/02/202204161652255.png" alt="image-20220416165211195"></p><p>题目要求很简单，给定两颗树的根节点，要求我们判断这两棵树是否相同</p><ul><li>如果两棵树都为空，树相同</li><li>如果其中一个为空，另外一个不为空，树不同</li><li>如果两个都不为空，但是节点值不相同，树不同</li><li>然后再递归判断左子树和右子树，将它们的结果与<code>&amp;&amp;</code>在一起，其中一个为假，返回假</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="title function_">isSameTree</span><span class="params">(<span class="keyword">struct</span> TreeNode* p, <span class="keyword">struct</span> TreeNode* q)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(p==<span class="literal">NULL</span>&amp;&amp;q==<span class="literal">NULL</span>)<span class="comment">//比较是否两个节点都为空，都为空是真</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(p==<span class="literal">NULL</span>||q==<span class="literal">NULL</span>)<span class="comment">//如果有一个为空，另外一个非空，即为假</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(p-&gt;val!=q-&gt;val)<span class="comment">//都不是空，判断val的值是否相等</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//递归判断左子树和右子树是否相等</span></span><br><span class="line">    <span class="keyword">return</span> isSameTree(p-&gt;left,q-&gt;left)</span><br><span class="line">        &amp;&amp; isSameTree(p-&gt;right,q-&gt;right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2023/02/202204161706054.png" alt="image-20220416170618951"></p><p>这里顺便给出C++代码，基本一模一样</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="comment">// 两棵树按相同的方式进行遍历，就能判断出来</span></span><br><span class="line">    <span class="type">bool</span> _isSameTree(TreeNode* p, TreeNode* q) &#123;</span><br><span class="line">        <span class="comment">// 两个都为空，相同</span></span><br><span class="line">        <span class="keyword">if</span> (p == <span class="literal">nullptr</span> &amp;&amp; q == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 有一个为空，不相同</span></span><br><span class="line">        <span class="keyword">if</span> (p == <span class="literal">nullptr</span> &amp;&amp; q != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (p != <span class="literal">nullptr</span> &amp;&amp; q == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 值不相同</span></span><br><span class="line">        <span class="keyword">if</span> (p-&gt;val != q-&gt;val) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 同时递归判断左右子树</span></span><br><span class="line">        <span class="type">bool</span> left = _isSameTree(p-&gt;left, q-&gt;left);</span><br><span class="line">        <span class="type">bool</span> right = _isSameTree(p-&gt;right, q-&gt;right);</span><br><span class="line">        <span class="keyword">return</span> left &amp;&amp; right; <span class="comment">// 左右子树都相同才是同一棵树</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isSameTree</span><span class="params">(TreeNode* p, TreeNode* q)</span> </span>&#123; <span class="keyword">return</span> _isSameTree(p, q); &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>学会这道题后，后面一些题目其实只需要把它的代码改一改就能用了😂</p><p>什么？你不信？那就看看下面这道题！</p><hr><h2 id="101-对称二叉树"><a href="#101-对称二叉树" class="headerlink" title="101 对称二叉树"></a>101 对称二叉树</h2><blockquote><p>leetcode：<a href="https://leetcode-cn.com/problems/symmetric-tree/">101. 对称二叉树</a></p></blockquote><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2023/02/202204161657137.png" alt="image-20220416165729067"></p><p>题目要求很简单哈，判断是不是两边对称的树。这和判断树相等有什么区别呢？不就是把左右子树的判断改一下就行了嘛？</p><ul><li>根节点的<strong>左子树的左侧</strong>和根节点的<strong>右子树的右侧</strong>相同，即为对称。</li></ul><p>直接调用上一题的代码！注意最后的return值，是<strong>p的左和q的右</strong>进行判断</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> _isSameTree(<span class="keyword">struct</span> TreeNode* p, <span class="keyword">struct</span> TreeNode* q)&#123;</span><br><span class="line">    <span class="keyword">if</span>(p==<span class="literal">NULL</span>&amp;&amp;q==<span class="literal">NULL</span>)<span class="comment">//比较是否两个节点都为空，都为空是真</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(p==<span class="literal">NULL</span>||q==<span class="literal">NULL</span>)<span class="comment">//如果有一个为空，另外一个非空，即为假</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(p-&gt;val!=q-&gt;val)<span class="comment">//都不是空，判断val的值是否相等</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 递归判断左子树和右子树是否对称相等</span></span><br><span class="line">    <span class="keyword">return</span> _isSameTree(p-&gt;left,q-&gt;right)</span><br><span class="line">        &amp;&amp; _isSameTree(p-&gt;right,q-&gt;left);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> <span class="title function_">isSymmetric</span><span class="params">(<span class="keyword">struct</span> TreeNode* root)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> _isSameTree(root-&gt;left,root-&gt;right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2023/02/202204161706197.png" alt="image-20220416170605085"></p><p>使用迭代法也能解决这道题目。迭代法的思路有点类似层序遍历，但是并不同！</p><ul><li>使用队列存放节点，将根节点的左子树和右子树入队列</li><li>开始循环</li><li>取出队列的两个节点（根节点的左子树和右子树），将左子树的左侧和右子树的右侧入队列，将左子树的右侧和右子树的左侧入队列；</li><li>此时队列中的四个数值就是依照对称需要判断的节点值来排列的，在下一层循环的时候，只需要判断取出队列的头部两个节点的值是否相等就行了。</li><li>当取出的两个节点有一个为空，或者都不为空但节点值不同时，即不符合对称的条件。</li><li>注意，两个节点都为空是符合条件的。</li></ul><p>C++代码如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isSymmetric</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">nullptr</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        queue&lt;TreeNode*&gt; que;</span><br><span class="line">        que.<span class="built_in">push</span>(root-&gt;left);</span><br><span class="line">        que.<span class="built_in">push</span>(root-&gt;right);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(!que.<span class="built_in">empty</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 这里左右的顺序要和上面根节点插入左右的顺序一致</span></span><br><span class="line">            TreeNode* left = que.<span class="built_in">front</span>();</span><br><span class="line">            que.<span class="built_in">pop</span>();</span><br><span class="line">            TreeNode* right = que.<span class="built_in">front</span>();</span><br><span class="line">            que.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="keyword">if</span>(left == <span class="literal">nullptr</span> &amp;&amp; right == <span class="literal">nullptr</span>)&#123;</span><br><span class="line">                <span class="keyword">continue</span>; <span class="comment">// 两个都是空，符合条件，跳过</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 有一个不为空，或者值不同，都是错误的</span></span><br><span class="line">            <span class="keyword">if</span>((left == <span class="literal">nullptr</span> || right == <span class="literal">nullptr</span>) || (left-&gt;val != right-&gt;val))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 对称插入队列</span></span><br><span class="line">            que.<span class="built_in">push</span>(left-&gt;left);</span><br><span class="line">            que.<span class="built_in">push</span>(right-&gt;right);</span><br><span class="line">            que.<span class="built_in">push</span>(left-&gt;right);</span><br><span class="line">            que.<span class="built_in">push</span>(right-&gt;left);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;   </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="572-另外一棵树的子树"><a href="#572-另外一棵树的子树" class="headerlink" title="572 另外一棵树的子树"></a>572 另外一棵树的子树</h2><blockquote><p>leetcode：<a href="https://leetcode-cn.com/problems/subtree-of-another-tree/">572. 另一棵树的子树</a></p></blockquote><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2023/02/202204161700348.png" alt="image-20220416170019257"></p><p>这道题我们要判断<strong>一颗树是否为另外一棵树的子树</strong>，和判断一个字符串是不是另外一个字符串的子串很相似</p><p>其实只需要递归判断每一个节点的左右子树是否和<code>subRoot</code>相同就可以了！</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> _isSameTree(<span class="keyword">struct</span> TreeNode* p, <span class="keyword">struct</span> TreeNode* q)&#123;</span><br><span class="line">    <span class="keyword">if</span>(p==<span class="literal">NULL</span>&amp;&amp;q==<span class="literal">NULL</span>)<span class="comment">//比较是否两个节点都为空，都为空是真</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(p==<span class="literal">NULL</span>||q==<span class="literal">NULL</span>)<span class="comment">//如果有一个为空，另外一个非空，即为假</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(p-&gt;val!=q-&gt;val)<span class="comment">//都不是空，判断val的值是否相等</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//递归判断左子树和右子树是否相等</span></span><br><span class="line">    <span class="keyword">return</span> _isSameTree(p-&gt;left,q-&gt;left)</span><br><span class="line">        &amp;&amp; _isSameTree(p-&gt;right,q-&gt;right);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> <span class="title function_">isSubtree</span><span class="params">(<span class="keyword">struct</span> TreeNode* root, <span class="keyword">struct</span> TreeNode* subRoot)</span>&#123;</span><br><span class="line">    <span class="comment">// if(root==NULL&amp;&amp;subRoot==NULL)</span></span><br><span class="line">    <span class="comment">//     return true;</span></span><br><span class="line">    <span class="comment">// if(root!=NULL&amp;&amp;subRoot==NULL)</span></span><br><span class="line">    <span class="comment">//     return true;</span></span><br><span class="line">    <span class="comment">// 让isSametree函数来比较这俩个</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(root==<span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(_isSameTree(root,subRoot))</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//只要左右有一个是返回真，那就是子树</span></span><br><span class="line">    <span class="keyword">return</span> isSubtree(root-&gt;left,subRoot)</span><br><span class="line">        || isSubtree(root-&gt;right,subRoot);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2023/02/202204161705445.png" alt="image-20220416170549320"></p><p>是不是爽起来了？再来一道！</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2023/02/202204161703532.png" alt="image-20220416170310498"></p><h2 id="102-层序遍历"><a href="#102-层序遍历" class="headerlink" title="102 层序遍历"></a>102 层序遍历</h2><blockquote><p><a href="https://leetcode.cn/problems/binary-tree-level-order-traversal/">https://leetcode.cn/problems/binary-tree-level-order-traversal/</a></p></blockquote><p>这道题在之前的博客中已经讲解过，为了方便后序写层序遍历的类型题目，将层序遍历最基本的代码贴在这里。</p><ul><li>根节点入队列</li><li>队列不为空，开始遍历；</li><li>记录当前队列长度（本层节点数量），出对头节点，将值插入数组，并将该节点的左右子树入队列；</li><li>一层节点遍历完毕后，将这一层的数组插入返回值二维数组中；</li><li>依照以上步骤，直到最后一层（队列为空）；</li></ul><p>代码如下。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">levelOrder</span>(TreeNode* root) &#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; retV;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">nullptr</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> retV;</span><br><span class="line">        &#125;</span><br><span class="line">        queue&lt;TreeNode*&gt; que;</span><br><span class="line">        que.<span class="built_in">push</span>(root);</span><br><span class="line">        <span class="keyword">while</span>(!que.<span class="built_in">empty</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> size = que.<span class="built_in">size</span>();</span><br><span class="line">            vector&lt;<span class="type">int</span>&gt; tempV;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; size;i++)</span><br><span class="line">            &#123;</span><br><span class="line">                TreeNode* front = que.<span class="built_in">front</span>();</span><br><span class="line">                que.<span class="built_in">pop</span>();</span><br><span class="line">                tempV.<span class="built_in">push_back</span>(front-&gt;val);</span><br><span class="line">                <span class="keyword">if</span>(front-&gt;left != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">                    que.<span class="built_in">push</span>(front-&gt;left);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(front-&gt;right != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">                    que.<span class="built_in">push</span>(front-&gt;right);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            retV.<span class="built_in">push_back</span>(tempV); <span class="comment">// 一层结束</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> retV;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="107-层序遍历Ⅱ"><a href="#107-层序遍历Ⅱ" class="headerlink" title="107 层序遍历Ⅱ"></a>107 层序遍历Ⅱ</h2><blockquote><p><a href="https://leetcode.cn/problems/binary-tree-level-order-traversal-ii/">https://leetcode.cn/problems/binary-tree-level-order-traversal-ii/</a></p></blockquote><p>这道题是上一道题的逆置，要求我们从最底层往上返回节点的数组。只需要将上题的返回数组逆置一下就OK了。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">levelOrderBottom</span>(TreeNode* root) &#123;</span><br><span class="line">         vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; retV;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">nullptr</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> retV;</span><br><span class="line">        &#125;</span><br><span class="line">        queue&lt;TreeNode*&gt; que;</span><br><span class="line">        que.<span class="built_in">push</span>(root);</span><br><span class="line">        <span class="keyword">while</span>(!que.<span class="built_in">empty</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> size = que.<span class="built_in">size</span>();</span><br><span class="line">            vector&lt;<span class="type">int</span>&gt; tempV;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; size;i++)</span><br><span class="line">            &#123;</span><br><span class="line">                TreeNode* front = que.<span class="built_in">front</span>();</span><br><span class="line">                que.<span class="built_in">pop</span>();</span><br><span class="line">                tempV.<span class="built_in">push_back</span>(front-&gt;val);</span><br><span class="line">                <span class="keyword">if</span>(front-&gt;left != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">                    que.<span class="built_in">push</span>(front-&gt;left);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(front-&gt;right != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">                    que.<span class="built_in">push</span>(front-&gt;right);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            retV.<span class="built_in">push_back</span>(tempV); <span class="comment">// 一层结束</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 逆置返回值数组即可</span></span><br><span class="line">        <span class="built_in">reverse</span>(retV.<span class="built_in">begin</span>(),retV.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">return</span> retV;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/03/a317dc68b0b4f9b98f31859e359165b2.png" alt="image.png"></p><h2 id="199-二叉树的右视图"><a href="#199-二叉树的右视图" class="headerlink" title="199 二叉树的右视图"></a>199 二叉树的右视图</h2><blockquote><p><a href="https://leetcode.cn/problems/binary-tree-right-side-view/description/">https://leetcode.cn/problems/binary-tree-right-side-view/description/</a></p></blockquote><p>题目要求我们假设自己是从右侧观察一颗二叉树，返回能从右侧观察到的节点。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">    5</span><br><span class="line">  4   6</span><br><span class="line">1   2</span><br></pre></td></tr></table></figure><p>比如这棵树，从右侧可以观察到的节点是<code>[5,6,2]</code>，题目要求返回的就是这个节点组成的数组。</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/03/b0c2e5474f671f282fac457fe734ef2c.png" alt="image.png"></p><p>思路还是层序遍历，这一次不需要把每个节点都入数组了，只需要遍历到<strong>每个层的末尾</strong>（循环到<code>size-1</code>的位置），将这个节点插入数组就行了。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">rightSideView</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; retV;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">nullptr</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> retV;</span><br><span class="line">        &#125;</span><br><span class="line">        queue&lt;TreeNode*&gt; que;</span><br><span class="line">        que.<span class="built_in">push</span>(root);</span><br><span class="line">        <span class="keyword">while</span>(!que.<span class="built_in">empty</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> size = que.<span class="built_in">size</span>();</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; size;i++)</span><br><span class="line">            &#123;</span><br><span class="line">                TreeNode* front = que.<span class="built_in">front</span>();</span><br><span class="line">                que.<span class="built_in">pop</span>();</span><br><span class="line">                <span class="comment">// 每一层的末尾才插入数组</span></span><br><span class="line">                <span class="keyword">if</span>(i == size<span class="number">-1</span>)&#123;</span><br><span class="line">                    retV.<span class="built_in">push_back</span>(front-&gt;val);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span>(front-&gt;left != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">                    que.<span class="built_in">push</span>(front-&gt;left);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(front-&gt;right != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">                    que.<span class="built_in">push</span>(front-&gt;right);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> retV;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/03/85b671427128bdd9adc04f79909a630b.png" alt="image.png"></p><h2 id="637-二叉树的层平均值"><a href="#637-二叉树的层平均值" class="headerlink" title="637 二叉树的层平均值"></a>637 二叉树的层平均值</h2><blockquote><p><a href="https://leetcode.cn/problems/average-of-levels-in-binary-tree/description/">https://leetcode.cn/problems/average-of-levels-in-binary-tree/description/</a></p></blockquote><p>给定一个非空二叉树的根节点 root , 以数组的形式返回每一层节点的平均值。与实际答案相差 <code>10^(-5)</code> 以内的答案可以被接受。</p><p>这道题简单，把每一层的节点都加起来，然后除以节点数量求平均就可以了。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">double</span>&gt; <span class="title">averageOfLevels</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="type">double</span>&gt; retV;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">nullptr</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> retV;</span><br><span class="line">        &#125;</span><br><span class="line">        queue&lt;TreeNode*&gt; que;</span><br><span class="line">        que.<span class="built_in">push</span>(root);</span><br><span class="line">        <span class="keyword">while</span>(!que.<span class="built_in">empty</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> size = que.<span class="built_in">size</span>();</span><br><span class="line">            <span class="type">double</span> sum = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; size;i++)</span><br><span class="line">            &#123;</span><br><span class="line">                TreeNode* front = que.<span class="built_in">front</span>();</span><br><span class="line">                que.<span class="built_in">pop</span>();</span><br><span class="line">                <span class="comment">// 求和</span></span><br><span class="line">                sum += front-&gt;val;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span>(front-&gt;left != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">                    que.<span class="built_in">push</span>(front-&gt;left);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(front-&gt;right != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">                    que.<span class="built_in">push</span>(front-&gt;right);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 一层结束。计算平均</span></span><br><span class="line">            retV.<span class="built_in">push_back</span>(sum/<span class="built_in">static_cast</span>&lt;<span class="type">double</span>&gt;(size*<span class="number">1.0</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> retV;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/03/67b4d7b9120a9184555c39f76908034f.png" alt="image.png"></p><h2 id="226-翻转二叉树"><a href="#226-翻转二叉树" class="headerlink" title="226 翻转二叉树"></a>226 翻转二叉树</h2><blockquote><p>leetcode：<a href="https://leetcode-cn.com/problems/invert-binary-tree/">226. 翻转二叉树</a></p></blockquote><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2023/02/202204161703706.png" alt="image-20220416170322647"></p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>这道题的思路如下哈！</p><ul><li>如果是空树，不需要翻转，直接return；</li><li>如果非空，就把该节点的左右子树交换（这里不需要担心交换后找不到子树的问题，因为并没有把子树删除或者丢掉）</li><li>不需要单独判断空的子树，一并交换就可以；</li><li>当根节点为空的时候，return；</li></ul><h3 id="前序遍历实现"><a href="#前序遍历实现" class="headerlink" title="前序遍历实现"></a>前序遍历实现</h3><p>啪的一下很快哈，代码就写出来了！</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> _invertTree(<span class="keyword">struct</span> TreeNode* root)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(root==<span class="literal">NULL</span>)<span class="comment">//设置退出条件，如果根节点为空就返回</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//让另外两个值来接收原本的左右节点</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span>* <span class="title">left</span>=</span>root-&gt;left;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span>* <span class="title">right</span>=</span>root-&gt;right;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//更改左右节点</span></span><br><span class="line">    root-&gt;right=left;</span><br><span class="line">    root-&gt;left=right;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//递归子树</span></span><br><span class="line">    _invertTree(root-&gt;left);</span><br><span class="line">    _invertTree(root-&gt;right);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> TreeNode* <span class="title function_">invertTree</span><span class="params">(<span class="keyword">struct</span> TreeNode* root)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root==<span class="literal">NULL</span>)<span class="comment">//判断空树</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    _invertTree(root);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2023/02/202204161705971.png" alt="image-20220416170530844"></p><p>使用迭代（循环）的方式进行前序遍历，也可以完成本题</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">invertTree</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">        stack&lt;TreeNode*&gt; st;</span><br><span class="line">        st.<span class="built_in">push</span>(root);</span><br><span class="line">        <span class="keyword">while</span>(!st.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            TreeNode* node = st.<span class="built_in">top</span>();              <span class="comment">// 中</span></span><br><span class="line">            st.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="built_in">swap</span>(node-&gt;left, node-&gt;right); <span class="comment">// 交换</span></span><br><span class="line">            <span class="keyword">if</span>(node-&gt;right) st.<span class="built_in">push</span>(node-&gt;right);   <span class="comment">// 右</span></span><br><span class="line">            <span class="keyword">if</span>(node-&gt;left) st.<span class="built_in">push</span>(node-&gt;left);     <span class="comment">// 左</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="层序遍历实现"><a href="#层序遍历实现" class="headerlink" title="层序遍历实现"></a>层序遍历实现</h3><p>使用层序遍历，思路还是一样的，层序遍历在出队列头部节点的时候，会将左右子树插入队列。只需要在插入之前，将队列头部节点的左右子树指针交换位置，即可。</p><p>注意：不能通过交换左右子树入队列的顺序实现，这样虽然遍历下一层的顺序改变了，但是上一层的节点左右子树的指针并没有被交换，还是原来的顺序，不符合题目要求。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">invertTree</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">nullptr</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        &#125;</span><br><span class="line">        queue&lt;TreeNode*&gt; que;</span><br><span class="line">        que.<span class="built_in">push</span>(root);</span><br><span class="line">        <span class="keyword">while</span>(!que.<span class="built_in">empty</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            TreeNode* front = que.<span class="built_in">front</span>();</span><br><span class="line">            que.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="built_in">swap</span>(front-&gt;left,front-&gt;right);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 虽然这里可以不用写不等于空，但是写上可读性更好。</span></span><br><span class="line">            <span class="keyword">if</span>(front-&gt;left != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">                que.<span class="built_in">push</span>(front-&gt;left);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(front-&gt;right != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">                que.<span class="built_in">push</span>(front-&gt;right);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="429-N叉树层序遍历"><a href="#429-N叉树层序遍历" class="headerlink" title="429 N叉树层序遍历"></a>429 N叉树层序遍历</h2><blockquote><p><a href="https://leetcode.cn/problems/n-ary-tree-level-order-traversal/">https://leetcode.cn/problems/n-ary-tree-level-order-traversal/</a></p></blockquote><p>基于二叉树层序遍历的代码，修改一下就是多叉树了。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">// Definition for a Node.</span></span><br><span class="line"><span class="comment">class Node &#123;</span></span><br><span class="line"><span class="comment">public:</span></span><br><span class="line"><span class="comment">    int val;</span></span><br><span class="line"><span class="comment">    vector&lt;Node*&gt; children;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    Node() &#123;&#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    Node(int _val) &#123;</span></span><br><span class="line"><span class="comment">        val = _val;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    Node(int _val, vector&lt;Node*&gt; _children) &#123;</span></span><br><span class="line"><span class="comment">        val = _val;</span></span><br><span class="line"><span class="comment">        children = _children;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">levelOrder</span>(Node* root) &#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; retV;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">nullptr</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> retV;</span><br><span class="line">        &#125;</span><br><span class="line">        queue&lt;Node*&gt; que;</span><br><span class="line">        que.<span class="built_in">push</span>(root);</span><br><span class="line">        <span class="keyword">while</span>(!que.<span class="built_in">empty</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> size = que.<span class="built_in">size</span>();</span><br><span class="line">            vector&lt;<span class="type">int</span>&gt; tempV;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; size ; j++)&#123;</span><br><span class="line">                Node* temp = que.<span class="built_in">front</span>();</span><br><span class="line">                que.<span class="built_in">pop</span>();</span><br><span class="line">                tempV.<span class="built_in">push_back</span>(temp-&gt;val);</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> i =<span class="number">0</span>;i&lt;temp-&gt;children.<span class="built_in">size</span>();i++)</span><br><span class="line">                &#123;</span><br><span class="line">                    que.<span class="built_in">push</span>(temp-&gt;children[i]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            retV.<span class="built_in">push_back</span>(tempV);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> retV;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/03/d5a314057186dc0fc8880444838d2381.png" alt="image.png"></p><h2 id="515-在每层中找最大值"><a href="#515-在每层中找最大值" class="headerlink" title="515 在每层中找最大值"></a>515 在每层中找最大值</h2><blockquote><p><a href="https://leetcode.cn/problems/find-largest-value-in-each-tree-row/">https://leetcode.cn/problems/find-largest-value-in-each-tree-row/</a></p></blockquote><p>还是层序遍历思路的题目，遍历一层的时候维护一个最大值就可以了。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">largestValues</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; retV;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">nullptr</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> retV;</span><br><span class="line">        &#125;</span><br><span class="line">        queue&lt;TreeNode*&gt; que;</span><br><span class="line">        que.<span class="built_in">push</span>(root);</span><br><span class="line">        <span class="keyword">while</span>(!que.<span class="built_in">empty</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> size = que.<span class="built_in">size</span>();</span><br><span class="line">            <span class="type">int</span> maxNum = INT32_MIN;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i =<span class="number">0</span>;i&lt; size;i++)</span><br><span class="line">            &#123;</span><br><span class="line">                TreeNode* temp = que.<span class="built_in">front</span>();</span><br><span class="line">                que.<span class="built_in">pop</span>();</span><br><span class="line">                maxNum = <span class="built_in">max</span>(maxNum,temp-&gt;val);</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">if</span>(temp-&gt;left != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">                    que.<span class="built_in">push</span>(temp-&gt;left);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(temp-&gt;right != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">                    que.<span class="built_in">push</span>(temp-&gt;right);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            retV.<span class="built_in">push_back</span>(maxNum);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> retV;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/03/42ebd64adefee9120536bd6968a50561.png" alt="image.png"></p><h2 id="116-填充每个节点的下一个右侧节点指针"><a href="#116-填充每个节点的下一个右侧节点指针" class="headerlink" title="116 填充每个节点的下一个右侧节点指针"></a>116 填充每个节点的下一个右侧节点指针</h2><blockquote><p><a href="https://leetcode.cn/problems/populating-next-right-pointers-in-each-node/description/">https://leetcode.cn/problems/populating-next-right-pointers-in-each-node/description/</a></p></blockquote><p>给定一个 完美二叉树 ，其所有叶子节点都在同一层，每个父节点都有两个子节点。二叉树定义如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">  <span class="type">int</span> val;</span><br><span class="line">  Node *left;</span><br><span class="line">  Node *right;</span><br><span class="line">  Node *next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>填充它的每个 next 指针，让这个指针指向其下一个右侧节点。如果找不到下一个右侧节点，则将 next 指针设置为 NULL。</p><p>初始状态下，所有 next 指针都被设置为 NULL。</p><hr><p>还是层序遍历的思路，遍历每一层的时候，将<strong>前一个节点的right</strong>设置为当前节点。</p><p>因为题目提到了node节点的next指针<strong>初始化都为nullptr</strong>，所以不需要我们手动操作每层最后一个节点的nullptr。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">Node* <span class="title">connect</span><span class="params">(Node* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">nullptr</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        &#125;</span><br><span class="line">        queue&lt;Node*&gt; que;</span><br><span class="line">        que.<span class="built_in">push</span>(root);</span><br><span class="line">        <span class="keyword">while</span>(!que.<span class="built_in">empty</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> size = que.<span class="built_in">size</span>();</span><br><span class="line">            Node* prevNode = <span class="literal">nullptr</span>;</span><br><span class="line">            Node* node = <span class="literal">nullptr</span>; <span class="comment">// 始终指向当前节点</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i =<span class="number">0</span>; i&lt; size;i++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// 每层第一个节点，设置前一个节点的值</span></span><br><span class="line">                <span class="keyword">if</span>(i == <span class="number">0</span>)&#123;</span><br><span class="line">                    prevNode = que.<span class="built_in">front</span>(); <span class="comment">// 前一个节点</span></span><br><span class="line">                    que.<span class="built_in">pop</span>();</span><br><span class="line">                    node = prevNode; <span class="comment">// 当前节点</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="comment">// 非第一个</span></span><br><span class="line">                &#123;</span><br><span class="line">                    node = que.<span class="built_in">front</span>(); <span class="comment">// 当前节点</span></span><br><span class="line">                    que.<span class="built_in">pop</span>();</span><br><span class="line">                    prevNode-&gt;next = node;</span><br><span class="line">                    prevNode = prevNode-&gt;next; <span class="comment">// 更新前一个节点为当前节点</span></span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 插入后续节点</span></span><br><span class="line">                <span class="keyword">if</span>(node-&gt;left != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">                    que.<span class="built_in">push</span>(node-&gt;left);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(node-&gt;right != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">                    que.<span class="built_in">push</span>(node-&gt;right);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/03/9316e276ec127d1e7ee096367a4c6e51.png" alt="image.png"></p><h2 id="117-填充每个节点的下一个右侧节点指针Ⅱ"><a href="#117-填充每个节点的下一个右侧节点指针Ⅱ" class="headerlink" title="117 填充每个节点的下一个右侧节点指针Ⅱ"></a>117 填充每个节点的下一个右侧节点指针Ⅱ</h2><blockquote><p><a href="https://leetcode.cn/problems/populating-next-right-pointers-in-each-node-ii/description/">https://leetcode.cn/problems/populating-next-right-pointers-in-each-node-ii/description/</a></p></blockquote><p>上题说的是完全二叉树，这道题是普通二叉树。不过我们写的层序遍历代码本来就是通用的，所以直接复制代码过来就行了，什么都不需要改。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">Node* <span class="title">connect</span><span class="params">(Node* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">nullptr</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        &#125;</span><br><span class="line">        queue&lt;Node*&gt; que;</span><br><span class="line">        que.<span class="built_in">push</span>(root);</span><br><span class="line">        <span class="keyword">while</span>(!que.<span class="built_in">empty</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> size = que.<span class="built_in">size</span>();</span><br><span class="line">            Node* prevNode = <span class="literal">nullptr</span>;</span><br><span class="line">            Node* node = <span class="literal">nullptr</span>; <span class="comment">// 始终指向当前节点</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i =<span class="number">0</span>; i&lt; size;i++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// 每层第一个节点，设置前一个节点的值</span></span><br><span class="line">                <span class="keyword">if</span>(i == <span class="number">0</span>)&#123;</span><br><span class="line">                    prevNode = que.<span class="built_in">front</span>(); <span class="comment">// 前一个节点</span></span><br><span class="line">                    que.<span class="built_in">pop</span>();</span><br><span class="line">                    node = prevNode; <span class="comment">// 当前节点</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="comment">// 非第一个</span></span><br><span class="line">                &#123;</span><br><span class="line">                    node = que.<span class="built_in">front</span>(); <span class="comment">// 当前节点</span></span><br><span class="line">                    que.<span class="built_in">pop</span>();</span><br><span class="line">                    prevNode-&gt;next = node;</span><br><span class="line">                    prevNode = prevNode-&gt;next; <span class="comment">// 更新前一个节点为当前节点</span></span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 插入后续节点</span></span><br><span class="line">                <span class="keyword">if</span>(node-&gt;left != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">                    que.<span class="built_in">push</span>(node-&gt;left);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(node-&gt;right != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">                    que.<span class="built_in">push</span>(node-&gt;right);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/03/0ea9cb0afb401d955754c2f85a50c9f1.png" alt="image.png"></p><h2 id="104-二叉树最大深度"><a href="#104-二叉树最大深度" class="headerlink" title="104 二叉树最大深度"></a>104 二叉树最大深度</h2><blockquote><p><a href="https://leetcode.cn/problems/maximum-depth-of-binary-tree/description/">https://leetcode.cn/problems/maximum-depth-of-binary-tree/description/</a></p></blockquote><p>这道题在链式二叉树的博客中讲解过递归版本。注意二叉树深度的定义：二叉树的 <strong>最大深度</strong> 是指从根节点到最远<strong>叶子节点</strong>的<strong>最长路径</strong>上的节点数。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 二叉树深度，即一共有几层</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">BTreeDepth</span><span class="params">(BTNode* root)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (root == <span class="literal">NULL</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 递归遍历左右子树</span></span><br><span class="line"><span class="type">int</span> left = <span class="built_in">BTreeDepth</span>(root-&gt;left);</span><br><span class="line"><span class="type">int</span> right = <span class="built_in">BTreeDepth</span>(root-&gt;right);</span><br><span class="line"><span class="comment">// 返回左右子树层数高的那一个，加一代表当前层，因为空指针是0</span></span><br><span class="line"><span class="keyword">return</span> left &gt; right ? left + <span class="number">1</span> : right + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用层序遍历也能解决这个问题，遍历到每一层都让深度计数器加一就行了。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxDepth</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> retDepth = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">nullptr</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> retDepth;</span><br><span class="line">        &#125;</span><br><span class="line">        queue&lt;TreeNode*&gt; que;</span><br><span class="line">        que.<span class="built_in">push</span>(root);</span><br><span class="line">        <span class="keyword">while</span>(!que.<span class="built_in">empty</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> size = que.<span class="built_in">size</span>();</span><br><span class="line">            retDepth++; <span class="comment">// 层数加一</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i =<span class="number">0</span>;i&lt; size;i++)</span><br><span class="line">            &#123;</span><br><span class="line">                TreeNode* temp = que.<span class="built_in">front</span>();</span><br><span class="line">                que.<span class="built_in">pop</span>();</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">if</span>(temp-&gt;left != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">                    que.<span class="built_in">push</span>(temp-&gt;left);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(temp-&gt;right != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">                    que.<span class="built_in">push</span>(temp-&gt;right);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> retDepth;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/03/9db4df1d7c69a02f1e809f2fac733fb8.png" alt="image.png"></p><p>下面是代码随想录上的递归思路。使用“回溯”的思想，将每一层的depth送给下一层，然后在每一层开始的时候判断当前深度是否大于存放的深度，并进行更新。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> result;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">getdepth</span><span class="params">(TreeNode* node, <span class="type">int</span> depth)</span> </span>&#123;</span><br><span class="line">        result = depth &gt; result ? depth : result; <span class="comment">// 中</span></span><br><span class="line">        <span class="keyword">if</span> (node-&gt;left == <span class="literal">NULL</span> &amp;&amp; node-&gt;right == <span class="literal">NULL</span>) <span class="keyword">return</span> ;</span><br><span class="line">        <span class="keyword">if</span> (node-&gt;left) &#123; <span class="comment">// 左</span></span><br><span class="line">            <span class="built_in">getdepth</span>(node-&gt;left, depth + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (node-&gt;right) &#123; <span class="comment">// 右</span></span><br><span class="line">            <span class="built_in">getdepth</span>(node-&gt;right, depth + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxDepth</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        result = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="number">0</span>) <span class="keyword">return</span> result;</span><br><span class="line">        <span class="built_in">getdepth</span>(root, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="114-二叉树的最小深度"><a href="#114-二叉树的最小深度" class="headerlink" title="114 二叉树的最小深度"></a>114 二叉树的最小深度</h2><blockquote><p> <a href="https://leetcode.cn/problems/minimum-depth-of-binary-tree/description/">https://leetcode.cn/problems/minimum-depth-of-binary-tree/description/</a></p></blockquote><p>二叉树的最小深度：最小深度是从根节点到最近叶子节点的最短路径上的节点数量。</p><p>以下面的二叉树为例，它的最小深度是从1到节点3，因为3才是第一个叶子节点，而1并不是叶子节点（没有左右子树的节点才是叶子节点）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1</span><br><span class="line">   2</span><br><span class="line">  3  4</span><br><span class="line">   5</span><br></pre></td></tr></table></figure><p>代码如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">minDepth</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> retDepth = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">nullptr</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> retDepth;</span><br><span class="line">        &#125;</span><br><span class="line">        queue&lt;TreeNode*&gt; que;</span><br><span class="line">        que.<span class="built_in">push</span>(root);</span><br><span class="line">        <span class="keyword">while</span>(!que.<span class="built_in">empty</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> size = que.<span class="built_in">size</span>();</span><br><span class="line">            retDepth++; <span class="comment">// 层数加一</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i =<span class="number">0</span>;i&lt; size;i++)</span><br><span class="line">            &#123;</span><br><span class="line">                TreeNode* temp = que.<span class="built_in">front</span>();</span><br><span class="line">                que.<span class="built_in">pop</span>();</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">if</span>(temp-&gt;left != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">                    que.<span class="built_in">push</span>(temp-&gt;left);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(temp-&gt;right != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">                    que.<span class="built_in">push</span>(temp-&gt;right);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 遇到叶子节点，说明就是最小深度，直接返回</span></span><br><span class="line">                <span class="keyword">if</span>(temp-&gt;left == <span class="literal">nullptr</span> &amp;&amp; temp-&gt;right == <span class="literal">nullptr</span>)&#123;</span><br><span class="line">                    <span class="keyword">return</span> retDepth;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> retDepth;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/03/fdeee76497ce1ee5fce7622e2d5c839b.png" alt="image.png"></p><p>如果使用递归的方式，代码如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getDepth</span><span class="params">(TreeNode* node)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> leftDepth = <span class="built_in">getDepth</span>(node-&gt;left);           <span class="comment">// 左</span></span><br><span class="line">        <span class="type">int</span> rightDepth = <span class="built_in">getDepth</span>(node-&gt;right);         <span class="comment">// 右</span></span><br><span class="line">                                                        <span class="comment">// 中</span></span><br><span class="line">        <span class="comment">// 当一个左子树为空，右不为空，这时并不是最低点</span></span><br><span class="line">        <span class="keyword">if</span> (node-&gt;left == <span class="literal">NULL</span> &amp;&amp; node-&gt;right != <span class="literal">NULL</span>) &#123; </span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span> + rightDepth;</span><br><span class="line">        &#125;   </span><br><span class="line">        <span class="comment">// 当一个右子树为空，左不为空，这时并不是最低点</span></span><br><span class="line">        <span class="keyword">if</span> (node-&gt;left != <span class="literal">NULL</span> &amp;&amp; node-&gt;right == <span class="literal">NULL</span>) &#123; </span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span> + leftDepth;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 此时是叶子节点，返回当前的最小高度（即深度）</span></span><br><span class="line">        <span class="type">int</span> result = <span class="number">1</span> + <span class="built_in">min</span>(leftDepth, rightDepth);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">minDepth</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">getDepth</span>(root);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="222-完全二叉树的节点数量"><a href="#222-完全二叉树的节点数量" class="headerlink" title="222 完全二叉树的节点数量"></a>222 完全二叉树的节点数量</h2><blockquote><p><a href="https://leetcode.cn/problems/count-complete-tree-nodes/description/">https://leetcode.cn/problems/count-complete-tree-nodes/description/</a></p></blockquote><p>给你一棵 <strong>完全二叉树</strong> 的根节点 <code>root</code> ，求出该树的节点个数。</p><p><a href="https://baike.baidu.com/item/%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%A0%91/7773232?fr=aladdin">完全二叉树</a> 的定义如下：在完全二叉树中，除了最底层节点可能没填满外，其余每层节点数都达到最大值，并且最下面一层的节点都集中在该层最左边的若干位置。若最底层为第 <code>h</code> 层，则该层包含 <code>1 ~ (2^h)</code> 个节点。</p><hr><p>先按普通二叉树来计算节点的数量，使用层序遍历的思路</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">countNodes</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">nullptr</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        queue&lt;TreeNode*&gt; que;</span><br><span class="line">        que.<span class="built_in">push</span>(root);</span><br><span class="line">        <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(!que.<span class="built_in">empty</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> size = que.<span class="built_in">size</span>();</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i =<span class="number">0</span>;i&lt;size;i++)</span><br><span class="line">            &#123;</span><br><span class="line">                TreeNode* front = que.<span class="built_in">front</span>();</span><br><span class="line">                que.<span class="built_in">pop</span>();</span><br><span class="line">                count++; </span><br><span class="line">                <span class="keyword">if</span>(front-&gt;left != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">                    que.<span class="built_in">push</span>(front-&gt;left);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(front-&gt;right != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">                    que.<span class="built_in">push</span>(front-&gt;right);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>使用递归遍历也能计算节点数量</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> _countNodes(TreeNode* root)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">nullptr</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> left = _countNodes(root-&gt;left);</span><br><span class="line">        <span class="type">int</span> right = _countNodes(root-&gt;right);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span> + left + right;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">countNodes</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> _countNodes(root);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/03/23e323a933739d577ae14b06b12ebb8a.png" alt="image-20240316092433289"></p><hr><p>但是上面这两个思路都是对任何二叉树都适用的，但本题直接说明了是<strong>完全二叉树</strong>。如果用通用的思路来解题，在面试的时候可能会扣分。我们需要用上完全二叉树的特性。</p><p>首先要知道<strong>满二叉树</strong>的节点数量为<code>2^k - 1</code>，k是二叉树的层数。在完全二叉树中，会有多个满二叉树。所以可以将思路转变为，正常计算非满二叉树的节点数量，但如果是满二叉树，获取层数后直接用公式计算节点数量，再二者相加。</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/03/9949b47e3423bf14897b688add450847.png" alt="image-20240316093135112"></p><p>计算满二叉树的层数比较简单，只需要从根节点往左侧、往右侧遍历，计算两侧的节点数量。最后对比左侧右侧节点数量，不同则不是满二叉树。</p><blockquote><p>因为题目已经说明了这棵树是<strong>完全二叉树</strong>，所以<strong>不会出现</strong>下面这种两侧节点数量一致，但中间缺少节点不符合完全二叉树&#x2F;满二叉树条件的情况。</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/03/449114798f3824b2d21fe98eae39ea67.png" alt="image-20240316093752286"></p></blockquote><p>C++代码如下，来自代码随想录。这里层数被初始化为0，这样在后续使用<code>(2 &lt;&lt; leftDepth)</code>的时候，其实就相当于计算2的<code>leftDepth+1</code>次方。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">countNodes</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 开始根据左深度和右深度是否相同来判断该子树是不是满二叉树</span></span><br><span class="line">        TreeNode* left = root-&gt;left;</span><br><span class="line">        TreeNode* right = root-&gt;right;</span><br><span class="line">        <span class="type">int</span> leftDepth = <span class="number">0</span>, rightDepth = <span class="number">0</span>; <span class="comment">// 这里初始为0是有目的的，为了下面求指数方便</span></span><br><span class="line">        <span class="keyword">while</span> (left) &#123;  <span class="comment">// 求左子树深度</span></span><br><span class="line">            left = left-&gt;left;</span><br><span class="line">            leftDepth++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (right) &#123; <span class="comment">// 求右子树深度</span></span><br><span class="line">            right = right-&gt;right;</span><br><span class="line">            rightDepth++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (leftDepth == rightDepth) &#123;</span><br><span class="line">            <span class="keyword">return</span> (<span class="number">2</span> &lt;&lt; leftDepth) - <span class="number">1</span>; <span class="comment">// 注意(2&lt;&lt;1) 相当于2^2，返回满足满二叉树的子树节点数量</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 后序遍历</span></span><br><span class="line">        <span class="type">int</span> leftTreeNum = <span class="built_in">countNodes</span>(root-&gt;left);       <span class="comment">// 左</span></span><br><span class="line">        <span class="type">int</span> rightTreeNum = <span class="built_in">countNodes</span>(root-&gt;right);     <span class="comment">// 右</span></span><br><span class="line">        <span class="type">int</span> result = leftTreeNum + rightTreeNum + <span class="number">1</span>;    <span class="comment">// 中</span></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="110-平衡二叉树"><a href="#110-平衡二叉树" class="headerlink" title="110 平衡二叉树"></a>110 平衡二叉树</h2><blockquote><p><a href="https://leetcode.cn/problems/balanced-binary-tree/">https://leetcode.cn/problems/balanced-binary-tree/</a></p></blockquote><p>这里涉及到高阶数据结构中平衡二叉树的概念，如果你没有了解过，可以移步<a href="https://blog.musnow.top/posts/1396203902">这篇博客</a>；</p><p>简而言之，<strong>平衡二叉树是节点的左右子树高度相差不超过1的树</strong>。这样能保证树的左右两侧节点层数基本一致，方便实现搜索二叉树。</p><p>对于本题而言，我们可以将思路改为计算每个节点左右两侧的树的高度。当高度相差超过1的时候，直接返回错误。这里可以用int来作为递归函数的返回值，用<code>-1</code>代表不符合平衡二叉树的条件。</p><p>题目给出树的节点数量 <code>[0, 5000]</code> ，最大的层数也就5000，用int是足够存放的。</p><p>C++代码如下，使用后序遍历的思想来递归处理。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> _isBalanced(TreeNode* root)&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">nullptr</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 使用后续遍历，如果有一个不符合预期就提前返回</span></span><br><span class="line">        <span class="type">int</span> left = _isBalanced(root-&gt;left);</span><br><span class="line">        <span class="keyword">if</span>(left == <span class="number">-1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> right = _isBalanced(root-&gt;right);</span><br><span class="line">        <span class="keyword">if</span>(right == <span class="number">-1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 都不是负一，计算节点高度插值</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">abs</span>(right -left)&gt;<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;<span class="comment">// 超过1了不符合</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span> + <span class="built_in">max</span>(right,left); <span class="comment">// 返回高的那一个作为当前树的高度</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isBalanced</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> _isBalanced(root) == <span class="number">-1</span> ? <span class="literal">false</span> : <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/03/f2d8a5287cd80e7f2aa5099de585d651.png" alt="image-20240316095740190"></p><h2 id="257-二叉树的所有路径"><a href="#257-二叉树的所有路径" class="headerlink" title="257 二叉树的所有路径"></a>257 二叉树的所有路径</h2><blockquote><p><a href="https://leetcode.cn/problems/binary-tree-paths/">https://leetcode.cn/problems/binary-tree-paths/</a></p></blockquote><p>思路是使用前序遍历，将当前节点的值转为字符串插入到数组中，并插入一个<code>-&gt;</code>字符串；递归的末尾条件分两个</p><ul><li>叶子节点，将当前节点的值插入，不需要额外插入<code>-&gt;</code>字符串；</li><li>空节点，直接返回</li></ul><p>递归函数的传参如下，其中string变量不能传引用，因为这样的话，下一层的修改就会影响上层，上层还需要做删除下一层的元素的操作，很麻烦。<code>vector&lt;string&gt;&amp; retV</code>变量需要传引用，因为它包含了所有路径字符串，作为返回值。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">binaryTreePaths</span><span class="params">(TreeNode* root,string curStr,vector&lt;string&gt;&amp; retV)</span></span></span><br></pre></td></tr></table></figure><hr><p>下面的代码中有一个错误的思路，如果遇到空节点就将字符串插入到数组，对于有一个子树的非叶子节点（此时它的左侧或者右侧是空的），就会多插入一个无效的路径，因为此时这个节点并非叶子节点。</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/03/25aa7223e84bc8baeb4dc74da7e3b5ca.png" alt="image-20240316101831139"></p><p>正确的处理办法是到叶子节点了再插入数组，遇到空节点直接返回，不需要做任何处理。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 字符串不能传引用，不然下层的更改会影响上层</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">binaryTreePaths</span><span class="params">(TreeNode* root,string curStr,vector&lt;string&gt;&amp; retV)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// // 到空节点了就插入到数组中</span></span><br><span class="line">        <span class="comment">// if(root == nullptr)&#123;</span></span><br><span class="line">        <span class="comment">//     // 删除多余的-&gt;</span></span><br><span class="line">        <span class="comment">//     retV.push_back(curStr.substr(0,curStr.size()-2));</span></span><br><span class="line">        <span class="comment">//     return;</span></span><br><span class="line">        <span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 上面的思路错误，如果某个节点有左子树或右子树，此时就会多插入一个无效的路径</span></span><br><span class="line">        <span class="comment">// 正确思路是空节点不处理</span></span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">nullptr</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 到叶子节点了就直接插入到数组中</span></span><br><span class="line">        <span class="keyword">if</span>(root-&gt;left == <span class="literal">nullptr</span> &amp;&amp; root-&gt;right == <span class="literal">nullptr</span>)&#123;</span><br><span class="line">            curStr +=  <span class="built_in">to_string</span>(root-&gt;val);</span><br><span class="line">            retV.<span class="built_in">push_back</span>(curStr); <span class="comment">// 不需要删除多余的-&gt;</span></span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 前序遍历</span></span><br><span class="line">        curStr += <span class="built_in">to_string</span>(root-&gt;val);</span><br><span class="line">        curStr += <span class="string">&quot;-&gt;&quot;</span>;</span><br><span class="line">        <span class="built_in">binaryTreePaths</span>(root-&gt;left,curStr,retV);</span><br><span class="line">        <span class="built_in">binaryTreePaths</span>(root-&gt;right,curStr,retV);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function">vector&lt;string&gt; <span class="title">binaryTreePaths</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        vector&lt;string&gt; retV;</span><br><span class="line">        <span class="built_in">binaryTreePaths</span>(root,<span class="string">&quot;&quot;</span>,retV);</span><br><span class="line">        <span class="keyword">return</span> retV;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/03/f1c77d652f76b84075ebb60c656bc98c.png" alt="image-20240316102109684"></p><p>也可以使用迭代法，就是利用<strong>前序遍历的迭代思路</strong>将代码从递归改成迭代。</p><p>这里需要用到第二个栈，一个栈用来存放遍历的节点，另外一个栈用来存放当前遍历到的节点的上一层的字符串。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;string&gt; <span class="title">binaryTreePaths</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        vector&lt;string&gt; retV;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">nullptr</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> retV;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        stack&lt;TreeNode*&gt; stNode; <span class="comment">// 存放节点</span></span><br><span class="line">        stack&lt;string&gt; stStr; <span class="comment">// 存放上一层的字符串</span></span><br><span class="line">        stNode.<span class="built_in">push</span>(root);</span><br><span class="line">        <span class="comment">// stStr.push(to_string(root-&gt;val));</span></span><br><span class="line">        stStr.<span class="built_in">push</span>(<span class="string">&quot;&quot;</span>); <span class="comment">// 这里一定要插入空字符串而不是根节点的值</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(!stNode.<span class="built_in">empty</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 前序遍历</span></span><br><span class="line">            TreeNode* curNode = stNode.<span class="built_in">top</span>(); <span class="comment">// 中</span></span><br><span class="line">            <span class="comment">// cout &lt;&lt; curNode-&gt;val &lt;&lt; endl;</span></span><br><span class="line">            stNode.<span class="built_in">pop</span>();</span><br><span class="line">            string curStr = stStr.<span class="built_in">top</span>();</span><br><span class="line">            stStr.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="comment">// 遇到叶子节点，插入值然后返回</span></span><br><span class="line">            <span class="keyword">if</span>(curNode-&gt;left == <span class="literal">nullptr</span> &amp;&amp; curNode-&gt;right == <span class="literal">nullptr</span>)&#123;</span><br><span class="line">                <span class="comment">// curStr += &quot;-&gt;&quot;;</span></span><br><span class="line">                curStr += <span class="built_in">to_string</span>(curNode-&gt;val);</span><br><span class="line">                retV.<span class="built_in">push_back</span>(curStr);</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 左</span></span><br><span class="line">            <span class="keyword">if</span>(curNode-&gt;left != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">                stNode.<span class="built_in">push</span>(curNode-&gt;left);</span><br><span class="line">                stStr.<span class="built_in">push</span>(curStr  + <span class="built_in">to_string</span>(curNode-&gt;val)+ <span class="string">&quot;-&gt;&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 右</span></span><br><span class="line">            <span class="keyword">if</span>(curNode-&gt;right != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">                stNode.<span class="built_in">push</span>(curNode-&gt;right);</span><br><span class="line">                stStr.<span class="built_in">push</span>(curStr  + <span class="built_in">to_string</span>(curNode-&gt;val)+ <span class="string">&quot;-&gt;&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> retV;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/03/00bec4e34eef1c6765743903454e323b.png" alt="image-20240316104632107"></p><h2 id="404-左叶子之和"><a href="#404-左叶子之和" class="headerlink" title="404 左叶子之和"></a>404 左叶子之和</h2><blockquote><p><a href="https://leetcode.cn/problems/sum-of-left-leaves/description/">https://leetcode.cn/problems/sum-of-left-leaves/description/</a></p></blockquote><p>给定二叉树的根节点 <code>root</code> ，返回所有左叶子之和。</p><p>这道题我本来的思路是使用层序遍历，除去根节点外，<strong>每一层的第一个就是左叶子的可能节点</strong>。注意是可能，还需要判断这个节点到底是不是叶子节点。如果是就将其加入sum中。</p><p>但是这个思路是<strong>错的</strong>，因为每一层不一定有左侧叶子节点，第一个节点可能是右子树，不符合题目条件。</p><p>正确的办法是用递归，顺序算是中序遍历，当遇到叶子节点和空节点的时候，返回0，当遇到当前节点的左侧节点是叶子节点的时候，返回这个节点的值。</p><p>因为左侧节点不能通过当前节点来判断出来，必须要用父亲节点才能判断，所以“中序”就是在通过父亲节点判断左侧节点是不是叶子节点。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> _sumOfLeftLeaves(TreeNode* root)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 根节点为空，跳过</span></span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">nullptr</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 叶子节点，跳过（因为左侧叶子节点不存在，值视作为0）</span></span><br><span class="line">        <span class="keyword">if</span>(root-&gt;left == <span class="literal">nullptr</span> &amp;&amp; root-&gt;right == <span class="literal">nullptr</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 遍历左侧</span></span><br><span class="line">        <span class="type">int</span> left = _sumOfLeftLeaves(root-&gt;left);</span><br><span class="line">        <span class="comment">// 判断左侧是否为叶子节点，如果是需要进行修正（上一行的递归会跳过叶子节点的情况）</span></span><br><span class="line">        <span class="keyword">if</span>(root-&gt;left &amp;&amp; root-&gt;left-&gt;left == <span class="literal">nullptr</span> &amp;&amp; root-&gt;left-&gt;right==<span class="literal">nullptr</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            left = root-&gt;left-&gt;val; <span class="comment">// 左侧叶子节点的值</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 遍历右侧</span></span><br><span class="line">        <span class="type">int</span> right = _sumOfLeftLeaves(root-&gt;right);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> right + left;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">sumOfLeftLeaves</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> _sumOfLeftLeaves(root);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/03/4b6bc8846a4683698401c3b0057e5c91.png" alt="image-20240316111425986"></p><p>你也可以把代码按下面的方式写，会更好理解一些。当判断出当前左子树是叶子节点，就直接赋值，不是叶子节点才去遍历。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> _sumOfLeftLeaves(TreeNode* root)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 根节点为空，跳过</span></span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">nullptr</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 叶子节点，跳过（因为左侧叶子节点不存在，值视作为0）</span></span><br><span class="line">        <span class="keyword">if</span>(root-&gt;left == <span class="literal">nullptr</span> &amp;&amp; root-&gt;right == <span class="literal">nullptr</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 判断左侧是否为叶子节点</span></span><br><span class="line">        <span class="keyword">if</span>(root-&gt;left &amp;&amp; root-&gt;left-&gt;left == <span class="literal">nullptr</span> &amp;&amp; root-&gt;left-&gt;right==<span class="literal">nullptr</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            left = root-&gt;left-&gt;val; <span class="comment">// 左侧叶子节点的值</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            left = _sumOfLeftLeaves(root-&gt;left);<span class="comment">// 遍历左侧</span></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 遍历右侧</span></span><br><span class="line">        <span class="type">int</span> right = _sumOfLeftLeaves(root-&gt;right);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> right + left;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">sumOfLeftLeaves</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> _sumOfLeftLeaves(root);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/03/4ae5fbd2fe03e19ee457f91c4716c20d.png" alt="image-20240316111635285"></p><p>使用迭代也是借用遍历的思路，都是在父节点判断左子树是否为叶子节点。下面的代码来自代码随想录。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">sumOfLeftLeaves</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        stack&lt;TreeNode*&gt; st;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        st.<span class="built_in">push</span>(root);</span><br><span class="line">        <span class="type">int</span> result = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (!st.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            TreeNode* node = st.<span class="built_in">top</span>();</span><br><span class="line">            st.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="keyword">if</span> (node-&gt;left != <span class="literal">NULL</span> &amp;&amp; node-&gt;left-&gt;left == <span class="literal">NULL</span> &amp;&amp; node-&gt;left-&gt;right == <span class="literal">NULL</span>) &#123;</span><br><span class="line">                result += node-&gt;left-&gt;val;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (node-&gt;right) st.<span class="built_in">push</span>(node-&gt;right);</span><br><span class="line">            <span class="keyword">if</span> (node-&gt;left) st.<span class="built_in">push</span>(node-&gt;left);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="513-找树左下角的值"><a href="#513-找树左下角的值" class="headerlink" title="513 找树左下角的值"></a>513 找树左下角的值</h2><blockquote><p><a href="https://leetcode.cn/problems/find-bottom-left-tree-value/">https://leetcode.cn/problems/find-bottom-left-tree-value/</a></p></blockquote><p>给定一个二叉树的 <strong>根节点</strong> <code>root</code>，请找出该二叉树的 <strong>最底层 最左边</strong> 节点的值。</p><p>假设二叉树中至少有一个节点。</p><hr><p>这道题用上题层序遍历的思路才是对的，利用层序遍历走到最底层，将这一层最左侧的节点返回。但是这里会涉及到一个问题，<strong>我们怎么知道自己走到最后一层了呢</strong>？</p><p>实际上，并不需要去特殊判断，只需要将层序遍历每一层的第一个节点的值设置为返回值，这样层序遍历结束后，最后被设置的值就是题目需要求的节点。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">findBottomLeftValue</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">nullptr</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        queue&lt;TreeNode*&gt; que;</span><br><span class="line">        que.<span class="built_in">push</span>(root);</span><br><span class="line">        <span class="type">int</span> ret = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(!que.<span class="built_in">empty</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> size = que.<span class="built_in">size</span>();</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i =<span class="number">0</span>;i&lt;size;i++)</span><br><span class="line">            &#123;</span><br><span class="line">                TreeNode* front = que.<span class="built_in">front</span>();</span><br><span class="line">                que.<span class="built_in">pop</span>();</span><br><span class="line">                <span class="keyword">if</span>(i == <span class="number">0</span>)&#123;</span><br><span class="line">                    ret = front-&gt;val;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(front-&gt;left != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">                    que.<span class="built_in">push</span>(front-&gt;left);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(front-&gt;right != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">                    que.<span class="built_in">push</span>(front-&gt;right);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;   </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/03/6f7b9f6babc8fcbb50d64eb37a926fd0.png" alt="image-20240317161855120"></p><p>递归法使用前序遍历的思想，使用一个变量来记录当前深度，另外一个变量记录最深处左侧节点的值。这里的代码和上文<code>104二叉树的最大深度</code>题目中的思路相似。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> maxDepth = <span class="number">-1</span>; <span class="comment">// 最大深度</span></span><br><span class="line">    <span class="type">int</span> result = <span class="number">0</span>; <span class="comment">// 左侧节点值</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">getMaxDepthLeftNode</span><span class="params">(TreeNode* root,<span class="type">int</span> depth)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// 叶子节点</span></span><br><span class="line">        <span class="keyword">if</span>(root-&gt;right == <span class="literal">nullptr</span> &amp;&amp; root-&gt;left == <span class="literal">nullptr</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(depth &gt; maxDepth)&#123;</span><br><span class="line">                maxDepth = <span class="built_in">max</span>(maxDepth,depth);</span><br><span class="line">                result = root-&gt;val; <span class="comment">// 存放叶子节点的值</span></span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果左侧不为空，往左侧递归</span></span><br><span class="line">        <span class="keyword">if</span>(root-&gt;left != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">            <span class="built_in">getMaxDepthLeftNode</span>(root-&gt;left,depth+<span class="number">1</span>); <span class="comment">// 这里深度加一就相当于加上当前节点</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 往右侧递归</span></span><br><span class="line">        <span class="keyword">if</span>(root-&gt;right != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">            <span class="built_in">getMaxDepthLeftNode</span>(root-&gt;right,depth+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">findBottomLeftValue</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">nullptr</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">getMaxDepthLeftNode</span>(root,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/03/f23bdbc09fdab06e7b0f7542aebeb9a5.png" alt="image-20240317162934828"></p><h2 id="112-路径总和"><a href="#112-路径总和" class="headerlink" title="112 路径总和"></a>112 路径总和</h2><blockquote><p><a href="https://leetcode.cn/problems/path-sum/description/">https://leetcode.cn/problems/path-sum/description/</a></p></blockquote><p>给你二叉树的根节点 <code>root</code> 和一个表示目标和的整数 <code>targetSum</code> 。判断该树中是否存在 <strong>根节点到叶子节点</strong> 的路径，这条路径上所有节点值相加等于目标和 <code>targetSum</code> 。如果存在，返回 <code>true</code> ；否则，返回 <code>false</code> 。</p><p><strong>叶子节点</strong> 是指没有子节点的节点。</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/03/9924f255828e9bf5d223554c29c23c31.png" alt="image-20240317163532398"></p><p>这道题和<code>257 二叉树的所有路径</code>有些类似，不过那道题是需要将路径写入数组，这道题是需要判断有没有路径中节点值的和为指定数的情况。</p><p>递归函数中，传入目标值targetSum，当前值curSum（这里的当前值也是用了“回溯”的思想），为了避免错误修改目标值targetSum，将其设置为const变量。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">frontTravelTree</span><span class="params">(TreeNode* root,<span class="type">const</span> <span class="type">int</span> targetSum, <span class="type">int</span> curSum)</span></span></span><br></pre></td></tr></table></figure><p>递归的思路如下</p><ul><li>如果当前节点为空，直接返回false，不需要处理</li><li>如果当前节点非空，将当前节点的值加入curSum；</li><li>如果当前节点是叶子节点，判断当前的curSum是否等于targetSum，等于返回true；</li><li>往左侧和右侧递归，返回这两个递归结果的<strong>或</strong>；</li></ul><p>注意，判断targetSum的时候一定要判断是不是叶子节点，我刚开始写的时候就忘记判断了，因为路径可能还没到叶子节点就已经等于targetSum了，但是这种情况不符合题目条件。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">frontTravelTree</span><span class="params">(TreeNode* root,<span class="type">const</span> <span class="type">int</span> targetSum, <span class="type">int</span> curSum)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">nullptr</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        curSum += root-&gt;val;</span><br><span class="line">        <span class="comment">// 当前已经相等，且是叶子节点，返回</span></span><br><span class="line">        <span class="keyword">if</span>(targetSum == curSum &amp;&amp; root-&gt;left == <span class="literal">nullptr</span> &amp;&amp; root-&gt;right == <span class="literal">nullptr</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="type">bool</span> retLeft = <span class="built_in">frontTravelTree</span>(root-&gt;left,targetSum,curSum);</span><br><span class="line">        <span class="type">bool</span> retRight = <span class="built_in">frontTravelTree</span>(root-&gt;right,targetSum,curSum);</span><br><span class="line">        <span class="keyword">return</span> retLeft || retRight;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">hasPathSum</span><span class="params">(TreeNode* root, <span class="type">int</span> targetSum)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">frontTravelTree</span>(root,targetSum,<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/03/15e968da70f14f4a995298e2cef928e4.png" alt="image-20240317163820934"></p><p>使用迭代，也是用前序遍历的思路，用栈来实现。这里的思路和<code>257 二叉树的所有路径</code>中也是一样的，需要用到两个栈，一个用来遍历节点，另外一个保存上一层遍历到的节点curSum。</p><p>注意，因为是前序遍历，且每一次都会让curSum加上当前节点的值，所以stSum这个栈在初始化的时候一定要插入0，而不是根节点的值（不然会二次加根节点的值，会出错）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">hasPathSum</span><span class="params">(TreeNode* root, <span class="type">int</span> targetSum)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">nullptr</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        stack&lt;TreeNode*&gt; stNode; <span class="comment">// 遍历节点</span></span><br><span class="line">        stack&lt;<span class="type">int</span>&gt; stSum; <span class="comment">// 上一层遍历的求和结果</span></span><br><span class="line">        </span><br><span class="line">        stNode.<span class="built_in">push</span>(root);</span><br><span class="line">        stSum.<span class="built_in">push</span>(<span class="number">0</span>); <span class="comment">// 这里一定要插入0而不是根节点的值</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(!stNode.<span class="built_in">empty</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            TreeNode* curNode = stNode.<span class="built_in">top</span>();</span><br><span class="line">            stNode.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="type">int</span> curSum = stSum.<span class="built_in">top</span>();</span><br><span class="line">            stSum.<span class="built_in">pop</span>();</span><br><span class="line">            </span><br><span class="line">            curSum += curNode-&gt;val;</span><br><span class="line">            <span class="comment">// 如果是叶子节点，判断是否相等</span></span><br><span class="line">            <span class="keyword">if</span>(curNode-&gt;left == <span class="literal">nullptr</span> &amp;&amp; curNode-&gt;right == <span class="literal">nullptr</span> &amp;&amp; curSum == targetSum)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 继续向下</span></span><br><span class="line">            <span class="keyword">if</span>(curNode-&gt;left != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">                stNode.<span class="built_in">push</span>(curNode-&gt;left);</span><br><span class="line">                stSum.<span class="built_in">push</span>(curSum);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(curNode-&gt;right != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">                stNode.<span class="built_in">push</span>(curNode-&gt;right);</span><br><span class="line">                stSum.<span class="built_in">push</span>(curSum);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/03/c2f0411797bfce72243ae97448cbd33b.png" alt="image-20240317165115333"></p><h2 id="113-路径总和Ⅱ"><a href="#113-路径总和Ⅱ" class="headerlink" title="113 路径总和Ⅱ"></a>113 路径总和Ⅱ</h2><blockquote><p><a href="https://leetcode.cn/problems/path-sum-ii/">113. 路径总和 II</a></p></blockquote><p>上一题是让我们判断是否存在某一条路径，这题是需要返回所有符合条件的路径。</p><p>思路是使用前序遍历，用一个curSum记录当前遍历到的和，将当前值加入到这个和中并将当前值插入curV数组；</p><p>如果<strong>是叶子节点</strong>，则与targetSum对比，符合条件则将curV数组插入到返回值数组retV中。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="type">void</span> _pathSum(TreeNode* root, <span class="type">const</span> <span class="type">int</span> targetSum,<span class="type">int</span> curSum, vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; retV,vector&lt;<span class="type">int</span>&gt; curV) &#123;</span><br><span class="line">        <span class="comment">// 空节点跳过</span></span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">nullptr</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 前序遍历</span></span><br><span class="line">        curSum += root-&gt;val;</span><br><span class="line">        curV.<span class="built_in">push_back</span>(root-&gt;val);</span><br><span class="line">        <span class="comment">// 叶子节点，且值相等，插入</span></span><br><span class="line">        <span class="keyword">if</span>(root-&gt;left == <span class="literal">nullptr</span> &amp;&amp; root-&gt;right == <span class="literal">nullptr</span> &amp;&amp; curSum == targetSum)&#123;</span><br><span class="line">            retV.<span class="built_in">push_back</span>(curV);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 左右递归</span></span><br><span class="line">        _pathSum(root-&gt;left,targetSum,curSum,retV,curV);</span><br><span class="line">        _pathSum(root-&gt;right,targetSum,curSum,retV,curV);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">pathSum</span>(TreeNode* root, <span class="type">int</span> targetSum) &#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; retV;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">nullptr</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> retV;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        _pathSum(root,targetSum,<span class="number">0</span>,retV,<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;());</span><br><span class="line">        <span class="keyword">return</span> retV;</span><br><span class="line">    &#125;   </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/03/d1bbdfc5f2846feb568ce10501ef2400.png" alt="image-20240318103424964"></p><h2 id="106-从中序与后序遍历序列构造二叉树"><a href="#106-从中序与后序遍历序列构造二叉树" class="headerlink" title="106 从中序与后序遍历序列构造二叉树"></a>106 从中序与后序遍历序列构造二叉树</h2><blockquote><p><a href="https://leetcode.cn/problems/construct-binary-tree-from-inorder-and-postorder-traversal/">106 从中序与后序遍历序列构造二叉树</a></p></blockquote><p>给定两个整数数组 <code>inorder</code> 和 <code>postorder</code> ，其中 <code>inorder</code> 是二叉树的中序遍历， <code>postorder</code> 是同一棵树的后序遍历，请你构造并返回这颗 <em>二叉树</em> 。</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/03/cd173d709ec7bad3687083e5340a185e.png" alt="image-20240317171026511"></p><p>首先，要通过中序和后序遍历的概念知道如何从这两个数组中构造一棵树来。</p><ul><li>后序的最后一个节点是根节点</li><li>确定根节点后，中序遍历中根节点左侧的是左子树，右侧的是右子树；</li><li>继续依照这个概念拆分后序遍历的数组，找到左右子树的根节点…</li></ul><p>对于代码而言，重点就是将左右子树从中序和后序的数组中拆分开来，直到拆分到空节点。</p><ol><li>数组大小为空，说明是空节点</li><li>数组大小不为空，从后序遍历中取出最后一个值作为根节点的值；</li><li>从中序遍历的数组中找到根节点所在位置，作为拆分的中位线；</li><li>将中序遍历的数组依照根节点所在位置拆分成左子数组和右子数组；</li><li>切割后序遍历的数组，依照左侧数组和右侧数组的长度和中序遍历拆分后的长度一致来处理（如果中序拆出来的左子树数组有3个元素，那么后序遍历中左子树的数组就是从前往后数的前3个元素）；</li><li>递归处理左侧和右侧的子树；</li></ol><p>代码如下，主要需要注意的是拆分中序和后序数组时候迭代器的位置，这里的下标拆分范围如果搞不清楚可以打印出来多试试，记住思路是最重要的。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    TreeNode* _buildTree(vector&lt;<span class="type">int</span>&gt;&amp; inorder, vector&lt;<span class="type">int</span>&gt;&amp; postorder) &#123;</span><br><span class="line">        <span class="comment">// 递归分治条件</span></span><br><span class="line">        <span class="keyword">if</span>(inorder.<span class="built_in">size</span>() == <span class="number">0</span> || postorder.<span class="built_in">size</span>() == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 后序遍历的最后一个节点是根节点</span></span><br><span class="line">        <span class="type">int</span> val = postorder[postorder.<span class="built_in">size</span>()<span class="number">-1</span>];</span><br><span class="line">        TreeNode* root = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(val);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 在中序遍历数组中找到这个值，注意题目保证节点值不重复，所以能这么做。</span></span><br><span class="line">        <span class="type">int</span> i = <span class="number">0</span>; <span class="comment">// 提前定义，后面要用</span></span><br><span class="line">        <span class="keyword">for</span>(i = <span class="number">0</span>;i&lt;inorder.<span class="built_in">size</span>();i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(inorder[i] == val)&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 拆中序数组，使用[0,i)区间</span></span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">inorderLeft</span><span class="params">(inorder.begin(),inorder.begin()+i)</span></span>;</span><br><span class="line">        <span class="comment">// 下面这里是[i+1,end)区间，必须额外加一，否则不符合条件</span></span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">inorderRight</span><span class="params">(inorder.begin()+i+<span class="number">1</span>,inorder.end())</span></span>; </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 拆后续数组，因为后续数组的大小肯定和中序一致，从前往后拆就分别对应中序的左数组和右数组了</span></span><br><span class="line">        <span class="comment">// 将后续遍历数组中的的最后一个值删掉，因为当前已经使用了</span></span><br><span class="line">        postorder.<span class="built_in">resize</span>(postorder.<span class="built_in">size</span>()<span class="number">-1</span>); </span><br><span class="line">        <span class="comment">// 这里inorderLeft.size()理论上和i是相同的，所以用i也没问题</span></span><br><span class="line">        <span class="comment">// [0,inorderLeft.size())</span></span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">postorderLeft</span><span class="params">(postorder.begin(),postorder.begin()+inorderLeft.size())</span></span>;</span><br><span class="line">        <span class="comment">// [inorderLeft.size(),end())</span></span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">postorderRight</span><span class="params">(postorder.begin()+inorderLeft.size(),postorder.end())</span></span>;</span><br><span class="line"></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 递归遍历</span></span><br><span class="line">        TreeNode* left = _buildTree(inorderLeft,postorderLeft);</span><br><span class="line">        TreeNode* right = _buildTree(inorderRight,postorderRight);</span><br><span class="line">        <span class="comment">// 链接</span></span><br><span class="line">        root-&gt;left = left;</span><br><span class="line">        root-&gt;right = right;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">buildTree</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; inorder, vector&lt;<span class="type">int</span>&gt;&amp; postorder)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(inorder.<span class="built_in">size</span>() == <span class="number">0</span> || postorder.<span class="built_in">size</span>() == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> _buildTree(inorder,postorder);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/03/77678c2d171a81344112bf3d3f177ef2.png" alt="image-20240317173609279"></p><p>当然，上面的代码性能并不好，因为会有额外的空间复杂度消耗（每次递归都需要构建4个vector数组），我们可以将构建数组的操作改成用下标来标定区间。</p><p>代码如下，同样需要注意下标的区间，详见注释。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    TreeNode* _buildTree(<span class="type">const</span> vector&lt;<span class="type">int</span>&gt;&amp; inorder,<span class="type">int</span> inorderBegin,<span class="type">int</span> inorderEnd,<span class="type">const</span> vector&lt;<span class="type">int</span>&gt;&amp; postorder,<span class="type">int</span> postorderBegin,<span class="type">int</span> postorderEnd) &#123;        </span><br><span class="line">        <span class="keyword">if</span>(inorderBegin&gt;=inorderEnd || postorderBegin &gt;= postorderEnd)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 后序遍历的最后一个节点是根节点</span></span><br><span class="line">        <span class="comment">// int val = postorder[postorder.size()-1];</span></span><br><span class="line">        <span class="type">int</span> val = postorder[postorderEnd<span class="number">-1</span>];</span><br><span class="line">        TreeNode* root = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(val);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 在中序遍历数组中找到这个值，注意题目保证节点值不重复，所以能这么做。</span></span><br><span class="line">        <span class="type">int</span> i = <span class="number">0</span>; <span class="comment">// 提前定义，后面要用</span></span><br><span class="line">        <span class="comment">// for(i = 0;i&lt;inorder.size();i++)</span></span><br><span class="line">        <span class="keyword">for</span>(i = inorderBegin;i&lt;inorderEnd;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(inorder[i] == val)&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 拆中序数组，使用[0,i)区间</span></span><br><span class="line">        <span class="type">int</span> inorderBeginLeft = inorderBegin;</span><br><span class="line">        <span class="type">int</span> inorderEndLeft = inorderBegin+(i-inorderBegin); <span class="comment">// 如果直接加i是错误的，i已经是下标了，再加会超出范围</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 下面这里是[i+1,end)区间，必须额外加一，否则不符合条件</span></span><br><span class="line">        <span class="type">int</span> inorderBeginRight = inorderBegin+(i-inorderBegin)+<span class="number">1</span>; <span class="comment">// 这里需要加一，是跳过被选中的中间节点</span></span><br><span class="line">        <span class="type">int</span> inorderEndRight = inorderEnd;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 拆后续数组，因为后续数组的大小肯定和中序一致，从前往后拆就分别对应中序的左数组和右数组了</span></span><br><span class="line">        <span class="comment">// [0,inorderLeft.size())</span></span><br><span class="line">        <span class="type">int</span> postorderBeginLeft = postorderBegin;</span><br><span class="line">        <span class="type">int</span> postorderEndLeft = postorderBegin + (i - inorderBegin);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// [inorderLeft.size(),end())</span></span><br><span class="line">        <span class="type">int</span> postorderBeginRight = postorderBegin + (i - inorderBegin); <span class="comment">// 这里不需要加一，因为中间没有多出来一个数</span></span><br><span class="line">        <span class="type">int</span> postorderEndRight = postorderEnd <span class="number">-1</span>; <span class="comment">// 排除最后一个节点</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 递归遍历</span></span><br><span class="line">        TreeNode* left = _buildTree(inorder,inorderBeginLeft,inorderEndLeft,postorder,postorderBeginLeft,postorderEndLeft);</span><br><span class="line">        TreeNode* right = _buildTree(inorder,inorderBeginRight,inorderEndRight,postorder,postorderBeginRight,postorderEndRight);</span><br><span class="line">        <span class="comment">// 链接</span></span><br><span class="line">        root-&gt;left = left;</span><br><span class="line">        root-&gt;right = right;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">buildTree</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; inorder, vector&lt;<span class="type">int</span>&gt;&amp; postorder)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(inorder.<span class="built_in">size</span>() == <span class="number">0</span> || postorder.<span class="built_in">size</span>() == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> _buildTree(inorder,<span class="number">0</span>,inorder.<span class="built_in">size</span>(),postorder,<span class="number">0</span>,postorder.<span class="built_in">size</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/03/c20668f2784839f073d00b700bc039d1.png" alt="image-20240317182254991"></p><h2 id="105-从前序和中序遍历构造二叉树"><a href="#105-从前序和中序遍历构造二叉树" class="headerlink" title="105 从前序和中序遍历构造二叉树"></a>105 从前序和中序遍历构造二叉树</h2><blockquote><p><a href="https://leetcode.cn/problems/construct-binary-tree-from-preorder-and-inorder-traversal/">105. 从前序与中序遍历序列构造二叉树</a></p></blockquote><p>给定两个整数数组 <code>preorder</code> 和 <code>inorder</code> ，其中 <code>preorder</code> 是二叉树的<strong>先序遍历</strong>， <code>inorder</code> 是同一棵树的<strong>中序遍历</strong>，请构造二叉树并返回其根节点。</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/03/3b2acc3f4d092a12194f29d9c922f159.png" alt="image-20240317182505486"></p><p>这道题和上一道题的思路基本一致，这里就不用构造vector的思路了，直接用下标的方式来处理。</p><ul><li>前序遍历的第一个值是根节点</li><li>在中序遍历的数组中找到根节点的位置，根据该位置左右拆分数组</li><li>在前序遍历数组中，从第二位开始，根据中序遍历拆出来的两个数组的长度，拆分前序遍历的数组。</li><li>递归处理</li></ul><p>在后序遍历的数组中，需要排除的是最后一位。在前序遍历的数组中，需要排除的是第一位。在拆分数组下标的地方体现出来。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    TreeNode* _buildTree(<span class="type">const</span> vector&lt;<span class="type">int</span>&gt;&amp; preorder,<span class="type">int</span> preorderBegin,<span class="type">int</span> preorderEnd,<span class="type">const</span>  vector&lt;<span class="type">int</span>&gt;&amp; inorder, <span class="type">int</span> inorderBegin,<span class="type">int</span> inorderEnd)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 递归返回条件</span></span><br><span class="line">        <span class="keyword">if</span>(inorderBegin &gt;= inorderEnd || preorderBegin &gt;= preorderEnd)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 前序遍历的第一个</span></span><br><span class="line">        <span class="type">int</span> val = preorder[preorderBegin];</span><br><span class="line">        TreeNode* root = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(val);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 在中序遍历数组中找</span></span><br><span class="line">        <span class="type">int</span> i =<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(i = inorderBegin;i&lt;inorderEnd;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(inorder[i] == val)&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 拆分中序遍历数组</span></span><br><span class="line">        <span class="type">int</span> offset = i-inorderBegin;</span><br><span class="line">        <span class="comment">// 左侧数组[inorderBegin,inorderBegin+offset)</span></span><br><span class="line">        <span class="type">int</span> inorderBeginLeft = inorderBegin;</span><br><span class="line">        <span class="type">int</span> inorderEndLeft = inorderBegin + offset;  <span class="comment">// 这里不能直接加i，应该加i和开头的偏移量</span></span><br><span class="line">        <span class="comment">// 右侧数组[inorderBegin+offset+1,inorderEnd)</span></span><br><span class="line">        <span class="type">int</span> inorderBeginRight = inorderBegin + offset+<span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> inorderEndRight = inorderEnd;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 拆分前序遍历数组</span></span><br><span class="line">        <span class="comment">// 左侧数组[preorderBegin+1,preorderBegin+1+offset)，开头需要加一跳过第一个值</span></span><br><span class="line">        <span class="type">int</span> preorderBeginLeft = preorderBegin+<span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> preorderEndLeft = preorderBegin+<span class="number">1</span>+offset;</span><br><span class="line">        <span class="comment">// 右侧数组[preorderBegin+1+offset,preorderEnd)</span></span><br><span class="line">        <span class="type">int</span> preorderBeginRight = preorderBegin+<span class="number">1</span>+offset;</span><br><span class="line">        <span class="type">int</span> preorderEndRight = preorderEnd;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 递归遍历</span></span><br><span class="line">        TreeNode* left = _buildTree(preorder,preorderBeginLeft,preorderEndLeft,inorder,inorderBeginLeft,inorderEndLeft);</span><br><span class="line">        TreeNode* right = _buildTree(preorder,preorderBeginRight,preorderEndRight,inorder,inorderBeginRight,inorderEndRight);</span><br><span class="line">        <span class="comment">// 链接</span></span><br><span class="line">        root-&gt;left = left;</span><br><span class="line">        root-&gt;right = right;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">buildTree</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; preorder, vector&lt;<span class="type">int</span>&gt;&amp; inorder)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(preorder.<span class="built_in">size</span>() == <span class="number">0</span> || inorder.<span class="built_in">size</span>() == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> _buildTree(preorder,<span class="number">0</span>,preorder.<span class="built_in">size</span>(),inorder,<span class="number">0</span>,inorder.<span class="built_in">size</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/03/61d66d0b4bbef588ec323178e26c13fa.png" alt="image-20240317184256405"></p><h2 id="654-最大二叉树"><a href="#654-最大二叉树" class="headerlink" title="654 最大二叉树"></a>654 最大二叉树</h2><blockquote><p><a href="https://leetcode.cn/problems/maximum-binary-tree/">654. 最大二叉树</a></p></blockquote><p>给定一个不重复的整数数组 <code>nums</code> 。 <strong>最大二叉树</strong> 可以用下面的算法从 <code>nums</code> 递归地构建:</p><ol><li>创建一个根节点，其值为 <code>nums</code> 中的最大值。</li><li>递归地在最大值 <strong>左边</strong> 的 <strong>子数组前缀上</strong> 构建左子树。</li><li>递归地在最大值 <strong>右边</strong> 的 <strong>子数组后缀上</strong> 构建右子树。</li></ol><p>返回 <code>nums</code> 构建的<strong>最大二叉树</strong> 。</p><hr><p>这道题和前面105&#x2F;106这两道题的思路几乎完全一致，用前序遍历递归的思想，先找到最大值作为根节点，然后拆分左右区间（类似与105&#x2F;106题目中拆分中序遍历数组的左右区间）。拆分区间后进行遍历构建左右子树就行了。</p><p>这里要注意递归的退出条件，因为begin&#x2F;end选用的是左闭右开的选择，所以<code>begin==end</code>的情况也是无效的，所以<code>begin&gt;=end</code>作为递归的退出条件。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="comment">// 查找最大值，返回最大值的下标</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">searchMaxIndex</span><span class="params">(<span class="type">const</span> vector&lt;<span class="type">int</span>&gt;&amp; nums,<span class="type">int</span> begin,<span class="type">int</span> end)</span></span>&#123;</span><br><span class="line">        <span class="type">int</span> maxNum = nums[begin];</span><br><span class="line">        <span class="type">int</span> maxNumIndex = begin;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = begin;i&lt;end;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i] &gt; maxNum)&#123;</span><br><span class="line">                maxNum = nums[i];</span><br><span class="line">                maxNumIndex = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxNumIndex;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    TreeNode* _constructMaximumBinaryTree(<span class="type">const</span> vector&lt;<span class="type">int</span>&gt;&amp; nums,<span class="type">int</span> begin,<span class="type">int</span> end)&#123;</span><br><span class="line">        <span class="comment">// 本题采用左闭右开，所以begin==end是无效区间</span></span><br><span class="line">        <span class="keyword">if</span>(nums.<span class="built_in">size</span>() == <span class="number">0</span> || begin&gt;=end)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 找到最大值的下标</span></span><br><span class="line">        <span class="type">int</span> maxNumIndex = <span class="built_in">searchMaxIndex</span>(nums,begin,end);</span><br><span class="line">        TreeNode* root = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(nums[maxNumIndex]);</span><br><span class="line">        <span class="comment">// 左右拆分</span></span><br><span class="line">        <span class="type">int</span> leftBegin = begin;</span><br><span class="line">        <span class="type">int</span> leftEnd = maxNumIndex; </span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> rightBegin = maxNumIndex+<span class="number">1</span>; <span class="comment">// 加一跳过当前选中节点</span></span><br><span class="line">        <span class="type">int</span> rightEnd = end;</span><br><span class="line"></span><br><span class="line">        root-&gt;left = _constructMaximumBinaryTree(nums,leftBegin,leftEnd);</span><br><span class="line">        root-&gt;right = _constructMaximumBinaryTree(nums,rightBegin,rightEnd);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">constructMaximumBinaryTree</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums.<span class="built_in">size</span>() == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> _constructMaximumBinaryTree(nums,<span class="number">0</span>,nums.<span class="built_in">size</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/03/da6a3c1927b4d27c72da012d018f3cbc.png" alt="image-20240317193842851"></p><h2 id="617-合并二叉树"><a href="#617-合并二叉树" class="headerlink" title="617 合并二叉树"></a>617 合并二叉树</h2><blockquote><p><a href="https://leetcode.cn/problems/merge-two-binary-trees/">617. 合并二叉树</a></p></blockquote><p>想象一下，当你将其中一棵覆盖到另一棵之上时，两棵树上的一些节点将会重叠（而另一些不会）。你需要将这两棵树合并成一棵新二叉树。合并的规则是：如果两个节点重叠，那么将这两个节点的值相加作为合并后节点的新值；否则，<strong>不为</strong> null 的节点将直接作为新二叉树的节点。</p><p>返回合并后的二叉树。</p><p><strong>注意:</strong> 合并过程必须从两个树的根节点开始。</p><hr><p>这道题其实就是遍历二叉树多了第二棵树而已，不需要想的太复杂</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    TreeNode* _mergeTrees(TreeNode* root1, TreeNode* root2) &#123;</span><br><span class="line">        <span class="comment">// 如果一棵树为空了，就直接返回另外一棵树来拼接</span></span><br><span class="line">        <span class="keyword">if</span>(root1 == <span class="literal">nullptr</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> root2;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(root2 == <span class="literal">nullptr</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> root1;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 借用root1加上值</span></span><br><span class="line">        root1-&gt;val += root2-&gt;val;</span><br><span class="line">        <span class="comment">// 这里因为root1和root2的遍历顺序都是一样的，所以肯定能匹配上</span></span><br><span class="line">        root1-&gt;left = _mergeTrees(root1-&gt;left,root2-&gt;left);</span><br><span class="line">        root1-&gt;right = _mergeTrees(root1-&gt;right,root2-&gt;right);</span><br><span class="line">        <span class="keyword">return</span> root1;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">mergeTrees</span><span class="params">(TreeNode* root1, TreeNode* root2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> _mergeTrees(root1,root2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/03/6d041cf7b2d1792eeb72179653d0d30d.png" alt="image-20240317205658359"></p><p>使用迭代法的层序遍历思想也能解决这道题，需要将两棵树的根都插入队列中。在开始遍历之前，需要确定我们是用root1还是root2来构造最终的二叉树。</p><ul><li>取出节点，值相加</li><li>如果两个节点的左侧都不为空，入队列（注意顺序要一致）</li><li>如果两个节点的右侧都不为空，入队列</li><li>如果r1的左侧节点为空，r2不为空，将r1的左侧链接为r2</li><li>如果r1的右侧节点为空，r2不为空，将r1的右侧链接为r2</li></ul><p>代码如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">mergeTrees</span><span class="params">(TreeNode* root1, TreeNode* root2)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 如果一棵树为空了，就直接返回另外一棵树来拼接</span></span><br><span class="line">        <span class="keyword">if</span>(root1 == <span class="literal">nullptr</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> root2;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(root2 == <span class="literal">nullptr</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> root1;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 到这里root1和2都不为空</span></span><br><span class="line">        queue&lt;TreeNode*&gt; que;</span><br><span class="line">        que.<span class="built_in">push</span>(root1);</span><br><span class="line">        que.<span class="built_in">push</span>(root2);</span><br><span class="line">        <span class="comment">// 确定用root1来链接树</span></span><br><span class="line">        <span class="keyword">while</span>(!que.<span class="built_in">empty</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 这里不需要多层序遍历的循环，因为root1和root2每一层节点个数不相同</span></span><br><span class="line">            </span><br><span class="line">            TreeNode* r1 = que.<span class="built_in">front</span>();</span><br><span class="line">            que.<span class="built_in">pop</span>();</span><br><span class="line">            TreeNode* r2 = que.<span class="built_in">front</span>();</span><br><span class="line">            que.<span class="built_in">pop</span>();</span><br><span class="line">            r1-&gt;val += r2-&gt;val;</span><br><span class="line">            <span class="comment">// 如果两个节点的左右子树都不空，则都插入数组</span></span><br><span class="line">            <span class="keyword">if</span>(r1-&gt;left != <span class="literal">nullptr</span> &amp;&amp; r2-&gt;left != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">                que.<span class="built_in">push</span>(r1-&gt;left);</span><br><span class="line">                que.<span class="built_in">push</span>(r2-&gt;left);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(r1-&gt;right != <span class="literal">nullptr</span> &amp;&amp; r2-&gt;right != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">                que.<span class="built_in">push</span>(r1-&gt;right);</span><br><span class="line">                que.<span class="built_in">push</span>(r2-&gt;right);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 如果r1的左侧为空，r2不为空，赋值</span></span><br><span class="line">            <span class="keyword">if</span>(r1-&gt;left == <span class="literal">nullptr</span> &amp;&amp; r2-&gt;left != <span class="literal">nullptr</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                r1-&gt;left = r2-&gt;left;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(r1-&gt;right == <span class="literal">nullptr</span> &amp;&amp; r2-&gt;right != <span class="literal">nullptr</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                r1-&gt;right = r2-&gt;right;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/03/5cd92f8447a1213e28984aa6693eeecf.png" alt="image-20240317210547382"></p><h2 id="700-二叉搜索树中的搜索"><a href="#700-二叉搜索树中的搜索" class="headerlink" title="700 二叉搜索树中的搜索"></a>700 二叉搜索树中的搜索</h2><blockquote><p><a href="https://leetcode.cn/problems/search-in-a-binary-search-tree/">700. 二叉搜索树中的搜索</a></p></blockquote><p>给定二叉搜索树（BST）的根节点 <code>root</code> 和一个整数值 <code>val</code>。</p><p>你需要在 BST 中找到节点值等于 <code>val</code> 的节点。 返回以该节点为根的子树。 如果节点不存在，则返回 <code>null</code> 。</p><p> 代码如下，其实就是最最基本的搜索二叉树的查找方式。搜索二叉树的左子树的值小于当前节点的值，右子树的值大于当前节点的值。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    TreeNode* _searchBST(TreeNode* root,<span class="type">const</span> <span class="type">int</span> val) &#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">nullptr</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(root-&gt;val == val)&#123;</span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(root-&gt;val &gt; val)&#123;</span><br><span class="line">            <span class="keyword">return</span> _searchBST(root-&gt;left,val); <span class="comment">// 左侧更小</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> _searchBST(root-&gt;right,val); <span class="comment">// 右侧更小</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">searchBST</span><span class="params">(TreeNode* root, <span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">nullptr</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> _searchBST(root,val);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/03/27109369c080398669b2833e19d5f102.png" alt="image-20240317211001013"></p><p>用循环也能实现，因为这里不涉及到前中后序遍历什么的，只是单纯找一个值，所以用不上队列或者栈</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">searchBST</span><span class="params">(TreeNode* root, <span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 用循环也可以</span></span><br><span class="line">        <span class="keyword">while</span>(root != <span class="literal">nullptr</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(root-&gt;val == val)&#123;</span><br><span class="line">                <span class="keyword">return</span> root;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span>(root-&gt;val &gt; val)</span><br><span class="line">            &#123;</span><br><span class="line">                root = root-&gt;left;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                root = root-&gt;right;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="98-验证二层搜索树"><a href="#98-验证二层搜索树" class="headerlink" title="98 验证二层搜索树"></a>98 验证二层搜索树</h2><blockquote><p><a href="https://leetcode.cn/problems/validate-binary-search-tree/">98. 验证二叉搜索树</a></p></blockquote><p>给你一个二叉树的根节点 <code>root</code> ，判断其是否是一个有效的二叉搜索树。</p><p><strong>有效</strong> 二叉搜索树定义如下：</p><ul><li>节点的左子树只包含 <strong>小于</strong> 当前节点的数。</li><li>节点的右子树只包含 <strong>大于</strong> 当前节点的数。</li><li>所有左子树和右子树自身必须也是二叉搜索树。</li></ul><p>注意：二叉搜索树中不能有重复节点，因为无法判断两个相同节点的区别。</p><hr><p>这道题可以采用中序遍历的方式，构建一个二叉树的数组，并遍历判断这个数组是否有序（搜索二叉树的中序遍历肯定是有序的），代码如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="type">void</span> _inorderTravel(TreeNode* root,vector&lt;<span class="type">int</span>&gt;&amp; v)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">nullptr</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        _inorderTravel(root-&gt;left,v);</span><br><span class="line">        v.<span class="built_in">push_back</span>(root-&gt;val);</span><br><span class="line">        _inorderTravel(root-&gt;right,v);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isValidBST</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 本题保证root非空</span></span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; v;</span><br><span class="line">        _inorderTravel(root,v);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i =<span class="number">0</span>;i&lt;v.<span class="built_in">size</span>()<span class="number">-1</span>;i++)&#123;</span><br><span class="line">            <span class="comment">// 不能有重复节点，这里是大于等于</span></span><br><span class="line">            <span class="keyword">if</span>(v[i] &gt;= v[i+<span class="number">1</span>])&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/03/e947106623f118df8d3af395f66560e9.png" alt="image-20240318104631391"></p><p>当然，不用额外的数组也能写出这道题。思路是用中序遍历，维护一个当前最大值（初始化为<code>LONG_MIN</code>），在中序部分判断当前节点是否小于这个最大值，如果小于等于，则说明当前节点之前有比当前节点更大或等于当前值的节点，这是不符合条件的，返回假。</p><p>其他情况返回真。</p><p>因为本题目保证了root是非空的，所以第一个root的判断返回false&#x2F;true可以根据算法自行选择。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">long</span> maxNum = LONG_MIN;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isValidBST</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">nullptr</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">bool</span> retLeft = <span class="built_in">isValidBST</span>(root-&gt;left);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(root-&gt;val &lt;= maxNum)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            maxNum = root-&gt;val;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="type">bool</span> retRight = <span class="built_in">isValidBST</span>(root-&gt;right);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> retLeft &amp;&amp; retRight;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/03/7def55fee335595ab04630b5e4be6416.png" alt="image-20240318105739796"></p><p>这个算法还是会有一个问题，即二层搜索树中可能会存在本来就等于<code>LONG_MIN</code>的节点，此时会直接返回false，不符合预期。所以应该把maxNum初始化为二叉树中左下角的那个节点的值，来保证无论如何都可以遍历成功，避免我们选用的初始值对算法结果的影响。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    TreeNode* prev = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isValidBST</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">nullptr</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">bool</span> retLeft = <span class="built_in">isValidBST</span>(root-&gt;left);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(prev != <span class="literal">nullptr</span> &amp;&amp; root-&gt;val &lt;= prev-&gt;val)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            prev = root;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="type">bool</span> retRight = <span class="built_in">isValidBST</span>(root-&gt;right);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> retLeft &amp;&amp; retRight;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/03/55533a22daa18eeb746d2d6cf3d913a8.png" alt="image-20240318110020250"></p><h2 id="530-二叉搜索树的最小绝对差"><a href="#530-二叉搜索树的最小绝对差" class="headerlink" title="530 二叉搜索树的最小绝对差"></a>530 二叉搜索树的最小绝对差</h2><blockquote><p><a href="https://leetcode.cn/problems/minimum-absolute-difference-in-bst/">530. 二叉搜索树的最小绝对差</a></p></blockquote><p>给你一个二叉搜索树的根节点 <code>root</code> ，返回 <strong>树中任意两不同节点值之间的最小差值</strong> 。</p><p>差值是一个正数，其数值等于两值之差的绝对值。</p><hr><p>因为题目给的是搜索二叉树，还是和前两题类似，利用中序遍历的有序序列，计算两个相邻节点之间的差值，<strong>差值的最小值只可能是在两个相邻节点之间</strong>。这就好比给你一个有序的<strong>单调递增的数组</strong>，让你返回这个数组中任意两个数的最小差值一样。</p><p>同样，可以用中序遍历将搜索二叉树转为数组再进行处理，具体代码参考上题（一模一样的转化再遍历），这里给出直接用中序遍历递归实现的的算法，思路是维护一个当前节点的<strong>前一个节点的指针</strong>，并依次计算两个相邻节点之间的差值。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> minDiff = INT_MAX;</span><br><span class="line">    TreeNode* prev = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="type">void</span> _getMinimumDifference(TreeNode* root)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">nullptr</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 遍历左侧</span></span><br><span class="line">        _getMinimumDifference(root-&gt;left);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 计算差值</span></span><br><span class="line">        <span class="keyword">if</span>(prev != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">            minDiff = <span class="built_in">min</span>(minDiff,root-&gt;val - prev-&gt;val);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 所有情况都需要更新prev</span></span><br><span class="line">        prev = root;</span><br><span class="line">      </span><br><span class="line">        <span class="comment">// 遍历右侧</span></span><br><span class="line">        _getMinimumDifference(root-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getMinimumDifference</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        _getMinimumDifference(root);</span><br><span class="line">        <span class="keyword">return</span> minDiff;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/03/a214d88159622e177076e223f43e6e95.png" alt="image-20240318143728984"></p><p>使用迭代，利用中序遍历的迭代思路也能解决这道题，这里主要是要记住怎么使用栈进行中序遍历。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getMinimumDifference</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">nullptr</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        stack&lt;TreeNode*&gt; st;</span><br><span class="line"></span><br><span class="line">        TreeNode* prev = <span class="literal">nullptr</span>;</span><br><span class="line">        TreeNode* cur = root;</span><br><span class="line">        <span class="type">int</span> ret = INT_MAX; <span class="comment">// 最小差值</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 两个条件符合都不符合才停止循环</span></span><br><span class="line">        <span class="keyword">while</span>(cur != <span class="literal">nullptr</span> || !st.<span class="built_in">empty</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(cur != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">                st.<span class="built_in">push</span>(cur);</span><br><span class="line">                cur = cur-&gt;left; <span class="comment">// 左</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123; <span class="comment">// 往左一直走到空了</span></span><br><span class="line">                cur = st.<span class="built_in">top</span>(); <span class="comment">// 父亲节点</span></span><br><span class="line">                st.<span class="built_in">pop</span>();</span><br><span class="line">                <span class="comment">// 中序处理，计算最小值</span></span><br><span class="line">                <span class="keyword">if</span>(prev != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">                    ret = <span class="built_in">min</span>(ret,cur-&gt;val - prev-&gt;val);</span><br><span class="line">                &#125;</span><br><span class="line">                prev = cur;</span><br><span class="line">                <span class="comment">// 右</span></span><br><span class="line">                cur = cur-&gt;right;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/03/eb41ec52f3f08a6acd2f547b9604ae29.png" alt="image-20240318144644478"></p><h2 id="501-二叉搜索树中的众数"><a href="#501-二叉搜索树中的众数" class="headerlink" title="501 二叉搜索树中的众数"></a>501 二叉搜索树中的众数</h2><blockquote><p><a href="https://leetcode.cn/problems/find-mode-in-binary-search-tree/">501. 二叉搜索树中的众数</a></p></blockquote><p>给你一个含重复值的二叉搜索树（BST）的根节点 <code>root</code> ，找出并返回 BST 中的所有 <a href="https://baike.baidu.com/item/%E4%BC%97%E6%95%B0/44796">众数</a>（即，出现频率最高的元素）。</p><p>如果树中有不止一个众数，可以按 <strong>任意顺序</strong> 返回。</p><p>假定 BST 满足如下定义：</p><ul><li>结点左子树中所含节点的值 <strong>小于等于</strong> 当前节点的值</li><li>结点右子树中所含节点的值 <strong>大于等于</strong> 当前节点的值</li><li>左子树和右子树都是二叉搜索树</li></ul><hr><p>这道题首先可以按任何二叉树来操作，即遍历整棵树，用map记录某个节点出现的频率，最终将出现频率最高的几个数取出来。</p><p>注意，这里不能一上来就直接用优先级队列，因为优先级队列是没有办法修改某个值的。可以用map统计完后再用优先级队列来排序。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="comment">// 因为只是遍历统计，所以用什么顺序遍历都没有区别</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">inorderTravel</span><span class="params">(TreeNode* root,unordered_map&lt;<span class="type">int</span>,<span class="type">int</span>&gt;&amp; countMap)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">nullptr</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">inorderTravel</span>(root-&gt;left,countMap);</span><br><span class="line">        countMap[root-&gt;val]++;</span><br><span class="line">        <span class="built_in">inorderTravel</span>(root-&gt;right,countMap);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">MyCmp</span>&#123;</span><br><span class="line">    <span class="keyword">public</span>: <span class="comment">// 别忘了设置为公有</span></span><br><span class="line">        <span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">const</span> pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt;&amp; p1, <span class="type">const</span> pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt;&amp; p2)</span></span>&#123;</span><br><span class="line">            <span class="keyword">return</span> p1.second &lt; p2.second; <span class="comment">// 使用小于建立大堆</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">findMode</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; retV;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">nullptr</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> retV;</span><br><span class="line">        &#125;</span><br><span class="line">        unordered_map&lt;<span class="type">int</span>,<span class="type">int</span>&gt; countMap;</span><br><span class="line">        <span class="built_in">inorderTravel</span>(root,countMap);</span><br><span class="line">        <span class="comment">// 使用优先级队列来初始化值</span></span><br><span class="line">        priority_queue&lt;pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt;,vector&lt;pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt;&gt;,MyCmp&gt; <span class="built_in">que</span>(countMap.<span class="built_in">begin</span>(),countMap.<span class="built_in">end</span>());</span><br><span class="line">        <span class="comment">// 取出头部计数器相同的，插入数组</span></span><br><span class="line">        <span class="keyword">auto</span> curPair = que.<span class="built_in">top</span>();</span><br><span class="line">        que.<span class="built_in">pop</span>();</span><br><span class="line">        retV.<span class="built_in">push_back</span>(curPair.first);</span><br><span class="line">        <span class="comment">// 只要队列不为空就继续操作</span></span><br><span class="line">        <span class="keyword">while</span>(!que.<span class="built_in">empty</span>())&#123;</span><br><span class="line">            <span class="comment">// 当当前计数和刚刚插入的一致，则继续插入</span></span><br><span class="line">            <span class="keyword">if</span>(curPair.second == que.<span class="built_in">top</span>().second)&#123;</span><br><span class="line">                curPair = que.<span class="built_in">top</span>();</span><br><span class="line">                que.<span class="built_in">pop</span>();</span><br><span class="line">                retV.<span class="built_in">push_back</span>(curPair.first);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">break</span>; <span class="comment">// 不符合条件，跳出</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> retV;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/03/7add75ede3a5bb148a880b6f8b545578.png" alt="image-20240318150300783"></p><p>不过本题是一个搜索二叉树，解题方法肯定不同。还是那个性质，搜索二叉树的中序遍历结果是有序的，那么我们就可以通过这个有序来遍历计算当前数字出现的频率。同样是维护一个prev指针指向上一个节点，并对连续相同的数进行计数。</p><p>当遇到第一个不相同的节点时，清空计数器，将上一个节点插入返回值数组，重新开始计数。如果新的这个数字的数量大于上一个数字，那么就将返回值数组清空（因为此时返回值数组中的元素是无效的），重新按这个新的count计算众数。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="type">int</span> maxCount = <span class="number">-1</span>; <span class="comment">// 计数器肯定是正的，初始化为负数即可</span></span><br><span class="line">    <span class="type">int</span> count = <span class="number">0</span>; <span class="comment">// 这里不能用count作为参数，因为每一层的修改对全局都是有效的</span></span><br><span class="line">    TreeNode* prev = <span class="literal">nullptr</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">inordereTravelCount</span><span class="params">(TreeNode* root,vector&lt;<span class="type">int</span>&gt;&amp; retV)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">nullptr</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 左</span></span><br><span class="line">        <span class="built_in">inordereTravelCount</span>(root-&gt;left,retV);</span><br><span class="line">        <span class="comment">// 中，计数</span></span><br><span class="line">        <span class="keyword">if</span>(prev == <span class="literal">nullptr</span>)<span class="comment">// 第一个节点</span></span><br><span class="line">        &#123;</span><br><span class="line">            count = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(prev-&gt;val == root-&gt;val) <span class="comment">// 相同</span></span><br><span class="line">        &#123;</span><br><span class="line">            count++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="comment">// 不相同，新的节点</span></span><br><span class="line">        &#123;</span><br><span class="line">            count = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        prev = root;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 和当前记录最大值相同，插入        </span></span><br><span class="line">        <span class="keyword">if</span>(count == maxCount)</span><br><span class="line">        &#123;</span><br><span class="line">            retV.<span class="built_in">push_back</span>(root-&gt;val);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 超过了最大记录，需要清空返回值数组</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(count &gt; maxCount)&#123;</span><br><span class="line">            maxCount = count;</span><br><span class="line">            retV.<span class="built_in">clear</span>();</span><br><span class="line">            retV.<span class="built_in">push_back</span>(root-&gt;val);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">inordereTravelCount</span>(root-&gt;right,retV);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">findMode</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; retV;</span><br><span class="line">        <span class="built_in">inordereTravelCount</span>(root,retV);</span><br><span class="line">        <span class="keyword">return</span> retV;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/03/493f11bd2c3022a88ee7307d30d5932b.png" alt="image-20240318151918601"></p><h2 id="236-二叉树的最近公共祖先"><a href="#236-二叉树的最近公共祖先" class="headerlink" title="236 二叉树的最近公共祖先"></a>236 二叉树的最近公共祖先</h2><blockquote><p><a href="https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-tree/">236. 二叉树的最近公共祖先</a></p></blockquote><p>给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。</p><p><a href="https://baike.baidu.com/item/%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88/8918834?fr=aladdin">百度百科</a>中最近公共祖先的定义为：“对于有根树 T 的两个节点 p、q，最近公共祖先表示为一个节点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（<strong>一个节点也可以是它自己的祖先</strong>）。”</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">示例 1：</span><br><span class="line">输入：root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 1</span><br><span class="line">输出：3</span><br><span class="line">解释：节点 5 和节点 1 的最近公共祖先是节点 3 。</span><br><span class="line"></span><br><span class="line">示例 2：</span><br><span class="line">输入：root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 4</span><br><span class="line">输出：5</span><br><span class="line">解释：节点 5 和节点 4 的最近公共祖先是节点 5 。因为根据定义最近公共祖先节点可以为节点本身。</span><br><span class="line"></span><br><span class="line">示例 3：</span><br><span class="line">输入：root = [1,2], p = 1, q = 2</span><br><span class="line">输出：1</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li>树中节点数目在范围 <code>[2, 105]</code> 内。</li><li><code>-109 &lt;= Node.val &lt;= 109</code></li><li>所有 <code>Node.val</code> <code>互不相同</code> 。</li><li><code>p != q</code></li><li><code>p</code> 和 <code>q</code> 均存在于给定的二叉树中。</li></ul><hr><p>首先要明确，root也可以是自己的公共祖先，所以root等于p或者等于q的情况也是符合条件的。本题需要我们从左右子树中找到p和q，然后再往上返回它的最近公共祖先，即从树的底部往上遍历。<strong>后序遍历</strong>（左右中）就是符合这个条件的。</p><p>下图中，带序号的线代表后序遍历的顺序，长虚线代表每一次的返回值。</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/03/11cc4daf0b5ecc01017d3515b944eb39.png" alt="image-20240318190309074"></p><p>整体思路如下：</p><ul><li>判断root是否等于q&#x2F;p，或者root为空，此时返回root；</li><li>递归判断左侧和右侧，记录返回值</li><li>如果左侧和右侧返回值都不为空，则代表当前节点就是最近的公共祖先节点，返回root节点（当前节点）；</li><li>如果左侧和右侧有一个为空，则返回不为空的那一个；</li><li>如果左侧和右侧都为空，则返回空（代表当前节点的子树中没有找到q和p）；</li></ul><p>代码如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">lowestCommonAncestor</span><span class="params">(TreeNode* root, TreeNode* p, TreeNode* q)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// root也可以是它自己的祖先</span></span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">nullptr</span> || root == p || root == q)&#123;</span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 用后序遍历的思路来处理，这样能找到当前节点的孩子里面有么有q或者p</span></span><br><span class="line">        TreeNode* left = <span class="built_in">lowestCommonAncestor</span>(root-&gt;left, p,  q);</span><br><span class="line">        TreeNode* right = <span class="built_in">lowestCommonAncestor</span>(root-&gt;right, p,  q);</span><br><span class="line">        <span class="comment">// 如果左右都不为空，则代表root就是最近的公共祖先</span></span><br><span class="line">        <span class="keyword">if</span>(left != <span class="literal">nullptr</span> &amp;&amp; right != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// // // 如果两个都为空，代表没有找到，返回空</span></span><br><span class="line">        <span class="comment">// if(left == nullptr &amp;&amp; right == nullptr)&#123;</span></span><br><span class="line">        <span class="comment">//     return nullptr;</span></span><br><span class="line">        <span class="comment">// &#125;</span></span><br><span class="line">        <span class="comment">// // 如果有一个为空，则返回另外一个</span></span><br><span class="line">        <span class="comment">// if(left != nullptr &amp;&amp; right == nullptr)&#123;</span></span><br><span class="line">        <span class="comment">//     return left;</span></span><br><span class="line">        <span class="comment">// &#125;</span></span><br><span class="line">        <span class="comment">// if(left == nullptr &amp;&amp; right != nullptr)&#123;</span></span><br><span class="line">        <span class="comment">//     return right;</span></span><br><span class="line">        <span class="comment">// &#125;</span></span><br><span class="line">        <span class="comment">// return nullptr; // 这里的返回没有意义，因为不会走到这里来</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 上面的三个判断可以精简成下面这个</span></span><br><span class="line">        <span class="comment">// 如果left为空且right也为空的时候，本来就需要返回nullptr，此时返回right也是一样的</span></span><br><span class="line">        <span class="keyword">return</span> left != <span class="literal">nullptr</span> ? left : right;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/03/3fbff287842a54bdb60b89c6ded43521.png" alt="image-20240318184443461"></p><h2 id="235-二叉搜索树的最近公共祖先"><a href="#235-二叉搜索树的最近公共祖先" class="headerlink" title="235 二叉搜索树的最近公共祖先"></a>235 二叉搜索树的最近公共祖先</h2><blockquote><p><a href="https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-search-tree/">235. 二叉搜索树的最近公共祖先</a></p></blockquote><p>给定一个二叉搜索树, 找到该树中两个指定节点的最近公共祖先。</p><p><a href="https://baike.baidu.com/item/%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88/8918834?fr=aladdin">百度百科</a>中最近公共祖先的定义为：“对于有根树 T 的两个结点 p、q，最近公共祖先表示为一个结点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（<strong>一个节点也可以是它自己的祖先</strong>）。”</p><hr><p>本题和上一题要求一致，但树是搜索二叉树。利用这个特性，给定q和p的公共祖先的值肯定在<code>[q, p]</code>范围区间之间（注意q和p没有说明谁更大，所以要判断<code>q&lt;cur&lt; p</code>和<code>p&lt;cur&lt;q</code>的两种情况），找公共祖先，只需要从上往下，找到第一个值符合这个区间范围的节点就可以了。</p><ul><li>搜索二叉树的左侧小于当前节点，右侧大于当前节点；</li><li>从上往下遍历（用前序遍历），此时先处理的是中间节点，那么第一个找到的符合<code>[q,p]</code>区间的节点就是最近的公共祖先，此时往左还是往右都会错过；</li></ul><p>如下所示，找1和8节点的公共祖先（即5），此时如果往左走到3，就会错过8的祖先，往右走到9，就会错过1的公共祖先</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/03/ed75ee6553efc114dccd290d96603fc2.png" alt="image-20240318192043482"></p><p>理解思路了，代码就不难写了，前序遍历的二叉搜索代码就可以了。因为这是搜索二叉树，不需要递归也能实现。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">lowestCommonAncestor</span><span class="params">(TreeNode* root, TreeNode* p, TreeNode* q)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">nullptr</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        TreeNode* cur = root;</span><br><span class="line">        <span class="comment">// 找到q和p中的最小值</span></span><br><span class="line">        <span class="type">int</span> min = q-&gt;val,max = p-&gt;val;</span><br><span class="line">        <span class="keyword">if</span>(min &gt; max)&#123;</span><br><span class="line">            min = max;</span><br><span class="line">            max = q-&gt;val;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(cur != <span class="literal">nullptr</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 符合条件</span></span><br><span class="line">            <span class="keyword">if</span>(cur-&gt;val &gt;= min &amp;&amp; cur-&gt;val &lt;= max)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> cur;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 如果大了，就往左走</span></span><br><span class="line">            <span class="keyword">if</span>(cur-&gt;val &gt; max)&#123;</span><br><span class="line">                cur = cur-&gt;left;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 小了就往右边走</span></span><br><span class="line">            <span class="keyword">if</span>(cur-&gt;val &lt; min)&#123;</span><br><span class="line">                cur = cur-&gt;right;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/03/38160fcf06b8e269687f27e24468d03d.png" alt="image-20240318192653511"></p><h2 id="701-二叉搜索树中的插入操作"><a href="#701-二叉搜索树中的插入操作" class="headerlink" title="701 二叉搜索树中的插入操作"></a>701 二叉搜索树中的插入操作</h2><blockquote><p><a href="https://leetcode.cn/problems/insert-into-a-binary-search-tree/">701. 二叉搜索树中的插入操作</a></p></blockquote><p>给定二叉搜索树（BST）的根节点 <code>root</code> 和要插入树中的值 <code>value</code> ，将值插入二叉搜索树。 返回插入后二叉搜索树的根节点。 输入数据 <strong>保证</strong> 新值和原始二叉搜索树中的任意节点值都不同。</p><p><strong>注意</strong>，可能存在多种有效的插入方式，只要树在插入后仍保持为二叉搜索树即可。 你可以返回 <strong>任意有效的结果</strong> 。</p><hr><p>这道题没有那么难，因为题目要求的是二叉搜索树，并不是平衡二叉搜索树，所以不存在需要翻转的情况。我们只需要找到这个新节点应该存放的位置，将其链接进去就行了。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">insertIntoBST</span><span class="params">(TreeNode* root, <span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">        TreeNode* newNode = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(val);</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">nullptr</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> newNode;</span><br><span class="line">        &#125;</span><br><span class="line">        TreeNode* cur = root;</span><br><span class="line">        TreeNode* prev = root;</span><br><span class="line">        <span class="keyword">while</span>(cur != <span class="literal">nullptr</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(cur-&gt;val &gt; val)&#123;</span><br><span class="line">                prev = cur;</span><br><span class="line">                cur = cur-&gt;left;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(cur-&gt;val &lt; val)&#123;</span><br><span class="line">                prev = cur;</span><br><span class="line">                cur = cur-&gt;right;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 走到对应位置了</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 上一个节点肯定是叶子节点</span></span><br><span class="line">        <span class="comment">// 当前节点值更大，是左侧</span></span><br><span class="line">        <span class="keyword">if</span>(prev-&gt;val &gt; val)&#123;</span><br><span class="line">            prev-&gt;left = newNode;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 当前节点值更小，所以是右侧</span></span><br><span class="line">        <span class="keyword">if</span>(prev-&gt;val &lt; val)&#123;</span><br><span class="line">            prev-&gt;right = newNode;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/03/535f71322ea3e7dc4ffbab1b94c9d509.png" alt="image-20240318193613367"></p><h2 id="450-删除二叉搜索树中的节点"><a href="#450-删除二叉搜索树中的节点" class="headerlink" title="450 删除二叉搜索树中的节点"></a>450 删除二叉搜索树中的节点</h2><blockquote><p><a href="https://leetcode.cn/problems/delete-node-in-a-bst/">450. 删除二叉搜索树中的节点</a></p></blockquote><p>给定一个二叉搜索树的根节点 <strong>root</strong> 和一个值 <strong>key</strong>，删除二叉搜索树中的 <strong>key</strong> 对应的节点，并保证二叉搜索树的性质不变。返回二叉搜索树（有可能被更新）的根节点的引用。</p><p>一般来说，删除节点可分为两个步骤：</p><ol><li>首先找到需要删除的节点；</li><li>如果找到了，删除它。</li></ol><p><strong>提示:</strong></p><ul><li>节点数的范围 <code>[0, 104]</code></li><li><code>-105 &lt;= Node.val &lt;= 105</code></li><li>节点值唯一</li><li><code>root</code> 是合法的二叉搜索树</li><li><code>-105 &lt;= key &lt;= 105</code></li></ul><hr><p>删除搜索二叉树中的节点需要判断当前的情况</p><ul><li>没找到需要删除的节点，直接返回；</li><li>当前节点是叶子节点，将父节点的指针改成nullptr，delete该节点即可；</li><li>当前节点左侧节点为空，右侧不为空，将右侧节点记录，父节点的指针改成右侧节点，删除当前节点；</li><li>当前节点右侧节点为空，左侧不为空，将左侧节点记录，父节点的指针改成左侧节点，删除当前节点；</li><li>当前节点左侧右侧都不为空，将当前节点的<strong>左侧</strong>移动至<strong>右侧的最左节点</strong>，</li></ul><p>这里最难处理的是最后一种情况，见下图，红色是要被删除的节点5，绿色是该节点的左子树，蓝色是该节点的右子树。我们需要将5节点的左子树3移动到它的右子树的最左侧节点（即移动到6的位置）链接上。</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/03/692196a8807952e769421990232060e8.png" alt="image-20240318200430007"></p><p>因为是二叉搜索树，所以不需要用递归，循环找节点就行了。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"></span><br><span class="line">    <span class="function">TreeNode* <span class="title">deleteOneNode</span><span class="params">(TreeNode* target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (target == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> target;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 右侧为空，无论如何都返回左侧</span></span><br><span class="line">        <span class="keyword">if</span> (target-&gt;right == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> target-&gt;left;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 右侧不为空，统一处理，找到右子树的最左侧节点，进行链接</span></span><br><span class="line">        TreeNode* cur = target-&gt;right;</span><br><span class="line">        <span class="keyword">while</span> (cur-&gt;left != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            cur = cur-&gt;left;</span><br><span class="line">        &#125;</span><br><span class="line">        cur-&gt;left = target-&gt;left;</span><br><span class="line">        <span class="keyword">return</span> target-&gt;right;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">deleteNode</span><span class="params">(TreeNode* root, <span class="type">int</span> key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        &#125;</span><br><span class="line">        TreeNode* cur = root;</span><br><span class="line">        TreeNode* pre = <span class="literal">nullptr</span>; <span class="comment">// 记录cur的父节点，用来删除cur</span></span><br><span class="line">        <span class="keyword">while</span> (cur != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (cur-&gt;val == key) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            pre = cur;</span><br><span class="line">            <span class="keyword">if</span> (cur-&gt;val &gt; key) &#123;</span><br><span class="line">                cur = cur-&gt;left;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                cur = cur-&gt;right;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (pre == <span class="literal">nullptr</span>) &#123; <span class="comment">// 如果搜索树只有头结点</span></span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">deleteOneNode</span>(cur);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 判断删左孩子还是右孩子</span></span><br><span class="line">        <span class="keyword">if</span> (pre-&gt;left != <span class="literal">nullptr</span> &amp;&amp; pre-&gt;left == cur) &#123;</span><br><span class="line">            pre-&gt;left = <span class="built_in">deleteOneNode</span>(cur);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (pre-&gt;right != <span class="literal">nullptr</span> &amp;&amp; pre-&gt;right == cur) &#123;</span><br><span class="line">            pre-&gt;right = <span class="built_in">deleteOneNode</span>(cur);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/03/c59158ebd922e21fcd72d0df02c3d4d0.png" alt="image-20240319105711618"></p><h2 id="669-修剪二叉搜索树"><a href="#669-修剪二叉搜索树" class="headerlink" title="669 修剪二叉搜索树"></a>669 修剪二叉搜索树</h2><blockquote><p><a href="https://leetcode.cn/problems/trim-a-binary-search-tree/">669. 修剪二叉搜索树</a></p></blockquote><p>给你二叉搜索树的根节点 <code>root</code> ，同时给定最小边界<code>low</code> 和最大边界 <code>high</code>。通过修剪二叉搜索树，使得所有节点的值在<code>[low, high]</code>中。修剪树 <strong>不应该</strong> 改变保留在树中的元素的相对结构 (即，如果没有被移除，原有的父代子代关系都应当保留)。 可以证明，存在 <strong>唯一的答案</strong> 。</p><p>所以结果应当返回修剪好的二叉搜索树的新的根节点。注意，根节点可能会根据给定的边界发生改变。</p><hr><p>这里使用递归的方式来处理节点，通过返回值来将需要删除的节点排除掉。</p><ul><li>空节点，返回（递归末端条件）；</li><li>如果当前节点小于目标区间，则往右侧找并返回（这就相当于删除了当前节点）；</li><li>如果当前节点大于目标区间，则往左侧找并返回（这就相当于删除了当前节点）；</li><li>如果当前节点符合目标区间，则递归遍历左子树和右子树，并重新赋值新的左子树和右子树；</li></ul><p>其中最后一步是比较重要的，当前节点符合条件后，它的左侧和右侧可能会有不在区间内的节点，所以在递归遍历的同时，需要更新当前节点的左右子树指针，来接受递归后<strong>剔除了不符合条件节点</strong>的树。</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/03/9915c8d233479e5891444fd29a9d1898.png" alt="image-20240319122027435"></p><p>主要是理解如何通过递归的返回值来巧妙的“删除”不符合条件的节点。以上图的树为例，给定区间<code>[2,4]</code>，需要删除的节点是0和1。过程如下</p><ul><li>3符合条件，递归遍历左子树和右子树</li><li>右子树的4符合条件，递归遍历左子树和右子树（都为空，直接返回，相当于对4的节点没有做修改），最终返回4节点，赋值给3节点的right（也相当于没有修改）</li><li>左子树的0不符合条件（小于边界最小值），递归遍历右子树；</li><li>右子树的2符合条件，递归遍历左子树和右子树（2的右子树是空，直接返回）；</li><li>2的左子树1不符合条件（小于边界最小值），递归遍历右子树，此时1的右子树为空，相当于遍历1的这一次也是返回nullptr，并赋值给了2节点的right，相当于删除了节点1；</li><li>此时递归返回，2号节点往上返回（即遍历到0的那一次会返回2号节点），赋值给了3号节点的right，相当于删除了节点0。</li></ul><p>代码如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    TreeNode* _trimBST(TreeNode* root, <span class="type">const</span> <span class="type">int</span> low,<span class="type">const</span> <span class="type">int</span> high) &#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">nullptr</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 注意题目给出的是闭区间，所以这里超出的情况不包括=的情况</span></span><br><span class="line">        <span class="comment">// 如果当前节点值不在区间内，则往右边/左边找是否有符合条件的</span></span><br><span class="line">        <span class="comment">// 如果有则会正常返回符合条件的节点（也相当于通过返回值把当前节点删掉了）</span></span><br><span class="line">        <span class="keyword">if</span>(root-&gt;val &lt; low)&#123;</span><br><span class="line">            <span class="keyword">return</span> _trimBST(root-&gt;right,low,high);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;val &gt; high)&#123;</span><br><span class="line">            <span class="keyword">return</span> _trimBST(root-&gt;left,low,high);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 当前root的值符合范围，递归左子树和右子树，剔除不符合条件的节点</span></span><br><span class="line">        root-&gt;left = _trimBST(root-&gt;left,low,high);</span><br><span class="line">        root-&gt;right = _trimBST(root-&gt;right,low,high);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">trimBST</span><span class="params">(TreeNode* root, <span class="type">int</span> low, <span class="type">int</span> high)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">nullptr</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> _trimBST(root,low,high);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/03/d182dfe0db490518d670dbdb30fea46f.png" alt="image-20240319121234419"></p><h2 id="108-将有序数组转为二叉搜索树"><a href="#108-将有序数组转为二叉搜索树" class="headerlink" title="108 将有序数组转为二叉搜索树"></a>108 将有序数组转为二叉搜索树</h2><blockquote><p><a href="https://leetcode.cn/problems/convert-sorted-array-to-binary-search-tree/">108. 将有序数组转换为二叉搜索树</a></p></blockquote><p>给你一个整数数组 <code>nums</code> ，其中元素已经按 <strong>升序</strong> 排列，请你将其转换为一棵 平衡 二叉搜索树。</p><hr><p>这道题其实没有想象中的那么难，因为题目给的数组是有序的（可以理解为本来就是一格二叉搜索树的中序遍历数组形式），我们只需要通过<strong>前序遍历</strong>加上拆分数组，最终构建出来的树肯定会是一个平衡的二叉搜索树。</p><p>在上文中的<code>654 最大二叉树</code>中已经使用了拆分数组构建树的方式，那道题是需要找到数组中的最大点。本题的平衡二叉搜索树需要找到<strong>有序数组的中间节点</strong>（即当前的中位数）作为根。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    TreeNode* _sortedArrayToBST(<span class="type">const</span> vector&lt;<span class="type">int</span>&gt;&amp; nums,<span class="type">int</span> left,<span class="type">int</span> right) &#123;</span><br><span class="line">    <span class="comment">// 注意right是开区间，left=right的时候也无效</span></span><br><span class="line">        <span class="keyword">if</span>(left &gt;= right)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> mid = left + ((right - left)/<span class="number">2</span>); </span><br><span class="line">        </span><br><span class="line">        <span class="comment">// int mid = (right - left)/2; // 这样计算的结果是错误的，值可能会小于left，导致陷入死循环</span></span><br><span class="line"></span><br><span class="line">        TreeNode* root = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(nums[mid]);</span><br><span class="line">        root-&gt;left = _sortedArrayToBST(nums,left,mid);</span><br><span class="line">        root-&gt;right = _sortedArrayToBST(nums,mid+<span class="number">1</span>,right);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">sortedArrayToBST</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums.<span class="built_in">size</span>() == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> _sortedArrayToBST(nums,<span class="number">0</span>,nums.<span class="built_in">size</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/03/ad9482d397c93fc97210bb4b8bba543a.png" alt="image-20240319124522237"></p><p>如果使用迭代法，需要三个队列，一个存放节点，一个存放左区间，一个存放右区间。以下代码来自<a href="https://www.programmercarl.com/0108.%E5%B0%86%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E8%BD%AC%E6%8D%A2%E4%B8%BA%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91.html#%E6%80%9D%E8%B7%AF">代码随想录</a>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">sortedArrayToBST</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (nums.<span class="built_in">size</span>() == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">        TreeNode* root = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(<span class="number">0</span>);   <span class="comment">// 初始根节点</span></span><br><span class="line">        queue&lt;TreeNode*&gt; nodeQue;           <span class="comment">// 放遍历的节点</span></span><br><span class="line">        queue&lt;<span class="type">int</span>&gt; leftQue;                 <span class="comment">// 保存左区间下标</span></span><br><span class="line">        queue&lt;<span class="type">int</span>&gt; rightQue;                <span class="comment">// 保存右区间下标</span></span><br><span class="line">        nodeQue.<span class="built_in">push</span>(root);                 <span class="comment">// 根节点入队列</span></span><br><span class="line">        leftQue.<span class="built_in">push</span>(<span class="number">0</span>);                    <span class="comment">// 0为左区间下标初始位置</span></span><br><span class="line">        rightQue.<span class="built_in">push</span>(nums.<span class="built_in">size</span>() - <span class="number">1</span>);     <span class="comment">// nums.size() - 1为右区间下标初始位置</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (!nodeQue.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            TreeNode* curNode = nodeQue.<span class="built_in">front</span>();</span><br><span class="line">            nodeQue.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="type">int</span> left = leftQue.<span class="built_in">front</span>(); leftQue.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="type">int</span> right = rightQue.<span class="built_in">front</span>(); rightQue.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="type">int</span> mid = left + ((right - left) / <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">            curNode-&gt;val = nums[mid];       <span class="comment">// 将mid对应的元素给中间节点</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (left &lt;= mid - <span class="number">1</span>) &#123;          <span class="comment">// 处理左区间</span></span><br><span class="line">                curNode-&gt;left = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(<span class="number">0</span>);</span><br><span class="line">                nodeQue.<span class="built_in">push</span>(curNode-&gt;left);</span><br><span class="line">                leftQue.<span class="built_in">push</span>(left);</span><br><span class="line">                rightQue.<span class="built_in">push</span>(mid - <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (right &gt;= mid + <span class="number">1</span>) &#123;         <span class="comment">// 处理右区间</span></span><br><span class="line">                curNode-&gt;right = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(<span class="number">0</span>);</span><br><span class="line">                nodeQue.<span class="built_in">push</span>(curNode-&gt;right);</span><br><span class="line">                leftQue.<span class="built_in">push</span>(mid + <span class="number">1</span>);</span><br><span class="line">                rightQue.<span class="built_in">push</span>(right);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="538-把二叉搜索树转为累加树"><a href="#538-把二叉搜索树转为累加树" class="headerlink" title="538 把二叉搜索树转为累加树"></a>538 把二叉搜索树转为累加树</h2><blockquote><p><a href="https://leetcode.cn/problems/convert-bst-to-greater-tree/">538. 把二叉搜索树转换为累加树</a></p></blockquote><p>给出二叉 <strong>搜索</strong> 树的根节点，该树的节点值各不相同，请你将其转换为累加树（Greater Sum Tree），使每个节点 <code>node</code> 的新值等于原树中大于或等于 <code>node.val</code> 的值之和。</p><p>提醒一下，二叉搜索树满足下列约束条件：</p><ul><li>节点的左子树仅包含键 <strong>小于</strong> 节点键的节点。</li><li>节点的右子树仅包含键 <strong>大于</strong> 节点键的节点。</li><li>左右子树也必须是二叉搜索树。</li></ul><p><strong>注意：</strong>本题和 1038: <a href="https://leetcode-cn.com/problems/binary-search-tree-to-greater-sum-tree/">https://leetcode-cn.com/problems/binary-search-tree-to-greater-sum-tree/</a> 相同</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/03/7ef89c321b9f619dfccde873ccd90f9c.png" alt="image-20240319124844008"></p><p>题目要求的是将每个节点的值转为它和它右侧的节点的和。用数组可能更好理解一些，即将当前数组下标位置的<strong>值改为它和它右侧的节点的和</strong>。</p><p>所以可以从右侧往左侧遍历这个数组，记录一个求和值，并将当前数组的值加上这个求和值就行了。比如数组<code>[15,24,30]</code>的结果是<code>[68,54,30]</code>；</p><p>对于二叉树也是一样的，从右侧往左侧遍历，顺序是<code>右中左</code>，把中序遍历的代码改一下顺序就行了。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="type">int</span> sum  = <span class="number">0</span>;</span><br><span class="line">    TreeNode* _convertBST(TreeNode* root) &#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">nullptr</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        &#125;</span><br><span class="line">        _convertBST(root-&gt;right);</span><br><span class="line">        sum += root-&gt;val;</span><br><span class="line">        root-&gt;val = sum;</span><br><span class="line">        _convertBST(root-&gt;left);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">convertBST</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">nullptr</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> _convertBST(root);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/03/60fa23c99471735c788fe0f350bac25d.png" alt="image-20240319183019626"></p><p>如果要用迭代法，同样是中序遍历的迭代模板，将左右子树遍历的顺序修改一下就可以了。以下代码来自代码随想录</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> pre; <span class="comment">// 记录前一个节点的数值</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">traversal</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        stack&lt;TreeNode*&gt; st;</span><br><span class="line">        TreeNode* cur = root;</span><br><span class="line">        <span class="keyword">while</span> (cur != <span class="literal">NULL</span> || !st.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (cur != <span class="literal">NULL</span>) &#123;</span><br><span class="line">                st.<span class="built_in">push</span>(cur);</span><br><span class="line">                cur = cur-&gt;right;   <span class="comment">// 右</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                cur = st.<span class="built_in">top</span>();     <span class="comment">// 中</span></span><br><span class="line">                st.<span class="built_in">pop</span>();</span><br><span class="line">                cur-&gt;val += pre;</span><br><span class="line">                pre = cur-&gt;val;</span><br><span class="line">                cur = cur-&gt;left;    <span class="comment">// 左</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">convertBST</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        pre = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">traversal</span>(root);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="129-求根节点到叶节点数字之和"><a href="#129-求根节点到叶节点数字之和" class="headerlink" title="129 求根节点到叶节点数字之和"></a>129 求根节点到叶节点数字之和</h2><blockquote><p><a href="https://leetcode.cn/problems/sum-root-to-leaf-numbers/description/">https://leetcode.cn/problems/sum-root-to-leaf-numbers/description/</a></p></blockquote><p>给你一个二叉树的根节点 root ，树中每个节点都存放有一个 0 到 9 之间的数字。<br>每条从根节点到叶节点的路径都代表一个数字：</p><p>例如，从根节点到叶节点的路径 1 -&gt; 2 -&gt; 3 表示数字 123 。<br>计算从根节点到叶节点生成的 所有数字之和 。</p><p>叶节点 是指没有子节点的节点。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入：root = [1,2,3]</span><br><span class="line">输出：25</span><br><span class="line">解释：</span><br><span class="line">从根到叶子节点路径 1-&gt;2 代表数字 12</span><br><span class="line">从根到叶子节点路径 1-&gt;3 代表数字 13</span><br><span class="line">因此，数字总和 = 12 + 13 = 25</span><br></pre></td></tr></table></figure><p>这道题和前文做过的路径总和类似，只不过路径总和是二叉树到叶子节点的整个路径上节点的和，而这道题让我们把二叉树从根到叶子节点的路径视作一个数字来处理。</p><p>所以可以用<strong>前序遍历</strong>（根左右）的方式，给每个二叉树到叶子节点的路径创建一个数组，将节点值尾插。并在叶子节点将这个数组转成int值，作为其中一个数字插入到retV最终数组中。在主函数内，先调用递归函数，然后再遍历retV数组相加里面的值就可以了。</p><p>这道题需要注意的是，我们需要在叶子节点做插入retV的处理，而不是在空节点中做。如果在空节点中做处理，那么一条路径的数字会被插入retV两次（因为叶子节点递归的左子树和右子树都是空，会被操作两次。）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; retV;</span><br><span class="line">    <span class="comment">// 数组转为int</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">vector2int</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; v)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; v.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            sum = sum * <span class="number">10</span> + v[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">void</span> _sumNumbers(TreeNode* root, vector&lt;<span class="type">int</span>&gt; curV) &#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">nullptr</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span>; <span class="comment">// 空节点不做任何处理</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 到叶子节点就需要插入了，不然会额外多处理一次</span></span><br><span class="line">        <span class="keyword">if</span> (root-&gt;right == <span class="literal">nullptr</span> &amp;&amp; root-&gt;left == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            curV.<span class="built_in">push_back</span>(root-&gt;val);        <span class="comment">// 叶子节点的值</span></span><br><span class="line">            retV.<span class="built_in">push_back</span>(<span class="built_in">vector2int</span>(curV)); <span class="comment">// 插入返回值数组</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 前序遍历</span></span><br><span class="line">        curV.<span class="built_in">push_back</span>(root-&gt;val);</span><br><span class="line">        _sumNumbers(root-&gt;left, curV);</span><br><span class="line">        _sumNumbers(root-&gt;right, curV);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">sumNumbers</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        _sumNumbers(root, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;());</span><br><span class="line">        <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; i : retV) &#123;</span><br><span class="line">            sum += i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/04/36c39234f901411008ac220c78eb5f60.png" alt="image.png"></p><h2 id="1382-将二叉搜索树变平衡"><a href="#1382-将二叉搜索树变平衡" class="headerlink" title="1382 将二叉搜索树变平衡"></a>1382 将二叉搜索树变平衡</h2><blockquote><p><a href="https://leetcode.cn/problems/balance-a-binary-search-tree/description/">https://leetcode.cn/problems/balance-a-binary-search-tree/description/</a></p></blockquote><p>给你一棵二叉搜索树，请你返回一棵 平衡后 的二叉搜索树，新生成的树应该与原来的树有着相同的节点值。如果有多种构造方法，请你返回任意一种。</p><p>如果一棵二叉搜索树中，每个节点的两棵子树高度差不超过 1 ，我们就称这棵二叉搜索树是 平衡的 。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：root = [1,null,2,null,3,null,4,null,null]</span><br><span class="line">输出：[2,1,3,null,null,null,4]</span><br><span class="line">解释：这不是唯一的正确答案，[3,1,4,null,2,null,null] 也是一个可行的构造方案。</span><br></pre></td></tr></table></figure><p>这道题其实是两道题的结合：将搜索二叉树转为有序数组+108从有序数组构造平衡搜索二叉树。我们将给定的搜索二叉树按中序遍历的方式存入数组，即得到了一个有序数组，再根据这个有序数组构造平衡二叉树即可</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="comment">// 中序遍历转数组</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">treeToVector</span><span class="params">(TreeNode* root, vector&lt;<span class="type">int</span>&gt;&amp; v)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">treeToVector</span>(root-&gt;left,v);</span><br><span class="line">        v.<span class="built_in">push_back</span>(root-&gt;val);</span><br><span class="line">        <span class="built_in">treeToVector</span>(root-&gt;right,v);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">TreeNode* <span class="title">vectorToBanlanceBST</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; v, <span class="type">int</span> left, <span class="type">int</span> right)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// right是开区间，left=right的情况也是无效的</span></span><br><span class="line">        <span class="keyword">if</span> (left &gt;= right) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">        TreeNode* root = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(v[mid]);</span><br><span class="line">        root-&gt;left = <span class="built_in">vectorToBanlanceBST</span>(v, left, mid);</span><br><span class="line">        root-&gt;right = <span class="built_in">vectorToBanlanceBST</span>(v, mid + <span class="number">1</span>, right);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">balanceBST</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">nullptr</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; v;</span><br><span class="line">        <span class="comment">// 先用中序遍历转成数组（题目给的已经是一个二叉搜索树，中序遍历肯定有序）</span></span><br><span class="line">        <span class="built_in">treeToVector</span>(root, v);</span><br><span class="line">        <span class="comment">// 然后用108有序数组转成二叉平衡树的思路来转换</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">vectorToBanlanceBST</span>(v, <span class="number">0</span>, v.<span class="built_in">size</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/04/1663eb89ae2a32c62f6380923d722be8.png" alt="image.png"></p><h1 id="3-递归函数什么时候需要返回值？"><a href="#3-递归函数什么时候需要返回值？" class="headerlink" title="3.递归函数什么时候需要返回值？"></a>3.递归函数什么时候需要返回值？</h1><blockquote><p>以下总结来自代码随想录</p></blockquote><p>递归函数什么时候需要返回值？什么时候不需要返回值？这里总结如下三点：</p><ul><li>如果需要搜索整棵二叉树且不用处理递归返回值，递归函数就不要返回值。（题目113路径总和2）</li><li>如果需要搜索整棵二叉树且需要处理递归返回值，递归函数就需要返回值。 （题目236二叉树的最近公共祖先）</li><li>如果要搜索其中一条符合条件的路径，那么递归一定需要返回值，因为遇到符合条件的路径了就要及时返回。（题目112路径总和）</li></ul><h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>本篇刷题笔记到这里就结束啦，如果对涉及到的题目有什么不懂的地方，可以在评论区提出哦！</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2023/02/202204161703532.png" alt="image-20220416170310498"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;本文首发于&lt;code&gt;2022-04-20&lt;/code&gt;，2024年重新刷题，对本文做了较大更新，所以重新发布。&lt;/p&gt;
&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;上篇博客我带</summary>
      
    
    
    
    <category term="编程学习" scheme="https://blog.musnow.top/categories/%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="数据结构" scheme="https://blog.musnow.top/categories/%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
    <category term="C语言" scheme="https://blog.musnow.top/tags/C%E8%AF%AD%E8%A8%80/"/>
    
    <category term="数据结构" scheme="https://blog.musnow.top/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    <category term="OJ刷题" scheme="https://blog.musnow.top/tags/OJ%E5%88%B7%E9%A2%98/"/>
    
    <category term="树" scheme="https://blog.musnow.top/tags/%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>【leetcode】239滑动窗口最大值</title>
    <link href="https://blog.musnow.top/posts/2402466745/"/>
    <id>https://blog.musnow.top/posts/2402466745/</id>
    <published>2024-03-14T01:05:54.000Z</published>
    <updated>2024-03-14T11:09:01.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p><a href="https://leetcode.cn/problems/sliding-window-maximum/description/">239. 滑动窗口最大值 - 力扣（LeetCode）</a></p><p>给你一个整数数组 nums，有一个大小为 k 的滑动窗口从数组的最左侧移动到数组的最右侧。你只可以看到在滑动窗口内的 k 个数字。滑动窗口每次只向右移动一位。</p><p>返回 滑动窗口中的最大值 。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">示例 1：</span><br><span class="line">输入：nums = [1,3,-1,-3,5,3,6,7], k = 3</span><br><span class="line">输出：[3,3,5,5,6,7]</span><br><span class="line">解释：</span><br><span class="line">滑动窗口的位置                最大值</span><br><span class="line">---------------               -----</span><br><span class="line">[1  3  -1] -3  5  3  6  7       3</span><br><span class="line"> 1 [3  -1  -3] 5  3  6  7       3</span><br><span class="line"> 1  3 [-1  -3  5] 3  6  7       5</span><br><span class="line"> 1  3  -1 [-3  5  3] 6  7       5</span><br><span class="line"> 1  3  -1  -3 [5  3  6] 7       6</span><br><span class="line"> 1  3  -1  -3  5 [3  6  7]      7</span><br><span class="line"></span><br><span class="line">示例 2：</span><br><span class="line">输入：nums = [1], k = 1</span><br><span class="line">输出：[1]</span><br></pre></td></tr></table></figure><p>提示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1 &lt;= nums.length &lt;= 105</span><br><span class="line">-104 &lt;= nums[i] &lt;= 104</span><br><span class="line">1 &lt;= k &lt;= nums.length</span><br></pre></td></tr></table></figure><h1 id="思路一"><a href="#思路一" class="headerlink" title="思路一"></a>思路一</h1><h2 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h2><p>我最初自己想的思路是，用一个队列来维护滑动窗口，并用一个当前最大值来记录滑动窗口内的最大值。每次滑动窗口满了（为k），都将这个最大值写入返回值数组中。</p><p>当滑动窗口左侧缩限的时候，判断被出队列的是否为最大值</p><ul><li>不是最大值，不用更新当前最大值；</li><li>是最大值，从队列剩余数据中选出一个新的当前最大值；</li></ul><p>这样就能维护出一个题目需要的数组。代码如下</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">maxSlidingWindow</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> curMax = INT32_MIN; <span class="comment">// 当前最大值</span></span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; retV; <span class="comment">//最大值返回数组</span></span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> size = <span class="number">0</span>;<span class="comment">// 当前队列长度</span></span><br><span class="line">        queue&lt;<span class="type">int</span>&gt; que;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span>&amp;e:nums)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 长度已经等于3了，需要出一个数字</span></span><br><span class="line">            <span class="keyword">if</span>(size == k)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="type">int</span> popNum = que.<span class="built_in">front</span>();</span><br><span class="line">                que.<span class="built_in">pop</span>();</span><br><span class="line">                size--;</span><br><span class="line">                <span class="comment">// 出队列的就是最大值，那需要从队列里面剩下的选出一个最大值</span></span><br><span class="line">                <span class="keyword">if</span>(popNum == curMax)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="type">int</span> count = size;</span><br><span class="line">                    curMax = que.<span class="built_in">front</span>(); <span class="comment">// 重置为队列开头值，避免无法匹配</span></span><br><span class="line">                    <span class="keyword">while</span>(count --)</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="comment">// 选最大值</span></span><br><span class="line">                        <span class="type">int</span> temp = que.<span class="built_in">front</span>();</span><br><span class="line">                        curMax = <span class="built_in">max</span>(curMax,temp);</span><br><span class="line">                        que.<span class="built_in">pop</span>();</span><br><span class="line">                        que.<span class="built_in">push</span>(temp); <span class="comment">// 再插回去</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 出队列的不是最大值，不用处理</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 长度小于3，需要入数字</span></span><br><span class="line">            <span class="keyword">if</span>(size &lt; k)</span><br><span class="line">            &#123;</span><br><span class="line">                curMax = <span class="built_in">max</span>(curMax,e);</span><br><span class="line">                que.<span class="built_in">push</span>(e);</span><br><span class="line">                size++;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 每次size等于3的时候都将最大值写入数组</span></span><br><span class="line">            <span class="keyword">if</span>(size == k)</span><br><span class="line">            &#123;</span><br><span class="line">                retV.<span class="built_in">push_back</span>(curMax);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 数量不足k个，最大值需要插入数组</span></span><br><span class="line">        <span class="keyword">if</span>(nums.<span class="built_in">size</span>() &lt; k)</span><br><span class="line">        &#123;</span><br><span class="line">            retV.<span class="built_in">push_back</span>(curMax);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> retV;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这个代码的时间复杂度是<code>O(N*K)</code>，因为最差情况视作每次都需要重新遍历队列，时间复杂度就很高了。但思路应该是没有问题的，通过了大部分测试用例，只不过在大测试用例中超时了，因为此时K很大，如果需要重新遍历对列找出第二个最大值，耗时会很高。</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/03/dbc1d566677a56a511bb37f3e9823663.png" alt="image.png"></p><p>当然，我想出了另外一个优化方案，就是对于这种大k的情况，维护一个队列中第二大的数据，就不需要遍历对列了。但这样很麻烦，且这个思路本身就已经不适合解这道题了，于是没有尝试。</p><h1 id="思路二"><a href="#思路二" class="headerlink" title="思路二"></a>思路二</h1><h2 id="说明-1"><a href="#说明-1" class="headerlink" title="说明"></a>说明</h2><p>思路二是<a href="https://www.programmercarl.com/0239.%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E6%9C%80%E5%A4%A7%E5%80%BC.html">代码随想录</a>上面的，使用一个单调递增&#x2F;递减对列来维护这个最大值。对于本题而言，使用单调递减序列更适合。</p><p>这个对列需要实现push&#x2F;pop&#x2F;front三个功能，其中front就是当前滑动窗口中的最大值：</p><ul><li>push：当<strong>当前值</strong>小于对列尾部值时，直接插入；大于时，出队列尾部数值，直到当前值小于队列尾部数值，插入；</li><li>pop：如果滑动窗口删除的数据和队头数据一致，出队头数据（因为这是一个需要被删除的最大值）；不一致则不做任何操作；</li><li>front：获取队头数据；</li></ul><p>注意，这个单调对列只是针对本体的需求来写的。本体只是需要滑动窗口中的最大值，对于对列而言并不需要维护滑动窗口中的所有元素，只需要维护几个递减的最大值就行了。</p><blockquote><p>本题也不能用堆来实现，因为堆只能删除堆顶元素，堆顶元素不一定是滑动窗口需要移除的元素。这会导致堆内元素和当前滑动窗口内的元素不对应，会出现问题。</p></blockquote><p>使用C++的deque数据结构就可以实现一个这样的对列。deque是stack&#x2F;queue默认的底层容器，stack&#x2F;queue在C++中是<strong>容器适配器</strong>（因为它们并不是直接实现的，而是借助其他容器实现的）。deque的特性让它支持队头队尾的插入删除操作。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 单调队列（从大到小）</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyQueue</span> </span><br><span class="line">&#123; </span><br><span class="line">deque&lt;<span class="type">int</span>&gt; que; <span class="comment">// 使用deque来实现单调队列</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 每次弹出的时候，比较当前要弹出的数值是否等于队列出口元素的数值，如果相等则弹出。</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">pop</span><span class="params">(<span class="type">int</span> value)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">    <span class="comment">// 先判断是否为空再判断是否相等</span></span><br><span class="line">        <span class="keyword">if</span> (!que.<span class="built_in">empty</span>() &amp;&amp; value == que.<span class="built_in">front</span>()) </span><br><span class="line">        &#123;</span><br><span class="line">            que.<span class="built_in">pop_front</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果push的数值大于入口元素的数值，那么就将队列后端的数值弹出，直到push的数值小于等于队列入口元素的数值为止。</span></span><br><span class="line">    <span class="comment">// 这样就保持了队列里的数值是单调从大到小的了。</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(<span class="type">int</span> value)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (!que.<span class="built_in">empty</span>() &amp;&amp; value &gt; que.<span class="built_in">back</span>()) </span><br><span class="line">        &#123;</span><br><span class="line">            que.<span class="built_in">pop_back</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        que.<span class="built_in">push_back</span>(value);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 查询当前队列里的最大值，直接返回队列前端就可以了。</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">front</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> que.<span class="built_in">front</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h2><p>有了这个单调递减的对列后，我们现在只需要将vector中的元素按K滑动窗口大小往对列输入就可以了。注意，删除元素的时候要删除当前滑动窗口第一个元素，再加入新元素。</p><p>第一次遍历后需要插入一次最大值是因为<strong>第二个循环可能不会进去</strong>，而且第二个循环中会先移动窗口再插入新的最大值，如果不提前插入第一个最大值，可能会漏掉。</p><p>另外，本体限定K不会大于数组的长度，所以第一个循环用K做边界是不会数组越界的。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="comment">// 单调队列（从大到小）</span></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">MyQueue</span> </span><br><span class="line">    &#123; </span><br><span class="line">        deque&lt;<span class="type">int</span>&gt; que; <span class="comment">// 使用deque来实现单调队列</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="comment">// 每次弹出的时候，比较当前要弹出的数值是否等于队列出口元素的数值，如果相等则弹出。</span></span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">pop</span><span class="params">(<span class="type">int</span> value)</span> </span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            <span class="comment">// 先判断是否为空再判断是否相等</span></span><br><span class="line">            <span class="keyword">if</span> (!que.<span class="built_in">empty</span>() &amp;&amp; value == que.<span class="built_in">front</span>()) </span><br><span class="line">            &#123;</span><br><span class="line">                que.<span class="built_in">pop_front</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果push的数值大于入口元素的数值，那么就将队列后端的数值弹出，直到push的数值小于等于队列入口元素的数值为止。</span></span><br><span class="line">        <span class="comment">// 这样就保持了队列里的数值是单调从大到小的了。</span></span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(<span class="type">int</span> value)</span> </span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            <span class="keyword">while</span> (!que.<span class="built_in">empty</span>() &amp;&amp; value &gt; que.<span class="built_in">back</span>()) </span><br><span class="line">            &#123;</span><br><span class="line">                que.<span class="built_in">pop_back</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            que.<span class="built_in">push_back</span>(value);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 查询当前队列里的最大值，直接返回队列前端就可以了。</span></span><br><span class="line">        <span class="function"><span class="type">int</span> <span class="title">front</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> que.<span class="built_in">front</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">maxSlidingWindow</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        MyQueue que;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; retV;</span><br><span class="line">        <span class="comment">// 先把数组前k个元素送入对列</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i =<span class="number">0</span>;i&lt;k;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            que.<span class="built_in">push</span>(nums[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 先把第一个最大值插入</span></span><br><span class="line">        retV.<span class="built_in">push_back</span>(que.<span class="built_in">front</span>());</span><br><span class="line">        <span class="comment">// 然后开始移动滑动窗口</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = k;i&lt;nums.<span class="built_in">size</span>();i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 当i == k 的时候删除0，符合题目条件，不需要修改其他地方的代码</span></span><br><span class="line">            que.<span class="built_in">pop</span>(nums[i - k]); <span class="comment">// 删除滑动窗口第一个元素</span></span><br><span class="line">            que.<span class="built_in">push</span>(nums[i]); <span class="comment">// 插入新元素</span></span><br><span class="line">            <span class="comment">// 插入最大值</span></span><br><span class="line">            retV.<span class="built_in">push_back</span>(que.<span class="built_in">front</span>());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> retV;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/03/30471dcac1c94c4b6abb659af91d11f7.png" alt="image.png"></p><h1 id="The-end"><a href="#The-end" class="headerlink" title="The end"></a>The end</h1><p>单调递增&#x2F;单调递减的对列思想还是第一次遇到，学到了。</p>]]></content>
    
    
    <summary type="html">leetcode239题，滑动窗口最大值</summary>
    
    
    
    <category term="编程学习" scheme="https://blog.musnow.top/categories/%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="把题目都给刷干净" scheme="https://blog.musnow.top/categories/%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0/%E6%8A%8A%E9%A2%98%E7%9B%AE%E9%83%BD%E7%BB%99%E5%88%B7%E5%B9%B2%E5%87%80/"/>
    
    
    <category term="队列" scheme="https://blog.musnow.top/tags/%E9%98%9F%E5%88%97/"/>
    
    <category term="leetcode" scheme="https://blog.musnow.top/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>【leetcode】150.逆波兰表达式求值，以及前缀中缀后缀的相互转换</title>
    <link href="https://blog.musnow.top/posts/3211822811/"/>
    <id>https://blog.musnow.top/posts/3211822811/</id>
    <published>2024-03-13T08:33:43.000Z</published>
    <updated>2024-03-31T04:09:02.000Z</updated>
    
    <content type="html"><![CDATA[<p>本文最初写作于2022-07-18，于近日大量更新，故重新发布。</p><h1 id="1-什么是前缀-x2F-中缀-x2F-后缀表达式？"><a href="#1-什么是前缀-x2F-中缀-x2F-后缀表达式？" class="headerlink" title="1. 什么是前缀&#x2F;中缀&#x2F;后缀表达式？"></a>1. 什么是前缀&#x2F;中缀&#x2F;后缀表达式？</h1><p>我们日常学习数学，使用的表达式就是中缀表达式</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1 + 2 * 3 / 2 - 5</span><br></pre></td></tr></table></figure><p><strong>前缀表达式就是将操作符放在操作数之前的表达式</strong>；中缀转前缀的方式是，先将中缀表达式按运算顺序加上括号，再将操作符移动到对应括号的前面，最后删除括号，就是前缀表达式</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">((1 + ((2 * 3) / 2)) - 5)</span><br><span class="line">- (+(1 / (*(2 3) 2))  5)</span><br><span class="line">- + 1 / * 2 3 2 5</span><br></pre></td></tr></table></figure><p><strong>后缀表达式就是将操作符放在操作数之前的表达式</strong>；同样是加括号，再将运算符移动到括号后，再去括号</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">((1 + ((2 * 3) / 2)) - 5)</span><br><span class="line">((1 ((2 3)* 2)/) + 5) - </span><br><span class="line">1 2 3 * 2 / + 5 - </span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/03/051e1603775a69a8cb8f557b8050812d.png" alt="img"></p><p>前缀表达式又称“波兰表达式”，后缀表达式为“逆波兰表达式”。</p><h1 id="2-表达式转换"><a href="#2-表达式转换" class="headerlink" title="2. 表达式转换"></a>2. 表达式转换</h1><h2 id="2-1-中缀转后缀"><a href="#2-1-中缀转后缀" class="headerlink" title="2.1. 中缀转后缀"></a>2.1. 中缀转后缀</h2><p>中缀表达式转换为后缀表达式的手工做法为：</p><p>按照运算符的优先级对所有的运算单位加括号。例： <code>((a/b) + (((c*d) - (e*f))/g))</code><br>把运算符号移动到对应括号的后面，然后去掉括号。例：<code>((ab)/ (((cd)*(ef)*)-g)/+</code>，去掉括号<code>ab/cd*ef*-g/+</code>；</p><p>以这个中缀表达式为例</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1 + 2 * 3 / 2 - 5</span><br></pre></td></tr></table></figure><p>我们都知道，运算顺序应该是先计算<code>2*3</code>然后在计算<code>6/2</code>，最后计算<code>1+3-5</code>得出结果<code>-1</code>；</p><p>因为<code>* /</code>操作符的优先级高于加减，这里就需要注意这种情况。我们需要用一个栈来存放操作符：</p><ul><li>遇到操作数的时候 <strong>先输出</strong> 到结果表达式中;</li><li>遇到操作符，和<strong>栈顶</strong>进行比较<ul><li>如果栈为空&#x2F;操作符优先级高于栈顶，入栈；</li><li>操作符优先级低于栈顶或和栈顶相同，出栈顶操作符；</li></ul></li><li>最后将栈中的操作符全部出栈，就可以获得后缀表达式；</li></ul><p>用上面这个思路走一遍，即为下面的情况（不知道这样写的大家能不能看明白）</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2023/02/202207181221808.jpg" alt="qq_pic_merged_1658118047047"></p><p>最终得到的结果如下，即需要的后缀表达式。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1 2 3 * 2 / + 5 -</span><br></pre></td></tr></table></figure><p>我们可以用下文提到的<strong>后缀表达式计算</strong>代码测试一下这个用例，得出的结果也是<code>-1</code>，正确！</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2023/02/202207181223795.png" alt="image-20220718122342759"></p><p>如果中缀表达式中带括号咋办？</p><ul><li>遇到操作数的时候 <strong>先输出</strong> 到结果表达式中;</li><li>遇到操作符，和<strong>栈顶</strong>进行比较<ul><li>如果栈为空&#x2F;操作符优先级高于栈顶，入栈；</li><li>操作符优先级低于栈顶或和栈顶相同，出栈顶操作符；</li></ul></li><li>如果是左括号<code>(</code>，正常入栈；</li><li>遇到右括号<code>)</code>，出栈内所有操作符，直到遇到对应左括号，注意，最终的输出后缀表达式中不需要添加左括号；</li><li>最后将栈中的操作符全部出栈，就可以获得后缀表达式；</li></ul><p>简单理解，左括号的优先级低于其他运算符，右括号的优先级高于其他运算符，就可以用前文提到的基本办法来处理带括号的中缀表达式了。</p><h2 id="2-2-中缀转前缀"><a href="#2-2-中缀转前缀" class="headerlink" title="2.2. 中缀转前缀"></a>2.2. 中缀转前缀</h2><p>首先设定一个操作符栈，<strong>从右到左</strong>顺序扫描整个中缀表达式</p><ul><li>如果是操作数，则直接归入<strong>最终表达式</strong>；</li><li>如果是操作符，则检测器是否是右括号，如果是右括号，则直接将其入栈；</li><li>如果是左括号，则将栈中的操作符依次弹栈，归入<strong>最终表达式</strong>，直至遇到右括号，将右括号弹栈，处理结束；</li><li>如果是其他操作符，则检测栈顶操作符的优先级与当前操作符的优先级关系，如果栈顶操作符优先级<strong>大于</strong>当前操作符的优先级，则弹栈，并归入<strong>最终表达式</strong>，直至栈顶操作符优先级小于等于当前操作符优先级，这时将当前操作符压栈。</li><li>当扫描完毕整个中缀表达式后，检测操作符栈是否为空，如果不为空，则依次将栈中操作符弹栈，归入<strong>最终表达式</strong>。</li><li>最后，将得出的<strong>最终表达式</strong>进行<strong>逆置</strong>，就得到中缀表达式对应的前缀表达式。</li></ul><p>以下面这个中缀表达式为例</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1 + 2 * 3 / 2 - 5</span><br></pre></td></tr></table></figure><p>使用上述步骤的栈操作示意图如下</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/03/01826c0b1143896defbabb4294308a3d.png" alt="image-20240313145529611"></p><p>得到的前缀表达式如下，符合前文使用加括号法得到的结果！</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- + 1 / * 2 3 2 5</span><br></pre></td></tr></table></figure><h2 id="2-3-后缀转中缀"><a href="#2-3-后缀转中缀" class="headerlink" title="2.3. 后缀转中缀"></a>2.3. 后缀转中缀</h2><p>后缀转中缀会简单一些，因为不需要考虑括号优先级的问题。参考 <a href="https://segmentfault.com/q/1010000004546083">知否</a>;</p><p>从左往右遍历后缀表达式：</p><ul><li>如果是操作数，入栈；</li><li>如果是运算符（设符号为#），从栈顶取两个元素a和b，注意<strong>先取出来的是右操作数</strong>，将<code>&quot;( b # a )&quot;</code>这个字符串入栈。这里加括号是保证运算顺序。</li></ul><p>最终栈顶的字符串就是我们需要的前缀表达式</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1 2 3 * 2 / + 5 - </span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/03/dfd35b63103a70940878c8534ecc05a0.png" alt="image-20240313154453407"></p><p>得到的中缀表达式符合预期！虽然会有多余的括号，但运算顺序是没有问题的。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1 + 2 * 3 / 2 - 5</span><br></pre></td></tr></table></figure><p>C++代码如下，设输入的后缀表达式是有效的。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function">string <span class="title">postfix_to_infix</span><span class="params">(vector&lt;string&gt; expr)</span> </span>&#123;</span><br><span class="line">    stack&lt;string&gt; s;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; expr.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">        <span class="comment">// a number</span></span><br><span class="line">        <span class="keyword">if</span> (!expr[i].<span class="built_in">empty</span>() &amp;&amp; expr[i][<span class="number">0</span>] &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; expr[i][<span class="number">0</span>] &lt;= <span class="string">&#x27;9&#x27;</span>) &#123;</span><br><span class="line">            s.<span class="built_in">push</span>(expr[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// an operator</span></span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            string second = s.<span class="built_in">top</span>(); s.<span class="built_in">pop</span>();</span><br><span class="line">            string first = s.<span class="built_in">top</span>(); s.<span class="built_in">pop</span>();</span><br><span class="line">            s.<span class="built_in">push</span>(<span class="string">&quot;(&quot;</span> + first + expr[i] + second + <span class="string">&quot;)&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> s.<span class="built_in">top</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    vector&lt;string&gt; expr = &#123;<span class="string">&quot;3&quot;</span>, <span class="string">&quot;2&quot;</span>, <span class="string">&quot;5&quot;</span>, <span class="string">&quot;-&quot;</span>, <span class="string">&quot;6&quot;</span>, <span class="string">&quot;*&quot;</span>, <span class="string">&quot;3&quot;</span>, <span class="string">&quot;/&quot;</span>, <span class="string">&quot;+&quot;</span>&#125;;</span><br><span class="line">    <span class="comment">// output: (3+(((2-5)*6)/3))</span></span><br><span class="line">    cout &lt;&lt; <span class="built_in">postfix_to_infix</span>(expr) &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-4-前缀转后缀"><a href="#2-4-前缀转后缀" class="headerlink" title="2.4. 前缀转后缀"></a>2.4. 前缀转后缀</h2><p>依照上述后缀转前缀的思路，前缀转后缀的操作如下</p><p>从<strong>右往左</strong>遍历后缀表达式：</p><ul><li>如果是操作数，入栈；</li><li>如果是运算符（设符号为#），从栈顶取两个元素a和b，注意先取出来的是左操作数，将<code>&quot;( a # b )&quot;</code>这个字符串入栈。这里加括号是保证运算顺序。</li></ul><p>这样运算就能得到中缀表达式。这里就不做演示了。</p><h2 id="2-5-前缀-x2F-后缀转换？"><a href="#2-5-前缀-x2F-后缀转换？" class="headerlink" title="2.5. 前缀&#x2F;后缀转换？"></a>2.5. 前缀&#x2F;后缀转换？</h2><p>因为已经学会了前缀转中缀，后缀转中缀的思路，前后缀的转换用中缀做个跳板就行了。面试的时候能说出思路来就够。</p><h1 id="3-逆波兰表达式求值"><a href="#3-逆波兰表达式求值" class="headerlink" title="3. 逆波兰表达式求值"></a>3. 逆波兰表达式求值</h1><h2 id="3-1-题目来源"><a href="#3-1-题目来源" class="headerlink" title="3.1. 题目来源"></a>3.1. 题目来源</h2><p>leetcode：<a href="https://leetcode.cn/problems/evaluate-reverse-polish-notation/">150. 逆波兰表达式求值</a></p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2023/02/202207181200929.png" alt="image-20220718120022828"></p><h2 id="3-2-思路"><a href="#3-2-思路" class="headerlink" title="3.2. 思路"></a>3.2. 思路</h2><p>逆波兰表达式又称为后缀表达式</p><ul><li>中缀 <code>1 + 2 * 3</code>；</li><li>后缀 <code>1 2 3 + *</code>；</li></ul><p>题目所给的参数是后缀表达式，其操作的思路如下：</p><ul><li>从左往右遍历，遇到操作数，入栈</li><li>遇到运算符，取栈顶两个连续数据进行计算（第二个取出来的是左操作数），再将计算结果入栈</li></ul><p>看起来不难，是因为这道题已经是简化后的版本，<del>其所给后缀表达式中没有出现括号这种特殊优先级的操作</del>。新注：这里理解有误，后缀&#x2F;前缀表达式本来就是从中缀按优先级转换过来的，它们是不会包含括号的！</p><h2 id="3-3-完整代码"><a href="#3-3-完整代码" class="headerlink" title="3.3. 完整代码"></a>3.3. 完整代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//https://leetcode.cn/problems/evaluate-reverse-polish-notation/submissions/</span></span><br><span class="line"><span class="comment">//150逆波兰表达式</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">evalRPN</span><span class="params">(vector&lt;string&gt;&amp; tokens)</span> </span>&#123;</span><br><span class="line">        stack&lt;<span class="type">int</span>&gt; s;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; ch : tokens)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(ch==<span class="string">&quot;+&quot;</span>||ch==<span class="string">&quot;-&quot;</span>||ch==<span class="string">&quot;*&quot;</span>||ch==<span class="string">&quot;/&quot;</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="type">int</span> right=s.<span class="built_in">top</span>();</span><br><span class="line">                s.<span class="built_in">pop</span>();</span><br><span class="line">                <span class="type">int</span> left=s.<span class="built_in">top</span>();</span><br><span class="line">                s.<span class="built_in">pop</span>();</span><br><span class="line">                <span class="keyword">switch</span>(ch[<span class="number">0</span>])</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">case</span> <span class="string">&#x27;+&#x27;</span>:</span><br><span class="line">                        s.<span class="built_in">push</span>(left+right);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">case</span> <span class="string">&#x27;-&#x27;</span>:</span><br><span class="line">                        s.<span class="built_in">push</span>(left-right);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">case</span> <span class="string">&#x27;*&#x27;</span>:</span><br><span class="line">                        s.<span class="built_in">push</span>(left*right);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">case</span> <span class="string">&#x27;/&#x27;</span>:</span><br><span class="line">                        s.<span class="built_in">push</span>(left/right);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">default</span>:</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="comment">// 注意，题目给的vector中是字符串，需要转数字</span></span><br><span class="line">                s.<span class="built_in">push</span>(<span class="built_in">stoi</span>(ch));</span><br><span class="line">            &#125;   </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s.<span class="built_in">top</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2023/02/202207181208425.png" alt="Snipaste_2022-07-18_11-20-17"></p><p>可以使用lambda表达式来改造这个oj的代码</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">evalRPN</span><span class="params">(vector&lt;string&gt;&amp; tokens)</span> </span>&#123;</span><br><span class="line">        stack&lt;<span class="type">int</span>&gt; s;</span><br><span class="line">        map&lt;string,function&lt;<span class="type">int</span>(<span class="type">int</span>,<span class="type">int</span>)&gt;&gt; FuncMap = &#123;</span><br><span class="line">            &#123;<span class="string">&quot;+&quot;</span>,[](<span class="type">int</span> x,<span class="type">int</span> y)&#123;<span class="keyword">return</span> x+y;&#125;&#125;,</span><br><span class="line">            &#123;<span class="string">&quot;-&quot;</span>,[](<span class="type">int</span> x,<span class="type">int</span> y)&#123;<span class="keyword">return</span> x-y;&#125;&#125;,</span><br><span class="line">            &#123;<span class="string">&quot;*&quot;</span>,[](<span class="type">int</span> x,<span class="type">int</span> y)&#123;<span class="keyword">return</span> x*y;&#125;&#125;,</span><br><span class="line">            &#123;<span class="string">&quot;/&quot;</span>,[](<span class="type">int</span> x,<span class="type">int</span> y)&#123;<span class="keyword">return</span> x/y;&#125;&#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; ch : tokens)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(ch==<span class="string">&quot;+&quot;</span>||ch==<span class="string">&quot;-&quot;</span>||ch==<span class="string">&quot;*&quot;</span>||ch==<span class="string">&quot;/&quot;</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="type">int</span> right=s.<span class="built_in">top</span>();</span><br><span class="line">                s.<span class="built_in">pop</span>();</span><br><span class="line">                <span class="type">int</span> left=s.<span class="built_in">top</span>();</span><br><span class="line">                s.<span class="built_in">pop</span>();</span><br><span class="line">                <span class="type">int</span> ret = FuncMap[ch](left,right);</span><br><span class="line">                s.<span class="built_in">push</span>(ret);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                s.<span class="built_in">push</span>(<span class="built_in">stoi</span>(ch));</span><br><span class="line">            &#125;   </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s.<span class="built_in">top</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="4-前缀表达式求值"><a href="#4-前缀表达式求值" class="headerlink" title="4. 前缀表达式求值"></a>4. 前缀表达式求值</h1><p>前缀表达式的计算方法和后缀基本一致。</p><ul><li>从右往左遍历，遇到操作数，入栈；</li><li>遇到操作符，从栈顶取出两个数字进行计算，第一个取出来的数字是左操作数。计算后重新入栈。</li></ul><p>还是以下面的前缀表达式为例</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- + 1 / * 2 3 2 5</span><br></pre></td></tr></table></figure><p>从右往左遍历入栈</p><ul><li>第一波操作后，栈中包括<code>2,3,2,5</code>；</li><li>随后遇到第一个操作符<code>*</code>，从栈取出2和3进行计算，得到6，重新入栈<code>6,2,5</code>；</li><li>遇到第二个操作符<code>/</code>，从栈取出6和2进行计算，得到3，重新入栈<code>3,5</code>；</li><li>操作数1入栈，<code>1,3,5</code>；</li><li>操作符<code>+</code>，从栈中取出1和3进行计算，得到4，入栈<code>4,5</code>；</li><li>操作符<code>-</code>，从栈中取出4和5进行计算，得到最终结果<code>-1</code>；</li></ul><p>这个前缀表达式对应的中缀如下，它的计算结果也是<code>-1</code>，处理正确！</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1 + 2 * 3 / 2 - 5 = -1</span><br></pre></td></tr></table></figure><p>和后缀表达式相比，前缀表达式只有遍历顺序不同，以及从栈取数据时左右操作数位置不同，所以只需要将遍历vector的操作改成<strong>反向迭代器</strong>就可以了。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 计算前缀表达式</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">evalPN</span><span class="params">(vector&lt;string&gt;&amp; tokens)</span> </span>&#123;</span><br><span class="line">    stack&lt;<span class="type">int</span>&gt; s;</span><br><span class="line">    map&lt;string,function&lt;<span class="type">int</span>(<span class="type">int</span>,<span class="type">int</span>)&gt;&gt; FuncMap = &#123;</span><br><span class="line">        &#123;<span class="string">&quot;+&quot;</span>,[](<span class="type">int</span> x,<span class="type">int</span> y)&#123;<span class="keyword">return</span> x+y;&#125;&#125;,</span><br><span class="line">        &#123;<span class="string">&quot;-&quot;</span>,[](<span class="type">int</span> x,<span class="type">int</span> y)&#123;<span class="keyword">return</span> x-y;&#125;&#125;,</span><br><span class="line">        &#123;<span class="string">&quot;*&quot;</span>,[](<span class="type">int</span> x,<span class="type">int</span> y)&#123;<span class="keyword">return</span> x*y;&#125;&#125;,</span><br><span class="line">        &#123;<span class="string">&quot;/&quot;</span>,[](<span class="type">int</span> x,<span class="type">int</span> y)&#123;<span class="keyword">return</span> x/y;&#125;&#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">auto</span> riter = tokens.<span class="built_in">rbegin</span>();</span><br><span class="line">    <span class="keyword">for</span>(;riter != tokens.<span class="built_in">rend</span>();riter++)</span><br><span class="line">    &#123;</span><br><span class="line">        string ch = *riter;</span><br><span class="line">        <span class="keyword">if</span>(ch==<span class="string">&quot;+&quot;</span>||ch==<span class="string">&quot;-&quot;</span>||ch==<span class="string">&quot;*&quot;</span>||ch==<span class="string">&quot;/&quot;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 前缀表达式第一个取出来的是左操作数</span></span><br><span class="line">            <span class="type">int</span> left=s.<span class="built_in">top</span>();</span><br><span class="line">            s.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="type">int</span> right=s.<span class="built_in">top</span>();</span><br><span class="line">            s.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="type">int</span> ret = FuncMap[ch](left,right);</span><br><span class="line">            s.<span class="built_in">push</span>(ret);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            s.<span class="built_in">push</span>(<span class="built_in">stoi</span>(ch));</span><br><span class="line">        &#125;   </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> s.<span class="built_in">top</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用表达式进行测试，得到正确输出</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vector&lt;string&gt; v = &#123;<span class="string">&quot;-&quot;</span>,<span class="string">&quot;+&quot;</span>,<span class="string">&quot;1&quot;</span>,<span class="string">&quot;/&quot;</span>,<span class="string">&quot;*&quot;</span>,<span class="string">&quot;2&quot;</span>,<span class="string">&quot;3&quot;</span>,<span class="string">&quot;2&quot;</span> ,<span class="string">&quot;5&quot;</span>&#125;;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">evalPN</span>(v) &lt;&lt; <span class="string">&quot;\n&quot;</span>; <span class="comment">// 输出 -1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="5-The-end"><a href="#5-The-end" class="headerlink" title="5. The end"></a>5. The end</h1><p>网易雷火的面试考到了前缀表达式求值，故此更新本文</p>]]></content>
    
    
    <summary type="html">leetcode150题逆波兰表达式求值，以及前缀中缀后缀的解释和相互转换</summary>
    
    
    
    <category term="编程学习" scheme="https://blog.musnow.top/categories/%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="把题目都给刷干净" scheme="https://blog.musnow.top/categories/%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0/%E6%8A%8A%E9%A2%98%E7%9B%AE%E9%83%BD%E7%BB%99%E5%88%B7%E5%B9%B2%E5%87%80/"/>
    
    
    <category term="Cpp" scheme="https://blog.musnow.top/tags/Cpp/"/>
    
    <category term="OJ刷题" scheme="https://blog.musnow.top/tags/OJ%E5%88%B7%E9%A2%98/"/>
    
    <category term="leetcode" scheme="https://blog.musnow.top/tags/leetcode/"/>
    
  </entry>
  
</feed>
