<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>慕雪的寒舍</title>
  
  <subtitle>雪下了一夜</subtitle>
  <link href="https://blog.musnow.top/atom.xml" rel="self"/>
  
  <link href="https://blog.musnow.top/"/>
  <updated>2024-06-04T04:00:17.000Z</updated>
  <id>https://blog.musnow.top/</id>
  
  <author>
    <name>慕雪年华</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>【leetcode】516.最长回文子序列</title>
    <link href="https://blog.musnow.top/posts/2092587888/"/>
    <id>https://blog.musnow.top/posts/2092587888/</id>
    <published>2024-06-04T02:34:54.000Z</published>
    <updated>2024-06-04T04:00:17.000Z</updated>
    
    <content type="html"><![CDATA[<p>leetcode刷题笔记-516.最长回文子序列</p><h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><blockquote><p><a href="https://leetcode.cn/problems/longest-palindromic-subsequence/">https://leetcode.cn/problems/longest-palindromic-subsequence/</a></p></blockquote><p>给你一个字符串 s ，找出其中最长的回文子序列，并返回该序列的长度。</p><p>子序列定义为：不改变剩余字符顺序的情况下，删除某些字符或者不删除任何字符形成的一个序列。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">示例 1：</span><br><span class="line">输入：s = &quot;bbbab&quot;</span><br><span class="line">输出：4</span><br><span class="line">解释：一个可能的最长回文子序列为 &quot;bbbb&quot; 。</span><br><span class="line"></span><br><span class="line">示例 2：</span><br><span class="line">输入：s = &quot;cbbd&quot;</span><br><span class="line">输出：2</span><br><span class="line">解释：一个可能的最长回文子序列为 &quot;bb&quot; 。</span><br></pre></td></tr></table></figure><p>提示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1 &lt;= s.length &lt;= 1000</span><br><span class="line">s 仅由小写英文字母组成</span><br></pre></td></tr></table></figure><h1 id="思路1：最长公共子序列"><a href="#思路1：最长公共子序列" class="headerlink" title="思路1：最长公共子序列"></a>思路1：最长公共子序列</h1><p>这道题可以直接使用<a href="https://leetcode.cn/problems/longest-common-subsequence/description/">1143.最长公共子序列</a>的代码，只要把原始字符串反转一下，就变成了两个字符串中求最长公共子序列的问题了。</p><p>对于回文子序列来说，<strong>字符串翻转过后也一定和原有的回文子序列相同</strong>，所以将原始字符串翻转后就能通过最长公共子序列找到最长的回文子序列。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">longestCommonSubsequence</span><span class="params">(string a, string b)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> result = <span class="number">0</span>; <span class="comment">// 结果集初始化</span></span><br><span class="line">        <span class="comment">// dp[i][j] 代表a中i和b中j下标和下标之前的最长公共子序列的长度</span></span><br><span class="line">        <span class="comment">// i为0和j为0的情况下，长度为0的字符串是不会有公共子序列的，所以可以全部初始化为0</span></span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dp</span>(a.<span class="built_in">size</span>() + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(b.<span class="built_in">size</span>() + <span class="number">1</span>, <span class="number">0</span>));</span><br><span class="line">        <span class="comment">// 判断 a[i-1] == b[j-1] 代表公共子序列可以扩展</span></span><br><span class="line">        <span class="comment">// dp[i][j] = dp[i-1][j-1] + 1</span></span><br><span class="line">        <span class="comment">// 其他情况，代表公共子序列不能扩展，那么当前的最长公共子序列和前一位的相同</span></span><br><span class="line">        <span class="comment">// 因为是二维数组，所以“前一位”其实有两种情况，分别是i-1和j-1，用max取最大值</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= a.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= b.<span class="built_in">size</span>(); j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (a[i - <span class="number">1</span>] == b[j - <span class="number">1</span>]) &#123;</span><br><span class="line">                    dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    dp[i][j] = <span class="built_in">max</span>(dp[i - <span class="number">1</span>][j], dp[i][j - <span class="number">1</span>]);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (dp[i][j] &gt; result) &#123;</span><br><span class="line">                    result = dp[i][j];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">longestPalindromeSubseq</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        string b = s;</span><br><span class="line">        <span class="built_in">reverse</span>(b.<span class="built_in">begin</span>(), b.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">longestCommonSubsequence</span>(s, b);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>整体的时间复杂度和空间复杂度都是<code>O(N^2)</code>。</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/06/b45b953cefb2b16cca25cc24ef99c8c9.png" alt="image.png"></p><h1 id="思路2：动态规划"><a href="#思路2：动态规划" class="headerlink" title="思路2：动态规划"></a>思路2：动态规划</h1><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>有了用之前写过的题目的思路，下面还是得想一个直接写这道题的思路。总不能回避问题嘛。</p><p>因为回文的结构一般都是要从字符串中心开始向两次扩张来判断的，本题中只有一个字符串，所以不要和之前写的其他题目搞混了。</p><ul><li><code>dp[i][j]</code>代表字符串s中<code>[i,j]</code>范围内的最长回文子序列的长度。</li></ul><p>因为单个字符也可以认为是回文子序列，<strong>所以当i等于j的时候，初始化为1</strong>。对于这个dp数组，我们只需要关注<code>i&lt;j</code>的情况，所以<code>i&gt;j</code>的位置都需要初始化为0。</p><p>这里可以沿用<a href="https://blog.musnow.top/posts/1161861455">5.最长回文子串</a>的思路，当i和j相等，回文子序列扩张的时候，最长的回文子序列的长度只能比<code>[i+1,j-1]</code>的范围多一对字符（即多两个字符）。</p><p>其他情况，因为本题求的是子序列，i和j不相等代表子序列不能被扩展，但dp数组的含义是<code>[i,j]</code>范围内的最长回文子序列的长度，所以当前的值依旧需要更新为“上一个结果”的值，对应本题也是在<code>dp[i+1][j]</code>和<code>dp[i][j-1]</code>中用max选最大值。</p><p>所以，递推代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(s[i] == s[j])&#123;</span><br><span class="line">dp[i][j] = dp[i+<span class="number">1</span>][j<span class="number">-1</span>]+<span class="number">2</span>;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">dp[i][j] = <span class="built_in">max</span>(dp[i+<span class="number">1</span>][j],dp[i][j<span class="number">-1</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>根据这个递推方程，<code>dp[i][j]</code>的依赖项是<code>dp[i+1][j-1]</code>、<code>dp[i+1][j]</code>、<code>dp[i][j-1]</code>，对于一个矩阵而言，是它的左下角的部分，如下图所示。</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/06/aec771ab871e6d1863313ce24aa511c8.png" alt="image.png"></p><p>根据依赖关系，我们遍历的时候，需要从i开始<strong>倒序遍历</strong>；因为依赖项中有<code>j-1</code>，所以j是<strong>正序遍历</strong>。</p><p>遍历顺序确定了，维护一个最大值，或者直接返回<code>dp[0][s.size()-1]</code>即为本题所求结果。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>完整代码如下。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">longestPalindromeSubseq</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = s.<span class="built_in">size</span>();</span><br><span class="line">        <span class="comment">// dp[i][j]代表s中[i,j]范围内最长公共子序列的长度</span></span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dp</span>(n, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(n, <span class="number">0</span>));</span><br><span class="line">        <span class="comment">// i和j相等的情况初始化为1</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            dp[i][i] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 开始递推</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="comment">// j 必须大于i</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = i + <span class="number">1</span>; j &lt; n; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (s[i] == s[j]) &#123;</span><br><span class="line">                    dp[i][j] = dp[i + <span class="number">1</span>][j - <span class="number">1</span>] + <span class="number">2</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    dp[i][j] = <span class="built_in">max</span>(dp[i + <span class="number">1</span>][j], dp[i][j - <span class="number">1</span>]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">0</span>][n - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/06/7f13895038a74d9db8a418a82698f5c0.png" alt="image.png"></p>]]></content>
    
    
    <summary type="html">leetcode刷题笔记-516.最长回文子序列</summary>
    
    
    
    <category term="编程学习" scheme="https://blog.musnow.top/categories/%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="把题目都给刷干净" scheme="https://blog.musnow.top/categories/%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0/%E6%8A%8A%E9%A2%98%E7%9B%AE%E9%83%BD%E7%BB%99%E5%88%B7%E5%B9%B2%E5%87%80/"/>
    
    
    <category term="OJ刷题" scheme="https://blog.musnow.top/tags/OJ%E5%88%B7%E9%A2%98/"/>
    
    <category term="leetcode" scheme="https://blog.musnow.top/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>【leetcode】1143.最长公共子序列</title>
    <link href="https://blog.musnow.top/posts/1438517746/"/>
    <id>https://blog.musnow.top/posts/1438517746/</id>
    <published>2024-06-01T07:46:40.000Z</published>
    <updated>2024-06-04T02:49:08.000Z</updated>
    
    <content type="html"><![CDATA[<p>leetcode刷题笔记-1143.最长公共子序列</p><h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><blockquote><p><a href="https://leetcode.cn/problems/longest-common-subsequence/description/">https://leetcode.cn/problems/longest-common-subsequence/description/</a></p></blockquote><p>给定两个字符串 text1 和 text2，返回这两个字符串的最长 公共子序列 的长度。如果不存在 公共子序列 ，返回 0 。</p><p>一个字符串的 子序列 是指这样一个新的字符串：它是由原字符串在不改变字符的相对顺序的情况下删除某些字符（也可以不删除任何字符）后组成的新字符串。</p><p>例如，”ace” 是 “abcde” 的子序列，但 “aec” 不是 “abcde” 的子序列。</p><p>两个字符串的 公共子序列 是这两个字符串所共同拥有的子序列。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">示例 1：</span><br><span class="line">输入：text1 = &quot;abcde&quot;, text2 = &quot;ace&quot; </span><br><span class="line">输出：3  </span><br><span class="line">解释：最长公共子序列是 &quot;ace&quot; ，它的长度为 3 。</span><br><span class="line"></span><br><span class="line">示例 2：</span><br><span class="line">输入：text1 = &quot;abc&quot;, text2 = &quot;abc&quot;</span><br><span class="line">输出：3</span><br><span class="line">解释：最长公共子序列是 &quot;abc&quot; ，它的长度为 3 。</span><br><span class="line"></span><br><span class="line">示例 3：</span><br><span class="line">输入：text1 = &quot;abc&quot;, text2 = &quot;def&quot;</span><br><span class="line">输出：0</span><br><span class="line">解释：两个字符串没有公共子序列，返回 0 。</span><br></pre></td></tr></table></figure><p>提示</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1 &lt;= text1.length, text2.length &lt;= 1000</span><br><span class="line">text1 和 text2 仅由小写英文字符组成。</span><br></pre></td></tr></table></figure><h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p>这道题和<a href="https://leetcode.cn/problems/maximum-length-of-repeated-subarray/description/">718. 最长重复子数组</a>的区别在于，718要求的是连续的子序列，而本题不要求子序列连续，就不是让你算子数组了。</p><p>虽然题目给出的是字符串，但本质上我们可以把它当作数组来处理，没有区别。</p><ul><li><code>dp[i][j]</code>代表字符串a中<code>i-1</code>和字符串b中<code>j-1</code>下标<strong>之前</strong>的最长公共子序列的长度。</li></ul><p>这样做就可以不对数组提前进行初始化了，因为<code>dp[0][x]</code>和<code>dp[x][0]</code>都是没有意义的。因为不会存在以下标<code>-1</code>为结尾的字符串，也自然没有公共子序列。换句话说，<strong>长度为0</strong>的字符串是不会有公共子序列的。</p><p>依照dp数组，可以想出递推的公式，当<code>a[i-1]</code>和<code>b[j-1]</code>相同的时候，就说明子序列可以被扩展，<code>dp[i][j] == dp[i-1][j-1]+1</code>。</p><p>如果不相同，则代表子序列断了，但注意我们dp数组的含义，它代表的是i-1和j-1之前的最长公共子序列的长度，即便i-1和j-1不相等，这个最长公共子序列依旧是有一个取值的，即选用“前一位”的公共子序列长度最大值。</p><p>但由于dp是一个二维数组，这里的“前一位”就有两个情况了，分别是<code>dp[i-1][j]</code>和<code>dp[i][j-1]</code>，对应含义是字符串a中前一位（根据dp数组，下标是i-1，公共子序列的含义是i-2）和<code>b[j-1]</code>能构成的最长公共子序列，以及字符串b中前一位和<code>a[i-1]</code>能构成的最长公共子序列的长度。<strong>需要用max来选取二者的最大值</strong>。</p><p>递推的代码如下。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (a[i - <span class="number">1</span>] == b[j - <span class="number">1</span>]) &#123;</span><br><span class="line">dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">dp[i][j] = <span class="built_in">max</span>(dp[i - <span class="number">1</span>][j], dp[i][j - <span class="number">1</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>根据递推公式，<code>dp[i][j]</code>的值可以从dp数组中的三个方向推导出来，如下图所示。</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/06/4796284855ff7814090f5f198e5eaedd.png" alt="image.png"></p><p>剩下的代码就很简单了，因为我们不需要对dp数组进行提前初始化，直接用vector构造函数统一初始化为0就可以了，然后从1开始遍历直到字符串末尾，维护一个最大值，返回即可。</p><p>其实不维护最大值也是可以的，因为根据dp数组的定义，<code>dp[a.size()][b.size()]</code>就是我们需要的最大值。</p><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><p>完整的代码如下，具体参考注释中的说明。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">longestCommonSubsequence</span><span class="params">(string a, string b)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> result = <span class="number">0</span>; <span class="comment">// 结果集初始化</span></span><br><span class="line">        <span class="comment">// dp[i][j] 代表a中i和b中j下标和下标之前的最长公共子序列的长度</span></span><br><span class="line">        <span class="comment">// i为0和j为0的情况下，长度为0的字符串是不会有公共子序列的，所以可以全部初始化为0</span></span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dp</span>(a.<span class="built_in">size</span>() + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(b.<span class="built_in">size</span>() + <span class="number">1</span>, <span class="number">0</span>));</span><br><span class="line">        <span class="comment">// 判断 a[i-1] == b[j-1] 代表公共子序列可以扩展</span></span><br><span class="line">        <span class="comment">// dp[i][j] = dp[i-1][j-1] + 1</span></span><br><span class="line">        <span class="comment">// 其他情况，代表公共子序列不能扩展，那么当前的最长公共子序列和前一位的相同</span></span><br><span class="line">        <span class="comment">// 因为是二维数组，所以“前一位”其实有两种情况，分别是i-1和j-1，用max取最大值</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= a.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= b.<span class="built_in">size</span>(); j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (a[i - <span class="number">1</span>] == b[j - <span class="number">1</span>]) &#123;</span><br><span class="line">                    dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    dp[i][j] = <span class="built_in">max</span>(dp[i - <span class="number">1</span>][j], dp[i][j - <span class="number">1</span>]);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (dp[i][j] &gt; result) &#123;</span><br><span class="line">                    result = dp[i][j];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/06/fc86ae51ad0f984572360fc94f373acf.png"></p>]]></content>
    
    
    <summary type="html">leetcode刷题笔记-1143.最长公共子序列</summary>
    
    
    
    <category term="编程学习" scheme="https://blog.musnow.top/categories/%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="把题目都给刷干净" scheme="https://blog.musnow.top/categories/%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0/%E6%8A%8A%E9%A2%98%E7%9B%AE%E9%83%BD%E7%BB%99%E5%88%B7%E5%B9%B2%E5%87%80/"/>
    
    
    <category term="OJ刷题" scheme="https://blog.musnow.top/tags/OJ%E5%88%B7%E9%A2%98/"/>
    
    <category term="leetcode" scheme="https://blog.musnow.top/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>【leetcode】718. 最长重复子数组</title>
    <link href="https://blog.musnow.top/posts/1636801435/"/>
    <id>https://blog.musnow.top/posts/1636801435/</id>
    <published>2024-05-31T07:22:41.000Z</published>
    <updated>2024-06-04T02:37:50.000Z</updated>
    
    <content type="html"><![CDATA[<p>leetcode刷题笔记-718. 最长重复子数组</p><h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><blockquote><p><a href="https://leetcode.cn/problems/maximum-length-of-repeated-subarray/description/">https://leetcode.cn/problems/maximum-length-of-repeated-subarray/description/</a></p></blockquote><p>给两个整数数组 nums1 和 nums2 ，返回 两个数组中 公共的 、长度最长的子数组的长度 。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">示例 1：</span><br><span class="line">输入：nums1 = [1,2,3,2,1], nums2 = [3,2,1,4,7]</span><br><span class="line">输出：3</span><br><span class="line">解释：长度最长的公共子数组是 [3,2,1] 。</span><br><span class="line"></span><br><span class="line">示例 2：</span><br><span class="line">输入：nums1 = [0,0,0,0,0], nums2 = [0,0,0,0,0]</span><br><span class="line">输出：5</span><br></pre></td></tr></table></figure><p>提示</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1 &lt;= nums1.length, nums2.length &lt;= 1000</span><br><span class="line">0 &lt;= nums1[i], nums2[i] &lt;= 100</span><br></pre></td></tr></table></figure><p>子数组其实就是连续的子序列。</p><h1 id="思路1"><a href="#思路1" class="headerlink" title="思路1"></a>思路1</h1><h2 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h2><p>依旧是用动态规划的思路，dp数组肯定需要一个二维的了，之前写过最长递增子序列，当时用的dp数组下标的含义是以j下标为结尾的最长递增子序列的长度。本题也是一样的思路</p><ul><li><code>dp[i][j]</code>代表数组1中以i结尾，数组2中以j结尾的最长公共子数组的长度（包括i和j）；</li></ul><p>根据这个定义，可以推算出递推公式，当 <code>nums1[i] == nums2[j]</code> 的时候，说明子数组可以被扩张，此时<code>dp[i][j] = dp[i-1][j-1] +1</code>，含义是当前的最长公共子数组的长度是前一位的最长公共子数组的长度加一（加上当前位）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(nums1[i] == nums2[j]) &#123;</span><br><span class="line">dp[i][j] = dp[i<span class="number">-1</span>][j<span class="number">-1</span>] + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们需要对这个dp数组进行初始化，需要初始化第一列和第一行，代码如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums1.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line"><span class="comment">// 第一个数组中的元素是否在第二个数组中第一位</span></span><br><span class="line"><span class="comment">// 在第一位说明最长公共子数组长度是1</span></span><br><span class="line"><span class="keyword">if</span> (nums1[i] == nums2[<span class="number">0</span>]) &#123;</span><br><span class="line">dp[i][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; nums2.<span class="built_in">size</span>(); j++) &#123;</span><br><span class="line"><span class="comment">// 第一个数组中的元素是否在第二个数组中第一位</span></span><br><span class="line"><span class="comment">// 在第一位说明最长公共子数组长度是1</span></span><br><span class="line"><span class="keyword">if</span> (nums2[j] == nums1[<span class="number">0</span>]) &#123;</span><br><span class="line">dp[<span class="number">0</span>][j] = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h2><p>随后就是i和j都从1开始遍历了，更新出一个最大值返回就可以了。完整代码如下。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">findLength</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums1, vector&lt;<span class="type">int</span>&gt;&amp; nums2)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// DP 以i和j结尾的元素最长的子数组的长度</span></span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dp</span>(nums1.<span class="built_in">size</span>(), <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(nums2.<span class="built_in">size</span>(), <span class="number">0</span>));</span><br><span class="line">        <span class="comment">// 我们要对第一行和第一列进行初始化</span></span><br><span class="line">        <span class="comment">// 判断第二个数组中是否出现了第一个数组中的元素，出现了就算是公共子数组</span></span><br><span class="line">        <span class="type">bool</span> contains = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums1.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="comment">// 第一个数组中的元素是否在第二个数组中第一位</span></span><br><span class="line">            <span class="comment">// 在第一位说明最长公共子数组长度是1</span></span><br><span class="line">            <span class="keyword">if</span> (nums1[i] == nums2[<span class="number">0</span>]) &#123;</span><br><span class="line">                dp[i][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">                contains = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; nums2.<span class="built_in">size</span>(); j++) &#123;</span><br><span class="line">            <span class="comment">// 第一个数组中的元素是否在第二个数组中第一位</span></span><br><span class="line">            <span class="comment">// 在第一位说明最长公共子数组长度是1</span></span><br><span class="line">            <span class="keyword">if</span> (nums2[j] == nums1[<span class="number">0</span>]) &#123;</span><br><span class="line">                dp[<span class="number">0</span>][j] = <span class="number">1</span>;</span><br><span class="line">                contains = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> result =</span><br><span class="line">            contains</span><br><span class="line">                ? <span class="number">1</span></span><br><span class="line">                : <span class="number">0</span>; <span class="comment">// 如果之前初始化的时候有相同的，那么就设置为1，没有就设置为0</span></span><br><span class="line">        <span class="comment">// 开始遍历，递推思路：如果当前两位相等，那么最长子数组长度就是前一位的子数组长度+1</span></span><br><span class="line">        <span class="comment">// 相当于是以i-1和j-1结尾的最长公共子数组的长度+1</span></span><br><span class="line">        <span class="comment">// dp[i][j] = dp[i-1][j-1]+1</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; nums1.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt; nums2.<span class="built_in">size</span>(); j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (nums1[i] == nums2[j]) &#123;</span><br><span class="line">                    dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (dp[i][j] &gt; result) &#123;</span><br><span class="line">                    result = dp[i][j];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>时间复杂度和空间复杂度都是<code>O(N^2)</code>；</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/05/a85f5e59980b419decd2d827832105a8.png" alt="image.png"></p><h1 id="思路2"><a href="#思路2" class="headerlink" title="思路2"></a>思路2</h1><h2 id="说明-1"><a href="#说明-1" class="headerlink" title="说明"></a>说明</h2><p>上文的思路中，dp数组下标的含义是以i和j结尾的最长公共子序列的长度。我们可以将其改成<code>dp[i][j]</code>代表以i-1和j-1结尾的最长重复子数组的长度。</p><p>这样做就可以不对数组提前进行初始化了，因为<code>dp[0][x]</code> 和<code>dp[x][0]</code>都是没有意义的。</p><p>基本思路都是一致的，只不过递推方程的判断改为判断<code>nums1[i-1] == nums2[j-1]</code>了，另外dp数组的长度也需要加一。</p><p>完整代码如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">findLength</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums1, vector&lt;<span class="type">int</span>&gt;&amp; nums2)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// DP 以i和j结尾的元素最长的子数组的长度</span></span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dp</span>(nums1.<span class="built_in">size</span>() + <span class="number">1</span>,</span><br><span class="line">                               <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(nums2.<span class="built_in">size</span>() + <span class="number">1</span>, <span class="number">0</span>));</span><br><span class="line">        <span class="comment">// 开始遍历，递推思路：如果i,j前两位相等，那么最长子数组长度就是前一位的子数组长度+1</span></span><br><span class="line">        <span class="comment">// 相当于是以i-1和j-1结尾的最长公共子数组的长度+1</span></span><br><span class="line">        <span class="comment">// dp[i][j] = dp[i-1][j-1]+1</span></span><br><span class="line">        <span class="type">int</span> result = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; dp.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt; dp[<span class="number">0</span>].<span class="built_in">size</span>(); j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (nums1[i - <span class="number">1</span>] == nums2[j - <span class="number">1</span>]) &#123;</span><br><span class="line">                    dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (dp[i][j] &gt; result) &#123;</span><br><span class="line">                    result = dp[i][j];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/05/220747fbd31883d92fa3f5e74dbe2ced.png" alt="image.png"></p><h2 id="压缩为一维数组"><a href="#压缩为一维数组" class="headerlink" title="压缩为一维数组"></a>压缩为一维数组</h2><p>这道题中的dp递推方程每次都只和<code>[i-1][j-1]</code>有关系，所以可以将二维数组直接压缩为一维，倒叙遍历j就可以沿用上一层dp的结果了，代码如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">findLength</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums1, vector&lt;<span class="type">int</span>&gt;&amp; nums2)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// DP 以i和j结尾的元素最长的子数组的长度</span></span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(nums2.size() + <span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="comment">// 开始遍历，递推思路：如果i,j前两位相等，那么最长子数组长度就是前一位的子数组长度+1</span></span><br><span class="line">        <span class="comment">// 相当于是以i-1和j-1结尾的最长公共子数组的长度+1</span></span><br><span class="line">        <span class="comment">// dp[i][j] = dp[i-1][j-1]+1</span></span><br><span class="line">        <span class="type">int</span> result = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 注意这里是从1遍历到=nums1.size()的位置</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= nums1.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = nums2.<span class="built_in">size</span>(); j &gt;= <span class="number">1</span>; j--) &#123;</span><br><span class="line">                <span class="keyword">if</span> (nums1[i - <span class="number">1</span>] == nums2[j - <span class="number">1</span>]) &#123;</span><br><span class="line">                    dp[j] = dp[j - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// 不相等需要把这一位设置为初始值（就好比二维矩阵中的初始值）</span></span><br><span class="line">                    dp[j] = <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (dp[j] &gt; result) &#123;</span><br><span class="line">                    result = dp[j];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/05/c17dc641583ca7e326b0467e6c992d7f.png" alt="image.png"></p><h1 id="类似题目"><a href="#类似题目" class="headerlink" title="类似题目"></a>类似题目</h1><h2 id="1143-最长公共子序列"><a href="#1143-最长公共子序列" class="headerlink" title="1143. 最长公共子序列"></a>1143. 最长公共子序列</h2><p>这道题要求是最长的公共子序列，就不是让你算子数组了。虽然题目给出的是字符串，但本质上我们可以把它当作数组来处理，没有区别。</p><p>完整的代码如下，采用的是思路2，具体参考注释中的说明。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">longestCommonSubsequence</span><span class="params">(string a, string b)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> result = <span class="number">0</span>; <span class="comment">// 结果集初始化</span></span><br><span class="line">        <span class="comment">// dp[i][j] 代表a中i和b中j下标和下标之前的最长公共子序列的长度</span></span><br><span class="line">        <span class="comment">// i为0和j为0的情况下，长度为0的字符串是不会有公共子序列的，所以可以全部初始化为0</span></span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dp</span>(a.<span class="built_in">size</span>() + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(b.<span class="built_in">size</span>() + <span class="number">1</span>, <span class="number">0</span>));</span><br><span class="line">        <span class="comment">// 判断 a[i-1] == b[j-1] 代表公共子序列可以扩展</span></span><br><span class="line">        <span class="comment">// dp[i][j] = dp[i-1][j-1] + 1</span></span><br><span class="line">        <span class="comment">// 其他情况，代表公共子序列不能扩展，那么当前的最长公共子序列和前一位的相同</span></span><br><span class="line">        <span class="comment">// 因为是二维数组，所以“前一位”其实有两种情况，分别是i-1和j-1，用max取最大值</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= a.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= b.<span class="built_in">size</span>(); j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (a[i - <span class="number">1</span>] == b[j - <span class="number">1</span>]) &#123;</span><br><span class="line">                    dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    dp[i][j] = <span class="built_in">max</span>(dp[i - <span class="number">1</span>][j], dp[i][j - <span class="number">1</span>]);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (dp[i][j] &gt; result) &#123;</span><br><span class="line">                    result = dp[i][j];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/06/fc86ae51ad0f984572360fc94f373acf.png"></p>]]></content>
    
    
    <summary type="html">leetcode刷题笔记-718. 最长重复子数组</summary>
    
    
    
    <category term="编程学习" scheme="https://blog.musnow.top/categories/%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="把题目都给刷干净" scheme="https://blog.musnow.top/categories/%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0/%E6%8A%8A%E9%A2%98%E7%9B%AE%E9%83%BD%E7%BB%99%E5%88%B7%E5%B9%B2%E5%87%80/"/>
    
    
    <category term="OJ刷题" scheme="https://blog.musnow.top/tags/OJ%E5%88%B7%E9%A2%98/"/>
    
    <category term="leetcode" scheme="https://blog.musnow.top/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>【leetcode】674.最长连续递增序列</title>
    <link href="https://blog.musnow.top/posts/3365284395/"/>
    <id>https://blog.musnow.top/posts/3365284395/</id>
    <published>2024-05-30T02:10:25.000Z</published>
    <updated>2024-05-30T02:38:53.000Z</updated>
    
    <content type="html"><![CDATA[<p>leetcode刷题笔记-674.最长连续递增序列。</p><h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><blockquote><p><a href="https://leetcode.cn/problems/longest-continuous-increasing-subsequence/">https://leetcode.cn/problems/longest-continuous-increasing-subsequence/</a></p></blockquote><p>给定一个未经排序的整数数组，找到最长且 连续递增的子序列，并返回该序列的长度。</p><p>连续递增的子序列 可以由两个下标 l 和 r（l &lt; r）确定，如果对于每个 <code>l &lt;= i &lt; r</code>，都有 <code>nums[i] &lt; nums[i + 1]</code> ，那么子序列 <code>[nums[l], nums[l + 1], ..., nums[r - 1], nums[r]]</code> 就是连续递增子序列。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">示例 1：</span><br><span class="line">输入：nums = [1,3,5,4,7]</span><br><span class="line">输出：3</span><br><span class="line">解释：最长连续递增序列是 [1,3,5], 长度为3。</span><br><span class="line">尽管 [1,3,5,7] 也是升序的子序列, 但它不是连续的，因为 5 和 7 在原数组里被 4 隔开。 </span><br><span class="line"></span><br><span class="line">示例 2：</span><br><span class="line">输入：nums = [2,2,2,2,2]</span><br><span class="line">输出：1</span><br><span class="line">解释：最长连续递增序列是 [2], 长度为1。</span><br></pre></td></tr></table></figure><p>提示</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1 &lt;= nums.length &lt;= 104</span><br><span class="line">-109 &lt;= nums[i] &lt;= 109</span><br></pre></td></tr></table></figure><h1 id="思路和代码"><a href="#思路和代码" class="headerlink" title="思路和代码"></a>思路和代码</h1><p>这道题相比<a href="https://leetcode.cn/problems/longest-increasing-subsequence/description/">300.最长递增子序列</a>多了一个连续的要求，这样一来思路其实就简单多了。</p><p>定义dp数组含义为i和i之前的最长递增子序列的长度（准确来说是以i为结尾的最长递增子序列的长度，子序列开始的下标不确定）</p><p>我们只需要判断当前位是不是比前一位大，如果比前一位大，那么就可以沿用之前的结果</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(nums[i] &gt; nums[i<span class="number">-1</span>])&#123;</span><br><span class="line">dp[i] = dp[i<span class="number">-1</span>]+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样就能很容易的写出代码来，时间和空间复杂度都是<code>O(N)</code>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">findLengthOfLCIS</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> ret = <span class="number">1</span>; <span class="comment">// 结果长度</span></span><br><span class="line">        <span class="comment">// 最开始的时候，每一位的最长子序列认为是它自己</span></span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(nums.size(), <span class="number">1</span>)</span></span>;</span><br><span class="line">        <span class="comment">// 从1开始遍历，因为0只有一个元素，没有意义</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; nums.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="comment">// 因为要求连续，所以只需要判断前一位就够了。</span></span><br><span class="line">            <span class="keyword">if</span>(nums[i] &gt; nums[i<span class="number">-1</span>])&#123;</span><br><span class="line">                dp[i] = dp[i<span class="number">-1</span>]+<span class="number">1</span>; </span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 更新结果最大值</span></span><br><span class="line">            <span class="keyword">if</span> (dp[i] &gt; ret) &#123;</span><br><span class="line">                ret = dp[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/05/213cf8eb8a3a43d87cf44919809169c1.png" alt="image.png"></p><h1 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h1><p>这个代码可以进行优化，因为每一次的递推只和前一个数字有关系，我们直接用一个变量来记录就够了，空间复杂度降低为<code>O(1)</code>。</p><p>这样做就有点类似<strong>贪心</strong>的思路，我们认为当前位大于前一位就是一个上升子序列的局部最优，最终的全局最优就是找到一个最长的连续上升子序列。官方的贪心题解本质上和下面的写法是一样的思路。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">findLengthOfLCIS</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> ret = <span class="number">1</span>; <span class="comment">// 结果长度</span></span><br><span class="line">        <span class="type">int</span> cur = <span class="number">1</span>; <span class="comment">// 当前的长度</span></span><br><span class="line">        <span class="comment">// 从1开始遍历，因为0只有一个元素，没有意义</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; nums.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="comment">// 因为要求连续，所以只需要判断前一位就够了。</span></span><br><span class="line">            <span class="keyword">if</span> (nums[i] &gt; nums[i - <span class="number">1</span>]) &#123;</span><br><span class="line">                cur = cur + <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                cur = <span class="number">1</span>; <span class="comment">// 其他情况，重置为1，重新开始计算</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 更新结果最大值</span></span><br><span class="line">            <span class="keyword">if</span> (cur &gt; ret) &#123;</span><br><span class="line">                ret = cur;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/05/3b3aa2b543bf4840c1b1a11273eb50f2.png" alt="image.png"></p><p>顺带贴一下官方题解的贪心代码</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">findLengthOfLCIS</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> start = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i &gt; <span class="number">0</span> &amp;&amp; nums[i] &lt;= nums[i - <span class="number">1</span>]) &#123;</span><br><span class="line">                start = i;</span><br><span class="line">            &#125;</span><br><span class="line">            ans = <span class="built_in">max</span>(ans, i - start + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 作者：力扣官方题解</span></span><br><span class="line"><span class="comment">// 链接：https://leetcode.cn/problems/longest-continuous-increasing-subsequence/solutions/573383/zui-chang-lian-xu-di-zeng-xu-lie-by-leet-dmb8/</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">leetcode刷题笔记-674.最长连续递增序列</summary>
    
    
    
    <category term="编程学习" scheme="https://blog.musnow.top/categories/%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="把题目都给刷干净" scheme="https://blog.musnow.top/categories/%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0/%E6%8A%8A%E9%A2%98%E7%9B%AE%E9%83%BD%E7%BB%99%E5%88%B7%E5%B9%B2%E5%87%80/"/>
    
    
    <category term="OJ刷题" scheme="https://blog.musnow.top/tags/OJ%E5%88%B7%E9%A2%98/"/>
    
    <category term="leetcode" scheme="https://blog.musnow.top/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>【leetcode】300.最长递增子序列</title>
    <link href="https://blog.musnow.top/posts/3118298969/"/>
    <id>https://blog.musnow.top/posts/3118298969/</id>
    <published>2024-05-30T01:32:50.000Z</published>
    <updated>2024-05-30T02:09:59.000Z</updated>
    
    <content type="html"><![CDATA[<p>leetcode刷题笔记-300.最长递增子序列。</p><h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><blockquote><p><a href="https://leetcode.cn/problems/longest-increasing-subsequence/description/">https://leetcode.cn/problems/longest-increasing-subsequence/description/</a></p></blockquote><p>给你一个整数数组 nums ，找到其中最长严格递增子序列的长度。</p><p>子序列 是由数组派生而来的序列，删除（或不删除）数组中的元素而不改变其余元素的顺序。例如，<code>[3,6,2,7]</code> 是数组 <code>[0,3,1,6,2,2,7]</code> 的子序列。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">示例 1：</span><br><span class="line">输入：nums = [10,9,2,5,3,7,101,18]</span><br><span class="line">输出：4</span><br><span class="line">解释：最长递增子序列是 [2,3,7,101]，因此长度为 4 。</span><br><span class="line"></span><br><span class="line">示例 2：</span><br><span class="line">输入：nums = [0,1,0,3,2,3]</span><br><span class="line">输出：4</span><br><span class="line"></span><br><span class="line">示例 3：</span><br><span class="line">输入：nums = [7,7,7,7,7,7,7]</span><br><span class="line">输出：1</span><br></pre></td></tr></table></figure><p>提示</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1 &lt;= nums.length &lt;= 2500</span><br><span class="line">-104 &lt;= nums[i] &lt;= 104</span><br></pre></td></tr></table></figure><h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p>先理解题目说的两个概念</p><ol><li>严格递增：<code>[1,2,3,4]</code>是严格递增，<code>[1,2,2,3]</code>不是严格递增；</li><li>子序列：数组中的一部分，删除某些元素后得到的序列，比如<code>[1,2,3]</code>数组，删除2后可以得到子序列<code>1,3</code>，也可以不删除元素<code>1,2,3</code>也是它的子序列。但是<code>3,1</code>或者<code>2,1</code>都不是这个数组的子序列，因为元素的顺序和源数组中元素的顺序不一致；</li></ol><p>了解定义了，就可以上动态规划的思路了。</p><p>我们定义dp数组的含义为源数组中下标i和i之前的最长递增子序列的长度（这一点和第五题最长回文子串的思路类似）。易得dp数组应该全部初始化为1，即认为最开始的时候，每一位之前的最长递增子序列是他自己。</p><p>那么递推方程应该是咋样的呢？分为两种情况</p><ul><li>当前位元素大于前一位，那么当前的最长子序列长度应该是前一位的最长子序列长度+1；</li><li>当前位元素小于前一位，说明不能沿用之前的结果，当前的最长子序列长度得保持不变；</li></ul><p>可得递推公式<code>dp[i] = max(dp[i], dp[j] + 1)</code>，判断逻辑如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(nums[i] &gt; nums[i<span class="number">-1</span>])&#123;</span><br><span class="line"><span class="comment">// 大于，沿用之前的结果</span></span><br><span class="line">dp[i] = <span class="built_in">max</span>(dp[i],dp[i<span class="number">-1</span>]+<span class="number">1</span>);</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line"><span class="comment">// 小于或者等于，不对dp[i]操作</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是这样判断还不够，因为子序列是允许删除某些元素的，对于遍历一个数组而言，<strong>它就是允许遍历不连续</strong>，所以我们需要用两层循环来处理，外层循环i从1开始遍历nums数组（从0开始没有意义），内层循环j从0开始遍历到i-1。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i&lt;nums.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>;j&lt;i;j++)&#123;</span><br><span class="line"><span class="keyword">if</span>(nums[i] &gt; nums[j])&#123;</span><br><span class="line"><span class="comment">// 大于，沿用之前的结果</span></span><br><span class="line">dp[i] = <span class="built_in">max</span>(dp[i],dp[j]+<span class="number">1</span>);</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line"><span class="comment">// 小于或者等于，不对dp[i]操作</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为什么我们需要用max来计算呢？因为每一次对i的递推都需要遍历i之前的所有元素才能递推出来，可能会出现前面某一位的最长递增子序列结果更大的情况，我们必须要保证得到的是最长的那一个子序列值。</p><p>同时，我们的遍历是从左往右的，当遍历到i的时候，i之前的那些元素在dp里面已经被正常计算出来最长的子序列长度了，所以我们只需要判断一次<code>nums[i] &gt; nums[j]</code>，就可以沿用之前的结果了。</p><h1 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h1><p>现在就可以写最终的代码了</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">lengthOfLIS</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> ret = <span class="number">1</span>;<span class="comment">// 结果长度</span></span><br><span class="line">        <span class="comment">// 最开始的时候，每一位的最长子序列认为是它自己</span></span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(nums.size(),<span class="number">1</span>)</span></span>;</span><br><span class="line">        <span class="comment">// 从1开始遍历，因为0只有一个元素，没有意义</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; nums.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; i; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (nums[i] &gt; nums[j]) &#123;</span><br><span class="line">                    <span class="comment">// 大于，沿用之前的结果</span></span><br><span class="line">                    dp[i] = <span class="built_in">max</span>(dp[i], dp[j] + <span class="number">1</span>);</span><br><span class="line">                &#125; </span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 更新结果最大值</span></span><br><span class="line">            <span class="keyword">if</span>(dp[i] &gt; ret)&#123;</span><br><span class="line">                ret = dp[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>时间复杂度是<code>O(n^2)</code>，空间复杂度是<code>O(n)</code>。</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/05/c1bf520c0b26f08b2835e7c311cfb071.png" alt="image.png"></p><p>和这道题类似的是 <a href="https://leetcode.cn/problems/longest-continuous-increasing-subsequence/description/">674. 最长连续递增序列</a>，其中要求子序列必须是连续的，中间不能中断。我会在另外一篇博客中写674的题解。</p>]]></content>
    
    
    <summary type="html">leetcode刷题笔记-300.最长递增子序列</summary>
    
    
    
    <category term="编程学习" scheme="https://blog.musnow.top/categories/%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="把题目都给刷干净" scheme="https://blog.musnow.top/categories/%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0/%E6%8A%8A%E9%A2%98%E7%9B%AE%E9%83%BD%E7%BB%99%E5%88%B7%E5%B9%B2%E5%87%80/"/>
    
    
    <category term="OJ刷题" scheme="https://blog.musnow.top/tags/OJ%E5%88%B7%E9%A2%98/"/>
    
    <category term="leetcode" scheme="https://blog.musnow.top/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>【leetcode】5.最长回文子串</title>
    <link href="https://blog.musnow.top/posts/1161861455/"/>
    <id>https://blog.musnow.top/posts/1161861455/</id>
    <published>2024-05-28T01:16:43.000Z</published>
    <updated>2024-05-30T01:30:16.000Z</updated>
    
    <content type="html"><![CDATA[<p>leetcode刷题笔记-5.最长回文子串。这么经典的题目我竟然现在才刷，懒虫一个。</p><blockquote><p>参考：<a href="https://writings.sh/post/algorithm-longest-palindromic-substring">https://writings.sh/post/algorithm-longest-palindromic-substring</a></p></blockquote><h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><blockquote><p><a href="https://leetcode.cn/problems/longest-palindromic-substring/description/">https://leetcode.cn/problems/longest-palindromic-substring/description/</a></p></blockquote><p>给你一个字符串 s，找到 s 中最长的回文子串。</p><p>回文字符串：从前往后和从后往前读的结果完全一致，比如aba；</p><p>子串：字符串s中的一部分称之为子串。与之区别的是<code>子序列</code>，子序列是不改变剩余字符顺序的情况下，删除某些字符或者不删除任何字符形成的一个序列。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">示例 1：</span><br><span class="line">输入：s = &quot;babad&quot;</span><br><span class="line">输出：&quot;bab&quot;</span><br><span class="line">解释：&quot;aba&quot; 同样是符合题意的答案。</span><br><span class="line"></span><br><span class="line">示例 2：</span><br><span class="line">输入：s = &quot;cbbd&quot;</span><br><span class="line">输出：&quot;bb&quot;</span><br></pre></td></tr></table></figure><p>提示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1 &lt;= s.length &lt;= 1000</span><br><span class="line">s 仅由数字和英文字母组成</span><br></pre></td></tr></table></figure><h1 id="思路一：暴力-O-N-3"><a href="#思路一：暴力-O-N-3" class="headerlink" title="思路一：暴力 O(N^3)"></a>思路一：暴力 O(N^3)</h1><h2 id="基本代码"><a href="#基本代码" class="headerlink" title="基本代码"></a>基本代码</h2><p>最蠢的办法就是直接暴力了，一个函数判断是否是回文，再用双层循环来枚举所有子串</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isReverseString</span><span class="params">(<span class="type">const</span> string&amp; s, <span class="type">int</span> begin, <span class="type">int</span> end)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = begin, j = end; i &lt; j; i++, j--) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s[i] != s[j]) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">longestPalindrome</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s.<span class="built_in">size</span>()&lt;=<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> s;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 一个也算回文</span></span><br><span class="line">        <span class="type">int</span> maxLength = <span class="number">1</span>;</span><br><span class="line">        string ret;</span><br><span class="line">        ret.<span class="built_in">push_back</span>(s[<span class="number">0</span>]);</span><br><span class="line">        <span class="comment">// 再去找其他的</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; s.<span class="built_in">size</span>() - <span class="number">1</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = i + <span class="number">1</span>; j &lt; s.<span class="built_in">size</span>(); j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (<span class="built_in">isReverseString</span>(s, i, j)) &#123;</span><br><span class="line">                    <span class="type">int</span> len = j - i + <span class="number">1</span>;</span><br><span class="line">                    <span class="comment">// cout &lt;&lt; len &lt;&lt; endl;</span></span><br><span class="line">                    <span class="keyword">if</span> (len &gt; maxLength) &#123;</span><br><span class="line">                        maxLength = len;</span><br><span class="line">                        ret = s.<span class="built_in">substr</span>(i, len);</span><br><span class="line">                        <span class="comment">// cout &lt;&lt; len &lt;&lt; endl;</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>对于本题而言，也能通过，但很明显耗时太长了，这是一个<code>O(N^3)</code>时间复杂度的暴力算法。</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/05/d782bfddd37df1f5e5c3c81f43e1d309.png" alt="image.png"></p><h2 id="一定优化"><a href="#一定优化" class="headerlink" title="一定优化"></a>一定优化</h2><p>其实这个暴力求解法也有可优化的地方，即内层循环的枚举我们可以用maxLength进行枚举，j的初始值是<code>i+maxLength</code>，<strong>这样每一次枚举都是比上一次更长的字符串</strong>，得到回文子串后也不需要判断长度是否大于maxLength了，能减少很多次遍历。</p><p>且在当前的写法中，每次得到一个结果，我们都调用了一次substr函数，这个函数也是<code>O(N)</code>的时间复杂度。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ret = s.substr(i, len);</span><br></pre></td></tr></table></figure><p>我们可以将其改成记录结果字符串的起始下标和长度，在最终才调用substr函数来构造返回字符串，这样也能减少一定的时间复杂度。</p><p>优化后的代码如下，注意maxLength必须初始化为1。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isReverseString</span><span class="params">(<span class="type">const</span> string&amp; s, <span class="type">int</span> begin, <span class="type">int</span> end)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = begin, j = end; i &lt; j; i++, j--) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s[i] != s[j]) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">longestPalindrome</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (s.<span class="built_in">size</span>() &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> s;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 一个也算回文</span></span><br><span class="line">        <span class="type">int</span> maxLength = <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> begin = <span class="number">0</span>,length = <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 再去找其他的</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; s.<span class="built_in">size</span>() - <span class="number">1</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = i + maxLength; j &lt; s.<span class="built_in">size</span>(); j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (<span class="built_in">isReverseString</span>(s, i, j)) &#123;</span><br><span class="line">                    <span class="type">int</span> len = j - i + <span class="number">1</span>;</span><br><span class="line">                    maxLength = len;</span><br><span class="line">                    begin = i;</span><br><span class="line">                    length = len;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 最后才构造结果字符串</span></span><br><span class="line">        <span class="keyword">return</span> s.<span class="built_in">substr</span>(begin,length);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>多次提交测试，平均耗时都是之前1000ms的十分之一了，还是有不少提升的，但是时间复杂度依旧不变，还是<code>O(N^3)</code>。</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/05/d843f12ea8c4c90df9af20813735bf7f.png" alt="image.png"></p><h1 id="思路二：动态规划-O-N-2"><a href="#思路二：动态规划-O-N-2" class="headerlink" title="思路二：动态规划 O(N^2)"></a>思路二：动态规划 O(N^2)</h1><h2 id="二维数组"><a href="#二维数组" class="headerlink" title="二维数组"></a>二维数组</h2><p>首先我们要知道，如果一个字符串是回文子串，那么它的中间一部分也一定是个回文子串。比如<code>ABCBA</code>的中间部分<code>BCB</code>也是一个回文子串。</p><p>这样我们就可以得出一个二维的dp数组，数组的下标<code>(i,j)</code>代表s字符串中，从i到j的这个字符串是一个回文子串。且i大于j的情况是不合法的。</p><p>这样我们就能省去很多的判断步骤，如果<code>dp[i][j]=true</code>，那么只需要判断i-1和j+1是否相等，就可以知道<code>(i-1,j+1)</code>这个范围是不是一个回文子串了。递推公式如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dp[i][j] = dp[i+1][j-1] &amp;&amp; (s[i] == s[j])</span><br></pre></td></tr></table></figure><p>那么dp数组要怎么遍历呢？从递归公式中可知，当前状态<code>i,j</code>依赖于<code>i+1,j-1</code>，即依赖于当前元素<strong>右上角</strong>的哪一个。所以，<strong>我们需要先遍历列j，再遍历行i</strong>。</p><blockquote><p>在别的题解中你可能看到大家谈论的是<code>左下角</code>，这是因为矩阵的<strong>坐标系原点</strong>选择不同，我个人比较喜欢选左上角作为原点，然后往左是i下标，往下是j下标。</p></blockquote><p>由下图可知，当我们需要知道<code>(1,2)</code>这个下标位置的结果是多少的时候，我们需要先把<code>(0,3)</code>给搞出来，所以应该让j作为外层循环开始遍历，这样才能保证遍历到某一个位置的时候，依赖项已经更新完成了。</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/05/26489357a33a0603d07abd6219fa3b1a.png" alt="image.png"></p><p>继续确定dp数组的初始值，我们可以知道长度为1的时候肯定是个回文子串，即所有i和j相等的位置都可以初始化为true。长度为2的时候是否为子串需要进行判断，两个字符相同就是个回文子串。</p><p>现在就可以写代码了</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">longestPalindrome</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = s.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span> (n &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> s;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 初始dp数组，[i][j]代表下标i到j是回文串</span></span><br><span class="line">        vector&lt;vector&lt;<span class="type">bool</span>&gt;&gt; <span class="built_in">dp</span>(n, <span class="built_in">vector</span>&lt;<span class="type">bool</span>&gt;(n, <span class="literal">false</span>));</span><br><span class="line">        <span class="comment">// 一个字符的时候肯定是true</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            dp[i][i] = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 记录结果字符的起始位置</span></span><br><span class="line">        <span class="type">int</span> maxLength = <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> begin = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 需要先遍历列j在遍历行i</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">            <span class="comment">// i大于j的情况不合法</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; j; i++) &#123;</span><br><span class="line">                <span class="comment">// 两个字符相等是回文</span></span><br><span class="line">                <span class="keyword">if</span> (j == i + <span class="number">1</span> &amp;&amp; s[i] == s[j]) &#123;</span><br><span class="line">                    dp[i][j] = <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 依赖于右上角，注意i+1不能超过j-1</span></span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (i + <span class="number">1</span> &lt;= j - <span class="number">1</span> &amp;&amp; dp[i + <span class="number">1</span>][j - <span class="number">1</span>] == <span class="literal">true</span> &amp;&amp;</span><br><span class="line">                         s[i] == s[j]) &#123;</span><br><span class="line">                    dp[i][j] = <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 当前是回文，更新最大值</span></span><br><span class="line">                <span class="keyword">if</span> (dp[i][j] == <span class="literal">true</span> &amp;&amp; maxLength &lt; j - i + <span class="number">1</span>) &#123;</span><br><span class="line">                    maxLength = j - i + <span class="number">1</span>;</span><br><span class="line">                    begin = i;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s.<span class="built_in">substr</span>(begin, maxLength);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>代码的时间复杂度和空间复杂度都是<code>O(N^2)</code>。</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/05/88a11eede2eeffa0540a837253b3bbbd.png" alt="image.png"></p><p>建议根据代码的遍历顺序画个矩阵，更方便理解。</p><h2 id="一维数组"><a href="#一维数组" class="headerlink" title="一维数组"></a>一维数组</h2><p>使用一维数组，就可以降低一层空间复杂度。对应的思路也需要改变。</p><ul><li>数组中<code>dp[j]</code>的值是下标j和j之前的最大回文子串的起始下标i；</li><li>易得初始值<code>dp[0] = 0</code>；</li></ul><p>举例字符串<code>aabba</code>对应的dp数组，第一个a的最大回文子串起始地址是他自己，也就是0；第二个a之前的最大回文子串是aa，所以起始地址是0；第三个b之前的最大回文子串是它自己，因为aab不构成回文子串；第四个b之前的最大回文子串是bb，起始地址下标是2；最后一个a的最大回文子串是abba，起始下标是1。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a  a  b  b  a</span><br><span class="line">0  0  2  2  1</span><br></pre></td></tr></table></figure><p>另外我们需要知道每一位的递推值是怎么的来的。依照上面这个dp数组，假设我们需要递推最后一位a（下标为4）的dp值，那么应该是前一位b（下标为3）的<strong>最长子串起始下标的前一位</strong>是否和当前位相等，即判断<code>s[i]==s[dp[i-1]-1]</code>。</p><p><strong>如果二者相等</strong>，则说明这个回文子串还可以被扩展，此时<code>dp[i]</code>等于<code>dp[i-1]-1</code>，子串长度是<code>i-(dp[i-1]-1)+1</code>。对于当前这个例子，<code>dp[4]=1</code>，回文子串长度是<code>4-1+1=4</code>。</p><blockquote><p>这里还有另外一个结论，即当前位i组成的最长回文子串长度一定只会比i-1能组成的最长回文子串长度多两个字符（即i-1能组成的最长回文子串左右各多一个字符）。</p></blockquote><p><strong>如果不相等</strong>，说明前一位的回文子串不能被扩展，但这并不代表当前位并不能组成回文子串了。如下图所示，虽然当前j和前一位j-1的回文子串不能继续扩展，但它依旧有一个长度为3的回文子串。这时候就需要从j之前通过遍历来判断是否有回文子串了。</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/05/1d494a61b864199c5ed4b42618789b25.png" alt="image.png"></p><p>不过我们并不需要从0开始遍历，只需要从<code>dp[j-1]</code>开始遍历就可以了（即上图中下标为3的字母c开始）。前文说了，<strong>当前位i组成的最长回文子串长度一定只会比i-1能组成的最长回文子串长度多两个字符</strong>，不可能会有<code>dp[j-1]-1</code>之前到j能组成的回文串，而<code>(dp[j-1]-1,j)</code>这个子串我们已经在前面的条件中判断过不是回文了。</p><p>思路解决了，就可以写代码了</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">longestPalindrome</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = s.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span> (n &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> s;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(n, <span class="number">0</span>)</span></span>;</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">0</span>; <span class="comment">// 下标为0只能和自己组成回文串</span></span><br><span class="line">        <span class="type">int</span> maxLength = <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> begin = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 注意j要从1开始，因为0已经被初始化过了，而且我们需要访问j-1</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt; n; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (dp[j - <span class="number">1</span>] - <span class="number">1</span> &gt;= <span class="number">0</span> &amp;&amp; s[j] == s[dp[j - <span class="number">1</span>] - <span class="number">1</span>]) &#123;</span><br><span class="line">                dp[j] = dp[j - <span class="number">1</span>] - <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 从左向右找</span></span><br><span class="line">                <span class="type">int</span> left = dp[j - <span class="number">1</span>];</span><br><span class="line">                <span class="type">int</span> right = j;</span><br><span class="line">                <span class="type">int</span> start = left; <span class="comment">// 记录回文子串查找的起始位置</span></span><br><span class="line">                <span class="comment">// 开始遍历</span></span><br><span class="line">                <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">                    <span class="comment">// 二者不相等，不是回文，左侧需要缩限</span></span><br><span class="line">                    <span class="keyword">if</span> (s[left] != s[right]) &#123;</span><br><span class="line">                        right = j;        <span class="comment">// 重置right</span></span><br><span class="line">                        start = left + <span class="number">1</span>; <span class="comment">// 左侧缩限</span></span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="comment">// 是回文，右侧缩限</span></span><br><span class="line">                        right--;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// 不管是不是回文，左侧都需要缩限</span></span><br><span class="line">                    left++;</span><br><span class="line">                &#125;</span><br><span class="line">                dp[j] = start;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 更新最大长度</span></span><br><span class="line">            <span class="type">int</span> len = j - dp[j] + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (len &gt; maxLength) &#123;</span><br><span class="line">                maxLength = len;</span><br><span class="line">                begin = dp[j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s.<span class="built_in">substr</span>(begin, maxLength);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>虽然这么做的时间复杂度依旧是<code>O(N^2)</code>，但是空间复杂度被降为了<code>O(N)</code>。</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/05/7abf018774001fa96a73b23ced72ae21.png" alt="image.png"></p><h1 id="思路三：中心扩散-O-N-2"><a href="#思路三：中心扩散-O-N-2" class="headerlink" title="思路三：中心扩散 O(N^2)"></a>思路三：中心扩散 O(N^2)</h1><p>中心扩散的思路比较简单，遍历每一个下标，从这个下标开始往左往右扩散，直到找到最长的回文子串。这个思路不需要借助额外的数组，空间复杂度为<code>O(1)</code>。时间复杂度依旧是<code>O(N^2)</code>。</p><p>第一版本代码如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">longestPalindrome</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = s.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span> (n &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> s;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> maxLength = <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> maxBegin = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="type">int</span> left = i - <span class="number">1</span>, right = i + <span class="number">1</span>;</span><br><span class="line">            <span class="comment">// 扩展</span></span><br><span class="line">            <span class="type">int</span> len = <span class="number">1</span>;</span><br><span class="line">            <span class="type">int</span> begin = i;</span><br><span class="line">            <span class="keyword">while</span> (left &gt;= <span class="number">0</span> &amp;&amp; right &lt; n) &#123;</span><br><span class="line">                <span class="keyword">if</span> (s[left] != s[right]) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 相同，记录长度和开始下标</span></span><br><span class="line">                len = right - left + <span class="number">1</span>;</span><br><span class="line">                begin = left;</span><br><span class="line">                <span class="comment">// 扩展</span></span><br><span class="line">                left--;</span><br><span class="line">                right++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 更新最大长度</span></span><br><span class="line">            <span class="keyword">if</span> (len &gt; maxLength) &#123;</span><br><span class="line">                maxLength = len;</span><br><span class="line">                maxBegin = begin;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 返回结果</span></span><br><span class="line">        <span class="keyword">return</span> s.<span class="built_in">substr</span>(maxBegin, maxLength);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这个代码看上去好像没有问题，但实际上我们漏掉了回文串为偶数的情况，直接从长度为3的回文串开始递推了。这是不可行的。</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/05/b64f95bf323975b47e765035e1a5c22a.png" alt="image.png"></p><p>应该要把回文串长度为奇数，回文串长度为偶数的情况都考虑进去。下面是修改后的代码，其中使用了C++17的新特性，auto的结构化绑定来接收pair返回值，会方便一些。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="comment">// 从left和right开始往左右扩展找回文子串，返回值是起始下标和长度</span></span><br><span class="line">    <span class="function">pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; <span class="title">findReverseString</span><span class="params">(<span class="type">const</span> string&amp; s, <span class="type">int</span> left, <span class="type">int</span> right)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 记录</span></span><br><span class="line">        <span class="type">int</span> len = <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> begin = left;</span><br><span class="line">        <span class="comment">// 往两边扩展</span></span><br><span class="line">        <span class="keyword">while</span> (left &gt;= <span class="number">0</span> &amp;&amp; right &lt; s.<span class="built_in">size</span>()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s[left] != s[right]) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 相同，记录长度和开始下标</span></span><br><span class="line">            len = right - left + <span class="number">1</span>;</span><br><span class="line">            begin = left;</span><br><span class="line">            <span class="comment">// 扩展</span></span><br><span class="line">            left--;</span><br><span class="line">            right++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> &#123;begin, len&#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">longestPalindrome</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = s.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span> (n &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> s;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> maxLength = <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> maxBegin = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="comment">// 偶数情况</span></span><br><span class="line">            <span class="keyword">auto</span> [begin, len] = <span class="built_in">findReverseString</span>(s, i, i + <span class="number">1</span>);</span><br><span class="line">            <span class="comment">// 奇数情况</span></span><br><span class="line">            <span class="keyword">auto</span> [begin2, len2] = <span class="built_in">findReverseString</span>(s, i - <span class="number">1</span>, i + <span class="number">1</span>);</span><br><span class="line">            <span class="comment">// 如果奇数的结果更长，更新结果</span></span><br><span class="line">            <span class="keyword">if</span> (len2 &gt; len) &#123;</span><br><span class="line">                len = len2;</span><br><span class="line">                begin = begin2;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 更新最大值</span></span><br><span class="line">            <span class="keyword">if</span> (len &gt; maxLength) &#123;</span><br><span class="line">                maxLength = len;</span><br><span class="line">                maxBegin = begin;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 返回结果</span></span><br><span class="line">        <span class="keyword">return</span> s.<span class="built_in">substr</span>(maxBegin, maxLength);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/05/bf0cf0b351446058ee6dbf56050df8f8.png" alt="image.png"></p><h1 id="The-end"><a href="#The-end" class="headerlink" title="The end"></a>The end</h1><p>其他更牛逼的思路暂时就不记录了！可以参考博客开头贴出来的博客。</p>]]></content>
    
    
    <summary type="html">leetcode刷题笔记-5.最长回文子串。这么经典的题目我竟然现在才刷，懒虫一个。</summary>
    
    
    
    <category term="编程学习" scheme="https://blog.musnow.top/categories/%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="把题目都给刷干净" scheme="https://blog.musnow.top/categories/%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0/%E6%8A%8A%E9%A2%98%E7%9B%AE%E9%83%BD%E7%BB%99%E5%88%B7%E5%B9%B2%E5%87%80/"/>
    
    
    <category term="OJ刷题" scheme="https://blog.musnow.top/tags/OJ%E5%88%B7%E9%A2%98/"/>
    
    <category term="leetcode" scheme="https://blog.musnow.top/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>【leetcode】计算器问题汇总</title>
    <link href="https://blog.musnow.top/posts/1512949254/"/>
    <id>https://blog.musnow.top/posts/1512949254/</id>
    <published>2024-05-26T02:20:29.000Z</published>
    <updated>2024-05-31T07:22:36.000Z</updated>
    
    <content type="html"><![CDATA[<p>腾讯面试手撕计算器，带括号和加减乘除的中缀表达式，面试的时候没有写出来，必须得学学咋做了。</p><h1 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h1><p>我们平时遇到的数学表达式其实都是中缀表达式，比如<code>1+2/3</code>这一类。但是对于计算机而言，计算后缀表达式是更加方便的操作，包括我们自己写计算的函数，也是后缀表达式更加好处理。</p><p>所以我们应该先记住中缀、后缀、前缀表达式的区别，以及如何将中缀表达式转为后缀表达式。因为<strong>选择题</strong>有时候也会考相关的题目，不仅是要会写代码，还得记住怎么人工转换。</p><blockquote><p>我当时面试的时候就是忘记怎么把中缀转为后缀了，结果一直在死算，手撕给的时间本来就不多，临时写之前没写过的代码实在是写不出来，一堆BUG，突出一个菜。</p></blockquote><p>这部分内容都在本站的另外一篇博客 <a href="https://blog.musnow.top/posts/3211822811">逆波兰表达式求值</a> 中有提到，本文不再重复。阅读本文之前，建议先阅读该文章并完成 leetcode <a href="https://leetcode.cn/problems/evaluate-reverse-polish-notation/description/">150.逆波兰表达式求值</a>那道题。后缀表达式求值的思路如下：</p><ul><li>从左往右遍历，遇到操作数，入栈；</li><li>遇到运算符，取栈顶两个连续数据进行计算（第二个取出来的是左操作数），再将计算结果入栈；</li></ul><p>下面给出的是逆波兰表达式求值的代码。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">evalRPN</span><span class="params">(vector&lt;string&gt;&amp; tokens)</span> </span>&#123;</span><br><span class="line">        stack&lt;<span class="type">int</span>&gt; s;</span><br><span class="line">        map&lt;string,function&lt;<span class="type">int</span>(<span class="type">int</span>,<span class="type">int</span>)&gt;&gt; FuncMap = &#123;</span><br><span class="line">            &#123;<span class="string">&quot;+&quot;</span>,[](<span class="type">int</span> x,<span class="type">int</span> y)&#123;<span class="keyword">return</span> x+y;&#125;&#125;,</span><br><span class="line">            &#123;<span class="string">&quot;-&quot;</span>,[](<span class="type">int</span> x,<span class="type">int</span> y)&#123;<span class="keyword">return</span> x-y;&#125;&#125;,</span><br><span class="line">            &#123;<span class="string">&quot;*&quot;</span>,[](<span class="type">int</span> x,<span class="type">int</span> y)&#123;<span class="keyword">return</span> x*y;&#125;&#125;,</span><br><span class="line">            &#123;<span class="string">&quot;/&quot;</span>,[](<span class="type">int</span> x,<span class="type">int</span> y)&#123;<span class="keyword">return</span> x/y;&#125;&#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; ch : tokens)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(ch==<span class="string">&quot;+&quot;</span>||ch==<span class="string">&quot;-&quot;</span>||ch==<span class="string">&quot;*&quot;</span>||ch==<span class="string">&quot;/&quot;</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="type">int</span> right=s.<span class="built_in">top</span>();</span><br><span class="line">                s.<span class="built_in">pop</span>();</span><br><span class="line">                <span class="type">int</span> left=s.<span class="built_in">top</span>();</span><br><span class="line">                s.<span class="built_in">pop</span>();</span><br><span class="line">                <span class="type">int</span> ret = FuncMap[ch](left,right);</span><br><span class="line">                s.<span class="built_in">push</span>(ret);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                s.<span class="built_in">push</span>(<span class="built_in">stoi</span>(ch));</span><br><span class="line">            &#125;   </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s.<span class="built_in">top</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="题目一：227-基本计算器-II"><a href="#题目一：227-基本计算器-II" class="headerlink" title="题目一：227. 基本计算器 II"></a>题目一：227. 基本计算器 II</h1><blockquote><p><a href="https://leetcode.cn/problems/basic-calculator-ii/description/">227. 基本计算器 II</a> 和 <a href="https://leetcode.cn/problems/calculator-lcci/description/">面试题 16.26. 计算器</a></p></blockquote><p>这是leetcode上和计算器有关的题目中最简单的一个，它并不需要我们将中缀表达式转为后缀，直接通过一个栈加遍历的方式就可以将其写出来。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">给定一个包含正整数、加(+)、减(-)、乘(*)、除(/)的算数表达式(括号除外)，计算其结果。</span><br><span class="line"></span><br><span class="line">表达式仅包含非负整数，+， - ，*，/ 四种运算符和空格。 整数除法仅保留整数部分。</span><br></pre></td></tr></table></figure><p>代码如下，我们需要一个栈来存放处理的数字，并用一个num来拼接字符串里面的数字（虽然用例都是一位数字，但是题目并没有说不会出现多位数字，所以需要拼接），和一个prevClac指代上一个操作符。</p><p>当遇到<strong>操作符且不为空格</strong>，或者当前已经遍历到字符串末尾的时候，就需要进行计算。其他情况都说明是数字，对num变量进行拼接就可以了。</p><p>在计算过程中，我们把加减计算给替代成用数字的正负号来处理，乘除计算则直接对栈内元素做处理。这里需要记住一个小知识点，即STL的<code>stack.top()</code>函数返回的是栈顶元素的引用，所以我们可以直接对其进行修改，不需要用临时变量来处理。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 是不是数字？</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isNum</span><span class="params">(<span class="type">char</span>&amp; c)</span> </span>&#123; <span class="keyword">return</span> c &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; c &lt;= <span class="string">&#x27;9&#x27;</span>; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">calculate</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        stack&lt;<span class="type">int</span>&gt; numSt;</span><br><span class="line">        <span class="type">int</span> num = <span class="number">0</span>;         <span class="comment">// 拼数字</span></span><br><span class="line">        <span class="type">char</span> prevClac = <span class="string">&#x27;+&#x27;</span>; <span class="comment">// 上一位运算符</span></span><br><span class="line">        <span class="comment">// 遍历字符串，跳过空格，遇到乘除直接计算，遇到加减推后计算</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; s.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="type">char</span>&amp; c = s[i];</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">isNum</span>(c)) &#123;</span><br><span class="line">                num = num * <span class="number">10</span> + <span class="built_in">int</span>(c - <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 如果是操作符（注意不能是空格），或者当前已经是最后一位了，就需要计算</span></span><br><span class="line">            <span class="keyword">if</span> ((!<span class="built_in">isNum</span>(c) &amp;&amp; c != <span class="string">&#x27; &#x27;</span>) || i == s.<span class="built_in">size</span>() - <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="comment">// 我们把加减操作改成数字的正负来处理</span></span><br><span class="line">                <span class="keyword">if</span> (prevClac == <span class="string">&#x27;+&#x27;</span>) &#123;</span><br><span class="line">                    numSt.<span class="built_in">push</span>(num);</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (prevClac == <span class="string">&#x27;-&#x27;</span>) &#123;</span><br><span class="line">                    numSt.<span class="built_in">push</span>(-num);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 直接计算乘除，top返回的是引用</span></span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (prevClac == <span class="string">&#x27;*&#x27;</span>) &#123;</span><br><span class="line">                    numSt.<span class="built_in">top</span>() *= num;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (prevClac == <span class="string">&#x27;/&#x27;</span>) &#123;</span><br><span class="line">                    numSt.<span class="built_in">top</span>() /= num;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 更新操作符</span></span><br><span class="line">                prevClac = c;</span><br><span class="line">                num = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 最后统一求和</span></span><br><span class="line">        <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (!numSt.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            sum += numSt.<span class="built_in">top</span>();</span><br><span class="line">            numSt.<span class="built_in">pop</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/05/c6c59e9995858323ff9f7a94d2021fc7.png" alt="image.png"></p><h1 id="题目二：224-基本计算器"><a href="#题目二：224-基本计算器" class="headerlink" title="题目二：224. 基本计算器"></a>题目二：224. 基本计算器</h1><blockquote><p><a href="https://leetcode.cn/problems/basic-calculator/description/">https://leetcode.cn/problems/basic-calculator/description/</a></p></blockquote><p>这道题在原本的普通中缀表达式的基础上，添加了括号，但没有乘除法。</p><p>我们可以用中缀表达式先转为后续表达式的方式，再使用上文提到过的150逆波兰表达式求值的代码来计算它。</p><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给你一个字符串表达式 s ，请你实现一个基本计算器来计算并返回它的值。</p><p>注意:不允许使用任何将字符串作为数学表达式计算的内置函数，比如 eval() 。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">示例 1：</span><br><span class="line">输入：s = &quot;1 + 1&quot;</span><br><span class="line">输出：2</span><br><span class="line"></span><br><span class="line">示例 2：</span><br><span class="line">输入：s = &quot; 2-1 + 2 &quot;</span><br><span class="line">输出：3</span><br><span class="line"></span><br><span class="line">示例 3：</span><br><span class="line">输入：s = &quot;(1+(4+5+2)-3)+(6+8)&quot;</span><br><span class="line">输出：23</span><br></pre></td></tr></table></figure><p>提示</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">1 &lt;= s.length &lt;= 3 * 105</span><br><span class="line">s 由数字、&#x27;+&#x27;、&#x27;-&#x27;、&#x27;(&#x27;、&#x27;)&#x27;、和 &#x27; &#x27; 组成</span><br><span class="line">s 表示一个有效的表达式</span><br><span class="line">&#x27;+&#x27; 不能用作一元运算(例如， &quot;+1&quot; 和 &quot;+(2 + 3)&quot; 无效)</span><br><span class="line">&#x27;-&#x27; 可以用作一元运算(即 &quot;-1&quot; 和 &quot;-(2 + 3)&quot; 是有效的)</span><br><span class="line">输入中不存在两个连续的操作符</span><br><span class="line">每个数字和运行的计算将适合于一个有符号的 32位 整数</span><br></pre></td></tr></table></figure><h2 id="中缀表达式转后缀表达式"><a href="#中缀表达式转后缀表达式" class="headerlink" title="中缀表达式转后缀表达式"></a>中缀表达式转后缀表达式</h2><p>使用一个栈来存放操作符，注意左右括号，左括号的优先级低于任何操作符，右括号优先级高于任何操作符。</p><ul><li>遇到操作数的时候 <strong>先输出</strong> 到结果表达式中;</li><li>遇到操作符，和<strong>栈顶</strong>进行比较<ul><li>如果栈为空&#x2F;操作符优先级<strong>高于</strong>栈顶，入栈；</li><li>操作符优先级<strong>低于</strong>栈顶或和栈顶<strong>相同</strong>，出栈顶操作符（然后继续比较当前操作符和栈顶操作符）；</li></ul></li><li>如果是左括号<code>(</code>，正常入栈；</li><li>遇到右括号<code>)</code>，出栈内所有操作符，直到遇到对应左括号，注意，最终的输出后缀表达式中不需要添加左&#x2F;右括号；</li><li>最后将栈中的操作符全部出栈，就可以获得后缀表达式；</li></ul><p>具体的代码如下，有点长，但是不难理解</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断当前的操作符优先级是不是比栈顶更高？</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isCalcHigher</span><span class="params">(<span class="type">const</span> string&amp; cur, <span class="type">const</span> string&amp; target)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 如果是乘除，且栈顶是加减，那么优先级就更高</span></span><br><span class="line">    <span class="keyword">if</span> ((cur == <span class="string">&quot;*&quot;</span> || cur == <span class="string">&quot;/&quot;</span>) &amp;&amp; (target == <span class="string">&quot;+&quot;</span> || target == <span class="string">&quot;-&quot;</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果target是左括号，则为true</span></span><br><span class="line">    <span class="keyword">if</span> (target == <span class="string">&quot;(&quot;</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 其他情况，包括栈顶也是乘除的情况，优先级都低</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 中序表达式转后缀表达式</span></span><br><span class="line"><span class="function">vector&lt;string&gt; <span class="title">inOrderTobackOrder</span><span class="params">(<span class="type">const</span> string&amp; s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vector&lt;string&gt; retV;</span><br><span class="line">    stack&lt;string&gt; st; <span class="comment">//  操作符栈</span></span><br><span class="line">    string num;       <span class="comment">// 零时存放数字</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; itr : s)</span><br><span class="line">    &#123;</span><br><span class="line">        string c;</span><br><span class="line">        c.<span class="built_in">push_back</span>(itr);</span><br><span class="line">        <span class="comment">// 跳过空格</span></span><br><span class="line">        <span class="keyword">if</span> (c == <span class="string">&quot; &quot;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 操作数</span></span><br><span class="line">        <span class="keyword">if</span> (c &gt;= <span class="string">&quot;0&quot;</span> &amp;&amp; c &lt;= <span class="string">&quot;9&quot;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            num.<span class="built_in">push_back</span>(c[<span class="number">0</span>]);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 其他情况都说明不是操作数，需要将之前的操作数输出</span></span><br><span class="line">        <span class="keyword">if</span> (num.<span class="built_in">size</span>() &gt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            retV.<span class="built_in">push_back</span>(num);</span><br><span class="line">            num.<span class="built_in">resize</span>(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 左括号入栈</span></span><br><span class="line">        <span class="keyword">if</span> (c == <span class="string">&quot;(&quot;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            st.<span class="built_in">push</span>(c);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 遇到右括号，需要一直出栈内操作符，直到遇到左括号</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (c == <span class="string">&quot;)&quot;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 遇到右括号的时候不可能出现栈为空的情况</span></span><br><span class="line">            <span class="keyword">while</span> (st.<span class="built_in">top</span>() != <span class="string">&quot;(&quot;</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                retV.<span class="built_in">emplace_back</span>(st.<span class="built_in">top</span>());</span><br><span class="line">                st.<span class="built_in">pop</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            st.<span class="built_in">pop</span>(); <span class="comment">// 弹出左括号</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果栈为空，则入栈</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (st.<span class="built_in">empty</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            st.<span class="built_in">push</span>(c);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="comment">// 其他操作符</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 栈不为空，和栈顶的优先级进行比较</span></span><br><span class="line">            <span class="comment">// 操作符优先级高于栈顶，入栈;</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">isCalcHigher</span>(c, st.<span class="built_in">top</span>()))</span><br><span class="line">            &#123;</span><br><span class="line">                st.<span class="built_in">push</span>(c);</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 优先级低于/等于栈顶操作符，将栈顶出栈（放入结果表达式）</span></span><br><span class="line">            retV.<span class="built_in">emplace_back</span>(st.<span class="built_in">top</span>());</span><br><span class="line">            st.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="comment">// 继续判断，直到高于栈顶运算符</span></span><br><span class="line">            <span class="keyword">while</span> (!st.<span class="built_in">empty</span>() &amp;&amp; !<span class="built_in">isCalcHigher</span>(c, st.<span class="built_in">top</span>()))</span><br><span class="line">            &#123;</span><br><span class="line">                retV.<span class="built_in">emplace_back</span>(st.<span class="built_in">top</span>());</span><br><span class="line">                st.<span class="built_in">pop</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 栈顶高于当前运算符或栈为空，入栈</span></span><br><span class="line">            st.<span class="built_in">push</span>(c);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// num不为空，还需要处理</span></span><br><span class="line">    <span class="keyword">if</span> (num.<span class="built_in">size</span>() &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        retV.<span class="built_in">push_back</span>(num);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 结束遍历，将栈内操作符依次输出，即得到了最终的后缀表达式</span></span><br><span class="line">    <span class="keyword">while</span> (!st.<span class="built_in">empty</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        retV.<span class="built_in">emplace_back</span>(st.<span class="built_in">top</span>());</span><br><span class="line">        st.<span class="built_in">pop</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> retV;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    string s;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;enter inOrder &gt; &quot;</span>;</span><br><span class="line">    <span class="built_in">getline</span>(cin, s);</span><br><span class="line">    <span class="comment">// 处理</span></span><br><span class="line">    <span class="keyword">auto</span> retV = <span class="built_in">inOrderTobackOrder</span>(s);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;backOrder result: [&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>;i&lt;retV.<span class="built_in">size</span>();i++)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;\&quot;&quot;</span> &lt;&lt; retV[i] &lt;&lt; <span class="string">&quot;\&quot;&quot;</span>;</span><br><span class="line">        <span class="keyword">if</span>(i!=retV.<span class="built_in">size</span>()<span class="number">-1</span>)&#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;, &quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;]&quot;</span>&lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在224题目中给出的<code>(1+(4+5+2)-3)+(6+8)</code>这个表达式，经过转换的结果如下。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">❯ g++ 中缀表达式转后缀表达式.cpp -o test &amp;&amp; ./test</span><br><span class="line">enter inOrder &gt; (1+(4+5+2)-3)+(6+8)</span><br><span class="line">backOrder result: [&quot;1&quot;, &quot;4&quot;, &quot;5&quot;, &quot;+&quot;, &quot;2&quot;, &quot;+&quot;, &quot;+&quot;, &quot;3&quot;, &quot;-&quot;, &quot;6&quot;, &quot;8&quot;, &quot;+&quot;, &quot;+&quot;]</span><br></pre></td></tr></table></figure><p>把这个结果提供给150题目中的代码，计算结果就是23，代表我们的中缀转后缀的转换代码是正确的。</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/05/f0d515cb379b565bb22f687256517196.png" alt="image.png"></p><h2 id="单独的正负号处理"><a href="#单独的正负号处理" class="headerlink" title="单独的正负号处理"></a>单独的正负号处理</h2><p>有了这个函数后，我们就可以编写OJ的代码了，先把给出的中缀表达式转成后缀的，在进行计算。</p><p>先把基本的代码合并在一起，然后运行。此时会发现题目中有些刁钻的测试用例是过不了的。比如下面这个，它缺少了一个操作数，这导致我们中序转后续转出来的表达式是错误的。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;1-(     -2)&quot;</span><br></pre></td></tr></table></figure><p>题目中的提示也说明了这一点</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#x27;+&#x27; 不能用作一元运算(例如， &quot;+1&quot; 和 &quot;+(2 + 3)&quot; 无效)</span><br><span class="line">&#x27;-&#x27; 可以用作一元运算(即 &quot;-1&quot; 和 &quot;-(2 + 3)&quot; 是有效的)</span><br></pre></td></tr></table></figure><p>这就需要我们对这种情况做个单独处理，即把<code>-2</code>变成<code>0-2</code>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 修改中缀表达式为合法表达式</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">stringHandler</span><span class="params">(string &amp;s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 去除所有空格</span></span><br><span class="line">    std::string tmp;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;c : s)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (c != <span class="string">&#x27; &#x27;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            tmp += c;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 处理独立的负号或者正号</span></span><br><span class="line">    <span class="comment">// (-n) -&gt; (0-n)</span></span><br><span class="line">    <span class="comment">// (+n) -&gt; (0+n)</span></span><br><span class="line">    <span class="comment">// 开头的-n -&gt; 0-n</span></span><br><span class="line">    <span class="comment">// 开头的+n -&gt; 0+n</span></span><br><span class="line">    s.<span class="built_in">resize</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="type">int</span> n = tmp.<span class="built_in">length</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 开头的-n或者括号里面的-n</span></span><br><span class="line">        <span class="keyword">if</span> (tmp[i] == <span class="string">&#x27;-&#x27;</span> &amp;&amp; (i == <span class="number">0</span> || tmp[i - <span class="number">1</span>] == <span class="string">&#x27;(&#x27;</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            s += <span class="string">&quot;0-&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 开头的+n或者括号里面的+n</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (tmp[i] == <span class="string">&#x27;+&#x27;</span> &amp;&amp; (i == <span class="number">0</span> || tmp[i - <span class="number">1</span>] == <span class="string">&#x27;(&#x27;</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            s += <span class="string">&quot;0+&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 其他情况说明是有匹配的表达式的，所以不需要处理</span></span><br><span class="line">            s += tmp[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>可以看到，通过这个函数处理后，一切都正常了。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">enter inOrder &gt; 1-( -2)</span><br><span class="line">handle: 1-(0-2)</span><br></pre></td></tr></table></figure><h2 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="comment">// 判断当前的操作符优先级是不是比栈顶更高？</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isCalcHigher</span><span class="params">(<span class="type">const</span> string&amp; cur, <span class="type">const</span> string&amp; target)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 如果是乘除，且栈顶是加减，那么优先级就更高</span></span><br><span class="line">        <span class="keyword">if</span> ((cur == <span class="string">&quot;*&quot;</span> || cur == <span class="string">&quot;/&quot;</span>) &amp;&amp; (target == <span class="string">&quot;+&quot;</span> || target == <span class="string">&quot;-&quot;</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果target是左括号，则为true</span></span><br><span class="line">        <span class="keyword">if</span> (target == <span class="string">&quot;(&quot;</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 其他情况，包括栈顶也是乘除的情况，优先级都低</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 修改中缀表达式为合法表达式</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">stringHandler</span><span class="params">(string&amp; s)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 去除所有空格</span></span><br><span class="line">        std::string tmp;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; c : s) &#123;</span><br><span class="line">            <span class="keyword">if</span> (c != <span class="string">&#x27; &#x27;</span>) &#123;</span><br><span class="line">                tmp += c;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 处理独立的负号或者正号</span></span><br><span class="line">        <span class="comment">// (-n) -&gt; (0-n)</span></span><br><span class="line">        <span class="comment">// (+n) -&gt; (0+n)</span></span><br><span class="line">        <span class="comment">// 开头的-n -&gt; 0-n</span></span><br><span class="line">        <span class="comment">// 开头的+n -&gt; 0+n</span></span><br><span class="line">        s.<span class="built_in">resize</span>(<span class="number">0</span>);</span><br><span class="line">        <span class="type">int</span> n = tmp.<span class="built_in">length</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="comment">// 开头的-n或者括号里面的-n</span></span><br><span class="line">            <span class="keyword">if</span> (tmp[i] == <span class="string">&#x27;-&#x27;</span> &amp;&amp; (i == <span class="number">0</span> || tmp[i - <span class="number">1</span>] == <span class="string">&#x27;(&#x27;</span>)) &#123;</span><br><span class="line">                s += <span class="string">&quot;0-&quot;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 开头的+n或者括号里面的+n</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (tmp[i] == <span class="string">&#x27;+&#x27;</span> &amp;&amp; (i == <span class="number">0</span> || tmp[i - <span class="number">1</span>] == <span class="string">&#x27;(&#x27;</span>)) &#123;</span><br><span class="line">                s += <span class="string">&quot;0+&quot;</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 其他情况说明是有匹配的表达式的，所以不需要处理</span></span><br><span class="line">                s += tmp[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 中序表达式转后缀表达式</span></span><br><span class="line">    <span class="function">vector&lt;string&gt; <span class="title">inOrderTobackOrder</span><span class="params">(string&amp; s)</span> </span>&#123;</span><br><span class="line">        vector&lt;string&gt; retV;</span><br><span class="line">        stack&lt;string&gt; st; <span class="comment">//  操作符栈</span></span><br><span class="line">        string num;       <span class="comment">// 零时存放数字</span></span><br><span class="line">        <span class="built_in">stringHandler</span>(s);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; itr : s) &#123;</span><br><span class="line">            string c;</span><br><span class="line">            c.<span class="built_in">push_back</span>(itr);</span><br><span class="line">            <span class="comment">// 跳过空格</span></span><br><span class="line">            <span class="keyword">if</span> (c == <span class="string">&quot; &quot;</span>) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 操作数</span></span><br><span class="line">            <span class="keyword">if</span> (c &gt;= <span class="string">&quot;0&quot;</span> &amp;&amp; c &lt;= <span class="string">&quot;9&quot;</span>) &#123;</span><br><span class="line">                num.<span class="built_in">push_back</span>(c[<span class="number">0</span>]);</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 其他情况都说明不是操作数，需要将之前的操作数输出</span></span><br><span class="line">            <span class="keyword">if</span> (num.<span class="built_in">size</span>() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                retV.<span class="built_in">push_back</span>(num);</span><br><span class="line">                num.<span class="built_in">resize</span>(<span class="number">0</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 左括号入栈</span></span><br><span class="line">            <span class="keyword">if</span> (c == <span class="string">&quot;(&quot;</span>) &#123;</span><br><span class="line">                st.<span class="built_in">push</span>(c);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 遇到右括号，需要一直出栈内操作符，直到遇到左括号</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (c == <span class="string">&quot;)&quot;</span>) &#123;</span><br><span class="line">                <span class="comment">// 遇到右括号的时候不可能出现栈为空的情况</span></span><br><span class="line">                <span class="keyword">while</span> (st.<span class="built_in">top</span>() != <span class="string">&quot;(&quot;</span>) &#123;</span><br><span class="line">                    retV.<span class="built_in">emplace_back</span>(st.<span class="built_in">top</span>());</span><br><span class="line">                    st.<span class="built_in">pop</span>();</span><br><span class="line">                &#125;</span><br><span class="line">                st.<span class="built_in">pop</span>(); <span class="comment">// 弹出左括号</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 如果栈为空，则入栈</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (st.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">                st.<span class="built_in">push</span>(c);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="comment">// 其他操作符</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// 栈不为空，和栈顶的优先级进行比较</span></span><br><span class="line">                <span class="comment">// 操作符优先级高于栈顶，入栈;</span></span><br><span class="line">                <span class="keyword">if</span> (<span class="built_in">isCalcHigher</span>(c, st.<span class="built_in">top</span>())) &#123;</span><br><span class="line">                    st.<span class="built_in">push</span>(c);</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 优先级低于/等于栈顶操作符，将栈顶出栈（放入结果表达式）</span></span><br><span class="line">                retV.<span class="built_in">emplace_back</span>(st.<span class="built_in">top</span>());</span><br><span class="line">                st.<span class="built_in">pop</span>();</span><br><span class="line">                <span class="comment">// 继续判断，直到高于栈顶运算符</span></span><br><span class="line">                <span class="keyword">while</span> (!st.<span class="built_in">empty</span>() &amp;&amp; !<span class="built_in">isCalcHigher</span>(c, st.<span class="built_in">top</span>())) &#123;</span><br><span class="line">                    retV.<span class="built_in">emplace_back</span>(st.<span class="built_in">top</span>());</span><br><span class="line">                    st.<span class="built_in">pop</span>();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 栈顶高于当前运算符或栈为空，入栈</span></span><br><span class="line">                st.<span class="built_in">push</span>(c);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// num不为空，还需要处理</span></span><br><span class="line">        <span class="keyword">if</span> (num.<span class="built_in">size</span>() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            retV.<span class="built_in">push_back</span>(num);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 结束遍历，将栈内操作符依次输出，即得到了最终的后缀表达式</span></span><br><span class="line">        <span class="keyword">while</span> (!st.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            retV.<span class="built_in">emplace_back</span>(st.<span class="built_in">top</span>());</span><br><span class="line">            st.<span class="built_in">pop</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> retV;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">calculate</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> retV = <span class="built_in">inOrderTobackOrder</span>(s);</span><br><span class="line">        <span class="comment">// 后缀表达式计算</span></span><br><span class="line">        stack&lt;<span class="type">int</span>&gt; st;</span><br><span class="line">        unordered_map&lt;string, function&lt;<span class="type">int</span>(<span class="type">int</span>, <span class="type">int</span>)&gt;&gt; funcMap = &#123;</span><br><span class="line">            &#123;<span class="string">&quot;+&quot;</span>, [](<span class="type">int</span> x, <span class="type">int</span> y) &#123; <span class="keyword">return</span> x + y; &#125;&#125;,</span><br><span class="line">            &#123;<span class="string">&quot;-&quot;</span>, [](<span class="type">int</span> x, <span class="type">int</span> y) &#123; <span class="keyword">return</span> x - y; &#125;&#125;,</span><br><span class="line">            &#123;<span class="string">&quot;*&quot;</span>, [](<span class="type">int</span> x, <span class="type">int</span> y) &#123; <span class="keyword">return</span> x * y; &#125;&#125;,</span><br><span class="line">            &#123;<span class="string">&quot;/&quot;</span>, [](<span class="type">int</span> x, <span class="type">int</span> y) &#123; <span class="keyword">return</span> x / y; &#125;&#125;&#125;;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; ch : retV) &#123;</span><br><span class="line">            <span class="keyword">if</span> (ch == <span class="string">&quot;+&quot;</span> || ch == <span class="string">&quot;-&quot;</span> || ch == <span class="string">&quot;*&quot;</span> || ch == <span class="string">&quot;/&quot;</span>) &#123;</span><br><span class="line">                <span class="type">int</span> right = st.<span class="built_in">top</span>();</span><br><span class="line">                st.<span class="built_in">pop</span>();</span><br><span class="line">                <span class="type">int</span> left = st.<span class="built_in">top</span>();</span><br><span class="line">                st.<span class="built_in">pop</span>();</span><br><span class="line">                <span class="type">int</span> ret = funcMap[ch](left, right);</span><br><span class="line">                st.<span class="built_in">push</span>(ret);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                st.<span class="built_in">push</span>(<span class="built_in">stoi</span>(ch));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> st.<span class="built_in">top</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/05/2a9fa990a2a0baa915ccff75e5b5c050.png" alt="image.png"></p><h1 id="题目三：772-基本计算器-III"><a href="#题目三：772-基本计算器-III" class="headerlink" title="题目三：772. 基本计算器 III"></a>题目三：772. 基本计算器 III</h1><blockquote><p><a href="https://leetcode.cn/problems/basic-calculator-iii/">https://leetcode.cn/problems/basic-calculator-iii/</a></p></blockquote><p>这道题和上一道题的区别就是多了乘法和除法。上一道题我们使用中缀转后缀再计算的思路已经包含了处理除法的情况了，所以直接用相同的代码就能过了。</p><p>腾讯面试的时候考的也是这道题，竟然在leetcode上需要开plus会员才能看，无语。</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/05/6b958f2376075c862637bfddba606a90.png" alt="image.png"></p>]]></content>
    
    
    <summary type="html">leetcode刷题笔记-计算器问题</summary>
    
    
    
    <category term="编程学习" scheme="https://blog.musnow.top/categories/%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="把题目都给刷干净" scheme="https://blog.musnow.top/categories/%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0/%E6%8A%8A%E9%A2%98%E7%9B%AE%E9%83%BD%E7%BB%99%E5%88%B7%E5%B9%B2%E5%87%80/"/>
    
    
    <category term="OJ刷题" scheme="https://blog.musnow.top/tags/OJ%E5%88%B7%E9%A2%98/"/>
    
    <category term="leetcode" scheme="https://blog.musnow.top/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>【docker】使用docker-compose的时候如何更新镜像版本</title>
    <link href="https://blog.musnow.top/posts/2589631185/"/>
    <id>https://blog.musnow.top/posts/2589631185/</id>
    <published>2024-05-21T08:58:26.000Z</published>
    <updated>2024-05-23T02:15:57.000Z</updated>
    
    <content type="html"><![CDATA[<p>使用docker-compose的时候如何更新镜像版本。之前总是会忘记怎么操作，每次都得百度搜，干脆记录一下。</p><h2 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h2><p>我有一个memos是用docker-compose部署的，memos更新的挺频繁的，新版本的功能也不错，更新一下没啥问题。</p><p>注意，执行下面的操作之前，请先把你的memos容器目录做好备份，同时记录下当前使用的memos镜像hash值，避免出现问题！记录了镜像的hash值即便更新出现问题也可以回档到之前使用的那个版本继续用，不会出现数据丢失。</p><p>docker-compose.yml文件中也需要指定镜像tag为latest，才能使用这个办法进行升级。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">image:</span> <span class="string">neosmemo/memos:latest</span></span><br></pre></td></tr></table></figure><h2 id="操作"><a href="#操作" class="headerlink" title="操作"></a>操作</h2><p>基本涉及到的操作是：停止容器，删除原有容器，拉取最新的latest镜像，重新创建新容器。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 停止并删除原有容器，记得备份！</span></span><br><span class="line">docker stop 容器名</span><br><span class="line">docker <span class="built_in">rm</span> 容器名</span><br><span class="line"><span class="comment"># 拉取最新的镜像并上线</span></span><br><span class="line">docker-compose pull</span><br><span class="line">docker-compose up -d</span><br></pre></td></tr></table></figure><p>执行的效果如下，此时就已经更新容器版本成功了！</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/05/d9ca6f4492015b047fc1e395ee38ed03.png" alt="image.png"></p>]]></content>
    
    
    <summary type="html">使用docker-compose的时候如何更新镜像版本</summary>
    
    
    
    <category term="编程学习" scheme="https://blog.musnow.top/categories/%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="Docker真好玩" scheme="https://blog.musnow.top/categories/%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0/Docker%E7%9C%9F%E5%A5%BD%E7%8E%A9/"/>
    
    
    <category term="默认标签" scheme="https://blog.musnow.top/tags/%E9%BB%98%E8%AE%A4%E6%A0%87%E7%AD%BE/"/>
    
  </entry>
  
  <entry>
    <title>【win】obsidian快速打开某个仓库的办法</title>
    <link href="https://blog.musnow.top/posts/1331378393/"/>
    <id>https://blog.musnow.top/posts/1331378393/</id>
    <published>2024-05-21T02:33:42.000Z</published>
    <updated>2024-05-21T02:51:47.000Z</updated>
    
    <content type="html"><![CDATA[<p>windows下obsidian快速打开某个仓库的办法。</p><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>如果你使用obsidian的时候需要管理多个vault（仓库），就会遇到一个麻烦的问题。每次点击obsidian的时候，默认只会打开上一次关闭的vault，且没有办法修改。</p><p>在状态栏上obsidian也不会像vscode一样驻留之前打开过的vault。</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/05/9b1a9d0fb5455fbc00406e7c968e3dc2.png" alt="image.png"></p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/05/ff1cb9dcfb3179f1793ad3574467d730.png" alt="image.png"></p><p>这就导致，如果我们想打开一个不是上一次关闭的vault，那么就需要在默认打开的vault中点击<strong>仓库选择按钮</strong>，再在仓库列表中选择目标vault，实在是麻烦！</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/05/2fba671b675e909c5b08347ea6456376.png" alt="image.png"></p><p>下面给大家提供一个在windows上可以使用的快捷打开某个vault的办法。</p><h2 id="办法"><a href="#办法" class="headerlink" title="办法"></a>办法</h2><blockquote><p>参考 <a href="https://zhuanlan.zhihu.com/p/619483889">https://zhuanlan.zhihu.com/p/619483889</a></p></blockquote><p>官方文档：<a href="https://publish.obsidian.md/help-zh/%E9%AB%98%E7%BA%A7%E7%94%A8%E6%B3%95/%E4%BD%BF%E7%94%A8+obsidian+URI">使用 obsidian URI</a></p><p>官方文档中提到了，obsidian会自动在windows的注册表中注册<code>obsidian://</code>这个链接，且为之提供了一部分功能，其中就包括我们需要的打开某个特定库的功能，链接格式如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">obsidian://open?vault=库ID</span><br></pre></td></tr></table></figure><p>我们要做的就是，先把你需要快捷打开的某个仓库，手动打开一次， 让其显示在库列表中。只有出现在列表中的仓库才能使用这个办法快速打开。</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/05/2fba671b675e909c5b08347ea6456376.png" alt="image.png"></p><p>然后按照图示方式，点击仓库列表中，某个仓库旁边的三个点，选择<code>Copy vault ID</code>拷贝库的vault ID，填入上文提到的链接中，比如</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">obsidian://open?vault=c7d248e04bcc1f58</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/05/83041d4683dd9d5c1b06e3ff0b7ce252.png" alt="image.png"></p><p>有了这个链接后，我们在桌面右键鼠标，选择菜单中的<code>新建-快捷方式</code>。</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/05/8320bdf709873737794cd75934f7a0b1.png" alt="image.png"></p><p>输入刚刚准备好的obsidian url，点击下一步</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/05/2db8f34185721e4d357b21664c4f3d26.png" alt="image.png"></p><p>起个名字，点击完成</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/05/3d4b0ddf84ef7f92cc0b5fb2292c2826.png" alt="image.png"></p><h2 id="搞定！"><a href="#搞定！" class="headerlink" title="搞定！"></a>搞定！</h2><p>现在你就在桌面上成功创建了一个打开特定obsidian vault的快捷方式了，不再需要去执行繁琐的操作了！你也可以把这个快捷方式移动到其他你想要的地方。</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/05/e9dff01b915351c873eb8579af83e512.png" alt="image.png"></p>]]></content>
    
    
    <summary type="html">obsidian快速打开某个仓库的办法</summary>
    
    
    
    <category term="差生文具多" scheme="https://blog.musnow.top/categories/%E5%B7%AE%E7%94%9F%E6%96%87%E5%85%B7%E5%A4%9A/"/>
    
    <category term="电脑使用小贴士" scheme="https://blog.musnow.top/categories/%E5%B7%AE%E7%94%9F%E6%96%87%E5%85%B7%E5%A4%9A/%E7%94%B5%E8%84%91%E4%BD%BF%E7%94%A8%E5%B0%8F%E8%B4%B4%E5%A3%AB/"/>
    
    
    <category term="默认标签" scheme="https://blog.musnow.top/tags/%E9%BB%98%E8%AE%A4%E6%A0%87%E7%AD%BE/"/>
    
  </entry>
  
  <entry>
    <title>【建站】使用mrdoc和1panel的时候如何添加bing站长验证</title>
    <link href="https://blog.musnow.top/posts/3781449179/"/>
    <id>https://blog.musnow.top/posts/3781449179/</id>
    <published>2024-05-19T02:01:50.000Z</published>
    <updated>2024-05-19T08:10:35.000Z</updated>
    
    <content type="html"><![CDATA[<p>使用mrdoc和1panel的时候如何添加bing站长验证。</p><h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><p>我需要将MrDoc添加到bing的站长工具中，方便bing收录wiki里面的文章。</p><blockquote><p><a href="https://wiki.musnow.top/">https://wiki.musnow.top/</a></p></blockquote><p>bing站长工具添加一个网站的时候需要进行验证，有三种方式</p><ol><li>xml文件验证</li><li>head中插入标签验证</li><li>cname验证</li></ol><p>我先尝试了cname验证，依照要求给域名添加了一个cname解析后，始终无法验证成功。不知道是不是我添加cname添加错了，只能换用前两种方案。</p><p>方案2涉及到修改页面的前端代码，而mrdoc并没有提供非常方便的修改的方式，在管理后台中也没有办法往head里面插入其他元素（可能是我没找到，能找到的添加统计代码不适用于站长验证）。</p><p>故考虑方案1，在nginx反代中直接添加一个新的location来使用xml文件验证。</p><h1 id="1panel如何添加新的静态location？"><a href="#1panel如何添加新的静态location？" class="headerlink" title="1panel如何添加新的静态location？"></a>1panel如何添加新的静态location？</h1><p>1panel的网站控制台中只有添加反向代理的选项，并没有添加静态文件代理的选项。</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/05/e515666ecc052f38a8c31f66117cd261.png" alt="image.png"></p><p>而我们需要的是添加一个对单个文件的location代理，所以直接去修改源配置文件就可以了。在网站详情里面点击配置文件</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/05/858b010c6f49289216a62d062774a4fc.png" alt="image.png"></p><p>我们需要把bing站长工具里面下载的xml文件，移动到如下目录中</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/opt/1panel/apps/openresty/openresty/www/sites/wiki.musnow.top</span><br></pre></td></tr></table></figure><p>因为这里openrestry的根目录起始是<code>/opt/1panel/apps/openresty/openresty/</code>路径，并不是linux主机的根路径。所以需要从它能识别的路径中添加xml文件。</p><p>在原本的include更多conf之前，依照图示添加一个location指向xml的静态文件就可以了。注意这里我们需要添加的是单个静态文件，所以应该使用alias而不是root，并且需要使用<code>=</code>进行完整匹配。</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">location</span> = /BingSiteAuth.xml &#123;</span><br><span class="line">       <span class="attribute">alias</span> /www/sites/wiki.musnow.top/BingSiteAuth.xml;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>添加完毕后，点击页面下方的重载配置，应该就能看到效果了。</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/05/7a6fa237a7d29ca8ab2f9f1da1b52a38.png" alt="image.png"></p><h1 id="效果"><a href="#效果" class="headerlink" title="效果"></a>效果</h1><p>添加之前，显示的是mrdoc的404页面</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/05/fc254949b106df6ab77011dad96462bb.png" alt="Snipaste_2024-05-19_09-48-11.png"></p><p>添加之后，成功显示了bing的xml文件内容。</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/05/3004e8f9f548a21198af58fbea4c4439.png" alt="image.png"></p><p>这下去bing站长工具里面验证就可以成功了。</p><p>添加sitemap方便bing爬文章，大功告成！</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/05/08c001d451cfbc9b82f45ea6c167d6b6.png" alt="image.png"></p>]]></content>
    
    
    <summary type="html">使用mrdoc和1panel的时候如何添加bing站长验证</summary>
    
    
    
    <category term="编程学习" scheme="https://blog.musnow.top/categories/%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="Docker真好玩" scheme="https://blog.musnow.top/categories/%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0/Docker%E7%9C%9F%E5%A5%BD%E7%8E%A9/"/>
    
    
    <category term="默认标签" scheme="https://blog.musnow.top/tags/%E9%BB%98%E8%AE%A4%E6%A0%87%E7%AD%BE/"/>
    
  </entry>
  
  <entry>
    <title>【leetcode】121.买卖股票的最佳时机</title>
    <link href="https://blog.musnow.top/posts/3174951422/"/>
    <id>https://blog.musnow.top/posts/3174951422/</id>
    <published>2024-05-04T02:05:23.000Z</published>
    <updated>2024-05-04T04:05:15.000Z</updated>
    
    <content type="html"><![CDATA[<p>leetcode刷题笔记-121.买卖股票的最佳时机。这道题有很多解法，特此记录一下不同的解法思路。</p><h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><blockquote><p><a href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock/description/">https://leetcode.cn/problems/best-time-to-buy-and-sell-stock/description/</a></p></blockquote><p>给定一个数组 prices ，它的第 i 个元素 prices[i] 表示一支给定股票第 i 天的价格。</p><p>你只能选择 某一天 买入这只股票，并选择在 未来的某一个不同的日子 卖出该股票。设计一个算法来计算你所能获取的最大利润。</p><p>返回你可以从这笔交易中获取的最大利润。如果你不能获取任何利润，返回 0 。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">示例 1：</span><br><span class="line">输入：[7,1,5,3,6,4]</span><br><span class="line">输出：5</span><br><span class="line">解释：在第 2 天（股票价格 = 1）的时候买入，在第 5 天（股票价格 = 6）的时候卖出，最大利润 = 6-1 = 5 。</span><br><span class="line">     注意利润不能是 7-1 = 6, 因为卖出价格需要大于买入价格；同时，你不能在买入前卖出股票。</span><br><span class="line">     </span><br><span class="line">示例 2：</span><br><span class="line">输入：prices = [7,6,4,3,1]</span><br><span class="line">输出：0</span><br><span class="line">解释：在这种情况下, 没有交易完成, 所以最大利润为 0。</span><br></pre></td></tr></table></figure><h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><h2 id="暴力"><a href="#暴力" class="headerlink" title="暴力"></a>暴力</h2><p>暴力思路就是两层for循环，计算最大的差值，就是得到的最大利润</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxProfit</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> maxProfit = <span class="number">0</span>; <span class="comment">// 最大收益</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; prices.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = i + <span class="number">1</span>; j &lt; prices.<span class="built_in">size</span>(); j++) &#123;</span><br><span class="line">                maxProfit = <span class="built_in">max</span>(maxProfit, prices[j] - prices[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxProfit;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>时间复杂度是<code>O(N^2)</code>，会超时</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/05/234748c82c574033336617a9303c6960.png" alt="image.png"></p><h2 id="贪心"><a href="#贪心" class="headerlink" title="贪心"></a>贪心</h2><h3 id="本题思路"><a href="#本题思路" class="headerlink" title="本题思路"></a>本题思路</h3><p>贪心算法，思路是枚举当前数之前的最小值，计算当前数得到的利润的最大值。</p><ul><li>用一个元素来记录最小值，每一次遍历都更新这个最小值（最小的买入价格）</li><li>用一个元素来记录得到的最大利润，每一次遍历都更新最大利润（当前价格减去最小买入价格）</li></ul><p>首先更新的是最大利润，再更新最小买入价格，这样能保证最小买入价格的值一定是当前元素之前的某一个值，计算出来的最大利润才有效。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxProfit</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> maxProfit = <span class="number">-1</span>;       <span class="comment">// 最大收益</span></span><br><span class="line">        <span class="type">int</span> minPrice = prices[<span class="number">0</span>]; <span class="comment">// 当前的最小价格</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; i : prices) &#123;</span><br><span class="line">            <span class="comment">// 当前值减去最小价格得到最大收益</span></span><br><span class="line">            maxProfit = <span class="built_in">max</span>(maxProfit, i - minPrice);</span><br><span class="line">            <span class="comment">// 需要更新最小价格，保证最小价格是在当前值之前的某一个数</span></span><br><span class="line">            minPrice = <span class="built_in">min</span>(minPrice, i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxProfit;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/05/cbde462eff228fcd0de5c1d883b59048.png" alt="image.png"></p><h3 id="122题-买卖股票的最佳时机2"><a href="#122题-买卖股票的最佳时机2" class="headerlink" title="122题 买卖股票的最佳时机2"></a>122题 买卖股票的最佳时机2</h3><p>这里顺带记录一下122题的贪心思路。122题在本题的基础上新增了一个可以多次卖出+买入的操作。而121题只能买入一次+未来卖出一次。</p><p>因为每一天都可以买入+卖出，所以我们可以把利润拆分成每一天。只要某一天买入+明天卖出的利润是正数，那么就把他加入到最终结果中。这样就相当于排除亏钱的情况，只要能赚钱就买，即可计算出最大利润。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 122. 买卖股票的最佳时机 II</span></span><br><span class="line"><span class="comment">// https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-ii/</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxProfit</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 第0天买，第3天卖的利润是prices[3]-prices[0]</span></span><br><span class="line">        <span class="comment">// 也等于 p[3]-p[2] + p[2]-p[1] + p[1]-p[0]</span></span><br><span class="line">        <span class="comment">// 所以最大利润其实就是每天利润之和（前提是利润都是正的）</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; prices.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="comment">// 计算昨天买今天卖能获得多少利润</span></span><br><span class="line">            <span class="comment">// 如果大于0就加入进去</span></span><br><span class="line">            count += <span class="built_in">max</span>(prices[i] - prices[i - <span class="number">1</span>], <span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h2><h3 id="本题思路-1"><a href="#本题思路-1" class="headerlink" title="本题思路"></a>本题思路</h3><p>动态规划就要记住解题的几个步骤。</p><ul><li>确定动归数组每个下标的含义</li><li>确定迭代方程</li><li>确定初始值</li><li>确定遍历顺序</li><li>举例推导</li></ul><p>对于这道题而言，每天都有两种状态：今天持有股票和今天卖出股票。</p><p>我们可以设定<code>dp[i][0]</code>是第i天持有股票时的得到的最多钱，<code>dp[i][1]</code>是第i天不持有股票时得到的最多钱。很容易发现每天不持有股票得到的钱是更多的，所以最终的答案就是<code>dp[prices.size()-1][1]</code>，即这个二维数组的右下角。</p><p>这里就需要两个递推公式了，先看第i天持有股票的钱</p><ul><li>上一天就持有股票，即保持<code>dp[i-1][0]</code>不变；</li><li>今天才持有股票（买入），即<code>-price[i]</code>，本题股票只能买入一次，所以选择今天买入，那么剩下的钱就是0减去股票的价格；</li></ul><p>可得 <code>dp[i][0] = max(dp[i-1][0],-price[i])</code>，上两种情况的最大值。</p><p>第i天不持有股票的钱也分为两种情况</p><ul><li>上一天就没有持有股票，即保持<code>dp[i-1][1]</code>不变；</li><li>今天才卖出股票，即保持<code>price[i]+dp[i-1][0]</code>（因为今天卖出，所以上一天肯定是持有股票的）</li></ul><p>可得递推公式 <code>dp[i][1] = max(dp[i-1][1],price[i]+dp[i-1][0])</code>；</p><p>初始化dp数组时，第0天肯定只能持有股票，不能卖出，所以初始化如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">dp[0][0] = 0-price[0];</span><br><span class="line">dp[0][1] = 0;</span><br></pre></td></tr></table></figure><p>这里还有另外一个优化方向，从递推公式中可以看出，每一天的值只和上一天有关系，那么并不需要一个完整的二维数组，只需要一个<code>2*2</code>的数组就可以了，我们把今天的值写入上一天就OK了，这样可以把空间复杂度降为<code>O(1)</code>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxProfit</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dp</span>(<span class="number">2</span>, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(<span class="number">2</span>, <span class="number">0</span>));</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span>-prices[<span class="number">0</span>];</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; prices.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            dp[<span class="number">1</span>][<span class="number">0</span>] = <span class="built_in">max</span>(<span class="number">0</span>-prices[i], dp[<span class="number">0</span>][<span class="number">0</span>]);</span><br><span class="line">            dp[<span class="number">1</span>][<span class="number">1</span>] = <span class="built_in">max</span>(prices[i] + dp[<span class="number">0</span>][<span class="number">0</span>], dp[<span class="number">0</span>][<span class="number">1</span>]);</span><br><span class="line">            <span class="comment">// 把当前值挪过去，作为上一行的结果</span></span><br><span class="line">            dp[<span class="number">0</span>][<span class="number">0</span>] = dp[<span class="number">1</span>][<span class="number">0</span>];</span><br><span class="line">            dp[<span class="number">0</span>][<span class="number">1</span>] = dp[<span class="number">1</span>][<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">1</span>][<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/05/d7cce93225d5d8f2ea36a3a2379fce97.png" alt="image.png"></p><p>不过个人感觉这道题用动态规划来写实在是想不出来思路，而且还感觉很麻烦，还不如用贪心来处理一下。</p><h3 id="122题-买卖股票的最佳时机2-1"><a href="#122题-买卖股票的最佳时机2-1" class="headerlink" title="122题 买卖股票的最佳时机2"></a>122题 买卖股票的最佳时机2</h3><p>同样记录一下122题的代码。122题和本题在动态规划上唯一的区别就是当天买入股票的时候，需要计算上一天卖出股票后能剩下的最多钱（因为同一天只能持有一张股票）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-ii</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxProfit</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dp</span>(<span class="number">2</span>, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(<span class="number">2</span>, <span class="number">0</span>));</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = -prices[<span class="number">0</span>];</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; prices.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="comment">// 1.今天买入股票的剩余钱需要计算上一天卖出后剩下的最多钱</span></span><br><span class="line">            <span class="comment">// 2.今天不买入，沿用上一天的结果</span></span><br><span class="line">            dp[<span class="number">1</span>][<span class="number">0</span>] = <span class="built_in">max</span>(dp[<span class="number">0</span>][<span class="number">1</span>] - prices[i], dp[<span class="number">0</span>][<span class="number">0</span>]);</span><br><span class="line">            <span class="comment">// 1.今天卖出股票，得到的钱是上一天买入股票剩余价值+今天卖出的价格</span></span><br><span class="line">            <span class="comment">// 2.今天不卖出股票，沿用上一天的结果</span></span><br><span class="line">            dp[<span class="number">1</span>][<span class="number">1</span>] = <span class="built_in">max</span>(prices[i] + dp[<span class="number">0</span>][<span class="number">0</span>], dp[<span class="number">0</span>][<span class="number">1</span>]);</span><br><span class="line">            <span class="comment">// 把当前值挪过去，作为上一行的结果</span></span><br><span class="line">            dp[<span class="number">0</span>][<span class="number">0</span>] = dp[<span class="number">1</span>][<span class="number">0</span>];</span><br><span class="line">            dp[<span class="number">0</span>][<span class="number">1</span>] = dp[<span class="number">1</span>][<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">1</span>][<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="The-end"><a href="#The-end" class="headerlink" title="The end"></a>The end</h1><p>股票是一系列的题目，这道题只是个简单开胃菜而已！</p>]]></content>
    
    
    <summary type="html">leetcode刷题笔记-121.买卖股票的最佳时机</summary>
    
    
    
    <category term="编程学习" scheme="https://blog.musnow.top/categories/%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="把题目都给刷干净" scheme="https://blog.musnow.top/categories/%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0/%E6%8A%8A%E9%A2%98%E7%9B%AE%E9%83%BD%E7%BB%99%E5%88%B7%E5%B9%B2%E5%87%80/"/>
    
    
    <category term="OJ刷题" scheme="https://blog.musnow.top/tags/OJ%E5%88%B7%E9%A2%98/"/>
    
    <category term="leetcode" scheme="https://blog.musnow.top/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>【leetcode】96.不同的二叉搜索树</title>
    <link href="https://blog.musnow.top/posts/3165124961/"/>
    <id>https://blog.musnow.top/posts/3165124961/</id>
    <published>2024-04-23T04:42:36.000Z</published>
    <updated>2024-04-23T05:14:56.000Z</updated>
    
    <content type="html"><![CDATA[<p>leetcode刷题笔记，96.不同的二叉搜索树。</p><h1 id="96-不同的二叉搜索树"><a href="#96-不同的二叉搜索树" class="headerlink" title="96.不同的二叉搜索树"></a>96.不同的二叉搜索树</h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><blockquote><p><a href="https://leetcode.cn/problems/unique-binary-search-trees/">https://leetcode.cn/problems/unique-binary-search-trees/</a></p></blockquote><p>给你一个整数 n ，求恰由 n 个节点组成且节点值从 1 到 n 互不相同的 二叉搜索树 有多少种？返回满足题意的二叉搜索树的种数。</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/04/eccdeb0edf954d5beeb65a50b53b2d8e.png" alt="image.png"></p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>这道题是道动态规划的题目，动态规划的最重要的就是找到迭代的方程。</p><p>可以先举例几个不同的二叉搜索树情况，再找找有没有啥规律可循。首先是最简单的单个节点和两个节点的树，单个节点的二叉树只有1种情况，两个节点的二叉树有2种情况。</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/04/9f1f0931587a1accb88aff60544e6597.png" alt="image.png"></p><p>如果是三个节点的二叉搜索树呢？以leetcode给出的示例图</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/04/c0ed905aa1b3549575006342a0fb7908.png" alt="image.png"></p><p>从图中可以总结出三种不同的情况，假设<code>f(x)</code>为有x元素的二叉搜索树的种类个数。</p><ul><li>当1为根节点的时候，左子树为空，右子树2个元素，那么当前树的形态数量就是 <code>f(0) * f(2)</code>，即只由右边的两个元素的树的形态数量决定；</li><li>当2为根节点的时候，左右子树都有1个元素，此时树的形态数量是 <code>f(1) * f(1)</code>，即由两个元素只有1的树的形态数量组合决定；</li><li>当3为根节点的时候，右子树为空，左子树2个元素，这和1为根节点的情况类似，即当前树只由左边两个元素的树的形态数量决定，<code>f(2) * f(0)</code>；</li></ul><p>由此可得x为3的时候二叉搜索树的种类的计算公式</p><p>$$<br>f(3) &#x3D; f(0) * f(2) + f(1) * f(1) + f(2) * f(0)<br>$$</p><p>这里就还需要确定一下<code>f(0)</code>应该是什么值了，<strong>因为空树也可以视作树的一种情况</strong>，再加上在当前的递推公式种涉及到了对<code>f(0)</code>的计算，所以应该将其初始化为1。否则计算的时候相关的值都为0了。</p><p>上面的这个公式结论，还可以推广到i个节点的树的情况：</p><p>$$<br>f(i) &#x3D; f(0) * f(i-1) + f(1) * f(i-2) + … + f(i-1) * f(0)<br>$$</p><p>我们需要计算有n个节点的二叉搜索树种类，可以用这个递推公式一直从1计算到n，即可得到最终的结果。<strong>其本质就是将一个大的二叉搜索树不断拆分成小的树</strong>。</p><blockquote><p>关于拆分这一点，可以参考一篇写的还不错的<a href="https://leetcode.cn/problems/unique-binary-search-trees/solutions/331743/er-cha-sou-suo-shu-fu-xi-li-zi-jie-shi-si-lu-by-xi/">题解</a>，详细介绍了整个拆分的思路。</p><p>我们可以认为我们需要遍历的是一个1到n的数组，那么从这个数组中，不管从哪一个位置“提起”这棵树，最终得到的都是一个符合二叉搜索树规定的树（可以参考<a href="https://leetcode.cn/problems/convert-sorted-array-to-binary-search-tree/">从有序数组构造二叉搜索树</a>的OJ题）。这样我们就可以使用二分的思想不断将树拆分，直到拆分成只有1个元素的树的情况。</p></blockquote><p>那么代码中应该怎么处理呢？这里需要多层循环，我们需要将计算公式改成<strong>循环的累加</strong>（总不可能一直写个很长的公式吧）</p><p>首先外层循环是从1递推到n，内层循环是进行每一次有i个元素的二叉搜索树的节点数量计算。这样就实现了递推的计算。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// i代表当前树中有几个节点</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">    <span class="comment">// j是单个循环中的处理，我们需要从0 * i-1 一直走到 i-1 * 0</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= i; j++) &#123;</span><br><span class="line">        v[i] += v[j - <span class="number">1</span>] * v[i - j];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>完整代码如下，注意vector中的所有元素需要初始化为0，否则无法正常进行累加。根据上述思路将<code>v[0]=1</code>初始化，然后用循环一直计算到n，最后<code>v[n]</code>就是我们需要的结果。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">numTrees</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">v</span><span class="params">(n + <span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">        v[<span class="number">0</span>] = <span class="number">1</span>; <span class="comment">// 没有节点的数也算一颗树</span></span><br><span class="line">        <span class="comment">// i代表当前树中有几个节点</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="comment">// j是单个循环中的处理，我们需要从0 * i-1 一直走到 i-1 * 0</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= i; j++) &#123;</span><br><span class="line">                v[i] += v[j - <span class="number">1</span>] * v[i - j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> v[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 下面这个题解比较好理解一些。首先要知道这个题目的答案是可以被缩小范围的</span></span><br><span class="line"><span class="comment">// https://leetcode.cn/problems/unique-binary-search-trees/solutions/331743/er-cha-sou-suo-shu-fu-xi-li-zi-jie-shi-si-lu-by-xi/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 需要得出某个值为根节点的时候，这颗树的形态个数是(左边节点数量时的形态个数)*(右边节点数量时的形态个数)</span></span><br><span class="line"><span class="comment">// 以[1,2,3]为例</span></span><br><span class="line"><span class="comment">// 当1为根节点的时候，左子树为空，右子树2个元素，那么当前树的形态数量就是 f(0) * f(2)，即只由右边的两个元素的树的形态数量决定</span></span><br><span class="line"><span class="comment">// 当2为根节点的时候，左右子树都有1个元素，此时树的形态数量是 f(1) * f(1)，即由两个元素只有1的树的形态数量组合决定</span></span><br><span class="line"><span class="comment">// 当3为根节点的时候，右子树为空，左子树2个元素，这和1为根节点的情况类似，即当前树只由左边两个元素的树的形态数量决定，f(2) * f(0)</span></span><br><span class="line"><span class="comment">// 这下就可以得到公式 f(3) = f(0) * f(2) + f(1) * f(1) + f(2) * f(0)</span></span><br><span class="line"><span class="comment">// 进一步得到i的公式 f(i) = f(0) * f(i-1) + f(1) * f(i-2) + ... + f(i-1) * f(0)</span></span><br><span class="line"><span class="comment">// 我们要做的就是把这个公式转换成一个循环中的累加，即上面代码中的for循环。</span></span><br><span class="line"><span class="comment">// 注意vector中的值应该都初始化为0，不然累加的时候会出问题。</span></span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/04/c99f72733da40e98adc4c08fdfd29207.png" alt="image.png"></p>]]></content>
    
    
    <summary type="html">leetcode刷题笔记-96.不同的二叉搜索树</summary>
    
    
    
    <category term="编程学习" scheme="https://blog.musnow.top/categories/%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="把题目都给刷干净" scheme="https://blog.musnow.top/categories/%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0/%E6%8A%8A%E9%A2%98%E7%9B%AE%E9%83%BD%E7%BB%99%E5%88%B7%E5%B9%B2%E5%87%80/"/>
    
    
    <category term="OJ刷题" scheme="https://blog.musnow.top/tags/OJ%E5%88%B7%E9%A2%98/"/>
    
    <category term="leetcode" scheme="https://blog.musnow.top/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>【leetcode】95.不同的二叉搜索树2</title>
    <link href="https://blog.musnow.top/posts/2470995449/"/>
    <id>https://blog.musnow.top/posts/2470995449/</id>
    <published>2024-04-23T04:42:36.000Z</published>
    <updated>2024-04-24T06:17:48.000Z</updated>
    
    <content type="html"><![CDATA[<p>leetcode刷题笔记-95.不同的二叉搜索树2</p><h1 id="95-不同的二叉搜索树2"><a href="#95-不同的二叉搜索树2" class="headerlink" title="95.不同的二叉搜索树2"></a>95.不同的二叉搜索树2</h1><blockquote><p><a href="https://leetcode.cn/problems/unique-binary-search-trees-ii/description/">https://leetcode.cn/problems/unique-binary-search-trees-ii/description/</a></p></blockquote><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给你一个整数 n ，请你生成并返回所有由 n 个节点组成且节点值从 1 到 n 互不相同的不同 二叉搜索树 。可以按 任意顺序 返回答案。</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/04/a74b8f2a30da6f406cc7cd01228c856d.png" alt="image.png"></p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>这道题需要在96题的基础上，构造这些不同的二叉树并返回。</p><p>乍一看好像是一个回溯的思路，但个人感觉更像是一个普通的分治递归，回溯的思想体现的不是很明显。</p><p>首先基本的想法还是要把这个树进行拆分，可以用区间作为递归函数的参数，区间越界的时候就返回。</p><p>在那之前，我们需要确定递归的返回值。注意本题的返回值是一个<code>vector&lt;TreeNode*&gt;</code>数组，而且并<strong>不能</strong>套用回溯题中在<strong>递归返回时插入结果集</strong>的思路，那样是在叶子节点插入，而本题需要的是根节点。</p><p>所以我们应该直接用<code>vector&lt;TreeNode*&gt;</code>作为递归函数的返回值，在每一层的循环结束后返回这个数组。数组值的含义是以本层区间为根节点，可以得到的不同子树集合。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;TreeNode*&gt; curTree; <span class="comment">// 当前层可能的树的集合</span></span><br></pre></td></tr></table></figure><p>确定了返回值，就可以写出递归的终止条件了，区间不合法的时候，返回一个包含nullptr的空数组。即代表空节点。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 两个区间越界，返回空</span></span><br><span class="line"><span class="keyword">if</span> (begin &gt; end) &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;<span class="literal">nullptr</span>&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在每一层循环中，我们尝试使用begin和end中的任意一个节点作为二叉搜索树的根节点，然后递归遍历左区间和右区间，构造符合条件的子树数组。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = begin; i &lt;= end; i++) &#123;</span><br><span class="line"><span class="comment">// 递归左右区间，注意begin和end都是闭区间，应该跳过i自己</span></span><br><span class="line">vector&lt;TreeNode*&gt; leftTree = _generateTrees(begin, i - <span class="number">1</span>);</span><br><span class="line">    vector&lt;TreeNode*&gt; rightTree = _generateTrees(i + <span class="number">1</span>, end);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后再将得到的子树数组拼起来。此时拼起来的树就可以插入当前层的完整树数组中了</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 遍历左右子树，构造可能的树的集合</span></span><br><span class="line"><span class="comment">// 如果是叶子节点，此时left和right应该都是一个&#123;nullptr&#125;</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span>&amp; left : leftTree) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span>&amp; right : rightTree) &#123;</span><br><span class="line"><span class="comment">// 直接用构造函数传参</span></span><br><span class="line">TreeNode* root = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(i, left, right);</span><br><span class="line">curTree.<span class="built_in">push_back</span>(root);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后循环终止，将得到的curTree数组返回。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>完整代码如下。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    vector&lt;TreeNode*&gt; _generateTrees(<span class="type">int</span> begin, <span class="type">int</span> end) &#123;</span><br><span class="line">        <span class="comment">// 两个区间越界，返回空</span></span><br><span class="line">        <span class="keyword">if</span> (begin &gt; end) &#123;</span><br><span class="line">            <span class="keyword">return</span> &#123;<span class="literal">nullptr</span>&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">        vector&lt;TreeNode*&gt; curTree; <span class="comment">// 当前层可能的树的集合</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = begin; i &lt;= end; i++) &#123;</span><br><span class="line">            <span class="comment">// 获取左右子树的可能的树的集合，而不是单个树（递归子区间的树集合，直到空节点）</span></span><br><span class="line">            vector&lt;TreeNode*&gt; leftTree = _generateTrees(begin, i - <span class="number">1</span>);</span><br><span class="line">            vector&lt;TreeNode*&gt; rightTree = _generateTrees(i + <span class="number">1</span>, end);</span><br><span class="line">            <span class="comment">// 遍历左右子树，构造可能的树的集合</span></span><br><span class="line">            <span class="comment">// 如果是叶子节点，此时left和right应该都是一个&#123;nullptr&#125;</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; left : leftTree) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; right : rightTree) &#123;</span><br><span class="line">                    <span class="comment">// 直接用构造函数传参</span></span><br><span class="line">                    TreeNode* root = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(i, left, right);</span><br><span class="line">                    curTree.<span class="built_in">push_back</span>(root);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 返回给上一层</span></span><br><span class="line">        <span class="keyword">return</span> curTree;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;TreeNode*&gt; <span class="title">generateTrees</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 递归生成1到n的树</span></span><br><span class="line">        <span class="keyword">return</span> _generateTrees(<span class="number">1</span>, n);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/04/0f4b773bcfd55124ac01f2de30d12606.png" alt="image.png"></p><p>这道题和其他题目的区别在于，之前写的二叉树题目，大多数是构建单科树，我们直接用<code>TreeNode*</code>作为返回值，而这道题需要的是符合条件的树的集合，所以返回值需要改成vector。</p>]]></content>
    
    
    <summary type="html">leetcode刷题笔记-95.不同的二叉搜索树2</summary>
    
    
    
    <category term="编程学习" scheme="https://blog.musnow.top/categories/%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="把题目都给刷干净" scheme="https://blog.musnow.top/categories/%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0/%E6%8A%8A%E9%A2%98%E7%9B%AE%E9%83%BD%E7%BB%99%E5%88%B7%E5%B9%B2%E5%87%80/"/>
    
    
    <category term="OJ刷题" scheme="https://blog.musnow.top/tags/OJ%E5%88%B7%E9%A2%98/"/>
    
    <category term="leetcode" scheme="https://blog.musnow.top/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>【Linux】如何用一条命令终止某个后台进程？</title>
    <link href="https://blog.musnow.top/posts/656037608/"/>
    <id>https://blog.musnow.top/posts/656037608/</id>
    <published>2024-04-23T01:14:50.000Z</published>
    <updated>2024-05-04T01:01:30.000Z</updated>
    
    <content type="html"><![CDATA[<p>在面试的时候被问道了这个问题，之前还从来没有了解过</p><h1 id="1-怎么终止某个进程？"><a href="#1-怎么终止某个进程？" class="headerlink" title="1.怎么终止某个进程？"></a>1.怎么终止某个进程？</h1><p>如果你学过Linux下的信号处理，这个问题应该不难答。在Linux下，使用kill命令发送信号给进程，其中9号信号<code>SIGKILL</code>就可以将进程终止。</p><p>还有很多其他信号也能终止进程，比如前台进程使用<code>CTRL+C</code>会发送2号信号，也能终止进程。但是9号信号<strong>是不能被自定义捕获</strong>的，进程收到9号信号后一定会被终止。</p><p>后台进程就需要我们知道这个进程的名字，然后查询这个进程的PID，再用kill发送信号将其终止。在之前我都是用下面这两个命令来处理的</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ps jax | grep 进程名 | grep -v grep</span><br><span class="line">kill -9 进程PID</span><br></pre></td></tr></table></figure><p>现在的问题就变成了，如何将这两条命令变成一条命令？</p><h1 id="2-如何用一条命令终止后台进程？"><a href="#2-如何用一条命令终止后台进程？" class="headerlink" title="2.如何用一条命令终止后台进程？"></a>2.如何用一条命令终止后台进程？</h1><h2 id="2-1-pkill-x2F-killall"><a href="#2-1-pkill-x2F-killall" class="headerlink" title="2.1 pkill&#x2F;killall"></a>2.1 pkill&#x2F;killall</h2><p>在Linux下除了kill命令，还有这两个命令，他们可以通过传入进程名字来删除某个进程</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pkill 进程名</span><br><span class="line">killall 进程名</span><br></pre></td></tr></table></figure><p>如下所示，我用c语言写了个死循环的程序，并让其后台运行。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">❯ ./test &amp;</span><br><span class="line">[1] 2578</span><br></pre></td></tr></table></figure><p>随后，可以使用pkill命令直接终止这个程序</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">❯ ps jax | grep test | grep -v grep</span><br><span class="line">   2265    2578    2578    2265 pts/5       3337 SN    1000   0:00 ./test</span><br><span class="line">❯ pkill test                       </span><br><span class="line">[1]  + 2578 terminated  ./test</span><br></pre></td></tr></table></figure><p>killall命令也是同理，需要注意的是，如果有两个同名的进程，这两个进程都会被终止。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">❯ killall test</span><br><span class="line">[1]  - 7309 terminated  ./test</span><br><span class="line">[2]  + 7327 terminated  ./test</span><br></pre></td></tr></table></figure><p>pkill和killall的区别在于，pkill是用<strong>正则捕获</strong>的方式来查询某个进程的，即输入test，实际上会删除所有进程名中包含test的进程。而killall则是完全捕获，必须是名字为test的进程才会被删除。</p><p>如下所示，使用<code>pkill est</code>命令，同样会删除test进程。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">❯ pkill est                        </span><br><span class="line">[1]  + 7664 terminated  ./test</span><br></pre></td></tr></table></figure><p>而killall则不会，会显示该进程名找不到对应进程。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">❯ killall est </span><br><span class="line">est: no process found</span><br></pre></td></tr></table></figure><h2 id="2-2-ps-kill-管道"><a href="#2-2-ps-kill-管道" class="headerlink" title="2.2 ps+kill+管道"></a>2.2 ps+kill+管道</h2><p>因为没有接触过上面的pkill命令，所以我当时面试的时候只能想到通过管道的方式来查询进程PID并将其传给kill命令。不过因为对linux下命令行的管道了解的并不多，具体怎么写命令也说不出来。</p><p>我们知道，使用ps命令的时候，显示的数据中第二列是该进程的PID，第一列是父进程的PID。即我们需要想办法把这个结果中第二列的值给取出来。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">❯ ps jax | grep test | grep -v grep                          </span><br><span class="line">   2265    9356    9356    2265 pts/5       9450 SN    1000   0:00 ./test</span><br></pre></td></tr></table></figure><p>使用awk命令就能做到这一点，从匹配的行中取出第二列，即得到了我们需要的进程PID。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">❯ ps jax | grep test | grep -v grep | awk &#x27;&#123;print $2&#125;&#x27;</span><br><span class="line">9356</span><br></pre></td></tr></table></figure><p>现在要做的就是用<code>$</code>号将这个命令的结果传给kill命令，这样就实现了用一条命令终止进程了。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">❯ kill -9 $(ps jax | grep test | grep -v grep | awk &#x27;&#123;print $2&#125;&#x27;)</span><br><span class="line">[1]  + 9356 killed     ./test  </span><br></pre></td></tr></table></figure><h1 id="The-end"><a href="#The-end" class="headerlink" title="The end"></a>The end</h1><p>有其他办法，欢迎在评论区交流!</p>]]></content>
    
    
    <summary type="html">Linux下如何用一条命令终止某个后台进程？</summary>
    
    
    
    <category term="编程学习" scheme="https://blog.musnow.top/categories/%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="Linux" scheme="https://blog.musnow.top/categories/%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0/Linux/"/>
    
    
    <category term="Linux" scheme="https://blog.musnow.top/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>【leetcode】62不同路径和63不同路径2</title>
    <link href="https://blog.musnow.top/posts/4112588292/"/>
    <id>https://blog.musnow.top/posts/4112588292/</id>
    <published>2024-04-20T02:31:40.000Z</published>
    <updated>2024-04-21T10:15:09.000Z</updated>
    
    <content type="html"><![CDATA[<p>leetcode刷题笔记-62不同路径和63不同路径2</p><h1 id="62-不同路径"><a href="#62-不同路径" class="headerlink" title="62 不同路径"></a>62 不同路径</h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><blockquote><p><a href="https://leetcode.cn/problems/unique-paths/">https://leetcode.cn/problems/unique-paths/</a></p></blockquote><p>一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为 “Start” ）。</p><p>机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为 “Finish” ）。</p><p>问总共有多少条不同的路径？</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/04/5e4de878ae09ea64c4aab67e2e471800.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">示例 2：</span><br><span class="line">输入：m = 3, n = 2</span><br><span class="line">输出：3</span><br><span class="line">解释：</span><br><span class="line">从左上角开始，总共有 3 条路径可以到达右下角。</span><br><span class="line">1. 向右 -&gt; 向下 -&gt; 向下</span><br><span class="line">2. 向下 -&gt; 向下 -&gt; 向右</span><br><span class="line">3. 向下 -&gt; 向右 -&gt; 向下</span><br><span class="line"></span><br><span class="line">示例 3：</span><br><span class="line">输入：m = 7, n = 3</span><br><span class="line">输出：28</span><br><span class="line"></span><br><span class="line">示例 4：</span><br><span class="line">输入：m = 3, n = 3</span><br><span class="line">输出：6</span><br></pre></td></tr></table></figure><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>这道题需要用动态规划的方式来写。首先是确定递归数组每一位代表什么。根据题意可以想出来<code>dp[i][j]</code>代表走到<code>(i,j)</code>位置的可行步骤数量。</p><p>随后是考虑递归方程，因为机器人只能向右和向下走，很容易得到下面的方程。即能到达当前位置的方法是走到左边那位（下一步往右走）和上面那位（下一步向下走）的步骤数之和。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dp[i][j] = dp[i-1][j] + dp[i][j-1]</span><br></pre></td></tr></table></figure><p>再考虑怎么设置这个数组的初始值。因为机器人只能向下和向右走，即这个数组的第一行和第一列都只有一种办法可以抵达，即将第一行和第一列中的值都初始化为1。</p><p>再从<code>(1,1)</code>下标位置开始，使用公式计算出所有的值，并最终返回<code>dp[m-1][n-1]</code>作为答案。</p><h2 id="代码1：二维数组"><a href="#代码1：二维数组" class="headerlink" title="代码1：二维数组"></a>代码1：二维数组</h2><p>代码如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">uniquePaths</span><span class="params">(<span class="type">int</span> m, <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// m 是行，n是列</span></span><br><span class="line">        <span class="comment">// dp方程是 dp[i][j] = dp[i-1][j] + dp[i][j-1]</span></span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">v</span>(m, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(n));</span><br><span class="line">        <span class="comment">// 因为只能向右和向下走，从0,0开始</span></span><br><span class="line">        <span class="comment">// 所以能直接推出来一部分结果，将第一行和第一列都初始化为1</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">            v[i][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">            v[<span class="number">0</span>][j] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 其他部分是用dp计算</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; m; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt; n; j++) &#123;</span><br><span class="line">                <span class="comment">// 当前的路径数量是上一位往右（v[i][j-1]）和上一位往下（v[i - 1][j]）的和</span></span><br><span class="line">                v[i][j] = v[i - <span class="number">1</span>][j] + v[i][j - <span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> v[m - <span class="number">1</span>][n - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/04/2621d414d668164ac684f75daa9c1f94.png" alt="image.png"></p><h2 id="代码2：一维数组"><a href="#代码2：一维数组" class="headerlink" title="代码2：一维数组"></a>代码2：一维数组</h2><p>上述代码中的时间复杂度不好优化，但是空间复杂度是可以优化的。我们可以将这个二维数组改成一个n长度（每一行）的一维数组。</p><p>首先是将这个数组初始化为1（因为第一行只有1种方式可以到达）。</p><p>然后同样是从下标<code>(1,1)</code>位置开始遍历，此时的方程是<code>dp[i] += dp[i-1]</code>。</p><p>用这种方式，巧妙的将二维的操作改成了一维的。加等操作相当于保留了上一行的结果，加上<code>dp[i-1]</code>相当于保留了左边那位（下一步向右走）的结果。这个思路很巧妙，建议画个矩阵来自行理解一下。</p><p>最终的代码如下。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">uniquePaths</span><span class="params">(<span class="type">int</span> m, <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 初始化为1，相当于将第一行设置为1</span></span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(n, <span class="number">1</span>)</span></span>;</span><br><span class="line">        <span class="comment">// 从第二行开始</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; m; i++) &#123;</span><br><span class="line">            <span class="comment">// 从第二列开始，相当于保留第一列始终为1</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt; n; j++) &#123;</span><br><span class="line">                <span class="comment">// += 保留上一行的结果</span></span><br><span class="line">                <span class="comment">// 加上 dp[j-1] 等于左边的结果</span></span><br><span class="line">                dp[j] += dp[j - <span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 返回左下角的结果</span></span><br><span class="line">        <span class="keyword">return</span> dp[n - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/04/052de7e5d4df2cc9f20993a1500ff8d8.png" alt="image.png"></p><h1 id="63-不同路径2"><a href="#63-不同路径2" class="headerlink" title="63 不同路径2"></a>63 不同路径2</h1><h2 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h2><blockquote><p><a href="https://leetcode.cn/problems/unique-paths-ii/description/">https://leetcode.cn/problems/unique-paths-ii/description/</a></p></blockquote><p>一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为 “Start” ）。</p><p>机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为 “Finish”）。</p><p>现在考虑网格中有障碍物。那么从左上角到右下角将会有多少条不同的路径？</p><p>网格中的障碍物和空位置分别用 1 和 0 来表示。</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/04/f5be15ab447e49687ba1f38c75328b40.png" alt="image.png"></p><h2 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h2><p>这道题在62题的基础上多加了一个障碍物，遇到障碍物肯定就无法抵达了，需要我们针对障碍物进行处理。</p><p>先采用上一题的二维数组的思路，考虑遇到障碍物应该怎么处理。这里我想的办法是用<code>-1</code>来标识障碍物，即当前位置无法到达。</p><ul><li>第一行和第一列有障碍物，往后的位置都无法抵达，往后的位置都要初始化为<code>-1</code>；</li><li>判断<code>obstacleGrid[i][j]</code>是否有障碍物，有则<code>dp[i][j]</code>为<code>-1</code>，无法抵达；</li><li><code>dp[i][j]</code>需要判断<code>dp[i-1][j]</code> 和 <code>dp[i][j-1]</code> 这两个位置是否有障碍物<ul><li>如果两个位置都是负一，则代表<code>dp[i][j]</code>无法到达，初始化为<code>-1</code>；</li><li>只有一个位置是负一，则代表当前位置可以到达，值为不为负一的那一个；</li><li>两个位置都不为负一，则是正常的情况，值为<code>dp[i-1][j] + dp[i][j-1]</code>。</li></ul></li></ul><p>把这些情况都考虑上，只需要在原本的代码上修改一下就可以了</p><h2 id="代码1"><a href="#代码1" class="headerlink" title="代码1"></a>代码1</h2><p>特别要注意的是第一行和第一列的情况，因为他们都只有一条可行的路径，那只要遇到了一个阻碍，后面的位置就都到不了了！都需要赋值为0！</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">uniquePathsWithObstacles</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; obstacleGrid)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> m = obstacleGrid.<span class="built_in">size</span>(), n = obstacleGrid[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        <span class="comment">// m 是行，n是列</span></span><br><span class="line">        <span class="comment">// dp方程是 dp[i][j] = dp[i-1][j] + dp[i][j-1]</span></span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">v</span>(m, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(n));</span><br><span class="line">        <span class="comment">// 因为只能向右和向下走，从0,0开始</span></span><br><span class="line">        <span class="comment">// 所以能直接推出来一部分结果，将第一行和第一列都初始化为1</span></span><br><span class="line">        <span class="type">bool</span> isBlock = <span class="literal">false</span>; <span class="comment">// 是否有阻碍？</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (obstacleGrid[i][<span class="number">0</span>] == <span class="number">1</span> || isBlock) &#123;</span><br><span class="line">                v[i][<span class="number">0</span>] = <span class="number">-1</span>; <span class="comment">// 不能走的初始化为负一</span></span><br><span class="line">                isBlock = <span class="literal">true</span>; <span class="comment">// 注意，只要有一个阻碍，就不能往下走了</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                v[i][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        isBlock = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (obstacleGrid[<span class="number">0</span>][j] == <span class="number">1</span> || isBlock) &#123;</span><br><span class="line">                v[<span class="number">0</span>][j] = <span class="number">-1</span>; <span class="comment">// 不能走的初始化为负一</span></span><br><span class="line">                isBlock = <span class="literal">true</span>; <span class="comment">// 注意，只要有一个阻碍，就不能往下走了</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                v[<span class="number">0</span>][j] = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 其他部分是用dp计算</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; m; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt; n; j++) &#123;</span><br><span class="line">                <span class="comment">// 当前的路径数量是上一位往右（v[i][j-1]）和上一位往下（v[i-1][j]）的和</span></span><br><span class="line">                <span class="comment">// 但是需要判断能不能走到这里，如果两个路径都不能走，则跳过这个位置</span></span><br><span class="line">                <span class="type">int</span> left = v[i][j - <span class="number">1</span>];</span><br><span class="line">                <span class="type">int</span> up = v[i - <span class="number">1</span>][j];</span><br><span class="line">                <span class="comment">// 两个都不能走，或者当前位置有障碍，说明当前位置到不了</span></span><br><span class="line">                <span class="keyword">if</span> (obstacleGrid[i][j] == <span class="number">1</span> || (left &lt; <span class="number">0</span> &amp;&amp; up &lt; <span class="number">0</span>)) &#123;</span><br><span class="line">                    v[i][j] = <span class="number">-1</span>;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 到的了，修正值</span></span><br><span class="line">                <span class="keyword">if</span> (left &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                    left = <span class="number">0</span>; <span class="comment">// 不能走的初始化为0</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (up &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                    up = <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                v[i][j] = up + left;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 因为我是用-1来设置到不了的，最终就需要修正为0</span></span><br><span class="line">        <span class="keyword">return</span> v[m - <span class="number">1</span>][n - <span class="number">1</span>] == <span class="number">-1</span> ? <span class="number">0</span> : v[m - <span class="number">1</span>][n - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/04/51435a0609c3c9afd0ee358a29958919.png" alt="image.png"></p><h2 id="代码2"><a href="#代码2" class="headerlink" title="代码2"></a>代码2</h2><p>实际上完全不需要用负一来标识到不了，每一次还需要判断将其修正为0。我们直接用0代表到不了就行了，可以节省几个判断，代码看起来也会舒服一点。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">uniquePathsWithObstacles</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; obstacleGrid)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// m 是行，n是列</span></span><br><span class="line">        <span class="type">int</span> m = obstacleGrid.<span class="built_in">size</span>(), n = obstacleGrid[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">v</span>(m, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(n));</span><br><span class="line">        <span class="comment">// 因为只能向右和向下走，从0,0开始</span></span><br><span class="line">        <span class="comment">// 所以能直接推出来一部分结果，将第一行和第一列都初始化为1</span></span><br><span class="line">        <span class="type">bool</span> isBlock = <span class="literal">false</span>; <span class="comment">// 是否有阻碍？</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (obstacleGrid[i][<span class="number">0</span>] == <span class="number">1</span> || isBlock) &#123;</span><br><span class="line">                v[i][<span class="number">0</span>] = <span class="number">0</span>; <span class="comment">// 不能走的初始化为0</span></span><br><span class="line">                isBlock = <span class="literal">true</span>; <span class="comment">// 注意，只要有一个阻碍，就不能往下走了</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                v[i][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        isBlock = <span class="literal">false</span>; <span class="comment">// 是否有阻碍？</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (obstacleGrid[<span class="number">0</span>][j] == <span class="number">1</span> || isBlock) &#123;</span><br><span class="line">                v[<span class="number">0</span>][j] = <span class="number">0</span>; <span class="comment">// 不能走的初始化为0</span></span><br><span class="line">                isBlock = <span class="literal">true</span>; <span class="comment">// 注意，只要有一个阻碍，就不能往下走了</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                v[<span class="number">0</span>][j] = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 其他部分是用dp计算</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; m; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt; n; j++) &#123;</span><br><span class="line">                <span class="comment">// 当前的路径数量是上一位往右（v[i][j-1]）和上一位往下（v[i-1][j]）的和</span></span><br><span class="line">                <span class="comment">// 但是需要判断能不能走到这里，如果两个路径都不能走，则跳过这个位置</span></span><br><span class="line">                <span class="type">int</span> left = v[i][j - <span class="number">1</span>];</span><br><span class="line">                <span class="type">int</span> up = v[i - <span class="number">1</span>][j];</span><br><span class="line">                <span class="comment">// 两个都不能走，或者当前位置有障碍，说明当前位置到不了</span></span><br><span class="line">                <span class="keyword">if</span> (obstacleGrid[i][j] == <span class="number">1</span> || (left &lt;= <span class="number">0</span> &amp;&amp; up &lt;= <span class="number">0</span>)) &#123;</span><br><span class="line">                    v[i][j] = <span class="number">0</span>; <span class="comment">// 走不了</span></span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                v[i][j] = up + left;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> v[m - <span class="number">1</span>][n - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/04/4a5ed2590bcf1250401ea4c807849f15.png" alt="image.png"></p>]]></content>
    
    
    <summary type="html">leetcode刷题笔记-62不同路径和63不同路径2</summary>
    
    
    
    <category term="编程学习" scheme="https://blog.musnow.top/categories/%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="把题目都给刷干净" scheme="https://blog.musnow.top/categories/%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0/%E6%8A%8A%E9%A2%98%E7%9B%AE%E9%83%BD%E7%BB%99%E5%88%B7%E5%B9%B2%E5%87%80/"/>
    
    
    <category term="OJ刷题" scheme="https://blog.musnow.top/tags/OJ%E5%88%B7%E9%A2%98/"/>
    
    <category term="leetcode" scheme="https://blog.musnow.top/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>【C语言】static和extern的作用</title>
    <link href="https://blog.musnow.top/posts/3198614716/"/>
    <id>https://blog.musnow.top/posts/3198614716/</id>
    <published>2024-04-18T04:21:36.000Z</published>
    <updated>2024-04-19T05:11:05.000Z</updated>
    
    <content type="html"><![CDATA[<p>简单介绍C&#x2F;C++中static关键字和extern关键字的作用。</p><h1 id="1-简介"><a href="#1-简介" class="headerlink" title="1.简介"></a>1.简介</h1><p>在之前的博客中，提到过static的三个作用，但是没有详细说明这三个作用的场景，现在回过头来记录一下。</p><ol><li>修饰函数</li><li>修饰全局变量</li><li>修饰函数内变量</li></ol><p>static还有一个隐藏的特性，即变量会被默认设置为0，因为静态区&#x2F;全局区的内存区域在初始化的时候都是0。</p><p>在C++的类和对象中，static还多了一个作用，即修饰C++类的成员变量或函数。被修饰的成员属于整个类，可以直接通过类的作用域来访问（前提是公有），这不是本文的重点。</p><h1 id="2-static修饰函数-x2F-变量"><a href="#2-static修饰函数-x2F-变量" class="headerlink" title="2.static修饰函数&#x2F;变量"></a>2.static修饰函数&#x2F;变量</h1><p>对于修饰函数和变量而言，作用基本是一致的，即限制这个函数&#x2F;变量的作用域，让他只对当前文件可见。</p><h2 id="修饰变量"><a href="#修饰变量" class="headerlink" title="修饰变量"></a>修饰变量</h2><p>给定下面两个文件</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// a.cpp</span></span><br><span class="line"><span class="type">int</span> aGlobal = <span class="number">10</span>;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> bGlobal = <span class="number">20</span>;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// b.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 声明文件a.cpp中的全局变量</span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">int</span> aGlobal;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; aGlobal &lt;&lt; endl;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在<code>b.cpp</code>中，使用了extern关键字来声明属于另外一个cpp文件中的全局变量，用如下命令编译成可执行文件test。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">g++ b.cpp a.cpp -o test</span><br></pre></td></tr></table></figure><p>在Ubuntu上进行测试，编译成功，运行能成功打印出10，符合预期。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">❯ g++ a.cpp b.cpp -o test</span><br><span class="line">❯ ./test</span><br><span class="line">10</span><br></pre></td></tr></table></figure><p>而被static修饰过的bGlobal就不能用这种方式被另外一个文件访问了。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// b.cpp 修改后</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 声明文件a.cpp中的全局变量</span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">int</span> bGlobal;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; bGlobal &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用相同的命令进行编译，此时就会报错了。因为static关键字将bGlobal这个全局变量的作用域限制在了<code>a.cpp</code>文件中，其他文件无法访问！</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">❯ g++ a.cpp b.cpp -o test</span><br><span class="line">/usr/bin/ld: /tmp/ccj43Xl9.o: warning: relocation against `bGlobal&#x27; in read-only section `.text&#x27;</span><br><span class="line">/usr/bin/ld: /tmp/ccj43Xl9.o: in function `main&#x27;:</span><br><span class="line">b.cpp:(.text+0xa): undefined reference to `bGlobal&#x27;</span><br><span class="line">/usr/bin/ld: warning: creating DT_TEXTREL in a PIE</span><br><span class="line">collect2: error: ld returned 1 exit status</span><br></pre></td></tr></table></figure><p>这里有个必须要注意的点，我们在<code>b.cpp</code>中并没有<code>#include &quot;a.cpp&quot;</code>，如果添加了include，那么上面的结论就无效了。因为include会在预编译期间被展开，此时<code>a.cpp</code>中的全局变量定义直接被添加在了<code>b.cpp</code>上面，并不属于两个文件的情况。比如下面的代码就可以正常编译通过。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 错误的测试逻辑</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;a.cpp&quot;</span> <span class="comment">// 引用了a.cpp</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 声明文件a.cpp中的全局变量？此时a.cpp都已经被展开了，完全不是另外一个文件了！</span></span><br><span class="line"><span class="comment">// extern int bGlobal; // 这一行加不加没有任何区别</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; bGlobal &lt;&lt; endl;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如下所示，编译成功且打印了bGlobal的值</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">❯ g++ b.cpp -o test</span><br><span class="line">❯ ./test</span><br><span class="line">20</span><br></pre></td></tr></table></figure><p>注意这里编译的时候不能再添加<code>a.cpp</code>了，因为此时已经被展开到了<code>b.cpp</code>之前，如果这样编译就会报错aGlobal重定义。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">❯ g++ a.cpp b.cpp -o test</span><br><span class="line">/usr/bin/ld: /tmp/cckcj9a5.o:(.data+0x0): multiple definition of `aGlobal&#x27;; /tmp/ccsNnuaN.o:(.data+0x0): first defined here</span><br><span class="line">collect2: error: ld returned 1 exit status</span><br></pre></td></tr></table></figure><h2 id="修饰函数"><a href="#修饰函数" class="headerlink" title="修饰函数"></a>修饰函数</h2><p>修饰函数的作用同理，没有修饰的函数可以被另外一个文件extern后调用，修饰后的不可以。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// a.cpp</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Add</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a+b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// b.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 声明文件a.cpp中的函数</span></span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="type">int</span> <span class="title">Add</span><span class="params">(<span class="type">int</span>,<span class="type">int</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="built_in">Add</span>(<span class="number">10</span>,<span class="number">20</span>) &lt;&lt; endl;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译成功，且调用Add函数成功。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">❯ g++ a.cpp b.cpp -o test</span><br><span class="line">❯ ./test</span><br><span class="line">30</span><br></pre></td></tr></table></figure><p>Add函数添加了static后就无法被extern调用了</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">❯ g++ a.cpp b.cpp -o test</span><br><span class="line">/usr/bin/ld: /tmp/ccFe9oSW.o: in function `main&#x27;:</span><br><span class="line">b.cpp:(.text+0x13): undefined reference to `Add(int, int)&#x27;</span><br><span class="line">collect2: error: ld returned 1 exit status</span><br></pre></td></tr></table></figure><h1 id="3-static修饰函数内变量"><a href="#3-static修饰函数内变量" class="headerlink" title="3.static修饰函数内变量"></a>3.static修饰函数内变量</h1><p>你可能见过这样的写法，在函数内定义一个static变量，并作为返回值</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">char</span>* <span class="title">Add</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span></span>&#123;</span><br><span class="line"><span class="type">static</span> <span class="type">char</span> arr[<span class="number">2</span>];</span><br><span class="line">arr[<span class="number">0</span>] = (<span class="type">char</span>)a + <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">arr[<span class="number">1</span>] = (<span class="type">char</span>)b + <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line"><span class="keyword">return</span> arr; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用static修饰函数内的变量后，这个变量的作用域不再是函数体内了，而是扩展到了全局（可以理解为他就是一个全局变量）。</p><p>这种方式可以避免使用动态内存管理（malloc&#x2F;free）的空间作为返回值，因为那样可能会出现内存泄漏问题。比较常见的一个应用就是linux下的<code>inet_ntoa</code>函数，这个函数可以将IP地址的结构体转为IP的字符串，其内部就是用static的char数组作为返回值的，这也是为什么该函数不能在printf中连续调用，会导致后续的调用覆盖前面的结果。</p><blockquote><p>如果有函数是利用static作为返回值传参的，则应该用另外一个变量拷贝来保存这个结果，再执行下一次调用。</p></blockquote><p>需要注意的是，<strong>static的这一行定义只会在第一次进入函数的时候执行</strong>，后续不再会执行。比如下面的代码，如果你对static修饰的作用不太了解，你可能会认为isGood这个变量每次进入该函数都会被设置为false，从而只会让他进入if判断体的A区域，搞得这个if判断都没有意义了。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">TestFunc</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="type">static</span> <span class="type">bool</span> isGood = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">if</span>(!isGood)&#123;</span><br><span class="line"><span class="comment">// A...</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// B...</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但实际上，<strong>这个变量只有第一次调用这个函数的时候会被创建且赋值为false</strong>，后续不再会执行static这一行，所以函数体内（A区域和B区域可能会做一些处理再设置isGood变量的值）对isGood值的修改会沿用到下一次调用这个函数！</p><h1 id="4-static和编译"><a href="#4-static和编译" class="headerlink" title="4.static和编译"></a>4.static和编译</h1><p>为什么被static修饰的函数&#x2F;变量不会被其他文件看见？</p><p>因为在生成符号表的时候，每一个static变量即便变量名相同，也会<strong>生成不同的符号表项</strong>。所以在链接阶段符号表合并的时候，并不会将两个文件中同名的static变量合并在一起，所以其他文件也就没有办法访问到当前文件中被static修饰的函数&#x2F;变量。</p><p>而extern了一个static变量，<strong>就会因为符号表无法找到，而链接失败</strong>。注意观察G++的报错，都是ld和<code>.o</code>相关字样的，说明这个并不是编译器通过语法检查出来的错误，而是在链接<code>.o</code>目标文件的时候，发现无法链接该变量的时候因为错误而退出编译的。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">❯ g++ a.cpp b.cpp -o test</span><br><span class="line">/usr/bin/ld: /tmp/ccj43Xl9.o: warning: relocation against `bGlobal&#x27; in read-only section `.text&#x27;</span><br><span class="line">/usr/bin/ld: /tmp/ccj43Xl9.o: in function `main&#x27;:</span><br><span class="line">b.cpp:(.text+0xa): undefined reference to `bGlobal&#x27;</span><br><span class="line">/usr/bin/ld: warning: creating DT_TEXTREL in a PIE</span><br><span class="line">collect2: error: ld returned 1 exit status</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">简单介绍C中static关键字和extern关键字的作用。</summary>
    
    
    
    <category term="编程学习" scheme="https://blog.musnow.top/categories/%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="C语言" scheme="https://blog.musnow.top/categories/%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0/C%E8%AF%AD%E8%A8%80/"/>
    
    
    <category term="C语言" scheme="https://blog.musnow.top/tags/C%E8%AF%AD%E8%A8%80/"/>
    
    <category term="Cpp" scheme="https://blog.musnow.top/tags/Cpp/"/>
    
  </entry>
  
  <entry>
    <title>【leetcode】23.合并K个升序链表</title>
    <link href="https://blog.musnow.top/posts/788614935/"/>
    <id>https://blog.musnow.top/posts/788614935/</id>
    <published>2024-04-16T10:36:39.000Z</published>
    <updated>2024-04-17T07:13:29.000Z</updated>
    
    <content type="html"><![CDATA[<p>leetcode刷题笔记-23-合并K个升序链表</p><h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><blockquote><p><a href="https://leetcode.cn/problems/merge-k-sorted-lists/description/">https://leetcode.cn/problems/merge-k-sorted-lists/description/</a></p></blockquote><p>给你一个链表数组，每个链表都已经按升序排列。</p><p>请你将所有链表合并到一个升序链表中，返回合并后的链表。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">示例 1：</span><br><span class="line">输入：lists = [[1,4,5],[1,3,4],[2,6]]</span><br><span class="line">输出：[1,1,2,3,4,4,5,6]</span><br><span class="line">解释：链表数组如下：</span><br><span class="line">[</span><br><span class="line">  1-&gt;4-&gt;5,</span><br><span class="line">  1-&gt;3-&gt;4,</span><br><span class="line">  2-&gt;6</span><br><span class="line">]</span><br><span class="line">将它们合并到一个有序链表中得到。</span><br><span class="line">1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4-&gt;5-&gt;6</span><br><span class="line"></span><br><span class="line">示例 2：</span><br><span class="line">输入：lists = []</span><br><span class="line">输出：[]</span><br><span class="line"></span><br><span class="line">示例 3：</span><br><span class="line">输入：lists = [[]]</span><br><span class="line">输出：[]</span><br></pre></td></tr></table></figure><p>最简单的思路就是用一个数组记录所有链表，再用sort将这个数组重排序，最后连成一个完整的升序链表。</p><h1 id="思路1"><a href="#思路1" class="headerlink" title="思路1"></a>思路1</h1><p>思路1是用小堆来处理。</p><p>因为给出的链表已经是升序的，所以最终的有序链表的头节点，一定是给定的链表中的其中一个的头节点。</p><p>那么第二个节点呢？可能是另外一个链表的头节点，也有可能是当前选中的这个链表的第二个节点。比如下面的例子，第一个节点是2，第二个节点并不是其他链表的头节点，而是这一个链表的第二个节点3。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">10 - 23</span><br><span class="line">5 - 6 </span><br><span class="line">2 - 3 - 7</span><br></pre></td></tr></table></figure><p>所以我们需要用小堆来维护最终的大小关系，首先是遍历给出的链表数组，将所有链表的头节点插入小堆，随后取出堆顶元素，链入最终链表，如果这个节点还有下一个节点，那么就将下一个节点也插入小堆。</p><p>这样才能保证最终的顺序性。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>注意，使用小堆需要用STD提供的<code>priority_queue</code>容器，并自己写一个仿函数来比较两个链表节点的大小。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="comment">// 注意优先级队列的传参是一个仿函数类</span></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">MyCmp</span> &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(ListNode* l, ListNode* r)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> l-&gt;val &gt; r-&gt;val; <span class="comment">// 小堆</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">mergeKLists</span><span class="params">(vector&lt;ListNode*&gt;&amp; lists)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 用最小堆来实现，注意最小堆是大的往上题，cmp中是大于</span></span><br><span class="line">        priority_queue&lt;ListNode*, vector&lt;ListNode*&gt;, MyCmp&gt; que;</span><br><span class="line">        <span class="comment">// 把不为空的链表头节点插入，因为链表本来都是升序的</span></span><br><span class="line">        <span class="comment">// 那么最终的有序链表的第一个节点肯定是某一个链表的头节点</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; i : lists) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">                que.<span class="built_in">push</span>(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 新建一个烧饼节点</span></span><br><span class="line">        ListNode* phead = <span class="keyword">new</span> ListNode;</span><br><span class="line">        ListNode* cur = phead;</span><br><span class="line">        <span class="keyword">while</span> (!que.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="comment">// 取出头节点</span></span><br><span class="line">            ListNode* head = que.<span class="built_in">top</span>();</span><br><span class="line">            que.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="comment">// 如果有下一个节点，插入最小堆</span></span><br><span class="line">            <span class="keyword">if</span> (head-&gt;next != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">                que.<span class="built_in">push</span>(head-&gt;next);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 将其连入链表</span></span><br><span class="line">            cur-&gt;next = head;</span><br><span class="line">            cur = cur-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> phead-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/04/222f9ff8ab3420eed6c464aeb1babcc7.png" alt="image.png"></p><h1 id="思路2"><a href="#思路2" class="headerlink" title="思路2"></a>思路2</h1><p>方法2就是用之前写过的<a href="https://leetcode.cn/problems/merge-two-sorted-lists/description/">21.合并两个有序链表</a>的练习。每次都选中两个链表进行合并，直到最终合并所有链表。</p><p>这里可以采用分治的思路，将链表数组拆分后进行合并。</p><h2 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="function">ListNode* <span class="title">mergeTwoLists</span><span class="params">(ListNode* list1, ListNode* list2)</span> </span>&#123;</span><br><span class="line">        ListNode* head = <span class="keyword">new</span> ListNode;</span><br><span class="line">        ListNode* oldHead = head;</span><br><span class="line">        ListNode *cur1 = list1, *cur2 = list2;</span><br><span class="line">        <span class="keyword">while</span> (cur1 != <span class="literal">nullptr</span> &amp;&amp; cur2 != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (cur1-&gt;val &gt;= cur2-&gt;val) &#123;</span><br><span class="line">                head-&gt;next = cur2;</span><br><span class="line">                head = head-&gt;next;</span><br><span class="line">                cur2 = cur2-&gt;next;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                head-&gt;next = cur1;</span><br><span class="line">                head = head-&gt;next;</span><br><span class="line">                cur1 = cur1-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (cur1 == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            head-&gt;next = cur2;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            head-&gt;next = cur1;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> oldHead-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 合并从 lists[i] 到 lists[j-1] 的链表</span></span><br><span class="line">    <span class="function">ListNode* <span class="title">mergeKLists</span><span class="params">(vector&lt;ListNode*&gt;&amp; lists, <span class="type">int</span> i, <span class="type">int</span> j)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> m = j - i;</span><br><span class="line">        <span class="keyword">if</span> (m == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nullptr</span>; <span class="comment">// 注意输入的 lists 可能是空的</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (m == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> lists[i]; <span class="comment">// 无需合并，直接返回</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">auto</span> left = <span class="built_in">mergeKLists</span>(lists, i, i + m / <span class="number">2</span>);  <span class="comment">// 合并左半部分</span></span><br><span class="line">        <span class="keyword">auto</span> right = <span class="built_in">mergeKLists</span>(lists, i + m / <span class="number">2</span>, j); <span class="comment">// 合并右半部分</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">mergeTwoLists</span>(left, right); <span class="comment">// 最后把左半和右半合并</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">mergeKLists</span><span class="params">(vector&lt;ListNode*&gt;&amp; lists)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">mergeKLists</span>(lists, <span class="number">0</span>, lists.<span class="built_in">size</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">leetcode刷题笔记-23-合并K个升序链表</summary>
    
    
    
    <category term="编程学习" scheme="https://blog.musnow.top/categories/%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="把题目都给刷干净" scheme="https://blog.musnow.top/categories/%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0/%E6%8A%8A%E9%A2%98%E7%9B%AE%E9%83%BD%E7%BB%99%E5%88%B7%E5%B9%B2%E5%87%80/"/>
    
    
    <category term="OJ刷题" scheme="https://blog.musnow.top/tags/OJ%E5%88%B7%E9%A2%98/"/>
    
    <category term="链表" scheme="https://blog.musnow.top/tags/%E9%93%BE%E8%A1%A8/"/>
    
    <category term="堆" scheme="https://blog.musnow.top/tags/%E5%A0%86/"/>
    
    <category term="leetcode" scheme="https://blog.musnow.top/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>【leetcode】2两数相加和989数组数字的相加问题</title>
    <link href="https://blog.musnow.top/posts/1455984707/"/>
    <id>https://blog.musnow.top/posts/1455984707/</id>
    <published>2024-04-14T07:13:00.000Z</published>
    <updated>2024-04-14T07:50:40.000Z</updated>
    
    <content type="html"><![CDATA[<p>leetcode刷题笔记：2和989这类数字一位一位相加的问题</p><h1 id="通用模板"><a href="#通用模板" class="headerlink" title="通用模板"></a>通用模板</h1><p>对于数字一位一位相加的问题，一般就是leetcode第2题链表的形式，和第989题数组的形式。参考leetcode上大佬的题解，会有一个通用的<a href="https://leetcode.cn/problems/add-to-array-form-of-integer/solutions/570659/989-ji-zhu-zhe-ge-jia-fa-mo-ban-miao-sha-8y9r/">加法模板</a>。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">进位carry初始化为0</span><br><span class="line">while ( A 没完 || B 没完 )&#123;</span><br><span class="line">    A 的当前位</span><br><span class="line">    B 的当前位</span><br><span class="line"></span><br><span class="line">    和 = A 的当前位 + B 的当前位 + 进位carry</span><br><span class="line"></span><br><span class="line">    当前位 = 和 % 10;</span><br><span class="line">    进位 = 和 / 10;</span><br><span class="line">&#125;</span><br><span class="line">判断是否还有进位？</span><br></pre></td></tr></table></figure><p>只要依靠这个模板，就能把这两道题很轻松的写出来。</p><h1 id="989-数组形式的整数加法"><a href="#989-数组形式的整数加法" class="headerlink" title="989.数组形式的整数加法"></a>989.数组形式的整数加法</h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><blockquote><p><a href="https://leetcode.cn/problems/add-to-array-form-of-integer/">https://leetcode.cn/problems/add-to-array-form-of-integer/</a></p></blockquote><p>整数的 数组形式  num 是按照从左到右的顺序表示其数字的数组。</p><p>例如，对于 <code>num = 1321</code> ，数组形式是 <code>[1,3,2,1]</code> 。</p><p>给定 num ，整数的 数组形式 ，和整数 k ，返回 整数 num + k 的 数组形式 。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">示例 1：</span><br><span class="line">输入：num = [1,2,0,0], k = 34</span><br><span class="line">输出：[1,2,3,4]</span><br><span class="line">解释：1200 + 34 = 1234</span><br><span class="line"></span><br><span class="line">示例 2：</span><br><span class="line">输入：num = [2,7,4], k = 181</span><br><span class="line">输出：[4,5,5]</span><br><span class="line">解释：274 + 181 = 455</span><br><span class="line"></span><br><span class="line">示例 3：</span><br><span class="line">输入：num = [2,1,5], k = 806</span><br><span class="line">输出：[1,0,2,1]</span><br><span class="line">解释：215 + 806 = 1021</span><br></pre></td></tr></table></figure><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>按上文提供的模板，写这道题是比较容易的，因为数组本身是可以随机访问的，我们从后往前遍历数组，按位与k的当前位相加就可以了。</p><p>注意，使用vector做返回值时，我们应该采用先尾插最后逆置的方式，效率会远高于每次都头插。因为vector的头插涉及到了其他元素的移动。</p><p>当然，你也可以选择链表来进行头插，最终再转成vector返回。</p><p>这里面要注意的是，虽然while的判断条件中已经有了判断，但是两个判断条件是通过<code>||</code>或连接的，可能会出现数组已经结束了，但是k还有位数（或反之）的情况，在操作a和b的时候一定要先进行判断再赋值。</p><p>当然，也可以选择用<code>&amp;&amp;</code>与链接，并在while之后单独处理数组或k剩下的数。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">addToArrayForm</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; num, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; retV;</span><br><span class="line">        <span class="type">int</span> i = num.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> carry = <span class="number">0</span>; <span class="comment">// 进位</span></span><br><span class="line">        <span class="comment">// 有一个不为0就需要继续加</span></span><br><span class="line">        <span class="keyword">while</span> (i &gt;= <span class="number">0</span> || k != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 可能有一个已经结束了，需要判断</span></span><br><span class="line">            <span class="type">int</span> a = i &gt;= <span class="number">0</span> ? num[i] : <span class="number">0</span>;</span><br><span class="line">            <span class="type">int</span> b = k != <span class="number">0</span> ? k % <span class="number">10</span> : <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">            <span class="type">int</span> sum = a + b + carry;</span><br><span class="line">            <span class="type">int</span> cur = sum % <span class="number">10</span>;          <span class="comment">// 当前位</span></span><br><span class="line">            carry = (sum &gt;= <span class="number">10</span>) ? <span class="number">1</span> : <span class="number">0</span>; <span class="comment">// 如果超过10了需要进位</span></span><br><span class="line">            <span class="comment">// 插入数组</span></span><br><span class="line">            retV.<span class="built_in">push_back</span>(cur);</span><br><span class="line">            <span class="comment">// 走下一位去</span></span><br><span class="line">            i--;</span><br><span class="line">            k /= <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 还有进位，需要再插入一个</span></span><br><span class="line">        <span class="keyword">if</span> (carry != <span class="number">0</span>) &#123;</span><br><span class="line">            retV.<span class="built_in">push_back</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 注意，我们插入是尾插（vector头插效率很低），需要逆置</span></span><br><span class="line">        <span class="built_in">reverse</span>(retV.<span class="built_in">begin</span>(), retV.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">return</span> retV;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/04/3dd4d93b32c706b3a81670877ff35a1f.png" alt="image.png"></p><h1 id="2-两数相加"><a href="#2-两数相加" class="headerlink" title="2.两数相加"></a>2.两数相加</h1><blockquote><p><a href="https://leetcode.cn/problems/add-two-numbers/description/">https://leetcode.cn/problems/add-two-numbers/description/</a></p></blockquote><h2 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h2><p>给你两个 非空 的链表，表示两个非负的整数。它们每位数字都是按照 <strong>逆序</strong> 的方式存储的，并且每个节点只能存储 一位 数字。</p><p>请你将两个数相加，并以相同形式返回一个表示和的链表。</p><p>你可以假设除了数字 0 之外，这两个数都不会以 0 开头。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">示例 1：</span><br><span class="line">输入：l1 = [2,4,3], l2 = [5,6,4]</span><br><span class="line">输出：[7,0,8]</span><br><span class="line">解释：342 + 465 = 807.</span><br><span class="line"></span><br><span class="line">示例 2：</span><br><span class="line">输入：l1 = [0], l2 = [0]</span><br><span class="line">输出：[0]</span><br><span class="line"></span><br><span class="line">示例 3：</span><br><span class="line">输入：l1 = [9,9,9,9,9,9,9], l2 = [9,9,9,9]</span><br><span class="line">输出：[8,9,9,9,0,0,0,1]</span><br></pre></td></tr></table></figure><h2 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h2><p>这道题虽然给的是链表，无法随机访问，但是链表是逆序存放的数字，本就符合我们从低位往高位相加的思路。</p><p>基本代码和上文一致，当某个链表结束之后，就将其视作0继续操作。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">addTwoNumbers</span><span class="params">(ListNode* l1, ListNode* l2)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 有一个为空的时候可以直接返回另外一个</span></span><br><span class="line">        <span class="keyword">if</span>(l1 == <span class="literal">nullptr</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> l2;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(l2 == <span class="literal">nullptr</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> l1;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ListNode* phead = <span class="keyword">new</span> ListNode;</span><br><span class="line">        ListNode* cur = phead;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> carry = <span class="number">0</span>; <span class="comment">// 进位制</span></span><br><span class="line">        ListNode* left = l1,*right = l2;</span><br><span class="line">        <span class="comment">// 有一个不为空就需要继续</span></span><br><span class="line">        <span class="keyword">while</span>(left != <span class="literal">nullptr</span> || right !=<span class="literal">nullptr</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> a = left != <span class="literal">nullptr</span>?left-&gt;val:<span class="number">0</span>;</span><br><span class="line">            <span class="type">int</span> b = right != <span class="literal">nullptr</span>?right-&gt;val:<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">            <span class="type">int</span> sum = a+b+carry;</span><br><span class="line">            <span class="type">int</span> val = sum % <span class="number">10</span>; <span class="comment">// 当前值</span></span><br><span class="line">            carry = sum&gt;=<span class="number">10</span>?<span class="number">1</span>:<span class="number">0</span>;</span><br><span class="line">            <span class="comment">// 注意，题目要求的是按相同的方式（数字逆序存放）来返回一个链表</span></span><br><span class="line">            <span class="comment">// 所以我们需要进行尾插操作</span></span><br><span class="line">            cur-&gt;next = <span class="keyword">new</span> <span class="built_in">ListNode</span>(val);</span><br><span class="line">            cur = cur-&gt;next;</span><br><span class="line">            <span class="comment">// 去下一位</span></span><br><span class="line">            <span class="keyword">if</span>(left != <span class="literal">nullptr</span>)&#123;    </span><br><span class="line">                left=left-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(right != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">                right=right-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 还有值，需要再尾插一个。</span></span><br><span class="line">        <span class="keyword">if</span>(carry!=<span class="number">0</span>)&#123;</span><br><span class="line">            cur-&gt;next = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> phead-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>备注：上面的代码中，phead指针出现内存泄漏了，但是写OJ的时候并不关心内存泄漏问题。</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/04/f3c0df34a05e87a15ff126f081a3e91d.png" alt="image.png"></p><h1 id="165-比较版本号"><a href="#165-比较版本号" class="headerlink" title="165.比较版本号"></a>165.比较版本号</h1><h2 id="题目-2"><a href="#题目-2" class="headerlink" title="题目"></a>题目</h2><blockquote><p><a href="https://leetcode.cn/problems/compare-version-numbers/description/">https://leetcode.cn/problems/compare-version-numbers/description/</a></p></blockquote><p>给你两个版本号 version1 和 version2 ，请你比较它们。</p><p>版本号由一个或多个修订号组成，各修订号由一个 <code>&#39;.&#39;</code> 连接。每个修订号由 多位数字 组成，可能包含 前导零 。每个版本号至少包含一个字符。修订号从左到右编号，下标从 0 开始，最左边的修订号下标为 0 ，下一个修订号下标为 1 ，以此类推。例如，<code>2.5.33</code> 和 <code>0.1</code> 都是有效的版本号。</p><p>比较版本号时，请按从左到右的顺序依次比较它们的修订号。比较修订号时，只需比较 忽略任何前导零后的整数值 。也就是说，修订号 1 和修订号 001 相等 。如果版本号没有指定某个下标处的修订号，则该修订号视为 0 。例如，版本 1.0 小于版本 1.1 ，因为它们下标为 0 的修订号相同，而下标为 1 的修订号分别为 0 和 1 ，0 &lt; 1 。</p><p>返回规则如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">如果 version1 &gt; version2 返回 1，</span><br><span class="line">如果 version1 &lt; version2 返回 -1，</span><br><span class="line">除此之外返回 0。</span><br></pre></td></tr></table></figure><p>示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">示例 1：</span><br><span class="line">输入：version1 = &quot;1.01&quot;, version2 = &quot;1.001&quot;</span><br><span class="line">输出：0</span><br><span class="line">解释：忽略前导零，&quot;01&quot; 和 &quot;001&quot; 都表示相同的整数 &quot;1&quot;</span><br><span class="line"></span><br><span class="line">示例 2：</span><br><span class="line">输入：version1 = &quot;1.0&quot;, version2 = &quot;1.0.0&quot;</span><br><span class="line">输出：0</span><br><span class="line">解释：version1 没有指定下标为 2 的修订号，即视为 &quot;0&quot;</span><br><span class="line"></span><br><span class="line">示例 3：</span><br><span class="line">输入：version1 = &quot;0.1&quot;, version2 = &quot;1.1&quot;</span><br><span class="line">输出：-1</span><br><span class="line">解释：version1 中下标为 0 的修订号是 &quot;0&quot;，version2 中下标为 0 的修订号是 &quot;1&quot; 。0 &lt; 1，所以 version1 &lt; version2</span><br></pre></td></tr></table></figure><p>提示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1 &lt;= version1.length, version2.length &lt;= 500</span><br><span class="line">version1 和 version2 仅包含数字和 &#x27;.&#x27;</span><br><span class="line">version1 和 version2 都是 有效版本号</span><br><span class="line">version1 和 version2 的所有修订号都可以存储在 32 位整数 中</span><br></pre></td></tr></table></figure><h2 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h2><p>上文提到的累计相加的思路同样可以扩大到字符串比较的题目中。只要有一个没有结束就继续比较，直到两个字符串都结束或找到结果。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">compareVersion</span><span class="params">(string version1, string version2)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> left = <span class="number">0</span>, right = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (left &lt; version1.<span class="built_in">size</span>() || right &lt; version2.<span class="built_in">size</span>()) &#123;</span><br><span class="line">            <span class="comment">// version1求和</span></span><br><span class="line">            <span class="type">int</span> leftSum = <span class="number">0</span>;</span><br><span class="line">            <span class="comment">// 这里并不需要对前导0做任何判断，因为初始值就是0，前导0操作后还是0</span></span><br><span class="line">            <span class="keyword">for</span> (; left &lt; version1.<span class="built_in">size</span>() &amp;&amp; version1[left] != <span class="string">&#x27;.&#x27;</span>; left++) &#123;</span><br><span class="line">                leftSum = leftSum * <span class="number">10</span> + (version1[left] - <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            left++; <span class="comment">// 跳过点</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// version2求和</span></span><br><span class="line">            <span class="type">int</span> rightSum = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (; right &lt; version2.<span class="built_in">size</span>() &amp;&amp; version2[right] != <span class="string">&#x27;.&#x27;</span>; right++) &#123;</span><br><span class="line">                rightSum = rightSum * <span class="number">10</span> + (version2[right] - <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            right++; <span class="comment">// 跳过点</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 不相同就说明有一个大了，判断一下</span></span><br><span class="line">            <span class="keyword">if</span> (leftSum != rightSum) &#123;</span><br><span class="line">                <span class="keyword">return</span> leftSum &gt; rightSum ? <span class="number">1</span> : <span class="number">-1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/04/004f1d885560d3d71f86d7c8a79314a3.png" alt="image.png"></p><p>这道题的另外一个思路就是通过<code>&#39;.&#39;</code>字符将两个字符串切割出来，再依次比较版本号。但是那样会有更大的时间复杂度消耗，逻辑也不是很清晰，不如直接在循环内处理。</p>]]></content>
    
    
    <summary type="html">leetcode刷题笔记：2和989这类数字一位一位相加的问题</summary>
    
    
    
    <category term="编程学习" scheme="https://blog.musnow.top/categories/%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="把题目都给刷干净" scheme="https://blog.musnow.top/categories/%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0/%E6%8A%8A%E9%A2%98%E7%9B%AE%E9%83%BD%E7%BB%99%E5%88%B7%E5%B9%B2%E5%87%80/"/>
    
    
    <category term="OJ刷题" scheme="https://blog.musnow.top/tags/OJ%E5%88%B7%E9%A2%98/"/>
    
    <category term="leetcode" scheme="https://blog.musnow.top/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>【网络】QUIC协议和HTTP3</title>
    <link href="https://blog.musnow.top/posts/2259793534/"/>
    <id>https://blog.musnow.top/posts/2259793534/</id>
    <published>2024-04-11T03:17:57.000Z</published>
    <updated>2024-05-13T08:36:53.000Z</updated>
    
    <content type="html"><![CDATA[<p>面试常考，临时抱佛脚学一下。参考 <a href="https://zhuanlan.zhihu.com/p/266578819">https://zhuanlan.zhihu.com/p/266578819</a></p><h1 id="HTTP1-0和HTTP1-1"><a href="#HTTP1-0和HTTP1-1" class="headerlink" title="HTTP1.0和HTTP1.1"></a>HTTP1.0和HTTP1.1</h1><p>HTTP1.0中，每一个请求必须等上一个请求收到响应了才能继续。且每一次请求都会重新建立TCP链接。</p><p>HTTP1.1中可以复用TCP链接，但是依旧没有解决队头阻塞的问题，虽然复用了TCP链接，但是请求B依旧需要等待请求A的响应，才能继续发送。</p><p>换句话说，服务器发送响应必须严格按照客户端发送请求的顺序。客户端按ABC发送，服务端也需要按ABC返回响应。</p><h1 id="HTTP2的升级"><a href="#HTTP2的升级" class="headerlink" title="HTTP2的升级"></a>HTTP2的升级</h1><p>总结就是：</p><ol><li>steam并发传输</li><li>哈夫曼编码HPACK压缩header为二进制后传输</li><li>服务器可以主动推送资源给客户端。</li></ol><p><strong>并发传输</strong>就是在HTTP中添加一个steamID，通过ID来标识不同的HTTP请求报文，这样就能在同一个TCP传输流中并发传输多个HTTP报文。而在HTTP1.1中，虽然可以复用同一个TCP链接，但是HTTP1.1中在某个请求没有收到响应之前，是无法传输其他请求的。</p><p><strong>压缩header</strong>：通过哈夫曼编码在双方建立一个动态表，其中包括61项常用header的静态表，同时可以对静态表进行动态扩展（需要使用但不在61项中的header），最终发送header的时候，会用序号来替代header的字符串，同时对header的value进行压缩，从而减少HTTP包的长度。</p><p><strong>服务器主动推送</strong>：请求一个资源后，服务器可以主动将其他客户端用的上的资源推送给客户端，而不需要等客户端主动请求。比如请求<code>index.html</code>后，将需要的js&#x2F;css也推送给客户端。</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/04/bdf5cbb21a7a3f384e42edc7e5d74c08.png" alt="image.png"></p><h1 id="QUIC可靠性保证"><a href="#QUIC可靠性保证" class="headerlink" title="QUIC可靠性保证"></a>QUIC可靠性保证</h1><p>其实这个问题就是UDP如何保证可靠性（加什么东西？），把TCP可靠性机制往里面加就行了。</p><ol><li>重传机制</li><li>确认机制</li><li>握手机制（快速握手）</li><li>拥塞控制（应用层处理的）</li><li>多路复用（多个stream并发）</li><li>前向纠错（校验码）</li></ol><h1 id="QUIC的特点"><a href="#QUIC的特点" class="headerlink" title="QUIC的特点"></a>QUIC的特点</h1><blockquote><p><a href="https://www.xiaolincoding.com/network/2_http/http3.html#%E6%9B%B4%E5%BF%AB%E7%9A%84%E8%BF%9E%E6%8E%A5%E5%BB%BA%E7%AB%8B">https://www.xiaolincoding.com/network/2_http/http3.html#%E6%9B%B4%E5%BF%AB%E7%9A%84%E8%BF%9E%E6%8E%A5%E5%BB%BA%E7%AB%8B</a></p></blockquote><h2 id="无队头阻塞"><a href="#无队头阻塞" class="headerlink" title="无队头阻塞"></a>无队头阻塞</h2><p>无队头阻塞：HTTP2中用tcp实现多stream并发传输，但是tcp本身需要保证数据到达应用层的有序性。假设有这样的报文到达顺序</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">stream1 tcp1</span><br><span class="line">stream2 tcp2</span><br><span class="line">stream1 tcp3 # 丢包</span><br><span class="line">stream2 tcp4</span><br><span class="line">stream3 tcp5</span><br></pre></td></tr></table></figure><p>此时tcp3出现了丢包，虽然我们客户端已经收到了服务器发送的stream2(tcp4)和stream3(tcp5)，但因为tcp协议栈<strong>需要维护序号有序性</strong>，没有收到tcp3之前，它不会把后序的数据交付给上层，这就导致了stream2&#x2F;3因为stream1的丢包而出现了阻塞，也就是<code>队头阻塞</code>的含义。</p><p>而QUIC基于UDP，因为UDP本身是无连接的，所以它不会出现队头阻塞的问题。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">stream1 udp3 # 丢包</span><br><span class="line">stream2 udp4</span><br><span class="line">stream3 udp5</span><br></pre></td></tr></table></figure><p>即便udp3丢包了，也不会影响udp4&#x2F;5，此时steam2&#x2F;3也能被正常交付给上层供HTTP使用。</p><p>反映到浏览器加载中，有可能这里的udp4&#x2F;5就是steam2&#x2F;3的最后一个分片，交付给上层后就已组成了一个完整的HTTP报文，表现在浏览器上就是某一个模块加载出来了，会让用户的体验更好。</p><h2 id="更快的链接建立"><a href="#更快的链接建立" class="headerlink" title="更快的链接建立"></a>更快的链接建立</h2><p>在通过TCP实现HTTPS的时候，需要涉及到TCP三次握手和TLS&#x2F;SSL握手。其中TCP三次握手和SSL握手都要进行3次数据传输，一共就是6次单向传输了（3RTT）。</p><p>而UDP实现的QUIC也需要握手，这个过程是1RTT。但是QUIC本身就是一个应用层实现的协议，它可以直接在第一次链接的时候就携带TLS&#x2F;SSL的相关信息，第二次链接的时候发送QUIC握手报文+TLS握手报文和数据载荷，同时完成TLS握手的功能，近似实现0RTT的握手。</p><blockquote><p>这里涉及到了TLS1.3，先暂且不去深入了解，知道大概就行。</p></blockquote><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/04/f97be469c526cb19338a066b1120c368.png" alt="image.png"></p><h2 id="链接迁移"><a href="#链接迁移" class="headerlink" title="链接迁移"></a>链接迁移</h2><p>在基于TCP的HTTP中，需要通过IP和TCP端口的四元组来定位客户端和服务端。</p><p>假设我们从WIFI切换成4G&#x2F;5G，此时客户端的ip和端口肯定会发生变化，而在旧版本中，这就需要使用TCP重新和服务器进行三次握手和TLS链接建立，才能重新开始数据传输。</p><p>而QUIC中，除了IP&#x2F;UDP的四元组外，还有个独特的QUIC会话ID来标识两边的传输。</p><p>假设一个客户端从WIFI切换成5G，发生了IP和端口的变化，但它发送的QUIC请求报文中，依旧包含了之前的<strong>QUIC会话ID</strong>，此时服务器可以通过这个会话ID定位之前的传输，并继续传输之前中断的时候的数据。</p><p>再加上前文提到的QUIC握手次数少，这两个相结合，客户端切换IP和端口的时间消耗就更少了！</p><h1 id="HTTP3的QPACK"><a href="#HTTP3的QPACK" class="headerlink" title="HTTP3的QPACK"></a>HTTP3的QPACK</h1><p>在HTTP2中，会用HPACK来将更新后的动态header表发送给对方，但是它的HPACK并没有确认机制。也就是说，如果你发送的一个新的HPACK更新丢包了，对方没有收到，也就不认识某个新的header序号，此时客户端发送的信息就没有办法被正常解码了，此时会出现阻塞。</p><p>而QPACK就是在HPACK的基础上加入了确认机制。有两个链接来进行</p><ul><li>一个叫 QPACK Encoder Stream，用于将一个字典（Key-Value）传递给对方，比如面对不属于静态表的 HTTP 请求头部，客户端可以通过这个 Stream 发送字典；</li><li>一个叫 QPACK Decoder Stream，用于响应对方，告诉它刚发的字典已经更新到自己的本地动态表了，后续就可以使用这个字典来编码了。</li></ul><p>这两个特殊的单向流是用来同步双方的动态表，编码方收到解码方更新确认的通知后，才使用动态表编码 HTTP 头部。</p><p>当A给B发送的动态表没有被收到时，A还不会对这个新的header进行压缩（以原始形式进行发送）。直到收到B对这个动态表的响应了，才会压缩传输。</p><p>这样就避免了HPACK中A会压缩发送一个<strong>B还不知道</strong>的动态表中的header的情况。</p>]]></content>
    
    
    <summary type="html">QUIC协议和HTTP3简介</summary>
    
    
    
    <category term="编程学习" scheme="https://blog.musnow.top/categories/%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="计算机网络" scheme="https://blog.musnow.top/categories/%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
    <category term="计算机网络" scheme="https://blog.musnow.top/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    <category term="面经" scheme="https://blog.musnow.top/tags/%E9%9D%A2%E7%BB%8F/"/>
    
  </entry>
  
  <entry>
    <title>【算法】贪心算法</title>
    <link href="https://blog.musnow.top/posts/3488338229/"/>
    <id>https://blog.musnow.top/posts/3488338229/</id>
    <published>2024-04-07T02:33:18.000Z</published>
    <updated>2024-05-21T02:35:51.000Z</updated>
    
    <content type="html"><![CDATA[<p>贪心算法学习</p><h1 id="基本理论"><a href="#基本理论" class="headerlink" title="基本理论"></a>基本理论</h1><p>贪心算法的基本理论是“从局部最优推出全局最优”。</p><p>每一次小操作都是在选择局部最优，最终得到的结果就是一个全局最优。</p><p>当一个题目能满足这个思路的时候，就可以尝试使用贪心了。</p><h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><h2 id="455-分发饼干"><a href="#455-分发饼干" class="headerlink" title="455 分发饼干"></a>455 分发饼干</h2><blockquote><p><a href="https://leetcode.cn/problems/assign-cookies/">https://leetcode.cn/problems/assign-cookies/</a></p></blockquote><h3 id="题目和思路"><a href="#题目和思路" class="headerlink" title="题目和思路"></a>题目和思路</h3><p>假设你是一位很棒的家长，想要给你的孩子们一些小饼干。但是，每个孩子最多只能给一块饼干。</p><p>对每个孩子 i，都有一个胃口值 <code>g[i]</code>，这是能让孩子们满足胃口的饼干的最小尺寸；并且每块饼干 j，都有一个尺寸 <code>s[j]</code> 。如果 <code>s[j] &gt;= g[i]</code>，我们可以将这个饼干 j 分配给孩子 i ，这个孩子会得到满足。你的目标是尽可能满足越多数量的孩子，并输出这个最大数值。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">示例 1:</span><br><span class="line">输入: g = [1,2,3], s = [1,1]</span><br><span class="line">输出: 1</span><br><span class="line">解释: </span><br><span class="line">你有三个孩子和两块小饼干，3个孩子的胃口值分别是：1,2,3。</span><br><span class="line">虽然你有两块小饼干，由于他们的尺寸都是1，你只能让胃口值是1的孩子满足。</span><br><span class="line">所以你应该输出1。</span><br><span class="line"></span><br><span class="line">示例 2:</span><br><span class="line">输入: g = [1,2], s = [1,2,3]</span><br><span class="line">输出: 2</span><br><span class="line">解释: </span><br><span class="line">你有两个孩子和三块小饼干，2个孩子的胃口值分别是1,2。</span><br><span class="line">你拥有的饼干数量和尺寸都足以让所有孩子满足。</span><br><span class="line">所以你应该输出2.</span><br></pre></td></tr></table></figure><p>这道题的思路其实很简单，即我们每次都应该选择大饼干满足大胃口的人，这样才能让最终可以吃到饼干的小孩最多。</p><p>直接排序两个数组，从右往左遍历，判断当前饼干是否能满足当前胃口的人，如果可以，则消耗一个饼干，并让计数器加一。不可以，则继续往左遍历胃口。</p><p>在这个例子中，局部最优是用大饼干满足大胃口的，全局最优是最终能吃上饼干的孩子最多。</p><h3 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h3><p>代码中需要注意对index的越界检查，特别是数组s为空的情况。当index已经越界的时候，就可以跳出循环了。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">findContentChildren</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; g, vector&lt;<span class="type">int</span>&gt;&amp; s)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">sort</span>(g.<span class="built_in">begin</span>(), g.<span class="built_in">end</span>());</span><br><span class="line">        <span class="built_in">sort</span>(s.<span class="built_in">begin</span>(), s.<span class="built_in">end</span>());</span><br><span class="line">        <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> index = s.<span class="built_in">size</span>() - <span class="number">1</span>; <span class="comment">// 饼干最后一个</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = g.<span class="built_in">size</span>() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="keyword">if</span> (index &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (s[index] &gt;= g[i]) &#123;</span><br><span class="line">                index--;</span><br><span class="line">                count++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="376-摆动序列"><a href="#376-摆动序列" class="headerlink" title="376 摆动序列"></a>376 摆动序列</h2><blockquote><p><a href="https://leetcode.cn/problems/wiggle-subsequence/description/">https://leetcode.cn/problems/wiggle-subsequence/description/</a></p></blockquote><h3 id="题目和思路-1"><a href="#题目和思路-1" class="headerlink" title="题目和思路"></a>题目和思路</h3><p>如果连续数字之间的差严格地在正数和负数之间交替，则数字序列称为 摆动序列 。第一个差（如果存在的话）可能是正数或负数。仅有一个元素或者含两个不等元素的序列也视作摆动序列。</p><p>例如， [1, 7, 4, 9, 2, 5] 是一个 摆动序列 ，因为差值 (6, -3, 5, -7, 3) 是正负交替出现的。</p><p>相反，[1, 4, 7, 2, 5] 和 [1, 7, 4, 5, 5] 不是摆动序列，第一个序列是因为它的前两个差值都是正数，第二个序列是因为它的最后一个差值为零。</p><p><strong>子序列</strong> 可以通过从原始序列中删除一些（也可以不删除）元素来获得，剩下的元素保持其原始顺序。</p><p>给你一个整数数组 nums ，返回 nums 中作为 摆动序列 的 最长子序列的长度 。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">示例 1：</span><br><span class="line">输入：nums = [1,7,4,9,2,5]</span><br><span class="line">输出：6</span><br><span class="line">解释：整个序列均为摆动序列，各元素之间的差值为 (6, -3, 5, -7, 3) 。</span><br><span class="line"></span><br><span class="line">示例 2：</span><br><span class="line">输入：nums = [1,17,5,10,13,15,10,5,16,8]</span><br><span class="line">输出：7</span><br><span class="line">解释：这个序列包含几个长度为 7 摆动序列。</span><br><span class="line">其中一个是 [1, 17, 10, 13, 10, 16, 8] ，各元素之间的差值为 (16, -7, 3, -3, 6, -8) 。</span><br><span class="line"></span><br><span class="line">示例 3：</span><br><span class="line">输入：nums = [1,2,3,4,5,6,7,8,9]</span><br><span class="line">输出：2</span><br></pre></td></tr></table></figure><p>首先需要拆分情况，除了正常的一上一下的折线图，还可能会出现下面的情况，这些情况都必须特别来处理。</p><ul><li>连续的上坡或连续的下坡</li><li>上坡下坡之间有平地</li><li>上坡和上坡之间有平地（下坡和下坡之间有平地）</li></ul><p>先来看第一个，<strong>连续的上坡或者连续的下坡的情况</strong>：这需要我们将连续的上坡只看作一个上坡，比如上坡有3个节点（包括坡底和坡顶），那么最终可以计算的只有一个（坡顶，坡底已经计算过了）。</p><p><strong>上坡下坡之间有平地的情况</strong>：将平地其他节点删除，只计算一个节点。</p><p><strong>上坡和上坡之间有平地</strong>：将平地删除成一个节点，此时就变成了情况1的连续上坡&#x2F;下坡。</p><blockquote><p>具体示意图的可以参考代码随想录：<a href="https://www.programmercarl.com/0376.%E6%91%86%E5%8A%A8%E5%BA%8F%E5%88%97.html#%E6%80%9D%E8%B7%AF">https://www.programmercarl.com/0376.%E6%91%86%E5%8A%A8%E5%BA%8F%E5%88%97.html#%E6%80%9D%E8%B7%AF</a></p></blockquote><h3 id="错误代码"><a href="#错误代码" class="headerlink" title="错误代码"></a>错误代码</h3><p>最开始的时候，我写出了这样一版代码，它的问题在于，只能处理子数组的情况（子数组是连续的），而不能处理子序列（中间可以不连续）。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">wiggleMaxLength</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 判断上一个diff是正数还是负数，正数设置为1，负数设置为-1</span></span><br><span class="line">        <span class="type">int</span> lastDiff = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> maxLength = <span class="number">-1</span>;</span><br><span class="line">        <span class="type">int</span> curLength = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; nums.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="type">int</span> diff = nums[i] - nums[i - <span class="number">1</span>];</span><br><span class="line">            cout &lt;&lt; nums[i] &lt;&lt; <span class="string">&quot; - &quot;</span> &lt;&lt; nums[i - <span class="number">1</span>] &lt;&lt; <span class="string">&quot; = &quot;</span> &lt;&lt; diff &lt;&lt; <span class="string">&quot; : &quot;</span></span><br><span class="line">                 &lt;&lt; curLength &lt;&lt; <span class="string">&quot;  f:&quot;</span> &lt;&lt; lastDiff &lt;&lt; endl;</span><br><span class="line">            <span class="keyword">if</span> (diff &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// 不符合条件，从当前位开始新算一个子数组</span></span><br><span class="line">                <span class="keyword">if</span> (lastDiff == <span class="number">1</span>) &#123;</span><br><span class="line">                    curLength = <span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 符合条件</span></span><br><span class="line">                curLength++;</span><br><span class="line">                maxLength = <span class="built_in">max</span>(curLength, maxLength);</span><br><span class="line">                <span class="comment">// 设置LastDiff</span></span><br><span class="line">                lastDiff = <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 不符合</span></span><br><span class="line">                <span class="keyword">if</span> (lastDiff == <span class="number">-1</span>) &#123;</span><br><span class="line">                    curLength = <span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 符合条件</span></span><br><span class="line">                curLength++;</span><br><span class="line">                maxLength = <span class="built_in">max</span>(curLength, maxLength);</span><br><span class="line">                <span class="comment">// 设置LastDiff</span></span><br><span class="line">                lastDiff = <span class="number">-1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxLength == <span class="number">-1</span> ? <span class="number">0</span> : maxLength;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="正确代码"><a href="#正确代码" class="headerlink" title="正确代码"></a>正确代码</h3><p>这里面，用curDiff记录当前的差值，preDiff记录上一个有变动的差值，result是返回值。</p><p>result初始化为1是因为判断是在<code>nums.size() - 2</code>就结束的（最后一个节点并没有被循环计入其中），而且当数组长度为2的时候，判断只会有一次，如果不置1就会漏掉一个值。</p><p>以下图为例，这是一个<strong>上坡和下坡之中有平坡</strong>的情况，如下的代码在循环中判断的是i和i+1，最终会在<code>nums.size() - 2</code>位置（图中已标注）跳出循环。此时<code>result++</code>是只加入了<code>nums.size() - 2</code>的这个点，而没有加入<code>nums.size() - 1</code>这个同样需要被加入的点，所以需要将result初始化为1来覆盖这种漏掉的情况。</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/04/feb535b0482c5164d16cec60ab748168.png" alt="image.png"></p><p>下面是详细的判断逻辑：</p><ul><li><code>preDiff &lt; 0 &amp;&amp; curDiff &gt; 0</code> 和 <code>preDiff &gt;0 &amp;&amp; curDiff &lt; 0</code> 是最基本的上坡和下坡情况，当前差值和之前的并非同正同负；</li><li><code>preDiff == 0 &amp;&amp; curDiff &gt; 0</code> 和 <code>preDiff == 0 &amp;&amp; curDiff &lt; 0</code> 的情况满足上文所述“上坡下坡之间有平地的情况，此时也需要记录摆动的变化。</li><li>只在摆动变化的时候记录preDiff就可以忽略“上坡和上坡之间有平地”的情况（如果不这么做，就会多记录一次节点）</li></ul><p>最终可以写出下面的代码。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">wiggleMaxLength</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (nums.<span class="built_in">size</span>() &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> nums.<span class="built_in">size</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> curDiff = <span class="number">0</span>; <span class="comment">// 当前一对差值</span></span><br><span class="line">        <span class="type">int</span> preDiff = <span class="number">0</span>; <span class="comment">// 前一对差值</span></span><br><span class="line">        <span class="type">int</span> result = <span class="number">1</span>; <span class="comment">// 记录峰值个数，序列默认序列最右边有一个峰值</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>() - <span class="number">1</span>; i++) &#123;</span><br><span class="line">            curDiff = nums[i + <span class="number">1</span>] - nums[i];</span><br><span class="line">            <span class="comment">// 出现峰值</span></span><br><span class="line">            <span class="keyword">if</span> ((preDiff &lt;= <span class="number">0</span> &amp;&amp; curDiff &gt; <span class="number">0</span>) ||</span><br><span class="line">                (preDiff &gt;= <span class="number">0</span> &amp;&amp; curDiff &lt; <span class="number">0</span>)) &#123;</span><br><span class="line">                result++;</span><br><span class="line">                preDiff = curDiff; <span class="comment">// 注意这里，只在摆动变化的时候更新prediff</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/04/49ffcd1cffbf381e29d94594decc9938.png" alt="image.png"></p><h2 id="122-买卖股票的最佳时机2"><a href="#122-买卖股票的最佳时机2" class="headerlink" title="122 买卖股票的最佳时机2"></a>122 买卖股票的最佳时机2</h2><h3 id="题目和思路-2"><a href="#题目和思路-2" class="headerlink" title="题目和思路"></a>题目和思路</h3><blockquote><p><a href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-ii/description/">https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-ii/description/</a></p></blockquote><p>给你一个整数数组 prices ，其中 <code>prices[i]</code> 表示某支股票第 i 天的价格。</p><p>在每一天，你可以决定是否购买和&#x2F;或出售股票。你在任何时候 最多 只能持有 一股 股票。你也可以先购买，然后在 同一天 出售。</p><p>返回 你能获得的 最大 利润 。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">示例 1：</span><br><span class="line">输入：prices = [7,1,5,3,6,4]</span><br><span class="line">输出：7</span><br><span class="line">解释：在第 2 天（股票价格 = 1）的时候买入，在第 3 天（股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5 - 1 = 4 。</span><br><span class="line">     随后，在第 4 天（股票价格 = 3）的时候买入，在第 5 天（股票价格 = 6）的时候卖出, 这笔交易所能获得利润 = 6 - 3 = 3 。</span><br><span class="line">     总利润为 4 + 3 = 7 。</span><br><span class="line">     </span><br><span class="line">示例 2：</span><br><span class="line">输入：prices = [1,2,3,4,5]</span><br><span class="line">输出：4</span><br><span class="line">解释：在第 1 天（股票价格 = 1）的时候买入，在第 5 天 （股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5 - 1 = 4 。</span><br><span class="line">     总利润为 4 。</span><br><span class="line">     </span><br><span class="line">示例 3：</span><br><span class="line">输入：prices = [7,6,4,3,1]</span><br><span class="line">输出：0</span><br><span class="line">解释：在这种情况下, 交易无法获得正利润，所以不参与交易可以获得最大利润，最大利润为 0 。</span><br></pre></td></tr></table></figure><p>首先需要想明白，这道题的利润是可以被分解的。第0天买，第3天卖的利润是 <code>prices[3]-prices[0]</code>，等价于 <code>(p[3]-p[2]) + (p[2]-p[1]) + (p[1]-p[0])</code>。想明白这一点后，这道题的解法就很明确了。</p><p>与其是动态计算咋样才能获得最高利润，还不如分解成一小块一小块的，<strong>只要昨天买入，今天卖出可以赚钱，那么就加入到最终的利润里面</strong>。因为你0天买3天卖，和每天都卖出昨日买入今日得到的钱是完全一致的。那么我们排除掉昨天买入今天卖出会亏钱的情况，就能计算出最终可以达到的最大利润。</p><h3 id="题目代码"><a href="#题目代码" class="headerlink" title="题目代码"></a>题目代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxProfit</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 第0天买，第3天卖的利润是prices[3]-prices[0]</span></span><br><span class="line">        <span class="comment">// 也等于 p[3]-p[2] + p[2]-p[1] + p[1]-p[0]</span></span><br><span class="line">        <span class="comment">// 所以最大利润其实就是每天利润之和（前提是利润都是正的）</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; prices.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="comment">// 计算昨天买今天卖能获得多少利润</span></span><br><span class="line">            <span class="comment">// 如果大于0就加入进去</span></span><br><span class="line">            count += <span class="built_in">max</span>(prices[i] - prices[i - <span class="number">1</span>], <span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/04/1d61dc355c9977d36978521b023b6129.png" alt="image.png"></p><h2 id="55-跳跃游戏"><a href="#55-跳跃游戏" class="headerlink" title="55 跳跃游戏"></a>55 跳跃游戏</h2><blockquote><p><a href="https://leetcode.cn/problems/jump-game/description/">https://leetcode.cn/problems/jump-game/description/</a></p></blockquote><h3 id="题目和思路-3"><a href="#题目和思路-3" class="headerlink" title="题目和思路"></a>题目和思路</h3><p>给你一个非负整数数组 nums ，你最初位于数组的 第一个下标 。数组中的每个元素代表你在该位置可以跳跃的最大长度。</p><p>判断你是否能够到达最后一个下标，如果可以，返回 true ；否则，返回 false 。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">示例 1：</span><br><span class="line">输入：nums = [2,3,1,1,4]</span><br><span class="line">输出：true</span><br><span class="line">解释：可以先跳 1 步，从下标 0 到达下标 1, 然后再从下标 1 跳 3 步到达最后一个下标。</span><br><span class="line"></span><br><span class="line">示例 2：</span><br><span class="line">输入：nums = [3,2,1,0,4]</span><br><span class="line">输出：false</span><br><span class="line">解释：无论怎样，总会到达下标为 3 的位置。但该下标的最大跳跃长度是 0 ， 所以永远不可能到达最后一个下标。</span><br></pre></td></tr></table></figure><p>这道题的思路主要在于判断当前下标加上可以跳的步数判断是否到了最后一位，到了就肯定能跳到。</p><h3 id="超时代码"><a href="#超时代码" class="headerlink" title="超时代码"></a>超时代码</h3><p>最开始我写出了这样的递归思路，本质是暴力求解。不出意外的超时了。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="type">bool</span> _canJump(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> index) &#123;</span><br><span class="line">        <span class="keyword">if</span> (index &gt;= nums.<span class="built_in">size</span>() - <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 判断当前是否包括了终点</span></span><br><span class="line">        <span class="keyword">if</span> (index + nums[index] &gt;= nums.<span class="built_in">size</span>() - <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>; <span class="comment">// 不需要跳了，肯定可以抵达终点</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 遍历进行递归</span></span><br><span class="line">        <span class="type">int</span> range = <span class="built_in">min</span>(index + nums[index], (<span class="type">int</span>)(nums.<span class="built_in">size</span>() - <span class="number">1</span>));</span><br><span class="line">        <span class="comment">// 要从index下一位开始，不然就死循环了</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = index + <span class="number">1</span>; i &lt;= range; i++) &#123;</span><br><span class="line">            <span class="comment">// 递归看看能不能跳到终点</span></span><br><span class="line">            <span class="keyword">if</span> (_canJump(nums, i)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 不可以，那就是无了</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">canJump</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123; <span class="keyword">return</span> _canJump(nums, <span class="number">0</span>); &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/04/c92d1741e6e228dc5ab4b49d9c1409c2.png" alt="image.png"></p><h3 id="正确代码-1"><a href="#正确代码-1" class="headerlink" title="正确代码"></a>正确代码</h3><p>代码随想录上提供了一个更好的办法，思路其实也是类似的，但是可以压缩在一个循环中。动态的改变当前for循环i的边界cover，直到cover大于等于最后一位下标的时候，就是可以跳到，返回true。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">canJump</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (nums.<span class="built_in">size</span>() == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="comment">// 只有一个元素，本来就是从这里起跳的，肯定可以达到</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>; </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> cover = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 注意这里是小于等于cover，cover是闭区间</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= cover; i++) &#123; </span><br><span class="line">            <span class="comment">// 判断当前能跳的范围和cover谁大</span></span><br><span class="line">            cover = <span class="built_in">max</span>(i + nums[i], cover);</span><br><span class="line">            <span class="keyword">if</span> (cover &gt;= nums.<span class="built_in">size</span>() - <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>; <span class="comment">// 说明可以覆盖到终点了</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/04/b7bf833dd954963861fc740c7c2517db.png" alt="image.png"></p><h2 id="45-跳跃游戏2"><a href="#45-跳跃游戏2" class="headerlink" title="45 跳跃游戏2"></a>45 跳跃游戏2</h2><h3 id="题目和思路-4"><a href="#题目和思路-4" class="headerlink" title="题目和思路"></a>题目和思路</h3><blockquote><p><a href="https://leetcode.cn/problems/jump-game-ii/description/">https://leetcode.cn/problems/jump-game-ii/description/</a></p></blockquote><p>给定一个长度为 n 的 0 索引整数数组 nums。初始位置为 nums[0]。</p><p>每个元素 nums[i] 表示从索引 i 向前跳转的最大长度。换句话说，如果你在 nums[i] 处，你可以跳转到任意 nums[i + j] 处:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">0 &lt;= j &lt;= nums[i] </span><br><span class="line">i + j &lt; n</span><br></pre></td></tr></table></figure><p>返回到达 nums[n - 1] 的最小跳跃次数。生成的测试用例可以到达 nums[n - 1]。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">示例 1:</span><br><span class="line">输入: nums = [2,3,1,1,4]</span><br><span class="line">输出: 2</span><br><span class="line">解释: 跳到最后一个位置的最小跳跃数是 2。</span><br><span class="line">     从下标为 0 跳到下标为 1 的位置，跳 1 步，然后跳 3 步到达数组的最后一个位置。</span><br><span class="line">     </span><br><span class="line">示例 2:</span><br><span class="line">输入: nums = [2,3,0,1,4]</span><br><span class="line">输出: 2</span><br></pre></td></tr></table></figure><p>这道题和上一题就不同了，上一题只是判断能不能跳到最后一个位置，这一题是在已经可以跳到最后一个位置的基础上，计算最小的跳跃次数。</p><p>不过基本思路还是一样的，就是判断cover的范围。</p><ul><li>在当前范围中，找到下一步能抵达的最大范围</li><li>i抵达当前范围的边界了，必须跳一步了<ul><li>步数加一</li><li>更新当前范围为下一步的最大范围</li><li>判断最大范围是否已经到了<code>nums.size()-1</code>，如果到了直接返回步数（只需要再跳一步就可以抵达末尾了）</li></ul></li></ul><p>不管当前怎么跳，当前范围都是可以跳到的，那么我们只需要找到当前范围中，下一步能抵达的最大位置，那么就是最好的选择。直到下一步抵达终点，返回步数。</p><h3 id="完整代码-1"><a href="#完整代码-1" class="headerlink" title="完整代码"></a>完整代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">jump</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (nums.<span class="built_in">size</span>() == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 当前的跳跃范围</span></span><br><span class="line">        <span class="type">int</span> curJump = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> maxJump = <span class="number">0</span>; <span class="comment">// 判断范围内可以跳的最大值</span></span><br><span class="line">        <span class="type">int</span> count = <span class="number">0</span>;   <span class="comment">// 跳了几次</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="comment">// 更新在[i,curJump]范围内下一步可以跳的最大范围</span></span><br><span class="line">            maxJump = <span class="built_in">max</span>(i + nums[i], maxJump);</span><br><span class="line">            <span class="comment">// 到达右边界了，必须再跳一步了。</span></span><br><span class="line">            <span class="keyword">if</span> (i == curJump) &#123;</span><br><span class="line">                count++;</span><br><span class="line">                curJump = maxJump;</span><br><span class="line">                <span class="comment">// 可以跳到下一步（这里提前count++就相当于跳了这一步）</span></span><br><span class="line">                <span class="keyword">if</span> (maxJump &gt;= nums.<span class="built_in">size</span>() - <span class="number">1</span>) &#123;</span><br><span class="line">                    <span class="keyword">return</span> count;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/04/3084162e56bfdd5cc3b6204357509ace.png" alt="image.png"></p><h2 id="1005-k次取反后的最大和"><a href="#1005-k次取反后的最大和" class="headerlink" title="1005 k次取反后的最大和"></a>1005 k次取反后的最大和</h2><blockquote><p><a href="https://leetcode.cn/problems/maximize-sum-of-array-after-k-negations/">https://leetcode.cn/problems/maximize-sum-of-array-after-k-negations/</a></p></blockquote><h3 id="题目和思路-5"><a href="#题目和思路-5" class="headerlink" title="题目和思路"></a>题目和思路</h3><p>给你一个整数数组 nums 和一个整数 k ，按以下方法修改该数组：</p><p>选择某个下标 i 并将 nums[i] 替换为 -nums[i] 。</p><p>重复这个过程恰好 k 次。可以多次选择同一个下标 i 。</p><p>以这种方式修改数组后，返回数组 可能的最大和 。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">示例 1：</span><br><span class="line">输入：nums = [4,2,3], k = 1</span><br><span class="line">输出：5</span><br><span class="line">解释：选择下标 1 ，nums 变为 [4,-2,3] 。</span><br><span class="line"></span><br><span class="line">示例 2：</span><br><span class="line">输入：nums = [3,-1,0,2], k = 3</span><br><span class="line">输出：6</span><br><span class="line">解释：选择下标 (1, 2, 2) ，nums 变为 [3,1,0,2] 。</span><br><span class="line"></span><br><span class="line">示例 3：</span><br><span class="line">输入：nums = [2,-3,-1,5,-4], k = 2</span><br><span class="line">输出：13</span><br><span class="line">解释：选择下标 (1, 4) ，nums 变为 [2,3,-1,5,4] </span><br></pre></td></tr></table></figure><p>这道题的思路很简单，首先我们肯定是先把负数反转成正的，都是正数了之后，再考虑反转最小的数。</p><p>本来我的想法是，反转完毕负数后，重排序，从最小的数开始一直往后反转，但是这样思考就忽略了题目中的一个要求。题目是<strong>允许在某个下标处重复反转</strong>的。</p><p>那么我们就没有必要从最小的数开始把它们都反转成负数了，而是一直操作最小的那个数，直到k用完。上面的示例2就是这样的，先把负数反转成正数，然后重复操作0。</p><h3 id="完整代码-2"><a href="#完整代码-2" class="headerlink" title="完整代码"></a>完整代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="comment">// 按绝对值从大到小排序</span></span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">bool</span> <span class="title">cmp</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123; <span class="keyword">return</span> <span class="built_in">abs</span>(a) &gt; <span class="built_in">abs</span>(b); &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">largestSumAfterKNegations</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 绝对值从大到小排列</span></span><br><span class="line">        <span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>(), cmp);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="comment">// 反转负数</span></span><br><span class="line">            <span class="keyword">if</span> (nums[i] &lt; <span class="number">0</span> &amp;&amp; k &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                nums[i] *= <span class="number">-1</span>;</span><br><span class="line">                k--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果k还没有用完，则反转绝对值最小的那个数，直到用完k</span></span><br><span class="line">        <span class="comment">// 这里直接判断k是奇数还是偶数，如果是奇数会多出来一次反转，只需要做这一次就可以了</span></span><br><span class="line">        <span class="keyword">if</span> (k % <span class="number">2</span> == <span class="number">1</span>) &#123;</span><br><span class="line">            nums[nums.<span class="built_in">size</span>() - <span class="number">1</span>] *= <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 求和</span></span><br><span class="line">        <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; e : nums) &#123;</span><br><span class="line">            sum += e;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="134-加油站"><a href="#134-加油站" class="headerlink" title="134 加油站"></a>134 加油站</h2><h3 id="题目和思路-6"><a href="#题目和思路-6" class="headerlink" title="题目和思路"></a>题目和思路</h3><blockquote><p><a href="https://leetcode.cn/problems/gas-station/">https://leetcode.cn/problems/gas-station/</a></p></blockquote><p>在一条环路上有 n 个加油站，其中第 i 个加油站有汽油 gas[i] 升。</p><p>你有一辆油箱容量无限的的汽车，从第 i 个加油站开往第 i+1 个加油站需要消耗汽油 cost[i] 升。你从其中的一个加油站出发，开始时油箱为空。</p><p>给定两个整数数组 gas 和 cost ，如果你可以按顺序绕环路行驶一周，则返回出发时加油站的编号，否则返回 -1 。如果存在解，则 保证 它是 唯一 的。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">示例 1:</span><br><span class="line">输入: gas = [1,2,3,4,5], cost = [3,4,5,1,2]</span><br><span class="line">输出: 3</span><br><span class="line">解释:</span><br><span class="line">从 3 号加油站(索引为 3 处)出发，可获得 4 升汽油。此时油箱有 = 0 + 4 = 4 升汽油</span><br><span class="line">开往 4 号加油站，此时油箱有 4 - 1 + 5 = 8 升汽油</span><br><span class="line">开往 0 号加油站，此时油箱有 8 - 2 + 1 = 7 升汽油</span><br><span class="line">开往 1 号加油站，此时油箱有 7 - 3 + 2 = 6 升汽油</span><br><span class="line">开往 2 号加油站，此时油箱有 6 - 4 + 3 = 5 升汽油</span><br><span class="line">开往 3 号加油站，你需要消耗 5 升汽油，正好足够你返回到 3 号加油站。</span><br><span class="line">因此，3 可为起始索引。</span><br><span class="line"></span><br><span class="line">示例 2:</span><br><span class="line">输入: gas = [2,3,4], cost = [3,4,3]</span><br><span class="line">输出: -1</span><br><span class="line">解释:</span><br><span class="line">你不能从 0 号或 1 号加油站出发，因为没有足够的汽油可以让你行驶到下一个加油站。</span><br><span class="line">我们从 2 号加油站出发，可以获得 4 升汽油。 此时油箱有 = 0 + 4 = 4 升汽油</span><br><span class="line">开往 0 号加油站，此时油箱有 4 - 3 + 2 = 3 升汽油</span><br><span class="line">开往 1 号加油站，此时油箱有 3 - 3 + 3 = 3 升汽油</span><br><span class="line">你无法返回 2 号加油站，因为返程需要消耗 4 升汽油，但是你的油箱只有 3 升汽油。</span><br><span class="line">因此，无论怎样，你都不可能绕环路行驶一周。</span><br></pre></td></tr></table></figure><p>这道题使用贪心的方式，找到局部最优：假设从start出发每次走一步，计算<code>gas[i]-cost[i]</code>得到剩余的油，如果剩余的油为负数，说明从<code>[start,i]</code>之中的任意位置出发，走到i的时候都会没油。那么就需要从i+1开始走（更新start）。</p><p>最终遍历完毕整个数组的时候，得到的start肯定是能走完整个区间的起始下标。因为其他下标开始走，都没有办法走完某一个区间。</p><h3 id="完整代码-3"><a href="#完整代码-3" class="headerlink" title="完整代码"></a>完整代码</h3><p>这里还有关于<code>start=i+1</code>是否会出现越界情况的说明，参考代码注释。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">canCompleteCircuit</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; gas, vector&lt;<span class="type">int</span>&gt;&amp; cost)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 1.所有油加起来没有距离长，说明永远走不到</span></span><br><span class="line">        <span class="comment">// 2.假设从0开始，走到i，如果剩余油为负数，说明[0,i]区间内，不管从哪里开始，都走不到i；</span></span><br><span class="line">        <span class="comment">//   那么就需要从i+1开始重新走，直到剩余油再次为负数或者走完整个区间</span></span><br><span class="line">        <span class="type">int</span> start = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> totalSum = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> leftGas = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; gas.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            leftGas += gas[i] - cost[i];</span><br><span class="line">            totalSum += gas[i] - cost[i];</span><br><span class="line">            <span class="keyword">if</span> (leftGas &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// 因为[start,i]区间内剩余油是负数，说明从这个区间任意位置开始都走不到i</span></span><br><span class="line">                <span class="comment">// 所以需要从i+1作为一个新的起点，继续往后走。</span></span><br><span class="line">                start = i + <span class="number">1</span>; </span><br><span class="line">                leftGas = <span class="number">0</span>; <span class="comment">// 重置剩余油</span></span><br><span class="line">                <span class="comment">// 会不会出现i+1越界了的情况？这种情况说明i=size-1的时候，leftGas小于0；</span></span><br><span class="line">                <span class="comment">// 同时也说明了[start,sz-1]还是无法走完，反应到全局说明油本来就是不够的；</span></span><br><span class="line">                <span class="comment">// 此时会在后面的totalSum的判断中返回-1，所以不会出现start越界的情况；</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果diff加起来最终是个负数，说明油是不够用的</span></span><br><span class="line">        <span class="keyword">if</span> (totalSum &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> start;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/04/7f32f785c9fdc45f7cb9296f24767696.png" alt="image.png"></p><h2 id="135-分发糖果"><a href="#135-分发糖果" class="headerlink" title="135 分发糖果"></a>135 分发糖果</h2><blockquote><p><a href="https://leetcode.cn/problems/candy/description/">https://leetcode.cn/problems/candy/description/</a></p></blockquote><h3 id="题目和思路-7"><a href="#题目和思路-7" class="headerlink" title="题目和思路"></a>题目和思路</h3><p>n 个孩子站成一排。给你一个整数数组 ratings 表示每个孩子的评分。</p><p>你需要按照以下要求，给这些孩子分发糖果：</p><p>每个孩子至少分配到 1 个糖果。<br>相邻两个孩子评分更高的孩子会获得更多的糖果。</p><p>请你给每个孩子分发糖果，计算并返回需要准备的 最少糖果数目 。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">示例 1：</span><br><span class="line">输入：ratings = [1,0,2]</span><br><span class="line">输出：5</span><br><span class="line">解释：你可以分别给第一个、第二个、第三个孩子分发 2、1、2 颗糖果。</span><br><span class="line"></span><br><span class="line">示例 2：</span><br><span class="line">输入：ratings = [1,2,2]</span><br><span class="line">输出：4</span><br><span class="line">解释：你可以分别给第一个、第二个、第三个孩子分发 1、2、1 颗糖果。</span><br><span class="line">     第三个孩子只得到 1 颗糖果，这满足题面中的两个条件。</span><br></pre></td></tr></table></figure><p>这道题的思路其实不难，但是我们不要一次性考虑某个小孩的两边，而是应该一次只考虑一边。</p><ul><li>初始化数组，每人一个糖果。</li><li>先从左往右遍历，如果当前孩子的分值高于左边，则当前孩子的糖果数量是左边孩子+1；</li><li>然后从右边往左边遍历，如果当前孩子的分值高于右边，则当前孩子的糖果数量是<code>max(右边孩子糖果数量+1,当前孩子糖果数量)</code></li></ul><p>为什么从右往左的时候需要进行max判断呢？因为题目需要的是最小的糖果数量，同时也需要满足条件，max判断能保证当前的孩子糖果大于右边，同时也满足大于左边的条件（如果直接等于右边的孩子糖果数量+1，可能会导致它不再满足高于左边孩子的糖果的情况）</p><h3 id="完整代码-4"><a href="#完整代码-4" class="headerlink" title="完整代码"></a>完整代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">candy</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; ratings)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 先给所有人分一个糖果</span></span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">candyArray</span><span class="params">(ratings.size(), <span class="number">1</span>)</span></span>;</span><br><span class="line">        <span class="comment">// 从左往右遍历，如果当前孩子比左边的孩子分数多，则让当前的孩子多分一个糖果</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; ratings.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (ratings[i] &gt; ratings[i - <span class="number">1</span>]) &#123;</span><br><span class="line">                candyArray[i] = candyArray[i - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 从右往左遍历，如果当前孩子比右边孩子分数多，则让当前孩子多分一个糖果</span></span><br><span class="line">        <span class="comment">// 注意这里我们需要从倒数第二个孩子开始，此时它的下标是sz-2</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = ratings.<span class="built_in">size</span>() - <span class="number">2</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="keyword">if</span> (ratings[i] &gt; ratings[i + <span class="number">1</span>]) &#123;</span><br><span class="line">                <span class="comment">// 因为前面已经操作过一次了，此时可能当前孩子的糖果已经比i+1多了，那么就需要判断</span></span><br><span class="line">                <span class="comment">// 不然右边孩子的糖果数量+1小于当前已有糖果时，直接赋值会导致左侧条件不满足。</span></span><br><span class="line">                candyArray[i] = <span class="built_in">max</span>(candyArray[i + <span class="number">1</span>] + <span class="number">1</span>, candyArray[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 计算糖果数量</span></span><br><span class="line">        <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; c : candyArray) &#123;</span><br><span class="line">            count += c;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/04/4090a2a83a429258083e07de6bae402a.png" alt="image.png"></p><h2 id="860-柠檬水找零"><a href="#860-柠檬水找零" class="headerlink" title="860 柠檬水找零"></a>860 柠檬水找零</h2><h3 id="题目和思路-8"><a href="#题目和思路-8" class="headerlink" title="题目和思路"></a>题目和思路</h3><blockquote><p><a href="https://leetcode.cn/problems/lemonade-change/description/">https://leetcode.cn/problems/lemonade-change/description/</a></p></blockquote><p>在柠檬水摊上，每一杯柠檬水的售价为 5 美元。顾客排队购买你的产品，（按账单 bills 支付的顺序）一次购买一杯。</p><p>每位顾客只买一杯柠檬水，然后向你付 5 美元、10 美元或 20 美元。你必须给每个顾客正确找零，也就是说净交易是每位顾客向你支付 5 美元。</p><p>注意，一开始你手头没有任何零钱。</p><p>给你一个整数数组 bills ，其中 bills[i] 是第 i 位顾客付的账。如果你能给每位顾客正确找零，返回 true ，否则返回 false 。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">示例 1：</span><br><span class="line">输入：bills = [5,5,5,10,20]</span><br><span class="line">输出：true</span><br><span class="line">解释：</span><br><span class="line">前 3 位顾客那里，我们按顺序收取 3 张 5 美元的钞票。</span><br><span class="line">第 4 位顾客那里，我们收取一张 10 美元的钞票，并返还 5 美元。</span><br><span class="line">第 5 位顾客那里，我们找还一张 10 美元的钞票和一张 5 美元的钞票。</span><br><span class="line">由于所有客户都得到了正确的找零，所以我们输出 true。</span><br><span class="line"></span><br><span class="line">示例 2：</span><br><span class="line">输入：bills = [5,5,10,10,20]</span><br><span class="line">输出：false</span><br><span class="line">解释：</span><br><span class="line">前 2 位顾客那里，我们按顺序收取 2 张 5 美元的钞票。</span><br><span class="line">对于接下来的 2 位顾客，我们收取一张 10 美元的钞票，然后返还 5 美元。</span><br><span class="line">对于最后一位顾客，我们无法退回 15 美元，因为我们现在只有两张 10 美元的钞票。</span><br><span class="line">由于不是每位顾客都得到了正确的找零，所以答案是 false。</span><br></pre></td></tr></table></figure><p>这道题其实是一个最最基本的数学问题。用到贪心的地方就是有<code>10+5</code>和<code>3*5</code>的时候应该先用哪一个进行找零。很明显我们需要用<code>10+5</code>来找零，因为10元只有这个地方能用上。如果优先用5元找零，后序有人用10元来买柠檬水的时候，可能零钱就不够了。</p><h3 id="完整代码-5"><a href="#完整代码-5" class="headerlink" title="完整代码"></a>完整代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">lemonadeChange</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; bills)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 剩余零钱初始化</span></span><br><span class="line">        unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; momenyMap;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> i : bills) &#123;</span><br><span class="line">            <span class="comment">// 先计入获得的零钱</span></span><br><span class="line">            momenyMap[i]++;</span><br><span class="line">            i -= <span class="number">5</span>;</span><br><span class="line">            <span class="comment">// 原本是10元</span></span><br><span class="line">            <span class="keyword">if</span> (i == <span class="number">5</span>) &#123;</span><br><span class="line">                <span class="comment">// 给她找5元</span></span><br><span class="line">                momenyMap[<span class="number">5</span>]--;</span><br><span class="line">                <span class="comment">// 没有零钱了，不行</span></span><br><span class="line">                <span class="keyword">if</span> (momenyMap[<span class="number">5</span>] &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 原本是20元</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (i == <span class="number">15</span>) &#123;</span><br><span class="line">                <span class="comment">// 先用10元的零钱，因为10元的零钱只有这时候可以用</span></span><br><span class="line">                <span class="keyword">if</span> (momenyMap[<span class="number">10</span>] &gt; <span class="number">0</span> &amp;&amp; momenyMap[<span class="number">5</span>] &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    momenyMap[<span class="number">5</span>]--;</span><br><span class="line">                    momenyMap[<span class="number">10</span>]--;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 如果没有十元的零钱，就用3个5元的零钱</span></span><br><span class="line">                <span class="comment">// 不够用，返回false</span></span><br><span class="line">                <span class="keyword">if</span> (momenyMap[<span class="number">5</span>] &lt; <span class="number">3</span>) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 扣掉零钱</span></span><br><span class="line">                momenyMap[<span class="number">5</span>] -= <span class="number">3</span>;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="452-用最少的箭引爆气球"><a href="#452-用最少的箭引爆气球" class="headerlink" title="452 用最少的箭引爆气球"></a>452 用最少的箭引爆气球</h2><h3 id="题目和思路-9"><a href="#题目和思路-9" class="headerlink" title="题目和思路"></a>题目和思路</h3><blockquote><p><a href="https://leetcode.cn/problems/minimum-number-of-arrows-to-burst-balloons/">https://leetcode.cn/problems/minimum-number-of-arrows-to-burst-balloons/</a></p></blockquote><p>有一些球形气球贴在一堵用 XY 平面表示的墙面上。墙面上的气球记录在整数数组 points ，其中<code>points[i] = [xstart, xend]</code> 表示水平直径在 xstart 和 xend之间的气球。你不知道气球的确切 y 坐标。</p><p>一支弓箭可以沿着 x 轴从不同点 完全垂直 地射出。在坐标 x 处射出一支箭，若有一个气球的直径的开始和结束坐标为<code> xstart，xend</code>， 且满足  <code>xstart ≤ x ≤ xend</code>，则该气球会被 引爆 。可以射出的弓箭的数量 没有限制 。 弓箭一旦被射出之后，可以无限地前进。</p><p>给你一个数组 points ，返回引爆所有气球所必须射出的 最小 弓箭数 。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">示例 1：</span><br><span class="line">输入：points = [[10,16],[2,8],[1,6],[7,12]]</span><br><span class="line">输出：2</span><br><span class="line">解释：气球可以用2支箭来爆破:</span><br><span class="line">-在x = 6处射出箭，击破气球[2,8]和[1,6]。</span><br><span class="line">-在x = 11处发射箭，击破气球[10,16]和[7,12]。</span><br><span class="line"></span><br><span class="line">示例 2：</span><br><span class="line">输入：points = [[1,2],[3,4],[5,6],[7,8]]</span><br><span class="line">输出：4</span><br><span class="line">解释：每个气球需要射出一支箭，总共需要4支箭。</span><br><span class="line"></span><br><span class="line">示例 3：</span><br><span class="line">输入：points = [[1,2],[2,3],[3,4],[4,5]]</span><br><span class="line">输出：2</span><br><span class="line">解释：气球可以用2支箭来爆破:</span><br><span class="line">- 在x = 2处发射箭，击破气球[1,2]和[2,3]。</span><br><span class="line">- 在x = 4处射出箭，击破气球[3,4]和[4,5]。</span><br></pre></td></tr></table></figure><p>首先我们需要对边界进行排序，这里选用左边界升序。</p><p>然后从左往右遍历，根据当前的左边界和上一个值的右边界，确定两个气球是否挨着。</p><ul><li>如果挨着，说明两个气球可以被一起射爆（注意边界值相等也视为重叠），此时需要更新当前值的右边界为<code>min(当前右边界,上一个气球的右边界)</code>，因为只有这样才能保证下一次遍历判断的时候得到的结果，能把之前的两个气球射爆</li><li>如果不挨着，说明前一个气球需要单独一箭，计数器加一。</li></ul><p>这里的贪心思想就是不断的更新边界值，来确保找到更多符合同一边界情况的气球，减少箭矢的使用。</p><h3 id="完整代码-6"><a href="#完整代码-6" class="headerlink" title="完整代码"></a>完整代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">bool</span> <span class="title">cmp</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; a, vector&lt;<span class="type">int</span>&gt;&amp; b)</span> </span>&#123; <span class="keyword">return</span> a[<span class="number">0</span>] &lt; b[<span class="number">0</span>]; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">findMinArrowShots</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; points)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (points.<span class="built_in">size</span>() == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 首先需要按左边界对区间排升序</span></span><br><span class="line">        <span class="built_in">sort</span>(points.<span class="built_in">begin</span>(), points.<span class="built_in">end</span>(), cmp);</span><br><span class="line">        <span class="type">int</span> arrow = <span class="number">1</span>; <span class="comment">// points 不为空至少需要一支箭</span></span><br><span class="line">        <span class="type">int</span> end = points[<span class="number">0</span>][<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; points.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="comment">// 重叠了，更新最小的子区间</span></span><br><span class="line">            <span class="keyword">if</span> (points[i][<span class="number">0</span>] &lt;= end) &#123;</span><br><span class="line">                end = <span class="built_in">min</span>(points[i][<span class="number">1</span>], end);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 不重叠，需要射箭</span></span><br><span class="line">                end = points[i][<span class="number">1</span>];</span><br><span class="line">                arrow++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> arrow;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/04/8279f8e0698fd1c921bf1eafedbed0a9.png" alt="image.png"></p><h2 id="406-根据身高重建队列"><a href="#406-根据身高重建队列" class="headerlink" title="406 根据身高重建队列"></a>406 根据身高重建队列</h2><blockquote><p><a href="https://leetcode.cn/problems/queue-reconstruction-by-height/description/">https://leetcode.cn/problems/queue-reconstruction-by-height/description/</a></p></blockquote><h3 id="题目和思路-10"><a href="#题目和思路-10" class="headerlink" title="题目和思路"></a>题目和思路</h3><p>假设有打乱顺序的一群人站成一个队列，数组 people 表示队列中一些人的属性（不一定按顺序）。每个 people[i] &#x3D; [hi, ki] 表示第 i 个人的身高为 hi ，前面 正好 有 ki 个身高大于或等于 hi 的人。</p><p>请你重新构造并返回输入数组 people 所表示的队列。返回的队列应该格式化为数组 queue ，其中 queue[j] &#x3D; [hj, kj] 是队列中第 j 个人的属性（queue[0] 是排在队列前面的人）。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">示例 1：</span><br><span class="line">输入：people = [[7,0],[4,4],[7,1],[5,0],[6,1],[5,2]]</span><br><span class="line">输出：[[5,0],[7,0],[5,2],[6,1],[4,4],[7,1]]</span><br><span class="line">解释：</span><br><span class="line">编号为 0 的人身高为 5 ，没有身高更高或者相同的人排在他前面。</span><br><span class="line">编号为 1 的人身高为 7 ，没有身高更高或者相同的人排在他前面。</span><br><span class="line">编号为 2 的人身高为 5 ，有 2 个身高更高或者相同的人排在他前面，即编号为 0 和 1 的人。</span><br><span class="line">编号为 3 的人身高为 6 ，有 1 个身高更高或者相同的人排在他前面，即编号为 1 的人。</span><br><span class="line">编号为 4 的人身高为 4 ，有 4 个身高更高或者相同的人排在他前面，即编号为 0、1、2、3 的人。</span><br><span class="line">编号为 5 的人身高为 7 ，有 1 个身高更高或者相同的人排在他前面，即编号为 1 的人。</span><br><span class="line">因此 [[5,0],[7,0],[5,2],[6,1],[4,4],[7,1]] 是重新构造后的队列。</span><br><span class="line"></span><br><span class="line">示例 2：</span><br><span class="line">输入：people = [[6,0],[5,0],[4,0],[3,2],[2,2],[1,4]]</span><br><span class="line">输出：[[4,0],[5,0],[2,2],[3,2],[1,4],[6,0]]</span><br></pre></td></tr></table></figure><p>这道题目和<code>135分发糖果</code>有一定相似，都需要从两个维度来考虑。但为了避免出错，我们一次只能考虑一个维度。</p><p>首先要做的就是对people进行排序，那么是根据身高排序，还是根据前面有几个人排序？</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">用例 [[7,0],[4,4],[7,1],[5,0],[6,1],[5,2]]</span><br><span class="line">身高 [[7,0],[7,1],[6,1],[5,0],[5,2],[4,4]]</span><br><span class="line">人数 [[7,0],[5,0],[7,1],[6,1],[5,2],[4,4]]</span><br></pre></td></tr></table></figure><p>会发现，如果按前面有几个人排序，最终得到的序列好像并没有用，也不是题目需要的序列。</p><p>但根据身高降序排序，会让这里的序列满足一个特性，即元素i之前的都比i高。</p><p>这时候我们就能直接根据元素i之前有几个比他高的人，将这个值视作下标，来构建出新的队列！前面有几个比他高的人，就往第几位之后插入。</p><h3 id="完整代码-7"><a href="#完整代码-7" class="headerlink" title="完整代码"></a>完整代码</h3><p>注意这里使用链表来进行插入操作，效率会更高。因为vector每次的insert都需要对元素进行移动，甚至会涉及到空间扩容的消耗（所以我提前reserve了），而list不会有这个问题。</p><p>我们可以先用list来进行插入操作，最后再用迭代器构造vector返回。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">bool</span> <span class="title">cmp</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; a, vector&lt;<span class="type">int</span>&gt;&amp; b)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 按身高升序排序</span></span><br><span class="line">        <span class="keyword">if</span> (a[<span class="number">0</span>] &gt; b[<span class="number">0</span>]) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果身高一样，前面的人少的排前面</span></span><br><span class="line">        <span class="keyword">if</span> (a[<span class="number">0</span>] == b[<span class="number">0</span>]) &#123;</span><br><span class="line">            <span class="keyword">return</span> a[<span class="number">1</span>] &lt; b[<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">reconstructQueue</span>(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; people) &#123;</span><br><span class="line">        <span class="comment">// 按身高降序+前面人的个数升序排列</span></span><br><span class="line">        <span class="built_in">sort</span>(people.<span class="built_in">begin</span>(), people.<span class="built_in">end</span>(), cmp);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; v : people) &#123;</span><br><span class="line">            cout &lt;&lt; v[<span class="number">0</span>] &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; v[<span class="number">1</span>] &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; que;</span><br><span class="line">        que.<span class="built_in">reserve</span>(people.<span class="built_in">size</span>()); <span class="comment">// 提前开空间</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; people.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="comment">// 前面有几个人，就往第几位插入</span></span><br><span class="line">            <span class="type">int</span> offset = people[i][<span class="number">1</span>];</span><br><span class="line">            que.<span class="built_in">insert</span>(que.<span class="built_in">begin</span>() + offset, people[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> que;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>链表版本</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">bool</span> <span class="title">cmp</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; a, vector&lt;<span class="type">int</span>&gt;&amp; b)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 按身高升序排序</span></span><br><span class="line">        <span class="keyword">if</span> (a[<span class="number">0</span>] &gt; b[<span class="number">0</span>]) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果身高一样，前面的人少的排前面</span></span><br><span class="line">        <span class="keyword">if</span> (a[<span class="number">0</span>] == b[<span class="number">0</span>]) &#123;</span><br><span class="line">            <span class="keyword">return</span> a[<span class="number">1</span>] &lt; b[<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">reconstructQueue</span>(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; people) &#123;</span><br><span class="line">        <span class="comment">// 按身高降序+前面人的个数升序排列</span></span><br><span class="line">        <span class="built_in">sort</span>(people.<span class="built_in">begin</span>(), people.<span class="built_in">end</span>(), cmp);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; v : people) &#123;</span><br><span class="line">            cout &lt;&lt; v[<span class="number">0</span>] &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; v[<span class="number">1</span>] &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        list&lt;vector&lt;<span class="type">int</span>&gt;&gt; que;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; people.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="comment">// 前面有几个人，就往第几位插入</span></span><br><span class="line">            <span class="type">int</span> offset = people[i][<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">auto</span> itr = que.<span class="built_in">begin</span>();</span><br><span class="line">            <span class="keyword">while</span>(offset--)&#123;</span><br><span class="line">                itr++;</span><br><span class="line">            &#125;</span><br><span class="line">            que.<span class="built_in">insert</span>(itr, people[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;(que.<span class="built_in">begin</span>(),que.<span class="built_in">end</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="435-无重叠区间"><a href="#435-无重叠区间" class="headerlink" title="435 无重叠区间"></a>435 无重叠区间</h2><h3 id="题目和思路-11"><a href="#题目和思路-11" class="headerlink" title="题目和思路"></a>题目和思路</h3><blockquote><p><a href="https://leetcode.cn/problems/non-overlapping-intervals/">https://leetcode.cn/problems/non-overlapping-intervals/</a></p></blockquote><p>给定一个区间的集合 intervals ，其中 <code>intervals[i] = [starti, endi]</code> 。返回 需要移除区间的最小数量，使剩余区间互不重叠 。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">示例 1:</span><br><span class="line">输入: intervals = [[1,2],[2,3],[3,4],[1,3]]</span><br><span class="line">输出: 1</span><br><span class="line">解释: 移除 [1,3] 后，剩下的区间没有重叠。</span><br><span class="line"></span><br><span class="line">示例 2:</span><br><span class="line">输入: intervals = [ [1,2], [1,2], [1,2] ]</span><br><span class="line">输出: 2</span><br><span class="line">解释: 你需要移除两个 [1,2] 来使剩下的区间没有重叠。</span><br><span class="line"></span><br><span class="line">示例 3:</span><br><span class="line">输入: intervals = [ [1,2], [2,3] ]</span><br><span class="line">输出: 0</span><br><span class="line">解释: 你不需要移除任何区间，因为它们已经是无重叠的了。</span><br></pre></td></tr></table></figure><p>这道题和前文射爆气球的题目很相似，但是需要注意，在射爆气球那道题中，边界值相同视作重叠。而本题边界值相同不视作重叠区间。</p><p>还是用左边界升序排序，记录重叠的区间的数量，即需要删除的区间数量。</p><p>判断到重叠区间的时候，也需要将边界值更新为区间最小右边界。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">end = <span class="built_in">min</span>(intervals[i][<span class="number">1</span>],end);</span><br></pre></td></tr></table></figure><p>因为我们发现两个区间重叠的时候，我们应该删除区间范围（只考虑右边界）最大的那个，才能尽可能的避免当前的这个重叠区间进一步和其他节点重叠。</p><p>题目需要求的是最少需要删除的区间数量，贪心的思想也是在此，每次都删除右边界更大的那个区间，才能保证最终删除的区间数量最少。</p><h3 id="完整代码-8"><a href="#完整代码-8" class="headerlink" title="完整代码"></a>完整代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">bool</span> <span class="title">cmp</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; a, vector&lt;<span class="type">int</span>&gt;&amp; b)</span> </span>&#123; <span class="keyword">return</span> a[<span class="number">0</span>] &lt; b[<span class="number">0</span>]; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">eraseOverlapIntervals</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; intervals)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (intervals.<span class="built_in">size</span>() &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 按左边界升序排序</span></span><br><span class="line">        <span class="built_in">sort</span>(intervals.<span class="built_in">begin</span>(), intervals.<span class="built_in">end</span>(), cmp);</span><br><span class="line">        <span class="comment">// 直接统计重叠区间有哪些</span></span><br><span class="line">        <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> end = intervals[<span class="number">0</span>][<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; intervals.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="comment">// 重叠区间</span></span><br><span class="line">            <span class="keyword">if</span> (intervals[i][<span class="number">0</span>] &lt; end) &#123;</span><br><span class="line">                count++;</span><br><span class="line">                <span class="comment">// 重叠的时候，需要更新最小的边界值</span></span><br><span class="line">                <span class="comment">// 因为我们假设移除那个边界值更大的节点，这样就能最大限度的避免重叠</span></span><br><span class="line">                <span class="comment">// 比如[[1,2],[2,3],[3,4],[1,3]]中，1,2和1,3重叠，我们应该移除1,3才是正确的</span></span><br><span class="line">                <span class="comment">// 此时就应该将2作为边界值继续判断，相当于保留1,2节点</span></span><br><span class="line">                end = <span class="built_in">min</span>(intervals[i][<span class="number">1</span>],end);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="comment">// 不重叠，更新边界值</span></span><br><span class="line">            &#123;</span><br><span class="line">                end = intervals[i][<span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/04/51943b3301f8319a3fdf388178a0ddf4.png" alt="image.png"></p><h2 id="763-划分字母区间"><a href="#763-划分字母区间" class="headerlink" title="763 划分字母区间"></a>763 划分字母区间</h2><h3 id="题目和思路-12"><a href="#题目和思路-12" class="headerlink" title="题目和思路"></a>题目和思路</h3><blockquote><p><a href="https://leetcode.cn/problems/partition-labels/description/">https://leetcode.cn/problems/partition-labels/description/</a></p></blockquote><p>给你一个字符串 s 。我们要把这个字符串划分为尽可能多的片段，同一字母最多出现在一个片段中。</p><p>注意，划分结果需要满足：将所有划分结果按顺序连接，得到的字符串仍然是 s 。</p><p>返回一个表示每个字符串片段的长度的列表。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">示例 1：</span><br><span class="line">输入：s = &quot;ababcbacadefegdehijhklij&quot;</span><br><span class="line">输出：[9,7,8]</span><br><span class="line">解释：</span><br><span class="line">划分结果为 &quot;ababcbaca&quot;、&quot;defegde&quot;、&quot;hijhklij&quot; 。</span><br><span class="line">每个字母最多出现在一个片段中。</span><br><span class="line">像 &quot;ababcbacadefegde&quot;, &quot;hijhklij&quot; 这样的划分是错误的，因为划分的片段数较少。 </span><br><span class="line"></span><br><span class="line">示例 2：</span><br><span class="line">输入：s = &quot;eccbbbbdec&quot;</span><br><span class="line">输出：[10]</span><br></pre></td></tr></table></figure><p>这道题的思路是，先遍历一次字符串，维护一个相同长度的字母最远出现位置（下标）的数组。</p><p>以题目给出的示例1为例，按照如上思路可以维护出一个这样的数组。</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/04/98c1a314b0c2c2f8be0f2012f0da26e2.png" alt="image.png"></p><p>再次遍历字符串，最开始start为0，以<code>[start,i]</code>为一个区间，维护一个这个<strong>区间中</strong>字母的<strong>最远出现位置</strong>，当i等于当前的“最远出现位置”时，说明已经得到了一个可分割的子区间，更新start为i+1，继续遍历下一个区间。</p><ul><li>为什么i等于当前最远出现位置时就找到了一个可分割的子序列呢？</li></ul><p>还是看示例1，观察图中被标红的位置，这些都是可以进行分割的位置。当我们遍历<code>[0,8]</code>这个区间时，维护的这个区间中字母最远出现位置就是8，当i等于8的时候，对应字符的最远出现位置也是8，说明在这个区间中，没有其他字符最远出现的位置大于8了，即符合题目中给出的“每个字母只在其中一个区间出现”的要求。</p><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/04/98c1a314b0c2c2f8be0f2012f0da26e2.png" alt="image.png"></p><p>这里并没有用到贪心思路，而是根据题意进行的一个模拟。</p><h3 id="完整代码-9"><a href="#完整代码-9" class="headerlink" title="完整代码"></a>完整代码</h3><p>注意这道题干说了字符串只包含因英文小写字母，所以使用一个定长的数组，效率会高于<code>unordered_map</code>数据结构。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">partitionLabels</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 统计每个字符最远出现的下标位置</span></span><br><span class="line">        <span class="comment">// unordered_map&lt;char, int&gt; indexMap;</span></span><br><span class="line">        <span class="type">int</span> indexMap[<span class="number">27</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; s.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            indexMap[s[i]-<span class="string">&#x27;a&#x27;</span>] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 遍历下标数组，如果当前数组的元素值和下标值相同，则找到了一个切割点</span></span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; retV;</span><br><span class="line">        <span class="type">int</span> start = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> end = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; s.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="comment">// 每一次都是在start,end范围内，找已经出现过的字符的最远出现位置</span></span><br><span class="line">            <span class="comment">// 如果最终i等于end了，说明当前字符是之前出现过的字符最后出现过的一个位置</span></span><br><span class="line">            <span class="comment">// 在当前字符之后，是不会有其他已经出现过的字符的，不然这里的max就没有意义了</span></span><br><span class="line">            end = <span class="built_in">max</span>(end, indexMap[s[i]-<span class="string">&#x27;a&#x27;</span>]);</span><br><span class="line">            <span class="keyword">if</span> (i == end) &#123;</span><br><span class="line">                retV.<span class="built_in">push_back</span>(i - start + <span class="number">1</span>); <span class="comment">// 插入长度</span></span><br><span class="line">                start = i + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> retV;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/04/591cb30a642d04b6003ca73436a1deb9.png" alt="image.png"></p><h2 id="56-合并区间"><a href="#56-合并区间" class="headerlink" title="56 合并区间"></a>56 合并区间</h2><blockquote><p><a href="https://leetcode.cn/problems/merge-intervals/">https://leetcode.cn/problems/merge-intervals/</a></p></blockquote><h3 id="题目和思路-13"><a href="#题目和思路-13" class="headerlink" title="题目和思路"></a>题目和思路</h3><p>以数组 intervals 表示若干个区间的集合，其中单个区间为 <code>intervals[i] = [starti, endi]</code> 。请你合并所有重叠的区间，并返回 一个不重叠的区间数组，该数组需恰好覆盖输入中的所有区间 。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">示例 1：</span><br><span class="line">输入：intervals = [[1,3],[2,6],[8,10],[15,18]]</span><br><span class="line">输出：[[1,6],[8,10],[15,18]]</span><br><span class="line">解释：区间 [1,3] 和 [2,6] 重叠, 将它们合并为 [1,6].</span><br><span class="line"></span><br><span class="line">示例 2：</span><br><span class="line">输入：intervals = [[1,4],[4,5]]</span><br><span class="line">输出：[[1,5]]</span><br><span class="line">解释：区间 [1,4] 和 [4,5] 可被视为重叠区间。</span><br></pre></td></tr></table></figure><p>这道题和前面遇到的几个区间重叠的问题一致，都是需要先对给出数组按左区间进行排序，再判断重叠区间，最终将重叠的区间进行合并。</p><p>当<code>intervals[i][0] &lt;= intervals[i-1][1]</code>的时候，视作两个区间重叠（相同也是重叠的情况），此时需要扩展原有区间为<code>max(intervals[i][1],intervals[i-1][1])</code>，再继续向后遍历。</p><h3 id="完整代码-10"><a href="#完整代码-10" class="headerlink" title="完整代码"></a>完整代码</h3><p>注意vector是有front&#x2F;back这两个函数来访问第一个&#x2F;最后一个元素的，<strong>且返回的是引用</strong>，写<code>retV.back()</code>的代码可读性会好于<code>retV[retV.size()-1]</code>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="comment">// 注意sort中升序是小于，降序是大于</span></span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">bool</span> <span class="title">cmp</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; a, vector&lt;<span class="type">int</span>&gt;&amp; b)</span> </span>&#123; <span class="keyword">return</span> a[<span class="number">0</span>] &lt; b[<span class="number">0</span>]; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">merge</span>(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; intervals) &#123;</span><br><span class="line">        <span class="keyword">if</span> (intervals.<span class="built_in">size</span>() &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> intervals;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">sort</span>(intervals.<span class="built_in">begin</span>(), intervals.<span class="built_in">end</span>(), cmp);</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; retV; <span class="comment">// 结果集</span></span><br><span class="line">        <span class="comment">// 先直接把第一个元素插入</span></span><br><span class="line">        retV.<span class="built_in">push_back</span>(intervals[<span class="number">0</span>]);</span><br><span class="line">        <span class="comment">// 从第二个元素开始遍历</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; intervals.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="comment">// 判断当前区间是否小于结果集中上一个的边界</span></span><br><span class="line">            <span class="keyword">if</span> (intervals[i][<span class="number">0</span>] &lt;= retV.<span class="built_in">back</span>()[<span class="number">1</span>]) &#123;</span><br><span class="line">                <span class="comment">// 如果小于，更新为两个值中更大的那个</span></span><br><span class="line">                retV.<span class="built_in">back</span>()[<span class="number">1</span>] = <span class="built_in">max</span>(intervals[i][<span class="number">1</span>], retV.<span class="built_in">back</span>()[<span class="number">1</span>]);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="comment">// 不小于，插入结果集</span></span><br><span class="line">            &#123;</span><br><span class="line">                retV.<span class="built_in">push_back</span>(intervals[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> retV;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/04/24f7470bf9f4043065640d9429b85037.png" alt="image.png"></p><h2 id="738-单调递增的数字"><a href="#738-单调递增的数字" class="headerlink" title="738 单调递增的数字"></a>738 单调递增的数字</h2><blockquote><p><a href="https://leetcode.cn/problems/monotone-increasing-digits/description/">https://leetcode.cn/problems/monotone-increasing-digits/description/</a></p></blockquote><h3 id="题目和思路-14"><a href="#题目和思路-14" class="headerlink" title="题目和思路"></a>题目和思路</h3><p>当且仅当每个相邻位数上的数字 x 和 y 满足 x &lt;&#x3D; y 时，我们称这个整数是单调递增的。</p><p>给定一个整数 n ，返回 小于或等于 n 的最大数字，且数字呈 单调递增 。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">示例 1:</span><br><span class="line">输入: n = 10</span><br><span class="line">输出: 9</span><br><span class="line"></span><br><span class="line">示例 2:</span><br><span class="line">输入: n = 1234</span><br><span class="line">输出: 1234</span><br><span class="line"></span><br><span class="line">示例 3:</span><br><span class="line">输入: n = 332</span><br><span class="line">输出: 299</span><br></pre></td></tr></table></figure><p>这道题需要我们<strong>从后往前</strong>遍历一个数字，方便处理，我们可以先把数字转成一个字符串（当然遍历一下写入到数组中也是可以的）。</p><ul><li>当前位大于上一位，不处理</li><li>当前位小于上一位，将上一位减一，当前位可以设置为9</li></ul><p>因为题目中给出的递增数字中，<code>x99999</code>也算做递增的情况，所以第二种情况，可以先记录一下当前的下标，并使用第二个循环从这个下标位置开始往后全部都设置为9。</p><h3 id="完整代码-11"><a href="#完整代码-11" class="headerlink" title="完整代码"></a>完整代码</h3><p>代码如下，不算难写。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">monotoneIncreasingDigits</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        string s = <span class="built_in">to_string</span>(n);</span><br><span class="line">        <span class="comment">// 从后往前遍历</span></span><br><span class="line">        <span class="type">int</span> start = s.<span class="built_in">size</span>() + <span class="number">1</span>; <span class="comment">// 初始化为不会进入第二个循环的值</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = s.<span class="built_in">size</span>() - <span class="number">1</span>; i &gt;= <span class="number">1</span>; i--) &#123;</span><br><span class="line">            <span class="comment">// 对于ascii来说也是增加的，所以可以直接判断</span></span><br><span class="line">            <span class="keyword">if</span> (s[i - <span class="number">1</span>] &gt; s[i]) &#123;</span><br><span class="line">                s[i - <span class="number">1</span>]--;</span><br><span class="line">                start = i; <span class="comment">// 从这一位开始设置9</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 从start开始遍历，设置9，注意x99999也视作递增序列</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = start; i &lt; s.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            s[i] = <span class="string">&#x27;9&#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">atoi</span>(s.<span class="built_in">c_str</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/04/a55a84276ea4632ff6f95b747c348bc0.png" alt="image.png"></p><p>写完这个代码后，我想到了一个问题，有没有可能<code>s[i-1]=&#39;0&#39;</code>，这样减减一下岂不是上一位就不是数字了？</p><p>实际上是不可能出现这个情况的，如果<code>s[i-1]=&#39;0&#39;</code>的情况，当前位<code>s[i]</code>是不可能小于他的，最多是等于的情况（两个都是零），所以不会出现操作0减减，自然不会有问题。</p><h2 id="968-监控二叉树"><a href="#968-监控二叉树" class="headerlink" title="968 监控二叉树"></a>968 监控二叉树</h2><blockquote><p><a href="https://leetcode.cn/problems/binary-tree-cameras/description/">https://leetcode.cn/problems/binary-tree-cameras/description/</a></p></blockquote><h3 id="题目和代码"><a href="#题目和代码" class="headerlink" title="题目和代码"></a>题目和代码</h3><p>给定一个二叉树，我们在树的节点上安装摄像头。</p><p>节点上的每个摄影头都可以监视其父对象、自身及其直接子对象。</p><p>计算监控树的所有节点所需的最小摄像头数量。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">这道题的示例建议看leetcode上给出的图例。</span><br><span class="line"></span><br><span class="line">输入：[0,0,null,0,0]</span><br><span class="line">输出：1</span><br><span class="line">解释：如图所示，一台摄像头足以监控所有节点。</span><br></pre></td></tr></table></figure><p>本题需要我们计算监控所有节点涉及到的最少的摄像头数量，那么一个摄像头最好是能同时监控下层和上层（没有漏掉的层），<strong>才是利用率最大化</strong>。这也是贪心的思想所在。首先可以确定的是，我们需要用<strong>后续遍历</strong>，从最底下开始往上遍历整个树。</p><p>根据这个思路，<strong>叶子节点肯定不能装摄像头</strong>。因为叶子节点没有子树，装摄像头相当于白白浪费了摄像头对下一层子树的监看，最终肯定不能达到最大的监控数量。</p><p>这个思路能帮我们确定递归的终止条件，即在空节点应该返回什么。不过在编写代码之前，我们应该先定义好三个状态值。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">0 没有监控也没有被覆盖上</span><br><span class="line">1 装了监控</span><br><span class="line">2 被覆盖上了（但是没有装监控）</span><br></pre></td></tr></table></figure><p>那么空节点应该返回哪一个状态码呢？先来考虑一下什么时候当前节点需要装摄像头</p><ul><li>左子树和右子树只要有其中一个装了摄像头（返回值为1），当前节点就能被覆盖上，不需要装摄像头；</li><li>右子树和左子树只要有一个没有被覆盖上（返回值为0），那么当前节点就必须装摄像头，<strong>否则会有子树无法被覆盖</strong>；</li></ul><p>由此可见，空节点不能返回1，因为这说明叶子节点被覆盖了，反馈到上一层会认为不需要装摄像头，导致最终叶子节点并没有被覆盖上，不符合题目条件。空节点也不能返回0，因为这说明叶子节点需要装摄像头。</p><p>所以，空节点只能返回2啦！</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(root == <span class="literal">nullptr</span>)&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其他情况就是上文提到的，采用后续遍历，用left&#x2F;right接受左右子树遍历的结果，只要有一个为0，那么就需要装摄像头，摄像头数量加一，函数返回1；</p><p>最后是只要有一个为1，就代表不用装摄像头，返回2；</p><h3 id="完整代码-12"><a href="#完整代码-12" class="headerlink" title="完整代码"></a>完整代码</h3><p>依照上述思路可以写出如下代码。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="comment">// 0代表没有被摄像头覆盖</span></span><br><span class="line">    <span class="comment">// 1代表有摄像头</span></span><br><span class="line">    <span class="comment">// 2代表被摄像头覆盖（但是没有装摄像头）</span></span><br><span class="line">    <span class="type">int</span> _minCameraCoverResult(TreeNode* root, <span class="type">int</span>&amp; result) &#123;</span><br><span class="line">        <span class="comment">// 空节点视作被摄像头覆盖了（题目不需要考虑空节点）</span></span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 后续遍历</span></span><br><span class="line">        <span class="type">int</span> left = _minCameraCoverResult(root-&gt;left, result);</span><br><span class="line">        <span class="type">int</span> right = _minCameraCoverResult(root-&gt;right, result);</span><br><span class="line">        <span class="comment">// 判断当前节点是否需要装摄像头</span></span><br><span class="line">        <span class="comment">// 1.如果两个都是2，代表当前节点不需要装摄像头（不然会损失一层覆盖），返回0</span></span><br><span class="line">        <span class="keyword">if</span> (left == <span class="number">2</span> &amp;&amp; right == <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">// 当前节点不装摄像头也没有被覆盖</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 2.如果两个节点中有一个是0，则代表当前节点必须装摄像头才能覆盖到下一层的节点</span></span><br><span class="line">        <span class="keyword">if</span> (left == <span class="number">0</span> || right == <span class="number">0</span>) &#123;</span><br><span class="line">            result++; <span class="comment">// 当前节点需要装摄像头</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 注意必须先判断两个其中有一个为0的情况，因为这种情况是必须装摄像头的；</span></span><br><span class="line">        <span class="comment">// 比如：一个为1一个为0，虽然此时本层已经被覆盖，但有一个子树没有覆盖上，本层必须装摄像头</span></span><br><span class="line">        <span class="comment">// 3.两个节点中其中一个是1，说明当前节点已经被覆盖上，不需要装摄像头</span></span><br><span class="line">        <span class="keyword">if</span> (left == <span class="number">1</span> || right == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">// 理论上不会走到这里</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">minCameraCover</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> result = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 如果当前位是0（没有覆盖上，即root节点没有被覆盖）</span></span><br><span class="line">        <span class="keyword">if</span> (_minCameraCoverResult(root, result) == <span class="number">0</span>) &#123;</span><br><span class="line">            result++; <span class="comment">// root节点装摄像头</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://img.musnow.top/i/2024/04/eeedb0da2db9105ff8ce3ddc422ae219.png" alt="image.png"></p>]]></content>
    
    
    <summary type="html">学习贪心算法</summary>
    
    
    
    <category term="编程学习" scheme="https://blog.musnow.top/categories/%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="把题目都给刷干净" scheme="https://blog.musnow.top/categories/%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0/%E6%8A%8A%E9%A2%98%E7%9B%AE%E9%83%BD%E7%BB%99%E5%88%B7%E5%B9%B2%E5%87%80/"/>
    
    
    <category term="算法" scheme="https://blog.musnow.top/tags/%E7%AE%97%E6%B3%95/"/>
    
    <category term="leetcode" scheme="https://blog.musnow.top/tags/leetcode/"/>
    
  </entry>
  
</feed>
