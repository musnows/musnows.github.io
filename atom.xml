<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>慕雪的寒舍</title>
  
  <subtitle>雪下了一夜</subtitle>
  <link href="https://blog.musnow.top/atom.xml" rel="self"/>
  
  <link href="https://blog.musnow.top/"/>
  <updated>2023-12-10T07:32:14.000Z</updated>
  <id>https://blog.musnow.top/</id>
  
  <author>
    <name>慕雪年华</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>【Hexo】在中英文之间添加空格</title>
    <link href="https://blog.musnow.top/posts/3894841472/"/>
    <id>https://blog.musnow.top/posts/3894841472/</id>
    <published>2023-12-10T07:32:14.000Z</published>
    <updated>2023-12-10T07:32:14.000Z</updated>
    
    <content type="html"><![CDATA[<p>如题，中英文添加空格是比较规范的写法， 但是我个人实在是懒，每次都要这么弄太累了。想找找 hexo 有没有对应的插件，还是有的</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-filter-auto-spacing --save</span><br></pre></td></tr></table></figure><p>安装了之后，在 hexo 的 <code>_config.yml</code> 里面添加配置项</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># hexo 中英文之间自动加空格</span><br><span class="line"># npm install hexo-filter-auto-spacing --save</span><br><span class="line">auto_spacing:</span><br><span class="line">  enable: true</span><br></pre></td></tr></table></figure><p>随后 <code>hexo s</code> 就能看到插件启用后的结果了</p><p><img src="https://img.musnow.top/i/2023/12/bc23322af55db5caac57603bdc3df125.png" alt="image-20231210153203131"></p><p>请注意，该插件仓库 <a href="https://github.com/hexojs/hexo-filter-auto-spacing">https://github.com/hexojs/hexo-filter-auto-spacing</a> 已经被设置为公共归档，且最后一次代码提交是<strong>2022 年 6 月</strong>。</p><p>2023 年 12 月 10 日实测该插件依旧有用，但不保证 hexo 更新后依旧有效。慕雪使用的 hexo 和主题版本如下。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hexo 6.2.0</span><br><span class="line">hexo-butterfly 4.9.0</span><br></pre></td></tr></table></figure><p>暂时没有搜到其他仍在更新的插件。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;如题，中英文添加空格是比较规范的写法， 但是我个人实在是懒，每次都要这么弄太累了。想找找 hexo 有没有对应的插件，还是有的&lt;/p&gt;
&lt;figure class=&quot;highlight plaintext&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pr</summary>
      
    
    
    
    <category term="差生文具多" scheme="https://blog.musnow.top/categories/%E5%B7%AE%E7%94%9F%E6%96%87%E5%85%B7%E5%A4%9A/"/>
    
    
    <category term="Hexo" scheme="https://blog.musnow.top/tags/Hexo/"/>
    
  </entry>
  
  <entry>
    <title>【Nginx】NGINX 配置避免 IP 访问时证书暴露域名</title>
    <link href="https://blog.musnow.top/posts/3528013149/"/>
    <id>https://blog.musnow.top/posts/3528013149/</id>
    <published>2023-12-09T09:12:55.000Z</published>
    <updated>2023-12-09T10:12:55.000Z</updated>
    
    <content type="html"><![CDATA[<p>本文转载自：<a href="https://zinglix.xyz/2021/10/04/nginx-ssl-reject-handshake/">https://zinglix.xyz/2021/10/04/nginx-ssl-reject-handshake/</a></p><h1 id="原文"><a href="# 原文" class="headerlink" title="原文"></a>原文</h1><h2 id="TL-DR"><a href="#TL-DR" class="headerlink" title="TL;DR"></a>TL;DR</h2><p>NGINX 配置避免 IP 访问时证书暴露域名</p><p>利用 <code>NGINX 1.19.4</code> 后的新特性 <code>ssl_reject_handshake on;</code>，将其置于默认访问时配置中，IP 访问时会终止 TLS 握手，也就不会暴露域名了。</p><p>使用如下命令查看你的 nginx 版本</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># nginx -v</span><br><span class="line">nginx version: nginx/1.20.1</span><br></pre></td></tr></table></figure><h2 id="细说"><a href="# 细说" class="headerlink" title="细说"></a>细说</h2><p>CDN 是建站时常用的工具，在自己的主机外面套一层 CDN 是常见操作，一般这样认为自己的主机就安全了，有人来攻击也会先到 CDN 服务器，攻击者根本无法获取到自己主机的 IP，但事实真的是这样吗？</p><p>我们先来看看一般配置后会出现什么问题。</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">    <span class="attribute">listen</span> <span class="number">80</span> default_server;</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Redirect all HTTP requests to HTTPS.</span></span><br><span class="line">    <span class="attribute">return</span> <span class="number">301</span> https://<span class="variable">$host</span><span class="variable">$request_uri</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">    <span class="attribute">listen</span> <span class="number">443</span> default_server;</span><br><span class="line">    <span class="attribute">server_name</span> _;</span><br><span class="line">    <span class="attribute">include</span> conf.d/ssl.config;</span><br><span class="line">    <span class="attribute">return</span> <span class="number">444</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面是一个很常用的 NGINX 配置，HTTP 访问全部重定向到 HTTPS 的 443 端口上，没有配置过的域名返回 444 终止连接。</p><p>好了，现在尝试用 IP 和 HTTPS 访问你的网站，你应该能够看到预想中访问失败、证书无效等连接失败的提示。</p><p><strong>但是！</strong>注意下浏览器左上角提示的不安全，点开查看证书信息，你就会发现你的域名其实随着证书发送了过来。此时如果你是攻击者，那么其实就可以知道该域名背后的源主机 IP 就是这个。</p><p><img src="https://img.musnow.top/i/2023/12/035ad572d3638bb917c07e53e24c9575.png"></p><p>上图即为用 IP 访问后，依旧能看到证书内容。这是因为返回 444 是 HTTP 层面的事情，意味着到达这一步下层的 TLS 握手已经完成。证书不被信任是一回事，但说明已经拿到了服务器的证书。</p><p>CDN 确实避免了直接 DNS 查询暴露 IP 的问题，但攻击者通过扫描全网 IP，用上述方式依旧可以知道每个 IP 对应的域名是什么，这也是为什么很多站长用了 CDN 后并且反复更换 IP 却依旧被攻击者迅速找到 IP 的原因。</p><blockquote><p><a href="https://search.censys.io/">Censys</a> 就一直在干这件事，全网扫描 IP 并找到其对应的域名</p></blockquote><h2 id="那该怎么办呢？"><a href="# 那该怎么办呢？" class="headerlink" title="那该怎么办呢？"></a>那该怎么办呢？</h2><p>问题根源出在 client 在 TLS 握手时发送了 ClientHello 后，NGINX 在 ServerHello 中带着含有域名的默认证书返回了，因为 NGINX 期望可以完成握手，这可能可以算是 NGINX 的一个缺陷。</p><blockquote><p>如果你不熟悉 TLS 握手流程，那么可以看看 <a href="https://zinglix.xyz/2019/05/07/tls-handshake/">这篇文章</a></p></blockquote><h3 id="笨办法"><a href="# 笨办法" class="headerlink" title="笨办法"></a>笨办法 </h3><p> 既然 NGINX 默认提供了带有域名的证书，那么想不暴露也很简单，提供一个不含有正确域名的证书即可。</p><p>NGINX 设置中 HTTPS 访问如果没有设置证书，那么就会报错。但反正 IP 访问也不需要提供服务，那么直接自签一个 IP 证书，或者随便一个域名的证书都可。当然，如果能搞定合法的 IP 证书也不是不行。</p><p>搞定证书后，添加一个配置，让 IP 访问返回错误证书就完事了。</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">    <span class="attribute">listen</span> <span class="number">443</span> ssl default_server;</span><br><span class="line">    <span class="attribute">server_name</span> your_ip;</span><br><span class="line"></span><br><span class="line">    <span class="attribute">ssl_certificate</span>    xxxx.pem;</span><br><span class="line">    // <span class="attribute">and</span> more ssl config ...</span><br><span class="line"></span><br><span class="line">    return <span class="number">444</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="好方法"><a href="# 好方法" class="headerlink" title="好方法"></a>好方法 </h3><p> 这种方法还得自己搞个证书，如果服务器多每个都得这么搞也挺麻烦的，好在这个问题 NGINX 这已经有了很完美的解决方案。</p><p>ClientHello 中是带着 SNI 的，所以其实握手阶段是可以知道访问的域名是否合法的，NGINX 1.19.4 中添加了一个新的配置项 <code>ssl_reject_handshake</code> 用于拒绝握手，也就不会提供证书。</p><p>使用方法也很简单，将原本默认配置中的 <code>return 444</code> 替换成 <code>ssl_reject_handshake on</code> 即可。</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">    <span class="attribute">listen</span> <span class="number">443</span> default_server;</span><br><span class="line">    <span class="attribute">server_name</span> _;</span><br><span class="line">    <span class="attribute">include</span> conf.d/ssl.config;</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 不用返回 444 了，直接拒绝握手</span></span><br><span class="line">    <span class="attribute">ssl_reject_handshake</span> <span class="literal">on</span>;</span><br><span class="line">    <span class="comment"># return 444;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>配置后，再尝试 IP 访问，会发现浏览器报了 <code>ERR_SSL_UNRECOGNIZED_NAME_ALERT</code> 的错误，也看不到证书信息，目标达成！</p><p><img src="https://img.musnow.top/i/2023/12/18ba4a8ac5a7c8d5400ecf4a2a6bb392.png"></p><h2 id="其实还没完"><a href="# 其实还没完" class="headerlink" title="其实还没完"></a>其实还没完 </h2><p> 上述方法是通过 ClientHello 中的 SNI 确定访问是否合法的，那如果 SNI 就是正确的域名呢？</p><p>这种场景发生于攻击者已经确定要攻击某个域名，那么他就可以将带着该域名的握手信息遍历所有 IP，握手成功就找到，这样访问其实与正常访问并无区别，<strong>唯一解决方法 </strong> 就是白名单只允许 CDN 服务器访问。</p><blockquote><p>例如攻击者用 hosts 直接硬写 IP，<strong>将域名强行指向某个 IP</strong></p><p>或者用这种方式 <code>curl https://example.com --resolve &#39;example.com:443:172.17.54.18&#39;</code></p></blockquote><p>如下，在 nginx 里面的 location 配置添加上 allow 的 IP 段，只允许 CDN 运营商的 IP 访问你的服务，就能避免绕过 CDN 造成的攻击</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">location</span> / &#123;</span><br><span class="line">    <span class="attribute">allow</span>   <span class="number">172.1.2.0</span>/<span class="number">24</span>; <span class="comment"># 允许 CDN 运营商的 IP</span></span><br><span class="line">    <span class="attribute">allow</span>   <span class="number">1.2.3.4</span>/<span class="number">32</span>;</span><br><span class="line">    <span class="attribute">deny</span>    all; <span class="comment"># 阻止其他任何 IP</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述 IP 段只能向 CDN 服务提供商询问，一般文档中都是有相关信息的。</p><h1 id="慕雪的测试"><a href="# 慕雪的测试" class="headerlink" title="慕雪的测试"></a>慕雪的测试 </h1><p> 上面这篇文章我第一次看的时候还没有理解他说的是什么内容。后来测试了一下，明白了。</p><h2 id="说明"><a href="# 说明" class="headerlink" title="说明"></a>说明 </h2><p> 以我的服务器举例，我是 <code>centos 7.2</code> 的服务器，直接用 yum 安装的 nginx，版本<code>nginx/1.20.1</code>，配置路径是<code>/etc/nginx</code>；</p><p>在默认情况下，你会有个 <code>nginx.conf</code>，和<code>/etc/nginx/conf.d</code> 里面的用户配置文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">/etc/nginx</span><br><span class="line">- nginx.conf</span><br><span class="line">- conf.d</span><br><span class="line">- server1.conf</span><br><span class="line">- server2.conf</span><br></pre></td></tr></table></figure><p>在 <code>nginx.conf</code> 里面除了加载用户配置文件，还会有一个默认的 server，指向一个 <strong> 静态文件路径</strong>。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"># 用户配置文件</span><br><span class="line">   include /etc/nginx/conf.d/*.conf;</span><br><span class="line"></span><br><span class="line">   server &#123;</span><br><span class="line">       listen       80;</span><br><span class="line">       listen       [::]:80;</span><br><span class="line">       server_name  _;</span><br><span class="line">       root         /usr/share/nginx/html; # 默认的静态文件路径</span><br><span class="line"></span><br><span class="line">       # Load configuration files for the default server block.</span><br><span class="line">       include /etc/nginx/default.d/*.conf;</span><br><span class="line"></span><br><span class="line">       error_page 404 /404.html;</span><br><span class="line">       location = /404.html &#123;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       error_page 500 502 503 504 /50x.html;</span><br><span class="line">       location = /50x.html &#123;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>在我的服务器上，这个路径里面是如下内容</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@bt-7274:/etc/nginx]# ls /usr/share/nginx/html</span><br><span class="line">404.html  50x.html  en-US  icons  img  index.html  nginx-logo.png  poweredby.png</span><br></pre></td></tr></table></figure><p>此时直接在浏览器访问你的 ip，会展示这个默认路径里面的<code>index.html</code>，是 centos 的一个介绍页面。</p><p><img src="https://img.musnow.top/i/2023/12/03207321f1c2ee5a4f77f22d55746121.png" alt="image-20231209173337849"></p><p>但是，这并不代表你当前没有解析到任何 <strong> 用户自定义文件 </strong>！nginx 默认情况下会使用第一个用户自定义 conf 来作为 ip 访问的结果（这是因为对用户自定义 conf 的 include 是在 defualt server 之前的，你可以理解为用户自定义文件会像 C 语言的头文件一样在<code>nginx.conf</code> 中被展开）</p><p>当前实际上是访问了 <code>/etc/nginx/conf.d</code> 里面按字典排序的 <strong> 第一个用户 conf 配置</strong>！</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">/etc/nginx</span><br><span class="line">- nginx.conf</span><br><span class="line">- conf.d</span><br><span class="line">- server1.conf # 直接访问 ip，使用了这个配置文件</span><br><span class="line">- server2.conf</span><br></pre></td></tr></table></figure><p>为什么在我这里依旧展示了 <strong> 默认的静态文件路径呢 </strong>？是因为我的第一个配置文件<code>a.conf</code> 中没有配置<code>location /</code>，全都是其他路径（比如<code>/a/</code>）的反代！所以 nginx 就往后采用了最末尾的 default server 里面提供的默认静态文件。</p><p>而浏览器链接左侧的红色 <code> 不安全 </code> 就告诉我们，当前其实收到了一个 ssl 证书，这便是上面原文中提到的 <code>ip 访问会因为 ssl 证书泄漏域名</code> 的问题。</p><p><img src="https://img.musnow.top/i/2023/12/0aff6af71c686835cb262961360442ab.png" alt="image-20231209174001901"></p><p>我们可以点击 <code> 不安全 </code> 提示，再点击右上角那个 <strong> 带徽章的小按钮</strong>，查看当前收到的证书</p><p><img src="https://img.musnow.top/i/2023/12/96fafa7dca660e58ec838fb95350aa05.png" alt="image-20231209174025184"></p><p>如下图，当前收到的这证书，正是我的 <code>/etc/nginx/conf.d</code> 中第一个用户配置里面的 ssl 证书；内部包含了该证书对应的域名，我们的域名因此泄漏！</p><p><img src="https://img.musnow.top/i/2023/12/c59ed5779697e2dda320ae46d6b8f7e5.png" alt="image-20231209174102666"></p><h2 id="思路回顾"><a href="# 思路回顾" class="headerlink" title="思路回顾"></a>思路回顾 </h2><p> 再来缕一缕思路</p><ul><li>nginx 会先加载用户配置文件，末尾才是默认指向 <code>/usr/share/nginx/html</code> 静态路径的配置</li><li>当你使用 ip 访问当前服务器，nginx 会给浏览器发送 <code>/etc/nginx/conf.d</code> 中按 <strong> 字典序 </strong> 排在第一位的 <strong> 用户配置文件 </strong> 中的 ssl 证书（即上图所示证书）</li><li>恶意访问人员可以通过遍历访问所有 IP 地址，当访问你的服务器 IP 地址时，他拿到一个 ssl 证书，其中包括了一个域名 A；</li><li>假设你的域名 A 是按 <code> 域名 A-&gt;CDN-&gt; 服务器 IP</code>来进行解析的，此时恶意访问人员就通过这个 ssl 证书直接得到了 <code> 域名 A-&gt; 服务器 IP</code>的对应关系，完全绕过了 CDN</li><li>此时他就可以通过修改 hosts 强制让 <code> 域名 A</code>指向 <code> 服务器 IP</code>，绕过 CDN 直接攻击你的源站</li></ul><p>套了 CDN 还暴露源站 IP 肯定不是我们想要的结果，所以我们需要解决这个问题！</p><h2 id="解决办法"><a href="# 解决办法" class="headerlink" title="解决办法"></a>解决办法 </h2><p> 在<code>/etc/nginx/conf.d</code>中直接添加一个 <code>a.conf</code>，让其排序在<strong> 字典序的第一位 </strong>，里面写入如下内容，其中<code>server_name _</code> 的含义是除了我们配置过的域名外的其他访问</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">    <span class="attribute">listen</span> <span class="number">80</span> default_server;</span><br><span class="line">    <span class="attribute">server_name</span> _;</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Redirect all HTTP requests to HTTPS.</span></span><br><span class="line">    <span class="attribute">return</span> <span class="number">301</span> https://<span class="variable">$host</span><span class="variable">$request_uri</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">    <span class="attribute">listen</span> <span class="number">443</span> default_server;</span><br><span class="line">    <span class="attribute">server_name</span> _;</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 不用返回 444 了，直接拒绝握手</span></span><br><span class="line">    <span class="attribute">ssl_reject_handshake</span> <span class="literal">on</span>;</span><br><span class="line">    <span class="comment"># return 444;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>配置后直接重启 nginx，没有报错就是 ok 了</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@bt-7274:/etc/nginx/conf.d]# systemctl restart nginx</span><br><span class="line">[root@bt-7274:/etc/nginx/conf.d]# ll</span><br><span class="line">total 28</span><br><span class="line">-rw-r--r-- 1 root root  193 Dec  9 17:52 a.conf</span><br></pre></td></tr></table></figure><p>此时直接访问就会报错 ssl 的 alert 了，但是 edge 中估计是因为 <strong> 缓存的问题</strong>，依旧能看到证书</p><p><img src="https://img.musnow.top/i/2023/12/9c095bed2d740e56c781c10e33212c9d.png" alt="image-20231209175534238"></p><p>换火狐看一下，无法连接，没有证书，目标达成！</p><p><img src="https://img.musnow.top/i/2023/12/20311f168b98f1ebe38157edf25b0c1a.png" alt="image-20231209175736923"></p><p>这里顺带贴一下火狐中一个正常 ssl 网站会显示成什么样子。在锁的按钮里面能看到证书的颁发者是谷歌，而 <strong> 上图中 </strong> 没有看到证书颁发者，即我们的证书并没有泄漏，目的达成。</p><p><img src="https://img.musnow.top/i/2023/12/6b4716321086d0e5ef6978695a52b630.png" alt="image-20231209175834078"></p><p>另外，我试了试我另外一个服务器使用的 1panel 安装的 OpenResty，这个比较好，在默认情况下直接访问 IP 地址返回的是 404，且没有暴露证书。不需要自己额外做配置了。</p>]]></content>
    
    
    <summary type="html">NGINX配置避免IP访问时证书暴露域名</summary>
    
    
    
    <category term="玩上Linux" scheme="https://blog.musnow.top/categories/%E7%8E%A9%E4%B8%8ALinux/"/>
    
    
    <category term="Linux" scheme="https://blog.musnow.top/tags/Linux/"/>
    
    <category term="Nginx" scheme="https://blog.musnow.top/tags/Nginx/"/>
    
  </entry>
  
  <entry>
    <title>【Nginx】nginx 通过配置文件阻止海外 ip 访问</title>
    <link href="https://blog.musnow.top/posts/2029711168/"/>
    <id>https://blog.musnow.top/posts/2029711168/</id>
    <published>2023-12-09T08:12:55.000Z</published>
    <updated>2023-12-09T12:12:55.000Z</updated>
    
    <content type="html"><![CDATA[<p>nginx 通过配置文件阻止海外 ip 访问</p><h1 id="说明"><a href="# 说明" class="headerlink" title="说明"></a>说明 </h1><p> 因为最近发现有不少刷评论的脚本，在 nginx 请求日志里面看了眼，都是海外的 ip，反正我的博客也是全中文。所以干脆把海外 ip 禁止 artalk 评论。</p><p>在 <code>/etc/nginx/nginx.conf</code> 中可以看到默认的日志路径，在里面能找到每一个转发的请求和其源 IP。其中 artak 新增评论的请求是 <code>/api/add</code> 路径</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">access_log  /var/log/nginx/access.log  main;</span><br></pre></td></tr></table></figure><p>考虑到添加海外 ip 屏蔽可能会阻止一些真的在国外的朋友，如果你在阅读本站博客时，遇到相关问题无法直接评论与我交流，可以移步 github 随便找个我的仓库开个 issue 提问！</p><h1 id="解决"><a href="# 解决" class="headerlink" title="解决"></a>解决 </h1><h2 id="APNIC 介绍"><a href="#APNIC 介绍" class="headerlink" title="APNIC 介绍"></a>APNIC 介绍</h2><p> 后文出现的网站是来自<strong>APNIC</strong> (Asia Pacific Network Information Center)，其是 IP 地址管理机构之一，负责亚洲、太平洋地区。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">APNIC 提供了每日更新的亚太地区 IPv4，IPv6，AS 号分配的信息表：</span><br><span class="line">http://ftp.apnic.net/apnic/stats/apnic/delegated-apnic-latest</span><br><span class="line">该文件的格式与具体内容参见：</span><br><span class="line">http://ftp.apnic.net/pub/apnic/stats/apnic/README.TXT</span><br></pre></td></tr></table></figure><h2 id="脚本获取 ip"><a href="# 脚本获取 ip" class="headerlink" title="脚本获取 ip"></a>脚本获取 ip</h2><p>初步解决方法参考：<a href="https://www.cnblogs.com/guoyabin/p/14263732.html">https://www.cnblogs.com/guoyabin/p/14263732.html</a></p><p>原博主提供的脚本如下，可以下载所有海外 ip 列表并生成一个 nginx 配置，写入 <code>/etc/nginx/blackip.conf</code> 中</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="built_in">rm</span> -f legacy-apnic-latest black_`<span class="built_in">date</span> +%F`.conf &amp;&amp; wget http://ftp.apnic.net/apnic/stats/apnic/legacy-apnic-latest</span><br><span class="line"></span><br><span class="line">awk -F <span class="string">&#x27;|&#x27;</span> <span class="string">&#x27;&#123;if(NR&gt;2)printf(&quot;%s %s/%d%s\n&quot;,&quot;deny&quot;,$4,24,&quot;;&quot;)&#125;&#x27;</span> legacy-apnic-latest &gt; black_`<span class="built_in">date</span> +%F`.conf &amp;&amp; \</span><br><span class="line"><span class="built_in">rm</span> -f /etc/nginx/blackip.conf &amp;&amp; \</span><br><span class="line"><span class="built_in">ln</span> -s <span class="variable">$PWD</span>/black_`<span class="built_in">date</span> +%F`.conf /etc/nginx/blackip.conf </span><br></pre></td></tr></table></figure><p>脚本执行后的效果如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@bt-7274:/etc/nginx]# ll</span><br><span class="line">total 88</span><br><span class="line">lrwxrwxrwx 1 root root   34 Dec  9 16:03 blackip.conf -&gt; /root/docker/black_2023-12-09.conf</span><br></pre></td></tr></table></figure><p>文件内容如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[root@bt-7274:/etc/nginx/conf.d]# cat ../blackip.conf</span><br><span class="line">deny 128.134.0.0/24;</span><br><span class="line">deny 128.184.0.0/24;</span><br><span class="line">deny 128.250.0.0/24;</span><br><span class="line">deny 129.60.0.0/24;</span><br><span class="line">deny 129.78.0.0/24;</span><br><span class="line">... 后面的省略了</span><br></pre></td></tr></table></figure><h2 id="nginx 屏蔽海外 ip"><a href="#nginx 屏蔽海外 ip" class="headerlink" title="nginx 屏蔽海外 ip"></a>nginx 屏蔽海外 ip</h2><p>参考原博主的做法，你可以将这个 <code>blackip.conf</code> 在<code>/etc/nginx/nginx.conf</code>中的 <strong>http 模块</strong> 里面 include，这样会阻止当前服务器所有反代的海外的请求。</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">include</span> /etc/nginx/blackip.conf;</span><br></pre></td></tr></table></figure><p>还可以在单个配置文件的<a href="https://zinglix.xyz/2021/10/04/nginx-ssl-reject-handshake/">location 里面引用</a></p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">  <span class="section">location</span> / &#123;</span><br><span class="line">      <span class="attribute">proxy_redirect</span> <span class="literal">off</span>; <span class="comment"># artalk 的 nginx 配置中必须有这个</span></span><br><span class="line">      <span class="attribute">proxy_set_header</span> X-Real-IP <span class="variable">$remote_addr</span>;</span><br><span class="line">      <span class="attribute">proxy_set_header</span> X-Forwarded-For <span class="variable">$proxy_add_x_forwarded_for</span>;</span><br><span class="line">      <span class="attribute">proxy_set_header</span> Host <span class="variable">$host</span>;</span><br><span class="line">      <span class="attribute">proxy_set_header</span> Upgrade-Insecure-Requests <span class="number">1</span>;</span><br><span class="line">      <span class="attribute">proxy_set_header</span> X-Forwarded-Proto https;</span><br><span class="line"></span><br><span class="line">      <span class="attribute">include</span> /etc/nginx/blackip.conf; <span class="comment"># 引用配置</span></span><br><span class="line"></span><br><span class="line">      <span class="attribute">proxy_pass</span> http://127.0.0.1:14722;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>修改后重启 nginx，没有报错就是 ok 了</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl restart nginx</span><br></pre></td></tr></table></figure><p>用海外的服务器试试能不能请求 artalk，用 <a href="https://artk.musnow.top/sidebar/#/login">artk.musnow.top&#x2F;sidebar&#x2F;…</a> 这个管理员登录页面来进行测试。</p><p>国内服务器请求结果如下，和浏览器打开的结果基本是一样（管理员登录界面）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">[root@bt-7274:/etc/nginx/conf.d]# curl https://artk.musnow.top/sidebar/#/login</span><br><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">  &lt;head&gt;</span><br><span class="line">    &lt;meta charset=&quot;UTF-8&quot; /&gt;</span><br><span class="line">    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot; /&gt;</span><br><span class="line">    &lt;title&gt;Artalk Sidebar&lt;/title&gt;</span><br><span class="line">    &lt;script type=&quot;module&quot; crossorigin src=&quot;./assets/index-5a0b3a93.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">    &lt;link rel=&quot;stylesheet&quot; href=&quot;./assets/index-84fdcf98.css&quot;&gt;</span><br><span class="line">  &lt;/head&gt;</span><br><span class="line">  &lt;body&gt;</span><br><span class="line">    &lt;div id=&quot;app&quot;&gt;&lt;/div&gt;</span><br><span class="line">  </span><br><span class="line">  &lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><p>海外服务器请求结果也是上面这样……然后发现是因为我的海外服务器 ip 压根不在那个 black 的 deny 列表里面</p><p>尝试把 ip 的网段给加进去，重启 nginx 再试试。<strong>完美处理</strong>！添加前能正常请求到，添加后就变成 403 了</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">[root@RainYun-8aNbbsmA:~]# curl https://artk.musnow.top/sidebar/#/login</span><br><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">  &lt;head&gt;</span><br><span class="line">    &lt;meta charset=&quot;UTF-8&quot; /&gt;</span><br><span class="line">    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot; /&gt;</span><br><span class="line">    &lt;title&gt;Artalk Sidebar&lt;/title&gt;</span><br><span class="line">    &lt;script type=&quot;module&quot; crossorigin src=&quot;./assets/index-5a0b3a93.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">    &lt;link rel=&quot;stylesheet&quot; href=&quot;./assets/index-84fdcf98.css&quot;&gt;</span><br><span class="line">  &lt;/head&gt;</span><br><span class="line">  &lt;body&gt;</span><br><span class="line">    &lt;div id=&quot;app&quot;&gt;&lt;/div&gt;</span><br><span class="line">    </span><br><span class="line">  &lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br><span class="line">[root@RainYun-8aNbbsmA:~]# </span><br><span class="line">[root@RainYun-8aNbbsmA:~]# curl https://artk.musnow.top/sidebar/#/login</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;&lt;title&gt;403 Forbidden&lt;/title&gt;&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;center&gt;&lt;h1&gt;403 Forbidden&lt;/h1&gt;&lt;/center&gt;</span><br><span class="line">&lt;hr&gt;&lt;center&gt;nginx/1.20.1&lt;/center&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br><span class="line">[root@RainYun-8aNbbsmA:~]# </span><br></pre></td></tr></table></figure><h2 id="nginx 屏蔽非国内 ip"><a href="#nginx 屏蔽非国内 ip" class="headerlink" title="nginx 屏蔽非国内 ip"></a>nginx 屏蔽非国内 ip</h2><p>我前文提到了我的海外服务器的 ip 不在这个 deny 的 ip 列表里面，没有被屏蔽。</p><p>考虑到网上搜不到 <code>legacy-apnic-latest</code> 文件存放的是什么 ip 的信息，我决定换一个思路：allow 国内的 ip，拒绝所有非国内的 ip</p><blockquote><p>获取国内 ip 列表 <a href="https://www.cnblogs.com/sentangle/p/13201770.html">https://www.cnblogs.com/sentangle/p/13201770.html</a></p></blockquote><p>下面这个 url 里面的 ip 地址标明了地区，我们只需要将其提取出来即可</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://ftp.apnic.net/apnic/stats/apnic/delegated-apnic-latest</span><br></pre></td></tr></table></figure><p>这个文件里面的内容结构如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">等级机构 | 获得该 IP 段的国家 / 组织 | 资源类型 | 起始 IP|IP 段长度 | 分配日期 | 分配状态</span><br></pre></td></tr></table></figure><p>我们只需要提取 CN 的所有 IP，然后允许他们，再 <code>deny all</code> 阻止其他 ip 就可以了</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="built_in">rm</span> -f delegated-apnic-latest blackcn_`<span class="built_in">date</span> +%F`.conf &amp;&amp; wget http://ftp.apnic.net/apnic/stats/apnic/delegated-apnic-latest</span><br><span class="line"></span><br><span class="line">awk -F\| <span class="string">&#x27;/CN\|ipv4/ &#123; printf(&quot;%s %s/%d%s\n&quot;,&quot;allow&quot;,$4, 32-log($5)/log(2), &quot;;&quot;) &#125;&#x27;</span> delegated-apnic-latest &gt; blackcn_`<span class="built_in">date</span> +%F`.conf &amp;&amp; \</span><br><span class="line"><span class="built_in">rm</span> -f /etc/nginx/blackcn.conf &amp;&amp; \</span><br><span class="line"><span class="built_in">ln</span> -s <span class="variable">$PWD</span>/blackcn_`<span class="built_in">date</span> +%F`.conf /etc/nginx/blackcn.conf</span><br></pre></td></tr></table></figure><p>执行这个脚本后，会生成 <code>/etc/nginx/blackcn.conf</code> 文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@bt-7274:/etc/nginx]# ll</span><br><span class="line">total 88</span><br><span class="line">lrwxrwxrwx 1 root root   42 Dec  9 16:54 blackcn.conf -&gt; /root/docker/nginx/blackcn_2023-12-09.conf</span><br><span class="line">lrwxrwxrwx 1 root root   40 Dec  9 16:56 blackip.conf -&gt; /root/docker/nginx/black_2023-12-09.conf</span><br></pre></td></tr></table></figure><p>内容如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">allow 223.248.0.0/14;</span><br><span class="line">allow 223.252.128.0/17;</span><br><span class="line">allow 223.254.0.0/16;</span><br><span class="line">allow 223.255.0.0/17;</span><br><span class="line">allow 223.255.236.0/22;</span><br><span class="line">allow 223.255.252.0/23;</span><br><span class="line">....</span><br></pre></td></tr></table></figure><p>还是修改 nginx 单个站点配置文件的 location 中的内容</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">  <span class="section">location</span> / &#123;</span><br><span class="line">      <span class="attribute">proxy_redirect</span> <span class="literal">off</span>;</span><br><span class="line">  <span class="attribute">proxy_set_header</span> X-Real-IP <span class="variable">$remote_addr</span>;</span><br><span class="line">      <span class="attribute">proxy_set_header</span> X-Forwarded-For <span class="variable">$proxy_add_x_forwarded_for</span>;</span><br><span class="line">      <span class="attribute">proxy_set_header</span> Host <span class="variable">$host</span>;</span><br><span class="line">      <span class="attribute">proxy_set_header</span> Upgrade-Insecure-Requests <span class="number">1</span>;</span><br><span class="line">      <span class="attribute">proxy_set_header</span> X-Forwarded-Proto https;</span><br><span class="line"><span class="comment"># 允许所有国内 ip</span></span><br><span class="line">  <span class="attribute">include</span> /etc/nginx/blackcn.conf;</span><br><span class="line">  <span class="attribute">deny</span> all; <span class="comment"># 阻止其他 ip</span></span><br><span class="line"></span><br><span class="line">  <span class="attribute">proxy_pass</span> http://127.0.0.1:14722;</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure><p>先来试试不修改配置文件（不做任何 deny 和 allow 操作的情况下）海外 ip 请求结果</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">[root@RainYun-8aNbbsmA:~]# curl https://artk.musnow.top/sidebar/#/login</span><br><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">  &lt;head&gt;</span><br><span class="line">    &lt;meta charset=&quot;UTF-8&quot; /&gt;</span><br><span class="line">    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot; /&gt;</span><br><span class="line">    &lt;title&gt;Artalk Sidebar&lt;/title&gt;</span><br><span class="line">    &lt;script type=&quot;module&quot; crossorigin src=&quot;./assets/index-5a0b3a93.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">    &lt;link rel=&quot;stylesheet&quot; href=&quot;./assets/index-84fdcf98.css&quot;&gt;</span><br><span class="line">  &lt;/head&gt;</span><br><span class="line">  &lt;body&gt;</span><br><span class="line">    &lt;div id=&quot;app&quot;&gt;&lt;/div&gt;</span><br><span class="line">    </span><br><span class="line">  &lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><p>符合预期，正常请求出了登录页面的 html 文件。</p><p>添加如上修改后，重启 nginx，再次进行测试。这一次已经 403 阻止了，完美！</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[root@RainYun-8aNbbsmA:~]# curl https://artk.musnow.top/sidebar/#/login</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;&lt;title&gt;403 Forbidden&lt;/title&gt;&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;center&gt;&lt;h1&gt;403 Forbidden&lt;/h1&gt;&lt;/center&gt;</span><br><span class="line">&lt;hr&gt;&lt;center&gt;nginx/1.20.1&lt;/center&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><h1 id="The-end"><a href="#The-end" class="headerlink" title="The end"></a>The end</h1><p>你可以写个 crontab 让其定时执行脚本并重启 nginx，我个人还是选择人工处理了（什么时候想起来就去更新一下 ip 列表）</p><p>感谢本文中出现的博客的博主。没有他们的帮助，我无法编写出 shell 脚本。</p>]]></content>
    
    
    <summary type="html">nginx通过配置文件阻止海外ip访问</summary>
    
    
    
    <category term="玩上Linux" scheme="https://blog.musnow.top/categories/%E7%8E%A9%E4%B8%8ALinux/"/>
    
    
    <category term="Linux" scheme="https://blog.musnow.top/tags/Linux/"/>
    
    <category term="Nginx" scheme="https://blog.musnow.top/tags/Nginx/"/>
    
  </entry>
  
  <entry>
    <title>【图床】删除对象存储桶前一定要检查！</title>
    <link href="https://blog.musnow.top/posts/3595872827/"/>
    <id>https://blog.musnow.top/posts/3595872827/</id>
    <published>2023-12-09T02:32:14.000Z</published>
    <updated>2023-12-09T02:32:14.000Z</updated>
    
    <content type="html"><![CDATA[<p>我又干蠢事了！虽然没有很大影响，但是这种问题还是不要发生的好。</p><h2 id="什么情况？"><a href="# 什么情况？" class="headerlink" title="什么情况？"></a>什么情况？</h2><p>我在博客尚有引用某个对象存储 bucket 中图片的情况下，删除了那个 bucket（因为这个 bucket 很久没有用，算是弃用的）</p><p>还好今天看旧笔记的时候，突然发现了这个问题，立马去重新搜索了一下这个旧 bucket 的图片链接，还好还好，受影响的只有两篇文章</p><ul><li>一篇之前导出过 PDF，图片还能找到</li><li>另外一篇文章以文字为主，内部丢失的图片可有可无</li></ul><p>我恢复了第一篇里面的图片，然后修改了第二篇中和图片相关的文字说明，算是解决了这个问题。</p><p>又重写检查了一下笔记目录，算是彻底没有这个被我删除的 bucket 里面的图片了。</p><p>这一次还好，算是没有丢东西，不然数据不备份就删除的笑料又要多一个了……🤣</p><h2 id="以此为戒"><a href="# 以此为戒" class="headerlink" title="以此为戒"></a>以此为戒 </h2><p> 删除 bucket 之前一定要检查自己到底还有没有使用这个 bucket 中的文件或者图片！</p><p>删除图床本地目录前，一定要检查自己还有没有这个本地目录里面的图片！</p><p>最佳方案：不要管那个 bucket，将其访问权限改成 <strong> 私有 </strong> 后，使用备注功能将其标记为弃用。以后不再使用该 bucket 即可。</p><p>因为对于我个人使用来说，一个 bucket 里面不会有太多文件，目前最大的图床 bucket 也不过 2GB 而已，把它留在那里花不了几个钱！不然把 bucket 删了，哪天发现需要去里面找旧文件的时候无从下手就麻烦了！</p><blockquote><p>至于我为什么要删……其实是因为我有点强迫症，不用还留在那里看着有点不爽……</p></blockquote><p>当然还有另外一个解决方案：使用 <code>rclone</code> 等工具，将 s3 中的所有文件下载到本地，打包多地备份后，删除云端 bucket</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;我又干蠢事了！虽然没有很大影响，但是这种问题还是不要发生的好。&lt;/p&gt;
&lt;h2 id=&quot;什么情况？&quot;&gt;&lt;a href=&quot;# 什么情况？&quot; class=&quot;headerlink&quot; title=&quot;什么情况？&quot;&gt;&lt;/a&gt;什么情况？&lt;/h2&gt;&lt;p&gt;我在博客尚有引用某个对象存储 buc</summary>
      
    
    
    
    <category term="差生文具多" scheme="https://blog.musnow.top/categories/%E5%B7%AE%E7%94%9F%E6%96%87%E5%85%B7%E5%A4%9A/"/>
    
    
    <category term="图床" scheme="https://blog.musnow.top/tags/%E5%9B%BE%E5%BA%8A/"/>
    
  </entry>
  
  <entry>
    <title>【博客】hexo 配置 sitemap 和百度 /bing/ 谷歌收录</title>
    <link href="https://blog.musnow.top/posts/3595872826/"/>
    <id>https://blog.musnow.top/posts/3595872826/</id>
    <published>2023-12-08T12:32:14.000Z</published>
    <updated>2023-12-08T12:32:14.000Z</updated>
    
    <content type="html"><![CDATA[<p>最近没事找事，又看了会关于博客主题的东西，之前的 sitemap 一直没有弄上去，现在有时间就弄一下。</p><h1 id="1-hexo 安装 sitemap 插件"><a href="#1-hexo 安装 sitemap 插件" class="headerlink" title="1.hexo 安装 sitemap 插件"></a>1.hexo 安装 sitemap 插件 </h1><p> 在你的 hexo 路径下执行如下命令，安装 sitemap 生成插件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-generator-baidu-sitemap --save</span><br><span class="line">npm install hexo-generator-sitemap --save</span><br></pre></td></tr></table></figure><p>实测在 windows11 的 <code>node v16.20.2</code> 和<code>npm  9.8.1</code>下可以正常安装，但是安装 baidu-sitemap 插件的时候可能会有警告（不影响使用）</p><p>安装完毕插件后，在你的 hexo 配置文件 <code>_config.yml</code> 中添加如下内容，指定站点地图的文件名字即可。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 百度和谷歌的 sitemap</span></span><br><span class="line"><span class="comment"># npm install hexo-generator-baidu-sitemap --save</span></span><br><span class="line"><span class="comment"># npm install hexo-generator-sitemap --save</span></span><br><span class="line"><span class="attr">baidusitemap:</span></span><br><span class="line">    <span class="attr">path:</span> <span class="string">baidusitemap.xml</span></span><br><span class="line"><span class="attr">sitemap:</span></span><br><span class="line">    <span class="attr">path:</span> <span class="string">sitemap.xml</span></span><br></pre></td></tr></table></figure><p>请注意，需要修改的是 hexo 的配置文件，并非主题配置文件！</p><h1 id="2- 如何修改 hexo 主题生成的 index-html 文件？"><a href="#2- 如何修改 hexo 主题生成的 index-html 文件？" class="headerlink" title="2. 如何修改 hexo 主题生成的 index.html 文件？"></a>2. 如何修改 hexo 主题生成的 index.html 文件？</h1><p>一般情况下，站点平台都会让你在 <code>index.html</code> 的<code>&lt;head&gt;</code>里面加一个 html 语句，来验证站点的所有权。比图百度的验证 html 语句如下</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;baidu-site-verification&quot;</span> <span class="attr">content</span>=<span class="string">&quot; 验证码 &quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure><p>部分 hexo 主题可能提供了自定义 <code>&lt;head&gt;</code> 的选项（比如 butterfly 主题就有）</p><p>如果你使用的主题没有提供自定义 <code>&lt;head&gt;</code>，可以尝试在主题文件夹下搜索 index 或者 head 关键字，来找到当前主题使用的<code>index.html</code> 生成源文件</p><blockquote><p>该方法 <strong> 仅</strong>适用于将主题文件直接下载到 <code>themes</code> 文件夹下的情况，因为如果你用的是 npm 安装的主题，那么修改的主题文件是不会对其他地方的部署生效的，下一次更新主题还会覆盖掉。</p></blockquote><p>比如下图是 keep 主题 <code>v3.6.1</code> 版本中的 <code>head.ejs</code>，你只需要把提供的 meta 标签加到这里面，下一次部署的时候的<code>index.html</code> 中就会带上这个标头了。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">themes\keep\layout\_partial\head.ejs</span><br></pre></td></tr></table></figure><p><img src="https://img.musnow.top/i/2023/12/c5c020be0607437acbd2d4364edd839b.png" alt="image-20231208205004240"></p><h1 id="3- 站长平台添加 sitemap"><a href="#3- 站长平台添加 sitemap" class="headerlink" title="3. 站长平台添加 sitemap"></a>3. 站长平台添加 sitemap</h1><h2 id="百度"><a href="# 百度" class="headerlink" title="百度"></a>百度 </h2><p> 百度资源搜索平台 <a href="https://ziyuan.baidu.com/site/index#/">https://ziyuan.baidu.com/site/index#/</a></p><p>百度实在是无语，之前安装了 <code>hexo-baidu-url-submit</code> 插件，主动调用百度 api 给他推送 url，结果弄了已经快一年了，还没有收录我的站点。</p><blockquote><p>实话说，百度不收录站点，网站看的人就很少。百度我自己博客的关键词，结果是一堆被百度收录的爬虫站点用我的文章赚流量。唉……</p></blockquote><p>在资源搜索平台的站点管理中添加你的站点，用第二点提到的方式进行验证</p><p><img src="https://img.musnow.top/i/2023/12/f5049ad4122b226e6621e3f77bbca406.png" alt="image-20231208205611557"></p><p>添加完毕后，在普通收录中可以找到 sitemap 提交的区域。但是不知道为什么我这里的提交配额是 0，搜索了一下也没有找到原因。</p><p><img src="https://img.musnow.top/i/2023/12/f1271309829d10b946af8dc1834d6530.png" alt="image-20231208205652153"></p><p><a href="https://zmingcx.com/baidu-linksubmit-sitemap.html">百度资源平台提交 sitemap 是取消了还是我被限制了？</a></p><p>有人说是站点质量太低被百度屏蔽了，但是这个情况也是很多人都遇到过的。估计是百度策略更新什么的，不允许你添加了吧！</p><p>如果你已经添加了 sitemap，请不要将其删除，免得到时候又没有办法添加了。</p><h2 id="bing"><a href="#bing" class="headerlink" title="bing"></a>bing</h2><p>bing 的站长平台直接搜就行：<a href="https://www.bing.com/webmasters/about?setlang=zh-cn">https://www.bing.com/webmasters/about?setlang=zh-cn</a></p><blockquote><p>国内裸连可能不稳定，需要用点方法。</p><p>不过 bing 即便不提交 sitemap 也咔咔收录了我的博客，主打一个主动 + 来者不拒。</p></blockquote><p>进去之后，用微软账户登录，然后点击新增站点，<strong>输入你博客的域名</strong></p><p><img src="https://img.musnow.top/i/2023/12/46eaebbcbe275e5719c48c0fa212d482.png" alt="image-20231208203803163"></p><p>bing 会让你验证站点所有权，根据下面三种方式的指引，选择一种就行了。如果你不知道如何修改 hexo 的源文件，使用 <strong>CNAME 验证</strong> 方式是最简单的（只要你有域名有权就行了）。</p><p><img src="https://img.musnow.top/i/2023/12/6decdf248d463e8dcf22c1408d1521a8.png" alt="image-20231208204120311"></p><p>不过估计有很多老哥都是白嫖的 github pages 或者 netlify&#x2F;vercel 的 <strong> 二级域名</strong>，在没有域名所有权的情况下，你可以用前两种方式来验证。</p><ul><li>XML 文件方式：将 bing 提供的 XML 文件下载，然后放到你 hexo 源目录的 <strong>source</strong> 文件夹下，就可以了。</li><li>HTML MATE 标记验证：部分 hexo 主题可能提供了自定义 header 的选项（比如 butterfly 主题就有）其他主题可以参考上文第二点操作</li></ul><p>域名验证完毕后，在左侧可以提交网站地图（即 sidemap）</p><p>直接点击按钮提交你的站点地图的 url 就可以了。bing 会自动进行处理，如下图我的第一个 sitemap 已经成功处理出来了 383 个链接，非常完美。</p><p><img src="https://img.musnow.top/i/2023/12/24f236053b3ebece4028124e987e6c65.png" alt="image-20231208204707769"></p><h2 id="谷歌"><a href="# 谷歌" class="headerlink" title="谷歌"></a>谷歌 </h2><p> 实话说，一个纯中文且面向国内读者的站点，在谷歌上面收录了估计也没多大用处，但是可以没用，但不能没有。也给他弄一下吧。</p><p><a href="https://search.google.com/search-console/welcome">https://search.google.com/search-console/welcome</a></p><p>首先是输入站点网址，因为我不需要验证所有站点，只把博客收录了就行，所以这里我选的是网址前缀。输入站点的时候需要把 http 也带上</p><p><img src="https://img.musnow.top/i/2023/12/940d735d204146063e8cb6de8db30326.png" alt="image-20231208210159103"></p><p>谷歌的验证方式也有很多种，这里的操作和 bing 是一样的，把它发给你的文件直接放到 hexo 的 source 路径下就可以了，或者采用 html 标签的方式验证。</p><p><img src="https://img.musnow.top/i/2023/12/6b7aef8d762ec3127bf418fba2257ff7.png" alt="image-20231208210317624"></p><p>验证成功后，选择前往资源界面，即前往当前站点的控制台。</p><p>如果你不小心点了完成，站点资源界面在站长工具的 <strong> 左侧边栏 </strong> 里面，在里面可以找到你已经添加了的站点。</p><p><img src="https://img.musnow.top/i/2023/12/2b62fc8c0f4a83a969894d7a97f13007.png" alt="image-20231208210604314"></p><p>在左侧选择站点地图，点击添加即可</p><p><img src="https://img.musnow.top/i/2023/12/f8159f7211dc0f12fc854ae74476f2f8.png" alt="image-20231208210802621"></p><p><img src="https://img.musnow.top/i/2023/12/d57012975919635230b6bd8f57e9871b.png" alt="image-20231208210849226"></p><h1 id="搞定！"><a href="# 搞定！" class="headerlink" title="搞定！"></a>搞定！</h1><p>有什么问题，欢迎评论区提出！</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;最近没事找事，又看了会关于博客主题的东西，之前的 sitemap 一直没有弄上去，现在有时间就弄一下。&lt;/p&gt;
&lt;h1 id=&quot;1-hexo 安装 sitemap 插件&quot;&gt;&lt;a href=&quot;#1-hexo 安装 sitemap 插件&quot; class=&quot;headerlink&quot; </summary>
      
    
    
    
    <category term="差生文具多" scheme="https://blog.musnow.top/categories/%E5%B7%AE%E7%94%9F%E6%96%87%E5%85%B7%E5%A4%9A/"/>
    
    
    <category term="Hexo" scheme="https://blog.musnow.top/tags/Hexo/"/>
    
  </entry>
  
  <entry>
    <title>【Linux】lcov2.0 安装和 perl 修改镜像源</title>
    <link href="https://blog.musnow.top/posts/1274282021/"/>
    <id>https://blog.musnow.top/posts/1274282021/</id>
    <published>2023-11-26T12:12:55.000Z</published>
    <updated>2023-11-26T12:12:55.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="安装 lcov-2-0"><a href="# 安装 lcov-2-0" class="headerlink" title="安装 lcov 2.0"></a>安装 lcov 2.0</h1><p>你可能不知道 lcov 是什么，简而言之，它是一个代码单元测试覆盖率的显示工具，基于 gcov。</p><ul><li>什么是单元测试覆盖率？</li></ul><p>我们需要对项目中的每个函数编写单元测试，其实就是测试函数的功能。通过 gcc&#x2F;g++ 的相关编译选项，可以得到一个 gcda 文件，内部包含某个 cpp 文件中相关函数被执行了多少次，以及某些 if&#x2F;switch 中的多分支是否覆盖上了；</p><p>lcov 就可以解析这些 gcda 文件，得到如下图所示的函数 <strong> 测试覆盖率 </strong> 的报告</p><p><img src="https://img.musnow.top/i/2023/11/6115958c076400afbfaf6ace5c1e89b9.png" alt="image-20231126201406666"></p><p>包括单元测试在内，这部分对代码函数测试的操作一般被称之为 <code> 功能安全</code>，这里就不多说了。</p><p>lcov 2.0 的安装命令相对来说很简单，就是下面这些</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">wget https://github.com/linux-test-project/lcov/releases/download/v2.0/lcov-2.0.tar.gz</span><br><span class="line">tar -zxvf lcov-2.0.tar.gz</span><br><span class="line"><span class="built_in">cd</span> lcov-2.0</span><br><span class="line">sudo make install</span><br></pre></td></tr></table></figure><h1 id="perl"><a href="#perl" class="headerlink" title="perl"></a>perl</h1><p>使用 lcov 的时候需要 perl，此时就需要修改镜像源。默认的 perl module 的源是在国外的，国内基本上是完全用不了。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># centos8 安装 perl</span></span><br><span class="line">sudo yum install perl</span><br></pre></td></tr></table></figure><p>如果你的 lcov 运行的时候遇到下面类似的错误，那么就是因为 perl 缺少对应 module 导致的，比如如下报错是因为缺少 <code>Capture::Tiny</code> 这个 module；</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Can&#x27;t locate Capture/Tiny.pm in @INC (you may need to install the Capture::Tiny module) (@INC contains: /usr/local/lib/lcov /usr/local/lib64/perl5 /usr/local/share/perl5 /usr/lib64/perl5/vendor_perl /usr/share/perl5/vendor_perl /usr/lib64/perl5 /usr/share/perl5) at /usr/local/lib/lcov/lcovutil.pm line 14.</span><br><span class="line">BEGIN failed--compilation aborted at /usr/local/lib/lcov/lcovutil.pm line 14.</span><br><span class="line">Compilation failed in require at /usr/local/bin/lcov line 102.</span><br><span class="line">BEGIN failed--compilation aborted at /usr/local/bin/lcov line 102.</span><br><span class="line">make: *** [makefile:6: lcov] Error 2</span><br></pre></td></tr></table></figure><h2 id="perl 使用清华源"><a href="#perl 使用清华源" class="headerlink" title="perl 使用清华源"></a>perl 使用清华源 </h2><p> 使用清华源就行了 <a href="https://mirrors.tuna.tsinghua.edu.cn/help/CPAN/">https://mirrors.tuna.tsinghua.edu.cn/help/CPAN/</a></p><p>因为我用的 centos 的系统，安装的 perl 版本很老，<code>v5.26.3</code>，所以这里记录一个手动修改镜像源的办法</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">perl --version</span><br></pre></td></tr></table></figure><p>在 root 用户下执行如下命令，会进入一个 perl 的命令行</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">perl -MCPAN -e shell</span><br></pre></td></tr></table></figure><p>在 perl 的命令行中执行如下命令</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">o conf init</span><br></pre></td></tr></table></figure><p>最终展现的结果应该如下，会自动往当前用户的家目录下创建一个配置文件</p><p><img src="https://img.musnow.top/i/2023/11/fdfb49a8a83aa12789080503070a9a7a.png" alt="image-20231126200126012"></p><p>这里创建的配置文件是在 root 用户下，输入 <code>quit</code> 退出 perl 的命令行后，我们直接 vim 打开这个配置文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim /root/.cpan/CPAN/MyConfig.pm</span><br></pre></td></tr></table></figure><p>在里面找到 urllist 选项，根据已有格式添加一个新的镜像路径就可以了</p><p><img src="https://img.musnow.top/i/2023/11/0f2b4af79a73a2f95bb6f6de6b17560b.png" alt="image-20231126200230352"></p><p>我这里添加后的 urllist 配置项如下，第一项是镜像源就 OK</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#x27;urllist&#x27; =&gt; [q[https://mirrors.tuna.tsinghua.edu.cn/CPAN/], q[http://www.cpan.org/]],</span><br></pre></td></tr></table></figure><p>但是要注意一下，在我这边的网络环境中，清华源在 perl 安装包的时候也容易抽风，我试出来比较稳定的 ip 如下，将其写入 <code>/etc/hosts</code> 文件中，这样安装 perl 包的时候就不会 timeout 了</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">101.6.15.130 mirrors.tuna.tsinghua.edu.cn</span><br></pre></td></tr></table></figure><p>这个 ip 后续可能会有变化啊，请以你的实际情况为准！</p><h2 id="perl 安装 module"><a href="#perl 安装 module" class="headerlink" title="perl 安装 module"></a>perl 安装 module</h2><p>后续安装包的时候，就可以用上镜像源了，安装包的语句如下，请注意这个安装语句最后还有个英文的单引号，一定不要把他删了！</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo perl -MCPAN -e <span class="string">&#x27;install &quot; 包名 &quot;&#x27;</span></span><br></pre></td></tr></table></figure><p>我需要用 perl 是因为要用到 lcov，在 lcov 仓库的 readme 里面提到了 lcov 需要的 perl 包，一个一个安装就行了（以下节选自 <code>lcov2.0</code> 的仓库 README）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">These perl packages include:</span><br><span class="line"></span><br><span class="line">  - Capture::Tiny</span><br><span class="line">  - DateTime</span><br><span class="line">  - Devel::Cover</span><br><span class="line">  - Digest::MD5</span><br><span class="line">  - File::Spec</span><br><span class="line">  - at least one flavor of JSON module.</span><br><span class="line">    In order of performance/preference:</span><br><span class="line">       - JSON::XS</span><br><span class="line">       - Cpanel::JSON::XS</span><br><span class="line">       - JSON::PP</span><br><span class="line">       - JSON</span><br><span class="line"> - Memory::Process</span><br><span class="line"> - Module::Load::Conditional</span><br><span class="line"> - Scalar::Util</span><br><span class="line"> - Time::HiRes</span><br><span class="line"></span><br><span class="line">If your system is missing any of these, then you may be able to install them</span><br><span class="line">via:</span><br><span class="line"></span><br><span class="line">   $ perl -MCPAN -e &#x27;install &quot;packageName&quot;&#x27;</span><br></pre></td></tr></table></figure><p>比如我需要安装 <code>Capture::Tiny</code> 包，就用如下命令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo perl -MCPAN -e <span class="string">&#x27;install &quot;Capture::Tiny&quot;&#x27;</span></span><br></pre></td></tr></table></figure><p>正常安装的命令输出结果如下图所示</p><p><img src="https://img.musnow.top/i/2023/11/566a4438035e393943d353c48b016149.png" alt="image-20231126201023622"></p><h2 id="ubuntu 安装 perl-module"><a href="#ubuntu 安装 perl-module" class="headerlink" title="ubuntu 安装 perl module"></a>ubuntu 安装 perl module</h2><p>如果是 ubuntu，安装 perl 的包会方便一点，因为 apt 源里面是有 perl 的 module</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># ubuntu 22.04 可以直接安装下面的依赖项，就可以使用 lcov 2.0 了</span></span><br><span class="line">sudo apt install -y perl libcapture-tiny-perl libdatetime-perl</span><br></pre></td></tr></table></figure><p>你可以根据 perl 的包名中的 <strong> 关键字 </strong>，尝试在<code>apt list</code> 里面找找有没有对应的包</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt list | grep 包名</span><br></pre></td></tr></table></figure><h1 id="使用 lcov"><a href="# 使用 lcov" class="headerlink" title="使用 lcov"></a>使用 lcov</h1><p>对于 lcov2.0 的命令使用，可以参考我的 linux 仓库中的测试</p><p><a href="https://gitee.com/musnows/raspberry-practice/tree/master/lcov_test">https://gitee.com/musnows/raspberry-practice/tree/master/lcov_test</a></p>]]></content>
    
    
    <summary type="html">lcov2.0安装和perl修改镜像源</summary>
    
    
    
    <category term="玩上Linux" scheme="https://blog.musnow.top/categories/%E7%8E%A9%E4%B8%8ALinux/"/>
    
    
    <category term="Linux" scheme="https://blog.musnow.top/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>【C++】空对象指针也能访问成员函数？</title>
    <link href="https://blog.musnow.top/posts/3858168549/"/>
    <id>https://blog.musnow.top/posts/3858168549/</id>
    <published>2023-11-16T08:40:46.000Z</published>
    <updated>2023-11-16T08:40:46.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1- 起因"><a href="#1- 起因" class="headerlink" title="1. 起因"></a>1. 起因 </h1><p> 今天写代码的时候遇到一个 bug，一个类中的 set 函数在设置一个 POD 类型的时候出现了异常，直接段错误退出了。</p><blockquote><p>小 tips，POD 类型指的是内置类型。</p></blockquote><p>想了好久，都没发现这里的问题到底是因为什么。后来才知道，原来空的对象指针，也能被解引用访问到函数！</p><h1 id="2- 示例"><a href="#2- 示例" class="headerlink" title="2. 示例"></a>2. 示例 </h1><p> 下面是关于这个情况的示例代码</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">mytest</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">mytest</span>() = <span class="keyword">default</span>;</span><br><span class="line">    <span class="built_in">mytest</span>(<span class="type">int</span> a):_a(<span class="number">0</span>)&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">set_int</span><span class="params">(<span class="type">int</span> a)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;set int to &quot;</span> &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">        _a = a;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(<span class="type">int</span> a)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;just a print&quot;</span> &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> _a = <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    mytest* ptr = <span class="literal">nullptr</span>;</span><br><span class="line">    ptr-&gt;<span class="built_in">print</span>(<span class="number">20</span>);</span><br><span class="line">    ptr-&gt;<span class="built_in">set_int</span>(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行这个程序，会出现段错误。但你会发现这个段错误并不是因为我们的 <code>ptr-&gt;</code> 里面出现的，而是成功进入了 set_int 函数，执行了打印，最终对成员变量<code>_a</code> 赋值的时候出现的！</p><p>对象指针为空，代表压根不存在一个实际的对象，也没办法对不存在的成员变量操作。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt; ./test</span><br><span class="line">just a print20</span><br><span class="line">set int to 10</span><br><span class="line">[1]    280362 segmentation fault  ./test</span><br></pre></td></tr></table></figure><p>当代码很多的时候，就会因为忽略这个特性（其实我当时是压根不知道）而误以为错误出现在 set_int 函数中。</p><p>没有想到是外层的对象指针为空导致的。</p><h1 id="3- 为什么？"><a href="#3- 为什么？" class="headerlink" title="3. 为什么？"></a>3. 为什么？</h1><p>在编译过程中，对象就已经绑定了函数地址。一个类的所有对象，使用的函数地址都是一样的。当编译<code>ptr-&gt;set_int(10)</code> 的时候，函数的地址就已经和这个指针绑定了，调用它等价于直接调用 set_int 函数。</p><p>如果这个函数中没有需要用到成员变量的地方，也就不需要解引用 this 指针，是不会出错的。比如上方代码中的 print 函数，就没有出现异常。</p><p>但如果函数内访问了内置成员，那么就会出现解引用空指针导致的段错误！</p>]]></content>
    
    
    <summary type="html">真没想到，空对象指针也能访问成员函数啊？</summary>
    
    
    
    <category term="遇见C++" scheme="https://blog.musnow.top/categories/%E9%81%87%E8%A7%81C/"/>
    
    
    <category term="C++" scheme="https://blog.musnow.top/tags/C/"/>
    
    <category term="数据结构" scheme="https://blog.musnow.top/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>【面经】C++ 面筋记录 (一) 231021</title>
    <link href="https://blog.musnow.top/posts/721187015/"/>
    <id>https://blog.musnow.top/posts/721187015/</id>
    <published>2023-10-21T10:50:14.000Z</published>
    <updated>2023-10-21T10:50:14.000Z</updated>
    
    <content type="html"><![CDATA[<p>记录部分从牛客网上看到的面筋</p><span id="more"></span><h1 id="1- 声明一个 vector，当 vector 过大时会栈溢出吗？"><a href="#1- 声明一个 vector，当 vector 过大时会栈溢出吗？" class="headerlink" title="1. 声明一个 vector，当 vector 过大时会栈溢出吗？"></a>1. 声明一个 vector，当 vector 过大时会栈溢出吗？</h1><p>答案是会。</p><p>默认申请的 vector 是放在栈区的，栈区的大小 &lt;&lt; 堆区的大小。所以如果我们在栈区中开辟的 vector 中插入巨量的数据，是会导致栈溢出的。</p><p>解决办法是将数据存放到堆区上（使用 new 来创建 vector，而不是直接创建）</p><h1 id="2- 如何实现多次运行程序但只有一个后台进程？"><a href="#2- 如何实现多次运行程序但只有一个后台进程？" class="headerlink" title="2. 如何实现多次运行程序但只有一个后台进程？"></a>2. 如何实现多次运行程序但只有一个后台进程？</h1><p>使用命名互斥锁，程序启动前申请锁。</p><ul><li>如果锁没有被申请，代表是第一个进程，可以正常运行</li><li>如果锁已经被占用，代表已经有进程了，直接退出当前进程（这里要使用 try_lock 避免阻塞等待）</li></ul><p>在 Linux 下可以用命名信号量来实现类似进程共享锁的操作。这部分可以去学习进程通信中信号量的部分。</p><p>咨询了发这篇面筋的大佬，说是用文件保存之前进程的 PID，读取出来将之前的进程 kill 掉。</p><h1 id="3- 二分法的前提是什么？"><a href="#3- 二分法的前提是什么？" class="headerlink" title="3. 二分法的前提是什么？"></a>3. 二分法的前提是什么？</h1><ul><li>数据有序</li><li>数据结构支持随机访问</li></ul><h1 id="4- 互斥锁和自旋锁有什么区别"><a href="#4- 互斥锁和自旋锁有什么区别" class="headerlink" title="4. 互斥锁和自旋锁有什么区别"></a>4. 互斥锁和自旋锁有什么区别</h1><ul><li>互斥锁是在内核态进行阻塞等待</li><li>自旋锁是在用户态不断循环沦陷检测锁的状态</li></ul><p>如果使用场景是较长运行的共享资源，那么就使用互斥锁。避免自旋锁不断沦陷检测消耗大量 CPU 资源。</p><p>如果使用场景的共享资源访问速度快，那么可以使用自旋锁。避免互斥锁频繁进行用户、内核态的转换而造成消耗（这里指其他需要获取锁的进程得进入内核态阻塞等待）</p><h1 id="5-TCP 三次握手除了序列号还发了什么其他东西？"><a href="#5-TCP 三次握手除了序列号还发了什么其他东西？" class="headerlink" title="5.TCP 三次握手除了序列号还发了什么其他东西？"></a>5.TCP 三次握手除了序列号还发了什么其他东西？</h1><ul><li>SYN 和 ACK 这些表记位（具体复习三次握手每个阶段的发送）</li><li>双方服务进程的端口号</li><li>起始序列号和对对方发送的 SYN 报文的应答序列号</li><li>TCP 校验和</li><li>TCP 窗口大小</li></ul><p>后续建立连接后，就会根据双方的窗口大小和数据的序列号开始相互通信。</p><h1 id="6- 子类重写父类函数，子类中该函数声明为 private，能否重写成功？"><a href="#6- 子类重写父类函数，子类中该函数声明为 private，能否重写成功？" class="headerlink" title="6. 子类重写父类函数，子类中该函数声明为 private，能否重写成功？"></a>6. 子类重写父类函数，子类中该函数声明为 private，能否重写成功？</h1><p>用下面这个毛坯房来进行测试，在默认情况下，我们子类的重写函数都和父类有相同的作用域声明符。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">test</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">foo1</span>();</span><br><span class="line"><span class="built_in">foo2</span>();</span><br><span class="line"><span class="built_in">foo3</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">foo1</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;A::foo1&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">foo2</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;A::foo2&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">foo3</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;A::foo3&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> : <span class="keyword">public</span> A</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">foo1</span>();</span><br><span class="line"><span class="built_in">foo2</span>();</span><br><span class="line"><span class="built_in">foo3</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">foo1</span><span class="params">()</span> <span class="keyword">override</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;B::foo1&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">foo2</span><span class="params">()</span> <span class="keyword">override</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;B::foo2&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">foo3</span><span class="params">()</span> <span class="keyword">override</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;B::foo3&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">B b;</span><br><span class="line">b.<span class="built_in">test</span>();</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;----&quot;</span> &lt;&lt; endl;</span><br><span class="line">A *bb = &amp;b;</span><br><span class="line">bb-&gt;<span class="built_in">test</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>直接运行，结果也符合预期，目前调用的是子类重写后的虚函数，所有函数都重写成功。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">B::foo1</span><br><span class="line">B::foo2</span><br><span class="line">B::foo3</span><br><span class="line">----</span><br><span class="line">B::foo1</span><br><span class="line">B::foo2</span><br><span class="line">B::foo3</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> : <span class="keyword">public</span> A</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">foo1</span>();</span><br><span class="line"><span class="built_in">foo2</span>();</span><br><span class="line"><span class="built_in">foo3</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">foo2</span><span class="params">()</span> <span class="keyword">override</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;B::foo2&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">foo3</span><span class="params">()</span> <span class="keyword">override</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;B::foo3&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">foo1</span><span class="params">()</span> <span class="keyword">override</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;B::foo1&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 编译能通过，运行输出和上方没区别</span></span><br></pre></td></tr></table></figure><p>我尝试了各种修改作用域的方式，包括将子类中 foo3 函数改成公有，foo1 函数改成私有，都能正常完成重写。这里的作用域声明符只是会改变 <strong> 子类外是否能调用这个函数</strong>，和能否完成虚函数重写无关！</p><p>请注意，如果你将 <strong> 继承方式由 public 改成 private</strong>，那么就无法在类外使用父类指针指向子类对象了</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">╰─ g++ test2.cpp -o test</span><br><span class="line">test2.cpp: In function ‘int main()’:</span><br><span class="line">test2.cpp:316:11: error: ‘A’ is an inaccessible base of ‘B’</span><br><span class="line">  A *bb = &amp;b;</span><br></pre></td></tr></table></figure><p>但这依旧不影响子类函数重写父类函数（我的依据是 override 关键字没有报错）</p><h1 id="7-pthread-create 能传入类成员函数的指针吗"><a href="#7-pthread-create 能传入类成员函数的指针吗" class="headerlink" title="7.pthread_create 能传入类成员函数的指针吗"></a>7.pthread_create 能传入类成员函数的指针吗 </h1><p> 可以，但是必须是静态成员函数。</p><p>如果是普通成员函数，那就需要用中间函数来处理，比如下面的示例代码。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span>* <span class="title">threadFunc</span><span class="params">(<span class="type">void</span>* arg)</span> </span>&#123;</span><br><span class="line">    std::function&lt;<span class="type">void</span>()&gt; func = *<span class="keyword">reinterpret_cast</span>&lt;std::function&lt;<span class="built_in">void</span>()&gt;*&gt;(arg);</span><br><span class="line">    <span class="built_in">func</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::function&lt;<span class="type">void</span>()&gt; myFunc = []() &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Hello from thread!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="type">pthread_t</span> thread;</span><br><span class="line">    <span class="built_in">pthread_create</span>(&amp;thread, <span class="literal">nullptr</span>, &amp;threadFunc, <span class="built_in">reinterpret_cast</span>&lt;<span class="type">void</span>*&gt;(&amp;myFunc));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 等待线程结束</span></span><br><span class="line">    <span class="built_in">pthread_join</span>(thread, <span class="literal">nullptr</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们可以用 <code>std::function</code> 包装一个类的成员函数，并用 <code>std::bind</code> 将对象的 this 指针绑定到第一个参数上。外层再套上一个用于执行该函数的 void 函数，就能传给<code>pthread_create</code>。</p><p><code>std::function</code>的对象不能直接传给 C 语言的函数指针，即便参数对应。会报错。</p><h1 id="8- 函数内 static 变量的作用"><a href="#8- 函数内 static 变量的作用" class="headerlink" title="8. 函数内 static 变量的作用"></a>8. 函数内 static 变量的作用 </h1><p> 在函数内定义一个 static 变量，该变量只会在进入这个函数的时候初始化一次。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 计算某一月的 1 号是一年的第几天(不考虑闰年)</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">DayOfYear</span><span class="params">(<span class="type">int</span> month)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> day_array = &#123;<span class="number">0</span>,<span class="number">31</span>,<span class="number">59</span>,<span class="number">90</span>,<span class="number">120</span>,<span class="number">151</span>,<span class="number">181</span>,<span class="number">212</span>,<span class="number">243</span>,<span class="number">273</span>,<span class="number">304</span>,<span class="number">334</span>&#125;;</span><br><span class="line">    <span class="keyword">return</span> day_array[month];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>比如上面的函数，我们定义的 day 数组就只会在第一次进入这个函数的时候初始化。之后进入这个函数将不在初始化，就节省了初始化一个数组的消耗。出了这个函数后，该数组变量依旧存在。</p><p>请注意，这个 static 语句并不只是变量只初始化一次，实际上这一行语句在该函数中都只会进行一次</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="title function_">checkFlag</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">static</span> <span class="type">bool</span> flag = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span>(!flag)&#123;</span><br><span class="line">        <span class="comment">// .. 进行对应修改</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>比如上面的代码中，如果用正常思维来理解，你会觉得这个 if 语句每次都会判断为真而进入其中。但实际上 flag 的定义只会被定义一次，<strong>只要我们在 if 中将其改成了 true</strong>，那么下一次进入该函数的时候，<strong>flag 依旧会是 true</strong>，<code>static bool flag = false;</code>语句会被直接跳过，并不会再次执行赋值！</p><p>我之前理解的就是 flag 变量只会被创建一次，但 static 后的赋值依旧会执行。这个理解是 <strong> 错误 </strong> 的！</p>]]></content>
    
    
    <summary type="html">C++面筋记录 (一) 231021</summary>
    
    
    
    <category term="求职路上一去不复返" scheme="https://blog.musnow.top/categories/%E6%B1%82%E8%81%8C%E8%B7%AF%E4%B8%8A%E4%B8%80%E5%8E%BB%E4%B8%8D%E5%A4%8D%E8%BF%94/"/>
    
    
    <category term="面经" scheme="https://blog.musnow.top/tags/%E9%9D%A2%E7%BB%8F/"/>
    
  </entry>
  
  <entry>
    <title>【Linux】wsl 安装的 ubuntu 不支持 POSIX 消息队列 | 已解决</title>
    <link href="https://blog.musnow.top/posts/4006913293/"/>
    <id>https://blog.musnow.top/posts/4006913293/</id>
    <published>2023-10-17T04:30:55.000Z</published>
    <updated>2023-10-17T04:30:55.000Z</updated>
    
    <content type="html"><![CDATA[<p>wsl 安装的 ubuntu 不支持 POSIX 消息队列的解决办法</p><span id="more"></span><h1 id="问题"><a href="# 问题" class="headerlink" title="问题"></a>问题</h1><p><img src="https://img.musnow.top/i/2023/10/f317c38d511b44a48ff5dc5df48b1c80.png"></p><p>如题，我的 win10 上安装了 wsl 的 ubuntu 后（微软商店下载的 wsl 的 Ubuntu）这个系统内部不支持 POSIX 的消息队列，虽然有 <code>&lt;mqueue.h&gt;</code> 头文件，但是没有实现，会报错。</p><p>如果想找个简单的办法呢，那就是用 systemV 的消息队列，可这是个 <strong> 虚拟机本地环境问题</strong>，我用 virtualbox 安装的虚拟机就能正常使用。所以肯定得解决这个问题，换成 systemV 的消息队列就有点「掩耳盗铃」的意味了。</p><h1 id="测试"><a href="# 测试" class="headerlink" title="测试"></a>测试 </h1><p> 下面是一个 POSIX 消息队列的 demo</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mqueue.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">mqd_t</span> mqID;</span><br><span class="line">    mqID = <span class="built_in">mq_open</span>(<span class="string">&quot;/testmQueue&quot;</span>, O_RDWR | O_CREAT, <span class="number">0666</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (mqID &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;open message queue error...&quot;</span>&lt;&lt;<span class="built_in">strerror</span>(errno)&lt;&lt;endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mq_attr mqAttr;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">mq_getattr</span>(mqID, &amp;mqAttr) &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;get the message queue attribute error&quot;</span>&lt;&lt;endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;mq_flags:&quot;</span>&lt;&lt;mqAttr.mq_flags&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;mq_maxmsg:&quot;</span>&lt;&lt;mqAttr.mq_maxmsg&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;mq_msgsize:&quot;</span>&lt;&lt;mqAttr.mq_msgsize&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;mq_curmsgs:&quot;</span>&lt;&lt;mqAttr.mq_curmsgs&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果编译后运行出现了下面的报错，代表当前系统不支持 POSIX 消息队列。当前系统下有 mqueue 头文件，但并没有函数的实现体</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">root@DESKTOP-5SQO6N0:~# ./test</span><br><span class="line">open message queue error...No such file or directory</span><br><span class="line">open message queue error...Function not implemented</span><br></pre></td></tr></table></figure><h1 id="解决"><a href="# 解决" class="headerlink" title="解决"></a>解决 </h1><p> 需要将 wsl 版本 1 改成版本 2，否则无完整 Linux 内核支持，无法使用 POSIX 消息队列。<strong>这也是 WSL 版本 1 和 2 的重大区别之一</strong>。</p><p>用如下命令将当前虚拟机改成 wsl2 版本，就可以使用了。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">wsl -l -v # 用这个命令查看当前虚拟机的 version 是不是 1</span><br><span class="line">wsl --update # 更新 wsl</span><br><span class="line">wsl --set-version 虚拟机名 2  # 把指定虚拟机改成 wsl 版本 2</span><br></pre></td></tr></table></figure><h2 id="再次测试"><a href="# 再次测试" class="headerlink" title="再次测试"></a>再次测试 </h2><p> 正常情况下，上面的消息队列代码应该输出如下内容</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">root@DESKTOP-5SQO6N0:~# ./test</span><br><span class="line">mq_flags:0</span><br><span class="line">mq_maxmsg:10</span><br><span class="line">mq_msgsize:8192</span><br><span class="line">mq_curmsgs:0</span><br></pre></td></tr></table></figure><h2 id="绑定目录"><a href="# 绑定目录" class="headerlink" title="绑定目录"></a>绑定目录 </h2><p> 除了上面这个问题，在使用消息队列之前还可以 monut 一下路径，参考 man 手册中的教程（似乎不是必须要做的，mount 了这个路径之后能更好地看到现有的消息队列）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mkdir /dev/mqueue</span><br><span class="line">mount -t mqueue none /dev/mqueue</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">wsl安装的ubuntu不支持POSIX消息队列的解决办法</summary>
    
    
    
    <category term="玩上Linux" scheme="https://blog.musnow.top/categories/%E7%8E%A9%E4%B8%8ALinux/"/>
    
    
    <category term="Linux" scheme="https://blog.musnow.top/tags/Linux/"/>
    
    <category term="虚拟机" scheme="https://blog.musnow.top/tags/%E8%99%9A%E6%8B%9F%E6%9C%BA/"/>
    
  </entry>
  
  <entry>
    <title>【微机】DOSBox 在 windows 上的安装和 masm 的配置</title>
    <link href="https://blog.musnow.top/posts/2839269095/"/>
    <id>https://blog.musnow.top/posts/2839269095/</id>
    <published>2023-10-16T17:49:13.000Z</published>
    <updated>2023-10-16T17:49:13.000Z</updated>
    
    <content type="html"><![CDATA[<p>最近学校学习微型计算机原理与接口技术，需要用到 DOSBox 来模拟 DOS 环境进行汇编编程的学习。</p><p>本文记录了如何在 windows11&#x2F;10 上安装 <code>DOSBox0.74</code> 并配置<code>masm5</code></p><h1 id="1- 安装"><a href="#1- 安装" class="headerlink" title="1. 安装"></a>1. 安装 </h1><p> 这两个软件我打包上传到了百度云盘。放心，加起来也就 2mb，下载应该不会很久</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">链接: https://pan.baidu.com/s/1vjbSL7iwP8WpMVA9K505ZA</span><br><span class="line">提取码: kr4x</span><br></pre></td></tr></table></figure><h2 id="1-1-DOSBox"><a href="#1-1-DOSBox" class="headerlink" title="1.1 DOSBox"></a>1.1 DOSBox</h2><p>点击 <code>DOSBox0.74</code> 的安装包，无脑下一步安装即可</p><p><img src="https://img.musnow.top/i/2023/10/4ef1475a8016a019d58a90bd6845e70d.png" alt="image-20231017015458406"></p><p>安装出来的图标如下</p><p><img src="https://img.musnow.top/i/2023/10/cc5f29112bed916bb978c49a9a23636d.png" alt="image-20231017015529621"></p><h2 id="1-2-masm5"><a href="#1-2-masm5" class="headerlink" title="1.2 masm5"></a>1.2 masm5</h2><p>找一个空的文件夹，文件路径中不能包含空格、特殊字符和中文，将 <code>masm5.zip</code> 中的文件全部解压到这个文件夹中，如下图</p><p><img src="https://img.musnow.top/i/2023/10/21d3adc3a7e767d3aa3d0eba69df75e9.png" alt="image-20231017015700958"></p><p>随后修改 DOSBox 软件的配置文件，右键桌面上 Dosbox 软件的快捷图标，选择 <code> 打开文件所在位置 </code> 找到 DOSBox 软件的安装路径，点击 <code>DOSBox 0.74 Options.bat</code> 文件，稍等片刻，会以记事本的方式打开配置文件。</p><p><img src="https://img.musnow.top/i/2023/10/06f84cbaea8c2c0380807a61e01f1a7d.png" alt="image-20231017015801923"></p><p>拉到配置文件最底下，新增如下配置。你只需要修改 <code>D:\GAME\masm</code> 为你的 masm5 文件的解压目录就行了。这个文件路径中不能有空格，也不能有特殊字符和中文！</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">MOUNT C D:\GAME\masm</span><br><span class="line">path=%path%; \masm</span><br><span class="line">C: </span><br><span class="line">cd \asm</span><br></pre></td></tr></table></figure><p>配置完成后，启动 DOSbox，查看 masm 命令是否能正常使用。如图所示，没有报错 masm 命令不存在，那么就是配置好了。</p><p><img src="https://img.musnow.top/i/2023/10/62cba64fa60c2fd957b5968d4387109b.png" alt="image-20231017020002774"></p><h1 id="2- 修改 DOSBox 窗口大小"><a href="#2- 修改 DOSBox 窗口大小" class="headerlink" title="2. 修改 DOSBox 窗口大小"></a>2. 修改 DOSBox 窗口大小 </h1><p> 默认情况下 DOSBox 的命令行窗口是非常非常非常小的，我们需要将其改大。同样是修改 DOSBox 的配置文件，如何打开配置文件参考上文。</p><p>按下图所示修改</p><p><img src="https://img.musnow.top/i/2023/10/2b5bab3f2fc1dbb0a766659d1eb51130.png" alt="image-20231017020347782"></p><p>请注意，这里的 1280 和 1080 中间的是大写的 X，并不是乘号</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">windowresolution=1280X1080</span><br><span class="line">output=opengl</span><br></pre></td></tr></table></figure><p>修改了之后保存，再重新打开 DOSBox，界面就应该会变大了。如果你觉得还是小了，可以修改这里的分辨率，继续让他变大一点。</p><h1 id="3- 编译一个汇编程序"><a href="#3- 编译一个汇编程序" class="headerlink" title="3. 编译一个汇编程序"></a>3. 编译一个汇编程序 </h1><p> 用下面最简单的汇编程序做测试，将如下内容写入到 <code>test.asm</code> 中，并放入和 masm 的同一目录下（必须要是同一目录）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">CODE SEGMENT ;USE16</span><br><span class="line">     ASSUME CS:CODE</span><br><span class="line">BEG: MOV DL,&#x27;H&#x27;</span><br><span class="line">     MOV AH, 2 ; 调用 2 号 DOS 系统调用输出字符到屏幕上</span><br><span class="line">     INT 21H</span><br><span class="line">     MOV AH, 4CH</span><br><span class="line">     INT 21H</span><br><span class="line">CODE  ENDS</span><br><span class="line">        END BEG</span><br></pre></td></tr></table></figure><p>打开 DOSBox，输入如下命令</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">masm test.asm</span><br><span class="line">link test.obj</span><br></pre></td></tr></table></figure><p>输出如下图所示，第一个命令的作用是编译源文件（注意看有没有编译报错）；第二个命令的作用是链接 obj 文件，最终会弹出来一个警告，不用管他。</p><p><img src="https://img.musnow.top/i/2023/10/60d8190bb6bda5b544018ce777909c0f.png" alt="image-20231017020903839"></p><p>最终执行 test，成功输出字符 H 到终端上。</p><p><img src="https://img.musnow.top/i/2023/10/8cace87b33fc71a4387afa5d7765e8a4.png" alt="image-20231017020946832"></p><p>能走到这一步，就代表你的 masm 基本环境已经配置好了。可以用来编译运行汇编代码了</p>]]></content>
    
    
    <summary type="html">DOSBox在windows上的安装和masm的配置</summary>
    
    
    
    <category term="差生文具多" scheme="https://blog.musnow.top/categories/%E5%B7%AE%E7%94%9F%E6%96%87%E5%85%B7%E5%A4%9A/"/>
    
    
    <category term="win" scheme="https://blog.musnow.top/tags/win/"/>
    
  </entry>
  
  <entry>
    <title>【Linux】ubuntu/centos8 安装 zsh 终端</title>
    <link href="https://blog.musnow.top/posts/2565866661/"/>
    <id>https://blog.musnow.top/posts/2565866661/</id>
    <published>2023-10-15T09:12:55.000Z</published>
    <updated>2023-10-15T09:12:55.000Z</updated>
    
    <content type="html"><![CDATA[<p>根据这篇知乎文章进行 <a href="https://zhuanlan.zhihu.com/p/514636147">https://zhuanlan.zhihu.com/p/514636147</a></p><h1 id="1- 安装 zsh"><a href="#1- 安装 zsh" class="headerlink" title="1. 安装 zsh"></a>1. 安装 zsh</h1><p>先安装 zsh 并设置为默认的终端</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># ubuntu</span></span><br><span class="line">sudo apt install zsh</span><br><span class="line"><span class="comment"># centos </span></span><br><span class="line">sudo yum install zsh util-linux-user</span><br><span class="line"><span class="comment"># 通用</span></span><br><span class="line">chsh -s /bin/zsh</span><br></pre></td></tr></table></figure><blockquote><p>如果 centos 下找不到 chsh 命令，参考此博客：<a href="https://blog.csdn.net/FungLeo/article/details/99448425">https://blog.csdn.net/FungLeo/article/details/99448425</a></p></blockquote><p>然后安装 oh-my-zsh，这是一个大佬在 github 上开源的一个 zsh 配置项，相对方便点</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget --no-check-certificate https://github.com/robbyrussell/oh-my-zsh/raw/master/tools/install.sh -O - | sh </span><br></pre></td></tr></table></figure><p>如果 github 连不上就用 gitee，如果你用的是子用户，那么 <strong> 这个命令不要用 sudo 权限执行</strong>！否则后续子用户会因为权限问题没办法使用。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sh -c <span class="string">&quot;<span class="subst">$(curl -fsSL https://gitee.com/shmhlsy/oh-my-zsh-install.sh/raw/master/install.sh)</span>&quot;</span></span><br></pre></td></tr></table></figure><p>最终出现如图所示的界面就是安装成功了。</p><p><img src="https://img.musnow.top/i/2023/10/5ebc935468a46d95ac77e65dc879c66d.png" alt="image-20231015205326739"></p><h1 id="2- 安装 zsh 插件"><a href="#2- 安装 zsh 插件" class="headerlink" title="2. 安装 zsh 插件"></a>2. 安装 zsh 插件 </h1><p> 安装这两个最常用的插件就可以了</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># zsh-autosuggestions 命令行命令键入时的历史命令建议</span></span><br><span class="line">git <span class="built_in">clone</span> https://github.com/zsh-users/zsh-autosuggestions <span class="variable">$&#123;ZSH_CUSTOM:-~/.oh-my-zsh/custom&#125;</span>/plugins/zsh-autosuggestions</span><br><span class="line"><span class="comment"># zsh-syntax-highlighting 命令行语法高亮插件</span></span><br><span class="line">git <span class="built_in">clone</span> https://gitee.com/Annihilater/zsh-syntax-highlighting.git <span class="variable">$&#123;ZSH_CUSTOM:-~/.oh-my-zsh/custom&#125;</span>/plugins/zsh-syntax-highlighting</span><br></pre></td></tr></table></figure><p>这个历史命令建议的插件是用方向键👉来进行补全的，不要和我一样傻乎乎按 tab。</p><h1 id="3- 配置文件和主题"><a href="#3- 配置文件和主题" class="headerlink" title="3. 配置文件和主题"></a>3. 配置文件和主题 </h1><p> 原文中的配置文件有很多地方都不对劲，需要我们修改；</p><p>首先是 <code>oh-my-zsh</code> 的安装路径，需要改成你的用户家目录下，然后需要先安装一下 <code>powerlevel10k</code> 主题，这个主题很好用！</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> --depth=1 https://gitee.com/romkatv/powerlevel10k.git <span class="variable">$&#123;ZSH_CUSTOM:-<span class="variable">$HOME</span>/.oh-my-zsh/custom&#125;</span>/themes/powerlevel10k</span><br></pre></td></tr></table></figure><p>配置文件 <code>~/.zshrc</code> 改成如下内容（建议将原本的配置文件 cp 备份一下）其中的 zsh 安装路径一定要修改，否则无法正常配置！</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 防止中文乱码</span></span><br><span class="line"><span class="built_in">export</span> LC_ALL=en_US.UTF-8</span><br><span class="line"><span class="built_in">export</span> LANG=en_US.UTF-8</span><br><span class="line"><span class="comment"># oh-my-zsh 的安装路径（zsh 的配置路径）</span></span><br><span class="line">ZSH=<span class="string">&quot;/home/ 你的用户名 /.oh-my-zsh&quot;</span></span><br><span class="line"><span class="comment"># ZSH_THEME=&quot;robbyrussell&quot;</span></span><br><span class="line"><span class="comment"># 设置字体模式以及配置命令行的主题</span></span><br><span class="line">POWERLEVEL9K_MODE=<span class="string">&#x27;nerdfont-complete&#x27;</span></span><br><span class="line"><span class="comment"># ZSH_THEME=&quot;agnoster&quot;</span></span><br><span class="line">ZSH_THEME=<span class="string">&quot;powerlevel10k/powerlevel10k&quot;</span> <span class="comment"># 主题推荐这个，需要进行安装</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 启动错误命令自动更正</span></span><br><span class="line">ENABLE_CORRECTION=<span class="string">&quot;true&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 在命令执行的过程中，使用小红点进行提示</span></span><br><span class="line">COMPLETION_WAITING_DOTS=<span class="string">&quot;true&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 配置要使用的插件</span></span><br><span class="line">plugins=(</span><br><span class="line">        git</span><br><span class="line">        extract</span><br><span class="line">        zsh-autosuggestions</span><br><span class="line">        zsh-syntax-highlighting</span><br><span class="line">)</span><br><span class="line"><span class="built_in">source</span> <span class="variable">$ZSH</span>/oh-my-zsh.sh</span><br><span class="line"><span class="built_in">source</span> <span class="variable">$ZSH_CUSTOM</span>/plugins/zsh-autosuggestions/zsh-autosuggestions.zsh</span><br><span class="line"><span class="comment"># python 虚拟环境相关设置</span></span><br><span class="line"><span class="keyword">if</span> [-f /usr/local/bin/virtualenvwrapper.sh];</span><br><span class="line"><span class="keyword">then</span></span><br><span class="line">    <span class="built_in">export</span> WORKON_HOME=<span class="variable">$HOME</span>/.virtualenvs</span><br><span class="line">    <span class="built_in">export</span> VIRTUALENVWRAPPER_PYTHON=/usr/bin/python3</span><br><span class="line">    <span class="built_in">source</span> /usr/local/bin/virtualenvwrapper.sh</span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure><p>改好了之后，启用他，然后就可以了；执行下方命令后，就会自动弹出 <code>powerlevel10k</code> 主题的配置引导过程。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">source ~/.zshrc</span><br></pre></td></tr></table></figure><p><img src="https://img.musnow.top/i/2023/10/684bc428ce3e1369d8d60997845180a8.png" alt="image-20231015205703586"></p><p>如果设置完毕后，你对 <code>powerlevel10k/powerlevel10k</code> 的配置又不满意了，可以执行如下命令重新配置</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">p10k configure</span><br></pre></td></tr></table></figure><p>你可能也会遇到如下报错，原因未知，但似乎不影响使用</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">❯ ls</span><br><span class="line">_p9k_worker_stop:zle:4: No handler installed for fd 12</span><br><span class="line">_p9k_worker_stop:5: failed to close file descriptor 12: bad file descriptor</span><br></pre></td></tr></table></figure><p>如上报错解决办法参考 github 的 issue 内的说明</p><p><a href="https://github.com/romkatv/powerlevel10k/issues/1554">https://github.com/romkatv/powerlevel10k/issues/1554</a></p><p>在配置文件 <code>.zshrc</code> 的末尾加上下面这一行，然后 source 让其生效就可以了</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">unset ZSH_AUTOSUGGEST_USE_ASYNC</span><br></pre></td></tr></table></figure><h1 id="4- 使用小技巧"><a href="#4- 使用小技巧" class="headerlink" title="4. 使用小技巧"></a>4. 使用小技巧 </h1><p> 输入命令的时候键入 tab，会弹出一些命令的提示</p><p><img src="https://img.musnow.top/i/2023/10/486730657def543552dc7a82163410e9.png" alt="image-20231015210623737"></p><p>输入之前写过的命令的时候，会出现历史命令提示，使用方向键右👉就可以补全这个命令</p><p><img src="https://img.musnow.top/i/2023/10/eb1e448943c27dd0bdeb29267b26d252.png" alt="image-20231015210708230"></p><p>zsh 主要就是这一点非常的方便，至于会不会和默认的 <code>/bin/bash</code> 有性能差异，那就不知道了。</p><p>另外，在 zsh 终端中直接重定向会卡住，如下命令就会阻塞掉。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt; 文本文件</span><br></pre></td></tr></table></figure><p>所以要用 echo（一般我是用来清空某个文本文件）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo &gt; 文本文件</span><br></pre></td></tr></table></figure><h1 id="5-zsh 安装后 git 中文乱码"><a href="#5-zsh 安装后 git 中文乱码" class="headerlink" title="5.zsh 安装后 git 中文乱码"></a>5.zsh 安装后 git 中文乱码 </h1><p> 安装 zsh 后用 <code>git log</code> 查看提交信息的时候发现中文乱码。</p><h2 id="5-1- 修改 zsh 配置文件"><a href="#5-1- 修改 zsh 配置文件" class="headerlink" title="5.1 修改 zsh 配置文件"></a>5.1 修改 zsh 配置文件 </h2><p> 其实上文中提到的配置文件里面已经有这两个配置项了，说明问题不在这里</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># 防止中文乱码</span><br><span class="line">export LC_ALL=en_US.UTF-8</span><br><span class="line">export LANG=en_US.UTF-8</span><br></pre></td></tr></table></figure><h2 id="5-2- 执行 git 配置"><a href="#5-2- 执行 git 配置" class="headerlink" title="5.2 执行 git 配置"></a>5.2 执行 git 配置 </h2><p> 一篇博客说要执行下面的 git 命令，也没有用</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">git config --global core.quotepath false </span><br><span class="line">git config --global gui.encoding utf-8 </span><br><span class="line">git config --global i18n.commit.encoding utf-8 </span><br><span class="line">git config --global i18n.logoutputencoding utf-8 </span><br><span class="line">set LESSCHARSET=utf-8</span><br></pre></td></tr></table></figure><h2 id="5-3- 修改系统字符配置"><a href="#5-3- 修改系统字符配置" class="headerlink" title="5.3 修改系统字符配置"></a>5.3 修改系统字符配置 </h2><p> 另外一篇博客说要修改系统的字符集配置，如下环境变量</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">export LESSCHARSET=utf-8</span><br></pre></td></tr></table></figure><p>执行后确实 ok 了，可以编辑 <code>/etc/profile</code> 文件，在该文件末尾追加如下内容让其始终生效</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">export LESSCHARSET=utf-8</span><br></pre></td></tr></table></figure><p>随后用 source 命令刷新这个配置文件即可。</p><h1 id="6- 粘贴文本很慢的问题"><a href="#6- 粘贴文本很慢的问题" class="headerlink" title="6. 粘贴文本很慢的问题"></a>6. 粘贴文本很慢的问题 </h1><p> 参考 <a href="https://github.com/zsh-users/zsh-autosuggestions/issues/238">zsh-users&#x2F;zsh-autosuggestions&#x2F;issues&#x2F;238</a> 解决这个问题</p><p>在 <code>.zshrc</code> 之后添加如下配置项</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"># This speeds up pasting w/ autosuggest</span><br><span class="line"># https://github.com/zsh-users/zsh-autosuggestions/issues/238</span><br><span class="line">pasteinit() &#123;</span><br><span class="line">  OLD_SELF_INSERT=$&#123;$&#123;(s.:.)widgets[self-insert]&#125;[2,3]&#125;</span><br><span class="line">  zle -N self-insert url-quote-magic # I wonder if you&#x27;d need `.url-quote-magic`?</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">pastefinish() &#123;</span><br><span class="line">  zle -N self-insert $OLD_SELF_INSERT</span><br><span class="line">&#125;</span><br><span class="line">zstyle :bracketed-paste-magic paste-init pasteinit</span><br><span class="line">zstyle :bracketed-paste-magic paste-finish pastefinish</span><br></pre></td></tr></table></figure><p>配置了之后，source 使其生效。</p><p>这时候在终端里面粘贴内容的时候，就不会一个一个字符地打印出来了。那样实在是太慢了。</p>]]></content>
    
    
    <summary type="html">ubuntu/centos8虚拟机安装zsh终端</summary>
    
    
    
    <category term="玩上Linux" scheme="https://blog.musnow.top/categories/%E7%8E%A9%E4%B8%8ALinux/"/>
    
    
    <category term="Linux" scheme="https://blog.musnow.top/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>【虚拟机】WIN11 的 WSL 安装 CentOS8Stream 虚拟机</title>
    <link href="https://blog.musnow.top/posts/4065446782/"/>
    <id>https://blog.musnow.top/posts/4065446782/</id>
    <published>2023-10-15T03:30:55.000Z</published>
    <updated>2023-10-15T03:30:55.000Z</updated>
    
    <content type="html"><![CDATA[<p>本人所使用的系统是 <code>win11 22H2 家庭版</code>，如果你不是非 CentOS 不可，强烈建议直接去微软应用商店里面下载 Ubuntu，全自动安装到 WSL，啥都不用管。(就是好像没办法选择安装路径)</p><h1 id="1- 启用 WSL"><a href="#1- 启用 WSL" class="headerlink" title="1. 启用 WSL"></a>1. 启用 WSL</h1><p>刚开始安装 WSL 的时候，参考的是 <a href="https://blog.csdn.net/qq_38442140/article/details/120724215"> 这个博客</a>。说实话，我个人并不喜欢这篇博客。因为里面遗漏了很多东西，并且在不恰当的位置贴出了命令，导致读者会误以为是需要执行这些命令。</p><p>比如我就理解错误，先执行了设置 wsl 默认版本为 2 的命令，<strong>这个命令先不要执行</strong>！后文会告诉你为什么。</p><p>这篇博客中对开启 wsl 的设置的位置描述也不完全，看上去像从网上哪里抄过来的 win10 的设置逻辑（win11 的位置完全不一样）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">该博客原文：在 windows 设置中打开【启用或关闭 Windwos 功能】，勾选【适用于 Linux 的 Windwos 子系统】，点击确定后会系统会提示重启，选择确认即可</span><br></pre></td></tr></table></figure><p>实际上在 win11 中，需要多点好几个地方才能找到这个设置的位置</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">右键桌面 - 个性化 - 进入 win11 设置界面 - 应用 - 可选功能 - (往下滑)更多 windows 功能</span><br></pre></td></tr></table></figure><p><img src="https://img.musnow.top/i/2023/10/542d2e77f4272f4598629626e44ee2a7.png" alt="image-20231015104701566"></p><blockquote><p>这都是我对一个 <strong> 不完善博客 </strong> 的吐槽，但并没有贬低这个教程的意思啊！至少他告诉我基本步骤应该做哪些。</p><p>为什么我要吐槽呢？因为这种写的不全的博客经常会让读者得去重新搜索某些设置的位置，而作者明明是已经走过这个流程的。博客里面作者的截图明显是 windows11，但他提供的设置却是 win10 中的旧位置。多花 30 秒写清楚位置并带上截图，不知道能节省读者多少时间……如果你体会过查资料的时候阅读这些「断头短尾」的博客，应该也能体会到我的心情。</p></blockquote><p>回到正题。在更多 windows 功能选项框中（win10&#x2F;11 的这个选项框基本相同），勾选上下面的几个选项，三个都要勾选上！</p><ul><li>适用于 Linux 的 Windows 子系统</li><li>虚拟机平台</li><li>windows 虚拟机监控程序平台</li></ul><p>点击确定，就成功启用了 WSL。系统会弹出一个进度条，下载一些东西。</p><p><img src="https://img.musnow.top/i/2023/10/61b796407e655ae94c7ff535edaeae69.png" alt="image-20231015104951463"></p><p>处理完毕后，WIN+R 输入 cmd，打开命令行工具，在命令行工具中输入 <code>wsl -l -v</code> 命令，有相关输出就是启用成功了！</p><p>初始化情况下，执行这个命令，应该会提示你当前什么虚拟机都没有安装。</p><h1 id="2- 安装 Centos8"><a href="#2- 安装 Centos8" class="headerlink" title="2. 安装 Centos8"></a>2. 安装 Centos8</h1><h2 id="2-1- 下载系统 zip"><a href="#2-1- 下载系统 zip" class="headerlink" title="2.1 下载系统 zip"></a>2.1 下载系统 zip</h2><p>去 <a href="https://github.com/wsldl-pg/CentWSL/releases/tag/8.1.1911.1">github&#x2F;wsldl-pg&#x2F;CentWSL</a> 上下载适用于 wsl 的 <code>CentOS8</code> 系统的 zip</p><blockquote><p>这个也可以：<a href="https://github.com/mishamosher/CentOS-WSL">https://github.com/mishamosher/CentOS-WSL</a></p></blockquote><p><img src="https://img.musnow.top/i/2023/10/c42449d2875a2e60a296953f2bfcfae8.png" alt="image-20231015104110576"></p><p>把 zip 解压到你想安装虚拟机的位置（一定要是一个空文件夹），然后右键<code>CentOS8.exe</code>，以管理员身份运行。</p><p><img src="https://img.musnow.top/i/2023/10/a13a0b3e0db1dab54e499c9c7bf5ddc6.png" alt="image-20231015104455537"></p><h2 id="2-2- 报错 HRESULT-0x80370102 解决"><a href="#2-2- 报错 HRESULT-0x80370102 解决" class="headerlink" title="2.2 报错 HRESULT:0x80370102 解决"></a>2.2 报错 HRESULT:0x80370102 解决 </h2><p> 安装 CentOS8 的时候，就遇到了这个 <strong>issue</strong> 中的问题👇</p><p><a href="https://github.com/wsldl-pg/CentWSL/issues/36">github.com&#x2F;wsldl-pg&#x2F;CentWSL&#x2F;issues&#x2F;36</a></p><p>用管理员身份运行 <code>CentOS8.exe</code> 之后，弹出的终端会输出如下内容</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ERROR:Installation Failed!</span><br><span class="line">HRESULT:0x80370102</span><br></pre></td></tr></table></figure><p>根据 <a href="https://github.com/wsldl-pg/CentWSL/issues/36"> 该 issue</a> 中最后一个回复的解决办法，我先将 wsl 版本设置回了 1（这就是为什么前文说不要先设置为默认 wsl2）</p><p><img src="https://img.musnow.top/i/2023/10/d19e82cbafe8e5eba20d8c6eef64687a.png" alt="image-20231015112649042"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wsl --set-default-version 1</span><br></pre></td></tr></table></figure><p>重复如上安装步骤（以管理员身份运行<code>CentOS8.exe</code>），就成功安装了虚拟机。在 win11 的文件管理器左侧会多出来一个 Linux 图标，里面有 CentOS8 的系统里面的文件。</p><p><img src="https://img.musnow.top/i/2023/10/721c72e099c746ab5f618282dc205e27.png" alt="image-20231015105247440"></p><p>在 windows 的 powershell 或者 cmd 中，输入<code>wsl</code>，就可以进入 CentOS8 的 bash；见下图，我们已经成功安装好了一个 CentOS8 的虚拟机。内部的文件就是 CentOS8 系统的默认文件。</p><p>在内部执行 <code>exit</code> 命令，就可以退出 wsl 虚拟机，回到 windows 的终端下。</p><p><img src="https://img.musnow.top/i/2023/10/fa9eb9786e59758af270ae93f120ed51.png" alt="image-20231015105338512"></p><p>而且 WSL 有个最大的好处，就是它能自动挂载 windows 下的文件到 <code>/mnt</code> 目录下，这个目录里面可以看到我的 win11 宿主机的 3 个硬盘分区；windows 的文件资源管理器里面也可以看到 Linux 中的文件，<strong>方便我们在 windows 和 linux 下互传文件</strong>（就不需要用 sftp 工具了）</p><p>特别是如果你需要写带 Doxygen 文档的项目，在生成 Doxygen 的 html 后，就能直接从这里在 windows 的浏览器中打开网页，而不需要用 sftp 或者其他工具传到 windows 下再打开了！</p><blockquote><p>当然，你也可以用带 GUI 的 Linux 系统来解决这个问题。</p></blockquote><h2 id="2-3- 更新为 WSL2"><a href="#2-3- 更新为 WSL2" class="headerlink" title="2.3 更新为 WSL2"></a>2.3 更新为 WSL2</h2><p>使用 <code>wsl -l -v</code> 命令，可以看到当前运行的 wsl 虚拟机，版本是 1</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">PS C:\Users\S2522\Desktop&gt; wsl -l -v</span><br><span class="line">  NAME       STATE           VERSION</span><br><span class="line">* CentOS8    Running         1</span><br></pre></td></tr></table></figure><p>我们可以将其升级为 WSL2 版本，但是这里会告诉你需要更新内核组件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">PS C:\Users\S2522\Desktop&gt; wsl --set-version CentOS8 2</span><br><span class="line">正在进行转换，这可能需要几分钟时间...</span><br><span class="line">有关与 WSL 2 的主要区别的信息，请访问 https://aka.ms/wsl2</span><br><span class="line">WSL 2 需要更新其内核组件。有关信息，请访问 https://aka.ms/wsl2kernel</span><br></pre></td></tr></table></figure><p>那就更新呗！<a href="https://aka.ms/wsl2kernel">微软官方文档 </a> 中会告诉你需要 <code>wsl.exe --install</code> 或 <code>wsl.exe --update</code> 命令。</p><p>这里我执行了 <code>wsl --update</code> 命令，执行后会弹窗要你提供管理权限，并出现一个进度条，等他跑完就行。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">PS C:\Users\S2522\Desktop&gt; wsl --update</span><br><span class="line">正在安装: 适用于 Linux 的 Windows 子系统 </span><br><span class="line"> 已安装 适用于 Linux 的 Windows 子系统。</span><br></pre></td></tr></table></figure><p>更新好了，再重新执行 <code>wsl --set-version CentOS8 2</code> 升级命令，会提示你正在执行转换，需要等待一会。</p><p><img src="https://img.musnow.top/i/2023/10/a870772fe8f185d55935bb2eb1d720d3.png" alt="image-20231015105730332"></p><p>最终成功转换了，使用命令 <code>wsl -l -v</code> 里面显示的版本也是 2 了。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">PS C:\Users\S2522\Desktop&gt; wsl --set-version CentOS8 2</span><br><span class="line">有关与 WSL 2 关键区别的信息，请访问 https://aka.ms/wsl2</span><br><span class="line"></span><br><span class="line">正在进行转换，这可能需要几分钟时间。</span><br><span class="line">操作成功完成。</span><br><span class="line">PS C:\Users\S2522\Desktop&gt; wsl -l -v</span><br><span class="line">  NAME       STATE           VERSION</span><br><span class="line">* CentOS8    Stopped         2</span><br></pre></td></tr></table></figure><p>搞定！现在我们就有一个方便的 CentOS8 的 WSL 环境啦！</p><p>可以用如下命令，将当前的 CentOS8 设置为默认的 wsl 虚拟机。这样在 windows 命令行中执行 wsl 或者 bash 命令，就能直接进入 CentOS8 中。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wslconfig /setdefault CentOS8</span><br></pre></td></tr></table></figure><p>重启电脑后，在 powershell 的下拉栏中会自动出现 CentOS8 的选项，点击它也能进入 wsl 虚拟机环境中。</p><p><img src="https://img.musnow.top/i/2023/10/e40e68ef976f8ef57c9f73d03a8dc892.png" alt="image-20231015134927313"></p><h1 id="3- 解决 yum 报错问题"><a href="#3- 解决 yum 报错问题" class="headerlink" title="3. 解决 yum 报错问题"></a>3. 解决 yum 报错问题 </h1><p> 因为这个 CentOS 的镜像是最小安装版本（类似于 Docker 安装的 CentOS），所以内部的 yum 源都是坏掉的。执行 <code>yum update</code> 会出现如下报错。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@7945R9P ~]# yum -y update</span><br><span class="line">Failed to set locale, defaulting to C.UTF-8</span><br><span class="line">CentOS-8 - AppStream                                                                     68  B/s |  38  B     00:00</span><br><span class="line">Failed to download metadata for repo &#x27;AppStream&#x27;</span><br><span class="line">Error: Failed to download metadata for repo &#x27;AppStream&#x27;</span><br></pre></td></tr></table></figure><p>这时候需要进行 yum 源的重新设置，参考本站博客解决这个问题就行</p><p> <a href="https://blog.musnow.top/posts/1296728696/">【Docker】配置 CentOS 容器时出现 Error Failed to download metadata for repo ‘appstream’ Cannot prepare internal mirrorlist | 转载</a></p><p>搞定 yum 之后，就可以正常安装你想要的开发软件了。这个系统很轻量，sudo 和 passwd 等很多完整系统会自带的命令都没有，需要自行安装一些。</p><p>另外，我写过一个 CentOS8 的初始化脚本，可以自动化安装一些软件，这里安装的软件并不一定是你想要的，请酌情参考：<a href="https://gitee.com/musnows/centos8-init">https://gitee.com/musnows/centos8-init</a></p><hr><p>而且，默认情况下的 ls 命令也没有颜色输出，需要修改 bash 配置来设置命令别名</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">alias</span> <span class="built_in">ls</span>=<span class="string">&#x27;ls --color=auto&#x27;</span></span><br></pre></td></tr></table></figure><p>你也可以根据自己的喜好，改成 zsh 或者其他终端。</p><h1 id="4-vscode 连接"><a href="#4-vscode 连接" class="headerlink" title="4.vscode 连接"></a>4.vscode 连接 </h1><p> 普通的虚拟机我们需要用 vscode 的 remote ssh 插件来连接，但是 WSL 主机我们直接用 vsc 的 <strong>WSL 插件</strong> 来连接就行了，使用的效果和 remote ssh 插件是相同的</p><p><img src="https://img.musnow.top/i/2023/10/4211aec9f60b6984a3a680c1a900b5c8.png" alt="image-20231015111412100"></p><p>在左侧这个远程连接控制器中（和 Remote ssh 是同一个位置），找到上方的下拉条，改成 WSL 目标，就能看到我们的 CentOS8 虚拟机。点击连接它就可以了。</p><p><img src="https://img.musnow.top/i/2023/10/344e4ab417ab6246fa14351b211f016c.png" alt="image-20231015111429863"></p><p>但是 vscode 默认链接的是 root 用户，一般情况下肯定不会在 root 下写代码的。所以需要配置一下子用户</p><p>修改虚拟机中的 <code>/etc/wsl.conf</code> 文件，添加下面两行</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[user]</span><br><span class="line">default= 用户名</span><br></pre></td></tr></table></figure><p>然后回到 windows 的命令行，重启 wsl</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wsl --shutdown CentOS8</span><br></pre></td></tr></table></figure><p>再次启动 wsl，这样 vsc 就能默认链接你的子用户了。</p><h1 id="5- 修改 wsl 资源限制"><a href="#5- 修改 wsl 资源限制" class="headerlink" title="5. 修改 wsl 资源限制"></a>5. 修改 wsl 资源限制 </h1><p> 默认情况下，<strong>wsl2 的虚拟机能访问到完整的系统资源</strong>，包括所有 CPU 核心和内存。</p><p>这就会导致如果 Linux 下对一些东西进行了缓存而没有及时清理，Windows 是没办法回收这部分内存的。<strong>最终就导致我们 Windows 宿主机没有足够的内存可用了</strong>，这怎么行？</p><blockquote><p>这种情况下，一般 windows 系统会把 wsl 直接给干掉，那我们虚拟机里面跑的活也没办法完成了。要知道，Linux 可是很喜欢 cache 内存的，很容易会把宿主机的内存给干没。</p></blockquote><p>为了解决这个问题，我们需要设置 wsl 的虚拟机内存 &#x2F;CPU 限制。</p><p>在 <strong>Linux 下</strong> 可以用这两个命令来查看 cpu 和内存的配置信息，刚开始的时候应该是和你的宿主机的 CPU 和内存一样。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cat</span> /proc/cpuinfo | grep processor <span class="comment"># 查看 cpu 核心数量</span></span><br><span class="line"><span class="built_in">cat</span> /proc/meminfo | grep Total     <span class="comment"># 查看内存信息</span></span><br></pre></td></tr></table></figure><p>在 windows 的 <strong>C 盘</strong> 的<strong>用户文件夹 </strong> 下，创建一个 <code>.wslconfig</code> 文件，并在内部写入限制</p><ul><li>processors 是 cpu 核数限制</li><li>memory 和 swap 都是内存限制</li></ul><p>顶多设置为宿主机内存的一半，避免宿主机卡顿。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[wsl2]</span><br><span class="line">processors=8</span><br><span class="line">memory=8GB</span><br><span class="line">swap=8GB</span><br></pre></td></tr></table></figure><p>这个配置文件的路径是（windows 下）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">C:\Users\ 你的用户名 \.wslconfig</span><br></pre></td></tr></table></figure><p>随后在 windows 的终端中使用如下命令，终止这个 wsl 虚拟机</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">PS C:\Users\S2522\Desktop&gt; wsl --shutdown CentOS8</span><br><span class="line">PS C:\Users\S2522\Desktop&gt; wsl -l -v</span><br><span class="line">  NAME       STATE           VERSION</span><br><span class="line">* CentOS8    Stopped         2</span><br></pre></td></tr></table></figure><p>wsl 命令中并没有 <code>--start</code> 选项，我们直接用 wsl 命令，就会自动重启并进入这个虚拟机。</p><p>这时候再在虚拟机内部看看 CPU 和内存信息，就可以看到你刚刚配置的性能限制结果了。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">[root@7945R9P ~]# cat /proc/cpuinfo | grep processor</span><br><span class="line">processor       : 0</span><br><span class="line">processor       : 1</span><br><span class="line">processor       : 2</span><br><span class="line">processor       : 3</span><br><span class="line">processor       : 4</span><br><span class="line">processor       : 5</span><br><span class="line">processor       : 6</span><br><span class="line">processor       : 7</span><br><span class="line">[root@7945R9P ~]# cat /proc/meminfo | grep Total</span><br><span class="line">MemTotal:        8136640 kB</span><br><span class="line">SwapTotal:       8388608 kB</span><br><span class="line">VmallocTotal:   34359738367 kB</span><br><span class="line">HugePages_Total:       0</span><br></pre></td></tr></table></figure><h2 id="删除 wsl 主机"><a href="# 删除 wsl 主机" class="headerlink" title="删除 wsl 主机"></a>删除 wsl 主机 </h2><p> 删除虚拟机的命令如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wsl --unregister &lt;DistributionName&gt;</span><br></pre></td></tr></table></figure><p>更多命令参考微软官网 <a href="https://learn.microsoft.com/zh-cn/windows/wsl/basic-commands">https://learn.microsoft.com/zh-cn/windows/wsl/basic-commands</a></p><h1 id="6- 启用 systemctl"><a href="#6- 启用 systemctl" class="headerlink" title="6. 启用 systemctl"></a>6. 启用 systemctl</h1><p>我们的系统里面有 systemctl 命令，但是没有办法使用。网上有些教程说用 service 命令来替代，但 CentOS 中是没有 service 命令的。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@7945R9P bison-3.8]# systemctl</span><br><span class="line">System has not been booted with systemd as init system (PID 1). Can&#x27;t operate.</span><br><span class="line">Failed to connect to bus: Host is down</span><br></pre></td></tr></table></figure><h2 id="6-1-distrod- 第三方工具"><a href="#6-1-distrod- 第三方工具" class="headerlink" title="6.1 distrod 第三方工具"></a>6.1 distrod 第三方工具 </h2><p> 我们需要用 distrod 来安装 systemctl 的组件，才能成功启用它。具体教程参考 github 仓库的 README 中的介绍。不是很难</p><blockquote><p><a href="https://github.com/nullpo-head/wsl-distrod">https://github.com/nullpo-head/wsl-distrod</a></p></blockquote><p>先下载一个自动安装的脚本（连不上 github 会报 ssl 或者 timeout 错误，请使用其他办法下载这个脚本再丢到虚拟机里面去就行）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">curl -L -O &quot;https://raw.githubusercontent.com/nullpo-head/wsl-distrod/main/install.sh&quot;</span><br><span class="line">chmod +x install.sh</span><br><span class="line">sudo ./install.sh install</span><br></pre></td></tr></table></figure><p>然后用下面两个命令之一来启动（第一个命令是会在 windows 开机自动启动的）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">/opt/distrod/bin/distrod enable --start-on-windows-boot</span><br><span class="line">/opt/distrod/bin/distrod enable</span><br></pre></td></tr></table></figure><p>更多内容相见 <a href="https://github.com/nullpo-head/wsl-distrod"> 该仓库 README</a>；</p><p>请注意，执行第一个自启动命令的时候需要 windows 的管理员权限，此时需要输入的是系统登录的微软账户的密码（不是你的 PIN），看下面，我第一次输入密码输入的就是 PIN，显示错误，第二次输入了微软账户的密码才成功。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">[root@7945R9P pkg]# /opt/distrod/bin/distrod enable --start-on-windows-boot</span><br><span class="line">[Distrod] Distrod has been enabled. Now your shell will start under systemd.</span><br><span class="line">[Distrod] Enabling atuomatic startup of Distrod. UAC dialog will appear because scheduling</span><br><span class="line">a task requires the admin privilege. Please hit enter to proceed.</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Error</span><br><span class="line">It seems the task has not been scheduled successfully. You may have typed a wrong password, or you may not have the</span><br><span class="line">necessary administrative privileges. Do you want to retry?</span><br><span class="line">[Y] Yes  [N] No  [?] 帮助 (默认值为“Y”): y</span><br><span class="line">Enabling autostart has succeeded.</span><br><span class="line">[Distrod] Distrod will now start automatically on Windows startup.</span><br></pre></td></tr></table></figure><p>操作完成后，需要重启虚拟机。用如下命令将对应的 wsl 虚拟机关闭就行了，再次执行 wsl 就会重启这个虚拟机。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wsl --terminate CentOS8</span><br></pre></td></tr></table></figure><p>如图，我的 systemctl 命令已经生效。</p><p><img src="https://img.musnow.top/i/2023/10/9340e7964572037fbd3b58f1b379b177.png" alt="image-20231015150251531"></p><p>也能正常通过 systemctl 命令启动 mariadb 数据库</p><p><img src="https://img.musnow.top/i/2023/10/6edf311cf4a5dd1749328456a0008255.png" alt="image-20231015150404823"></p><h2 id="6-2- 微软官方（推荐）"><a href="#6-2- 微软官方（推荐）" class="headerlink" title="6.2 微软官方（推荐）"></a>6.2 微软官方（推荐）</h2><blockquote><p>参考 <a href="https://zhuanlan.zhihu.com/p/569883693">https://zhuanlan.zhihu.com/p/569883693</a></p></blockquote><p>查看 wsl 版本号命令为： <code>wsl --version</code>，如果此命令未正常回显版本号，或版本号低于<code>0.67.6</code>，那么你安装的 wsl 还不支持 systemd。如下，我的 wsl 版本已经是支持的了。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">PS C:\Users\S2522\Desktop&gt; wsl --version</span><br><span class="line">WSL 版本： 1.2.5.0</span><br><span class="line">内核版本： 5.15.90.1</span><br><span class="line">WSLg 版本： 1.0.51</span><br><span class="line">MSRDC 版本： 1.2.3770</span><br><span class="line">Direct3D 版本： 1.608.2-61064218</span><br><span class="line">DXCore 版本： 10.0.25131.1002-220531-1700.rs-onecore-base2-hyp</span><br><span class="line">Windows 版本： 10.0.22621.2134</span><br></pre></td></tr></table></figure><p>进入 wsl 的 CentOS 虚拟机，执行如下命令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> -e <span class="string">&quot;[boot]\nsystemd=true&quot;</span> | sudo <span class="built_in">tee</span> -a /etc/wsl.conf</span><br></pre></td></tr></table></figure><p>随后 exit 退出虚拟机，<strong>回到 windows 终端命令行</strong>，重启 wsl</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wsl <span class="literal">--shutdown</span></span><br></pre></td></tr></table></figure><p>随后再次在 windows 命令行下执行 wsl 命令，重启这个虚拟机；</p><p>重启 wsl 虚拟机后，在 <strong> 虚拟机内部 </strong> 执行如下命令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ps --no-headers -o <span class="built_in">comm</span> 1</span><br></pre></td></tr></table></figure><ul><li>如果这个命令返回结果是 <strong>systemd</strong>，则代表我们的<code>systemctl</code> 命令已经可以使用。</li><li>如果返回的是<code>init</code>，则设置失败</li></ul><p>如下图，我已经设置成功了！</p><p><img src="https://img.musnow.top/i/2023/10/a072fdd5b53abc04cf444c1ab0ac9ad2.png" alt="image-20231015204810685"></p><p>微软官方支持的 systemd 还是有一点是优于 distrod 的，那就是启用了官方 systemd 的 wsl2 实例，在用户停止操作后，<strong>会自动关闭</strong>，和未启用 systemd 时的特性一样，这有利于节约电脑的计算资源。</p>]]></content>
    
    
    <summary type="html">win11安装wsl和CentOS8Stream虚拟机</summary>
    
    
    
    <category term="玩上Linux" scheme="https://blog.musnow.top/categories/%E7%8E%A9%E4%B8%8ALinux/"/>
    
    
    <category term="Linux" scheme="https://blog.musnow.top/tags/Linux/"/>
    
    <category term="虚拟机" scheme="https://blog.musnow.top/tags/%E8%99%9A%E6%8B%9F%E6%9C%BA/"/>
    
  </entry>
  
  <entry>
    <title>【七牛云】artalk 表情遇到跨域访问问题</title>
    <link href="https://blog.musnow.top/posts/489538601/"/>
    <id>https://blog.musnow.top/posts/489538601/</id>
    <published>2023-10-02T04:35:28.000Z</published>
    <updated>2023-10-02T04:35:28.000Z</updated>
    
    <content type="html"><![CDATA[<p> 如题，当我在我自己编写的文档站点 <a href="https://khl-py.eu.org/">https://khl-py.eu.org/</a> 访问我的 artalk 服务时，其中包含一个 artalk 表情的请求，被浏览器的跨域策略给挡住了。这会导致 artalk 评论中无法发送表情（虽然无伤大雅）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Access to fetch at &#x27;https://img.musnow.top/i/artalk-emoji.json&#x27; from origin &#x27;https://khl-py.eu.org&#x27; has been blocked by CORS policy: No &#x27;Access-Control-Allow-Origin&#x27; header is present on the requested resource. If an opaque response serves your needs, set the request&#x27;s mode to &#x27;no-cors&#x27; to fetch the resource with CORS disabled.</span><br></pre></td></tr></table></figure><p> 百度了一下，我们需要在七牛云的 CDN 策略中进行配置（我的七牛云 KODO 是绑定到 CDN 上，通过 CDN 进行访问的）</p><p> 找到 CDN 界面中的 <strong>HTTP 响应头配置 </strong></p><p><img src="https://img.musnow.top/i/2023/10/6e1119859945ce9b07928a2bff2643d8.png" alt="image-20231002222846450"></p><p> 点击修改配置，添加如下两点 </p><p><img src="https://img.musnow.top/i/2023/10/6b3b5f2bc783ef6bf7cc614d5bc2a1e7.png" alt="image-20231002222920540"></p><p> 保存后过一会，就不会出现这个跨域访问问题了。至于这部分设置会不会导致有人盗刷你的 CDN 流量，仍待更多的观察。</p><p> 另外，如果你的 CDN 还开启了防盗链，还需要把对应域名填入防盗链的白名单中！</p>]]></content>
    
    
    <summary type="html">七牛云存放的artalk表情遇到跨域访问问题</summary>
    
    
    
    <category term="差生文具多" scheme="https://blog.musnow.top/categories/%E5%B7%AE%E7%94%9F%E6%96%87%E5%85%B7%E5%A4%9A/"/>
    
    
    <category term="图床" scheme="https://blog.musnow.top/tags/%E5%9B%BE%E5%BA%8A/"/>
    
  </entry>
  
  <entry>
    <title>【C 语言】clock_gettime 函数的使用</title>
    <link href="https://blog.musnow.top/posts/107825263/"/>
    <id>https://blog.musnow.top/posts/107825263/</id>
    <published>2023-09-27T12:41:59.000Z</published>
    <updated>2023-09-27T13:29:17.000Z</updated>
    
    <content type="html"><![CDATA[<p>函数的基本信息如下</p><ul><li>其中第一个参数是配置你想获取什么类型的时间</li><li>第二个参数是一个 <strong> 输出型参数</strong>，会将当前时间存放到一个结构体里面给你返回。</li><li>返回值标识是否获取成功</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 头文件</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;time.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数原型</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">clock_gettime</span><span class="params">(<span class="type">clockid_t</span> clock_id,<span class="keyword">struct</span> timespec * tp )</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// timespec 结构体</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">timespec</span> &#123;</span> </span><br><span class="line">    <span class="type">__time_t</span> tv_sec; <span class="comment">/* 秒 */</span> </span><br><span class="line">    __syscall_s <span class="type">long_t</span> tv_nsec; <span class="comment">/* 纳秒 */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>第一个参数有下面几种选项</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">CLOCK_REALTIME: 是指系统时间，随着系统时间的改变而改变。系统时钟会被用户而改变。并非不变的时间戳。</span><br><span class="line">CLOCK_MONOTONIC: 指从系统启动时开始计时。不受系统设置影响，也不会被用户改变。</span><br><span class="line">CLOCK_PROCESS_CPUTIME_ID: 指这个进程运行到当前代码时，CPU 花费的时间。</span><br><span class="line">CLOCK_THREAD_CPUTIME_ID: 指这个线程运行到当前代码时，CPU 花费的时间。</span><br></pre></td></tr></table></figure><p>使用例子</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;time.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">timespec</span> <span class="title">now</span>;</span></span><br><span class="line"></span><br><span class="line">    clock_gettime(CLOCK_MONOTONIC,&amp;now);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Seconds = %ld \t Nanoseconds = %ld\n&quot;</span>,, now.tv_sec, now.tv_nsec);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Seconds = 29642          Nanoseconds = 751516090</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">clock_gettime函数的使用</summary>
    
    
    
    <category term="初识C语言" scheme="https://blog.musnow.top/categories/%E5%88%9D%E8%AF%86C%E8%AF%AD%E8%A8%80/"/>
    
    
    <category term="C语言" scheme="https://blog.musnow.top/tags/C%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title>【Linux】valgrind 检测程序内存泄漏</title>
    <link href="https://blog.musnow.top/posts/565285228/"/>
    <id>https://blog.musnow.top/posts/565285228/</id>
    <published>2023-09-26T10:12:55.000Z</published>
    <updated>2023-09-26T10:12:55.000Z</updated>
    
    <content type="html"><![CDATA[<p>valgrind 是一个用于检测 debug 内存泄漏的命令行工具</p><h1 id="安装遵循如下命令"><a href="# 安装遵循如下命令" class="headerlink" title="安装遵循如下命令"></a>安装遵循如下命令 </h1><h2 id="下载"><a href="# 下载" class="headerlink" title="下载"></a> 下载</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget https://sourceware.org/pub/valgrind/valgrind-3.21.0.tar.bz2</span><br></pre></td></tr></table></figure><h2 id="解压"><a href="# 解压" class="headerlink" title="解压"></a>解压</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">tar -xf valgrind-3.21.0.tar.bz2</span><br><span class="line">cd valgrind-3.21.0</span><br></pre></td></tr></table></figure><h2 id="配置 -x2F- 安装，需要有 root 权限"><a href="# 配置 -x2F- 安装，需要有 root 权限" class="headerlink" title="配置 &#x2F; 安装，需要有 root 权限"></a>配置 &#x2F; 安装，需要有 root 权限</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo ./configure</span><br><span class="line">sudo make</span><br><span class="line">sudo make install</span><br></pre></td></tr></table></figure><h1 id="使用 mencheck"><a href="# 使用 mencheck" class="headerlink" title="使用 mencheck"></a>使用 mencheck</h1><p>mencheck 是 valgrind 的一个模块，其还拥有其他功能，但是我们在这里不做使用<br> –tool&#x3D;memcheck  选择 memcheck 工具<br> –log-file&#x3D;log.txt  指定日志输出文件到 log.txt <br> –leak-check&#x3D;no|summary|full  指定输出日志的详细程度</p><p>基本使用命令的一个示例，最后的 <code>./test</code> 是一个可执行文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">valgrind --tool=memcheck --log-file=log.txt --leak-check=full ./test</span><br></pre></td></tr></table></figure><h2 id="说明"><a href="# 说明" class="headerlink" title="说明"></a>说明</h2><p>memcheck 模块检测的范围包括 </p><ul><li>使用未初始化的内存</li><li>使用已经被释放的内存</li><li>使用超出 malloc 分配空间的内存</li><li>对堆栈的非法访问</li><li>是否有释放申请的空间</li><li>memcpy 中 src 和 dst 的重叠（参数的内存空间有重合部分）</li></ul><p>注意，对于某些 new 和 malloc 出来的常驻对象（比如全局的某个对象，单例模式中就会遇到）并不能算作内存泄漏，因为它是需要被使用的。</p><h2 id="测试"><a href="# 测试" class="headerlink" title="测试"></a>测试 </h2><p> 整了个最简单的代码 </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstddef&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line">​</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test_leak</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> *p = (<span class="type">int</span> *)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">    *p = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">​</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> *p1 = (<span class="type">int</span> *)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">    *p1 = <span class="number">2</span>;</span><br><span class="line">​</span><br><span class="line">    <span class="type">int</span> *p2 = (<span class="type">int</span> *)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">    *p2 = <span class="number">3</span>;</span><br><span class="line">    <span class="comment">// 只析构一个，看看能不能检查出报错</span></span><br><span class="line">    <span class="built_in">free</span>(p2);</span><br><span class="line">    <span class="built_in">test_leak</span>();<span class="comment">// 只有调用的模块出现内存泄漏才能被检测到</span></span><br><span class="line">    <span class="comment">// 如果不调用这个函数，则不会检测到这里的问题</span></span><br><span class="line">    <span class="comment">// 因为 valgrind 是操作监看可执行文件的，并不是来扫描代码的</span></span><br><span class="line">​</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里面有 3 个 malloc，其中有两个是没有 free 的，那么用 valgrind 可以检测出来吗？</p><p>答案是肯定的:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">==24089== Memcheck, a memory error detector</span><br><span class="line">==24089== Copyright (C) 2002-2022, and GNU GPL&#x27;d, by Julian Seward et al.</span><br><span class="line">==24089== Using Valgrind-3.21.0 and LibVEX; rerun with -h for copyright info</span><br><span class="line">==24089== Command: ./test</span><br><span class="line">==24089== Parent PID: 24056</span><br><span class="line">==24089== </span><br><span class="line">==24089== </span><br><span class="line">==24089== HEAP SUMMARY:</span><br><span class="line">==24089==     in use at exit: 8 bytes in 2 blocks</span><br><span class="line">==24089==   total heap usage: 4 allocs, 2 frees, 72,716 bytes allocated</span><br><span class="line">==24089== </span><br><span class="line">==24089== 4 bytes in 1 blocks are definitely lost in loss record 1 of 2</span><br><span class="line">==24089==    at 0x484880F: malloc (vg_replace_malloc.c:431)</span><br><span class="line">==24089==    by 0x1091F8: main (in /home/lyk/ub-vm/test)</span><br><span class="line">==24089== </span><br><span class="line">==24089== 4 bytes in 1 blocks are definitely lost in loss record 2 of 2</span><br><span class="line">==24089==    at 0x484880F: malloc (vg_replace_malloc.c:431)</span><br><span class="line">==24089==    by 0x1091C1: test_leak() (in /home/lyk/ub-vm/test)</span><br><span class="line">==24089==    by 0x10922C: main (in /home/lyk/ub-vm/test)</span><br><span class="line">==24089== </span><br><span class="line">==24089== LEAK SUMMARY:</span><br><span class="line">==24089==    definitely lost: 8 bytes in 2 blocks</span><br><span class="line">==24089==    indirectly lost: 0 bytes in 0 blocks</span><br><span class="line">==24089==      possibly lost: 0 bytes in 0 blocks</span><br><span class="line">==24089==    still reachable: 0 bytes in 0 blocks</span><br><span class="line">==24089==         suppressed: 0 bytes in 0 blocks</span><br><span class="line">==24089== </span><br><span class="line">==24089== For lists of detected and suppressed errors, rerun with: -s</span><br><span class="line">==24089== ERROR SUMMARY: 2 errors from 2 contexts (suppressed: 0 from 0)</span><br></pre></td></tr></table></figure><p>在最后的 summry 里面可以看到，这里提示 <code>definitely lost</code> 了 8 个字节，而且是在两个不同的区块中丢失的。和我们的代码吻合。</p><p>如果你不调用  <code>test_leak()</code>  函数，那么就不会出现第二次的内存泄漏，报告会变成只有  <code>4 bytes in 1 blocks</code> ，因为 valgrind 是通过可执行文件来检测是否有内存泄漏的，他不会扫描你的代码（那样的成本太高了而且不一定准确！）</p>]]></content>
    
    
    <summary type="html">valgrind是一个用于检测debug内存泄漏的命令行工具</summary>
    
    
    
    <category term="玩上Linux" scheme="https://blog.musnow.top/categories/%E7%8E%A9%E4%B8%8ALinux/"/>
    
    
    <category term="Linux" scheme="https://blog.musnow.top/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>【C++】C++17 的那些新特性</title>
    <link href="https://blog.musnow.top/posts/3858168547/"/>
    <id>https://blog.musnow.top/posts/3858168547/</id>
    <published>2023-09-26T04:40:46.000Z</published>
    <updated>2023-09-26T04:40:46.000Z</updated>
    
    <content type="html"><![CDATA[<p>学习 C++17 的新特性</p><h1 id="1- 构造函数模板推导"><a href="#1- 构造函数模板推导" class="headerlink" title="1. 构造函数模板推导"></a>1. 构造函数模板推导 </h1><p> 在之前，我们如果想用 stl 容器，都需要用<code>&lt;&gt;</code> 来手动指定参数类型。但在 C++17 中，我们不需要这么做了。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::vector v1 = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125;;</span><br><span class="line">    std::pair p1  = &#123;<span class="number">1</span>,<span class="number">2.4234</span>&#125;;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">typeid</span>(v1).<span class="built_in">name</span>() &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">typeid</span>(p1).<span class="built_in">name</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用 C++11 编译，这个代码会报错。报错的意思是让我们指定参数的模板类型。</p><p>比如 <code>std::pair p1  = &#123;1,2.4234&#125;;</code> 在 C++11 中应该写成 <code>std::pair&lt;int,double&gt; p1  = &#123;1,2.4234&#125;;</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">test.cpp:16:10: error: use of class template &#x27;std::pair&#x27; requires template arguments</span><br><span class="line">    std::pair p1  = &#123;1,2.4234&#125;;</span><br><span class="line">         ^</span><br><span class="line">/usr/bin/../lib/gcc/x86_64-linux-gnu/11/../../../../include/c++/11/bits/stl_pair.h:211:12: note: template is declared here</span><br><span class="line">    struct pair</span><br><span class="line">           ^</span><br><span class="line">3 errors generated.</span><br><span class="line">make: *** [makefile:3: test] Error 1</span><br></pre></td></tr></table></figure><p>在 C++17 中，这样的写法就是可以被通过的了，也能正常推断出参数的类型，分别是一个 int 的 vector，和一个 int+double 的 pair；</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ make</span><br><span class="line">clang++ test.cpp -o test -std=c++17</span><br><span class="line">$ ./test</span><br><span class="line">St6vectorIiSaIiEE</span><br><span class="line">St4pairIidE</span><br></pre></td></tr></table></figure><h1 id="2- 结构化绑定"><a href="#2- 结构化绑定" class="headerlink" title="2. 结构化绑定"></a>2. 结构化绑定 </h1><p> 我们可以用 <code>auto[变量 1, 变量 2]</code>的方式来接受一个 tuple 或者 pair 的返回值，将其绑定到两个不同的变量上。</p><p>tuple 是 C++11 新增的一个数据结构，它和 pair 的用法类似，不同的是元组支持无数个参数。而 pair 仅支持两个。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::tuple&lt;<span class="type">int</span>, <span class="type">double</span>&gt; <span class="title">func_tuple</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> std::<span class="built_in">tuple</span>&lt;<span class="type">int</span>,<span class="type">double</span>&gt;(<span class="number">1</span>, <span class="number">2.2</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">std::pair&lt;<span class="type">int</span>, <span class="type">double</span>&gt; <span class="title">func_pair</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;<span class="number">1</span>,<span class="number">2</span>&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> [i, d] = <span class="built_in">func_tuple</span>(); </span><br><span class="line">    cout &lt;&lt; <span class="built_in">typeid</span>(i).<span class="built_in">name</span>() &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">typeid</span>(d).<span class="built_in">name</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> [x,y] = <span class="built_in">func_pair</span>();</span><br><span class="line">    cout &lt;&lt; <span class="built_in">typeid</span>(x).<span class="built_in">name</span>() &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">typeid</span>(y).<span class="built_in">name</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用 C++11 来编译，编译器会报错，但编译依旧能成功。这是因为我们的编译器是支持 C++17 的，但又被指定了<code>-std=c++11</code>，所以给用户报了个警告，但没有报错（因为这个语法在 C++17 里面是正确的）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">clang++ test.cpp -o test -std=c++11</span><br><span class="line">test.cpp:34:10: warning: decomposition declarations are a C++17 extension [-Wc++17-extensions]</span><br><span class="line">    auto [i, d] = func_tuple(); </span><br><span class="line">         ^~~~~~</span><br><span class="line">test.cpp:40:10: warning: decomposition declarations are a C++17 extension [-Wc++17-extensions]</span><br><span class="line">    auto [x,y] = func_pair();</span><br><span class="line">         ^~~~~</span><br><span class="line">2 warnings generated.</span><br></pre></td></tr></table></figure><p>运行输出结果如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ ./test</span><br><span class="line">i</span><br><span class="line">d</span><br><span class="line"></span><br><span class="line">i</span><br><span class="line">d</span><br></pre></td></tr></table></figure><p>注意：结构化绑定不能应用于 constexpr！</p><p>结构化绑定不止可以绑定 pair 和 tuple，还可以绑定数组和结构体等。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 注意这里的 struct 的成员一定要是 public 的，不然外部无法访问，还怎么绑定？</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Point</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line">    <span class="type">int</span> y;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回值是 point 的函数</span></span><br><span class="line"><span class="function">Point <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;<span class="number">1</span>, <span class="number">2</span>&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> array[<span class="number">3</span>] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line">    <span class="keyword">auto</span> [a, b, c] = array;</span><br><span class="line">    cout &lt;&lt; a &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; b &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; c &lt;&lt; endl;</span><br><span class="line">    <span class="comment">// 直接推导出两个成员变量并赋值给变量 x 和 y</span></span><br><span class="line">    <span class="type">const</span> <span class="keyword">auto</span> [x, y] = <span class="built_in">func</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>成功编译并输出结果</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ make</span><br><span class="line">clang++ test.cpp -o test -std=c++17</span><br><span class="line">$ ./test</span><br><span class="line">1 2 3</span><br><span class="line">1 2</span><br></pre></td></tr></table></figure><p>自定义类型也能实现结构化绑定，这里从网上扒了一个代码下来，就不自己做测试了</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 需要实现相关的 tuple_size 和 tuple_element 和 get&lt;N&gt; 方法。</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Entry</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        name_ = <span class="string">&quot;name&quot;</span>;</span><br><span class="line">        age_ = <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">std::string <span class="title">GetName</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> name_; &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">GetAge</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> age_; &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::string name_;</span><br><span class="line">    <span class="type">int</span> age_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="type">size_t</span> I&gt;</span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">get</span><span class="params">(<span class="type">const</span> Entry&amp; e)</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">if</span> <span class="title">constexpr</span> <span class="params">(I == <span class="number">0</span>)</span> <span class="keyword">return</span> e.<span class="title">GetName</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> <span class="built_in">constexpr</span> (I == <span class="number">1</span>) <span class="keyword">return</span> e.<span class="built_in">GetAge</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> std &#123;</span><br><span class="line">    <span class="keyword">template</span>&lt;&gt; <span class="keyword">struct</span> <span class="title class_">tuple_size</span>&lt;Entry&gt; : integral_constant&lt;<span class="type">size_t</span>, <span class="number">2</span>&gt; &#123;&#125;;</span><br><span class="line">    <span class="keyword">template</span>&lt;&gt; <span class="keyword">struct</span> <span class="title class_">tuple_element</span>&lt;<span class="number">0</span>, Entry&gt; &#123; <span class="keyword">using</span> type = std::string; &#125;;</span><br><span class="line">    <span class="keyword">template</span>&lt;&gt; <span class="keyword">struct</span> <span class="title class_">tuple_element</span>&lt;<span class="number">1</span>, Entry&gt; &#123; <span class="keyword">using</span> type = <span class="type">int</span>; &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Entry e;</span><br><span class="line">    e.<span class="built_in">Init</span>();</span><br><span class="line">    <span class="keyword">auto</span> [name, age] = e;</span><br><span class="line">    cout &lt;&lt; name &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; age &lt;&lt; endl; <span class="comment">// name 10</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="3-if 语句新增初始条件"><a href="#3-if 语句新增初始条件" class="headerlink" title="3.if 语句新增初始条件"></a>3.if 语句新增初始条件 </h1><p> 在之前我们都是用 <code>if(判断条件)</code> 来使用 if 语句的，C++17 中给 if 新增了一个类似 for 循环中第一个参数的相同参数</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">if(初始化条件, 判断条件)</span><br></pre></td></tr></table></figure><p>比如</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(<span class="type">int</span> i=<span class="number">20</span>;i&lt;<span class="number">39</span>)&#123;</span><br><span class="line">    cout &lt;&lt;<span class="string">&quot;i&lt;39!&quot;</span>&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行效果如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ ./test</span><br><span class="line">i&lt;39!</span><br></pre></td></tr></table></figure><h1 id="4- 内联变量"><a href="#4- 内联变量" class="headerlink" title="4. 内联变量"></a>4. 内联变量 </h1><p> 在之前我们想初始化一个类中的 static 变量，需要在类中定义，类外初始化。但如果是 const 的 static 变量，就能直接在类中通过缺省值的方式来初始化。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在头文件里面这样是能通过编译的，但是不建议在头文件中初始化 static 变量，会产生 ODR 冲突:</span></span><br><span class="line"><span class="comment">// Variable &#x27;value&#x27; defined in a header file; variable definitions in header files can lead to ODR violations</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">A</span> &#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> value;  </span><br><span class="line">    <span class="type">static</span> <span class="type">const</span> <span class="type">int</span> value_c=<span class="number">10</span>;  <span class="comment">// const 可以直接初始化</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">int</span> A::value = <span class="number">10</span>;</span><br></pre></td></tr></table></figure><p>在 C++17 中内联变量引入后，我们就可以直接实现在头文件中初始化 static 非 const 变量，或者直接用缺省值来初始化了</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">A</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> value;</span><br><span class="line">    <span class="type">static</span> <span class="type">const</span> <span class="type">int</span> value_c = <span class="number">10</span>;</span><br><span class="line">    <span class="comment">// static int value = 10;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">inline</span> <span class="type">int</span> A::value = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ========= 或者 ========</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">B</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">inline</span> <span class="type">static</span> <span class="type">int</span> value = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">inline</span> <span class="type">static</span> <span class="type">const</span> <span class="type">int</span> value_c = <span class="number">10</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>相比于原本 static 变量初始化需要放到另外一个 cpp 源文件中，这种直接在头文件里面声明 + 初始化的方式能更好的确定变量的初始值。</p><h1 id="5- 折叠表达式"><a href="#5- 折叠表达式" class="headerlink" title="5. 折叠表达式"></a>5. 折叠表达式</h1><p>C++17 引入了折叠表达式使可变参数模板编程更方便：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> ... Ts&gt;</span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">sum</span><span class="params">(Ts ... ts)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (ts + ...);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> a &#123;<span class="built_in">sum</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>)&#125;; <span class="comment">// 15</span></span><br><span class="line">std::string a&#123;<span class="string">&quot;hello &quot;</span>&#125;;</span><br><span class="line">std::string b&#123;<span class="string">&quot;world&quot;</span>&#125;;</span><br><span class="line">cout &lt;&lt; <span class="built_in">sum</span>(a, b) &lt;&lt; endl; <span class="comment">// hello world</span></span><br></pre></td></tr></table></figure><p>实话说，可变模板参数这部分就没有弄明白过，实际上也没有用过，直接跳过！</p><h1 id="6-constexpr-lambda 表达式"><a href="#6-constexpr-lambda 表达式" class="headerlink" title="6.constexpr+lambda 表达式"></a>6.constexpr+lambda 表达式</h1><p>C++17 前 lambda 表达式只能在运行时使用，C++17 引入了 constexpr lambda 表达式，可以用于在编译期进行计算。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">int main() &#123; // c++17 可编译</span><br><span class="line">    constexpr auto lamb = [] (int n) &#123; return n * n; &#125;;</span><br><span class="line">    static_assert(lamb(3) == 9, &quot;a&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>规则和普通的 constexpr 函数相同，参考我的 C++11 和 14 的文章。这里做简单说明：</p><p>constexpr 修饰的函数体不能包含汇编语句、goto 语句、label、try 块、静态变量、线程局部存储、没有初始化的普通变量，不能动态分配内存，不能有 new delete 等，不能虚函数。</p><h1 id="7- 嵌套命名空间"><a href="#7- 嵌套命名空间" class="headerlink" title="7. 嵌套命名空间"></a>7. 嵌套命名空间 </h1><p> 在之前如果需要嵌套命名空间，需要这样写</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> A &#123;</span><br><span class="line">    <span class="keyword">namespace</span> B &#123;</span><br><span class="line">        <span class="keyword">namespace</span> C &#123;</span><br><span class="line">            <span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span></span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>C++17 中可以直接用类似访问限定符的方式，前面加一个 namespace 来标明嵌套的命名空间。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// c++17，方便了，可读性也更好</span></span><br><span class="line"><span class="keyword">namespace</span> A::B::C &#123;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="8-has-include 预处理表达式"><a href="#8-has-include 预处理表达式" class="headerlink" title="8.__has_include 预处理表达式"></a>8.__has_include 预处理表达式</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">if</span> defined __has_include <span class="comment">// 判断是否支持这个表达式</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> __has_include(<span class="string">&lt;charconv&gt;</span>) <span class="comment">// 支持，判断是否存在该头文件</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> has_charconv 1 <span class="comment">// 头文件存在，定义一个宏</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;charconv&gt;</span> <span class="comment">// 引用这个头文件</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>如果一个代码会在多个不同的平台下跑，这个功能就很重要。比如我之前写项目的时候需要使用到 jsoncpp，在 centos 和 deepin 下，安装 jsoncpp 的 include 路径是不同的</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//centos</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;json/json.h&gt;</span></span></span><br><span class="line"><span class="comment">//deepin</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;jsoncpp/json/json.h&gt;</span></span></span><br></pre></td></tr></table></figure><p>这种场景下就可以使用上面提到的这个预处理表达式进行判断，来确认你的 jsoncpp 路径到底在哪里。注意，这只能解决从 yum 和 apt 安装的 jsoncpp，如果是自己手动安装的，那鬼知道你安装到哪里去了？🤣</p><p>所以很多大型项目如果需要使用 jsoncpp 这种第三方依赖项目，一般都会采用 <code>git submodule</code> 的方式，直接将第三方库下载到当前项目路径下，以避免不同平台的依赖项 <code>include</code> 路径不对而导致无法编译程序的问题。</p><h1 id="9-this 指针捕获（lambda）"><a href="#9-this 指针捕获（lambda）" class="headerlink" title="9.this 指针捕获（lambda）"></a>9.this 指针捕获（lambda）</h1><p>在 lambda 表达式中，采用 <code>[this]</code> 方式捕获的 this 指针是 <strong> 值传递 </strong> 捕获的，但在一些情况下，会出现访问已经被释放了的空间的行为；比如如下代码</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Foo</span></span><br><span class="line">&#123;</span><br><span class="line">    std::unique_ptr&lt;<span class="type">int</span>&gt; p;</span><br><span class="line"></span><br><span class="line">    <span class="function">std::function&lt;<span class="title">void</span><span class="params">()</span>&gt; <span class="title">f</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        p.<span class="built_in">reset</span>(<span class="keyword">new</span> <span class="built_in">int</span>(<span class="number">10</span>));</span><br><span class="line">        <span class="keyword">return</span> [&amp;]</span><br><span class="line">        &#123;</span><br><span class="line">            cout &lt;&lt; <span class="number">5</span> &lt;&lt; endl;</span><br><span class="line">            cout &lt;&lt; *p &lt;&lt; endl; <span class="comment">// 实际上是这一步报错的</span></span><br><span class="line">            <span class="comment">// 这里对 *p 的访问可以解析为 *(this-&gt;p)，但实际上 this 指针已经被销毁了</span></span><br><span class="line">            <span class="comment">// 注意，这里采用了智能指针，不存在内存泄漏，p 指针指向的空间也被销毁了</span></span><br><span class="line">            <span class="comment">// 但我们的报错其实是对 this 指针解引用的时候就抛出了</span></span><br><span class="line">            cout &lt;&lt; <span class="number">6</span> &lt;&lt; endl;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> foo = <span class="keyword">new</span> <span class="built_in">Foo</span>();</span><br><span class="line">    cout &lt;&lt; <span class="number">1</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">auto</span> f = foo-&gt;<span class="built_in">f</span>();  <span class="comment">// 获取了一个类内成员函数</span></span><br><span class="line">    cout &lt;&lt; <span class="number">2</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">delete</span> foo;  <span class="comment">// 销毁这个对象</span></span><br><span class="line">    cout &lt;&lt; <span class="number">3</span> &lt;&lt; endl;</span><br><span class="line">    <span class="comment">// 尝试在销毁后继续使用这个对象，我们是通过 lambda 中 = 捕获的 this 指针来访问对象的</span></span><br><span class="line">    <span class="built_in">f</span>();  <span class="comment">// 这里直接报错了 Segmentation fault (core dumped)</span></span><br><span class="line">    cout &lt;&lt; <span class="number">4</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行这个程序，可以看到是在 <code>*p</code> 的位置报错退出的；具体的原因参考代码中的注释。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ ./test</span><br><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">5</span><br><span class="line">Segmentation fault (core dumped)</span><br></pre></td></tr></table></figure><p>需要注意，lambda 表达式中，使用 &#x3D; 和 &amp; 都会默认采用 <strong> 传值捕获 this 指针</strong>，因为 this 指针是存在于函数作用域中的一个隐藏参数，并不是独立在成员函数外的变量，所以是可以被捕捉到的；另外，this 指针是不能被传引用捕获的，<code>[&amp;this]</code> 的写法是不允许的；</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">clang++ test.cpp -o test -std=c++17</span><br><span class="line">test.cpp:84:18: error: &#x27;this&#x27; cannot be captured by reference</span><br><span class="line">        return [&amp;this]</span><br><span class="line">                 ^</span><br><span class="line">1 error generated.</span><br></pre></td></tr></table></figure><p>C++17 中提供了一个特殊的写法 <code>[*this]</code> 通过传值的方式捕获了当前对象本身，此时 lambda 表达式中存在的就是一个对象的拷贝，即便当前对象被销毁了，我们依旧可以通过这个拷贝访问到目标；</p><p>代码修改如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Foo</span></span><br><span class="line">&#123;</span><br><span class="line">    std::shared_ptr&lt;<span class="type">int</span>&gt; p; <span class="comment">// 不能用 unique_ptr，因为它的拷贝构造函数是被 delete 禁止使用的</span></span><br><span class="line"></span><br><span class="line">    <span class="function">std::function&lt;<span class="title">void</span><span class="params">()</span>&gt; <span class="title">f</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        p.<span class="built_in">reset</span>(<span class="keyword">new</span> <span class="built_in">int</span>(<span class="number">10</span>));</span><br><span class="line">        <span class="keyword">return</span> [*<span class="keyword">this</span>]</span><br><span class="line">        &#123;</span><br><span class="line">            cout &lt;&lt; <span class="number">5</span> &lt;&lt; endl;</span><br><span class="line">            cout &lt;&lt; *p &lt;&lt; endl;</span><br><span class="line">            cout &lt;&lt; <span class="number">6</span> &lt;&lt; endl;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> foo = <span class="keyword">new</span> <span class="built_in">Foo</span>();</span><br><span class="line">    cout &lt;&lt; <span class="number">1</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">auto</span> f = foo-&gt;<span class="built_in">f</span>();  <span class="comment">// 获取了一个类内成员函数</span></span><br><span class="line">    cout &lt;&lt; <span class="number">2</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">delete</span> foo;  <span class="comment">// 销毁这个对象</span></span><br><span class="line">    cout &lt;&lt; <span class="number">3</span> &lt;&lt; endl;</span><br><span class="line">    <span class="comment">// 尝试在销毁后继续使用这个对象，我们是通过 lambda 中 = 捕获的 this 指针来访问对象的</span></span><br><span class="line">    <span class="built_in">f</span>();  <span class="comment">// 这里直接报错了 Segmentation fault (core dumped)</span></span><br><span class="line">    cout &lt;&lt; <span class="number">4</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时重新编译，就能成功访问到指针 p 指向的对象了，并不受 foo 对象已经被 delete 的影响；</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ ./test</span><br><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">5</span><br><span class="line">10</span><br><span class="line">6</span><br><span class="line">4</span><br></pre></td></tr></table></figure><h1 id="10- 字符串转换"><a href="#10- 字符串转换" class="headerlink" title="10. 字符串转换"></a>10. 字符串转换</h1><blockquote><p>没看懂这两个函数是干嘛的，找到的代码连编译都过不去，跳过吧</p></blockquote><p>新增 from_chars 函数和 to_chars 函数</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">https://zh.cppreference.com/w/cpp/utility/from_chars</span><br><span class="line">https://blog.csdn.net/defaultbyzt/article/details/120151801</span><br></pre></td></tr></table></figure><h1 id="11-std-variant"><a href="#11-std-variant" class="headerlink" title="11.std::variant"></a>11.std::variant</h1><p>C++17 增加 <code>std::variant</code> 实现类似 union 的功能，但却比 union 更高级，举个例子 union 里面不能有 string 这种类型，但 <code>std::variant</code> 却可以，还可以支持更多复杂类型，如 map 等，看代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123; <span class="comment">// c++17 可编译</span></span><br><span class="line">    <span class="function">std::variant&lt;<span class="type">int</span>, std::string&gt; <span class="title">var</span><span class="params">(<span class="string">&quot;hello&quot;</span>)</span></span>;</span><br><span class="line">    cout &lt;&lt; var.<span class="built_in">index</span>() &lt;&lt; endl;</span><br><span class="line">    var = <span class="number">123</span>;</span><br><span class="line">    cout &lt;&lt; var.<span class="built_in">index</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        var = <span class="string">&quot;world&quot;</span>;</span><br><span class="line">        std::string str = std::<span class="built_in">get</span>&lt;std::string&gt;(var); <span class="comment">// 通过类型获取值</span></span><br><span class="line">        var = <span class="number">3</span>;</span><br><span class="line">        <span class="type">int</span> i = std::<span class="built_in">get</span>&lt;<span class="number">0</span>&gt;(var); <span class="comment">// 通过 index 获取对应值</span></span><br><span class="line">        cout &lt;&lt; str &lt;&lt; endl;</span><br><span class="line">        cout &lt;&lt; i &lt;&lt; endl;</span><br><span class="line">    &#125; <span class="built_in">catch</span>(...) &#123;</span><br><span class="line">        <span class="comment">// xxx;</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意：一般情况下 variant 的第一个类型一般要有对应的构造函数，否则编译失败：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">A</span> &#123;</span><br><span class="line">    <span class="built_in">A</span>(<span class="type">int</span> i)&#123;&#125;  </span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::variant&lt;A, <span class="type">int</span>&gt; var; <span class="comment">// 编译失败</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如何避免这种情况呢，可以使用 <code>std::monostate</code> 来打个桩，模拟一个空状态。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">std::variant&lt;std::monostate, A&gt; var; <span class="comment">// 可以编译成功</span></span><br></pre></td></tr></table></figure><h2 id="12-std-optional"><a href="#12-std-optional" class="headerlink" title="12.std::optional"></a>12.std::optional</h2><p><a href="https://en.cppreference.com/w/cpp/utility/optional">https://en.cppreference.com/w/cpp/utility/optional</a></p><p>有的时候，我们想在异常的时候抛出一个异常的对象，亦或者是在出现一些不可预期的错误的时候，返回一个空值。要怎么区分空值和异常的对象呢？</p><p>在 python 中，我们有一个专门的 None 对象可以来处理这件事。在 MySQL 中，我们也有 NULL 来标识空；但在 CPP 中，我们只剩下一个 <code>nullptr</code>，其本质是个<strong> 指针</strong>，与 Py 中的 None 和 MySQL 中的 NULL 完全不同！如果想用指针来区分空和异常对象，那就需要用到动态内存管理，亦或者是用智能指针来避免内存泄漏。</p><p>说人话就是，在 CPP 中没有一个类似 None 的含义为空的对象，来告诉调用这个程序的人，到底是发生了错误，生成了一个错误的对象，还是说压根什么都没有弄出来。</p><p>于是 <code>std::optional</code> 就出现了，其可以包含一个类型，并有 <code>std::nullopt</code> 来专门标识“空”这个含义。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;optional&gt;</span></span></span><br><span class="line"><span class="function">std::optional&lt;<span class="type">int</span>&gt; <span class="title">StoI</span><span class="params">(<span class="type">const</span> std::string &amp;s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> std::<span class="built_in">stoi</span>(s);</span><br><span class="line">    &#125; <span class="built_in">catch</span>(...) &#123;</span><br><span class="line">        <span class="keyword">return</span> std::<span class="literal">nullopt</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::string s&#123;<span class="string">&quot;123&quot;</span>&#125;;</span><br><span class="line">    std::optional&lt;<span class="type">int</span>&gt; o = <span class="built_in">StoI</span>(s);</span><br><span class="line">    <span class="keyword">if</span> (o) &#123;</span><br><span class="line">        cout &lt;&lt; *o &lt;&lt; endl;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;error&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里我们进行了 if 的判断，首先判断变量 o 本身，为真代表的确返回了一个 int 值，为假代表返回的是<code>nullopt</code>；</p><p>随后再使用 <code>*o</code> 来访问到内部托管的成员。</p><p>需要注意这里是两层的逻辑关系，只有 optional 对象中成功托管了一个指定的参数类型，其本身才是真的。如果想访问它托管的对象，则需要用解引用。</p><p>比如这里，我们的 o 对象托管的是一个 bool 类型的假，但假并不代表空，o 对象本身的判断是真，内部对 <code>*o</code> 的判断才是判断托管的 bool 值到底是真是假。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;optional&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::optional&lt;<span class="type">bool</span>&gt; o = <span class="literal">false</span>;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">typeid</span>(o).<span class="built_in">name</span>() &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">if</span> (o) <span class="comment">// 这里判断的是 optional 对象是否有托管一个 bool 值</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(*o)&#123; <span class="comment">// 这里判断的是托管的 bool 值本身</span></span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;true&quot;</span> &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;false&quot;</span> &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123; <span class="comment">// 这里则代表托管的是 nullopt</span></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;error&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最终运行打印的结果是<code>false</code>；</p><h1 id="13-std-any"><a href="#13-std-any" class="headerlink" title="13.std::any"></a>13.std::any</h1><p><a href="https://en.cppreference.com/w/cpp/utility/any">https://en.cppreference.com/w/cpp/utility/any</a></p><p>这个类型可以托管任意类型的值，与之对应的还有一个 <code>std::any_cast</code> 来将其托管的值转成我们需要的类型。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;any&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123; <span class="comment">// c++17 可编译</span></span><br><span class="line">    std::any a = <span class="number">1</span>;</span><br><span class="line">    cout &lt;&lt; a.<span class="built_in">type</span>().<span class="built_in">name</span>() &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; std::<span class="built_in">any_cast</span>&lt;<span class="type">int</span>&gt;(a) &lt;&lt; endl;</span><br><span class="line">    a = <span class="number">2.2f</span>;</span><br><span class="line">    cout &lt;&lt; a.<span class="built_in">type</span>().<span class="built_in">name</span>() &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; std::<span class="built_in">any_cast</span>&lt;<span class="type">float</span>&gt;(a) &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">if</span> (a.<span class="built_in">has_value</span>()) &#123;</span><br><span class="line">        cout &lt;&lt; a.<span class="built_in">type</span>().<span class="built_in">name</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    a.<span class="built_in">reset</span>();</span><br><span class="line">    <span class="keyword">if</span> (a.<span class="built_in">has_value</span>()) &#123;</span><br><span class="line">        cout &lt;&lt; a.<span class="built_in">type</span>().<span class="built_in">name</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    a = std::<span class="built_in">string</span>(<span class="string">&quot;a&quot;</span>);</span><br><span class="line">    cout &lt;&lt; a.<span class="built_in">type</span>().<span class="built_in">name</span>() &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; std::<span class="built_in">any_cast</span>&lt;std::string&gt;(a) &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">i 1</span><br><span class="line">f 2.2</span><br><span class="line">fNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEE a</span><br></pre></td></tr></table></figure><p>虽然 any 的出现让 cpp 也在一定程度上能实现“弱类型”变量，但在具体的开发中，明确变量的类型依旧比使用 any 好得多。特别是在变量的类型并不可以被直接转换的情况下。</p><h1 id="14-std-apply"><a href="#14-std-apply" class="headerlink" title="14.std::apply"></a>14.std::apply</h1><p>使用 <code>std::apply</code> 可以将 tuple 展开作为函数的参数传入，见代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;tuple&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">add</span><span class="params">(<span class="type">int</span> first, <span class="type">int</span> second)</span> </span>&#123; <span class="keyword">return</span> first + second; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> add_lambda = [](<span class="keyword">auto</span> first, <span class="keyword">auto</span> second) &#123; <span class="keyword">return</span> first + second; &#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; std::<span class="built_in">apply</span>(add, std::<span class="built_in">pair</span>(<span class="number">1</span>, <span class="number">2</span>)) &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="built_in">add</span>(std::<span class="built_in">pair</span>(<span class="number">1</span>, <span class="number">2</span>)) &lt;&lt; <span class="string">&quot;\n&quot;</span>; <span class="comment">// error</span></span><br><span class="line">    std::cout &lt;&lt; std::<span class="built_in">apply</span>(add_lambda, std::<span class="built_in">tuple</span>(<span class="number">2.0f</span>, <span class="number">3.0f</span>)) &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="15-std-make-from-tuple"><a href="#15-std-make-from-tuple" class="headerlink" title="15.std::make_from_tuple"></a>15.std::make_from_tuple</h1><p>使用 make_from_tuple 可以将 tuple 展开作为构造函数参数</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Foo</span> &#123;</span><br><span class="line">    <span class="built_in">Foo</span>(<span class="type">int</span> first, <span class="type">float</span> second, <span class="type">int</span> third) &#123;</span><br><span class="line">        std::cout &lt;&lt; first &lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; second &lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; third &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   <span class="keyword">auto</span> tuple = std::<span class="built_in">make_tuple</span>(<span class="number">42</span>, <span class="number">3.14f</span>, <span class="number">0</span>);</span><br><span class="line">   std::<span class="built_in">make_from_tuple</span>&lt;Foo&gt;(std::<span class="built_in">move</span>(tuple));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="16-std-string-view"><a href="#16-std-string-view" class="headerlink" title="16.std::string_view"></a>16.std::string_view</h1><p><a href="https://zhuanlan.zhihu.com/p/166359481">https://zhuanlan.zhihu.com/p/166359481</a></p><p><a href="https://en.cppreference.com/w/cpp/string/basic_string_view">https://en.cppreference.com/w/cpp/string/basic_string_view</a></p><p>如果我们只需要一个 string 的只读类型的话，可以用 string_view 来托管。其内部只包含一个指向目标字符串的指针，以及字符串的长度。</p><p>string_view 内部封装了 string 的所有只读接口，本来就是给你读的。</p><p>需要注意的是，因为内部只有一个指针，所以当 string_view 托管的 string 被销毁了，与之关联的所有 string_view 都会失效！同样是因为内部只有一个指针和字符串的长度两个变量，所以在传值拷贝的时候，string_view 的效率会高很多。</p><ul><li>这和<code>const string&amp;</code> 类型的传值又有什么区别呢？传引用不是也没有拷贝消耗吗？</li></ul><p>这个问题很好，我不知道！百度也没有百度出来……</p><p>我能想到的就是用 <code>string_view</code> 作为参数的时候，如果入参是一个常量字符串，此时不需要构造 string，而使用<code>const string&amp;</code> 接受常量字符串的时候依旧需要构造一个 string 对象。这部分就会有一定的消耗。</p><h1 id="17-as-const"><a href="#17-as-const" class="headerlink" title="17.as_const"></a>17.as_const</h1><p>C++17 使用 as_const 可以将左值转成 const 类型</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">std::string str = <span class="string">&quot;str&quot;</span>;</span><br><span class="line"><span class="type">const</span> std::string&amp; constStr = std::<span class="built_in">as_const</span>(str);</span><br></pre></td></tr></table></figure><h1 id="18-file-system"><a href="#18-file-system" class="headerlink" title="18.file_system"></a>18.file_system</h1><p>C++17 正式将 file_system 纳入标准中，提供了关于文件的大多数功能，基本上应有尽有，这里简单举几个例子：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> fs = std::filesystem;</span><br><span class="line">fs::<span class="built_in">create_directory</span>(dir_path); <span class="comment">// 创建文件或者路径</span></span><br><span class="line">fs::<span class="built_in">copy_file</span>(src, dst, fs::copy_options::skip_existing); <span class="comment">// 文件 cp</span></span><br><span class="line">fs::<span class="built_in">exists</span>(filename); <span class="comment">// 文件是否存在</span></span><br><span class="line">fs::<span class="built_in">current_path</span>(err_code); <span class="comment">// 获取当前路径</span></span><br></pre></td></tr></table></figure><h1 id="19-shared-mutex"><a href="#19-shared-mutex" class="headerlink" title="19.shared_mutex"></a>19.shared_mutex</h1><p>这玩意是个读写锁。简单介绍一下什么是读写锁：</p><ul><li>读者可以有多个，写者只能有一个</li><li>写锁是互斥的，如果 A 有锁，B 想拿锁就得阻塞等待</li><li>读锁是共享的，C 有读锁，D 也想读，两个人可以一起看</li><li>读写锁是互斥的，有人写的时候不能读，有人读的时候不能写</li></ul><p>换到专业术语上，就是分为独占锁（写锁）和共享锁（读锁）；</p><p>在 C++14 中其实已经有了一个<code>shared_timed_mutex</code>，C++17 中这个锁的操作与其基本一致，只不过多了几个和时间相关的接口</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">try_lock_for</span>(...);</span><br><span class="line"><span class="built_in">try_lock_shared_for</span>(...);</span><br><span class="line"><span class="built_in">try_lock_shared_until</span>(...);</span><br><span class="line"><span class="built_in">try_lock_until</span>(...);</span><br></pre></td></tr></table></figure><p>具体使用可以参考 </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">https://zh.cppreference.com/w/cpp/thread/shared_mutex</span><br><span class="line">https://zhuanlan.zhihu.com/p/610781321</span><br></pre></td></tr></table></figure><h1 id="The-end"><a href="#The-end" class="headerlink" title="The end"></a>The end</h1><p>关于 C++17 常用的基本就是这些了，后续遇到新的再更新本文。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;学习 C++17 的新特性&lt;/p&gt;
&lt;h1 id=&quot;1- 构造函数模板推导&quot;&gt;&lt;a href=&quot;#1- 构造函数模板推导&quot; class=&quot;headerlink&quot; title=&quot;1. 构造函数模板推导&quot;&gt;&lt;/a&gt;1. 构造函数模板推导 &lt;/h1&gt;&lt;p&gt; 在之前，我们如果想用 </summary>
      
    
    
    
    <category term="遇见C++" scheme="https://blog.musnow.top/categories/%E9%81%87%E8%A7%81C/"/>
    
    
    <category term="C++" scheme="https://blog.musnow.top/tags/C/"/>
    
    <category term="数据结构" scheme="https://blog.musnow.top/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    <category term="C++17" scheme="https://blog.musnow.top/tags/C-17/"/>
    
  </entry>
  
  <entry>
    <title>【面经】230915 上海戎磐网络科技 C/LINUX 实习生</title>
    <link href="https://blog.musnow.top/posts/2553205100/"/>
    <id>https://blog.musnow.top/posts/2553205100/</id>
    <published>2023-09-15T06:50:14.000Z</published>
    <updated>2023-09-15T06:50:14.000Z</updated>
    
    <content type="html"><![CDATA[<p>10 分钟就面完了，堪称急速，面试官说我答的不错；而且上来自我介绍完毕后就问问题，不多比比🤣</p><span id="more"></span><h1 id="知识点"><a href="# 知识点" class="headerlink" title="知识点"></a>知识点 </h1><h2 id="1-Linux 下线程互斥怎么实现"><a href="#1-Linux 下线程互斥怎么实现" class="headerlink" title="1.Linux 下线程互斥怎么实现"></a>1.Linux 下线程互斥怎么实现</h2><p> 加锁，pthread，然后我还提到了 cpp 的原子变量</p><p><a href="https://blog.musnow.top/posts/1309150756/">https://blog.musnow.top/posts/1309150756/</a></p><h2 id="2-CPP 多态怎么实现"><a href="#2-CPP 多态怎么实现" class="headerlink" title="2.CPP 多态怎么实现"></a>2.CPP 多态怎么实现 </h2><p> 虚函数表，巴拉巴拉</p><p><a href="https://blog.musnow.top/posts/3933786088/">https://blog.musnow.top/posts/3933786088/</a></p><h2 id="3-CPP 为啥要引入模板"><a href="#3-CPP 为啥要引入模板" class="headerlink" title="3.CPP 为啥要引入模板"></a>3.CPP 为啥要引入模板 </h2><p> 代码更高复用</p><p><a href="https://blog.musnow.top/posts/2940029419/">https://blog.musnow.top/posts/2940029419/</a></p><h2 id="4-NAT 怎么实现的？"><a href="#4-NAT 怎么实现的？" class="headerlink" title="4.NAT 怎么实现的？"></a>4.NAT 怎么实现的？</h2><p>转化表，IP 地址替换，巴拉巴拉吧说一大堆</p><p><a href="https://blog.musnow.top/posts/3482559497/">https://blog.musnow.top/posts/3482559497/</a></p><h2 id="5- 进程通信"><a href="#5- 进程通信" class="headerlink" title="5. 进程通信"></a>5. 进程通信 </h2><p> 老问题了</p><h2 id="6-inet-ntoa 函数知道吗？连续调用会有什么问题？"><a href="#6-inet-ntoa 函数知道吗？连续调用会有什么问题？" class="headerlink" title="6.inet_ntoa 函数知道吗？连续调用会有什么问题？"></a>6.inet_ntoa 函数知道吗？连续调用会有什么问题？</h2><blockquote><p>这是最后一个问题，面试官说我答的挺好的</p></blockquote><p>我先说了这个函数是用于 16 位 IP 地址和字符串的转换的；</p><p>然后面试官这里问了一个业务上的问题</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s %s\n&quot;</span>,<span class="built_in">inet_ntoa</span>(x),<span class="built_in">inet_ntoa</span>(y));<span class="comment">// x 和 y 是两个 ip 地址</span></span><br></pre></td></tr></table></figure><p>这个函数会不会有什么错误的地方？</p><blockquote><p>请注意，这里是面试时候的描述，面试官肯定只能给你描述个大概的，并不会细致到具体的传参应该传什么类型的变量，所以传参 x 和 y 也只是个伪代码，想问的地方不在这里！</p></blockquote><p>这里我说了 <code>inet_ntoa</code> 是采用 static 变量来返回 ip 字符串的，线程不安全，有可能两个调用最终返回了一个相同的 IP 地址，又明说了我不确定；（肯定有问题，不然问你干嘛？）</p><hr><p>面试结束了，来测试一下到底是啥情况吧！</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">in_addr</span> ip1;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">in_addr</span> ip2;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">inet_aton</span>(<span class="string">&quot;192.168.3.1&quot;</span>,&amp;ip1);</span><br><span class="line">    <span class="built_in">inet_aton</span>(<span class="string">&quot;10.161.33.42&quot;</span>,&amp;ip2);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s %s\n&quot;</span>,<span class="built_in">inet_ntoa</span>(ip1),<span class="built_in">inet_ntoa</span>(ip2));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果如下，两个 IP 地址返回了同一个，我猜对了；</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ ./test</span><br><span class="line">192.168.3.1 192.168.3.1</span><br></pre></td></tr></table></figure><p>为什么呢？打印一下地址，会得到如下输出，两次调用返回了相同的地址，自然打印出来的结果相同；</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%x %x\n&quot;</span>,<span class="built_in">inet_ntoa</span>(ip1),<span class="built_in">inet_ntoa</span>(ip2));</span><br><span class="line"><span class="comment">//68db1ef0 68db1ef0</span></span><br></pre></td></tr></table></figure><p>对于这个函数而言，它需要给我们返回一个字符串，又必须保证这个字符串能在函数外被正常访问（不能被释放），再加上这是一个 C 语言接口，那么就只有三种方案了</p><ul><li>函数里面 malloc，需要用户手动 free</li><li>static 变量</li><li>让用户传入一个有效的地址，将数据写入作为输出型参数</li></ul><p>第一个方案肯定是不可行的！这相当于官方提供了一个 <strong> 极其容易导致内存泄漏 </strong> 的接口！这不得被开发者喷死？比如本题提到的场景里面就是两次 printf 而已，除此之外没有保存这个返回值，更别提 free 了，这里就直接两次内存泄漏了！</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s %s\n&quot;</span>,inet_ntoa(ip1),inet_ntoa(ip2));</span><br><span class="line"><span class="comment">// 如果用 malloc 后的字符串地址做返回值，这里就是两个内存泄漏</span></span><br></pre></td></tr></table></figure><p>第三个方案也不方便，系统依赖用户传入一个数组的入参，我们知道 ipv4 的 IP 地址字符串最长是 <code>3*4+3=15</code> 位，那么如果用户只传入一个 <code>char arr[12]</code> 呢？越界访问的问题怎么解决？相当于系统之中依旧会出现参数不匹配而可能导致的地址访问错误！</p><p><strong>而这个函数本身的工作很简单，完全没必要弄那么复杂</strong>；</p><p>最终 linux 系统采用了 static 变量的方式，来返回这个 IP 地址的字符串；man 手册里面是这么说的，直接看最后一句，翻译过来的意思是 <strong> 后续的调用会覆盖掉前面的值</strong>；</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"> The inet_ntoa() function converts the Internet host address in, </span><br><span class="line"> given in network byte order, to a string in IPv4 dotted-decimal notation.  </span><br><span class="line"> The string  is returned in a statically allocated buffer,</span><br><span class="line">which subsequent calls will overwrite.</span><br></pre></td></tr></table></figure><p>所以最终我们看到的结果就是两次打印出了相同的 IP 地址；</p><p>这里还涉及到第二个知识点，<a href="https://blog.musnow.top/posts/3888883052/">printf 的传参顺序</a>;</p><p>简单说来就是 printf 是从右往左执行的（其实所有函数的传参都是这样，这也是为什么缺省值要从右边往左给）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s %s\n&quot;</span>,<span class="built_in">inet_ntoa</span>(ip1),<span class="built_in">inet_ntoa</span>(ip2));</span><br></pre></td></tr></table></figure><p>这里的执行顺序如下</p><ul><li>ip2 结构体传给函数，转成 ip 地址字符串后存在 static 变量中</li><li>ip1 结构体传给函数，转成 ip 地址字符串后存在了 static 变量中，覆盖了 ip2 的结果</li></ul><p>最终打印出来的两个字符串都是 ip1 的地址！</p><p>对于 <code>inet_aton</code> 函数而言，<strong>正确的调用 </strong> 办法是每次调用后都取走返回的 IP 地址字符串，可以用 <code>std::string</code> 接收，也可以用 strcmp 拷贝到一个自己定义的字符串数组变量中；</p><p>你学会了吗，骚年？</p><blockquote><p><code>inet_aton</code>这个函数最早出现于本站的此博客：<a href="https://blog.musnow.top/posts/368672249/">【Linux】来写一个 udp 的服务端 + 客户端</a></p></blockquote><h1 id="项目"><a href="# 项目" class="headerlink" title="项目"></a>项目 </h1><p> 因为是 cpp 的岗位，所以没有问 python 的机器人项目问题；</p><h2 id="1- 视频点播传一半关闭了怎么解决"><a href="#1- 视频点播传一半关闭了怎么解决" class="headerlink" title="1. 视频点播传一半关闭了怎么解决"></a>1. 视频点播传一半关闭了怎么解决 </h2><p> 两次面试都问到了这个问题，我提到了将新的文件和本地已有文件进行校验，跳过已有数据</p><h2 id="2- 传一半剩下的数据后端怎么处理，什么时候删除？"><a href="#2- 传一半剩下的数据后端怎么处理，什么时候删除？" class="headerlink" title="2. 传一半剩下的数据后端怎么处理，什么时候删除？"></a>2. 传一半剩下的数据后端怎么处理，什么时候删除？</h2><p>我提到了前后端用 md5 验证来确认视频文件无误，如果有问题，可以设置一个定时器，一小时后删除错误的数据</p><h2 id="3- 用户修改了视频后上传怎么处理？"><a href="#3- 用户修改了视频后上传怎么处理？" class="headerlink" title="3. 用户修改了视频后上传怎么处理？"></a>3. 用户修改了视频后上传怎么处理？</h2><p>同第一个，进行一定的数据校验，然后再复写没有的数据；</p><blockquote><p>然而这些功能我一个都没有实现🤣</p></blockquote><h1 id="效率"><a href="# 效率" class="headerlink" title="效率"></a>效率 </h1><p> 面经还没写完，结果已经出啦，过了初试！但是要线下复试；</p>]]></content>
    
    
    <summary type="html">230915上海戎磐网络科技C/LINUX实习生</summary>
    
    
    
    <category term="求职路上一去不复返" scheme="https://blog.musnow.top/categories/%E6%B1%82%E8%81%8C%E8%B7%AF%E4%B8%8A%E4%B8%80%E5%8E%BB%E4%B8%8D%E5%A4%8D%E8%BF%94/"/>
    
    
    <category term="面经" scheme="https://blog.musnow.top/tags/%E9%9D%A2%E7%BB%8F/"/>
    
  </entry>
  
  <entry>
    <title>【MySQL】字节跳动 MySQL 连环 40 问</title>
    <link href="https://blog.musnow.top/posts/3873856211/"/>
    <id>https://blog.musnow.top/posts/3873856211/</id>
    <published>2023-09-15T00:52:14.000Z</published>
    <updated>2023-09-15T00:52:30.000Z</updated>
    
    <content type="html"><![CDATA[<p>字节 MySQL 连环 40 问，网图</p><span id="more"></span><p><img src="https://img.musnow.top/i/2023/09/188abb653b96cb823385befe4c196698.jpg" alt="QQ 图片 20230915081943"></p><p>虽然感觉这玩意和字节跳动没关系，但是管他的？直接开始回答！</p><h1 id="1-MySQL 中有哪几种锁？"><a href="#1-MySQL 中有哪几种锁？" class="headerlink" title="1.MySQL 中有哪几种锁？"></a>1.MySQL 中有哪几种锁？</h1><blockquote><p>会的不全，所以查的 GPT</p></blockquote><p>MySQL 中有多种类型的锁，主要包括以下几种：</p><ol><li>共享锁（Shared Lock）：也称为 <strong> 读锁</strong>，多个会话可以同时持有共享锁，并且不互斥。共享锁适用于读取操作，多个会话可以并发读取同一份数据而不会产生冲突。</li><li>排他锁（Exclusive Lock）：也称为 <strong> 写锁</strong>，排他锁与其他任何锁都互斥，只有一个会话可以持有排他锁。排他锁适用于写入或修改操作，确保在某个会话持有排他锁的时候，其他会话无法同时进行写入操作。</li><li>记录锁（Record Lock）：记录锁（<strong>行锁</strong>）是针对某条记录的锁定，用于保护特定记录的完整性。在使用 InnoDB 存储引擎时，读取或修改某条记录时会自动给该记录加上记录锁，其他会话则无法对该记录进行并发写入或删除操作。</li><li>Gap 锁：Gap 锁是 InnoDB 引擎的一种锁机制，<strong>用于防止幻读</strong>。它锁定了一个范围，但不包含实际的记录，用于防止其他会话在这个范围内插入新记录，以避免幻读现象的发生。</li><li>表锁（Table Lock）：表锁是对整个表格进行锁定，可以在某些特殊情况下使用，但会阻塞其他会话的读取和写入操作。在需要并发读写的情况下，表锁的性能较低，因此一般不推荐使用。</li></ol><p>除此之外，还有一个 NEXT-KEY 锁：</p><p>NEXT-KEY 锁是 InnoDB 存储引擎中的一种锁机制，用于 <strong> 解决幻读 </strong> 问题。它是通过将 Gap 锁和 记录锁 组合而成的。</p><p>具体来说，当一个事务在 InnoDB 表中执行范围查询时，如使用 <code>&lt;</code>、<code>&lt;=</code>、<code>&gt;</code>、<code>&gt;=</code> 等操作符，InnoDB 引擎会为查询涉及到的范围加上 NEXT-KEY 锁。这个 NEXT-KEY 锁包含两部分：</p><ol><li>Gap 锁：锁定了查询范围内的间隙（Gap），防止其他事务向该范围内插入新的记录。</li><li>记录锁：锁定了满足查询条件的记录，防止其他事务对这些记录进行并发修改或删除。</li></ol><p>通过使用 NEXT-KEY 锁，InnoDB 可以有效地避免幻读现象的发生。它保证了在一个事务读取一个范围的数据时，<strong>其他事务无法并发地在该范围内插入新的记录</strong>，从而保证了读取的一致性。</p><p>需要注意的是，NEXT-KEY 锁只在事务隔离级别为 <strong> 可重复读</strong>（REPEATABLE READ）或更高级别时使用（MySQL 默认隔离级别为可重复读）。在较高的并发环境下，使用 NEXT-KEY 锁可能会增加锁冲突的概率，因此在设计数据库和查询时需要考虑到锁的开销和事务的隔离级别。</p><h1 id="2-MySQL 中有哪些不同的表格？"><a href="#2-MySQL 中有哪些不同的表格？" class="headerlink" title="2.MySQL 中有哪些不同的表格？"></a>2.MySQL 中有哪些不同的表格？</h1><blockquote><p>这个也是 GPT 回答的，注意，表格和存储引擎不是同一个概念！</p></blockquote><p>在 MySQL 中，有以下几种不同的表格类型：</p><ol><li>MyISAM：MyISAM 是旧版本 MySQL 的默认表格类型。它提供了快速的读取速度，适用于大量的并发读取操作。不过，MyISAM 不支持事务处理和崩溃恢复功能。</li><li>InnoDB：InnoDB 是一种支持事务处理和崩溃恢复功能的表格类型。它提供了行级锁定和外键约束等高级功能，适用于需要数据完整性和并发写入操作的场景。InnoDB 是 <strong>MySQL 5.5 版本后</strong> 的默认表格类型。</li><li>Memory：Memory（也称为 Heap）表格是将数据存储在内存中的临时表格类型。它在读取和写入方面非常快速，但它的数据是临时的，当数据库服务器重启时，表格中的数据将会丢失。</li><li>Archive：Archive 表格是一种高度压缩的表格类型，适用于存储大量历史数据和归档数据。它对于读取操作不太有效，但在大量写入和存储空间方面具有优势。</li><li>CSV：CSV 表格允许将数据以 CSV（逗号分隔值）格式存储在文件中，支持导入和导出数据。它不支持索引，事务处理和其他高级特性。</li></ol><p>除了以上列举的几种常见的表格类型外，MySQL 还支持其他一些特殊用途的表格类型，如 Partitioned（分区表格）和 Federated（联合表格）等。</p><ul><li>表格和存储引擎是同一个东西吗？并 <strong> 不是</strong>！</li></ul><p>在关系型数据库中，表格（Table）是指一个逻辑上的数据结构，用来组织和存储数据。一张表格由若干列（Column）和若干行（Row）组成，每列定义了一种数据类型和一个字段名，表格中的每一行则代表一个实体或记录，每个单元格存储着对应列的一个数值或字符串。</p><p>存储引擎（Storage Engine）则是指实现了数据库的表格和索引等功能的底层软件模块，它负责将表格数据存储到磁盘、跟踪并处理事务、执行查询语句等任务。不同的存储引擎具有各自的特点和优缺点，在不同场景下选择合适的存储引擎可以提高数据库的性能和可靠性。</p><h1 id="3-MyISAM 和 InnoDB 的区别？"><a href="#3-MyISAM 和 InnoDB 的区别？" class="headerlink" title="3.MyISAM 和 InnoDB 的区别？"></a>3.MyISAM 和 InnoDB 的区别？</h1><p>MyISAM</p><ul><li>不支持事务；</li><li>采用非聚簇索引，普通索引和主键索引的形式相同；</li><li>一张表包含三个本地文件；</li></ul><p>InnoDB</p><ul><li>支持事务；</li><li>采用聚簇索引，普通索引存放的是主键索引中的 key 值，需要回表查询；可以用索引覆盖来优化；</li><li>一张表包含两个本地文件；</li></ul><h1 id="4-InnoDB 支持的四种事务隔离级别和区别"><a href="#4-InnoDB 支持的四种事务隔离级别和区别" class="headerlink" title="4.InnoDB 支持的四种事务隔离级别和区别"></a>4.InnoDB 支持的四种事务隔离级别和区别 </h1><p> 四种隔离级别：读未提交，读已提交，可重复读，串行化；</p><p>这部分直接去看我的 <a href="https://blog.musnow.top/posts/3474107655/">MySQL 索引</a> 博客，里面详细介绍了区别，这里就不重写一遍了；</p><h1 id="5-CHAR 和 VARCHAR 的区别"><a href="#5-CHAR 和 VARCHAR 的区别" class="headerlink" title="5.CHAR 和 VARCHAR 的区别"></a>5.CHAR 和 VARCHAR 的区别</h1><ul><li>char 是定长字符串，最长 255；varchar 是变长字符串，最长 65535；</li><li>这就意味着 varchar 需要更多空间来存放当前字符串长度等信息，并且会根据当前字符串长度动态开辟空间大小，不会有额外的存储空间浪费；</li><li>而 char 是定死的空间，<code>char(8)</code>里面即便只有一个字符也会占用八个的空间（会用空格进行补齐）；</li><li>在字符串长度确定的情况下，比如计算长度确定的 MD5，那就可以用 char 定长存储；长度不确定的情况下，比如人名、邮箱等信息，可以采用 varchar；</li></ul><p>顺带说一下 varchar 和 text 的区别；需要进行索引的长文可以用 TEXT 进行存储（注意，只有 MyISAM 支持全文索引）</p><ol><li>存储空间：VARCHAR 列存储的内容长度是可变的，而 TEXT 列可以存储大量的可变长度的文本数据。VARCHAR 在存储时会根据实际存储的内容长度进行调整，而 TEXT 没有固定的最大长度限制，可以用来存储非常长的文本。由于 TEXT 可以存储更大的数据量，因此它通常占用更多的存储空间。</li><li>查询性能：由于 VARCHAR 具有固定的最大长度限制，数据库可以更好地优化和管理存储空间，这可能会在某些情况下提升查询性能。而 TEXT 由于其可变长度和大容量，可能会对某些查询操作稍有影响。</li><li>索引和排序：VARCHAR 可以被索引和排序，这意味着可以根据这些列进行快速搜索和排序操作。而 TEXT 类型通常不直接支持索引和排序，需要额外的配置和处理才能实现类似的功能。</li></ol><p>如下 user1 表做测试，会发现我们无法给 TEXT 类型上普通索引。给出的提示是，<code>BLOG/TEXT</code>类型不能在没有指定长度的时候上索引；因为你的长度不确定，如果 MySQL 将一个几万字的 TEXT 存到内存里面作为索引节点，那么就会占用过多的内存空间。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">MariaDB [hello_mysql]&gt; desc user1;</span><br><span class="line">+-------+------------------+------+-----+---------+-------+</span><br><span class="line">| Field | Type             | Null | Key | Default | Extra |</span><br><span class="line">+-------+------------------+------+-----+---------+-------+</span><br><span class="line">| id    | int(10) unsigned | NO   | PRI | NULL    |       |</span><br><span class="line">| name  | varchar(200)     | NO   |     | NULL    |       |</span><br><span class="line">| info  | text             | NO   |     | NULL    |       |</span><br><span class="line">+-------+------------------+------+-----+---------+-------+</span><br><span class="line">3 rows in set (0.001 sec)</span><br><span class="line">MariaDB [hello_mysql]&gt; alter table user1 add index(info);</span><br><span class="line">ERROR 1170 (42000): BLOB/TEXT column &#x27;info&#x27; used in key specification without a key length</span><br></pre></td></tr></table></figure><p>即便在创建列的时候给定了 TEXT 的长度，依旧不能创建索引。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">MariaDB [hello_mysql]&gt; alter table user1 add info1 TEXT(20) NOT NULL;</span><br><span class="line">Query OK, 0 rows affected (0.002 sec)</span><br><span class="line">Records: 0  Duplicates: 0  Warnings: 0</span><br><span class="line"></span><br><span class="line">MariaDB [hello_mysql]&gt; desc user1;</span><br><span class="line">+-------+------------------+------+-----+---------+-------+</span><br><span class="line">| Field | Type             | Null | Key | Default | Extra |</span><br><span class="line">+-------+------------------+------+-----+---------+-------+</span><br><span class="line">| id    | int(10) unsigned | NO   | PRI | NULL    |       |</span><br><span class="line">| name  | varchar(200)     | NO   |     | NULL    |       |</span><br><span class="line">| info  | text             | NO   |     | NULL    |       |</span><br><span class="line">| info1 | tinytext         | NO   |     | NULL    |       |</span><br><span class="line">+-------+------------------+------+-----+---------+-------+</span><br><span class="line">4 rows in set (0.001 sec)</span><br><span class="line"></span><br><span class="line">MariaDB [hello_mysql]&gt; alter table user1 add index(info1);</span><br><span class="line">ERROR 1170 (42000): BLOB/TEXT column &#x27;info1&#x27; used in key specification without a key length</span><br></pre></td></tr></table></figure><p>正确的写法如下，需要在创建索引的时候，括号指定索引的长度；比如 <code>index(info1(10))</code> 含义就是给 info1 列的前 10 个字符建立索引。只要 TEXT 里面存放的文本前 10 个字符重复率低，那么这个索引就是有意义的！</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">MariaDB [hello_mysql]&gt; alter table user1 add index(info1(10));</span><br><span class="line">Query OK, 0 rows affected (0.007 sec)</span><br><span class="line">Records: 0  Duplicates: 0  Warnings: 0</span><br></pre></td></tr></table></figure><h1 id="6- 主键和候选键 - 码 - 有啥区别？"><a href="#6- 主键和候选键 - 码 - 有啥区别？" class="headerlink" title="6. 主键和候选键 (码) 有啥区别？"></a>6. 主键和候选键 (码) 有啥区别？</h1><p>候选键是一些可以选用（备选）为主键或者唯一键的类型；</p><p>比如一个学生表里面，包含学生主键的 INT 自增 ID，学生学号，学生身份证，学生姓名，学生性别等等信息；在这个表里面，除了主键这个 INT 的 ID，我们还可以把学生的学号和学生的身份证作为主键或者唯一键，因为他们都包含唯一性！</p><p>这时候，这些可以作为主键的列，就叫做候选键；</p><ul><li>候选键也需要保持唯一性</li><li>候选键需要遵循最小原则，不能是某一个聚合唯一标识的子集；（比如我需要用 <strong> 部门 ID 和部门内员工 ID</strong>来唯一标识一个员工，此时部门 ID 就不能作为这个员工表的候选键，因为在整个表中部门 ID 会重复）</li></ul><p>在《数据库系统概率》这门课里面，会把键称作为码，本质上是一个东西。</p><blockquote><p>到底是谁把 key 翻译成码的？真无语😒</p></blockquote><h1 id="7-myisamchk 是用来干什么的"><a href="#7-myisamchk 是用来干什么的" class="headerlink" title="7.myisamchk 是用来干什么的"></a>7.myisamchk 是用来干什么的 </h1><p> 一个命令行工具（在 bash 下使用，不是在 MySQL 命令行使用）</p><blockquote><p>Myisamchk 是 MyISAM 表维护的一个非常实用的工具。可以使用 myisamchk 实用程序来获得有关数据库表的信息或检查、修复、优化他们。myisamchk 适用 MyISAM 表(对应.MYI 和.MYD 文件的表)。</p></blockquote><p>这个命令了解即可，下面是两篇使用博客。有需要再去深入学习用法</p><p><a href="http://www.4u4v.net/myisamchk-gadgets-manual.html">http://www.4u4v.net/myisamchk-gadgets-manual.html</a></p><p><a href="https://www.cnblogs.com/analyzer/articles/1381538.html">https://www.cnblogs.com/analyzer/articles/1381538.html</a></p><h1 id="8- 如果表中有一列定义为 TIMESTAMP 会发生什么"><a href="#8- 如果表中有一列定义为 TIMESTAMP 会发生什么" class="headerlink" title="8. 如果表中有一列定义为 TIMESTAMP 会发生什么"></a>8. 如果表中有一列定义为 TIMESTAMP 会发生什么</h1><p>TIMESTAMP 底层一般是 4 个字节，在 MySQL 里面进行查询的时候，会根据系统时区，转成可读时间进行输出。包括使用 cpp devel 包获取到的也是可读时间；</p><p>因为只有 4 个字节，所以 TIMESTAMP 最多能表示 <code>1970-01-01 00:00:01</code>到<code>2038-01-19 03:14:07</code>，这也是一个 2038 年问题，需要改成 8 字节存储才能存放更长的时间。</p><p>另外，如果你想更加精确的标识时间，而不依赖于 MySQL 对时间戳的自动转换，那么就可以用 BIGINT 或者 DECIMAL 类型来存放时间戳数字，再在应用层进行时间戳和可读时间之间的转换。</p><h1 id="9- 怎么看到表格定义的所有索引"><a href="#9- 怎么看到表格定义的所有索引" class="headerlink" title="9. 怎么看到表格定义的所有索引"></a>9. 怎么看到表格定义的所有索引 </h1><p> 两种方式都可以</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> index <span class="keyword">from</span> 表名;</span><br><span class="line"><span class="keyword">show</span> keys <span class="keyword">from</span> 表名;</span><br></pre></td></tr></table></figure><h1 id="10-LIKE 声明中的 - 是什么意思"><a href="#10-LIKE 声明中的 - 是什么意思" class="headerlink" title="10.LIKE 声明中的 % 是什么意思"></a>10.LIKE 声明中的 % 是什么意思 </h1><p> 代表通配符，匹配所有字符串。下面举几个例子</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">查询 &#x27; 张 %&#x27;</span><br><span class="line">    张丽丽 </span><br><span class="line">    张扣扣</span><br><span class="line">    张三</span><br><span class="line">    张阿斯顿</span><br><span class="line"></span><br><span class="line"> 查询 &#x27;% 张 %&#x27;</span><br><span class="line">里张里 </span><br><span class="line">    十大张撒打发</span><br><span class="line"></span><br><span class="line"> 查询 &#x27;% 张 &#x27;</span><br><span class="line">xx 张</span><br><span class="line">xxxxx 张</span><br></pre></td></tr></table></figure><p>需要注意，只有 <code> 关键字 %</code>的使用方式才能用上索引，另外两种匹配方式无法使用索引！</p><h1 id="11- 列对比运算符是什么"><a href="#11- 列对比运算符是什么" class="headerlink" title="11. 列对比运算符是什么"></a>11. 列对比运算符是什么 </h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"> 等于 =</span><br><span class="line">不等于 &lt;&gt; !=</span><br><span class="line">大于和大于等于  &gt; &gt;=</span><br><span class="line">小于和小于等于  &lt; &lt;=</span><br><span class="line">区间 BETWEEN .. AND ...</span><br><span class="line">是否在列表中 IN</span><br><span class="line">模糊匹配 LIKE</span><br><span class="line">NULL 比较 IS NULL, IS NOT NULL</span><br></pre></td></tr></table></figure><h1 id="12-BLOB 和 TEXT 有什么区别？"><a href="#12-BLOB 和 TEXT 有什么区别？" class="headerlink" title="12.BLOB 和 TEXT 有什么区别？"></a>12.BLOB 和 TEXT 有什么区别？</h1><p>GPT 说的：</p><ol><li>存储容量：BLOB 可以存储二进制数据，而 TEXT 只能存储纯文本数据。</li><li>字符集排序规则：BLOB 没有字符集排序规则，而 TEXT 有，默认为字符集的排序规则。</li><li>数据排序和比较：BLOB 会按二进制方式进行排序和比较，而 TEXT 会按字符排序规则进行排序和比较。</li><li>存储方式：BLOB 数据以二进制形式存储，没有字符集转换；而 TEXT 数据会根据字符集进行转换和存储。</li><li>索引：在 MySQL 中，BLOB 和 TEXT 列可以有索引，但有一些限制。BLOB 列或前缀索引的最大长度是 768 字节，对于 UTF-8 字符集是 255 个字符。而 TEXT 列或前缀索引的最大长度是 3072 字节，在 UTF-8 字符集中是 1024 个字符。</li><li>默认值：BLOB 和 TEXT 列不能具有默认值。</li></ol><p>总的来说，BLOB 适合存储二进制数据，例如图像、音频或视频文件等。而 TEXT 适合存储纯文本数据，如长文本、文章内容等。根据具体的需求，你可以选择适当的数据类型来存储相应的数据。</p><blockquote><p>实际上，把图片、音频这些静态资源存入数据库是不合理的……</p></blockquote><h1 id="13-MySQL-fetch-array 和 MySQL-fetch-obj 有什么区别？"><a href="#13-MySQL-fetch-array 和 MySQL-fetch-obj 有什么区别？" class="headerlink" title="13.MySQL_fetch_array 和 MySQL_fetch_obj 有什么区别？"></a>13.MySQL_fetch_array 和 MySQL_fetch_obj 有什么区别？</h1><p>PHP 里面的函数，不学，直接跳过</p><h1 id="14-MyISAM 表格将在那里存储？并且还提供其存储格式？"><a href="#14-MyISAM 表格将在那里存储？并且还提供其存储格式？" class="headerlink" title="14.MyISAM 表格将在那里存储？并且还提供其存储格式？"></a>14.MyISAM 表格将在那里存储？并且还提供其存储格式？</h1><p>在 linux 下，MyISAM 表格以文件形式存储在数据目录下的对应数据库目录中。每个表格对应一个.MYD 数据文件（用于存储表格数据）和一个.MYI 索引文件（用于存储表格索引），以及一个.frm 表格定义文件（包含表格定义信息，如字段名、数据类型等）</p><p>MyISAM 使用一种称为“静态行格式”的存储格式来存储表格数据。这种格式用于在磁盘上保存由定长行组成的表格，每个行定长，占用相同的存储空间，以便更快地读取和写入数据。MyISAM 表格还支持动态行格式，这种格式允许可变行长度，因此可以更有效地存储可变长度的数据类型（如 VARCHAR，TEXT 等）。</p><h1 id="15-MySQL 如何优化 DISTINCT"><a href="#15-MySQL 如何优化 DISTINCT" class="headerlink" title="15.MySQL 如何优化 DISTINCT?"></a>15.MySQL 如何优化 DISTINCT?</h1><p>使用索引，减少查询行数来优化去重操作</p><h1 id="16- 如何显示前 50 行？"><a href="#16- 如何显示前 50 行？" class="headerlink" title="16. 如何显示前 50 行？"></a>16. 如何显示前 50 行？</h1><p>查询语句后带上 limit 就可以</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> 表名 limit <span class="number">50</span>;</span><br></pre></td></tr></table></figure><h1 id="17- 可以使用多少列创建索引？"><a href="#17- 可以使用多少列创建索引？" class="headerlink" title="17. 可以使用多少列创建索引？"></a>17. 可以使用多少列创建索引？</h1><p>根据实际使用场景来确定用几列，并没有固定限制。理论上来说需要保持最小原则，不要包含多余的无效列（除非你需要用来进行索引优化，减少回表操作）</p><h1 id="18-now 和 current-date 有什么区别？"><a href="#18-now 和 current-date 有什么区别？" class="headerlink" title="18.now 和 current_date 有什么区别？"></a>18.now 和 current_date 有什么区别？</h1><p>now 会返回一直到时分秒的信息，current_date 只会返回当日日期</p><h1 id="19- 什么是非标准字符串类型"><a href="#19- 什么是非标准字符串类型" class="headerlink" title="19. 什么是非标准字符串类型"></a>19. 什么是非标准字符串类型</h1><blockquote><p>GPT</p></blockquote><p>非标准字符串类型是指在数据库中没有明确定义或标准化的字符串数据类型。这些类型通常是特定数据库管理系统（DBMS）或应用程序开发框架所支持的扩展。由于不同的 DBMS 和框架有各自的特性和需求，可能会引入额外的非标准字符串类型以满足特定的数据存储和操作需求。</p><p>举例来说，MySQL 数据库在其标准字符串类型中包含了 CHAR、VARCHAR、TEXT 等。而非标准字符串类型可能是根据具体需求和扩展开发的，如 JSON、XML、BLOB、CLOB 等。这些非标准类型在一些特定场景中使用广泛，例如存储非结构化的文本数据、大型二进制数据、以及存储和查询复杂的结构化数据等。</p><p>需要注意的是，非标准字符串类型在不同的 DBMS 和开发框架之间可能存在差异，并且在跨平台和迁移时可能会出现兼容性问题。因此，在使用非标准字符串类型时，建议仔细了解相关的文档和规范，并评估其对应用程序的影响和可移植性。</p><h1 id="20- 什么是通用 SQL 函数"><a href="#20- 什么是通用 SQL 函数" class="headerlink" title="20. 什么是通用 SQL 函数"></a>20. 什么是通用 SQL 函数 </h1><p> 以下列举了一些常见的通用 SQL 函数：</p><ol><li>聚合函数：如 SUM、AVG、COUNT、MIN、MAX 等，用于对数据进行统计和聚合计算。</li><li>字符串函数：如 CONCAT、SUBSTRING、UPPER、LOWER、LENGTH 等，用于处理和操作字符串数据。</li><li>数值函数：如 ABS、ROUND、CEILING、FLOOR 等，用于执行数值计算和转换。</li><li>日期和时间函数：如 DATE, TIME, YEAR, MONTH, DAY 等，用于处理日期和时间数据的计算和格式化。</li><li>条件函数：如 IF, CASE WHEN, COALESCE 等，用于根据条件执行不同的逻辑和返回不同的结果。</li><li>类型转换函数：如 CAST、CONVERT 等，用于在不同的数据类型之间进行转换。</li></ol><p>这只是一小部分通用 SQL 函数的例子，实际上还有很多其他的函数可用于不同的数据处理和查询需求。需要注意的是，尽管这些函数在大多数 DBMS 中都存在，但某些特定的 DBMS 可能会提供额外的函数或有稍微不同的语法，因此在使用函数时应查阅相应的文档和规范以确保兼容性和正确性。</p><h1 id="21-MySQL 支持事务吗？"><a href="#21-MySQL 支持事务吗？" class="headerlink" title="21.MySQL 支持事务吗？"></a>21.MySQL 支持事务吗？</h1><p>肯定支持，这个问题第四点就已经详细问了</p><h1 id="22-MySQL 里面记录货币用什么类型好？"><a href="#22-MySQL 里面记录货币用什么类型好？" class="headerlink" title="22.MySQL 里面记录货币用什么类型好？"></a>22.MySQL 里面记录货币用什么类型好？</h1><p>因为浮点数的精度问题，可以用 BIGINT 来存放以 <strong> 分</strong>为单位的货币，实际调用的时候再加上小数点，来保证数据准确。</p><p>如果不用 BIGINT，那就需要用 DECIMAL 来存放货币。</p><blockquote><p>B 站冲浪看到的</p></blockquote><h1 id="23-MySQL 有关权限的表有那几个"><a href="#23-MySQL 有关权限的表有那几个" class="headerlink" title="23.MySQL 有关权限的表有那几个"></a>23.MySQL 有关权限的表有那几个 </h1><p> 在 MySQL 中，有几个与权限相关的系统表和视图，用于管理用户、角色和权限。以下是一些常见的权限相关的表和视图：</p><ol><li>mysql.user：这个表包含了 MySQL 实例上的所有用户账户信息，包括用户名、密码等。该表记录了每个用户的全局权限。</li><li>mysql.db：这个表记录了用户对数据库级别的权限。它指定了哪个用户对哪个数据库具有什么样的权限。</li><li>mysql.tables_priv：这个表记录了用户对表级别的权限。它存储了用户对某个具体表的权限信息（如 SELECT、INSERT、UPDATE、DELETE 等）。</li><li>mysql.columns_priv：这个表记录了用户对列级别的权限。它存储了用户对表中某个具体列的权限信息。</li><li>mysql.procs_priv：这个表记录了用户对存储过程和函数的权限。</li><li>mysql.roles：这个表存储了角色的相关信息，包括角色名、角色的创建者等。</li></ol><p>除了上述的表之外，MySQL 还提供了一些权限相关的视图，这些视图可以方便地查看用户、角色和权限的信息，如：</p><ul><li>information_schema.USER_PRIVILEGES：显示所有用户的权限信息。</li><li>information_schema.SCHEMA_PRIVILEGES：显示所有数据库的权限信息。</li><li>information_schema.TABLE_PRIVILEGES：显示所有表的权限信息。</li><li>information_schema.COLUMN_PRIVILEGES：显示所有列的权限信息。</li></ul><p>如下是个使用示例</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> information_schema.USER_PRIVILEGES;</span><br></pre></td></tr></table></figure><p>这些表和视图可以通过查询相应的系统表或视图来查看和管理用户、角色和权限。请注意，具体的系统表和视图名称可能因 MySQL 版本和配置而有所不同。为了确保准确性，请参考 MySQL 官方文档或特定版本的文档。</p><h1 id="24- 列的字符串类型可以是什么"><a href="#24- 列的字符串类型可以是什么" class="headerlink" title="24. 列的字符串类型可以是什么"></a>24. 列的字符串类型可以是什么</h1><p>TEXT CHAR VARCHAR，详见第五点</p><h1 id="25-MySQL 作为发布系统的存储，一天五万条以上的增量，预计运维三年，如何优化？"><a href="#25-MySQL 作为发布系统的存储，一天五万条以上的增量，预计运维三年，如何优化？" class="headerlink" title="25.MySQL 作为发布系统的存储，一天五万条以上的增量，预计运维三年，如何优化？"></a>25.MySQL 作为发布系统的存储，一天五万条以上的增量，预计运维三年，如何优化？</h1><blockquote><p>没见过这种业务，只能问 GPT</p></blockquote><p>对于一个 MySQL 作为发布系统存储的场景，处理每天超过五万条增量数据并且需要保持三年的数据，以下是一些优化建议：</p><ol><li>数据库硬件和配置优化：<ul><li>硬件性能：确保数据库服务器具备足够的计算、内存和存储资源，以处理高负载的写入和读取操作。</li><li>存储设备：使用高性能的存储设备（如 SSD）来提高写入和读取速度。</li><li>MySQL 参数调优：根据实际情况调整 MySQL 的配置参数，例如设置合理的缓冲区大小、并发连接数、查询缓存等。</li></ul></li><li>数据库架构优化：<ul><li>分库分表：考虑将数据进行分库分表来分担单个数据库的负载压力。根据数据的特点和访问模式，合理划分数据到不同的库表中。</li><li>索引优化：根据查询需求创建合适的索引，以加快查询速度。避免过多的索引和冗余索引，以减少维护成本。</li><li>分区表：如果数据的时间范围有明显的界限，可以考虑使用 MySQL 的分区表功能，将数据按时间范围进行分区，提高查询性能和维护效率。</li></ul></li><li>数据写入优化：<ul><li>批量插入：使用批量插入方式（如 INSERT INTO … VALUES (), (), ()…）来减少单条插入的开销，提高写入性能。</li><li>事务处理：将多个写入操作放在一个事务中，确保数据的一致性和完整性，减少 IO 开销。</li></ul></li><li>数据归档和压缩：<ul><li>数据归档：对于历史数据，可以将其归档到独立的存储介质中，例如将旧数据迁移到归档数据库或者离线存储系统中以减轻主数据库的负载。</li><li>数据压缩：对于不频繁查询的历史数据，可以考虑使用压缩算法（例如 MySQL 的压缩表功能或者第三方压缩库）进行存储，以减少存储空间占用。</li></ul></li><li>监控和优化工具：<ul><li>使用监控工具实时监测数据库的性能指标，如查询速度、磁盘使用、锁等情况，及时发现潜在的性能瓶颈并进行调优。</li><li>使用性能优化工具，如 Explain 分析、慢查询日志等，来找出慢查询和低效的 SQL 语句，并进行优化。</li></ul></li></ol><p>以上是一些常见的优化建议，具体优化方案还需要根据实际场景和需求进行调整。同时，建议在进行优化前，充分了解应用的读写特征、数据访问模式和业务需求，以便有针对性地进行优化工作。</p><h1 id="26- 锁的优化策略？"><a href="#26- 锁的优化策略？" class="headerlink" title="26. 锁的优化策略？"></a>26. 锁的优化策略？</h1><h1 id="27- 索引的底层实现和优化？"><a href="#27- 索引的底层实现和优化？" class="headerlink" title="27. 索引的底层实现和优化？"></a>27. 索引的底层实现和优化？</h1><p>底层用 B+ 实现，优化索引方式见索引博客 <a href="https://blog.musnow.top/posts/3474107655/">https://blog.musnow.top/posts/3474107655/</a></p><h1 id="28- 什么情况下有索引但是无法使用"><a href="#28- 什么情况下有索引但是无法使用" class="headerlink" title="28. 什么情况下有索引但是无法使用"></a>28. 什么情况下有索引但是无法使用 </h1><p> 索引失效，见索引博客 <a href="https://blog.musnow.top/posts/3474107655/">https://blog.musnow.top/posts/3474107655/</a></p><h1 id="29- 实践中如何优化 MySQL"><a href="#29- 实践中如何优化 MySQL" class="headerlink" title="29. 实践中如何优化 MySQL"></a>29. 实践中如何优化 MySQL</h1><p>太宽泛了，不好回答</p><ul><li>索引优化</li><li>分表</li><li>事务隔离性选择</li></ul><h1 id="30- 优化数据库的办法？"><a href="#30- 优化数据库的办法？" class="headerlink" title="30. 优化数据库的办法？"></a>30. 优化数据库的办法？</h1><p>和 29 题重合，不做回答</p><h1 id="31- 简单描述索引、主键、唯一索引、联合索引的区别，对数据库性能有什么影响（读写两方面）"><a href="#31- 简单描述索引、主键、唯一索引、联合索引的区别，对数据库性能有什么影响（读写两方面）" class="headerlink" title="31. 简单描述索引、主键、唯一索引、联合索引的区别，对数据库性能有什么影响（读写两方面）"></a>31. 简单描述索引、主键、唯一索引、联合索引的区别，对数据库性能有什么影响（读写两方面）</h1><p>见索引博客 <a href="https://blog.musnow.top/posts/3474107655/">https://blog.musnow.top/posts/3474107655/</a></p><h1 id="32- 数据库的事务是什么"><a href="#32- 数据库的事务是什么" class="headerlink" title="32. 数据库的事务是什么"></a>32. 数据库的事务是什么 </h1><p> 见事务博客 <a href="https://blog.musnow.top/posts/2200233148/">https://blog.musnow.top/posts/2200233148/</a></p><h1 id="33-SQL 注入漏洞的产生和原因，如何防止"><a href="#33-SQL 注入漏洞的产生和原因，如何防止" class="headerlink" title="33.SQL 注入漏洞的产生和原因，如何防止"></a>33.SQL 注入漏洞的产生和原因，如何防止</h1><p>SQL 注入漏洞是一种常见的安全漏洞，它可以使攻击者通过构造恶意的 SQL 语句来绕过应用程序的输入验证，进而执行非法的数据库操作或获取敏感信息。以下是 SQL 注入漏洞产生的原因和一些防止方法：</p><ol><li>原因：<ul><li>不正确的输入验证：当应用程序没有对用户的输入进行充分验证和过滤时，攻击者可以通过输入特定的字符或语句来修改 SQL 语句的结构，从而执行恶意操作。</li><li>拼接字符串构造 SQL 语句：如果应用程序使用拼接字符串的方式构造 SQL 查询语句，并且未对用户输入进行正确的转义处理，就容易受到 SQL 注入攻击。</li></ul></li><li>防止方法：<ul><li>使用参数化查询或预编译语句：参数化查询将用户输入作为参数传递给 SQL 语句，而不是直接拼接字符串。这样可以通过数据库驱动程序自动处理转义和编码，有效防止 SQL 注入攻击。</li><li>输入验证和过滤：对用户的输入数据进行验证和过滤，只接受符合规范的数据。可以使用白名单、黑名单、正则表达式等方法进行输入验证和过滤。</li><li>最小权限原则：在数据库中为应用程序使用的账号设置最小权限，即只授予应用程序完成必要操作所需的最低权限，避免攻击者利用注入漏洞进行更危险的操作。</li><li>不要直接暴露数据库错误信息：在生产环境中，不要将详细的数据库错误信息返回给用户，以防止攻击者从中获取关键信息。可以记录错误日志并给用户一个友好的错误提示。</li><li>定期更新和修补数据库和应用程序：及时安装数据库和应用程序的安全补丁，以修复已知的漏洞，并确保使用最新的安全措施。</li></ul></li></ol><p>总之，为了防止 SQL 注入漏洞，关键是要对用户输入数据进行合理验证、过滤和转义处理，并使用参数化查询或预编译语句来构造 SQL 语句。同时，保持应用程序和数据库的安全性，并及时更新和修补已知的安全漏洞。</p><h1 id="34- 如何为表中字段选择合适数据类型"><a href="#34- 如何为表中字段选择合适数据类型" class="headerlink" title="34. 如何为表中字段选择合适数据类型"></a>34. 如何为表中字段选择合适数据类型 </h1><p> 肯定是根据具体情况回答</p><h1 id="35- 存储时期？"><a href="#35- 存储时期？" class="headerlink" title="35. 存储时期？"></a>35. 存储时期？</h1><p>感觉这道题有问题，不管他</p><h1 id="36- 索引相关问题？"><a href="#36- 索引相关问题？" class="headerlink" title="36. 索引相关问题？"></a>36. 索引相关问题？</h1><p>和 31 重合，不回答</p><h1 id="37- 解释 MySQL 中外连接、内连接、自连接的区别"><a href="#37- 解释 MySQL 中外连接、内连接、自连接的区别" class="headerlink" title="37. 解释 MySQL 中外连接、内连接、自连接的区别"></a>37. 解释 MySQL 中外连接、内连接、自连接的区别</h1><ol><li>内连接（INNER JOIN）：<ul><li>内连接返回两个表中满足连接条件的记录，即只返回两个表中能够匹配的行。</li><li>内连接使用一个连接谓词（JOIN）或者在 FROM 子句中使用逗号（,）来表示。</li><li>内连接可以根据指定的连接条件将两个表中的列进行匹配。如果未提供连接条件，则会返回两个表的笛卡尔积。</li><li>语法示例：SELECT * FROM 表 1 INNER JOIN 表 2 ON 表 1. 列 &#x3D; 表 2. 列;</li></ul></li><li>外连接（OUTER JOIN）：<ul><li>外连接将返回两个表中满足连接条件的记录，并且还包括不满足连接条件的记录。</li><li>外连接分为左外连接（LEFT JOIN）和右外连接（RIGHT JOIN）。</li><li>左外连接返回左表中的所有记录，以及右表中与左表满足连接条件的记录。如果右表中没有匹配的记录，则会返回 NULL 值。</li><li>右外连接返回右表中的所有记录，以及左表中与右表满足连接条件的记录。如果左表中没有匹配的记录，则会返回 NULL 值。</li><li>语法示例：<ul><li>左外连接：SELECT * FROM 表 1 LEFT JOIN 表 2 ON 表 1. 列 &#x3D; 表 2. 列;</li><li>右外连接：SELECT * FROM 表 1 RIGHT JOIN 表 2 ON 表 1. 列 &#x3D; 表 2. 列;</li></ul></li></ul></li><li>自连接（SELF JOIN）：<ul><li>自连接是指将表视为两个独立的实例，使用别名来区分它们，然后根据某些条件将它们连接在一起。</li><li>自连接通常用于在同一个表中根据某种关系进行数据查询。</li><li>语法示例：SELECT 别名 1. 列, 别名 2. 列 FROM 表 别名 1, 表 别名 2 WHERE 别名 1. 列 &#x3D; 别名 2. 列;</li></ul></li></ol><p>总结：</p><ul><li>内连接返回两个表中匹配的记录，外连接返回满足连接条件的记录以及不满足连接条件的记录，而自连接是对同一个表进行连接操作。</li><li>内连接和外连接需要使用 JOIN 关键字，而自连接使用同一个表的别名进行连接。</li><li>内连接和外连接可以根据连接条件将两个表进行关联，而自连接可以根据表中的某些条件进行关联。</li></ul><h1 id="38-MySQL 中事务回滚机制描述"><a href="#38-MySQL 中事务回滚机制描述" class="headerlink" title="38.MySQL 中事务回滚机制描述"></a>38.MySQL 中事务回滚机制描述 </h1><p> 见事务博客 <a href="https://blog.musnow.top/posts/2200233148/">https://blog.musnow.top/posts/2200233148/</a></p><h1 id="39-SQL 语言包含哪几部分？每部分都有哪些操作关键字"><a href="#39-SQL 语言包含哪几部分？每部分都有哪些操作关键字" class="headerlink" title="39.SQL 语言包含哪几部分？每部分都有哪些操作关键字"></a>39.SQL 语言包含哪几部分？每部分都有哪些操作关键字 </h1><p> 包括 DQL 数据查询语言，DML 数据操作语言（增删改），数据控制语言 DCL 用来管理数据库，事务控制语言 TCL 用来控制事务，数据定义语言 DDL 用来创建删除表</p><ol><li>数据查询语言（Data Query Language，DQL）：用于从数据库中查询和检索数据。常用的操作关键字包括：<ul><li>SELECT：用于从一个或多个表中选择数据列以进行查询。</li><li>FROM：指定要查询的表。</li><li>WHERE：用于指定查询的条件。</li><li>GROUP BY：按照指定的列对结果进行分组。</li><li>HAVING：用于指定对分组后的结果进行筛选的条件。</li><li>ORDER BY：指定结果集的排序方式。</li></ul></li><li>数据操作语言（Data Manipulation Language，DML）：用于对数据库中的数据进行增加、修改和删除操作。常用的操作关键字包括：<ul><li>INSERT INTO：向表中插入新的行或数据。</li><li>UPDATE：更新表中已有的数据。</li><li>DELETE FROM：从表中删除指定的行或数据。</li></ul></li><li>数据定义语言（Data Definition Language，DDL）：用于创建、修改和删除数据库和表结构。常用的操作关键字包括：<ul><li>CREATE DATABASE：创建新的数据库。</li><li>CREATE TABLE：创建新的数据表。</li><li>ALTER TABLE：修改已存在的数据表结构。</li><li>DROP DATABASE：删除现有的数据库。</li><li>DROP TABLE：删除现有的数据表。</li></ul></li><li>数据控制语言（Data Control Language，DCL）：用于管理数据库中的用户权限和访问权限。常用的操作关键字包括：<ul><li>GRANT：授予用户特定的权限。</li><li>REVOKE：撤销用户的权限。</li></ul></li><li>事务控制语言（Transaction Control Language，TCL）：用于管理数据库的事务处理。常用的操作关键字包括：<ul><li>COMMIT：提交一个事务，使其永久生效。</li><li>ROLLBACK：回滚一个事务，撤销之前的操作，使其不生效。</li><li>SAVEPOINT：在事务中设置保存点，以便在需要时进行回滚。</li></ul></li></ol><h1 id="40- 完整性的约束包括那些？"><a href="#40- 完整性的约束包括那些？" class="headerlink" title="40. 完整性的约束包括那些？"></a>40. 完整性的约束包括那些？</h1><p>原子性、隔离性、持久性；这里说的完整性应该就是一致性；</p><p>具体的解释依旧是去看事务的博客 <a href="https://blog.musnow.top/posts/2200233148/">https://blog.musnow.top/posts/2200233148/</a></p>]]></content>
    
    
    <summary type="html">字节MySQL连环40问</summary>
    
    
    
    <category term="学习sql" scheme="https://blog.musnow.top/categories/%E5%AD%A6%E4%B9%A0sql/"/>
    
    
    <category term="mysql" scheme="https://blog.musnow.top/tags/mysql/"/>
    
  </entry>
  
  <entry>
    <title>【面经】230913 上海零念科技 CPP 实习生</title>
    <link href="https://blog.musnow.top/posts/2719794733/"/>
    <id>https://blog.musnow.top/posts/2719794733/</id>
    <published>2023-09-13T09:32:14.000Z</published>
    <updated>2023-09-13T10:32:14.000Z</updated>
    
    <content type="html"><![CDATA[<p>230913 上海零念科技 CPP 实习生面试记录</p><span id="more"></span><p>上来先做了个自我介绍，然后面试官介绍了他们是做系统进程调度的；</p><h1 id="CPP"><a href="#CPP" class="headerlink" title="CPP"></a>CPP</h1><p>题目顺序并非实际问的顺序</p><h2 id="1- 类的大小"><a href="#1- 类的大小" class="headerlink" title="1. 类的大小"></a>1. 类的大小 </h2><p> 类的大小和什么东西有关系？</p><p>我答了成员变量和虚函数表</p><h2 id="2- 多态怎么实现的"><a href="#2- 多态怎么实现的" class="headerlink" title="2. 多态怎么实现的"></a>2. 多态怎么实现的 </h2><p> 顺着虚函数表问的，就说了一下动态多态的基本实现方式</p><h2 id="3- 只能在栈上的类"><a href="#3- 只能在栈上的类" class="headerlink" title="3. 只能在栈上的类"></a>3. 只能在栈上的类 </h2><p> 禁止拷贝构造和赋值，构造函数私有化，提供单独函数在栈上开辟空间；</p><p>顺便问了一下动态内存管理的基础形式</p><h2 id="4- 智能指针"><a href="#4- 智能指针" class="headerlink" title="4. 智能指针"></a>4. 智能指针 </h2><p> 哪些类型？有啥区别？weak ptr 怎么解决循环引用问题的？</p><p>weak ptr 的 lock 函数用过吗？有没有办法获取到 shared ptr 的引用计数？</p><p>unique_ptr 可以转成 share_ptr 吗？</p><p>如果要用 C++11 的类型转换，要使用哪一个来进行 unique_ptr 和 share_ptr 的转换？（这个不会，应该是 static_cast）</p><p>定制删除器是干嘛的？</p><p>智能指针线程安全吗？</p><p>拷贝构造 share_ptr 会不会有内存泄漏？</p><h2 id="5- 类型转换"><a href="#5- 类型转换" class="headerlink" title="5. 类型转换"></a>5. 类型转换</h2><p>C++11 的类型转换，几个，区别是什么？</p><p>指针之间转换要用什么？（不会，答的 static）</p><p>dynamic_cast 父子转换的时候，向上还是向下是安全的？（子转成父是安全的，即向上安全）</p><h2 id="6- 单例"><a href="#6- 单例" class="headerlink" title="6. 单例"></a>6. 单例 </h2><p> 几种类型，怎么实现？</p><h2 id="7- 模板"><a href="#7- 模板" class="headerlink" title="7. 模板"></a>7. 模板 </h2><p> 模板的声明和定义为啥不能分离？（忘记了）</p><p>模板特化是什么？函数模板支持半特化吗？（不支持）</p><h2 id="8-C- 线程和 async 有啥区别？"><a href="#8-C- 线程和 async 有啥区别？" class="headerlink" title="8.C++ 线程和 async 有啥区别？"></a>8.C++ 线程和 async 有啥区别？</h2><p>thread 是类，aysnc 是函数</p><p>async 有两种用法，一个是立马异步执行，会开一个线程；第二个是延迟同步执行，在使用 <code>future.get</code> 的时候才会执行。</p><p>这部分是在云账房面试的时候问道的，得亏我专门去学了，开心！</p><h2 id="9-C-14 新特性"><a href="#9-C-14 新特性" class="headerlink" title="9.C++14 新特性"></a>9.C++14 新特性 </h2><p> 知道的全说了，auto，lambda 新特性，constexpr（和 c++11 的区别），变量模板，二进制变量，然后还说了最后几个 std 的函数看不明白；面试官人很好，一直说没关系；</p><p>专门问了 <code>constexpr</code> 声明变量和 const 有啥区别（不知道）</p><blockquote><p>GPT 的回答</p><ol><li>时间点：<code>constexpr</code> 是在编译时确定值的，而 <code>const</code> 是在运行时确定值的。</li><li>编译期计算：<code>constexpr</code> 变量可以用于编译时期间的计算，比如数组大小、模板参数等需要在编译阶段确定大小的场景。而 <code>const</code> 变量只是表示它的值不可以修改，在编译阶段无法使用 <code>const</code> 变量进行编译期计算。</li><li>初始化：<code>constexpr</code> 变量必须在声明时进行初始化，并且只能使用常量表达式初始化；<code>const</code> 变量可以在声明时初始化，也可以稍后赋值，但赋值后就不能再修改。</li><li>地址：<code>constexpr</code> 变量往往会被编译器优化，可能不会占用内存空间，并且在编译期间被消除。<code>const</code> 变量在运行时分配内存，并且有相应的内存地址。</li><li>但是这两个关键字声明的变量都具有常量属性，不可修改；</li></ol></blockquote><p>对 C++17 有没有了解？（无）</p><h2 id="10-stl 用过什么？"><a href="#10-stl 用过什么？" class="headerlink" title="10.stl 用过什么？"></a>10.stl 用过什么？</h2><p>把常用的 stl 都说了一遍</p><p>stl 线程安全吗？当然不</p><h2 id="11-vector 和 array 区别"><a href="#11-vector 和 array 区别" class="headerlink" title="11.vector 和 array 区别"></a>11.vector 和 array 区别</h2><p>array 是定长数组，vector 动态开辟</p><p>array 可以使用迭代器，保证代码风格统一</p><p>这里顺便提到了 <code>[]</code> 的重载，面试官问了 vector 里面 at 函数和 <code>[]</code> 重载的区别（at 会抛异常，<code>[]</code>不会）</p><h2 id="12-emplace-back 和 push-back 区别"><a href="#12-emplace-back 和 push-back 区别" class="headerlink" title="12.emplace_back 和 push_back 区别"></a>12.emplace_back 和 push_back 区别 </h2><p> 我说了 emplace_back 能节省一次拷贝的消耗；</p><p>面试官问要怎么使用才能节省这个消耗？使用方式（不会）</p><p>emplace_back 既然高效，为啥没有取代 push_back？（不会，这里我就说了一下设计考虑兼容性的问题）</p><h2 id="13- 初始化列表、构造函数体内初始化、成员变量给缺省值"><a href="#13- 初始化列表、构造函数体内初始化、成员变量给缺省值" class="headerlink" title="13. 初始化列表、构造函数体内初始化、成员变量给缺省值"></a>13. 初始化列表、构造函数体内初始化、成员变量给缺省值 </h2><p> 那个更好？有啥区别？</p><p>引用是没有办法使用缺省值的，只有常量 &#x2F; 普通变量可以用缺省值；</p><p>在 VS2019 里面调试测试了一下运行顺序：</p><ul><li>缺省值（会优化成初始化列表）&#x2F; 初始化列表</li><li>函数体内</li></ul><p>具体的测试参考 <a href="https://blog.musnow.top/posts/2894176175/">CPP 类和对象默认成员函数</a>，里面详细注明了构造顺序；</p><h2 id="14- 默认构造函数"><a href="#14- 默认构造函数" class="headerlink" title="14. 默认构造函数"></a>14. 默认构造函数 </h2><p> 什么时候可以不自己写构造函数？</p><p>这里没有答全，感觉自己已经被绕晕了</p><h2 id="15-function 和 bind 的作用"><a href="#15-function 和 bind 的作用" class="headerlink" title="15.function 和 bind 的作用"></a>15.function 和 bind 的作用 </h2><p> 如题</p><h2 id="16-final-x2F-overide-x2F-explicit"><a href="#16-final-x2F-overide-x2F-explicit" class="headerlink" title="16.final&#x2F;overide&#x2F;explicit"></a>16.final&#x2F;overide&#x2F;explicit</h2><p>作用</p><p>explicit 忘记了，<strong>面试官说没关系，反正也不用</strong>🤣</p><h1 id="Linux"><a href="#Linux" class="headerlink" title="Linux"></a>Linux</h1><h2 id="1- 进程通信"><a href="#1- 进程通信" class="headerlink" title="1. 进程通信"></a>1. 进程通信 </h2><p> 有哪些，这里主要问了共享内存和管道的优劣，使用谁的资源消耗更优（这里问的是资源消耗，不是通信速度）</p><blockquote><p>我答的是因为管道是文件描述符，操作系统需要维护文件和进程之间的关系，所以消耗会高一点；然后共享内存是直接在页表上操作，没有额外的消耗；</p><p>咱也不知道对不对，感觉答案应该是下面这个</p><p><img src="https://img.musnow.top/i/2023/09/17766a5a0226a48b578aed58d9ed5c1d.png" alt="image-20230913212808024"></p></blockquote><p>问有没有用过消息队列（知道这玩意，没用过）</p><h2 id="2- 进程和线程区别"><a href="#2- 进程和线程区别" class="headerlink" title="2. 进程和线程区别"></a>2. 进程和线程区别 </h2><p> 说了资源消耗区别，功能比较隔离的时候适合用进程，还举了个 epoll 的 reactor 模式的例子（我瞎编的，说实话，也不知道对不对）</p><h2 id="3- 开发环境"><a href="#3- 开发环境" class="headerlink" title="3. 开发环境"></a>3. 开发环境 </h2><p> 前期用 vs2019，后期用 vscode+remote ssh；</p><p>面试官问我很多个文件怎么进行编译和管理，我说了 makefile；问有没有用过 cmake（无）</p><h2 id="4- 编译链接过程"><a href="#4- 编译链接过程" class="headerlink" title="4. 编译链接过程"></a>4. 编译链接过程 </h2><p> 这个其实是第一个问的问题，就简单地说了一下；</p><h2 id="5- 动静态库"><a href="#5- 动静态库" class="headerlink" title="5. 动静态库"></a>5. 动静态库 </h2><p> 有啥区别？优缺点？</p><h1 id="The-end"><a href="#The-end" class="headerlink" title="The end"></a>The end</h1><p>没有问网络，也没有写 OJ，也没有问项目；</p><p>这次的面试官很耐心，会引导你回答问题。爱了；</p>]]></content>
    
    
    <summary type="html">230913上海零念科技CPP实习生</summary>
    
    
    
    <category term="求职路上一去不复返" scheme="https://blog.musnow.top/categories/%E6%B1%82%E8%81%8C%E8%B7%AF%E4%B8%8A%E4%B8%80%E5%8E%BB%E4%B8%8D%E5%A4%8D%E8%BF%94/"/>
    
    
    <category term="面经" scheme="https://blog.musnow.top/tags/%E9%9D%A2%E7%BB%8F/"/>
    
  </entry>
  
  <entry>
    <title>【MySQL】事务</title>
    <link href="https://blog.musnow.top/posts/2200233148/"/>
    <id>https://blog.musnow.top/posts/2200233148/</id>
    <published>2023-09-10T00:52:14.000Z</published>
    <updated>2023-09-10T00:52:30.000Z</updated>
    
    <content type="html"><![CDATA[<p>学习了之后，你会对 MySQL 如何进行数据的访问控制有更深刻的了解；</p><span id="more"></span><p>本文中有大量截图，如果出现 404 的图片，请评论告知，谢谢；</p><h1 id="1- 什么是事务？"><a href="#1- 什么是事务？" class="headerlink" title="1. 什么是事务？"></a>1. 什么是事务？</h1><h2 id="1-1- 场景举例"><a href="#1-1- 场景举例" class="headerlink" title="1.1 场景举例"></a>1.1 场景举例 </h2><h3 id="1-1-1- 转账"><a href="#1-1-1- 转账" class="headerlink" title="1.1.1 转账"></a>1.1.1 转账</h3><p> 当 A 需要给 B 转账 50 元的时候，后台应该进行如何处理？</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 先判断用户还有多少余额（这里的 user_id=A 只是一个示例，知道什么意思就行）</span></span><br><span class="line"><span class="keyword">select</span> money <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">where</span> user_id<span class="operator">=</span>A;</span><br><span class="line"><span class="comment">-- 如果余额充足，那就给 A 扣 50</span></span><br><span class="line"><span class="keyword">update</span> <span class="keyword">user</span> <span class="keyword">set</span> money <span class="operator">=</span> money <span class="operator">-</span> <span class="number">50</span> <span class="keyword">where</span> user_id<span class="operator">=</span>A;</span><br><span class="line"><span class="comment">-- 然后给 B 加 50</span></span><br><span class="line"><span class="keyword">update</span> <span class="keyword">user</span> <span class="keyword">set</span> money <span class="operator">=</span> money <span class="operator">+</span> <span class="number">50</span> <span class="keyword">where</span> user_id<span class="operator">=</span>B;</span><br></pre></td></tr></table></figure><p>这一个操作，需要 3 个 SQL 语句才能完成，但很明显，我们即便在当前的服务器端对这 3 条语句的操作进行加锁，也没有办法避免如下的情况</p><ul><li>服务器负载过高，进程被 kill 了</li><li>服务器断电了</li><li>MySQL 服务器抽风挂掉了</li><li>等等不可抗力</li></ul><p>这时候，如果在执行第一条查询语句后就挂掉了，那还不会有啥问题；但如果是在执行完毕第二条扣钱的语句之后挂掉了，那问题就大了！</p><ul><li>A 给 B 转钱，A 的钱扣了，B 的钱没有加，这怎么可以？</li></ul><p>最终还需要程序员通过 MySQL 的日志一个个核对到底是谁出现了这样的情况，给人家把钱加回去，那太过麻烦；在数据量大的时候，这种工作更是不应该由人工手动完成的！</p><p>所以，MySQL 就需要提供一种方法，让我们能够实现类似原子性的操作。在执行这 3 条语句的时候，<strong>只能出现两种情况</strong>：</p><ul><li>成功执行，A 扣了钱，B 也加了钱，转账成功；</li><li>执行失败，但是 A 和 B 的钱都没有变化，并告知用户转账失败；</li></ul><p>这样才是靠谱的结果！</p><h3 id="1-1-2- 卖票"><a href="#1-1-2- 卖票" class="headerlink" title="1.1.2 卖票"></a>1.1.2 卖票 </h3><p> 另外 <span id="jump1"> 一个场景 </span> 就是卖票，其也包含了多条 SQL</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> ticket <span class="keyword">where</span> tid<span class="operator">=</span>?; <span class="comment">-- 查询某某车次高铁的票还有没有余量</span></span><br><span class="line"><span class="comment">-- 有余量，进行售卖流程；这里可能要操作另外一张表来添加买票者的用户信息</span></span><br><span class="line"><span class="keyword">update</span> ticket <span class="keyword">set</span> num<span class="operator">=</span>num<span class="number">-1</span> <span class="keyword">where</span> tid<span class="operator">=</span>?; <span class="comment">-- 售卖流程结束，扣去这张票</span></span><br></pre></td></tr></table></figure><p>如果有两个客户端都同时来执行这两条 SQL 语句，那么就会出现问题；</p><ul><li>只剩一张票</li><li>客户端 A 进行查询，发现有票，开始执行卖票流程</li><li>客户端 B 进行查询，也发现有票，开始执行卖票流程</li><li>此时 A 执行完毕，将票的数量 -1，卖完票了；</li><li>随后 B 执行完毕，也将票的数量 -1，此时就会出现票数是负数的情况！</li><li>更难受的是，同一张票被错误地卖给了两个用户！</li></ul><p>这时候在客户端里面加锁是不顶用的，两个客户端都不是同一个进程，锁无法共享；需要 MySQL 解决这个问题，就还得提供更加严格的访问控制，在 A 没有完成整个卖票逻辑，票数没有扣掉的情况下，<strong>B 不可以来查询票数</strong>；</p><h2 id="1-2- 事务的介绍"><a href="#1-2- 事务的介绍" class="headerlink" title="1.2 事务的介绍"></a>1.2 事务的介绍 </h2><p> 事务（transaction）就是一组 DML 语句的集合，这些语句在逻辑上是一个整体；执行这组语句，必须全部成功，亦或者是全部失败。</p><p>在执行这组 SQL 的时候，MySQL 需要将其视作一个原子性的操作；这个操作不能被其他事务打断，出现问题的时候还需要回滚到开始执行之前的初始状态；事务还能使不同客户端看到的数据是不同的，不同事务之间的操作不会相互影响；只有事务结束后，双方才能看到对方的操作（根据隔离级别不同，这点也会有区别）；</p><p>正如上面的两个场景所提到的操作，同一个时刻对于 MySQL 的一个数据库来说，其可能有多个客户端进行不同业务的操作，如果都在访问同一个表，在不加访问控制的情况下，一定会出现访问临界资源的数据二义性问题。</p><blockquote><p>事务的出现，是客户端在实际应用场景下的需要，</p></blockquote><p>所以，一个完整的事务，除了是多条 DML 语句的集合，还需要满足下面 4 个特性</p><ul><li>原子性：一个事务中的所有操作，要么全部完成，要么全部失败；如果事务在执行过程中发现错误，那就需要回滚（Rollback）到事务开始之前的状态，就好比这个事务并没有执行过一般</li><li>一致性：事务开始之前和结束后，数据库的完整性没有被破坏。进行的操作复合我们预设的要求；这包含数据的准确度、串联性以及后续数据库可以自发完成预定的工作；</li><li>隔离性：数据库允许多个并发事务同时对数据库中的数据进行 CURD 操作，隔离性保证这些事务之间的操作并不会由于并发的交叉运行而出现不一致的情况。事务隔离性分为不同级别，具体的区别会在后文详解<ul><li>读未提交（Read Uncommitted）</li><li>读已提交（Read Committed）</li><li>可重复读（Repeatble Read）</li><li>串行化（Serializable）</li></ul></li><li>持久性：事务处理完毕后，对事务的修改是永久的，即便系统宕机了也不会丢失（除非硬盘坏了）</li></ul><p>上面的四个属性，简称为 ACID；</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">原子性（Atomicity，或称不可分割性）</span><br><span class="line">一致性（Consistency）</span><br><span class="line">隔离性（Isolation，又称独立性）</span><br><span class="line">持久性（Durability）</span><br></pre></td></tr></table></figure><p>其中，一致性是由原子性、隔离性、持久性来保证的，只要满足了这三个性质，自然能实现一致性。简单记忆，AID 来保证 C；</p><h2 id="1-3- 事务的存储引擎支持"><a href="#1-3- 事务的存储引擎支持" class="headerlink" title="1.3 事务的存储引擎支持"></a>1.3 事务的存储引擎支持 </h2><p> 在 MySQL 中，只有 <code>Innodb</code> 支持事务，<code>MyISAM</code>是不支持事务的；</p><p>我们可以用如下语句来查询 MySQL 的引擎和支持的特性</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line">MariaDB [hello_mysql]<span class="operator">&gt;</span> <span class="keyword">show</span> engines \G</span><br><span class="line"><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span> <span class="number">1.</span> <span class="type">row</span> <span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span></span><br><span class="line">      Engine: MEMORY</span><br><span class="line">     Support: YES</span><br><span class="line">     Comment: Hash based, stored <span class="keyword">in</span> memory, useful <span class="keyword">for</span> temporary tables</span><br><span class="line">Transactions: <span class="keyword">NO</span></span><br><span class="line">          XA: <span class="keyword">NO</span></span><br><span class="line">  Savepoints: <span class="keyword">NO</span></span><br><span class="line"><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span> <span class="number">2.</span> <span class="type">row</span> <span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span></span><br><span class="line">      Engine: MRG_MyISAM</span><br><span class="line">     Support: YES</span><br><span class="line">     Comment: Collection <span class="keyword">of</span> identical MyISAM tables</span><br><span class="line">Transactions: <span class="keyword">NO</span></span><br><span class="line">          XA: <span class="keyword">NO</span></span><br><span class="line">  Savepoints: <span class="keyword">NO</span></span><br><span class="line"><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span> <span class="number">3.</span> <span class="type">row</span> <span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span></span><br><span class="line">      Engine: CSV</span><br><span class="line">     Support: YES</span><br><span class="line">     Comment: Stores tables <span class="keyword">as</span> CSV files</span><br><span class="line">Transactions: <span class="keyword">NO</span></span><br><span class="line">          XA: <span class="keyword">NO</span></span><br><span class="line">  Savepoints: <span class="keyword">NO</span></span><br><span class="line"><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span> <span class="number">4.</span> <span class="type">row</span> <span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span></span><br><span class="line">      Engine: BLACKHOLE</span><br><span class="line">     Support: YES</span><br><span class="line">     Comment: <span class="operator">/</span>dev<span class="operator">/</span><span class="keyword">null</span> storage engine (anything you write <span class="keyword">to</span> it disappears)</span><br><span class="line">Transactions: <span class="keyword">NO</span></span><br><span class="line">          XA: <span class="keyword">NO</span></span><br><span class="line">  Savepoints: <span class="keyword">NO</span></span><br><span class="line"><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span> <span class="number">5.</span> <span class="type">row</span> <span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span></span><br><span class="line">      Engine: MyISAM</span><br><span class="line">     Support: YES</span><br><span class="line">     Comment: Non<span class="operator">-</span>transactional engine <span class="keyword">with</span> good performance <span class="keyword">and</span> small data footprint</span><br><span class="line">Transactions: <span class="keyword">NO</span></span><br><span class="line">          XA: <span class="keyword">NO</span></span><br><span class="line">  Savepoints: <span class="keyword">NO</span></span><br><span class="line"><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span> <span class="number">6.</span> <span class="type">row</span> <span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span></span><br><span class="line">      Engine: ARCHIVE</span><br><span class="line">     Support: YES</span><br><span class="line">     Comment: gzip<span class="operator">-</span>compresses tables <span class="keyword">for</span> a low storage footprint</span><br><span class="line">Transactions: <span class="keyword">NO</span></span><br><span class="line">          XA: <span class="keyword">NO</span></span><br><span class="line">  Savepoints: <span class="keyword">NO</span></span><br><span class="line"><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span> <span class="number">7.</span> <span class="type">row</span> <span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span></span><br><span class="line">      Engine: FEDERATED</span><br><span class="line">     Support: YES</span><br><span class="line">     Comment: Allows <span class="keyword">to</span> access tables <span class="keyword">on</span> other MariaDB servers, supports transactions <span class="keyword">and</span> more</span><br><span class="line">Transactions: YES</span><br><span class="line">          XA: <span class="keyword">NO</span></span><br><span class="line">  Savepoints: YES</span><br><span class="line"><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span> <span class="number">8.</span> <span class="type">row</span> <span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span></span><br><span class="line">      Engine: PERFORMANCE_SCHEMA</span><br><span class="line">     Support: YES</span><br><span class="line">     Comment: Performance Schema</span><br><span class="line">Transactions: <span class="keyword">NO</span></span><br><span class="line">          XA: <span class="keyword">NO</span></span><br><span class="line">  Savepoints: <span class="keyword">NO</span></span><br><span class="line"><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span> <span class="number">9.</span> <span class="type">row</span> <span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span></span><br><span class="line">      Engine: SEQUENCE</span><br><span class="line">     Support: YES</span><br><span class="line">     Comment: Generated tables filled <span class="keyword">with</span> sequential <span class="keyword">values</span></span><br><span class="line">Transactions: YES</span><br><span class="line">          XA: <span class="keyword">NO</span></span><br><span class="line">  Savepoints: YES</span><br><span class="line"><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span> <span class="number">10.</span> <span class="type">row</span> <span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span></span><br><span class="line">      Engine: InnoDB</span><br><span class="line">     Support: <span class="keyword">DEFAULT</span> <span class="comment">-- 默认引擎</span></span><br><span class="line">     Comment: Supports transactions, <span class="type">row</span><span class="operator">-</span>level locking, <span class="keyword">foreign</span> keys <span class="keyword">and</span> encryption <span class="keyword">for</span> tables <span class="comment">-- 描述</span></span><br><span class="line">Transactions: YES  <span class="comment">-- 支持事务</span></span><br><span class="line">          XA: YES  </span><br><span class="line">  Savepoints: YES  <span class="comment">-- 支持事务中的保存点</span></span><br><span class="line"><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span> <span class="number">11.</span> <span class="type">row</span> <span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span></span><br><span class="line">      Engine: Aria</span><br><span class="line">     Support: YES</span><br><span class="line">     Comment: Crash<span class="operator">-</span>safe tables <span class="keyword">with</span> MyISAM heritage</span><br><span class="line">Transactions: <span class="keyword">NO</span></span><br><span class="line">          XA: <span class="keyword">NO</span></span><br><span class="line">  Savepoints: <span class="keyword">NO</span></span><br><span class="line"><span class="number">11</span> <span class="keyword">rows</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.000</span> sec)</span><br></pre></td></tr></table></figure><h2 id="1-4- 保存点"><a href="#1-4- 保存点" class="headerlink" title="1.4 保存点"></a>1.4 保存点 </h2><p> 所谓保存点，就是在事务执行过程中，给当前的数据设置一个 savepoint，这样在出现问题的时候，可以回退到当前的数据中；就好比之后的操作没有进行一样；</p><p>游戏中的保存点其实也是这样的功能，让玩家回退到打某个 BOSS 之前，包括当时你收集的材料，都会回退到打这个 BOSS 之前的状态；</p><p>你可以理解为，是给当前的数据拍了张照片，出现问题的时候，用这个照片里面的东西复写掉新的东西。这便是保存点的作用；</p><h2 id="1-5- 基础命令操作"><a href="#1-5- 基础命令操作" class="headerlink" title="1.5 基础命令操作"></a>1.5 基础命令操作 </h2><p> 先提一下事务的开启和结束方式，以及如何设置保存点和回滚吧</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 开启，这两种方式是一样的</span></span><br><span class="line"><span class="keyword">begin</span>;</span><br><span class="line"><span class="keyword">start</span> transaction;</span><br><span class="line"><span class="comment">-- 设置保存点（名字可以自由更改，但不能有重复）</span></span><br><span class="line"><span class="keyword">savepoint</span> save1; <span class="comment">-- 创建一个保存点 save1</span></span><br><span class="line"><span class="keyword">rollback</span> <span class="keyword">to</span> save1; <span class="comment">-- 回滚到保存点 save1</span></span><br><span class="line"><span class="keyword">rollback</span>; <span class="comment">-- 回滚到事务开始</span></span><br><span class="line"><span class="comment">-- 结束</span></span><br><span class="line"><span class="keyword">commit</span>; <span class="comment">-- 提交事务</span></span><br></pre></td></tr></table></figure><h1 id="2- 使用"><a href="#2- 使用" class="headerlink" title="2. 使用"></a>2. 使用 </h1><p> 了解了事务为什么存在，下面就是来使用一下事务了；</p><h2 id="2-1- 提交方式"><a href="#2-1- 提交方式" class="headerlink" title="2.1 提交方式"></a>2.1 提交方式 </h2><p> 事务的提交方式有两种方式</p><ul><li>自动提交</li><li>手动提交</li></ul><p>默认情况下，MySQL 的自动提交是处于开启状态的</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">MariaDB [hello_mysql]&gt; show variables like &#x27;autocommit&#x27;;</span><br><span class="line">+---------------+-------+</span><br><span class="line">| Variable_name | Value |</span><br><span class="line">+---------------+-------+</span><br><span class="line">| autocommit    | ON    |</span><br><span class="line">+---------------+-------+</span><br><span class="line">1 row in set (0.001 sec)</span><br></pre></td></tr></table></figure><p>我们可以用下面的语句来设置是否开启自动提交（只对当前会话生效）</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">set</span> autocommit <span class="operator">=</span> <span class="number">0</span>; <span class="comment">-- 关闭自动提交</span></span><br><span class="line"><span class="keyword">set</span> autocommit <span class="operator">=</span> <span class="number">1</span>; <span class="comment">-- 开启</span></span><br></pre></td></tr></table></figure><p>这两个提交方式有啥区别呢？是不是开了自动提交就什么都不用管了？后文我们再通过实测来说明；</p><h2 id="2-2- 场景演示"><a href="#2-2- 场景演示" class="headerlink" title="2.2 场景演示"></a>2.2 场景演示 </h2><p> 最开始测试的时候，先将事务隔离级别设置为读未提交；请注意，不要在有生产环境的 MySQL 中进行此项操作；</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 设置全局隔离级别为读未提交</span></span><br><span class="line"><span class="keyword">set</span> <span class="keyword">global</span> transaction isolation level READ UNCOMMITTED; </span><br><span class="line"><span class="comment">-- 重启 mysql 终端后查看隔离级别</span></span><br><span class="line"><span class="keyword">select</span> @<span class="variable">@tx</span>_isolation; </span><br><span class="line"><span class="operator">+</span><span class="comment">------------------+</span></span><br><span class="line"><span class="operator">|</span> @<span class="variable">@tx</span>_isolation   <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">------------------+</span></span><br><span class="line"><span class="operator">|</span> READ<span class="operator">-</span>UNCOMMITTED <span class="operator">|</span>   <span class="comment">-- 成功设置读未提交的隔离级级别</span></span><br><span class="line"><span class="operator">+</span><span class="comment">------------------+</span></span><br><span class="line"><span class="number">1</span> <span class="type">row</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.000</span> sec)</span><br></pre></td></tr></table></figure><h3 id="2-2-1- 数据回滚演示"><a href="#2-2-1- 数据回滚演示" class="headerlink" title="2.2.1 数据回滚演示"></a>2.2.1 数据回滚演示 </h3><p> 设置完毕后，进入测试数据库，创建如下测试表</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> test_ruc(</span><br><span class="line">id <span class="type">int</span> unsigned <span class="keyword">primary</span> key,</span><br><span class="line">user_id <span class="type">int</span> unsigned <span class="keyword">not</span> <span class="keyword">null</span>,</span><br><span class="line">    name <span class="type">varchar</span>(<span class="number">30</span>) <span class="keyword">not</span> <span class="keyword">null</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>先给表里面插入几个基本的数据：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> test_ruc <span class="keyword">values</span> (<span class="number">1</span>,<span class="number">10</span>,<span class="string">&#x27; 李华 &#x27;</span>),(<span class="number">2</span>,<span class="number">20</span>,<span class="string">&#x27; 王五 &#x27;</span>);</span><br></pre></td></tr></table></figure><p>插入后，我们在两侧的终端中都可以看到已有的数据</p><p><img src="https://img.musnow.top/i/2023/09/319fbe3f23373d34fb0eff4a249ef16b.png" alt="image-20230910163833837"></p><p>随后在两个终端中都开启一个事务，左侧终端插入一个数据，右侧终端查看</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> test_ruc <span class="keyword">values</span> (<span class="number">3</span>,<span class="number">30</span>,<span class="string">&#x27; 左侧终端插入 &#x27;</span>);</span><br></pre></td></tr></table></figure><p>可以看到，两侧的终端都可以看到这份数据</p><p><img src="https://img.musnow.top/i/2023/09/8021cf95d4fa8a29c24771161f17cf52.png" alt="image-20230910164315360"></p><p>此时将左侧终端强制退出（使用 <code>CTRL+\</code>），右侧再次查询，会发现新插入的数据没有了；这里便是事务的<strong> 原子性 </strong> 的体现，左侧的终端所执行的事务没有 <code>commit</code> 就因为异常退出了，MySQL 自动将数据回滚到了这个事务执行之前，即没有插入这份新数据；</p><p><img src="https://img.musnow.top/i/2023/09/db2ea78350e2fe7927f8367f7aecf2db.png" alt="image-20230910164414488"></p><p>左侧重新链接 MySQL，开启一个事务；在右侧插入一个数据，随后创建保存点<code>save1</code>；插入第二个数据，创建保存点<code>save2</code>；</p><p>在左侧查询，我们可以看到右侧插入的两条新数据；</p><p><img src="https://img.musnow.top/i/2023/09/cf012a62e99049bc5b41b66583e7b49a.png" alt="image-20230910165426916"></p><p>在右侧回滚到保存点 save1，会发现插入的数据 2 没有了；这与保存点的预期操作相符合；</p><p><img src="https://img.musnow.top/i/2023/09/99e569e2c4fde9770594fc1176aa52ec.png" alt="image-20230910165719357"></p><p>将右侧终端强制退出，再次查询数据，可以看到第一次插入的数据也没有了，数据又回到了右侧终端事务开始之前的样子。</p><p><img src="https://img.musnow.top/i/2023/09/60cb747da1ac4756bce1c6e6ff12ace0.png" alt="image-20230910171826318"></p><p>这里能得出一个结论：如果终端异常退出，MySQL 会将数据回滚到事务开始时；你可以理解为，我们使用 <code>begin;</code> 的时候就已经创建了一个隐藏的保存点，MySQL 在异常的时候只会将数据回退到这个 <strong> 事务开始之时 </strong> 的隐藏保存点，无论中途用户有没有设置其他保存点！</p><p>即：在异常退出的时候，MySQL 会自动帮我们执行 <code>rollback</code> 命令回退到事务开头！</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">rollback</span>; <span class="comment">-- 回退到事务开头</span></span><br></pre></td></tr></table></figure><p>这样就能避免最开始提到的，转账系统中给 A 扣了钱但是没有给 B 加钱的问题！</p><h3 id="2-2-2- 数据持久化演示"><a href="#2-2-2- 数据持久化演示" class="headerlink" title="2.2.2 数据持久化演示"></a>2.2.2 数据持久化演示 </h3><p> 接着我们再来看看，如果执行了 commit 之后又会是什么情况；</p><p>右侧提交了事务后退出，左侧依旧能查询倒已经提交的数据。代表数据已经被持久化写入到了磁盘（当然这个时候也不一定立刻刷盘了，但是这已经能代表 MySQL 将我们的数据加入到了持久化策略中，并不需要我们管啥时候刷盘的问题！）</p><p><img src="https://img.musnow.top/i/2023/09/e04e7e3b782a176b62e140c1143b1695.png" alt="image-20230910213252764"></p><h3 id="2-2-3- 自动提交"><a href="#2-2-3- 自动提交" class="headerlink" title="2.2.3 自动提交"></a>2.2.3 自动提交 </h3><p> 前面提到了，MySQL 的自动提交默认是开启的；那么这个自动提交有什么作用呢？是不是开启了自动提交，就不需要手动创建事务了？</p><p><strong>并不是 </strong>！在之前的测试中，<code>autocommit</code> 是开启的；我们已经证明了，手动 <code>begin</code> 创建的事务，在没有手动 <code>commit</code> 的时候不会被写入磁盘（不进行持久化）；这代表我们手动创建的事务，不会受到 <code>autocommit</code> 是否开关的影响；（开着的时候都没有自动提交，关闭的时候肯定更不会自动提交了）</p><ul><li>那么这个 <code>autocommit</code> 会影响谁呢？</li></ul><p>开启两个终端，左侧将自动提交关闭，随后插入一个数据；插入后会发现右侧看不到左侧新插入的数据！</p><blockquote><p>备注：<code>set autocommit = 0;</code>语句只会影响当前终端，不会影响另外的终端。</p></blockquote><p><img src="https://img.musnow.top/i/2023/09/05a473c988222c4e9f669040110ce010.png" alt="image-20230911081342217"></p><p>此时手动进行<code>commit</code>，右侧就看得到数据了！</p><p><img src="https://img.musnow.top/i/2023/09/b0c20ecfa43ae1ba23143c78abea5a3d.png" alt="image-20230911081509985"></p><p>而如果我们不手动执行 <code>commit</code> 就把左侧终端 <code>CTRL+\</code> 退出，那么新插入的这一条数据会丢失！</p><h3 id="2-2-4- 单条 SQL 和事务的关系"><a href="#2-2-4- 单条 SQL 和事务的关系" class="headerlink" title="2.2.4 单条 SQL 和事务的关系"></a>2.2.4 单条 SQL 和事务的关系 </h3><p> 欸？我们明明没有 <code>begin</code> 开启事务，为什么可以执行 <code>commit</code> 呢？</p><p>这是因为，在 MySQL 中，每一个不主动使用事务的单条 SQL 语句，都会视作一个事务进行操作！既我们之前没学习事务时，执行的所有单条 SQL 也是一个个各自独立的事务！</p><p>知道了这一点，你就能理解 <strong> 自动提交的作用 </strong> 了：在执行单条 SQL 的时候，是否自动提交该 SQL 语句的事务。</p><p>将 <code>autocommit</code> 重新开启，再进行测试；会发现左侧插入的数据右侧可以立马看到，无需手动<code>commit</code>。这便是自动提交的作用的体现！</p><p><img src="https://img.musnow.top/i/2023/09/2fa8f41ee1644efb200d2fdbe65677ac.png" alt="image-20230911082134863"></p><h2 id="2-3- 结论"><a href="#2-3- 结论" class="headerlink" title="2.3 结论"></a>2.3 结论 </h2><p> 经过上面的这些简单测试，我们可以看到事务的原子性和持久性，做一个总结</p><ul><li>输入了 <code>begin/start transaction</code> 手动创建的事务，必须通过 <code>commit</code> 手动挡提交，才会持久化；这一点和 <code>autocommit</code> 无关！</li><li>事务可以设置保存点和手动回滚，出现异常的时候，MySQL 会自动回退到事务开头；</li><li>对于 <code>InnoDB</code> 存储引擎而言，所有的单条 SQL 语句都会被视作一个事务，自动提交；</li><li><code>select</code>语句会有一些差别，因为 MySQL 有 MVCC 访问控制（后文讲解）</li></ul><p>操作事务的一些注意事项</p><ul><li>只有 <code>InnoDB</code> 才支持事务，<code>MyISAM</code>不支持;</li><li>一个事务被提交了之后，不可以执行<code>rollback</code>;</li><li>创建了保存点后，可以选择回退到哪一个保存点，亦或者是回退到事务开头；</li></ul><h1 id="3- 事务隔离级别"><a href="#3- 事务隔离级别" class="headerlink" title="3. 事务隔离级别"></a>3. 事务隔离级别 </h1><h2 id="3-1- 基本说明"><a href="#3-1- 基本说明" class="headerlink" title="3.1 基本说明"></a>3.1 基本说明</h2><p> 事务的隔离级别和事务的隔离性息息相关</p><ul><li>MySQL 的单个数据库可能被多个进程 &#x2F; 线程同时进行访问和事务操作；</li><li>一个事务是由多个 SQL 语句组成的，任何一个事务，都会存在执行前 &#x2F; 中 &#x2F; 后的阶段。所谓原子性，就是 MySQL 要保证各个客户端要么只能看到事务执行前或者执行后的数据；执行中的事务，对于其他用户来看是原子的，出现异常会被自动回滚；</li><li>但事务毕竟还是存在执行中的概念，其他客户端是有可能看到某个事物执行中的状态的，这就需要隔离性来介入了；</li><li>隔离性：保证事务在执行过程中尽量不受干扰；</li><li>隔离级别：允许事务受不同程度的干扰；</li></ul><p>开头就提到了，MySQL 的事务有 4 种隔离级别</p><ul><li>读未提交（Read Uncommitted）：在这个隔离级别中，所有事务都可以看到其他事物还没有提交的内容（你可以理解为压根没有隔离性，之前的测试使用的就是这个隔离级别）这种情况下就容易引起并发和读取数据的不一致问题，还有 <strong> 脏读 </strong> 问题（对方没有 commit 的数据就叫做脏数据），生产环境中是打死不能用这个隔离级别的！</li><li>读已提交（Read Committed）：在这个隔离级别中，事务只可以看到其他事务已经提交了的内容。这已经满足了隔离的基本定义：只能看到其他事务开始前或者开始后的内容；但是这种隔离模式会产生 <strong> 不可重复读 </strong> 的问题（相同 <code>select</code> 会出现不同结果）；</li><li>可重复读（Repeatable Read）：为了解决不可重复读的问题，这个隔离级别保证了事务在运行过程中多次读取相同数据时会得到相同结果；但是这个隔离级别在某些数据库中可能会出现 <strong> 幻读 </strong> 问题；MySQL 默认采用此隔离级别；</li><li>串行化（Serializable）：所谓串行化，就是 MySQL 给数据库的所有操作都上锁，必须要排队运行。一个事务在运行时，另外一个事务得等它运行完毕了才能进来运行，这样能最大程度保证隔离性；但是会降低效率；</li></ul><p>隔离级别是由 MySQL 进行各种类型的加锁来实现的，比如表锁、行锁、读写锁、间隙锁（GAP）、NEXT-KEY 锁（GAP+ 行锁）等等；</p><blockquote><p>这里还需要验证另外一件事，MySQL 如果开启了串行化，客户端 c&#x2F;cpp 操作还需要加锁吗？<code>mysqlquery</code>的操作是会阻塞还是直接错误退出？</p></blockquote><p>在 MySQL 中，事务的隔离级别可以分别设置全局的隔离级别和当前客户端的隔离级别；如果没有主动设置客户端的隔离级别，则会继承全局的隔离级别。顾名思义，会话隔离级别只会影响当前的会话，不会影响另外的客户端；</p><p>另外，全局的隔离级别会在数据库服务重启后，被重置为配置文件中默认的隔离级别（一般是 RR）</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 设置 会话 / 全局 隔离级别</span></span><br><span class="line"><span class="keyword">set</span> [session <span class="operator">|</span> <span class="keyword">global</span>] transaction isolation level [read uncommitted <span class="operator">|</span> read committed <span class="operator">|</span> repeatable read <span class="operator">|</span> serializable ]</span><br><span class="line"><span class="comment">-- 查看当前会话的隔离级别</span></span><br><span class="line"><span class="keyword">select</span> @<span class="variable">@session</span>.tx_isolation;</span><br><span class="line"><span class="comment">-- 查看全局的隔离级别</span></span><br><span class="line"><span class="keyword">select</span> @<span class="variable">@tx</span>_isolation;</span><br></pre></td></tr></table></figure><h2 id="3-2- 读未提交"><a href="#3-2- 读未提交" class="headerlink" title="3.2 读未提交"></a>3.2 读未提交 </h2><p> 这个隔离级别在第二大点里面就已经测试过了，左侧终端插入的数据，即便没有 commit，在右侧终端中也能看得到，这里就不二次演示了</p><p><img src="https://img.musnow.top/i/2023/09/8021cf95d4fa8a29c24771161f17cf52.png" alt="image-20230910164315360"></p><p>清楚已有的数据，来测试一下会话隔离级别的作用；默认情况下，全局和会话的隔离级别都是 RR；</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">MariaDB [hello_mysql]&gt; select @@tx_isolation;</span><br><span class="line">+-----------------+</span><br><span class="line">| @@tx_isolation  |</span><br><span class="line">+-----------------+</span><br><span class="line">| REPEATABLE-READ |</span><br><span class="line">+-----------------+</span><br><span class="line">1 row in set (0.000 sec)</span><br><span class="line"></span><br><span class="line">MariaDB [hello_mysql]&gt; select @@session.tx_isolation;</span><br><span class="line">+------------------------+</span><br><span class="line">| @@session.tx_isolation |</span><br><span class="line">+------------------------+</span><br><span class="line">| REPEATABLE-READ        |</span><br><span class="line">+------------------------+</span><br><span class="line">1 row in set (0.000 sec)</span><br></pre></td></tr></table></figure><p>将左侧的终端中的会话隔离级别设置为读未提交</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">set</span> session transaction isolation level read uncommitted;</span><br></pre></td></tr></table></figure><p><strong>插入数据之前 </strong>，执行一次<code>select</code> 全列查询，两侧都是空；</p><p>在左侧插入数据后，右侧查看会发现依旧是 <code>empty set</code> 没有结果；只有左侧 <code>commit</code> 之后，右侧才能看到数据；这是因为在之前测试的时候，<strong>我们将自动提交关闭了</strong>；右侧看不到我们还没有提交的事务；</p><p><img src="https://img.musnow.top/i/2023/09/9c76acac8deca528d4226b226146de13.png" alt="image-20230911100829407"></p><p>右侧手动开启事务后，即便没有进行<code>commit</code>，但是左侧因为设置了读未提交，所以可以直接看到右侧还没有提交的事务中的修改。这便是这个隔离级别的特性；</p><p><img src="https://img.musnow.top/i/2023/09/6ba51b47e8c05b4171645e423f1ad6a2.png" alt="image-20230911101100927"></p><h2 id="3-3- 读已提交"><a href="#3-3- 读已提交" class="headerlink" title="3.3 读已提交"></a>3.3 读已提交 </h2><p> 接下来再将全局隔离级别设置为读已提交，重新开启两个终端进行测试；</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set global transaction isolation level read committed;</span><br></pre></td></tr></table></figure><p>设置完毕，重启终端后，可以看到两侧的隔离级别都是读已提交，自动提交都是开启的；</p><p><img src="https://img.musnow.top/i/2023/09/bc6c1464a3c9331191aee2a24f9273e4.png" alt="image-20230911102633596"></p><p>两侧都开启一个事务，左侧插入数据，右侧查看，发现没有内容；</p><p><img src="https://img.musnow.top/i/2023/09/8e60ab3a2b5b4bff70b80ed22bce706b.png" alt="image-20230911103402950"></p><p>左侧 commit 之后，右侧才可以看到这个数据；</p><p><img src="https://img.musnow.top/i/2023/09/9ec9807c381ccebd42a77a741151c422.png" alt="image-20230911103432740"></p><p>这符合我们对 <strong> 读已提交 </strong> 这个隔离级别的字面理解，但是这并不代表这个隔离级别没有问题！</p><h3 id="3-3-1- 出问题的场景"><a href="#3-3-1- 出问题的场景" class="headerlink" title="3.3.1 出问题的场景"></a>3.3.1 出问题的场景 </h3><p> 来看看下面这个场景：</p><ul><li>公司需要根据员工工资，分发不同级别的奖金：<ul><li>2000-4000 级别一</li><li>4001-8000 级别二</li><li>8001-15000 级别三</li></ul></li><li>甲开启了一个客户端，开始用 MySQL 筛选不同工资区间的员工，记录下来；</li><li>乙开启了一个客户端，想要给员工丁加工资<ul><li>丁原本的工资是 3000</li><li>乙给丁加了 2000 工资，丁的工资变成了 5000，跳到了工资级别二；</li><li>乙提交修改（commit）</li></ul></li><li>假设甲已经完成了对 2000-4000 级别工资的员工筛选，此时乙过来给丁加了工资，丁跳到了工资级别二；</li><li>因为隔离级别是读已提交，甲在筛选工资级别二的人员时，会把刚刚被修改过的丁也给纳入进去；</li><li>这时候，对于甲而言，<strong>丁就同时出现在了工资级别一和二的人员中，这明显是不合理的</strong>！</li></ul><p>这个场景被称为 <code> 不可重复读 </code>，即在一个事务中，同一个查询语句，可能会因为其他事务的提交而产生不同的结果；换做 SQL 语句来描述，在读已提交的隔离级别中，同一个 select 语句只能执行一次，第二次执行的时候，可能会获取到和第一次不同的结果，所以这个问题才被称作<code> 不可重复读</code>（不可以重复执行 select）问题；</p><hr><p>来实际演示一下，两侧都开启一个新的事务，左侧终端更新表中的用户 id，只要它不提交，右侧就看不到修改。</p><p><img src="https://img.musnow.top/i/2023/09/8789693271635e5d27c7ad0873937af8.png" alt="image-20230911105147039"></p><p>但是提交了之后，右侧就能看到这个用户 id 的改变，在进行数据筛选的时候，这种情形就会出现问题！</p><p><img src="https://img.musnow.top/i/2023/09/c9f4f3c119361dfcfab135c9e4342921.png" alt="image-20230911105214340"></p><h2 id="3-4- 可重复读"><a href="#3-4- 可重复读" class="headerlink" title="3.4 可重复读"></a>3.4 可重复读 </h2><p> 所以，为了避免上面提到的这个问题，MySQL 还提供了一个可重复读的隔离级别，且默认采用的就是这个隔离级别；</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">set</span> <span class="keyword">global</span> transaction isolation level  repeatable read;</span><br></pre></td></tr></table></figure><p>可重复读就解决了上面提到的问题，即便其他事务提交了修改，当前事务也看不到这份修改，只有当前事务结束后，才能看到最新的数据；</p><p>看下图，两侧都开启一个事务，不管左侧是否有提交事务，右侧都看不到左侧新插入的数据；</p><p><img src="https://img.musnow.top/i/2023/09/c702bd94bb9b4f1b39da177aba23faf0.png" alt="image-20230911150201158"></p><p>只有右侧也提交了自己的事务，才能看到左侧插入的新数据；</p><p><img src="https://img.musnow.top/i/2023/09/8e5ce5e2e310cf65a10b003bb0036e3e.png" alt="image-20230911150323005"></p><p>这就保证了，右侧这个事务在运行的始终，它执行的相同 <code>select</code> 语句的结果永远都是一样的，不会出现不可重复读的问题！</p><p>而如果在 RR 级别中，同时访问相同数据，会出现 <strong> 加锁 </strong> 的情况，下图中，右侧插入了主键为 6 的数据，此时左侧如果也尝试插入一个主键为 6 的数据，会进入阻塞状态；</p><p><img src="https://img.musnow.top/i/2023/09/fa7dbb9ad31fd27e00307f37aac40a4e.png" alt="image-20230911151027879"></p><p>如果很久都不继续操作，就会因为等待超时，跳出等待</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">MariaDB [hello_mysql]&gt; insert into test_ruc values (6,60,&#x27; 天数 &#x27;);</span><br><span class="line">ERROR 1205 (HY000): Lock wait timeout exceeded; try restarting transaction</span><br></pre></td></tr></table></figure><p>但当前事务中插入的数据依旧是存在的，当前事务也没有结束</p><p><img src="https://img.musnow.top/i/2023/09/d8de538b5a89adf04842efd2097239c6.png" alt="image-20230911151335335"></p><p>再次尝试插入这个主键为 6 的数据，依旧会陷入阻塞态，只有右侧的事务被提交了之后，左侧才会出现主键冲突的提示，禁止插入；</p><p><img src="https://img.musnow.top/i/2023/09/be7f7f5c5a63329fbe574ba4ff22d085.png" alt="image-20230911151444595"></p><p>左侧 commit 了之后，右侧才能看到左侧新插入的主键为 5 的数据；</p><p><img src="https://img.musnow.top/i/2023/09/0827a5499036b9e5b024b60f174ec44a.png" alt="image-20230911151710391"></p><h2 id="3-5- 串行化"><a href="#3-5- 串行化" class="headerlink" title="3.5 串行化"></a>3.5 串行化 </h2><p> 这个就比较简单了，一个事务没结束，另外一个就阻塞等待；</p><p>串行化是最高的隔离级别，但其并发性能很低，实际上用的也不多；</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">set</span> <span class="keyword">global</span> transaction isolation level  serializable;</span><br></pre></td></tr></table></figure><p>两侧终端都开始事务，查询的时候是不会加锁的，但是左侧执行 <code>update</code> 的时候，阻塞了（可以通过左侧 update 的执行时间观察到阻塞现象，截图看的不是很明显）；右侧也执行一次<code>update</code>，左侧的 update 就立马成功了，右侧显示报错检测到死锁，建议尝试重启事务；</p><p><img src="https://img.musnow.top/i/2023/09/d75f063fa7959ec6c7926eba70d25e35.png" alt="image-20230911110259760"></p><p>再来试试，两侧都开启事务，左侧尝试插入一个数据，<strong>会阻塞 </strong>；右侧<code>commit</code> 之后，左侧的插入就立马成功了！</p><p><img src="https://img.musnow.top/i/2023/09/8f8ed448629e2b9a842eb819c91f6cea.png" alt="image-20230911110525989"></p><p>这便是串行化的表现：两个事务如果都是在执行 select 的读取操作，则不会被阻塞，但如果有一个事务要执行 <strong> 增删改</strong>，那么就必须等待其他事务都结束了，这个操作才能被执行；</p><h3 id="3-5-1- 串行化的适用场景"><a href="#3-5-1- 串行化的适用场景" class="headerlink" title="3.5.1 串行化的适用场景"></a>3.5.1 串行化的适用场景 </h3><p> 回到 <a href="#jump1">1.1.2 卖票</a> 的场景，在这个场景下，如果你需要保证客户端 A 的卖票逻辑完全执行完毕了，客户端 B 才能过来查询票数，那就需要使用串行化；</p><p>但是，串行化中，我们是可以执行查询操作的！那么在 A 没有结束的情况下，B 不还是会查询到有剩余票数？</p><blockquote><p>实际上，我们的卖票操作并不是直连数据库实现的，而是有一个服务端进程来提供 API，供客户端来查询剩余票数，剩下的卖票操作其实都是服务端来实现的（让客户端直连 MySQL 来执行 SQL 是非常不可靠的，很有可能出现 SQL 注入攻击）</p></blockquote><p>所以，这个问题得在服务端进程中加锁解决！MySQL 本身即便使用串行化也是没有办法解决这个问题的；</p><p>但是，别忘了，MySQL 还有另外一个东西——<strong>约束 </strong>；你可以设置一个触发器，更新剩余票数的时候，拒绝将票数设置为负数；这样客户端 B 即便进入了卖票业务，最终将剩余票数的数据设置为负数的时候，<strong> 也会被 MySQL 阻止插入</strong>，这个卖票的事务 B 就相当于错误退出了，所有操作都会被回滚！而隔离级别就是避免 A 和 B 同时修改一个数据而导致的错误；</p><p>二者相辅相成，就能解决这个问题；当然，在服务端 API 处理逻辑中加锁是更好的解决办法，既可以保证数据一致性，又能隔离客户端和 MySQL 服务；</p><blockquote><p>后文讲到的当前读也能在某种程度上解决这个问题，反正解决的办法多多！</p></blockquote><h3 id="3-5-2- 串行化和 CPP"><a href="#3-5-2- 串行化和 CPP" class="headerlink" title="3.5.2 串行化和 CPP"></a>3.5.2 串行化和 CPP</h3><p>如果将 MySQL 的隔离级别（isolation level）设置为最高级别的串行化（SERIALIZABLE），那么并发的多线程操作可能会遇到以下情况之一：</p><ol><li>阻塞：当一个线程正在使用某个数据时，其他线程需要等待该线程释放锁才能继续进行操作。这会导致其他线程在获得所需锁之前被阻塞。</li><li>错误退出：如果多个线程同时操作相同的数据，并且它们无法同时持有访问该数据的锁，就会引发死锁。在这种情况下，某些线程会被系统终止，从而导致错误退出。</li></ol><p>所以，并不是说你将 MySQL 的隔离级别设置好了，那么客户端就啥事不用干了；最好的操作依旧是在客户端就加锁进行一定的访问控制，因为 MySQL Query 函数的错误退出 + 退出情况识别，相比于客户端进行访问控制更难以操作；</p><h2 id="3-6- 总结"><a href="#3-6- 总结" class="headerlink" title="3.6 总结"></a>3.6 总结</h2><ul><li>隔离级别越高，安全性越高，数据库的并发性能就越低；我们需要根据业务逻辑，选用合适的隔离级别；</li><li>不可重复读的问题在于其他客户端的修改和删除，同样的 select 语句会查出不同的结果，是不合理的；</li><li>幻读的重点在于新增，其他客户端新增的记录可能被我们当前的客户端查询到；但是在 MySQL 中，这个问题是不存在的，因为 <code>InnoDB</code> 通过 NEXT-KEY 锁解决了幻读问题；</li><li>事务也分为长短事务的概念，事务之间互相影响，主要指的是事务在并行阶段（都没有 <code>commit</code> 的时候）产生的影响；</li><li>一般情况下，我们使用 MySQL 默认的 RR 的事务级别就可以了；</li></ul><p>下面给出一个不同事务级别之间的区别的表格，Y 代表会出现这个问题，N 代表不会出现这个问题</p><table><thead><tr><th>隔离级别</th><th>脏读</th><th>不可重复读</th><th>幻读</th><th>加锁读</th></tr></thead><tbody><tr><td>读未提交</td><td>Y</td><td>Y</td><td>Y</td><td>不加锁</td></tr><tr><td>读已提交</td><td>N</td><td>Y</td><td>Y</td><td>不加锁</td></tr><tr><td>可重复读</td><td>N</td><td>N</td><td>N</td><td>不加锁</td></tr><tr><td>串行化</td><td>N</td><td>N</td><td>N</td><td>加锁</td></tr></tbody></table><h2 id="3-7- 一致性"><a href="#3-7- 一致性" class="headerlink" title="3.7 一致性"></a>3.7 一致性</h2><ul><li>事务执行的结果，必须使数据库从一个一致性状态，变到另一个一致性状态。当数据库只包含事务 成功提交的结果时，数据库处于一致性状态。</li><li>如果系统运行发生中断，某个事务尚未完成而被迫中 断，而改未完成的事务对数据库所做的修改已被写入数据库，此时数据库就处于一种不正确（不一致）的状态。因此一致性是通过 <strong> 原子性 </strong> 来保证的。</li><li>其实一致性和用户的业务逻辑强相关，一般 MySQL 提供技术支持，但是一致性还是要用户业务逻辑做支撑（比如客户端如果不使用事务，那 MySQL 也没有办法帮助维护），所以说，一致性是由用户决定是否维护的。 </li><li>技术上，通过 AID 保证 C</li></ul><h1 id="4- 隔离性的理解"><a href="#4- 隔离性的理解" class="headerlink" title="4. 隔离性的理解"></a>4. 隔离性的理解 </h1><p> 说完了隔离级别，接下来再深入理解一下隔离性</p><h2 id="4-1-MVCC"><a href="#4-1-MVCC" class="headerlink" title="4.1 MVCC"></a>4.1 MVCC</h2><p>数据库并发的场景一共有下面三种</p><ul><li><code>读 - 读</code>：不存在任何问题，不需要访问控制</li><li><code>读 - 写</code>：有线程安全问题，可能会遇到隔离性中的脏读、幻读、不可重复读问题；</li><li><code>写 - 写</code>：有线程安全问题，还有可能出现更新丢失问题；</li></ul><p>我们主要关注的是读写并发的情况，这也是数据库最常遇到的处理场景；</p><p>再 MySQL 中，采用了 MVCC（多版本并发控制）来解决读写冲突，这是一种无锁的并发控制机制；</p><p>在了解 MVCC 之前，我们需要了解几个前置知识：</p><ul><li>三个隐藏列字段</li><li>UNDO 日志</li><li>READ VIEW</li></ul><h3 id="4-1-1- 隐藏列字段"><a href="#4-1-1- 隐藏列字段" class="headerlink" title="4.1.1 隐藏列字段"></a>4.1.1 隐藏列字段 </h3><p> 在 MySQL 中，每一个表都存在三个隐藏的列字段</p><ul><li>DB_TRX_ID：6 byte，最近修改 (修改 &#x2F; 插入) 事务 ID，记录创建这条记录 &#x2F; 最后一次修改该记录的事务 ID；</li><li>DB_ROLL_PTR: 7 byte，回滚指针，指向这条记录的上一个版本（简单理解成，指向历史版本就 行，这些数据一般在 <code>undo log</code> 中） </li><li>DB_ROW_ID: 6 byte，隐含的自增 ID（隐藏主键），如果数据表没有主键， InnoDB 会自动以 DB_ROW_ID 产生一个 <strong> 聚簇索引</strong>；</li><li>补充：实际还有一个删除 flag 隐藏字段，既记录被更新或删除并不代表真的删除，而是删除 flag 变了；</li></ul><p>假设有如下表结构</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> if <span class="keyword">not</span> <span class="keyword">exists</span> student(</span><br><span class="line">    name <span class="type">varchar</span>(<span class="number">11</span>) <span class="keyword">not</span> <span class="keyword">null</span>,</span><br><span class="line">    age <span class="type">int</span> <span class="keyword">not</span> <span class="keyword">null</span></span><br><span class="line">);</span><br><span class="line"><span class="comment">-- 插入一条记录</span></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> student (name, age) <span class="keyword">values</span> (<span class="string">&#x27; 张三 &#x27;</span>, <span class="number">19</span>);</span><br></pre></td></tr></table></figure><p>那么这个表中的实际数据是这样的</p><table><thead><tr><th>name</th><th>age</th><th>DB_TRX_ID(创建这个记录的事务 ID)</th><th>DB_ROW_ID（隐藏主键）</th><th>DB_ROLL_PTR（回滚指针）</th></tr></thead><tbody><tr><td>张三</td><td>19</td><td>NULL</td><td>1</td><td>NULL</td></tr></tbody></table><p>我们并不知道创建这个记录的事务 ID，所以设置为 NULL；因为是第一条记录，所以隐藏主键是 1；因为是第一条记录，所以没有回滚的地方，回滚指针也是 NULL（换句话说，如果回滚指针为 NULL，代表这个就是这个表中的第一条记录了）</p><h3 id="4-1-2-undo 日志"><a href="#4-1-2-undo 日志" class="headerlink" title="4.1.2 undo 日志"></a>4.1.2 undo 日志 </h3><p>MySQL 是以服务进程的方式在内存中运行的，我们对数据的 CURD 操作，都需要通过 MySQL 将其刷入到硬盘上进行持久化，MySQL 为这些操作会提供一个专门的<code>buffer pool</code> 内存缓冲区；而 <code>undo log/redo log</code> 也是内存中的一块区域，对于 MySQL 而言</p><ul><li>日志需要立刻刷盘（有一个专门的线程来管理日志）</li><li>数据根据运行策略，选择合适的时间刷盘（因为数据量一般比较大，如果实时刷盘会造成较大 IO 负载，影响进程运行）</li></ul><p>先来说说 <code>redo log</code>，这里包含了 MySQL 中的所有尚未落盘的 CURD 操作；如果 MySQL 还没有写入数据的时候就挂了，那么下次启动的时候就会从<code>redo log</code> 里面恢复数据，来确保数据的一致性和完整性；</p><p>在 MySQL 存储路径 <code>/var/lib/mysql</code> 中的 <code>ib_logfile0/ib_logfile1</code> 就是<code>redo log</code>；</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-rw-rw----. 1 mysql mysql  50331648 Sep 11 03:16 ib_logfile0</span><br><span class="line">-rw-rw----. 1 mysql mysql  50331648 Sep  9 21:03 ib_logfile1</span><br></pre></td></tr></table></figure><p>而 <code>undo log</code> 主要用于以下功能</p><ol><li>回滚事务</li><li>MVCC（多版本控制 &#x2F; 隔离性和隔离级别）</li></ol><p>假设我们来了一个 update 操作，将刚刚插入的张三的年龄改成 30 岁，对于 MySQL 而言就会在 <code>undo log</code> 里面做如下处理；</p><ul><li>该 update 操作对应的事务 <code>DB_TRX_ID</code> 是 10；</li><li>将旧数据放入 <code>undo log</code> 中，并将当前数据的 <code>DB_ROLL_PTR</code> 指向旧数据的地址；</li><li>如果需要回滚，那么就通过 <code>DB_ROLL_PTR</code> 找到旧数据，复写回去；</li></ul><p><img src="https://img.musnow.top/i/2023/09/6f386ba45e0c26e72de76bff973c4a4f.png" alt="image-20230911172501941"></p><p>如果再来一次修改，将张三的名字改成李四，也是依照这个逻辑在 <code>undo log</code> 中新增旧数据，并链接 <code>DB_ROLL_PTR</code> 指针；</p><ul><li>事务 11 修改这条数据，先申请锁；</li><li>将现有数据复制到 <code>undo log</code> 中（头插），并将 <code>DB_ROLL_PTR</code> 指针指向旧数据的地址；</li><li>修改记录中的 name，并且将 <code>DB_TRX_ID</code> 改成当前事务的 ID 11；</li><li>事务 11 提交，释放锁；</li></ul><p><img src="https://img.musnow.top/i/2023/09/d4a9aca8bdd9c3e38daa5b07896e7684.png" alt="image-20230911173024425"></p><p>这样，我们就有了一个类似于链表的历史版本链；每次回退的时候，都可以找到历史数据，覆盖当前的数据。这些版本我们称之为 <code> 快照</code>；</p><p>而插入和删除都可以写入<code>undo log</code>，但是只有更新和删除能形成历史版本链；</p><ul><li>删除是将删除 flag 置为真，旧数据依旧可以写入到 <code>undo log</code> 中，如果需要回滚，将这行记录恢复；</li><li>插入并没有历史版本，但也需要将其放入 <code>undo log</code> 中，事务回滚的时候需要将新插入的数据删除；</li><li>事务提交了之后，已有的历史记录可以被删除；</li></ul><p>增删改都说了，那么 <code>select</code> 呢？</p><p>一般而言，查询不会产生数据写入操作，也不需要设置历史版本链；</p><p>但是在之前关于 RR 级别隔离性的验证中，我们看到了 <code>select</code> 无法看到另外一个事务已经提交了的数据，这说明 <code>select</code> 有时候读取的是 <strong> 历史版本 </strong> 的数据，而并非当前最新的数据！</p><p>读取历史数据我们称之为 <code> 快照读</code>，在 RR 级别中默认采用的就是快照读；读取最新数据叫做当前读（增删改都是当前读）；还有一种读取是为了更新而查询；</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> ... <span class="comment">-- 在 RR 级别下，默认是快照读</span></span><br><span class="line"><span class="keyword">select</span> ... <span class="keyword">for</span> <span class="keyword">update</span>; <span class="comment">-- 为了更新而查询</span></span><br><span class="line"><span class="comment">-- MySQL 会将当前行上排他锁，上锁了之后，其他客户端只能查询该行，无法修改</span></span><br><span class="line"><span class="keyword">select</span> ... lock <span class="keyword">in</span> share mode; <span class="comment">-- 查询最新数据（当前读）</span></span><br><span class="line"><span class="comment">-- 是串行化的，只有其他事务完成了，才能查询到最新结果；</span></span><br></pre></td></tr></table></figure><p>除了手动指定 <code>select</code> 的查询方式以外，隔离级别会影响 <code>select</code> 的默认行为，比如在串行化隔离级别的场景下，默认执行的就是 <strong> 当前读</strong>；</p><p>在 RR 模式下进行测试，会发现当前读会阻塞当前的客户端（右侧客户端阻塞）；</p><p><img src="https://img.musnow.top/i/2023/09/4025f787fda333689872e3295712df1b.png" alt="image-20230911200703608"></p><p>只有左侧的事务在提交了之后，右侧的查询才会返回最新的结果；</p><p><img src="https://img.musnow.top/i/2023/09/1675840504edd0a5689e3a6ec052a4dd.png" alt="image-20230911201033979"></p><p>这是因为 <strong> 当前读 </strong>，包括增删改操作，是需要加锁的；如果要在 RR 模式下实现当前读，那么整个系统就需要<strong> 串行化 </strong> 执行；</p><p>而快照读不需要加锁，因为它可以读取历史版本，而历史版本是不会被其他线程修改的，也就不需要维护访问控制，提高了并发效率；</p><p>那么，MySQL 是如何实现快照读的呢？</p><h3 id="4-1-3-Read-View"><a href="#4-1-3-Read-View" class="headerlink" title="4.1.3 Read View"></a>4.1.3 Read View</h3><p><code>Read View</code>就是 MySQL 为快照读生成的一个 <strong> 读视图 </strong>；在事务执行快照读的时候（即执行<code>select</code> 的时候）将当前数据拍一张照，这样在这个事务中，后续的所有 <code>select</code> 都只会看到这个照片里面的结果，看不到其他事务最新的修改（不管其他事务是否 commit）。</p><blockquote><p>快照读的现象我们已经在本文 <code>3.4 可重复读</code> 中演示过了，这里就不再二次演示了；</p></blockquote><p><code>Read View</code>在 MySQL 的源码中其实就是一个类，该类中包含一些可读性判断的信息，内部有条件，来标明当前事务能够看到那个版本的数据，即有可能是当前最新的数据，也有可能是 <code>undo log</code> 中的某个历史版本；</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ReadView</span> &#123;</span><br><span class="line"><span class="comment">// 省略...</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">/** 高水位，大于等于这个 ID 的事务均不可见 */</span></span><br><span class="line">    <span class="type">trx_id_t</span> m_low_limit_id</span><br><span class="line">    <span class="comment">/** 低水位：小于这个 ID 的事务均可见 */</span></span><br><span class="line">    <span class="type">trx_id_t</span> m_up_limit_id;</span><br><span class="line">    <span class="comment">/** 创建该 Read View 的事务 ID*/</span></span><br><span class="line">    <span class="type">trx_id_t</span> m_creator_trx_id;</span><br><span class="line">    <span class="comment">/** 创建视图时的活跃事务 id 列表，是一个位图 */</span></span><br><span class="line">    <span class="type">ids_t</span> m_ids;</span><br><span class="line">    <span class="comment">/** 配合 purge，标识该视图不需要小于 m_low_limit_no 的 UNDO LOG，</span></span><br><span class="line"><span class="comment">    * 如果其他视图也不需要，则可以删除小于 m_low_limit_no 的 UNDO LOG*/</span></span><br><span class="line">    <span class="type">trx_id_t</span> m_low_limit_no;</span><br><span class="line">    <span class="comment">/** 标记视图是否被关闭 */</span></span><br><span class="line">    <span class="type">bool</span> m_closed;</span><br><span class="line">    <span class="comment">// 省略...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>单独说明一下这里的 4 个重要的变量；其中需要注意，在这里面<strong>up 是低水位，low 是高水位</strong>，这是由他们保存的数据的性质决定的，请不要和这两个单词的本意混淆！</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">m_ids; <span class="comment">// 一张位图，用来保存 Read View 生成时，系统正活跃（没有结束的）的事务 ID</span></span><br><span class="line">up_limit_id; <span class="comment">// 记录 m_ids 列表中事务 ID 最小的 ID </span></span><br><span class="line">low_limit_id; <span class="comment">// ReadView 生成时刻系统尚未分配的下一个事务 ID，也就是目前已出现过的事务 ID 的最大值 +1</span></span><br><span class="line">creator_trx_id <span class="comment">// 创建该 ReadView 的事务 ID</span></span><br></pre></td></tr></table></figure><p>要知道，当前事务是知道自己的事务 ID 的（<code>DB_TRX_ID</code>），那么我们手中就有快照读中最大最小的事务 ID，以及当前活跃中的事务 ID；那么在读取版本链的时候，就进行如下匹配，设当前开启的这个 <strong> 事务为 A</strong>:</p><ul><li>版本链中的事务 ID 不存在于 <code>m_ids</code> 中，代表 <strong> 事务 A 开启 </strong> 的时候，这个事务已经提交了，所以我们可以读取这个事务操作的结果；</li><li>版本链中的事务 ID 存在于 <code>m_ids</code> 中，代表事务 A 开启的时候，这个事务是 <strong> 活跃状态</strong>，那么我就不应该读到这个事务的操作结果；</li><li>版本链的中的事务 ID 大于<code>low_limit_id</code>，代表事务 A 开启的时候，这个事务还不存在，所以也不应该看到这个在 A 之后来的事务的操作结果；（A 还没操作完毕，这个新事务就来了）</li><li>版本链中的事物 ID 小于 <code>up_limit_id</code>，代表事物 A 开启的时候，这个事物都不知道是是它的父亲辈还是爷爷辈了，<strong> 长辈给你留下的东西肯定得好好收着</strong>；说人话：这个是 A 来之前的之前就已经结束了的事物，肯定是可以读取其结果的；</li></ul><p>在 MySQL 中我们可以看到如下源码，链接也贴出来了，github 上可以查看源码；这个函数就是用来判断当前事务应该能看到那些版本链的，具体的判断逻辑参考中文注释（英文注释是官方留的）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这个函数是 ReadView 类的成员函数 ReadView::changes_visible </span></span><br><span class="line"><span class="comment">// 源码链接 https://github.com/mysql/mysql-server/blob/ea1efa9822d81044b726aab20c857d5e1b7e046a/storage/innobase/include/read0types.h#L162  </span></span><br><span class="line"></span><br><span class="line"><span class="comment">// [[nodiscard]] 代表这个函数的返回值不能被忽略，一定需要使用该返回值；否则编译器会爆警告；即告知程序员必须关注这个函数的返回值！</span></span><br><span class="line"><span class="comment">// 函数的返回值是当前事务能否看到某一个事务 id 值的版本链，入参是目标事务 id</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/** Check whether the changes by id are visible.</span></span><br><span class="line"><span class="comment">  @param[in]    id      transaction id to check against the view</span></span><br><span class="line"><span class="comment">  @param[in]    name    table name</span></span><br><span class="line"><span class="comment">  @return whether the view sees the modifications of id. */</span></span><br><span class="line">  [[nodiscard]] <span class="function"><span class="type">bool</span> <span class="title">changes_visible</span><span class="params">(<span class="type">trx_id_t</span> id,</span></span></span><br><span class="line"><span class="params"><span class="function">                                     <span class="type">const</span> <span class="type">table_name_t</span> &amp;name)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">    <span class="built_in">ut_ad</span>(id &gt; <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 小于最小的事务 id 或者等于当前事务 id，则代表这个事务我们可以看到 </span></span><br><span class="line">    <span class="keyword">if</span> (id &lt; m_up_limit_id || id == m_creator_trx_id) &#123;</span><br><span class="line">      <span class="keyword">return</span> (<span class="literal">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">check_trx_id_sanity</span>(id, name);</span><br><span class="line"><span class="comment">// 如果这个 id 比当前事务中的高水位还大，说明这个 id 是后来者，不应该看到</span></span><br><span class="line">    <span class="keyword">if</span> (id &gt;= m_low_limit_id) &#123;</span><br><span class="line">      <span class="keyword">return</span> (<span class="literal">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// 如果当前事务创建时，没有活跃事务</span></span><br><span class="line">    <span class="comment">// 且 m_up_limit_id &lt;= id &lt; m_low_limit_id </span></span><br><span class="line">    <span class="comment">// 那么这个事务 ID 就可以被看到，返回真</span></span><br><span class="line">     <span class="keyword">else</span> <span class="keyword">if</span> (m_ids.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">      <span class="built_in">return</span> (<span class="literal">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">const</span> <span class="type">ids_t</span>::value_type *p = m_ids.<span class="built_in">data</span>();</span><br><span class="line"><span class="comment">// 如果上面都没有匹配到，那就检查这个 id 是否在活跃列表 m_ids 中</span></span><br><span class="line">    <span class="comment">// std::binary_search 的返回值：是否在位图中，true 代表在，false 代表不在</span></span><br><span class="line">    <span class="comment">// 如果在，那么这个事务是活跃状态，不能被看到</span></span><br><span class="line">    <span class="comment">// 如果不在，那么这个事务是已经提交了，可以被看到</span></span><br><span class="line">    <span class="keyword">return</span> (!std::<span class="built_in">binary_search</span>(p, p + m_ids.<span class="built_in">size</span>(), id));</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>如果查到不应该看到当前版本，接下来就是遍历下一个版本，直到符合条件，即可以看到。这便是我们 select 当前读的时候，会自动产生的 <code>ReadView</code> 结构体的作用；</p><p>根据这份源码，我们也能知道 <code>m_ids</code> 位图中，并不需要存放当前事务 ID，因为会有额外的判断来处理当前事务 ID！</p><h2 id="4-2- 快照读实操"><a href="#4-2- 快照读实操" class="headerlink" title="4.2 快照读实操"></a>4.2 快照读实操 </h2><h3 id="4-2-1- 快照是什么时候生成的？"><a href="#4-2-1- 快照是什么时候生成的？" class="headerlink" title="4.2.1 快照是什么时候生成的？"></a>4.2.1 快照是什么时候生成的？</h3><p> 假设当前的事务流程如下，事务 2 能看到事务 1 的操作结果吗？</p><table><thead><tr><th>事务 1</th><th>事务 2</th></tr></thead><tbody><tr><td>事务开始</td><td>事务开始</td></tr><tr><td>插入数据 1 并提交事务</td><td></td></tr><tr><td></td><td>第一次查询</td></tr><tr><td>重开一个新事务，插入数据 2 并提交</td><td></td></tr><tr><td></td><td>第二次查询</td></tr></tbody></table><p>来实操一下，开两个 MySQL 终端，隔离级别设置为 RR；图中黄字标出了每一个 SQL 的执行顺序；我们会发现，当左侧终端提交了第一个插入的数据后，右侧才查询，<strong>是可以看到这条新插入的数据的</strong>！</p><p>而左侧插入的第二条数据右侧就看不到了，很明显，此时访问的就是快照中的旧数据，而不是新数据了；</p><p><img src="https://img.musnow.top/i/2023/09/c8def576b68454081f60029cfa781b5a.png" alt="image-20230912094327001"></p><p>这就告诉我们：快照读的 <strong> 快照 </strong> 是在事务中第一次执行 <code>select</code> 语句的时候生成的！并不是事务开始的时候生成的！</p><p>这也非常合理，如果你的当前事务压根没有进行 <code>select</code> 语句，那我也就没有必要生成快照了，毕竟快照的底层是 <code>ReadView</code> 对象，也是会占用内存空间的！而增删改操作本身就是当前读，无需生成快照！</p><h3 id="4-2-2- 实例解释 ReadView 的成员变量"><a href="#4-2-2- 实例解释 ReadView 的成员变量" class="headerlink" title="4.2.2 实例解释 ReadView 的成员变量"></a>4.2.2 实例解释 ReadView 的成员变量 </h3><p> 用实际例子来解释一下 ReadView 里面的 4 个成员变量到底应该存放什么值；</p><p>假设有下面这个数据</p><table><thead><tr><th>name</th><th>age</th><th>DB_TRX_ID(创建这个记录的事务 ID)</th><th>DB_ROW_ID（隐藏主键）</th><th>DB_ROLL_PTR（回滚指针）</th></tr></thead><tbody><tr><td>张三</td><td>19</td><td>NULL</td><td>1</td><td>NULL</td></tr></tbody></table><p>一共有 4 个事务同时运行，事务序号就是事务 ID</p><table><thead><tr><th>事务 2</th><th>事务 3</th><th>事务 4</th><th>事务 5</th></tr></thead><tbody><tr><td>事务开始</td><td>事务开始</td><td>事务开始</td><td>事务开始</td></tr><tr><td>……</td><td>……</td><td>……</td><td>修改张三的年龄并提交</td></tr><tr><td>运行</td><td>快照读</td><td>运行</td><td>……</td></tr><tr><td>……</td><td>……</td><td>……</td><td>……</td></tr></tbody></table><p>在这种情况下，事务 3 对某行数据进行了快照读，MySQL 就会在这时候生成一个<code>ReadView</code>，内部变量赋值如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">m_ids; <span class="comment">// 2,4 (当前事务 5 已经提交了，所以除了自己就只有 2 和 4 活跃中)</span></span><br><span class="line">up_limit_id; <span class="comment">// 2 (m_ids 中最小事务 ID)</span></span><br><span class="line">low_limit_id; <span class="comment">// 5 + 1 = 6 (当前已经出现的最大事务 ID+1)</span></span><br><span class="line">creator_trx_id <span class="comment">// 3 (当前事务 ID)</span></span><br></pre></td></tr></table></figure><p>当事务 3 进行快照读的时候，就会拿事务 5 的这份数据进行比较，最终得到的结果是，事务 3 的快照是 <strong> 可以 </strong> 看到事务 5 对数据进行的修改的！</p><p>而且对于全局来说，事务 5 提交的这份数据也是当前最新的数据！</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 比较流程（依照上方 MySQL 的源码）</span></span><br><span class="line"><span class="number">5</span> &lt; up_limit_id || <span class="number">5</span> == <span class="number">3</span>; <span class="comment">// 不小于最小的，且也不等于当前的事务 ID 3</span></span><br><span class="line"><span class="number">5</span> &gt; low_limit_id; <span class="comment">// 不大于最大的</span></span><br><span class="line"><span class="comment">// 判断 5 是否在 m_ids 里面</span></span><br><span class="line">m_ids.<span class="built_in">contains</span>(<span class="number">5</span>); <span class="comment">// 不在</span></span><br><span class="line"><span class="comment">// 结论：return true;</span></span><br></pre></td></tr></table></figure><h2 id="4-3- 当前读实操"><a href="#4-3- 当前读实操" class="headerlink" title="4.3 当前读实操"></a>4.3 当前读实操 </h2><p> 快照读的场景基本搞明白了，再来试试当前读（这里小提一嘴，<strong>写 - 写并发 </strong> 可以理解为所有操作都是当前读，需要串行化）</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> ... lock <span class="keyword">in</span> share mode;</span><br></pre></td></tr></table></figure><p>下面是两个不同的操作流程，最终会得到不同的结果；操作之前，先执行如下两个 sql</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">delete</span> <span class="keyword">from</span> test_ruc;</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> test_ruc <span class="keyword">values</span> (<span class="number">1</span>,<span class="number">20</span>,<span class="string">&#x27; 张三 &#x27;</span>);</span><br></pre></td></tr></table></figure><p>在第一次测试中，我们在左侧终端更新数据之前就执行了一次快照读，此时 MySQL 会生成快照，即便在左侧终端的事务 commit 了之后，右侧也无法看到最新的 <code>user_id=18</code> 的数据；<strong>此时使用当前读，就可以读取到最新的数据</strong>！</p><p><img src="https://img.musnow.top/i/2023/09/c7088a7f3657cc02ea436a8bfd30cb88.png" alt="image-20230912103634717"></p><p>而在第二次测试中，我们让左侧终端完成所有操作，右侧终端再去查询，会发现快照读和当前读都能查询到最新的修改；</p><p><img src="https://img.musnow.top/i/2023/09/615e7b7cfb64f9d8f4020469bd669cf3.png" alt="image-20230912103902180"></p><p>由此可见</p><ul><li>快照读的快照是第一次 select 查询的时候生成的</li><li>当前读能绕过快照查看到最新数据！</li></ul><h2 id="4-4-RR 和 RC 的区别"><a href="#4-4-RR 和 RC 的区别" class="headerlink" title="4.4 RR 和 RC 的区别"></a>4.4 RR 和 RC 的区别</h2><ul><li>正是 Read View 生成时机的不同，从而造成 RC,RR 级别下快照读的结果的不同</li><li>在 RR 级别下的某个事务的对某条记录的第一次快照读会创建一个快照及 Read View, 将当前系统活 跃的其他事务记录起来</li><li>此后在调用快照读的时候，还是使用的是同一个 Read View，所以只要当前事务在其他事务提交更新之前使用过快照读，那么之后的快照读使用的都是同一个 Read View，所以对之后的修改不可见；</li><li>即 RR 级别下，快照读生成 Read View 时，Read View 会记录此时所有其他活动事务的快照，这些事务的修改对于当前事务都是不可见的。而早于 Read View 创建的事务所做的修改均是可见；</li><li>而在 RC 级别下的，事务中，每次快照读都会 <strong> 新生成一个快照 </strong> 和 Read View, 这就是我们在 RC 级别下的事务中可以看到别的事务提交的更新的原因；</li><li>总之在 RC 隔离级别下，是每个快照读都会生成并获取最新的 Read View；而在 RR 隔离级别下，则是同一个事务中的第一个快照读才会创建 Read View，之后的快照读获取的都是同一个 Read View。 </li><li>正是 RC 每次快照读，都会形成 Read View，所以，RC 才会有不可重复读问题。</li></ul><h1 id="The-end"><a href="#The-end" class="headerlink" title="The end"></a>The end</h1><p>关于 MySQL 事务的内容到这里基本就 OVER 了，内容多多，也需要多多理解和复习！</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">可以深入阅读如下文章</span><br><span class="line">https://blog.csdn.net/SnailMann/article/details/94724197</span><br><span class="line">https://www.cnblogs.com/f-ck-need-u/archive/2018/05/08/9010872.html</span><br><span class="line">https://blog.csdn.net/chenghan_yang/article/details/97630626</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">事务的学习</summary>
    
    
    
    <category term="学习sql" scheme="https://blog.musnow.top/categories/%E5%AD%A6%E4%B9%A0sql/"/>
    
    
    <category term="Linux" scheme="https://blog.musnow.top/tags/Linux/"/>
    
    <category term="mysql" scheme="https://blog.musnow.top/tags/mysql/"/>
    
  </entry>
  
</feed>
